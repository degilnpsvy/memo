<H3 style="MARGIN: 13pt 0cm"><SPAN lang=EN-US style="FONT-SIZE: 22pt; LINE-HEIGHT: 173%; mso-bidi-font-size: 16.0pt">Process versus kernel views of the system</SPAN></H3>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt">In many everyday programming tasks, we are accustomed to thinking about programming in a process-oriented way. However, when considering various topics covered later in this book, it can be useful to reorient our perspective to consider things from the kernel&#8217;s point of view. To make the contrast clear, we now consider how things look first from a process viewpoint and then from a kernel viewpoint. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt">A running system typically has numerous processes. For a process, many things happen asynchronously. An executing process doesn&#8217;t know when it will next time out, which other processes will then be scheduled for the CPU (and in what order), or when it will next be scheduled. The delivery of signals and the occurrence of interprocess communication events are mediated by the kernel, and can occur at any time for a process. Many things happen transparently for a process. A process doesn&#8217;t know where it is located in RAM or, in general, whether a particular part of its memory space is currently resident in memory or held in the swap area (a reserved area of disk space used to supplement the computer&#8217;s RAM). Similarly, a process doesn&#8217;t know where on the disk drive the files it accesses are being held; it simply refers to the files by name. A process operates in isolation; it can&#8217;t directly communicate with another process. A process can&#8217;t itself create a new process or even end its own existence. Finally, a process can&#8217;t communicate directly with the input and output devices attached to the computer. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt">By contrast, a running system has one kernel that knows and controls everything. The kernel facilitates the running of all processes on the system. The kernel decides which process will next obtain access to the CPU, when it will do so, and for how long. The kernel maintains data structures containing information about all running processes and updates these structures as processes are created, change state, and terminate. The kernel maintains all of the low-level data structures that enable the filenames used by programs to be translated into physical locations on the disk. The kernel also maintains data structures that map the virtual memory of each process into the physical memory of the computer and the swap area(s) on disk. All communication between processes is done via mechanisms provided by the kernel. In response to requests from processes, the kernel creates new processes and terminates existing processes. Lastly, the kernel (in particular, device drivers) performs all direct communication with input and output devices, transferring information to and from user processes as required.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt">Later in this book we&#8217;ll say things such as &#8220;a process can create another process,&#8221; &#8220;a process can create a pipe,&#8221; &#8220;a process can write data to a file,&#8221; and &#8220;a process can terminate by calling exit().&#8221; Remember, however, that the kernel mediates all such actions, and these statements are just shorthand for &#8220;a process can request that the kernel create another process,&#8221; and so on.</SPAN>