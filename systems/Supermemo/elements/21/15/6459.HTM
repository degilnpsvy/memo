<H2 style="MARGIN: 13pt 0cm"><SPAN lang=EN-US style="FONT-SIZE: 22pt; LINE-HEIGHT: 173%; mso-bidi-font-size: 16.0pt"><FONT face=Arial>2.5 File I/O Model</FONT></SPAN></H2>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt">One of the distinguishing features of the I/O model on UNIX systems is the concept of universality of I/O. This means that the same system calls (open(), read(), write(), close(), and so on) are used to perform I/O on all types of files, including devices. (The kernel translates the application&#8217;s I/O requests into appropriate file-system or device-driver operations that perform I/O on the target file or device.)</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt">Thus, a program employing these system calls will work on any type of file.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt">The kernel essentially provides one file type: a sequential stream of bytes, which, in the case of disk files, disks, and tape devices, can be randomly accessed using the lseek()system call.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt">Many applications and libraries interpret the newline character (ASCII code 10 decimal, sometimes also known as linefeed) as terminating one line of text and commencing another. UNIX systems have no end-of-file character; the end of a file is detected by a read that returns no data.</SPAN>