<B><SPAN lang=EN-US style="FONT-SIZE: 16pt; FONT-FAMILY: Arial; mso-font-kerning: 0pt">Basic Linker Script Concepts</SPAN></B> 
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">The following documentation discusses some basic concepts and vocabulary in order to describe the linker script language.</SPAN></P>
<P><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">The linker always uses a linker script. If you do not supply one yourself, the linker will use a default script that compiles into the linker executable. You can use the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; FONT-FAMILY: Courier; mso-font-kerning: 0pt; mso-bidi-font-family: Courier">--verbose </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">command line option to display the default linker script. Certain command line options, such as </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; FONT-FAMILY: Courier; mso-font-kerning: 0pt; mso-bidi-font-family: Courier">-r </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">or </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; FONT-FAMILY: Courier; mso-font-kerning: 0pt; mso-bidi-font-family: Courier">-N</SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">, will affect the default linker script.</SPAN></FONT></P>
<P><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">You may supply your own linker script by using the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; FONT-FAMILY: Courier; mso-font-kerning: 0pt; mso-bidi-font-family: Courier">-T </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">command line option. When you do this, your linker script will replace the default linker script.</SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt"><FONT class=extract>You may also use linker scripts implicitly by naming them as input files to the linker, as though they were files to be linked. See &#8220;Implicit Linker Scripts&#8221; on page 61.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">The linker combines input files into a single output file. The output file and each input file are in a special data format known as an <I>object file format</I>. Each file is called an <I>object file</I>. The output file is often called an <I>executable</I>, but for our purposes it is also called an object file. Each object file has, among other things, a list of <I>sections</I>. A section in an input file is sometimes referred to as an <I>input section</I>; similarly, a section in the output file is an <I>output section</I>.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt"><FONT class=extract>Each section in an object file has a name and a size. Most sections also have an associated block of data, known as the <I>section contents</I>. A section may be marked as <I>loadable</I>, meaning that the contents should be loaded into memory when the output file is run. A section with no contents may be <I>allocatable</I>, which means that an area in memory should be set aside, but nothing in particular should be loaded there (in some cases this memory must be zeroed out). A section, which is neither loadable nor allocatable, typically contains some sort of debugging information.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt"><FONT class=extract>Every loadable or allocatable output section has two addresses. The first is the <I>VMA</I>, or <I>virtual memory address</I>. This is the address the section will have when the output file is run. The second is the <I>LMA</I>, or <I>load memory address</I>. This is the address at which the section will be loaded. In most cases the two addresses will be the same. An example of when they might be different is when a data section is loaded into ROM, and then copied into RAM when the program starts up (this technique is often used to initialize global variables in a ROM based system). In this case the ROM address would be the LMA, and the RAM address would be the VMA.</FONT> </SPAN>
<P><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">You can see the sections in an object file by using the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; FONT-FAMILY: Courier; mso-font-kerning: 0pt; mso-bidi-font-family: Courier">objdump </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">program with the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; FONT-FAMILY: Courier; mso-font-kerning: 0pt; mso-bidi-font-family: Courier">-h </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">option. Every object file also has a list of <I>symbols</I>, known as the <I>symbol table</I>. A symbol may be defined or undefined. Each symbol has a name, and each defined symbol has an address, among other information. If you compile a C or C++ program into an object file, you will get a defined symbol for every defined function and global or static variable. Every undefined function or global variable, which is referenced in the input file, will become an undefined symbol. You can see the symbols in an object file by using the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; FONT-FAMILY: Courier; mso-font-kerning: 0pt; mso-bidi-font-family: Courier">nm </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">program, or by using the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; FONT-FAMILY: Courier; mso-font-kerning: 0pt; mso-bidi-font-family: Courier">objdump </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">program with the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; FONT-FAMILY: Courier; mso-font-kerning: 0pt; mso-bidi-font-family: Courier">-t </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-font-kerning: 0pt">option.</SPAN></FONT>