A Note on Git&#8217;s Use of SHA1 
<P></P>
<P><FONT class=extract>Before peering at the contents of the tree object in more detail, let&#8217;s check out an important feature of SHA1 hashes: </FONT></P>
<P><FONT class=extract>$ git write-tree </FONT></P>
<P><FONT class=extract>68aba62e560c0ebc3396e8ae9335232cd93a3f60 </FONT></P>
<P><FONT class=extract>$ git write-tree </FONT></P>
<P><FONT class=extract>68aba62e560c0ebc3396e8ae9335232cd93a3f60 </FONT></P>
<P><FONT class=extract>$ git write-tree </FONT></P>
<P><FONT class=extract>68aba62e560c0ebc3396e8ae9335232cd93a3f60</FONT></P>
<P><FONT class=extract>Every time you compute another tree object for the same index, the SHA1 hash remains exactly the same.</FONT> Git doesn&#8217;t need to recreate a new tree object. If you&#8217;re following these steps at the computer, you should be seeing exactly the same SHA1 hashes as the ones published in this book.</P>
<P>In this sense, the hash function is a true function in the mathematical sense: For a given input, it always produces the same output. Such a hash function is sometimes called a digest to emphasize that it serves as a sort of summary of the hashed object. Of course, any hash function, even the lowly parity bit, has this property.</P>
<P>That&#8217;s extremely important. For example, if you create the exact same content as another developer, regardless of where or when or how both of you work, an identical hash is proof enough that the full content is identical, too. In fact, Git treats them as identical. </P>
<P>But hold on a second&#8212;aren&#8217;t SHA1 hashes unique? What happened to the trillions of people with trillions of blobs per second who never produce a single collision? This is a common source of confusion among new Git users. So read on carefully, because if you can understand this distinction, then everything else in this chapter is easy. Identical SHA1 hashes in this case do not count as a collision. It would be a collision only if two different objects produced the same hash. Here, you created two separate instances of the very same content, and the same content always has the same hash. Git depends on another consequence of the SHA1 hash function: it doesn&#8217;t matter how you got a tree called 68aba62e560c0ebc3396e8ae9335232cd93a3f60. If you have it, you can be extremely confident it is the same tree object that, say, another reader of this book has. Bob might have created the tree by combining commits A and B from Jennie and commit C from Sergey, whereas you got commit A from Sue and an update from Lakshmi that combines commits B and C. The results are the same, and this facilitates distributed development.</P>
<P><FONT class=extract>If you are asked to look for object 68aba62e560c0ebc3396e8ae9335232cd93a3f60 and can find such an object, then, because SHA1 is a cryptographic hash, you can be confident that you are looking at precisely the same data from which the hash was created. The converse is also true: If you don&#8217;t find an object with a specific hash in your object store, then you can be confident that you do not hold a copy of that exact object. In sum, you can determine whether your object store does or does not have a particular object even though you know nothing about its (potentially very large) contents. The hash thus serves as a reliable label or name for the object.</FONT></P>
<P><FONT class=extract>But Git also relies on something stronger than that conclusion, too. Consider the most recent commit (or its associated tree object). Because it contains, as part of its content, the hash of its parent commits and of its tree and that in turn contains the hash of all of its subtrees and blobs recursively through the whole data structure, it follows by induction that the hash of the original commit uniquely identifies the state of the whole data structure rooted at that commit.</FONT></P>
<P><FONT class=extract>Finally, the implications of our claim in the previous paragraph lead to a powerful use of the hash function: It provides an efficient way of comparing two objects, even two very large and complex data structures,( 2. This data structure is covered in more detail in &#8220;Commit Graphs&#8221; on page 74 of Chapter 6. ) without transmitting either in full.</FONT>