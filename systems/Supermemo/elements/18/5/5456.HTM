Objects, Hashes, and Blobs 
<P></P>
<P>When it creates an object for hello.txt, Git doesn&#8217;t care that the filename is hello.txt. Git cares only about what&#8217;s inside the file: the sequence of 12 bytes that represent &#8220;hello world&#8221; and the terminating newline (the same blob created earlier). Git performs a few operations on this blob, calculates its SHA1 hash, and enters it into the object store as a file named after the hexadecimal representation of the hash. </P>
<P><FONT class=extract>The hash in this case is 3b18e512dba79e4c8300dd08aeb37f8e728b8dad. The 160 bits of an SHA1 hash correspond to 20 bytes, which takes 40 bytes of hexadecimal to display, so the content is stored as .git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad. Git inserts a / after the first two digits to improve filesystem efficiency. (Some filesystems slow down if you put too many files in the same directory; making the first byte of the SHA1 into a directory is an easy way to create a fixed, 256-way partitioning of the namespace for all possible objects with an even distribution.) </FONT></P>
<P><FONT class=extract>To show that Git really hasn&#8217;t done very much with the content in the file (it&#8217;s still the same comforting &#8220;hello world&#8221;), you can use the hash to pull it back out of the object store any time you want: </FONT></P>
<P><FONT class=extract>$ git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad</FONT></P>
<P><FONT class=extract>hello world</FONT></P>
<P><FONT class=extract>Git also knows that 40 characters is a bit chancy to type by hand, so it provides a command to look up objects by a unique prefix of the object hash:</FONT></P>
<P><FONT class=extract>$ git rev-parse 3b18e512d </FONT></P>
<P><FONT class=extract>3b18e512dba79e4c8300dd08aeb37f8e728b8dad<SPAN lang=EN-US style="FONT-SIZE: 10pt; FONT-FAMILY: Birka; mso-bidi-font-family: Birka; mso-font-kerning: 0pt"></P></SPAN></FONT>