<HEAD></HEAD>
<BODY>
<P>Merges and Git&#8217;s Object Model </P>
<P>In most VCSs, each commit has only one parent. On such a system, when you merge some_branch into my_branch, you create a new commit on my_branch with the changes from some_branch. Conversely, if you merge my_branch into some_branch then this creates a new commit on some_branch containing the changes from my_branch. Merging branch A into branch B and merging branch B into branch A are two different operations. </P>
<P>However, the Git designers noticed that each of these two operations results in the same set of files when you&#8217;re done. The natural way to express either operation is simply to say, &#8220;Merge all the changes from some_branch and another_branch into a single branch.&#8221;</P>
<P>In Git, the merge yields a new tree object with the merged files, but it also introduces a new commit object on only the target branch. After these commands: </P>
<P>$ git checkout my_branch </P>
<P>$ git merge some_branch</P>
<P>the object model looks like Figure9-10. </P>
<P>&nbsp;</P>
<P>Figure 9-10. Object model after a merge</P>
<P>In Figure 9-10, each Cx is a commit object and each Tx represents the corresponding tree object. Notice how there is one common merged commit (CZC) that has both CC and CZ as commit parents, but it has only one resulting set of files represented in the TZC tree. The merged tree object symmetrically represents both source branches equally. But because my_branch was the checked out branch into which the merge happened, only my_branch has been updated to show the new commit on it; some_branch remains where it was.</P>
<P>This is not just a matter of semantics. It reflects Git&#8217;s underlying philosophy that all branches are created equal.( 3. And, by extension, so are all complete repository clones. )</P></BODY>