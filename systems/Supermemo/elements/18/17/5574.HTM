Applying Merge Strategies </P>
<P>So how does Git know or determine which strategy to use? Or, if you don&#8217;t like Git&#8217;s choice, how do you specify a different one? </P>
<P>Git tries to keep the algorithms it uses as simple and inexpensive as possible, so it first tries using the already up-to-date and fast-forward to eliminate the trivial, easy scenarios if possible.</P>
<P>If you specify more than one other branch to be merged into your current branch, Git has no choice but trying the octopus strategy because that is the only one capable of joining more than two branches in a single merge.</P>
<P>Failing those special cases, Git must use a default strategy that works reliably in all other scenarios. Originally, resolve was the default merge strategy used by Git. In criss-cross merge situations such as those described previously, where there is more than one possible merge basis, the resolve strategy works like this: pick one of the possible merge bases (either the last merge from Bob&#8217;s branch or the last merge from Cal&#8217;s branch) and hope for the best. This is actually not as bad as it sounds. It often turns out that Alice, Bob, and Cal have all been working on different parts of the code. In that case, Git detects that it&#8217;s remerging some changes that are already in place and just skips duplicate changes, avoiding the conflict. Or, if there are slight changes that do cause a conflict, at least the conflicts should be fairly easy for a developer to handle. Because resolve is no longer Git&#8217;s default, if Alice wanted to use it then she would make an explicit request:</P>
<P>$ git merge -s resolveBob</P>
<P>In 2005, Fredrik Kuivinen contributed the new recursive merge strategy, which has since become the default. It is more general than resolve and has been shown to result in fewer conflicts, without fault, on the Linux kernel. It also handles merges with renames quite well.</P>
<P>In the previous example, where Alice wants to merge all of Bob&#8217;s work, the recursive strategy would work likethis:</P>
<P>1. Start with the most recent revision from Cal that both Alice and Bob have. In this case, that&#8217;s Cal&#8217;s most recent revision, Q, which has been merged into both Bob&#8217;s and Alice&#8217;s branches.</P>
<P>2. Calculate the diff between that revision and the most recent revision that Alice merged from Bob, and patch thatin.</P>
<P>3. Calculate the diff between that combined version and Bob&#8217;s latest version, and patch that in.</P>
<P>This method is called &#8220;recursive&#8221; because there may be extra iterations, depending on how many levels of criss-crossing and merge bases Git encounters. And it works. Not only does the recursive method make intuitive sense, it has also been proven to result in fewer conflicts in real-life situations than the simpler resolve strategy. That&#8217;s why recursive is now the default strategy for git merge.</P>
<P>Of course, no matter which strategy Alice chooses to use, the final history looks the same (Figure 9-9).