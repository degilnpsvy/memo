Git Tracks Content 
<P></P>
<P>It&#8217;s important to see Git as something more than a VCS: Git is a content tracking system. This distinction, however subtle, guides much of the design of Git and is perhaps the key reason it can perform internal data manipulations with relative ease. Yet, this is also perhaps one of the most difficult concepts for new users of Git to grasp, so some exposition is worthwhile. </P>
<P>Git&#8217;s content tracking is manifested in two critical ways that differ fundamentally from almost all other(1. Monotone, Mercurial, OpenCMS, and Venti are notable exceptions here. ) revision control systems.</P>
<P>First, <FONT class=extract>Git&#8217;s object store is based on the hashed computation of the contents of its objects, not on the file or directory names from the user&#8217;s original file layout. Thus, when Git places a file into the object store, it does so based on the hash of the data and not on the name of the file. In fact, Git does not track file or directory names, which are associated with files in secondary ways. Again, Git tracks content instead of files. If two separate files have exactly the same content, whether in the same or different directories, Git stores a single copy of that content as a blob within the object store. Git computes the hash code of each file according solely to its content, determines that the files have the same SHA1 values and thus the same content, and places the blob object in the object store indexed by that SHA1 value. Both files in the project, regardless of where they are located in the user&#8217;s directory structure, use that same object for content.</FONT></P>
<P>If one of those files changes, Git computes a new SHA1 for it, determines that it is now a different blob object, and adds the new blob to the object store. The original blob remains in the object store for the unchanged file to use.</P>
<P>Second, <FONT class=extract>Git&#8217;s internal database efficiently stores every version of every file&#8212;not their differences&#8212;as files go from one revision to the next. Because Git uses the hash of a file&#8217;s complete content as the name for that file, it must operate on each complete copy of the file. It cannot base its work or its object store entries on only part of the file&#8217;s content nor on the differences between two revisions of that file.</FONT></P>
<P>The typical user view of a file&#8212;that it has revisions and appears to progress from one revision to another revision&#8212;is simply an artifact. Git computes this history as a set of changes between different blobs with varying hashes, rather than storing a file name and set of differences directly. It may seem odd, but this feature allows Git to perform certain tasks with ease.