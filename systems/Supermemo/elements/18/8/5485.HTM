Atomic Changesets 
<P></P>
<P>Every Git commit represents a single, atomic changeset with respect to the previous state. Regardless of the number of directories, files, lines, or bytes that change with a commit,( 1. <FONT class=extract>Git also records a mode flag indicating the executability of each file. Changes in this flag are also part of a changeset. ) either all changes apply or none do.</FONT> </P>
<P>In terms of the underlying object model, atomicity just makes sense: A commit snapshot represents the total set of modified files and directories. It must represent one tree state or the other, and a changeset between two state snapshots represents a complete tree-to-tree transformation. (You can read about derived differences between commits in Chapter 8.)</P>
<P><FONT class=extract>Consider the workflow of moving a function from one file to another. If you perform the removal with one commit and then follow with a second commit to add it back, there remains a small &#8220;semantic gap&#8221; in the history of your repository during which time the function is gone. Two commits in the other order is problematic, too. In either case, before the first commit and after the second your code is semantically consistent, but after the first commit, the code is faulty.</FONT></P>
<P><FONT class=extract>However, with an atomic commit that simultaneously deletes and adds the function, no such semantic gap appears in the history. You can learn how best to construct and organize your commits in Chapter 10.</FONT></P>
<P>Git doesn&#8217;t care why files are changing. That is, the content of the changes doesn&#8217;t matter. As the developer, you might move a function from here to there and expect this to be handled as one unitary move. But you could, alternatively, commit the removal and then later commit the addition. Git doesn&#8217;t care. It has nothing to do with the semantics of what is in the files.</P>
<P>But this does bring up one of the key reasons why Git implements atomicity: It allows you to structure your commits more appropriately by following some best practice advice.</P>
<P>Ultimately, you can rest assured that Git has not left your repository in some transitory state between one commit snapshot and the next.