CHAPTER 6 Commits 
<P></P>
<P>In Git, a commit is used to record changes to a repository. </P>
<P>At face value, a Git commit seems no different from a commit or check in found in other VCS. Under the hood, however, a Git commit operates in a unique way. When a commit occurs, Git records a snapshot of the index and places that snapshot in the object store. (Preparing the index for a commit is covered in Chapter 5.) This snapshot does not contain a copy of every file and directory in the index, because such a strategy would require enormous and prohibitive amounts of storage. Instead, Git compares the current state of the index to the previous snapshot and so derives a list of affected files and directories. Git creates new blobs for any file that has changed and new trees for any directory that has changed, and it reuses any blob or tree object that has not changed. </P>
<P>Commit snapshots are chained together, with each new snapshot pointing to its predecessor. Over time, a sequences of changes is represented as a series of commits. It may seem expensive to compare the entire index to some prior state, yet the whole process is remarkably fast because every Git object has an SHA1 hash. If two objects, even two subtrees, have the same SHA1 hash, the objects are identical. <FONT class=extract>Git can avoid swaths of recursive comparisons by pruning subtrees that have the same content.</FONT> <FONT class=extract>There is a one-to-one correspondence between a set of changes in the repository and a commit: A commit is the only method of introducing changes to a repository, and any change in the repository must be introduced by a commit. This mandate provides accountability. Under no circumstance should repository data change without a record of the change!</FONT> Just imagine the chaos if, somehow, content in the master repository changed and there was no record of how it happened, who did it, or why.</P>
<P><FONT class=extract>Although commits are most often introduced explicitly by a developer, Git itself can introduce commits. As you&#8217;ll see in Chapter 9, a merge operation causes a commit in the repository in addition to any commits made by users before the merge.</FONT> </P>
<P>How you decide when to commit is pretty much up to you and your preferences or development style. In general, you should perform a commit at well-defined points in time when your development is at a quiescent stage, such as when a test suite passes, when everyone goes home for the day, or any number of other reasons.</P>
<P>However, don&#8217;t hesitate to introduce commits! Git is well suited to frequent commits and provides a rich set of commands for manipulating them. Later, you&#8217;ll see how several commits&#8212;each with small, well-defined changes&#8212;can also lead to better organization of changes and easier manipulation of patch sets.