Identifying Commits 
<P></P>
<P>Whether you code individually or with a team, identifying individual commits is an essential task. For example, to create a branch, you must choose a commit from which to diverge; to compare code variations, you must specify two commits; and to edit the commit history, you must provide a collection of commits. In Git, you can refer to every commit via an explicit or an implied reference. </P>
<P><FONT class=extract>You&#8217;ve already seen explicit references and a few implied references. The unique, 40- hexadecimal-digit SHA1 commit ID is an explicit reference, whereas HEAD, which always points to the most recent commit, is an implied reference.</FONT> At times, though, neither reference is convenient. Fortunately, Git provides many different mechanisms for naming a commit, each with advantages and some more useful than others, depending on the context.</P>
<P>For example, when discussing a particular commit with a colleague working on the same data but in a distributed environment, it&#8217;s best to use a commit name guaranteed to be the same in both repositories. On the other hand, if you&#8217;re working within your own repository and need to refer to the state a few commits back on a branch, a simple relative name works perfectly.