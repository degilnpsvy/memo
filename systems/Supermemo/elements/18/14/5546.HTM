Comparing How Subversion and Git Derive diffs </P>
<P>Most systems, such as CVS or SVN, track a series of revisions and store just the changes between each pair of files. This technique is meant to save storage space and overhead. Internally, such systems spend a lot of time thinking about things like &#8220;the series of changes between A and B.&#8221; When you update your files from the central repository, for example, SVN remembers that the last time you updated the file you were at revision r1095, but now the repository is at revision r1123. Thus, the server must send you the diff between r1095 and r1123. Once your SVN client has these diffs, it can incorporate them into your working copy and produce r1123. (That&#8217;s how SVN avoids sending you all the contents of all files every time you update.) </P>
<P>To save disk space, SVN also stores its own repository as a series of diffs on the server. When you ask for the diffs between r1095 and r1123, it looks up all the individual diffs for each version between those two versions, merges them together into one large diff, and sends you the result. But Git doesn&#8217;t work like that.</P>
<P>In Git, as you&#8217;ve seen, each commit contains a tree, which is a list of files contained by that commit. Each tree is independent of all other trees. Git users still talk about diffs and patches, of course, because these are still extremely useful. Yet, in Git, a diff and a patch are derived data, not the fundamental data they are in CVS or SVN. If you look in the .git directory, you won&#8217;t find a single diff; if you look in a SVN repository, it consists mostly of diffs.</P>
<P>Just as SVN is able to derive the complete set of differences between r1095 and r1123, Git can retrieve and derive the differences between any two arbitrary states. But SVN must look at each version between r1095 and r1123, whereas Git doesn&#8217;t care about the intermediate steps.</P>
<P>Each revision has its own tree, but Git doesn&#8217;t require those to generate the diff; Git can operate directly on snapshots of the complete state at each of the two versions. This simple difference in storage systems is one of the most important reasons that Git is so much faster than other RCSs.