<FONT class=extract>Using git rm </FONT>
<P></P>
<P><FONT class=extract>The command git rm is, naturally the inverse of git add. It removes a file from both the repository and the working directory. However, because removing a file tends to be more problematic (if something goes wrong) than adding a file, Git treats the removal of a file with a bit more care. </FONT></P>
<P><FONT class=extract>Git will remove a file only from the index or from the index and working directory simultaneously. Git will not remove a file just from the working directory; the regular rm command may be used for that purpose.</FONT></P>
<P><FONT class=extract>Removing a file from your directory and the index does not remove the file&#8217;s existing history from the repository. Any versions of the file that are part of its history already committed in the repository remain in the object store and retain that history. Continuing the example, let&#8217;s introduce an &#8220;accidental&#8221; additional file that shouldn&#8217;t be staged and see how to remove it.</FONT></P>
<P><FONT class=extract>$ echo "Random stuff" &gt; oops </FONT></P>
<P><FONT class=extract># Can't "git rm" files Git considers "other" </FONT></P>
<P><FONT class=extract># This should be just "rm oops"</FONT></P>
<P><FONT class=extract>$ git rm oops </FONT></P>
<P><FONT class=extract>fatal: pathspec 'oops' did not match any files </FONT></P>
<P><FONT class=extract>Because git rm is also an operation on the index, the command won&#8217;t work on a file that hasn&#8217;t been previously added to the repository or index; Git must first be aware of a file.</FONT> <FONT class=extract>So let&#8217;s accidentally stage the oops file: </FONT></P>
<P><FONT class=extract># Accidentally stage "oops" file </FONT></P>
<P><FONT class=extract>$ git add oops </FONT></P>
<P><FONT class=extract>$ git status </FONT></P>
<P><FONT class=extract># On branch master </FONT></P>
<P><FONT class=extract># </FONT></P>
<P><FONT class=extract># Initial commit </FONT></P>
<P><FONT class=extract># </FONT></P>
<P><FONT class=extract># Changes to be committed: </FONT></P>
<P><FONT class=extract># (use "git rm --cached <FILE>..." to unstage) </FONT></P>
<P><FONT class=extract># </FONT></P>
<P><FONT class=extract># new file: .gitignore </FONT></P>
<P><FONT class=extract># new file: data </FONT></P>
<P><FONT class=extract># new file: oops </FONT></P>
<P><FONT class=extract>#</FONT></P>
<P><FONT class=extract>To convert a file from staged to unstaged, use git rm --cached: </FONT></P>
<P><FONT class=extract>$ git ls-files --stage </FONT></P>
<P><FONT class=extract>100644 0487f44090ad950f61955271cf0a2d6c6a83ad9a 0 .gitignore </FONT></P>
<P><FONT class=extract>100644 e476983f39f6e4f453f0fe4a859410f63b58b500 0 data </FONT></P>
<P><FONT class=extract>100644 fcd87b055f261557434fa9956e6ce29433a5cd1c 0 oops</FONT></P>
<P><FONT class=extract>$ git rm --cached oops </FONT></P>
<P><FONT class=extract>rm 'oops' </FONT></P>
<P><FONT class=extract>$ git ls-files --stage </FONT></P>
<P><FONT class=extract>100644 0487f44090ad950f61955271cf0a2d6c6a83ad9a 0 .gitignore </FONT></P>
<P><FONT class=extract>100644 e476983f39f6e4f453f0fe4a859410f63b58b500 0 data</FONT></P>
<P><FONT class=extract>Whereas git rm --cached removes the file from the index and leaves it in the working directory, git rm removes the file from both the index and the working directory.</FONT> </P>
<P><FONT class=extract>Using git rm --cached to make a file untracked while leaving a copy in the working directory is dangerous, because you may forget that it is no longer being tracked. Using this approach also overrides Git&#8217;s check that the working file&#8217;s contents are current. Be careful.</FONT></P>
<P><FONT class=extract>If you want to remove a file once it&#8217;s been committed, just stage the request through a simple git rm filename:</FONT></P>
<P><FONT class=extract>$ git commit -m "Add some files"</FONT></P>
<P><FONT class=extract>Created initial commit 5b22108: Add some files </FONT></P>
<P><FONT class=extract>2 files changed, 3 insertions(+), 0 deletions(-)</FONT></P>
<P><FONT class=extract>create mode 100644 .gitignore </FONT></P>
<P><FONT class=extract>create mode 100644 data</FONT></P>
<P><FONT class=extract>$ git rm data </FONT></P>
<P><FONT class=extract>rm 'data'</FONT></P>
<P><FONT class=extract>$ git status </FONT></P>
<P><FONT class=extract># On branch master </FONT></P>
<P><FONT class=extract># Changes to be committed: </FONT></P>
<P><FONT class=extract># (use "git reset HEAD <FILE>..." to unstage) </FONT></P>
<P><FONT class=extract># </FONT></P>
<P><FONT class=extract># deleted: data </FONT></P>
<P><FONT class=extract>#</FONT></P>
<P><FONT class=extract>Before Git removes a file, it checks to make sure the version of the file in the working directory matches the latest version in the current branch (the version that Git commands call the HEAD). This verification precludes the accidental loss of any changes (due to your editing) that may have been made to the file. </FONT></P>
<P><FONT class=extract>Use git rm -f to force the removal of your file. Force is an explicit mandate and removes the file even if you have altered it since your last commit.</FONT></P>
<P><FONT class=extract>And in case you really meant to keep a file that you accidentally removed, simply add it back:</FONT></P>
<P><FONT class=extract>$ git add data </FONT></P>
<P><FONT class=extract>fatal: pathspec 'data' did not match any files</FONT></P>
<P><FONT class=extract>Darn! Git removed the working copy, too! But don&#8217;t worry. VCSs are good at recovering old versions of files:</FONT></P>
<P><FONT class=extract>$ git checkout HEAD -- data </FONT></P>
<P><FONT class=extract>$ cat data </FONT></P>
<P><FONT class=extract>New data</FONT></P>
<P><FONT class=extract>And some more data now </FONT></P>
<P><FONT class=extract>$ git status </FONT></P>
<P><FONT class=extract># On branch master </FONT></P>
<P><FONT class=extract>nothing to commit (working directory clean)</FONT>