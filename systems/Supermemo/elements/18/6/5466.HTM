Using git add 
<P></P>
<P><FONT class=extract>The command git add stages a file. In terms of Git&#8217;s file classifications, if a file is untracked, then git add converts that file&#8217;s status to tracked. When git add is used on a directory name, all of the files and subdirectories beneath it are staged recursively. Let&#8217;s continue the example from the previous section. </FONT></P>
<P><FONT class=extract>$ git status </FONT></P>
<P><FONT class=extract># On branch master </FONT></P>
<P><FONT class=extract># </FONT></P>
<P><FONT class=extract># Initial commit </FONT></P>
<P><FONT class=extract># </FONT></P>
<P><FONT class=extract># Untracked files: </FONT></P>
<P><FONT class=extract># (use "git add <FILE>..." to include in what will be committed) </FONT></P>
<P><FONT class=extract># </FONT></P>
<P><FONT class=extract># .gitignore </FONT></P>
<P><FONT class=extract># data </FONT></P>
<P><FONT class=extract># Track both new files. </FONT></P>
<P><FONT class=extract>$ git add data .gitignore </FONT></P>
<P><FONT class=extract>$ git status </FONT></P>
<P><FONT class=extract># On branch master</FONT></P>
<P><FONT class=extract># </FONT></P>
<P><FONT class=extract># Initial commit </FONT></P>
<P><FONT class=extract># </FONT></P>
<P><FONT class=extract># Changes to be committed: </FONT></P>
<P><FONT class=extract># (use "git rm --cached <FILE>..." to unstage) </FONT></P>
<P><FONT class=extract># </FONT></P>
<P><FONT class=extract># new file: .gitignore </FONT></P>
<P><FONT class=extract># new file: data </FONT></P>
<P><FONT class=extract>#</FONT></P>
<P><FONT class=extract>The first git status shows you that two files are untracked and reminds you that to make a file tracked, you simply need to use git add. After git add, both data and .gitignore are staged and tracked, and ready to be added to the repository on the next commit.</FONT> </P>
<P><FONT class=extract>In terms of Git&#8217;s object model, the entirety of each file at the moment you issued git add was copied into the object store and indexed by its resulting SHA1 name. Staging a file is also called caching a file(2. You did see the --cached in the git status output, didn&#8217;t you? ) or &#8220;putting a file in the index.&#8221;</FONT> </P>
<P><FONT class=extract>You can use git ls-files to peer under the object model hood and find the SHA1 values for those staged files: </FONT></P>
<P><FONT class=extract>$ git ls-files --stage</FONT></P>
<P><FONT class=extract>100644 0487f44090ad950f61955271cf0a2d6c6a83ad9a 0 .gitignore </FONT></P>
<P><FONT class=extract>100644 534469f67ae5ce72a7a274faf30dee3c2ea1746d 0 data </FONT></P>
<P>Most of the day-to-day changes within your repository will likely be simple edits. After any edit and before you commit your changes, run git add to update the index with the absolute latest and greatest version of your file. If you don&#8217;t, you&#8217;ll have two different versions of the file: one captured in the object store and referenced from the index, and the other in your working directory.</P>
<P><FONT class=extract>To continue the example, let&#8217;s change the file data so it&#8217;s different from the one in the index and use the arcane git hash-object file command (which you&#8217;ll hardly ever invoke directly) to directly compute and print the SHA1 hash for the new version.</FONT></P>
<P><FONT class=extract>$ git ls-files --stage </FONT></P>
<P><FONT class=extract>100644 0487f44090ad950f61955271cf0a2d6c6a83ad9a 0 .gitignore </FONT></P>
<P><FONT class=extract>100644 534469f67ae5ce72a7a274faf30dee3c2ea1746d 0 data</FONT></P>
<P><FONT class=extract># edit "data" to contain... </FONT></P>
<P><FONT class=extract>$ cat data</FONT></P>
<P><FONT class=extract>New data </FONT></P>
<P><FONT class=extract>And some more data now</FONT></P>
<P><FONT class=extract>$ git hash-object data </FONT></P>
<P><FONT class=extract>e476983f39f6e4f453f0fe4a859410f63b58b500 </FONT></P>
<P><FONT class=extract>After the file is amended, the previous version of the file in the object store and index has SHA1 534469f67ae5ce72a7a274faf30dee3c2ea1746d. However, the updated version of the file has SHA1 e476983f39f6e4f453f0fe4a859410f63b58b500. Let&#8217;s update the index to contain the new version of the file: </FONT></P>
<P><FONT class=extract>$ git add data</FONT></P>
<P><FONT class=extract>$ git ls-files --stage </FONT></P>
<P><FONT class=extract>100644 0487f44090ad950f61955271cf0a2d6c6a83ad9a 0 .gitignore </FONT></P>
<P><FONT class=extract>100644 e476983f39f6e4f453f0fe4a859410f63b58b500 0 data </FONT></P>
<P><FONT class=extract>The index now has the updated version of the file. Again, &#8220;the file data has been staged,&#8221; or speaking loosely, &#8220;the file data is in the index.&#8221; The latter phrase is less accurate because the file is actually in the object store and the index merely refers to it. The seemingly idle play with SHA1 hashes and the index brings home a key point: Think of git add not as &#8220;add this file,&#8221; but more as &#8220;add this content.&#8221;</FONT></P>
<P><FONT class=extract>In any event, the important thing to remember is that the version of a file in your working directory can be out of sync with the version staged in the index. When it comes time to make a commit, Git uses the version in the index. The --interactive option to either git add or git commit can be a useful way to explore which files you would like to stage for a commit.</FONT>