A Note on Tracking Renames 
<P></P>
<P>Let&#8217;s talk a bit more about how Git keeps track of file renames. </P>
<P>SVN, as an example of traditional revision control, does a lot of work tracking when a file is renamed and moved around because it keeps track only of diffs between files. If you move a file, it&#8217;s essentially the same as deleting all the lines from the old file and adding them to the new one. But it would be inefficient to transfer and store all the contents of the file again whenever you do a simple rename; imagine renaming a whole subdirectory that contains thousands of files.</P>
<P>To alleviate this situation, SVN tracks each rename explicitly. If you want to rename hello.txt to subdir/hello.txt, you must use svn mv instead of svn rm and svn add on the files. Otherwise, SVN has no way to see that it&#8217;s a rename and must go through the inefficient delete/add sequence just described. </P>
<P>Next, given this exceptional feature of tracking a rename, the SVN server needs a special protocol to tell its clients, &#8220;please move hello.txt into subdir/hello.txt.&#8221; Furthermore, each SVN client must ensure that it performs this (relatively rare) operation correctly. Git, on the other hand, doesn&#8217;t keep track of a rename. You can move or copy hello.txt anywhere you want, but doing so affects only tree objects. (Remember that tree objects store the relationships between content, whereas the content itself is stored in blobs.) A look at the differences between two trees makes it obvious that the blob named 3b18e5... has moved to a new place. And even if you don&#8217;t explicitly examine the differences, every part of the system knows it already has that blob, so every part knows it doesn&#8217;t need another copy of it.</P>
<P>In this situation, as in many other places, Git&#8217;s simple hash-based storage system simplifies a lot of things that baffle or elude other RCS.