As Figure 5-3 shows, Git first takes the version of file1 from the working directory, computes a SHA1 hash ID (bd71363) for its contents, and places that ID in the object store. Next, Git records in the index that the pathname file1 has been updated to the new bd71363 SHA1. </P>
<P>Because the contents of file2 haven&#8217;t changed and no git add staged file2, the index continues to reference the original blob object for it. </P>
<P>At this point, you have staged file1 in the index, and the working directory and index agree. However, the index is considered dirty with respect to HEAD because it differs from the tree recorded in the object store for the HEAD commit of the master branch.( 3. You can get a dirty index in the other direction, too, irrespective of the working directory state. By reading a non-HEAD commit out of the object store into the index and not checking out the corresponding files into the working directory, you create the situation where the index and working directory are not in agreement and where the index is still dirty with respect to the HEAD.)</P>
<P>Finally, after all changes have been staged in the index, a commit applies them to the repository. The effects of git commit are depicted in Figure 5-4.