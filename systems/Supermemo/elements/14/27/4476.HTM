j label </P>
<P>The basic &#8220;go-to&#8221; instruction. Note that it's limited to reaching instructions within a 2^28-byte &#8220;page.&#8221; goto label;</P>
<P>j r =&gt; jr r </P>
<P>Jump to the instruction pointed to by register r. This is the only way of transferring control to an arbitrary address, since all the address-in-instruction formats span less than 32 bits. </P>
<P>jal label </P>
<P>Subroutine call, with return address in $ra ($31). Note that the return address is the next instruction but one&#8212;as is usual with MIPS branches, the immediately following instruction position is the branch delay slot, and the instruction there is always executed before you reach the subroutine. </P>
<P>jal d,addr =&gt; la $at,addr; jalr d,$at </P>
<P>Like function call, but leaves the return address in the register d instead of the usual $31. Synthesized with jalr. It's cheating to use the instruction la in the machine code expansion, as la is itself a macro&#8212;but it means we can avoid explaining addressing modes here (see section 9.4 instead). </P>
<P>jalr d,s </P>
<P>Variant of jal d,addr above, when the address syntax is just another register s. You can write jal or jalr. </P>
<P>jal s =&gt; jalr $ra,s </P>
<P>If you specify just one register, that's the address to call, and the return address is put in the usual $ra.</P></TD></TR>