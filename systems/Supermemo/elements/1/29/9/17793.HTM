<H4 class=subsection>6.3.3 Boolean Expressions</H4><A name=index-and-Boolean_002dlogic-operator></A><A name=index-or-Boolean_002dlogic-operator></A><A name=index-not-Boolean_002dlogic-operator></A><A name=index-expressions_002c-Boolean></A><A name=index-Boolean-expressions></A><A name=index-operators_002c-Boolean_002c-See-Boolean-expressions></A><A name=index-Boolean-operators_002c-See-Boolean-expressions></A><A name=index-logical-operators_002c-See-Boolean-expressions></A><A name=index-operators_002c-logical_002c-See-Boolean-expressions></A>
<P>A <EM>Boolean expression</EM> is a combination of comparison expressions or matching expressions, using the Boolean operators &#8220;or&#8221; (&#8216;<SAMP>||</SAMP>&#8217;), &#8220;and&#8221; (&#8216;<SAMP>&amp;&amp;</SAMP>&#8217;), and &#8220;not&#8221; (&#8216;<SAMP>!</SAMP>&#8217;), along with parentheses to control nesting. The truth value of the Boolean expression is computed by combining the truth values of the component expressions. Boolean expressions are also referred to as <EM>logical expressions</EM>. The terms are equivalent. </P>
<P>Boolean expressions can be used wherever comparison and matching expressions can be used. They can be used in <CODE>if</CODE>, <CODE>while</CODE>, <CODE>do</CODE>, and <CODE>for</CODE> statements (see <A href="http://www.gnu.org/software/gawk/manual/gawk.html#Statements">Statements</A>). They have numeric values (one if true, zero if false) that come into play if the result of the Boolean expression is stored in a variable or used in arithmetic. </P>
<P>In addition, every Boolean expression is also a valid pattern, so you can use one as a pattern to control the execution of rules. The Boolean operators are: </P>
<DL compact>
<DT><CODE><VAR>boolean1</VAR> &amp;&amp; <VAR>boolean2</VAR></CODE></DT>
<DD>
<P>True if both <VAR>boolean1</VAR> and <VAR>boolean2</VAR> are true. For example, the following statement prints the current input record if it contains both &#8216;<SAMP>edu</SAMP>&#8217; and &#8216;<SAMP>li</SAMP>&#8217;: </P>
<DIV class=example><PRE class=example>if ($0 ~ /edu/ &amp;&amp; $0 ~ /li/) print
</PRE></DIV><A name=index-side-effects_002c-Boolean-operators></A>
<P>The subexpression <VAR>boolean2</VAR> is evaluated only if <VAR>boolean1</VAR> is true. This can make a difference when <VAR>boolean2</VAR> contains expressions that have side effects. In the case of &#8216;<SAMP>$0 ~ /foo/ &amp;&amp; ($2 == bar++)</SAMP>&#8217;, the variable <CODE>bar</CODE> is not incremented if there is no substring &#8216;<SAMP>foo</SAMP>&#8217; in the record. </P></DD>
<DT><CODE><VAR>boolean1</VAR> || <VAR>boolean2</VAR></CODE></DT>
<DD>
<P>True if at least one of <VAR>boolean1</VAR> or <VAR>boolean2</VAR> is true. For example, the following statement prints all records in the input that contain <EM>either</EM> &#8216;<SAMP>edu</SAMP>&#8217; or &#8216;<SAMP>li</SAMP>&#8217; or both: </P>
<DIV class=example><PRE class=example>if ($0 ~ /edu/ || $0 ~ /li/) print
</PRE></DIV>
<P>The subexpression <VAR>boolean2</VAR> is evaluated only if <VAR>boolean1</VAR> is false. This can make a difference when <VAR>boolean2</VAR> contains expressions that have side effects. </P></DD>
<DT><CODE>! <VAR>boolean</VAR></CODE></DT>
<DD>
<P>True if <VAR>boolean</VAR> is false. For example, the following program prints &#8216;<SAMP>no home!</SAMP>&#8217; in the unusual event that the <CODE>HOME</CODE> environment variable is not defined: </P>
<DIV class=example><PRE class=example>BEGIN { if (! ("HOME" in ENVIRON))
               print "no home!" }
</PRE></DIV>
<P>(The <CODE>in</CODE> operator is described in <A href="http://www.gnu.org/software/gawk/manual/gawk.html#Reference-to-Elements">Reference to Elements</A>.) </P></DD></DL><A name=index-short_002dcircuit-operators></A><A name=index-operators_002c-short_002dcircuit></A><A name=index-_0026-_0028ampersand_0029_002c-_0026_0026-operator></A><A name=index-ampersand-_0028_0026_0029_002c-_0026_0026-operator></A><A name=index-_007c-_0028vertical-bar_0029_002c-_007c_007c-operator></A><A name=index-vertical-bar-_0028_007c_0029_002c-_007c_007c-operator></A>
<P>The &#8216;<SAMP>&amp;&amp;</SAMP>&#8217; and &#8216;<SAMP>||</SAMP>&#8217; operators are called <EM>short-circuit</EM> operators because of the way they work. Evaluation of the full expression is &#8220;short-circuited&#8221; if the result can be determined part way through its evaluation. </P><A name=index-line-continuations></A>
<P>Statements that use &#8216;<SAMP>&amp;&amp;</SAMP>&#8217; or &#8216;<SAMP>||</SAMP>&#8217; can be continued simply by putting a newline after them. But you cannot put a newline in front of either of these operators without using backslash continuation (see <A href="http://www.gnu.org/software/gawk/manual/gawk.html#Statements_002fLines">Statements/Lines</A>). </P><A name=index-_0021-_0028exclamation-point_0029_002c-_0021-operator></A><A name=index-exclamation-point-_0028_0021_0029_002c-_0021-operator></A><A name=index-newlines-2></A><A name=index-variables_002c-flag></A><A name=index-flag-variables></A>
<P>The actual value of an expression using the &#8216;<SAMP>!</SAMP>&#8217; operator is either one or zero, depending upon the truth value of the expression it is applied to. The &#8216;<SAMP>!</SAMP>&#8217; operator is often useful for changing the sense of a flag variable from false to true and back again. For example, the following program is one way to print lines in between special bracketing lines: </P>
<DIV class=example><PRE class=example>$1 == "START"   { interested = ! interested; next }
interested == 1 { print }
$1 == "END"     { interested = ! interested; next }
</PRE></DIV>
<P>The variable <CODE>interested</CODE>, as with all <CODE>awk</CODE> variables, starts out initialized to zero, which is also false. When a line is seen whose first field is &#8216;<SAMP>START</SAMP>&#8217;, the value of <CODE>interested</CODE> is toggled to true, using &#8216;<SAMP>!</SAMP>&#8217;. The next rule prints lines as long as <CODE>interested</CODE> is true. When a line is seen whose first field is &#8216;<SAMP>END</SAMP>&#8217;, <CODE>interested</CODE> is toggled back to false.<A href="http://www.gnu.org/software/gawk/manual/gawk.html#FOOT36" name=DOCF36><SUP>36</SUP></A> </P><A name=index-next-statement></A>
<BLOCKQUOTE>
<P><B>NOTE:</B> The <CODE>next</CODE> statement is discussed in <A href="http://www.gnu.org/software/gawk/manual/gawk.html#Next-Statement">Next Statement</A>. <CODE>next</CODE> tells <CODE>awk</CODE> to skip the rest of the rules, get the next record, and start processing the rules over again at the top. The reason it&#8217;s there is to avoid printing the bracketing &#8216;<SAMP>START</SAMP>&#8217; and &#8216;<SAMP>END</SAMP>&#8217; lines. </P></BLOCKQUOTE>