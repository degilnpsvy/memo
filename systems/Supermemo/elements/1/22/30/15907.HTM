<H3 style="MARGIN: 13pt 0cm"><SPAN style="LINE-HEIGHT: 173%; FONT-SIZE: 21pt; mso-bidi-font-size: 16.0pt; mso-font-kerning: 0pt" lang=EN-US>pthread_mutex_trylock() </SPAN><SPAN style="LINE-HEIGHT: 173%; FONT-FAMILY: 'Futura-CondensedBold','sans-serif'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: Futura-CondensedBold" lang=EN-US><FONT size=5>and </FONT></SPAN><SPAN style="LINE-HEIGHT: 173%; FONT-SIZE: 21pt; mso-bidi-font-size: 16.0pt; mso-font-kerning: 0pt" lang=EN-US>pthread_mutex_timedlock()</SPAN></H3>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US>The Pthreads API provides two variants of the pthread_mutex_lock() function: pthread_mutex_trylock() and pthread_mutex_timedlock(). (See the manual pages for prototypes of these functions.)</SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>The pthread_mutex_trylock() function is the same as pthread_mutex_lock(), except that if the mutex is currently locked, pthread_mutex_trylock() fails, returning the error EBUSY.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>The pthread_mutex_timedlock() function is the same as pthread_mutex_lock(), except that the caller can specify an additional argument, abstime, that places a limit on the time that the thread will sleep while waiting to acquire the mutex. If the time interval specified by its abstime argument expires without the caller becoming the owner of the mutex, pthread_mutex_timedlock() returns the error ETIMEDOUT.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>The pthread_mutex_trylock() and pthread_mutex_timedlock() functions are much less frequently used than pthread_mutex_lock(). In most well-designed applications, a thread should hold a mutex for only a short time, so that other threads are not prevented from executing in parallel. This guarantees that other threads that are blocked on the mutex will soon be granted a lock on the mutex. A thread that uses pthread_mutex_trylock() to periodically poll the mutex to see if it can be locked risks being starved of access to the mutex while other queued threads are successively granted access to the mutex via pthread_mutex_lock().</FONT></SPAN>