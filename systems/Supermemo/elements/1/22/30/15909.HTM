<HEAD></HEAD>
<BODY>
<H3 style="MARGIN: 13pt 0cm"><SPAN style="LINE-HEIGHT: 173%; FONT-SIZE: 21pt; mso-bidi-font-size: 16.0pt; mso-font-kerning: 0pt" lang=EN-US>30.1.4 Mutex Deadlocks</SPAN></H3>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US>Sometimes, a thread needs to simultaneously access two or more different shared resources, each of which is governed by a separate mutex. When more than one thread is locking the same set of mutexes, deadlock situations can arise. Figure 30-3 shows an example of a deadlock in which each thread successfully locks one mutex, and then tries to lock the mutex that the other thread has already locked. Both threads will remain blocked indefinitely.</SPAN></P>
<P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none" class=MsoNormal align=left><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt" lang=EN-US><?xml:namespace prefix = v /><v:shapetype id=_x0000_t75 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"><v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"></v:path><?xml:namespace prefix = o /><o:lock v:ext="edit" aspectratio="t"></o:lock></v:shapetype><v:shape style="WIDTH: 629.25pt; HEIGHT: 186pt" id=_x0000_i1025 type="#_x0000_t75"><v:imagedata src="file:///C:\Users\DONPOP~1\AppData\Local\Temp\msohtmlclip1\01\clip_image001.emz" o:title=""></v:imagedata></v:shape></SPAN></P>
<P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none" class=MsoNormal align=left><B><SPAN style="FONT-FAMILY: 'Futura-Heavy','sans-serif'; FONT-SIZE: 14pt; mso-bidi-font-size: 9.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: Futura-Heavy" lang=EN-US>Figure 30-3: </SPAN></B><SPAN style="FONT-FAMILY: 'Futura-Book','sans-serif'; FONT-SIZE: 14pt; mso-bidi-font-size: 9.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: Futura-Book" lang=EN-US>A deadlock when two threads lock two mutexes</SPAN><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt" lang=EN-US></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>The simplest way to avoid such deadlocks is to define a mutex hierarchy. When threads can lock the same set of mutexes, they should always lock them in the same order. For example, in the scenario in Figure 30-3, the deadlock could be avoided if the two threads always lock the mutexes in the order mutex1 followed by mutex2. Sometimes, there is a logically obvious hierarchy of mutexes. However, even if there isn&#8217;t, it may be possible to devise an arbitrary hierarchical order that all threads should follow.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>An alternative strategy that is less frequently used is &#8220;try, and then back off.&#8221; In this strategy, a thread locks the first mutex using pthread_mutex_lock(), and then locks the remaining mutexes using pthread_mutex_trylock(). If any of the pthread_mutex_trylock() calls fails (with EBUSY), then the thread releases all mutexes, and then tries again, perhaps after a delay interval. This approach is less efficient than a lock hierarchy, since multiple iterations may be required. On the other hand, it can be more flexible, since it doesn&#8217;t require a rigid mutex hierarchy. An example of this strategy is shown in [Butenhof, 1996].</FONT></SPAN></P></BODY>