drm_cvt_mode<BR>Prev &nbsp;Display Modes Function Reference&nbsp; Next<BR>Name</P>
<P>drm_cvt_mode &#8212; create a modeline based on the CVT algorithm<BR>Synopsis<BR>struct drm_display_mode * drm_cvt_mode (&nbsp;struct drm_device * dev,<BR>&nbsp;&nbsp;int hdisplay,<BR>&nbsp;&nbsp;int vdisplay,<BR>&nbsp;&nbsp;int vrefresh,<BR>&nbsp;&nbsp;bool reduced,<BR>&nbsp;&nbsp;bool interlaced,<BR>&nbsp;&nbsp;bool margins);<BR>&nbsp;<BR>Arguments</P>
<P>dev</P>
<P>&nbsp;&nbsp;&nbsp; drm device <BR>hdisplay</P>
<P>&nbsp;&nbsp;&nbsp; hdisplay size <BR>vdisplay</P>
<P>&nbsp;&nbsp;&nbsp; vdisplay size <BR>vrefresh</P>
<P>&nbsp;&nbsp;&nbsp; vrefresh rate <BR>reduced</P>
<P>&nbsp;&nbsp;&nbsp; whether to use reduced blanking <BR>interlaced</P>
<P>&nbsp;&nbsp;&nbsp; whether to compute an interlaced mode <BR>margins</P>
<P>&nbsp;&nbsp;&nbsp; whether to add margins (borders) </P>
<P>Description</P>
<P>This function is called to generate the modeline based on CVT algorithm according to the hdisplay, vdisplay, vrefresh. It is based from the VESA(TM) Coordinated Video Timing Generator by Graham Loveridge April 9, 2003 available at<BR>http</P>
<P>//www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls</P>
<P>And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c. What I have done is to translate it by using integer calculation.<BR>Returns</P>
<P>The modeline based on the CVT algorithm stored in a drm_display_mode object. The display mode object is allocated with drm_mode_create. Returns NULL when no mode could be allocated.<BR>Prev &nbsp;Up&nbsp; Next<BR>drm_mode_probed_add &nbsp;Home&nbsp; drm_gtf_mode_complex