VMA Offset Manager 
<P>drm_vma_offset_manager_init &#8212; Initialize new offset-manager<BR>drm_vma_offset_manager_destroy &#8212; Destroy offset manager<BR>drm_vma_offset_lookup &#8212; Find node in offset space<BR>drm_vma_offset_lookup_locked &#8212; Find node in offset space<BR>drm_vma_offset_add &#8212; Add offset node to manager<BR>drm_vma_offset_remove &#8212; Remove offset node from manager<BR>drm_vma_node_allow &#8212; Add open-file to list of allowed users<BR>drm_vma_node_revoke &#8212; Remove open-file from list of allowed users<BR>drm_vma_node_is_allowed &#8212; Check whether an open-file is granted access<BR>drm_vma_offset_exact_lookup &#8212; Look up node by exact address<BR>drm_vma_offset_lock_lookup &#8212; Lock lookup for extended private use<BR>drm_vma_offset_unlock_lookup &#8212; Unlock lookup for extended private use<BR>drm_vma_node_reset &#8212; Initialize or reset node object<BR>drm_vma_node_start &#8212; Return start address for page-based addressing<BR>drm_vma_node_size &#8212; Return size (page-based)<BR>drm_vma_node_has_offset &#8212; Check whether node is added to offset manager<BR>drm_vma_node_offset_addr &#8212; Return sanitized offset for user-space mmaps<BR>drm_vma_node_unmap &#8212; Unmap offset node<BR>drm_vma_node_verify_access &#8212; Access verification helper for TTM</P>
<P>The vma-manager is responsible to map arbitrary driver-dependent memory regions into the linear user address-space. It provides offsets to the caller which can then be used on the address_space of the drm-device. It takes care to not overlap regions, size them appropriately and to not confuse mm-core by inconsistent fake vm_pgoff fields. Drivers shouldn't use this for object placement in VMEM. This manager should only be used to manage mappings into linear user-space VMs.</P>
<P>We use drm_mm as backend to manage object allocations. But it is highly optimized for alloc/free calls, not lookups. Hence, we use an rb-tree to speed up offset lookups.</P>
<P>You must not use multiple offset managers on a single address_space. Otherwise, mm-core will be unable to tear down memory mappings as the VM will no longer be linear. Please use VM_NONLINEAR in that case and implement your own offset managers.</P>
<P>This offset manager works on page-based addresses. That is, every argument and return code (with the exception of drm_vma_node_offset_addr) is given in number of pages, not number of bytes. That means, object sizes and offsets must always be page-aligned (as usual). If you want to get a valid byte-based user-space address for a given offset, please see drm_vma_node_offset_addr.</P>
<P>Additionally to offset management, the vma offset manager also handles access management. For every open-file context that is allowed to access a given node, you must call drm_vma_node_allow. Otherwise, an mmap call on this open-file with the offset of the node will fail with -EACCES. To revoke access again, use drm_vma_node_revoke. However, the caller is responsible for destroying already existing mappings, if required.