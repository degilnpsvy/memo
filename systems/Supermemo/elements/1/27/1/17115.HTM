Driver Load
<P>Driver Private Data<BR>IRQ Registration<BR>Memory Manager Initialization<BR>Miscellaneous Device Configuration</P>
<P>The load method is the driver and device initialization entry point. The method is responsible for allocating and initializing driver private data, performing resource allocation and mapping (e.g. acquiring clocks, mapping registers or allocating command buffers), initializing the memory manager (the section called &#8220;Memory management&#8221;), installing the IRQ handler (the section called &#8220;IRQ Registration&#8221;), setting up vertical blanking handling (the section called &#8220;Vertical Blanking&#8221;), mode setting (the section called &#8220;Mode Setting&#8221;) and initial output configuration (the section called &#8220;KMS Initialization and Cleanup&#8221;).<BR>Note</P>
<P>If compatibility is a concern (e.g. with drivers converted over from User Mode Setting to Kernel Mode Setting), care must be taken to prevent device initialization and control that is incompatible with currently active userspace drivers. For instance, if user level mode setting drivers are in use, it would be problematic to perform output discovery &amp; configuration at load time. Likewise, if user-level drivers unaware of memory management are in use, memory management and command buffer setup may need to be omitted. These requirements are driver-specific, and care needs to be taken to keep both old and new applications and libraries working.</P>
<P>int (*load) (struct drm_device *, unsigned long flags);</P>
<P>The method takes two arguments, a pointer to the newly created drm_device and flags. The flags are used to pass the driver_data field of the device id corresponding to the device passed to drm_*_init(). Only PCI devices currently use this, USB and platform DRM drivers have their load method called with flags to 0.<BR>Driver Private Data</P>
<P>The driver private hangs off the main drm_device structure and can be used for tracking various device-specific bits of information, like register offsets, command buffer status, register state for suspend/resume, etc. At load time, a driver may simply allocate one and set drm_device.dev_priv appropriately; it should be freed and drm_device.dev_priv set to NULL when the driver is unloaded.<BR>IRQ Registration</P>
<P>The DRM core tries to facilitate IRQ handler registration and unregistration by providing drm_irq_install and drm_irq_uninstall functions. Those functions only support a single interrupt per device, devices that use more than one IRQs need to be handled manually.<BR>Managed IRQ Registration</P>
<P>drm_irq_install starts by calling the irq_preinstall driver operation. The operation is optional and must make sure that the interrupt will not get fired by clearing all pending interrupt flags or disabling the interrupt.</P>
<P>The passed-in IRQ will then be requested by a call to request_irq. If the DRIVER_IRQ_SHARED driver feature flag is set, a shared (IRQF_SHARED) IRQ handler will be requested.</P>
<P>The IRQ handler function must be provided as the mandatory irq_handler driver operation. It will get passed directly to request_irq and thus has the same prototype as all IRQ handlers. It will get called with a pointer to the DRM device as the second argument.</P>
<P>Finally the function calls the optional irq_postinstall driver operation. The operation usually enables interrupts (excluding the vblank interrupt, which is enabled separately), but drivers may choose to enable/disable interrupts at a different time.</P>
<P>drm_irq_uninstall is similarly used to uninstall an IRQ handler. It starts by waking up all processes waiting on a vblank interrupt to make sure they don't hang, and then calls the optional irq_uninstall driver operation. The operation must disable all hardware interrupts. Finally the function frees the IRQ by calling free_irq.<BR>Manual IRQ Registration</P>
<P>Drivers that require multiple interrupt handlers can't use the managed IRQ registration functions. In that case IRQs must be registered and unregistered manually (usually with the request_irq and free_irq functions, or their devm_* equivalent).</P>
<P>When manually registering IRQs, drivers must not set the DRIVER_HAVE_IRQ driver feature flag, and must not provide the irq_handler driver operation. They must set the drm_device irq_enabled field to 1 upon registration of the IRQs, and clear it to 0 after unregistering the IRQs.<BR>Memory Manager Initialization</P>
<P>Every DRM driver requires a memory manager which must be initialized at load time. DRM currently contains two memory managers, the Translation Table Manager (TTM) and the Graphics Execution Manager (GEM). This document describes the use of the GEM memory manager only. See the section called &#8220;Memory management&#8221; for details.<BR>Miscellaneous Device Configuration</P>
<P>Another task that may be necessary for PCI devices during configuration is mapping the video BIOS. On many devices, the VBIOS describes device configuration, LCD panel timings (if any), and contains flags indicating device state. Mapping the BIOS can be done using the pci_map_rom() call, a convenience function that takes care of mapping the actual ROM, whether it has been shadowed into memory (typically at address 0xc0000) or exists on the PCI device in the ROM BAR. Note that after the ROM has been mapped and any necessary information has been extracted, it should be unmapped; on many devices, the ROM address decoder is shared with other BARs, so leaving it mapped could cause undesired behaviour like hangs or memory corruption.