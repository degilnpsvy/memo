Device Registration
<P>drm_pci_alloc &#8212; Allocate a PCI consistent memory block, for DMA.<BR>drm_pci_free &#8212; Free a PCI consistent memory block<BR>drm_get_pci_dev &#8212; Register a PCI device with the DRM subsystem<BR>drm_pci_init &#8212; Register matching PCI devices with the DRM subsystem<BR>drm_pci_exit &#8212; Unregister matching PCI devices from the DRM subsystem<BR>drm_usb_init &#8212; Register matching USB devices with the DRM subsystem<BR>drm_usb_exit &#8212; Unregister matching USB devices from the DRM subsystem<BR>drm_platform_init &#8212; Register a platform device with the DRM subsystem<BR>drm_put_dev &#8212; Unregister and release a DRM device<BR>drm_dev_alloc &#8212; Allocate new DRM device<BR>drm_dev_ref &#8212; Take reference of a DRM device<BR>drm_dev_unref &#8212; Drop reference of a DRM device<BR>drm_dev_register &#8212; Register DRM device<BR>drm_dev_unregister &#8212; Unregister DRM device<BR>drm_dev_set_unique &#8212; Set the unique name of a DRM device</P>
<P>A number of functions are provided to help with device registration. The functions deal with PCI, USB and platform devices, respectively.</P>
<P>New drivers that no longer rely on the services provided by the drm_bus structure can call the low-level device registration functions directly. The drm_dev_alloc() function can be used to allocate and initialize a new drm_device structure. Drivers will typically want to perform some additional setup on this structure, such as allocating driver-specific data and storing a pointer to it in the DRM device's dev_private field. Drivers should also set the device's unique name using the drm_dev_set_unique() function. After it has been set up a device can be registered with the DRM subsystem by calling drm_dev_register(). This will cause the device to be exposed to userspace and will call the driver's .load() implementation. When a device is removed, the DRM device can safely be unregistered and freed by calling drm_dev_unregister() followed by a call to drm_dev_unref().