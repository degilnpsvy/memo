CRTCs (struct drm_crtc)
<P>CRTC Initialization<BR>CRTC Operations</P>
<P>A CRTC is an abstraction representing a part of the chip that contains a pointer to a scanout buffer. Therefore, the number of CRTCs available determines how many independent scanout buffers can be active at any given time. The CRTC structure contains several fields to support this: a pointer to some video memory (abstracted as a frame buffer object), a display mode, and an (x, y) offset into the video memory to support panning or configurations where one piece of video memory spans multiple CRTCs.<BR>CRTC Initialization</P>
<P>A KMS device must create and register at least one struct drm_crtc instance. The instance is allocated and zeroed by the driver, possibly as part of a larger structure, and registered with a call to drm_crtc_init with a pointer to CRTC functions.<BR>CRTC Operations<BR>Set Configuration</P>
<P>int (*set_config)(struct drm_mode_set *set);</P>
<P>Apply a new CRTC configuration to the device. The configuration specifies a CRTC, a frame buffer to scan out from, a (x,y) position in the frame buffer, a display mode and an array of connectors to drive with the CRTC if possible.</P>
<P>If the frame buffer specified in the configuration is NULL, the driver must detach all encoders connected to the CRTC and all connectors attached to those encoders and disable them.</P>
<P>This operation is called with the mode config lock held.<BR>Note</P>
<P>Note that the drm core has no notion of restoring the mode setting state after resume, since all resume handling is in the full responsibility of the driver. The common mode setting helper library though provides a helper which can be used for this: drm_helper_resume_force_mode.<BR>Page Flipping</P>
<P>int (*page_flip)(struct drm_crtc *crtc, struct drm_framebuffer *fb,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct drm_pending_vblank_event *event);</P>
<P>Schedule a page flip to the given frame buffer for the CRTC. This operation is called with the mode config mutex held.</P>
<P>Page flipping is a synchronization mechanism that replaces the frame buffer being scanned out by the CRTC with a new frame buffer during vertical blanking, avoiding tearing. When an application requests a page flip the DRM core verifies that the new frame buffer is large enough to be scanned out by the CRTC in the currently configured mode and then calls the CRTC page_flip operation with a pointer to the new frame buffer.</P>
<P>The page_flip operation schedules a page flip. Once any pending rendering targeting the new frame buffer has completed, the CRTC will be reprogrammed to display that frame buffer after the next vertical refresh. The operation must return immediately without waiting for rendering or page flip to complete and must block any new rendering to the frame buffer until the page flip completes.</P>
<P>If a page flip can be successfully scheduled the driver must set the drm_crtc-&lt;fb field to the new framebuffer pointed to by fb. This is important so that the reference counting on framebuffers stays balanced.</P>
<P>If a page flip is already pending, the page_flip operation must return -EBUSY.</P>
<P>To synchronize page flip to vertical blanking the driver will likely need to enable vertical blanking interrupts. It should call drm_vblank_get for that purpose, and call drm_vblank_put after the page flip completes.</P>
<P>If the application has requested to be notified when page flip completes the page_flip operation will be called with a non-NULL event argument pointing to a drm_pending_vblank_event instance. Upon page flip completion the driver must call drm_send_vblank_event to fill in the event and send to wake up any waiting processes. This can be performed with</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drm_send_vblank_event(dev, pipe, event);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P>Note</P>
<P>FIXME: Could drivers that don't need to wait for rendering to complete just add the event to dev-&gt;vblank_event_list and let the DRM core handle everything, as for "normal" vertical blanking events?</P>
<P>While waiting for the page flip to complete, the event-&gt;base.link list head can be used freely by the driver to store the pending event in a driver-specific list.</P>
<P>If the file handle is closed before the event is signaled, drivers must take care to destroy the event in their preclose operation (and, if needed, call drm_vblank_put).<BR>Miscellaneous</P>
<P>&nbsp;&nbsp;&nbsp; void (*set_property)(struct drm_crtc *crtc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct drm_property *property, uint64_t value);</P>
<P>&nbsp;&nbsp;&nbsp; Set the value of the given CRTC property to value. See the section called &#8220;KMS Properties&#8221; for more information about properties.</P>
<P>&nbsp;&nbsp;&nbsp; void (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t start, uint32_t size);</P>
<P>&nbsp;&nbsp;&nbsp; Apply a gamma table to the device. The operation is optional.</P>
<P>&nbsp;&nbsp;&nbsp; void (*destroy)(struct drm_crtc *crtc);</P>
<P>&nbsp;&nbsp;&nbsp; Destroy the CRTC when not needed anymore. See the section called &#8220;KMS Initialization and Cleanup&#8221;.