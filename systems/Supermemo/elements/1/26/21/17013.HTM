scanf might stop scanning a particular field before reaching the normal field end character, or may terminate entirely. 
<P></P>
<P><FONT class=extract>scanf stops scanning and storing the current field and moves to the next input field (if any) in any of the following situations: </FONT></P>
<P><FONT class=extract>&#183; The assignment suppressing character (*) appears after the % in the format specification; the current input field is scanned but not stored. </FONT></P>
<P><FONT class=extract>&#183; width characters have been read (width is a width specification, a positive decimal integer). </FONT></P>
<P><FONT class=extract>&#183; The next character read cannot be converted under the the current format (for example, if a Z is read when the format is decimal). </FONT></P>
<P><FONT class=extract>&#183; The next character in the input field does not appear in the search set (or does appear in the inverted search set). </FONT></P>
<P><FONT class=extract>When scanf stops scanning the current input field for one of these reasons, the next character is considered unread and used as the first character of the following input field, or the first character in a subsequent read operation on the input.</FONT> </P>
<P><FONT class=extract>scanf will terminate under the following circumstances:</FONT></P>
<P><FONT class=extract>&#183; The next character in the input field conflicts with a corresponding non-whitespace character in the format string. </FONT></P>
<P><FONT class=extract>&#183; The next character in the input field is EOF. </FONT></P>
<P><FONT class=extract>&#183; The format string has been exhausted.</FONT></P>
<P><FONT class=extract>When the format string contains a character sequence that is not part of a format specification, the same character sequence must appear in the input; scanfwill scan but not store the matched characters. If a conflict occurs, the first conflicting character remains in the input as if it had never been read.</FONT></P><!--EndFragment-->