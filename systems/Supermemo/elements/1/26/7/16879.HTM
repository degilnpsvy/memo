<HEAD></HEAD>
<BODY>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><STRONG><SPAN lang=EN-US style="FONT-SIZE: 18.5pt; FONT-FAMILY: 'Calibri','sans-serif'; COLOR: black; mso-bidi-font-size: 13.5pt; mso-ascii-theme-font: minor-latin; mso-hansi-theme-font: minor-latin; mso-bidi-font-family: 'Times New Roman'; mso-bidi-theme-font: minor-bidi">How do memory and I/O ports work?</SPAN></STRONG><SPAN class=apple-converted-space><SPAN lang=EN-US style="FONT-SIZE: 22pt; FONT-FAMILY: 'Simsun','serif'; COLOR: black; mso-bidi-font-size: 13.5pt"><SPAN style="WORD-SPACING: 0px; FLOAT: none; -webkit-text-stroke-width: 0px">&nbsp;</SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 22pt; FONT-FAMILY: 'Simsun','serif'; COLOR: black; mso-bidi-font-size: 13.5pt"><BR style="WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><SPAN style="WORD-SPACING: 0px; FLOAT: none; -webkit-text-stroke-width: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT class=extract>80x86 machines have both a memory address space and an input/output (I/O) address space. Most of the memory is provided as system RAM on the motherboard and most of the I/O devices are provided by cards (although the motherboard does provide quite a bit of I/O capability, varying on the motherboard design.) Also some cards also provide memory.</FONT> <FONT class=extract>The VGA and SVGA display adapters provide memory in the form of video memory, and they also handle I/O addresses for controlling the display, so you must learn to deal with both. An adapter card could perform all of its functions using solely memory or I/O (and some do), but I/O is usually used because the decoding circuitry is simpler and memory is used when higher performance is required.</FONT><SPAN class=apple-converted-space>&nbsp;</SPAN></SPAN><BR style="WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><SPAN style="WORD-SPACING: 0px; FLOAT: none; -webkit-text-stroke-width: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The original PC design was based upon the capabilities of the 8086/8088, which allowed for only 1 MB of memory, of which a small range (64K) was allotted for graphics memory. Designers of high-resolution video cards needed to put more than 64K of memory on their video adapters to support higher resolution modes, and used a concept called "banking" which made the 64K available to the processor into a "window" which shows a 64K chunk of video memory at once. Later designs used multiple banks and other techniques to simplify programming. Since modern 32-bit processors have 4 gigabytes of address space, some designers allow you to map all of the video memory into a "linear frame buffer" allowing access to the entire video memory at once without having to change the current window pointer (which can be time consuming.) while still providing support for the windowed method.<SPAN class=apple-converted-space>&nbsp;</SPAN></SPAN><BR style="WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><SPAN style="WORD-SPACING: 0px; FLOAT: none; -webkit-text-stroke-width: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT class=extract>Memory can be accessed most flexibly as it can be the source and/or target of almost every machine language instruction the CPU is capable of executing, as opposed to a very limited set of I/O instructions. I/O space is divided into 65536 addresses in the range 0-65535. Most I/O devices are configured to use a limited set of addresses that cannot conflict with another device. The primary instructions for accessing I/O are the assembly instructions "IN" and "OUT", simply enough. Most programming environments provide similarly named instructions, functions, or procedures for accessing these.</FONT><SPAN class=apple-converted-space>&nbsp;</SPAN></SPAN><BR style="WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><SPAN style="WORD-SPACING: 0px; FLOAT: none; -webkit-text-stroke-width: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT class=extract>Memory can be a bit confusing though, because the CPU has two memory addressing modes, Real mode and Protected mode. Real mode was the only method available on the 8086 and is still the primary addressing mode used in DOS. Unfortunately, real mode only provides access to the first 1 MB of memory. Protected mode is used on the 80286 and up to allow access to more memory. (There are also other details such as protection, virtual memory, and other aspects not particularly applicable to this discussion.) Memory is accessed by the 80x86 processors using segments and offsets. Segments tell the memory management unit where in memory is located, and the offset is the displacement from that address. In real mode offsets are limited to 64K, because of the 16-bit nature of the 8086. In protected mode, segments can be any size up to the full address capability of the machine. Segments are accessed via special segment registers in the processor. In real mode, the segment address is shifted left four bits and added to the offset, allowing for a 20 bit address (20 bits = 1 MB); in protected mode segments are offsets into a table in memory which tells where the segment is located. Your particular programming environment may create code for real and/or protected mode, and it is important to know which mode is being used. An added difficulty is the fact that protected mode provides for I/O and memory protection (hence protected mode), in order to allow multiple programs to share one processor and prevent them from corrupting other processes. This means that you may need to interact with the operating system to gain rights to access the hardware directly. If you write your own protected mode handler for DOS or are using a DOS extender, then this should be simple, but it is much more complicated under multi-tasking operating systems such as Windows or Linux.</FONT></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><?xml:namespace prefix = "o" ns = "urn:schemas-microsoft-com:office:office" /><o:p></o:p></SPAN></P></BODY>