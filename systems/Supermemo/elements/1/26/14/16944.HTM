<HEAD></HEAD>
<BODY>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><FONT face=Calibri><B><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt">External merge sort</SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt">[<A title="Edit section: External merge sort" href="http://en.wikipedia.org/w/index.php?title=External_sorting&amp;action=edit&amp;section=1"><FONT color=#0000ff>edit</FONT></A>]<B><?xml:namespace prefix = "o" ns = "urn:schemas-microsoft-com:office:office" /><o:p></o:p></B></SPAN></FONT></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>One example of external sorting is the external&nbsp;</FONT><A title="Merge sort" href="http://en.wikipedia.org/wiki/Merge_sort"><FONT color=#0000ff face=Calibri>merge sort</FONT></A><FONT face=Calibri>&nbsp;algorithm, which sorts chunks that each fit in RAM, then merges the sorted chunks together.<SUP><A href="http://en.wikipedia.org/wiki/External_sorting#cite_note-1"><FONT color=#0000ff>[1]</FONT></A><A href="http://en.wikipedia.org/wiki/External_sorting#cite_note-2"><FONT color=#0000ff>[2]</FONT></A></SUP>&nbsp;For example, for sorting 900&nbsp;</FONT><A title=Megabyte href="http://en.wikipedia.org/wiki/Megabyte"><FONT color=#0000ff face=Calibri>megabytes</FONT></A><FONT face=Calibri>&nbsp;of data using only 100 megabytes of RAM:<o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 36pt; TEXT-INDENT: -18pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-bidi-font-family: Calibri; mso-bidi-theme-font: minor-latin"><SPAN style="mso-list: Ignore"><FONT face=Calibri>1.</FONT><SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Read 100 MB of the data in main memory and sort by some conventional method, like&nbsp;</FONT><A title=Quicksort href="http://en.wikipedia.org/wiki/Quicksort"><FONT color=#0000ff face=Calibri>quicksort</FONT></A><FONT face=Calibri>. <o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 36pt; TEXT-INDENT: -18pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-bidi-font-family: Calibri; mso-bidi-theme-font: minor-latin"><SPAN style="mso-list: Ignore"><FONT face=Calibri>2.</FONT><SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Write the sorted data to disk. <o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 36pt; TEXT-INDENT: -18pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-bidi-font-family: Calibri; mso-bidi-theme-font: minor-latin"><SPAN style="mso-list: Ignore"><FONT face=Calibri>3.</FONT><SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Repeat steps 1 and 2 until all of the data is in sorted 100 MB chunks (there are 900MB / 100MB = 9 chunks), which now need to be merged into one single output file. <o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 36pt; TEXT-INDENT: -18pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-bidi-font-family: Calibri; mso-bidi-theme-font: minor-latin"><SPAN style="mso-list: Ignore"><FONT face=Calibri>4.</FONT><SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Read the first 10 MB (= 100MB / (9 chunks + 1)) of each sorted chunk into input buffers in main memory and allocate the remaining 10 MB for an output buffer. (In practice, it might provide better performance to make the output buffer larger and the input buffers slightly smaller.) <o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 36pt; TEXT-INDENT: -18pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-bidi-font-family: Calibri; mso-bidi-theme-font: minor-latin"><SPAN style="mso-list: Ignore"><FONT face=Calibri>5.</FONT><SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Perform a 9-way&nbsp;</FONT><A title="Merge algorithm" href="http://en.wikipedia.org/wiki/Merge_algorithm"><FONT color=#0000ff face=Calibri>merge</FONT></A><FONT face=Calibri>&nbsp;and store the result in the output buffer. Whenever the output buffer fills, write it to the final sorted file and empty it. Whenever any of the 9 input buffers empties, fill it with the next 10 MB of its associated 100 MB sorted chunk until no more data from the chunk is available. This is the key step that makes external merge sort work externally -- because the merge algorithm only makes one pass sequentially through each of the chunks, each chunk does not have to be loaded completely; rather, sequential parts of the chunk can be loaded as needed.<o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><FONT face=Calibri><B><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt">Additional passes</SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt">[<A title="Edit section: Additional passes" href="http://en.wikipedia.org/w/index.php?title=External_sorting&amp;action=edit&amp;section=2"><FONT color=#0000ff>edit</FONT></A>]<B><o:p></o:p></B></SPAN></FONT></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Above example shows a two-pass sort: a sort pass followed by a merge pass. Note that we had one merge pass that merged all the chunks at once, rather than in regular merge sort, where we merge two chunks at each step, and take&nbsp;</FONT><SPAN style="mso-no-proof: yes"><?xml:namespace prefix = "v" ns = "urn:schemas-microsoft-com:vml" /><v:shapetype id=_x0000_t75 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"><FONT face=Calibri> <v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"></v:path><o:lock v:ext="edit" aspectratio="t"></o:lock></FONT></v:shapetype><v:shape id=&#22270;&#29255;_x0020_2 style="HEIGHT: 13.5pt; WIDTH: 30.75pt; VISIBILITY: visible; mso-wrap-style: square" o:spid="_x0000_i1025" type="#_x0000_t75" alt="\log n"><v:imagedata src="file:///C:\Users\DONPOP~1\AppData\Local\Temp\msohtmlclip1\01\clip_image001.png" o:title="log n"></v:imagedata></v:shape></SPAN><FONT face=Calibri>&nbsp;merge passes total. The reason for this is that every merge pass requires reading and writing&nbsp;<I>every value</I>&nbsp;in the array from and to disk once. Disk access is usually slow, and so reads and writes should be avoided as much as possible.<o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>However, there is a trade-off with using fewer merge passes. As the number of chunks increases, the amount of data we can read from each chunk at a time during the merge process decreases. For sorting, say, 50 GB in 100 MB of RAM, using a single merge pass isn't efficient: the disk seeks required to fill the input buffers with data from each of the 500 chunks (we read 100MB / 501 ~ 200KB from each chunk at a time) take up most of the sort time. Using two merge passes solves the problem. Then the sorting process might look like this:<o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 36pt; TEXT-INDENT: -18pt; mso-list: l1 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-bidi-font-family: Calibri; mso-bidi-theme-font: minor-latin"><SPAN style="mso-list: Ignore"><FONT face=Calibri>1.</FONT><SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Run the initial chunk-sorting pass as before. <o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 36pt; TEXT-INDENT: -18pt; mso-list: l1 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-bidi-font-family: Calibri; mso-bidi-theme-font: minor-latin"><SPAN style="mso-list: Ignore"><FONT face=Calibri>2.</FONT><SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Run a first merge pass combining 25 chunks at a time, resulting in 20 larger sorted chunks. <o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt 36pt; TEXT-INDENT: -18pt; mso-list: l1 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Calibri; mso-fareast-theme-font: minor-latin; mso-bidi-font-family: Calibri; mso-bidi-theme-font: minor-latin"><SPAN style="mso-list: Ignore"><FONT face=Calibri>3.</FONT><SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Run a second merge pass to merge the 20 larger sorted chunks.<o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Like in-memory sorts, efficient external sorts require&nbsp;</FONT><A title="Big O notation" href="http://en.wikipedia.org/wiki/Big_O_notation"><FONT color=#0000ff face=Calibri>O</FONT></A><FONT face=Calibri>(<I>n</I>&nbsp;log&nbsp;<I>n</I>) time: exponential increases in data size require linear increases in the number of passes. If one makes liberal use of the gigabytes of RAM provided by modern computers, the logarithmic factor grows very slowly: under reasonable assumptions, one could sort at least 500 GB of data using 1 GB of main memory before a third pass became advantageous, and could sort many times that before a fourth pass became useful.<SUP><A href="http://en.wikipedia.org/wiki/External_sorting#cite_note-3"><FONT color=#0000ff>[3]</FONT></A></SUP><o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Doubling the memory dedicated to sorting both allows the same amount of data to be sorted using half as many chunks&nbsp;<I>and</I>&nbsp;allows the merge phase to do half as many buffer-filling reads during the merging phase, potentially reducing the number of seeks required by about three-quarters. So, dedicating more RAM to sorting can be an effective way to increase speed if it allows reducing the number of passes, or if disk seek time accounts for a substantial part of sorting time.<o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><FONT face=Calibri><B><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt">Tuning performance</SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt">[<A title="Edit section: Tuning performance" href="http://en.wikipedia.org/w/index.php?title=External_sorting&amp;action=edit&amp;section=3"><FONT color=#0000ff>edit</FONT></A>]<B><o:p></o:p></B></SPAN></FONT></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>The&nbsp;</FONT><A href="http://sortbenchmark.org/"><FONT color=#0000ff face=Calibri>Sort Benchmark</FONT></A><FONT face=Calibri>, created by computer scientist&nbsp;</FONT><A title="Jim Gray (computer scientist)" href="http://en.wikipedia.org/wiki/Jim_Gray_(computer_scientist)"><FONT color=#0000ff face=Calibri>Jim Gray</FONT></A><FONT face=Calibri>, compares external sorting algorithms implemented using finely tuned hardware and software. Winning implementations use several techniques:<o:p></o:p></FONT></SPAN></P>
<UL style="MARGIN-TOP: 0cm" type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level1 lfo3; tab-stops: list 36.0pt"><FONT face=Calibri><B><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt">Using parallelism</SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"> <o:p></o:p></SPAN></FONT>
<UL style="MARGIN-TOP: 0cm" type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level2 lfo3; tab-stops: list 72.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Multiple disk drives can be used in parallel in order to improve sequential read and write speed. This can be a very cost-efficient improvement: a Sort Benchmark winner in the cost-centric Penny Sort category uses six hard drives in an otherwise midrange machine.<SUP><A href="http://en.wikipedia.org/wiki/External_sorting#cite_note-4"><FONT color=#0000ff>[4]</FONT></A></SUP> <o:p></o:p></FONT></SPAN>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level2 lfo3; tab-stops: list 72.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Sorting software can use&nbsp;</FONT><A title="Thread (computer science)" href="http://en.wikipedia.org/wiki/Thread_(computer_science)"><FONT color=#0000ff face=Calibri>multiple threads</FONT></A><FONT face=Calibri>, to speed up the process on modern multicore computers. <o:p></o:p></FONT></SPAN>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level2 lfo3; tab-stops: list 72.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Software can use&nbsp;</FONT><A title="Asynchronous I/O" href="http://en.wikipedia.org/wiki/Asynchronous_I/O"><FONT color=#0000ff face=Calibri>asynchronous I/O</FONT></A><FONT face=Calibri>&nbsp;so that one run of data can be sorted or merged while other runs are being read from or written to disk. <o:p></o:p></FONT></SPAN>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level2 lfo3; tab-stops: list 72.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Multiple machines connected by fast network links can each sort part of a huge dataset in parallel.<SUP><A href="http://en.wikipedia.org/wiki/External_sorting#cite_note-5"><FONT color=#0000ff>[5]</FONT></A></SUP><o:p></o:p></FONT></SPAN></LI></UL>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level1 lfo3; tab-stops: list 36.0pt"><FONT face=Calibri><B><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt">Increasing hardware speed</SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"> <o:p></o:p></SPAN></FONT>
<UL style="MARGIN-TOP: 0cm" type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level2 lfo3; tab-stops: list 72.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Using more RAM for sorting can reduce the number of disk seeks and avoid the need for more passes. <o:p></o:p></FONT></SPAN>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level2 lfo3; tab-stops: list 72.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Fast external memory, like 15K RPM disks or&nbsp;</FONT><A title="Solid-state drives" href="http://en.wikipedia.org/wiki/Solid-state_drives"><FONT color=#0000ff face=Calibri>solid-state drives</FONT></A><FONT face=Calibri>, can speed sorts (but adds substantial costs proportional to the data size). <o:p></o:p></FONT></SPAN>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level2 lfo3; tab-stops: list 72.0pt"><FONT face=Calibri><I><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt">Many</SPAN></I><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt">&nbsp;other factors can affect hardware's maximum sorting speed: CPU speed and number of cores, RAM access latency, input/output bandwidth, disk read/write speed, disk seek time, and others. "Balancing" the hardware to minimize bottlenecks is an important part of designing an efficient sorting system. <o:p></o:p></SPAN></FONT>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level2 lfo3; tab-stops: list 72.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Cost-efficiency as well as absolute speed can be critical, especially in cluster environments where lower node costs allow purchasing more nodes.<o:p></o:p></FONT></SPAN></LI></UL>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level1 lfo3; tab-stops: list 36.0pt"><FONT face=Calibri><B><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt">Increasing software speed</SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"> <o:p></o:p></SPAN></FONT>
<UL style="MARGIN-TOP: 0cm" type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level2 lfo3; tab-stops: list 72.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Some Sort Benchmark entrants use a variation on&nbsp;</FONT><A title="Radix sort" href="http://en.wikipedia.org/wiki/Radix_sort"><FONT color=#0000ff face=Calibri>radix sort</FONT></A><FONT face=Calibri>&nbsp;for the first phase of sorting: they separate data into one of many "bins" based on the beginning of its value. Sort Benchmark data is random and especially well-suited to this optimization. <o:p></o:p></FONT></SPAN>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level2 lfo3; tab-stops: list 72.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Compacting the input, intermediate files, and output can reduce time spent on I/O, but is not allowed in the Sort Benchmark. <o:p></o:p></FONT></SPAN>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level2 lfo3; tab-stops: list 72.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Because the Sort Benchmark sorts long (100-byte) records using short (10-byte) keys, sorting software sometimes rearranges the keys separately from the values to reduce memory I/O volume.<o:p></o:p></FONT></SPAN></LI></UL></LI></UL></BODY>