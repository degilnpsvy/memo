<CENTER style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><B>Hardware Level VGA and SVGA Video Programming Information Page</B></CENTER>
<CENTER style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Accessing the VGA Display Memory&nbsp; 
<HR width="100%">
</CENTER>
<UL style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<LI><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#intro">Introduction</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>-- gives an overview of the VGA display memory. 
<LI><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#detect">Detecting the Amount of Display Memory on the Adapter</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>-- details how to determine the amount of memory present on the VGA. 
<LI><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#mapping">Mapping of Display Memory into CPU Address Space</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>-- details how to control the location and size of the memory aperture. 
<LI><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#address">Host Address to Display Address Translation</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>-- detail how the VGA hardware maps a host access to a display memory access 
<LI><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#manip">Manipulating Display Memory</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>-- Details on reading and writing to VGA memory 
<UL>
<LI><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#read">Reading from Display Memory</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>-- Details the hardware mechanisms used when reading display memory. 
<LI><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#write">Writing to Display Memory</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>-- Details the hardware mechanisms used when writing display memory.</LI></UL></LI></UL><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" name=intro></A><B style="FONT-SIZE: medium; FONT-FAMILY: Simsun; FONT-VARIANT: normal; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Introduction</B><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><BR style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT class=extract>The standard VGA hardware contains up to 256K of onboard display memory.</FONT> While it would seem logical that this memory would be directly available to the processor, this is not the case. <FONT class=extract>The host CPU accesses the display memory through a window of up to 128K located in the high memory area. (Note that many SVGA chipsets provide an alternate method of accessing video memory directly, called a Linear Frame Buffer.)</FONT> <FONT class=extract>Thus in order to be able to access display memory you must deal with registers that control the mapping into host address space.</FONT> To further complicate things, the VGA hardware provides support for memory models similar to that used by the monochrome, CGA, EGA, and MCGA adapters. In addition, due to the way the VGA handles 16 color modes, additional hardware is included that can speed access immensely. Also, hardware is present that allows the programer to rapidly copy data from one area of display memory to another. While it is quite complicated to understand, learning to utilize the VGA's hardware at a low level can vastly improve performance. Many game programmers utilize the BIOS mode 13h, simply because it offers the simplest memory model and doesn't require having to deal with the VGA's registers to draw pixels. However, this same decision limits them from being able to use the infamous X modes, or higher resolution modes.</SPAN> 
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><A name=detect></A><B>Detecting the Amount of Display Memory on the Adapter</B><SPAN class=Apple-converted-space>&nbsp;</SPAN><BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN></B>Most VGA cards in existence have 256K on board; however there is the possibility that some VGA boards have less. To actually determine further if the card has 256K one must actually write to display memory and read back values. If RAM is not present in a location, then the value read back will not equal the value written. It is wise to utilize multiple values when doing this, as the undefined result may equal the value written. Also, the card may alias addresses, causing say the same 64K of RAM to appear 4 times in the 256K address space, thus it is wise to change an address and see if the change is reflected anywhere else in display memory. In addition, the card may buffer one location of video memory in the chipset, making it appear that there is RAM at an address where there is none present, so you may have to read or write to a second location to clear the buffer. Not that if the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/seqreg.htm#04">Extended Memory</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>field is not set to 1, the adapter appears to only have 64K onboard, thus this bit should be set to 1 before attempting to determine the memory size.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><A name=mapping></A><B>Mapping of Display Memory into CPU Address Space</B><SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT class=extract>The first element that defines this mapping is whether or not the VGA decodes accesses from the CPU. This is controlled by the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/extreg.htm#3CCR3C2W"><FONT class=extract>RAM Enable</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field.</FONT> If display memory decoding is disabled, then the VGA hardware ignores writes to its address space. <FONT class=extract>The address range that the VGA hardware decodes is based upon the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#06"><FONT class=extract>Memory Map Select</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. The following table shows the address ranges in absolute 32-bit form decoded for each value of this field:</FONT></P>
<UL style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<LI><FONT class=extract>00 -- A0000h-BFFFFh -- 128K </FONT>
<LI><FONT class=extract>01 -- A0000h-AFFFFh -- 64K </FONT>
<LI><FONT class=extract>10 -- B0000h-B7FFFh -- 32K </FONT>
<LI><FONT class=extract>11 -- B8000h-BFFFFh -- 32K</FONT></LI></UL><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Note -- It would seem that by setting the<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#06">Memory Map Select</A><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN>field to 00 and then using planar memory access that you could gain access to more than 256K of memory on an SVGA card. However, I have found that some cards simply mirror the first 64K twice within the 128K address space. This memory map is intended for use in the Chain Odd/Even modes, eliminating the need to use the Odd/Even Page Select field. Also I have found that MS-DOS memory managers don't like this very much and are likely to lock up the system if configured to use the area from B0000h-B7FFFh for loading device drivers high.</SPAN> 
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><A name=address></A><B>Host Address to Display Address Translation</B><SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The most complicated part of accessing display memory involves the translation between a host address and a display memory address. Internally, the VGA has a 64K 32-bit memory locations. These are divided into four 64K bit planes. Because the VGA was designed for 8 and 16 bit bus systems, and due to the way the Intel chips handle memory accesses, it is impossible for the host CPU to access the bit planes directly, instead relying on I/O registers to make part of the memory accessible. The most straightforward display translation is where a host access translates directly to a display memory address. What part of the particular 32-bit memory location is dependent on certain registers and is discussed in more detail in Manipulating Display Memory below. <FONT class=extract>The VGA has three modes for addressing, Chain 4, Odd/Even mode, and normal mode:</FONT></P>
<UL style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<LI><FONT class=extract>Chain 4: This mode is used for MCGA emulation in the 320x200 256-color mode. The address is mapped to memory MOD 4 (shifted right 2 places.)</FONT></LI></UL><B style="FONT-SIZE: medium; FONT-FAMILY: Simsun; FONT-VARIANT: normal; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">&lt;More to be added here.&gt;</B><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"></SPAN> 
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><A name=manip></A><B>Manipulating Display Memory</B><SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The VGA hardware contains hardware that can perform bit manipulation on data and allow the host to operate on all four display planes in a single operation. These features are fairly straightforward, yet complicated enough that most VGA programmers choose to ignore them. This is unfortunate, as properly utilization of these registers is crucial to programming the VGA's 16 color modes. Also, knowledge of this functionality can in many cases enhance performance in other modes including text and 256 color modes. <FONT class=extract>In addition to normal read and write operations the VGA hardware provides enhanced operations such as the ability to perform rapid comparisons, to write to multiple planes simultaneously, and to rapidly move data from one area of display memory to another, faster logical operations (AND/OR/XOR) as well as bit rotation and masking.</FONT></P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><A name=read></A><B>Reading from Display Memory</B><SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The VGA hardware has two read modes, selected by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#05">Read Mode</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. The first is a straightforward read of one or more consecutive bytes (depending on whether a byte, word or dword operation is used) from one bit plane. The value of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#04">Read Map Select</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>field is the page that will be read from. The second read mode returns the result of a comparison of the display memory and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#02">Color Compare</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>field and masked by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#07">Color Don't Care</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. This mode which can be used to rapidly perform up to 32 pixel comparisons in one operation in the planar video modes, helpful for the implementation of fast flood-fill routines. A read from display memory also loads a 32 bit latch register, one byte from each plane. This latch register, is not directly accessible from the host CPU; rather it can be used as data for the various write operations. The latch register retains its value until the next read and thus may be used with more than one write operation.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT class=extract>The two read modes, simply called Read Mode 0-1 based on the value of the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#05"><FONT class=extract>Read Mode</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field are:</FONT></P>
<UL style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<LI><FONT class=extract><B>Read Mode 0:</B><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Read Mode 0 is used to read one byte from a single plane of display memory. The plane read is the value of the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#04"><FONT class=extract>Read Map Select</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. In order to read a single pixel's value in planar modes, four read operations must be performed, one for each plane. If more than one bytes worth of data is being read from the screen it is recommended that you read it a plane at a time instead of having to perform four I/O operations to the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#04"><FONT class=extract>Read Map Select</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field for each byte, as this will allow the use of faster string copy instructions and reduce the number I/O operations performed. </FONT>
<LI><FONT class=extract><B>Read Mode 1:</B><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Read Mode 1 is used to perform comparisons against a reference color, specified by the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#02"><FONT class=extract>Color Compare</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. If a bit is set in the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#07"><FONT class=extract>Color Don't Care</FONT></A><FONT class=extract>field then the corresponding color plane is considered for by the comparison, otherwise it is ignored. Each bit in the returned result represents one comparison between the reference color from the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#02"><FONT class=extract>Color Compare</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field, with the bit being set if the comparison is true. This mode is mainly used by flood fill algorithms that fill an area of a specific color, as it requires 1/4 the number of reads to determine the area that needs to be filled in addition to the additional work done by the comparison. Also an efficient "search and replace" operation that replaces one color with another can be performed when this mode is combined with Write Mode 3.</FONT></LI></UL><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" name=write></A><B style="FONT-SIZE: medium; FONT-FAMILY: Simsun; FONT-VARIANT: normal; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Writing to Display Memory</B><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><BR style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The VGA has four write modes, selected by the<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#05">Write Mode</A><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. This controls how the write operation and host data affect the display memory. The VGA, depending on the<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#05">Write Mode</A><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN>field performs up to five distinct operations before the write affects display memory. Note that not all write modes use all of pipelined stages in the write hardware, and others use some of the pipelined stages in different ways.<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><BR style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The first of these allows the VGA hardware to perform a bitwise rotation on the data written from the host. This is accomplished via a barrel rotator that rotates the bits to the right by the number of positions specified by the<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#03">Rotate Count</A><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. This performs the same operation as the 8086 ROR instruction, shifting bits to the right (from bit 7 towards bit 0.) with the bit shifted out of position 0 being "rolled" into position 7. Note that if the rotate count field is zero then no rotation is performed.<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><BR style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The second uses the<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#01">Enable Set/Reset</A><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#00">Set/Reset</A><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN>fields. These fields can provide an additional data source in addition to the data written and the latched value from the last read operation performed. Normally, data from the host is replicated four times, one for each plane. In this stage, a 1 bit in the<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#01">Enable Set/Reset</A><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN>field will cause the corresponding bit plane to be replaced by the bit value in the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#00">Set/Reset</A><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN>field location, replicated 8 times to fill the byte, giving it either the value 00000000b or 11111111b. If the<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#01">Enable Set/Reset</A><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN>field for a given plane is 0 then the host data byte is used instead. Note that in some write modes, the host data byte is used for other purposes, and the set/reset register is always used as data, and in other modes the set/reset mechanism is not used at all.<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><BR style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The third stage performs logical operations between the host data, which has been split into four planes and is now 32-bits wide, and the latch register, which provides a second 32-bit operand. The<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#03">Logical Operation</A><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN>field selects the operation that this stage performs. The four possibilities are: NOP (the host data is passed directly through, performing no operation), AND (the data is logically ANDed with the latched data.), OR (the data is logically ORed with the latched data), and XOR (the data is logically XORed with the latched data.) The result of this operation is then passed on. whilst the latched data remains unchanged, available for use in successive operations.<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><BR style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In the fourth stage, individual bits may be selected from the result or copied from the latch register. Each bit of the<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#08">Bit Mask</A><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN>field determines whether the corresponding bits in each plane are the result of the previous step or are copied directly from the latch register. This allows the host CPU to modify only a single bit, by first performing a dummy read to fill the latch register<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><BR style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The fifth stage allows specification of what planes, if any a write operation affects, via the<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/seqreg.htm#02">Memory Plane Write Enable</A><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. The four bits in this field determine whether or not the write affects the corresponding plane If the a planes bit is 1 then the data from the previous step will be written to display memory, otherwise the display buffer location in that plane will remain unchanged.<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><BR style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT class=extract>The four write modes, of which the current one is set by writing to the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#05"><FONT class=extract>Write Mode</FONT></A><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field The four write modes, simply called write modes 0-3, based on the value of the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT></SPAN><A style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px" href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#05"><FONT class=extract>Write Mode</FONT></A><FONT class=extract><SPAN style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: none; COLOR: rgb(0,0,0); FONT: medium Simsun; DISPLAY: inline !important; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><SPAN class=Apple-converted-space>&nbsp;</SPAN>field are:</SPAN> </FONT>
<UL style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<LI><FONT class=extract><B>Write Mode 0:</B><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Write Mode 0 is the standard and most general write mode. While the other write modes are designed to perform a specific task, this mode can be used to perform most tasks as all five operations are performed on the data. The data byte from the host is first rotated as specified by the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#03"><FONT class=extract>Rotate Count</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field, then is replicated across all four planes. Then the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#01"><FONT class=extract>Enable Set/Reset</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field selects which planes will receive their values from the host data and which will receive their data from that plane's<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#00"><FONT class=extract>Set/Reset</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field location. Then the operation specified by the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#03"><FONT class=extract>Logical Operation</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field is performed on the resulting data and the data in the read latches. The<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#08"><FONT class=extract>Bit Mask</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field is then used to select between the resulting data and data from the latch register. Finally, the resulting data is written to the display memory planes enabled in the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/seqreg.htm#02"><FONT class=extract>Memory Plane Write Enable</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. </FONT>
<LI><FONT class=extract><B>Write Mode 1:</B><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Write Mode 1 is used to transfer the data in the latches register directly to the screen, affected only by the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/seqreg.htm#02"><FONT class=extract>Memory Plane Write Enable</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. This can facilitate rapid transfer of data on byte boundaries from one area of video memory to another or filling areas of the display with a pattern of 8 pixels. When Write Mode 0 is used with the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#08"><FONT class=extract>Bit Mask</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field set to 00000000b the operation of the hardware is identical to this mode, although it is entirely possible that this mode is faster on some cards. </FONT>
<LI><FONT class=extract><B>Write Mode 2:</B><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Write Mode 2 is used to unpack a pixel value packed into the lower 4 bits of the host data byte into the 4 display planes. In the byte from the host, the bit representing each plane will be replicated across all 8 bits of the corresponding planes. Then the operation specified by the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#03"><FONT class=extract>Logical Operation</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field is performed on the resulting data and the data in the read latches. The<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#08"><FONT class=extract>Bit Mask</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field is then used to select between the resulting data and data from the latch register. Finally, the resulting data is written to the display memory planes enabled in the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/seqreg.htm#02"><FONT class=extract>Memory Plane Write Enable</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. </FONT>
<LI><FONT class=extract><B>Write Mode 3:</B><BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN></B>Write Mode 3 is used when the color written is fairly constant but the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#08"><FONT class=extract>Bit Mask</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field needs to be changed frequently, such as when drawing single color lines or text. The value of the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#00"><FONT class=extract>Set/Reset</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field is expanded as if the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#01"><FONT class=extract>Enable Set/Reset</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field were set to 1111b, regardless of its actual value. The host data is first rotated as specified by the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#03"><FONT class=extract>Rotate Count</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field, then is ANDed with the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#08"><FONT class=extract>Bit Mask</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. The resulting value is used where the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#08"><FONT class=extract>Bit Mask</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field normally would be used, selecting data from either the expansion of the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/graphreg.htm#00"><FONT class=extract>Set/Reset</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field or the latch register. Finally, the resulting data is written to the display memory planes enabled in the<SPAN class=Apple-converted-space>&nbsp;</SPAN></FONT><A href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/seqreg.htm#02"><FONT class=extract>Memory Plane Write Enable</FONT></A><FONT class=extract><SPAN class=Apple-converted-space>&nbsp;</SPAN>field.</FONT></LI></UL>