<SPAN lang=EN style="FONT-SIZE: 15.5pt; FONT-FAMILY: 'Arial','sans-serif'; COLOR: #252525; mso-bidi-font-size: 10.5pt; mso-ansi-language: EN">One merit of memory-mapped I/O is that, by discarding the extra complexity that port I/O brings, a CPU requires less internal logic and is thus cheaper, faster, easier to build, consumes less power and can be physically smaller; this follows the basic tenets of<SPAN class=apple-converted-space>&nbsp;</SPAN><A title=RISC href="http://en.wikipedia.org/wiki/RISC"><SPAN style="COLOR: #0b0080">reduced instruction set computing</SPAN></A>, and is also advantageous in<SPAN class=apple-converted-space>&nbsp;</SPAN><A title="Embedded system" href="http://en.wikipedia.org/wiki/Embedded_system"><SPAN style="COLOR: #0b0080">embedded systems</SPAN></A>. The other advantage is that, because regular memory instructions are used to address devices, all of the CPU's addressing modes are available for the I/O as well as the memory, and instructions that perform an<SPAN class=apple-converted-space>&nbsp;</SPAN><A title="Arithmetic logic unit" href="http://en.wikipedia.org/wiki/Arithmetic_logic_unit"><SPAN style="COLOR: #0b0080">ALU</SPAN></A><SPAN class=apple-converted-space>&nbsp;</SPAN>operation directly on a memory operand&nbsp;&#8211; loading an operand from a memory location, storing the result to a memory location, or both, can be used with I/O device registers as well. In contrast, port-mapped I/O instructions are often very limited, often providing only for simple load and store operations between CPU registers and I/O ports, so that, for example, to add a constant to a port-mapped device register would require three instructions: read the port to a CPU register, add the constant to the CPU register, and write the result back to the port.</SPAN>