Memory management<BR>Prev &nbsp;Chapter 2. DRM Internals&nbsp; Next<BR>Memory management 
<P></P>
<P>The Translation Table Manager (TTM)<BR>The Graphics Execution Manager (GEM)<BR>VMA Offset Manager<BR>PRIME Buffer Sharing<BR>PRIME Function References<BR>DRM MM Range Allocator<BR>DRM MM Range Allocator Function References</P>
<P>Modern Linux systems require large amount of graphics memory to store frame buffers, textures, vertices and other graphics-related data. Given the very dynamic nature of many of that data, managing graphics memory efficiently is thus crucial for the graphics stack and plays a central role in the DRM infrastructure.</P>
<P>The DRM core includes two memory managers, namely Translation Table Maps (TTM) and Graphics Execution Manager (GEM). TTM was the first DRM memory manager to be developed and tried to be a one-size-fits-them all solution. It provides a single userspace API to accommodate the need of all hardware, supporting both Unified Memory Architecture (UMA) devices and devices with dedicated video RAM (i.e. most discrete video cards). This resulted in a large, complex piece of code that turned out to be hard to use for driver development.</P>
<P>GEM started as an Intel-sponsored project in reaction to TTM's complexity. Its design philosophy is completely different: instead of providing a solution to every graphics memory-related problems, GEM identified common code between drivers and created a support library to share it. GEM has simpler initialization and execution requirements than TTM, but has no video RAM management capabilities and is thus limited to UMA devices.<BR>Prev &nbsp;Up&nbsp; Next<BR>drm_dev_set_unique &nbsp;Home&nbsp; drm_gem_object_init