<H1 style="BACKGROUND: white; MARGIN: 6pt 0cm"><SPAN lang=EN-US style="FONT-SIZE: 28pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 24.0pt">CMake: The Cross Platform Build System</SPAN></H1>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>Here's an article I wrote for the July 2006 issue of Linux Magazine. This article is Copyright (c) 2006 by Tanner Lovelace, All Rights Reserved.</FONT></SPAN></P>
<DIV class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" align=center><SPAN lang=EN-US style="FONT-SIZE: 14.5pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>
<HR style="WIDTH: 933.95pt" align=center width=1245 color=#336699 noShade SIZE=2>
</FONT></SPAN></DIV>
<H3 style="MARGIN: 2.4pt 0cm"><I><SPAN lang=EN-US style="FONT-SIZE: 17.5pt; COLOR: #002244; mso-bidi-font-size: 13.5pt"><FONT face=&#23435;&#20307;>Abstract:</FONT></SPAN></I></H3>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>CMake is a portable build system: Create a single source definition and build your code on one or many platforms. Learn how to use CMake and see how KDE uses the tool for the project&#8217;s next generation build system.</FONT></SPAN></P>
<H2 style="MARGIN: 3.6pt 0cm 1.2pt"><A name=cutid1></A><SPAN lang=EN-US style="FONT-WEIGHT: normal; FONT-SIZE: 22pt; COLOR: #003366; mso-bidi-font-size: 18.0pt"><FONT face=&#23435;&#20307;>CMake: The Cross Platform Build System</FONT></SPAN></H2>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>How many times have you downloaded a source tarball only to find that your system&#8217;s version of autotools fails to work? While autotools is quite capable, variants abound, many of which are simply incompatible, and fixing autotools requires knowledge of at least make, m4, and shell scripting. Moreover, autotools can grow so complex that additional tools, such as automake, are required just to manage the intricacies. Still, many open source projects use autotools as a build system.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>However, some projects have started to switch to other tools, such as Cross Platform Make, or CMake, which has several interesting features not found in autotools. Like autotools, CMake can generate a Unix Makefile. Unlike autotools, CMake can also create KDevelop, Visual Studio, and (Apple) XCode project files from the same configuration file. Furthermore, both configuration and build commands are specified in one location and handled entirely by CMake. Because of these and other advantages over autotools, CMake was recently chosen as the configuration and build system for KDE4.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>While many Linux distributions offer CMake, the version included is probably out of date. A lot of new CMake features have been added recently, and you should download the latest 2.4. x version from http://www.cmake.org/HTML/Download.html.<SPAN class=apple-converted-space>&nbsp;</SPAN>(KDE4 requires at least version 2.4.1. As the magazine went to press, version 2.4.2 had just been released.)</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>After you download the newest release, un-tar it in a temporary directory. CMake uses itself as a build system, so the application must be bootstrapped before you can compile it. To bootstrap, compile, and install CMake, type these commands:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>$ ./bootstrap</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>$ make</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>$ sudo make install</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>Without any options, CMake is installed in /usr/local/. If you want to install to another directory, add &#8211;&#8211;prefix= /other/ directory to the bootstrap command.</FONT></SPAN></P>
<H2 style="MARGIN: 3.6pt 0cm 1.2pt"><SPAN lang=EN-US style="FONT-WEIGHT: normal; FONT-SIZE: 22pt; COLOR: #003366; mso-bidi-font-size: 18.0pt"><FONT face=&#23435;&#20307;>Using CMake</FONT></SPAN></H2>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>Once CMake is installed, it&#8217;s ready for use. To begin, you need a project that uses CMake. Since CMake uses CMake to build itself, let&#8217;s use it. Create a new temporary directory, change to that directory, and un-tar the CMake sources anew.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>One of the most important concepts in CMake is out of source builds. While CMake allows source and build directories to be the same, the practice isn&#8217;t recommended. Instead, it&#8217;s better to separate the source and build directories so a single source directory can serve as the basis for different types of builds, such as so-called "debug" and "non-debug" builds, and even a number of builds, one for each target platform.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>With that in mind, create a directory for your build files. From within that directory type:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>$ cmake /path/to/CMAKE/SOURCE</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>This configures CMake and generates Unix Makefiles that can be used to compile CMake using normal make commands. If you prefer to use an integrated development environment (IDE) like KDevelop, CMake supports that too. To generate KDevelop project files for CMake, type this command:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>$ cmake &#8211;G KDevelop3 /path/to/CMAKE/SOURCE</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>This configures CMAKE and generates a KDevelop project file that can be loaded and used directly.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>If you prefer not to use the command-line at all, CMake also provides a curses interface that will let you interactively edit all available options. It&#8217;s called ccmake and you run it exactly like CMake. To try ccmake, remain in the build directory and run:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>$ ccmake /path/to/CMAKE/SOURCE</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>This launches a curses interface to all of the configuration variables. If you run ccmake before CMake, the interface is rather bare. There&#8217;s nothing to worry about, though: CMake only aggregates all options from the source tree into a single cache file after the first configuration.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>So, let&#8217;s configure the tree. Press c to configure. You&#8217;ll see some messages on the status line just above the CMake version banner, and shortly after, you should see more variables on the screen. If the display still seems rather sparse, press t to switch to advanced mode, which shows you all available variables. Use the Up and Down (arrow) keys to traverse the list, and hit Enter if you want to modify any.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>One variable that&#8217;s commonly modified is CMAKE_INSTALL_PREFIX. As you might suspect, this variable determines the base directory of where a project is installed. By default, it points to /usr/local, but let&#8217;s change it to be something else. Center the cursor on the current value for CMAKE_INSTALL_PREFIX and press Enter. Use the arrow keys to go to the end of the current value, then press Backspace repeatedly to delete it. In it&#8217;s place, type /opt/CMAKE. Press Enter to record the new value. Press c to configure again, then press g to generate the Makefiles. Now, when you type make install, /opt/CMAKE is the install prefix.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>If you subsequently want to change the installation prefix from the command-line, use this command:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>$ cmake &#8211;DCMAKE_INSTALL_PREFIX=/opt/CMAKE</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>This tells CMake to set CMAKE_INSTALL_PREFIX to /opt/CMAKE.</FONT></SPAN></P>
<H2 style="MARGIN: 3.6pt 0cm 1.2pt"><SPAN lang=EN-US style="FONT-WEIGHT: normal; FONT-SIZE: 22pt; COLOR: #003366; mso-bidi-font-size: 18.0pt"><FONT face=&#23435;&#20307;>Creating Projects with CMake</FONT></SPAN></H2>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>So, how do you use CMake for your own project?</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>CMake stores its commands in a file named CMakeLists.txt. Here&#8217;s a CMakeLists.txt for the familiar "Hello, World! " C program:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>PROJECT(hello C)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>ADD_EXECUTABLE(hello hello.c)</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>That&#8217;s it. The first line specifies a C language project called hello. The second line creates an executable called hello from a source file named hello.c. If you have more than one source file, just add the files after hello.c. You can build your new project with the same commands used to build CMake.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>Now let&#8217;s try something a bit more complicated. Suppose you have a library of code that you want to build and link with your "Hello, World!" program. The CMake code for that would be:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>PROJECT (hello C)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>ADD_LIBRARY(hellolib STATIC hellolib.c)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>ADD_EXECUTABLE(hello hello.c)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>TARGET_LINK_LIBRARIES(hello hellolib)</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>This short file creates a statically linked hellolib library from the file hellolib.c, and links it to the hello program. You can also specify system libraries in the TARGET_LINK_LIBRARIES command.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>If shorthand was the extent of what CMake offered, it wouldn&#8217;t offer much advantage over straight Makefiles. But CMake also gives you full control over any options your program may need. As an example, consider a project that optionally includes a component that communiates via USB and allows the user, at compile time, to specify whether to include that component or not. The CMakeLists.txt file to do that looks like this:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>PROJECT(myproject)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>OPTION(WITH_USB "Include our USB component" OFF)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>SET(SRCS file1.c file2.c file3.c)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>IF(WITH_USB)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;><FONT class=extract><SPAN style="mso-spacerun: yes">&nbsp; </SPAN>SET(SRCS ${SRCS} usbfile1.c usbfile2.c)</FONT></FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>ENDIF(WITH_USB)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>ADD_EXECUTABLE(myproject ${SRCS})</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>The OPTION(...) line creates a parameter WITH_USB and set its default value to OFF. CMake also includes a help string to describe what the option does. Based on the value of WITH_USB, the variable SRCS either includes or excludes the two USB-related files usbfile1.c and usbfile2.c. SRCS is then passed to the ADD_EXECUTABLE call to define the program&#8217;s source files. To include USB support, simply enable WITH_USB like this:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>$ cmake &#8211;DWITH_USB=ON /path/to/source/files</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>Let&#8217;s go a little bit further and make the optional USB support a library in a subdirectory. The new CMakeLists.txt file would look like this:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>PROJECT(myproject)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>OPTION(WITH_USB "Include our USB component" OFF)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>SET(SRCS file1.c file2.c file3.c)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>ADD_EXECUTABLE(myproject ${SRCS})</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>IF(WITH_USB)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;><FONT class=extract><SPAN style="mso-spacerun: yes">&nbsp; </SPAN>ADD_DIRECTORY(usblib)</FONT></FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;><FONT class=extract><SPAN style="mso-spacerun: yes">&nbsp; </SPAN>TARGET_LINK_LIBRARIES(myproject usblib)</FONT></FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>ENDIF(WITH_USB)</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>Given this file, the USB source files would be placed in a subdirectory called usblib along with a new CMakeLists.txt file:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>PROJECT(usblib)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>SET(SRCS usbfile1.c usbfile2.c)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>ADD_LIBRARY(usblib ${SRCS})</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>Now, if USB support is enabled, CMake builds the USB library and link sit into the executable.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>But how does the code code know to use the optional USB code? First, the USB-specific code should be surrounded with a #ifdef WITH_USB. Next, CMake processes a special configuration file, substituting placeholders with CMake variables.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>Let&#8217;s make a new file called config.h.cmake that contains this:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>#ifndef TEST_CONFIG_H</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>#define TEST_CONFIG_H</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>&nbsp;</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>#cmakedefine WITH_USB</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>&nbsp;</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>#endif</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>Then, in the CMakeLists.txt file, modify the first part to look like this:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>PROJECT(myproject)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>OPTION(WITH_USB "Include our USB component" OFF)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>CONFIGURE_FILE(${CMAKE_SOURCE_DIR}/config.h.cmake </FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;><FONT class=extract><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN>${CMAKE_BINARY_DIR}/config.h)</FONT></FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR} ${CMAKE_BINARY_DIR})</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>Given this, CMake translates config.h.cmake to create config.h in the build directory. The INCLUDE_DIRECTORIES command tells the compiler to add both the source directory and the build directory to the include path. If WITH_USB is enabled, CMake replaces #cmakedefine WITH_USB with #define WITH_USB. Otherwise, it replaces #cmakedefine WITH_USB with /*#undef WITH_USB*/. As long as you #include config.h and surround the USB code with #ifdef WITH_USB, everything just works. The only downside at the moment is that config.h.cmake must be created manually. </FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>CMake includes standard macros to check for header files, functions, variables, libraries, symbols, and sizes of types. For instance, if you&#8217;d like to know if the header file unistd.h exists, use these commands:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>INCLUDE(CheckIncludeFile) </FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>CHECK_INCLUDE_FILE(unistd.h HAVE_UNISTD) </FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>This checks if the compiler can find unistd.h and sets the HAVE_UNISTD variable accordingly. Now add #cmakedefine HAVE_UNISTD to config.h.cmake and you&#8217;re good to go.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>Functions can be found by including CheckFunctionExists and using the CHECK_FUNCTION_EXISTS macro. Variables can be checked by including CheckVariableExists and using CHECK_VARIABLE_EXISTS. Both features use the same syntax as CHECK_INCLUDE_FILE.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>To search for a library, use the CHECK_LIBRARY_EXISTS macro. It requires you to specify the library name, the name of a function provided by the library, a location to search, and a variable to store the result of the search. For example, to check for the dynamic loader library, use these commands:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>INCLUDE(CheckLibraryExists) </FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>CHECK_LIBRARY_EXISTS(dl dlopen "" HAVE_LIBDL) </FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>This checks for the dlopen() function in the libdl library and sets the HAVE_LIBDL variable to true if it&#8217;s found. CMake automatically checks standard system libraries, so an empty string suffices for the library location.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>Searching for a symbol finds both symbols and functions names. In addition to a symbol and an output variable, you must also specify the header files to include. Here&#8217;s an example that searches for the symbol LC_MESSAGES in the header file locale.h and sets the HAVE_LC_MESSAGES variable accordingly:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>INCLUDE(CheckSymbolExists)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>CHECK_SYMBOL_EXISTS(LC_MESSAGES "locale.h" HAVE_LC_MESSAGES)</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>Checking for the size of a variable works a bit differently. In this feature, the output variable is set to the size in bytes of the type being checked and a new variable, HAVE_ ${VARIABLE}, is created to specify if the type exists or not. Here&#8217;s an example:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>INCLUDE(CheckTypeSize)</FONT></SPAN></PRE><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>CHECK_TYPE_SIZE (int INT_SIZE)</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>If you&#8217;re on a 32-bit machine, INT_SIZE would be set to 4 (bytes) and HAVE_INT_SIZE would be set to true.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>In addition to mechanisms for detecting low-level configuration options, CMake includes options to find entire packages. For instance, many Linux programs make use of the X Windows System Version 11 (X11). To easily discover if X11 is installed and what options should be used for include files and linking, use this command:</FONT></SPAN></P><PRE style="mso-line-height-alt: 12.0pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>FIND_PACKAGE(X11 REQUIRED)</FONT></SPAN></PRE>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>The optional REQUIRED parameter tells CMake to stop with an error if the package isn&#8217;t found. FIND_PACKAGE (X11 REQUIRED) sets the following variables:</FONT></SPAN></P>
<UL type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1"><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt">X11_FOUND is true if X11 is available.</SPAN> </FONT>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1"><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt">X11_INCLUDE_DIR contains the include directories to use X11.</SPAN> </FONT>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan; mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract>X11_LIBRARIES points to the libraries to link against to use X11.</FONT></SPAN></LI></UL>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>The last two variables can be fed directly into INCLUDE_DIRECTORIES and TARGET_LINK_LIBRARIES. CMake provides modules to search for many standard packages. Type cmake &#8211;&#8211;help-module-list for a complete list of all installed modules including FIND_PACKAGE modules.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT class=extract face=&#23435;&#20307;>If all else fails, CMake also lets you compile and run C or C++ code snippets using the TRY_COMPILE or TRY_RUN commands. See the CMake documentation for more information on how to use them.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 18pt"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-size: 10.0pt"><FONT face=&#23435;&#20307;>CMake provides extensive online help for all of its built-in commands and modules. cmake &#8211;&#8211;help will get you started. cmake &#8211;&#8211;help-command commandname and cmake &#8211;&#8211;help-module modulename yields help for a specific command or module. To get a list of available commands or modules use cmake &#8211;&#8211;help-command-list or cmake &#8211;&#8211;help-module-list.</FONT></SPAN>