<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt">With pthread_cond_signal(), we are simply guaranteed that at least one of the blocked threads is woken up; with pthread_cond_broadcast(), all blocked threads are woken up.</SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt">Using pthread_cond_broadcast() always yields correct results (since all threads should be programmed to handle redundant and spurious wake-ups), but pthread_cond_signal() can be more efficient. However, pthread_cond_signal() should be used only if just one of the waiting threads needs to be woken up to handle the change in state of the shared variable, and it doesn&#8217;t matter which one of the waiting threads is woken up. This scenario typically applies when all of the waiting threads are designed to perform the exactly same task. Given these assumptions, pthread_cond_signal() can be more efficient than pthread_cond_broadcast(), because it avoids the following possibility:</SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt">1. All waiting threads are awoken.</SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt">2. One thread is scheduled first. This thread checks the state of the shared variable(s) (under protection of the associated mutex) and sees that there is work to be done. The thread performs the required work, changes the state of the shared variable(s) to indicate that the work has been done, and unlocks the associated mutex.</SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt">3. Each of the remaining threads in turn locks the mutex and tests the state of the shared variable. However, because of the change made by the first thread, these threads see that there is no work to be done, and so unlock the mutex and go back to sleep (i.e., call pthread_cond_wait() once more).</SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt">By contrast, pthread_cond_broadcast() handles the case where the waiting threads are designed to perform different tasks (in which case they probably have different predicates associated with the condition variable).</SPAN>