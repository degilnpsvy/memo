<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>The task that pthread_join() performs for threads is similar to that performed by waitpid() for processes. However, there are some notable differences:</FONT></SPAN></P>
<P style="TEXT-INDENT: -21pt; MARGIN: 0cm 0cm 0pt 21pt; mso-list: l0 level1 lfo1; tab-stops: list 21.0pt" class=MsoNormal><FONT class=extract><SPAN style="FONT-FAMILY: Wingdings; FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt; mso-fareast-font-family: Wingdings; mso-bidi-font-family: Wingdings" lang=EN-US><SPAN style="mso-list: Ignore">l<SPAN style="FONT: 7pt 'Times New Roman'">&nbsp; </SPAN></SPAN></SPAN><SPAN style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US>Threads are peers. Any thread in a process can use pthread_join() to join with any other thread in the process. For example, if thread A creates thread B, which creates thread C, then it is possible for thread A to join with thread C, or vice versa. This differs from the hierarchical relationship between processes. When a parent process creates a child using fork(), it is the only process that can wait() on that child. There is no such relationship between the thread that calls pthread_create() and the resulting new thread.</SPAN></FONT></P>
<P style="TEXT-INDENT: -21pt; MARGIN: 0cm 0cm 0pt 21pt; mso-list: l0 level1 lfo1; tab-stops: list 21.0pt" class=MsoNormal><SPAN style="FONT-FAMILY: Wingdings; FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt; mso-fareast-font-family: Wingdings; mso-bidi-font-family: Wingdings" lang=EN-US><SPAN style="mso-list: Ignore"><FONT class=extract>l<SPAN style="FONT: 7pt 'Times New Roman'">&nbsp; </SPAN></FONT></SPAN></SPAN><SPAN style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>There is no way of saying &#8220;join with any thread&#8221; (for processes, we can do this using the call waitpid(&#8211;1, &amp;status, options)); nor is there a way to do a nonblocking join (analogous to the waitpid() WNOHANG flag). There are ways to achieve similar functionality using condition variables; we show an example in Section 30.2.4.</FONT> </SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 15pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><EM><FONT class=extract>The limitation that pthread_join() can join only with a specific thread ID is intentional. The idea is that a program should join only with the threads that it &#8220;knows&#8221; about. The problem with a &#8220;join with any thread&#8221; operation stems from the fact that there is no hierarchy of threads, so such an operation could indeed join with any thread, including one that was privately created by a library function. (The condition-variable technique that we show in Section 30.2.4 allows a thread to join only with any other thread that it knows about.) As a consequence, the library would no longer be able to join with that thread in order to obtain its status, and it would erroneously try to join with a thread ID that had already been joined. In other words, a &#8220;join with any thread&#8221; operation is incompatible with modular program design.</FONT></EM></SPAN>