<H2 style="MARGIN: 13pt 0cm"><SPAN lang=EN-US style="FONT-SIZE: 21pt; LINE-HEIGHT: 173%; mso-bidi-font-size: 16.0pt; mso-font-kerning: 0pt"><FONT face=Arial>31.5 Summary</FONT></SPAN></H2>
<P class=MsoNormal style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none" align=left><SPAN lang=EN-US style="FONT-SIZE: 16pt; FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman"><FONT class=extract>A function is said to be thread-safe if it can safely be invoked from multiple threads at the same time.</FONT> The usual reason a function is not thread-safe is that it makes use of global or static variables. One way to render a non-thread-safe function safe in a multithreaded application is to guard all calls to the function with a mutex lock. This approach suffers the problem that it reduces concurrency, because only one thread can be in the function at any time. An approach that allows greater concurrency is to add mutex locks around just those parts of the function that manipulate shared variables (the critical sections).</SPAN></P>
<P class=MsoNormal style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none" align=left><SPAN lang=EN-US style="FONT-SIZE: 16pt; FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman">Mutexes can be used to render most functions thread-safe, but they carry a performance penalty because there is a cost to locking and unlocking a mutex. By avoiding the use of global and static variables, <FONT class=extract>a reentrant function achieves threadsafety without the use of mutexes</FONT>.</SPAN></P>
<P class=MsoNormal style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none" align=left><SPAN lang=EN-US style="FONT-SIZE: 16pt; FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman">Most of the functions specified in SUSv3 are required to be thread-safe. SUSv3 also lists a small set of functions that are not required to be thread-safe. Typically, these are functions that employ static storage to return information to the caller or to maintain information between successive calls. By definition, such functions are not reentrant, and mutexes can&#8217;t be used to make them thread-safe. We considered two roughly equivalent coding techniques&#8212;thread-specific data and thread-local storage&#8212;that can be used to render an unsafe function thread-safe without needing to change its interface. Both of these techniques allow a function to allocate persistent, per-thread storage.</SPAN>