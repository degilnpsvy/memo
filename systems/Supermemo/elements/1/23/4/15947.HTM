<H2 style="MARGIN: 13pt 0cm"><SPAN style="LINE-HEIGHT: 173%; FONT-SIZE: 21pt; mso-bidi-font-size: 16.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT face=Arial>32.6 Asynchronous Cancelability</FONT></SPAN></H2>
<P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none" class=MsoNormal align=left><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>When a thread is made asynchronously cancelable (cancelability type </SPAN><SPAN style="FONT-FAMILY: TheSansMonoCondensed-Plain; FONT-SIZE: 12pt; mso-bidi-font-size: 8.5pt; mso-font-kerning: 0pt; mso-bidi-font-family: TheSansMonoCondensed-Plain; mso-hansi-font-family: Futura-Bold" lang=EN-US>PTHREAD_CANCEL_ASYNCHRONOUS</SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>), it may be canceled at any time (i.e., at any machinelanguage instruction); delivery of a cancellation is not held off until the thread next reaches a cancellation point.</SPAN></P>
<P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none" class=MsoNormal align=left><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>The problem with asynchronous cancellation is that, although cleanup handlers are still invoked, the handlers have no way of determining the state of a thread. In the program in Listing 32-2, which employs the deferred cancelability type, the thread can be canceled only when it executes the call to </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-RomanIta','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-RomanIta" lang=EN-US>pthread_cond_wait()</SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>, which is the only cancellation point. By this time, we know that </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-RomanIta','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-RomanIta" lang=EN-US>buf </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>has been initialized to point to a block of allocated memory and that the mutex </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-RomanIta','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-RomanIta" lang=EN-US>mtx </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>has been locked. However, with asynchronous cancelability, the thread could be canceled at any point; for example, before the </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-RomanIta','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-RomanIta" lang=EN-US>malloc() </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>call, between the </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-RomanIta','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-RomanIta" lang=EN-US>malloc() </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>call and locking the mutex, or after locking the mutex. The cleanup handler has no way of knowing where cancellation has occurred, or precisely which cleanup steps are required. Furthermore, the thread might even be canceled </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-RomanIta','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-RomanIta" lang=EN-US>during </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>the </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-RomanIta','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-RomanIta" lang=EN-US>malloc() </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>call, after which chaos is likely to result (Section 7.1.3).</SPAN></P>
<P style="TEXT-ALIGN: left; MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none" class=MsoNormal align=left><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>As a general principle, an asynchronously cancelable thread can&#8217;t allocate any resources or acquire any mutexes, semaphores, or locks. This precludes the use of a wide range of library functions, including most of the Pthreads functions. (SUSv3 makes exceptions for </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-RomanIta','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-RomanIta" lang=EN-US>pthread_cancel()</SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>, </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-RomanIta','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-RomanIta" lang=EN-US>pthread_setcancelstate()</SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>, and </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-RomanIta','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-RomanIta" lang=EN-US>pthread_setcanceltype()</SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>, which are explicitly required to be </SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-RomanIta','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-RomanIta" lang=EN-US>async-cancel-safe</SPAN><SPAN style="FONT-FAMILY: 'NewBaskervilleEF-Roman','sans-serif'; FONT-SIZE: 16pt; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: NewBaskervilleEF-Roman" lang=EN-US>; that is, an implementation must make them safe to call from a thread that is asynchronously cancelable.) In other words, there are few circumstances where asynchronous cancellation is useful. One such circumstance is canceling a thread that is in a compute-bound loop.</SPAN>