<H3 style="MARGIN: 13pt 0cm"><SPAN style="LINE-HEIGHT: 173%; FONT-SIZE: 21pt; mso-bidi-font-size: 16.0pt; mso-font-kerning: 0pt" lang=EN-US>Using a condition variable in the producer-consumer example</SPAN></H3>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US>Let&#8217;s revise our previous example to use a condition variable. The declarations of our global variable and associated mutex and condition variable are as follows:</SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>static int avail = 0;</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>The code segments shown in this section can be found in the file threads/prod_condvar.c in the source code distribution for this book.</EM></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US>The code in the producer threads is the same as before, except that we add a call to pthread_cond_signal():</SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>s = pthread_mutex_lock(&amp;mtx);</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>if (s != 0)</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>errExitEN(s, "pthread_mutex_lock");</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>avail++; /* Let consumer know another unit is available */</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>s = pthread_mutex_unlock(&amp;mtx);</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>if (s != 0)</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>errExitEN(s, "pthread_mutex_unlock");</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>s = pthread_cond_signal(&amp;cond); /* Wake sleeping consumer */</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>if (s != 0)</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>errExitEN(s, "pthread_cond_signal");</EM></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US>Before considering the code of the consumer, we need to explain pthread_cond_wait() in greater detail. <FONT class=extract>We noted earlier that a condition variable always has an associated mutex. Both of these objects are passed as arguments to pthread_cond_wait(), which performs the following steps:</FONT></SPAN></P>
<P style="TEXT-INDENT: -21pt; MARGIN: 0cm 0cm 0pt 21pt; mso-list: l0 level1 lfo1; tab-stops: list 21.0pt" class=MsoNormal><FONT class=extract><SPAN style="FONT-FAMILY: Wingdings; FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt; mso-fareast-font-family: Wingdings; mso-bidi-font-family: Wingdings" lang=EN-US><SPAN style="mso-list: Ignore">l<SPAN style="FONT: 7pt 'Times New Roman'">&nbsp; </SPAN></SPAN></SPAN><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US>unlock the mutex specified by mutex;</SPAN></FONT></P>
<P style="TEXT-INDENT: -21pt; MARGIN: 0cm 0cm 0pt 21pt; mso-list: l0 level1 lfo1; tab-stops: list 21.0pt" class=MsoNormal><FONT class=extract><SPAN style="FONT-FAMILY: Wingdings; FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt; mso-fareast-font-family: Wingdings; mso-bidi-font-family: Wingdings" lang=EN-US><SPAN style="mso-list: Ignore">l<SPAN style="FONT: 7pt 'Times New Roman'">&nbsp; </SPAN></SPAN></SPAN><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US>block the calling thread until another thread signals the condition variable cond; and</SPAN></FONT></P>
<P style="TEXT-INDENT: -21pt; MARGIN: 0cm 0cm 0pt 21pt; mso-list: l0 level1 lfo1; tab-stops: list 21.0pt" class=MsoNormal><FONT class=extract><SPAN style="FONT-FAMILY: Wingdings; FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt; mso-fareast-font-family: Wingdings; mso-bidi-font-family: Wingdings" lang=EN-US><SPAN style="mso-list: Ignore">l<SPAN style="FONT: 7pt 'Times New Roman'">&nbsp; </SPAN></SPAN></SPAN><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US>relock mutex.</SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US>The pthread_cond_wait() function is designed to perform these steps because, <FONT class=extract>normally, we access a shared variable in the following manner:</FONT></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>s = pthread_mutex_lock(&amp;mtx);</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>if (s != 0)</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>errExitEN(s, "pthread_mutex_lock");</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>while (/* Check that shared variable is not in state we want */)</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>pthread_cond_wait(&amp;cond, &amp;mtx);</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>/* Now shared variable is in desired state; do some work */</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>s = pthread_mutex_unlock(&amp;mtx);</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>if (s != 0)</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>errExitEN(s, "pthread_mutex_unlock");</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US>(We explain why the pthread_cond_wait() call is placed within a while loop rather than an if statement in the next section.)</SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US>In the above code, both accesses to the shared variable must be mutex-protected for the reasons that we explained earlier. In other words, <FONT class=extract>there is a natural association of a mutex with a condition variable:</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>1. The thread locks the mutex in preparation for checking the state of the shared variable.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>2. The state of the shared variable is checked.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>3. If the shared variable is not in the desired state, then the thread must unlock the mutex (so that other threads can access the shared variable) before it goes to sleep on the condition variable.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>4. When the thread is reawakened because the condition variable has been signaled, the mutex must once more be locked, since, typically, the thread then immediately accesses the shared variable.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>The pthread_cond_wait() function automatically performs the mutex unlocking and locking required in the last two of these steps. In the third step, releasing the mutex and blocking on the condition variable are performed atomically. In other words, it is not possible for some other thread to acquire the mutex and signal the condition variable before the thread calling pthread_cond_wait() has blocked on the condition variable.</FONT></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>There is a corollary to the observation that there is a natural relationship between a condition variable and a mutex: all threads that concurrently wait on a particular condition variable must specify the same mutex in their pthread_cond_wait() (or pthread_cond_timedwait()) calls. In effect, a pthread_cond_wait() call dynamically binds a condition variable to a unique mutex for the duration of the call. SUSv3 notes that the result of using more than one mutex for concurrent pthread_cond_wait() calls on the same condition variable is undefined.</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US>Putting the above details together, we can now modify the main (consumer) thread to use pthread_cond_wait(), as follows:</SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>for (;;) {</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>s = pthread_mutex_lock(&amp;mtx);</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>if (s != 0)</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>errExitEN(s, "pthread_mutex_lock");</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>while (avail == 0) { /* Wait for something to consume */</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>s = pthread_cond_wait(&amp;cond, &amp;mtx);</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>if (s != 0)</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>errExitEN(s, "pthread_cond_wait");</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>}</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>while (avail &gt; 0) { /* Consume all available units */</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>/* Do something with produced unit */</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>avail--;</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>}</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>s = pthread_mutex_unlock(&amp;mtx);</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>if (s != 0)</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>errExitEN(s, "pthread_mutex_unlock");</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>/* Perhaps do other work here that doesn't require mutex lock */</EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM>}</EM></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>We conclude with one final observation about the use of pthread_cond_signal() (and pthread_cond_broadcast()). In the producer code shown earlier, we called pthread_mutex_unlock(), and then called pthread_cond_signal(); that is, we first unlocked the mutex associated with the shared variable, and then signaled the corresponding condition variable. We could have reversed these two steps; SUSv3 permits them to be done in either order.</FONT></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>[Butenhof, 1996] points out that, on some implementations, unlocking the mutex and then signaling the condition variable may yield better performance than performing these steps in the reverse sequence. If the mutex is unlocked only after the condition variable is signaled, the thread performing pthread_cond_wait() may wake up while the mutex is still locked, and then immediately go back to sleep again when it finds that the mutex is locked. This results in two superfluous context switches. Some implementations eliminate this problem by employing a technique called wait morphing, which moves the signaled thread from the condition variable wait queue to the mutex wait queue without performing a context switch if the mutex is locked.</FONT></EM></SPAN>