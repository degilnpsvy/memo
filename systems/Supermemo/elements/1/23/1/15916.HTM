<H3 style="MARGIN: 13pt 0cm"><SPAN style="LINE-HEIGHT: 173%; FONT-SIZE: 21pt; mso-bidi-font-size: 16.0pt; mso-font-kerning: 0pt" lang=EN-US>30.2.2 Signaling and Waiting on Condition Variables</SPAN></H3>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>The principal condition variable operations are signal and wait. The signal operation is a notification to one or more waiting threads that a shared variable&#8217;s state has changed. The wait operation is the means of blocking until such a notification is received.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>The pthread_cond_signal() and pthread_cond_broadcast() functions both signal the condition variable specified by cond. The pthread_cond_wait() function blocks a thread until the condition variable cond is signaled.</FONT></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>#include &lt;pthread.h&gt;</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>int pthread_cond_signal(pthread_cond_t *cond);</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>int pthread_cond_broadcast(pthread_cond_t *cond);</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>All return 0 on success, or a positive error number on error</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>The difference between pthread_cond_signal() and pthread_cond_broadcast() lies in what happens if multiple threads are blocked in pthread_cond_wait(). With pthread_cond_signal(), we are simply guaranteed that at least one of the blocked threads is woken up; with pthread_cond_broadcast(), all blocked threads are woken up.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>Using pthread_cond_broadcast() always yields correct results (since all threads should be programmed to handle redundant and spurious wake-ups), but pthread_cond_signal() can be more efficient. However, pthread_cond_signal() should be used only if just one of the waiting threads needs to be woken up to handle the change in state of the shared variable, and it doesn&#8217;t matter which one of the waiting threads is woken up. This scenario typically applies when all of the waiting threads are designed to perform the exactly same task. Given these assumptions, pthread_cond_signal() can be more efficient than pthread_cond_broadcast(), because it avoids the following possibility:</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>1. All waiting threads are awoken.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>2. One thread is scheduled first. This thread checks the state of the shared variable(s) (under protection of the associated mutex) and sees that there is work to be done. The thread performs the required work, changes the state of the shared variable(s) to indicate that the work has been done, and unlocks the associated mutex.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>3. Each of the remaining threads in turn locks the mutex and tests the state of the shared variable. However, because of the change made by the first thread, these threads see that there is no work to be done, and so unlock the mutex and go back to sleep (i.e., call pthread_cond_wait() once more).</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>By contrast, pthread_cond_broadcast() handles the case where the waiting threads are designed to perform different tasks (in which case they probably have different predicates associated with the condition variable).</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>A condition variable holds no state information. It is simply a mechanism for communicating information about the application&#8217;s state. If no thread is waiting on the condition variable at the time that it is signaled, then the signal is lost. A thread that later waits on the condition variable will unblock only when the variable is signaled once more.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>The pthread_cond_timedwait() function is the same as pthread_cond_wait(), except that the abstime argument specifies an upper limit on the time that the thread will sleep while waiting for the condition variable to be signaled.</FONT></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>#include &lt;pthread.h&gt;</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>const struct timespec *abstime);</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 10.5pt 0pt" class=a><SPAN style="FONT-SIZE: 14pt; mso-bidi-font-size: 12.0pt" lang=EN-US><EM><FONT class=extract>Returns 0 on success, or a positive error number on error</FONT></EM></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt" lang=EN-US><FONT class=extract>The abstime argument is a timespec structure (Section 23.4.2) specifying an absolute time expressed as seconds and nanoseconds since the Epoch (Section 10.1). If the time interval specified by abstime expires without the condition variable being signaled, then pthread_cond_timedwait() returns the error ETIMEDOUT.</FONT></SPAN>