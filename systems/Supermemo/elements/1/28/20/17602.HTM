<TABLE width="100%">
<TBODY>
<TR>
<TD vAlign=top>
<H2><SPAN class=refentrytitle><A name=glib-Threads.top_of_page></A>Threads</SPAN></H2>
<P>Threads &#8212; portable support for threads, mutexes, locks, conditions and thread private data</P></TD>
<TD class=gallery_image vAlign=top align=right></TD></TR></TBODY></TABLE>
<DIV class=refsect1><A name=glib-Threads.functions></A>
<H2>Functions</H2>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=functions_return width=150></COL>
<COL class=functions_name></COL></COLGROUP>
<TBODY>
<TR>
<TD class=function_type><A class=link title=gpointer href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=returnvalue>gpointer</SPAN></A> </TD>
<TD class=function_name><SPAN class=c_punctuation>(</SPAN><A class=link title=GThreadFunc&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThreadFunc">*GThreadFunc</A><SPAN class=c_punctuation>)</SPAN>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=returnvalue>GThread</SPAN></A>&nbsp;* </TD>
<TD class=function_name><A class=link title=g_thread_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-new">g_thread_new</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=returnvalue>GThread</SPAN></A>&nbsp;* </TD>
<TD class=function_name><A class=link title=g_thread_try_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-try-new">g_thread_try_new</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=returnvalue>GThread</SPAN></A>&nbsp;* </TD>
<TD class=function_name><A class=link title=g_thread_ref&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-ref">g_thread_ref</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_thread_unref&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-unref">g_thread_unref</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=gpointer href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=returnvalue>gpointer</SPAN></A> </TD>
<TD class=function_name><A class=link title=g_thread_join&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-join">g_thread_join</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_thread_yield&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-yield">g_thread_yield</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_thread_exit&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-exit">g_thread_exit</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=returnvalue>GThread</SPAN></A>&nbsp;* </TD>
<TD class=function_name><A class=link title=g_thread_self&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-self">g_thread_self</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_mutex_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-init">g_mutex_init</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_mutex_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-clear">g_mutex_clear</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_mutex_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-lock">g_mutex_lock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A> </TD>
<TD class=function_name><A class=link title=g_mutex_trylock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-trylock">g_mutex_trylock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_mutex_unlock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-unlock">g_mutex_unlock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=define_keyword>#define</TD>
<TD class=function_name><A class=link title=G_LOCK_DEFINE() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK-DEFINE:CAPS">G_LOCK_DEFINE</A><SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=define_keyword>#define</TD>
<TD class=function_name><A class=link title=G_LOCK_DEFINE_STATIC() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK-DEFINE-STATIC:CAPS">G_LOCK_DEFINE_STATIC</A><SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=define_keyword>#define</TD>
<TD class=function_name><A class=link title=G_LOCK_EXTERN() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK-EXTERN:CAPS">G_LOCK_EXTERN</A><SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=define_keyword>#define</TD>
<TD class=function_name><A class=link title=G_LOCK() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK:CAPS">G_LOCK</A><SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=define_keyword>#define</TD>
<TD class=function_name><A class=link title=G_TRYLOCK() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-TRYLOCK:CAPS">G_TRYLOCK</A><SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=define_keyword>#define</TD>
<TD class=function_name><A class=link title=G_UNLOCK() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-UNLOCK:CAPS">G_UNLOCK</A><SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_rec_mutex_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-init">g_rec_mutex_init</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_rec_mutex_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-clear">g_rec_mutex_clear</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_rec_mutex_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-lock">g_rec_mutex_lock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A> </TD>
<TD class=function_name><A class=link title=g_rec_mutex_trylock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-trylock">g_rec_mutex_trylock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_rec_mutex_unlock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-unlock">g_rec_mutex_unlock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_rw_lock_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-init">g_rw_lock_init</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_rw_lock_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-clear">g_rw_lock_clear</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_rw_lock_writer_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-writer-lock">g_rw_lock_writer_lock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A> </TD>
<TD class=function_name><A class=link title=g_rw_lock_writer_trylock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-writer-trylock">g_rw_lock_writer_trylock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_rw_lock_writer_unlock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-writer-unlock">g_rw_lock_writer_unlock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_rw_lock_reader_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-reader-lock">g_rw_lock_reader_lock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A> </TD>
<TD class=function_name><A class=link title=g_rw_lock_reader_trylock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-reader-trylock">g_rw_lock_reader_trylock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_rw_lock_reader_unlock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-reader-unlock">g_rw_lock_reader_unlock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_cond_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-init">g_cond_init</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_cond_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-clear">g_cond_clear</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_cond_wait&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-wait">g_cond_wait</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A> </TD>
<TD class=function_name><A class=link title=g_cond_timed_wait&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-timed-wait">g_cond_timed_wait</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A> </TD>
<TD class=function_name><A class=link title=g_cond_wait_until&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-wait-until">g_cond_wait_until</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_cond_signal&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-signal">g_cond_signal</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_cond_broadcast&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-broadcast">g_cond_broadcast</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=define_keyword>#define</TD>
<TD class=function_name><A class=link title=G_PRIVATE_INIT() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-PRIVATE-INIT:CAPS">G_PRIVATE_INIT</A><SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=gpointer href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=returnvalue>gpointer</SPAN></A> </TD>
<TD class=function_name><A class=link title=g_private_get&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-private-get">g_private_get</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_private_set&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-private-set">g_private_set</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_private_replace&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-private-replace">g_private_replace</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=define_keyword>#define</TD>
<TD class=function_name><A class=link title=g_once() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once">g_once</A><SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A> </TD>
<TD class=function_name><A class=link title=g_once_init_enter&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once-init-enter">g_once_init_enter</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_once_init_leave&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once-init-leave">g_once_init_leave</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_bit_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-bit-lock">g_bit_lock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A> </TD>
<TD class=function_name><A class=link title=g_bit_trylock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-bit-trylock">g_bit_trylock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_bit_unlock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-bit-unlock">g_bit_unlock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_pointer_bit_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-pointer-bit-lock">g_pointer_bit_lock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A> </TD>
<TD class=function_name><A class=link title=g_pointer_bit_trylock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-pointer-bit-trylock">g_pointer_bit_trylock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><SPAN class=returnvalue>void</SPAN> </TD>
<TD class=function_name><A class=link title=g_pointer_bit_unlock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-pointer-bit-unlock">g_pointer_bit_unlock</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR>
<TR>
<TD class=function_type><A class=link title=guint href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#guint"><SPAN class=returnvalue>guint</SPAN></A> </TD>
<TD class=function_name><A class=link title=g_get_num_processors&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-get-num-processors">g_get_num_processors</A>&nbsp;<SPAN class=c_punctuation>()</SPAN> </TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect1><A name=glib-Threads.other></A>
<H2>Types and Values</H2>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=name width=150></COL>
<COL class=description></COL></COLGROUP>
<TBODY>
<TR>
<TD class=define_keyword>#define</TD>
<TD class=function_name><A class=link title=G_THREAD_ERROR href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-THREAD-ERROR:CAPS">G_THREAD_ERROR</A></TD></TR>
<TR>
<TD class=datatype_keyword>enum</TD>
<TD class=function_name><A class=link title="enum GThreadError" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThreadError">GThreadError</A></TD></TR>
<TR>
<TD class=datatype_keyword>&nbsp;</TD>
<TD class=function_name><A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread">GThread</A></TD></TR>
<TR>
<TD class=datatype_keyword>union</TD>
<TD class=function_name><A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex">GMutex</A></TD></TR>
<TR>
<TD class=datatype_keyword>struct</TD>
<TD class=function_name><A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex">GRecMutex</A></TD></TR>
<TR>
<TD class=datatype_keyword>struct</TD>
<TD class=function_name><A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock">GRWLock</A></TD></TR>
<TR>
<TD class=datatype_keyword>struct</TD>
<TD class=function_name><A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond">GCond</A></TD></TR>
<TR>
<TD class=datatype_keyword>struct</TD>
<TD class=function_name><A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate">GPrivate</A></TD></TR>
<TR>
<TD class=datatype_keyword>struct</TD>
<TD class=function_name><A class=link title="struct GOnce" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnce">GOnce</A></TD></TR>
<TR>
<TD class=datatype_keyword>enum</TD>
<TD class=function_name><A class=link title="enum GOnceStatus" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnceStatus">GOnceStatus</A></TD></TR>
<TR>
<TD class=define_keyword>#define</TD>
<TD class=function_name><A class=link title=G_ONCE_INIT href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-ONCE-INIT:CAPS">G_ONCE_INIT</A></TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect1><A name=glib-Threads.includes></A>
<H2>Includes</H2><PRE class=synopsis>#include &lt;glib.h&gt;
</PRE></DIV>
<DIV class=refsect1><A name=glib-Threads.description></A>
<H2>Description</H2>
<P>Threads act almost like processes, but unlike processes all threads of one process share the same memory. This is good, as it provides easy communication between the involved threads via this shared memory, and it is bad, because strange things (so called "Heisenbugs") might happen if the program is not carefully designed. In particular, due to the concurrent nature of threads, no assumptions on the order of execution of code running in different threads can be made, unless order is explicitly forced by the programmer through synchronization primitives.</P>
<P>The aim of the thread-related functions in GLib is to provide a portable means for writing multi-threaded software. There are primitives for mutexes to protect the access to portions of memory (<A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A>, <A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A> and <A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A>). There is a facility to use individual bits for locks (<A class=link title=g_bit_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-bit-lock"><CODE class=function>g_bit_lock()</CODE></A>). There are primitives for condition variables to allow synchronization of threads (<A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A>). There are primitives for thread-private data - data that every thread has a private instance of (<A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A>). There are facilities for one-time initialization (<A class=link title="struct GOnce" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnce"><SPAN class=type>GOnce</SPAN></A>, <A class=link title=g_once_init_enter&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once-init-enter"><CODE class=function>g_once_init_enter()</CODE></A>). Finally, there are primitives to create and manage threads (<A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A>).</P>
<P>The GLib threading system used to be initialized with <A class=link title=g_thread_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Deprecated-Thread-APIs.html#g-thread-init"><CODE class=function>g_thread_init()</CODE></A>. This is no longer necessary. Since version 2.32, the GLib threading system is automatically initialized at the start of your program, and all thread-creation functions and synchronization primitives are available right away.</P>
<P>Note that it is not safe to assume that your program has no threads even if you don't call <A class=link title=g_thread_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-new"><CODE class=function>g_thread_new()</CODE></A> yourself. GLib and GIO can and will create threads for their own purposes in some cases, such as when using <A class=link title=g_unix_signal_source_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-UNIX-specific-utilities-and-integration.html#g-unix-signal-source-new"><CODE class=function>g_unix_signal_source_new()</CODE></A> or when using GDBus.</P>
<P>Originally, UNIX did not have threads, and therefore some traditional UNIX APIs are problematic in threaded programs. Some notable examples are</P>
<DIV class=itemizedlist>
<UL style="LIST-STYLE-TYPE: disc" class=itemizedlist>
<LI class=listitem>
<P>C library functions that return data in statically allocated buffers, such as <CODE class=function>strtok()</CODE> or <CODE class=function>strerror()</CODE>. For many of these, there are thread-safe variants with a _r suffix, or you can look at corresponding GLib APIs (like <A class=link title=g_strsplit&nbsp;() href="https://developer.gnome.org/glib/stable/glib-String-Utility-Functions.html#g-strsplit"><CODE class=function>g_strsplit()</CODE></A> or <A class=link title=g_strerror&nbsp;() href="https://developer.gnome.org/glib/stable/glib-String-Utility-Functions.html#g-strerror"><CODE class=function>g_strerror()</CODE></A>).</P></LI>
<LI class=listitem>
<P>The functions <CODE class=function>setenv()</CODE> and <CODE class=function>unsetenv()</CODE> manipulate the process environment in a not thread-safe way, and may interfere with <CODE class=function>getenv()</CODE> calls in other threads. Note that <CODE class=function>getenv()</CODE> calls may be hidden behind other APIs. For example, GNU <CODE class=function>gettext()</CODE> calls <CODE class=function>getenv()</CODE> under the covers. In general, it is best to treat the environment as readonly. If you absolutely have to modify the environment, do it early in <CODE class=function>main()</CODE>, when no other threads are around yet.</P></LI>
<LI class=listitem>
<P>The <A class=link title=Locale href="https://developer.gnome.org/glib/stable/glib-running.html#setlocale"><CODE class=function>setlocale()</CODE></A> function changes the locale for the entire process, affecting all threads. Temporary changes to the locale are often made to change the behavior of string scanning or formatting functions like <CODE class=function>scanf()</CODE> or <CODE class=function>printf()</CODE>. GLib offers a number of string APIs (like <A class=link title=g_ascii_formatd&nbsp;() href="https://developer.gnome.org/glib/stable/glib-String-Utility-Functions.html#g-ascii-formatd"><CODE class=function>g_ascii_formatd()</CODE></A> or <A class=link title=g_ascii_strtod&nbsp;() href="https://developer.gnome.org/glib/stable/glib-String-Utility-Functions.html#g-ascii-strtod"><CODE class=function>g_ascii_strtod()</CODE></A>) that can often be used as an alternative. Or you can use the <CODE class=function>uselocale()</CODE> function to change the locale only for the current thread.</P></LI>
<LI class=listitem>
<P>The <CODE class=function>fork()</CODE> function only takes the calling thread into the child's copy of the process image. If other threads were executing in critical sections they could have left mutexes locked which could easily cause deadlocks in the new child. For this reason, you should call <CODE class=function>exit()</CODE> or <CODE class=function>exec()</CODE> as soon as possible in the child and only make signal-safe library calls before that.</P></LI>
<LI class=listitem>
<P>The <CODE class=function>daemon()</CODE> function uses <CODE class=function>fork()</CODE> in a way contrary to what is described above. It should not be used with GLib programs.</P></LI></UL></DIV>
<P>GLib itself is internally completely thread-safe (all global data is automatically locked), but individual data structure instances are not automatically locked for performance reasons. For example, you must coordinate accesses to the same <A class=link title=GHashTable href="https://developer.gnome.org/glib/stable/glib-Hash-Tables.html#GHashTable"><SPAN class=type>GHashTable</SPAN></A> from multiple threads. The two notable exceptions from this rule are <A class=link title=GMainLoop href="https://developer.gnome.org/glib/stable/glib-The-Main-Event-Loop.html#GMainLoop"><SPAN class=type>GMainLoop</SPAN></A> and <A class=link title=GAsyncQueue href="https://developer.gnome.org/glib/stable/glib-Asynchronous-Queues.html#GAsyncQueue"><SPAN class=type>GAsyncQueue</SPAN></A>, which are thread-safe and need no further application-level locking to be accessed from multiple threads. Most refcounting functions such as <A href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-ref"><CODE class=function>g_object_ref()</CODE></A> are also thread-safe.</P></DIV>
<DIV class=refsect1><A name=glib-Threads.functions_details></A>
<H2>Functions</H2>
<DIV class=refsect2><A name=GThreadFunc></A>
<H3>GThreadFunc&nbsp;()</H3><PRE class=programlisting><A class=link title=gpointer href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=returnvalue>gpointer</SPAN></A>
<SPAN class=c_punctuation>(</SPAN>*GThreadFunc<SPAN class=c_punctuation>)</SPAN> (<EM class=parameter><CODE><A class=link title=gpointer href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=type>gpointer</SPAN></A> data</CODE></EM>);</PRE>
<P>Specifies the type of the <EM class=parameter><CODE>func</CODE></EM> functions passed to <A class=link title=g_thread_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-new"><CODE class=function>g_thread_new()</CODE></A> or <A class=link title=g_thread_try_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-try-new"><CODE class=function>g_thread_try_new()</CODE></A>.</P>
<DIV class=refsect3><A name=id-1.4.3.7.2.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>data</P></TD>
<TD class=parameter_description>
<P>data passed to the thread</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.2.6></A>
<H4>Returns</H4>
<P>the return value of the thread</P>
<P></P></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-thread-new></A>
<H3>g_thread_new&nbsp;()</H3><PRE class=programlisting><A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=returnvalue>GThread</SPAN></A>&nbsp;*
g_thread_new (<EM class=parameter><CODE>const <A class=link title=gchar href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gchar"><SPAN class=type>gchar</SPAN></A> *name</CODE></EM>,
              <EM class=parameter><CODE><A class=link title=GThreadFunc&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThreadFunc"><SPAN class=type>GThreadFunc</SPAN></A> func</CODE></EM>,
              <EM class=parameter><CODE><A class=link title=gpointer href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=type>gpointer</SPAN></A> data</CODE></EM>);</PRE>
<P>This function creates a new thread. The new thread starts by invoking <EM class=parameter><CODE>func</CODE></EM> with the argument data. The thread will run until <EM class=parameter><CODE>func</CODE></EM> returns or until <A class=link title=g_thread_exit&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-exit"><CODE class=function>g_thread_exit()</CODE></A> is called from the new thread. The return value of <EM class=parameter><CODE>func</CODE></EM> becomes the return value of the thread, which can be obtained with <A class=link title=g_thread_join&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-join"><CODE class=function>g_thread_join()</CODE></A>.</P>
<P>The <EM class=parameter><CODE>name</CODE></EM> can be useful for discriminating threads in a debugger. It is not used for other purposes and does not have to be unique. Some systems restrict the length of <EM class=parameter><CODE>name</CODE></EM> to 16 bytes.</P>
<P>If the thread can not be created the program aborts. See <A class=link title=g_thread_try_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-try-new"><CODE class=function>g_thread_try_new()</CODE></A> if you want to attempt to deal with failures.</P>
<P>To free the struct returned by this function, use <A class=link title=g_thread_unref&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-unref"><CODE class=function>g_thread_unref()</CODE></A>. Note that <A class=link title=g_thread_join&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-join"><CODE class=function>g_thread_join()</CODE></A> implicitly unrefs the <A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A> as well.</P>
<DIV class=refsect3><A name=id-1.4.3.7.3.8></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>name</P></TD>
<TD class=parameter_description>
<P>an (optional) name for the new thread. </P></TD>
<TD class=parameter_annotations><SPAN class=annotation>[<ACRONYM title="NULL is OK, both for passing and for returning."><SPAN class=acronym>allow-none</SPAN></ACRONYM>]</SPAN></TD></TR>
<TR>
<TD class=parameter_name>
<P>func</P></TD>
<TD class=parameter_description>
<P>a function to execute in the new thread</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>data</P></TD>
<TD class=parameter_description>
<P>an argument to supply to the new thread</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.3.9></A>
<H4>Returns</H4>
<P>the new <A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A></P>
<P></P></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-thread-try-new></A>
<H3>g_thread_try_new&nbsp;()</H3><PRE class=programlisting><A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=returnvalue>GThread</SPAN></A>&nbsp;*
g_thread_try_new (<EM class=parameter><CODE>const <A class=link title=gchar href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gchar"><SPAN class=type>gchar</SPAN></A> *name</CODE></EM>,
                  <EM class=parameter><CODE><A class=link title=GThreadFunc&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThreadFunc"><SPAN class=type>GThreadFunc</SPAN></A> func</CODE></EM>,
                  <EM class=parameter><CODE><A class=link title=gpointer href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=type>gpointer</SPAN></A> data</CODE></EM>,
                  <EM class=parameter><CODE><A class=link title="struct GError" href="https://developer.gnome.org/glib/stable/glib-Error-Reporting.html#GError"><SPAN class=type>GError</SPAN></A> **error</CODE></EM>);</PRE>
<P>This function is the same as <A class=link title=g_thread_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-new"><CODE class=function>g_thread_new()</CODE></A> except that it allows for the possibility of failure.</P>
<P>If a thread can not be created (due to resource limits), <EM class=parameter><CODE>error</CODE></EM> is set and <A class=link title=NULL href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#NULL:CAPS"><CODE class=literal>NULL</CODE></A> is returned.</P>
<DIV class=refsect3><A name=id-1.4.3.7.4.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>name</P></TD>
<TD class=parameter_description>
<P>an (optional) name for the new thread. </P></TD>
<TD class=parameter_annotations><SPAN class=annotation>[<ACRONYM title="NULL is OK, both for passing and for returning."><SPAN class=acronym>allow-none</SPAN></ACRONYM>]</SPAN></TD></TR>
<TR>
<TD class=parameter_name>
<P>func</P></TD>
<TD class=parameter_description>
<P>a function to execute in the new thread</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>data</P></TD>
<TD class=parameter_description>
<P>an argument to supply to the new thread</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>error</P></TD>
<TD class=parameter_description>
<P>return location for error, or <A class=link title=NULL href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#NULL:CAPS"><CODE class=literal>NULL</CODE></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.4.7></A>
<H4>Returns</H4>
<P>the new <A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A>, or <A class=link title=NULL href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#NULL:CAPS"><CODE class=literal>NULL</CODE></A> if an error occurred</P>
<P></P></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-thread-ref></A>
<H3>g_thread_ref&nbsp;()</H3><PRE class=programlisting><A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=returnvalue>GThread</SPAN></A>&nbsp;*
g_thread_ref (<EM class=parameter><CODE><A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A> *thread</CODE></EM>);</PRE>
<P>Increase the reference count on <EM class=parameter><CODE>thread</CODE></EM> .</P>
<DIV class=refsect3><A name=id-1.4.3.7.5.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>thread</P></TD>
<TD class=parameter_description>
<P>a <A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.5.6></A>
<H4>Returns</H4>
<P>a new reference to <EM class=parameter><CODE>thread</CODE></EM> </P>
<P></P></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-thread-unref></A>
<H3>g_thread_unref&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_thread_unref (<EM class=parameter><CODE><A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A> *thread</CODE></EM>);</PRE>
<P>Decrease the reference count on <EM class=parameter><CODE>thread</CODE></EM> , possibly freeing all resources associated with it.</P>
<P>Note that each thread holds a reference to its <A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A> while it is running, so it is safe to drop your own reference to it if you don't need it anymore.</P>
<DIV class=refsect3><A name=id-1.4.3.7.6.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>thread</P></TD>
<TD class=parameter_description>
<P>a <A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-thread-join></A>
<H3>g_thread_join&nbsp;()</H3><PRE class=programlisting><A class=link title=gpointer href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=returnvalue>gpointer</SPAN></A>
g_thread_join (<EM class=parameter><CODE><A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A> *thread</CODE></EM>);</PRE>
<P>Waits until <EM class=parameter><CODE>thread</CODE></EM> finishes, i.e. the function <EM class=parameter><CODE>func</CODE></EM> , as given to <A class=link title=g_thread_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-new"><CODE class=function>g_thread_new()</CODE></A>, returns or <A class=link title=g_thread_exit&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-exit"><CODE class=function>g_thread_exit()</CODE></A> is called. If <EM class=parameter><CODE>thread</CODE></EM> has already terminated, then <A class=link title=g_thread_join&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-join"><CODE class=function>g_thread_join()</CODE></A> returns immediately.</P>
<P>Any thread can wait for any other thread by calling <A class=link title=g_thread_join&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-join"><CODE class=function>g_thread_join()</CODE></A>, not just its 'creator'. Calling <A class=link title=g_thread_join&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-join"><CODE class=function>g_thread_join()</CODE></A> from multiple threads for the same <EM class=parameter><CODE>thread</CODE></EM> leads to undefined behaviour.</P>
<P>The value returned by <EM class=parameter><CODE>func</CODE></EM> or given to <A class=link title=g_thread_exit&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-exit"><CODE class=function>g_thread_exit()</CODE></A> is returned by this function.</P>
<P>g_thread_join() consumes the reference to the passed-in <EM class=parameter><CODE>thread</CODE></EM> . This will usually cause the <A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A> struct and associated resources to be freed. Use <A class=link title=g_thread_ref&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-ref"><CODE class=function>g_thread_ref()</CODE></A> to obtain an extra reference if you want to keep the GThread alive beyond the <A class=link title=g_thread_join&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-join"><CODE class=function>g_thread_join()</CODE></A> call.</P>
<DIV class=refsect3><A name=id-1.4.3.7.7.8></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>thread</P></TD>
<TD class=parameter_description>
<P>a <A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.7.9></A>
<H4>Returns</H4>
<P>the return value of the thread</P>
<P></P></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-thread-yield></A>
<H3>g_thread_yield&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_thread_yield ();</PRE>
<P>Causes the calling thread to voluntarily relinquish the CPU, so that other threads can run.</P>
<P>This function is often used as a method to make busy wait less evil.</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-thread-exit></A>
<H3>g_thread_exit&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_thread_exit (<EM class=parameter><CODE><A class=link title=gpointer href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=type>gpointer</SPAN></A> retval</CODE></EM>);</PRE>
<P>Terminates the current thread.</P>
<P>If another thread is waiting for us using <A class=link title=g_thread_join&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-join"><CODE class=function>g_thread_join()</CODE></A> then the waiting thread will be woken up and get <EM class=parameter><CODE>retval</CODE></EM> as the return value of <A class=link title=g_thread_join&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-join"><CODE class=function>g_thread_join()</CODE></A>.</P>
<P>Calling <A class=link title=g_thread_exit&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-exit"><CODE class=function>g_thread_exit()</CODE></A> with a parameter <EM class=parameter><CODE>retval</CODE></EM> is equivalent to returning <EM class=parameter><CODE>retval</CODE></EM> from the function <EM class=parameter><CODE>func</CODE></EM> , as given to <A class=link title=g_thread_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-new"><CODE class=function>g_thread_new()</CODE></A>.</P>
<P>You must only call <A class=link title=g_thread_exit&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-exit"><CODE class=function>g_thread_exit()</CODE></A> from a thread that you created yourself with <A class=link title=g_thread_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-new"><CODE class=function>g_thread_new()</CODE></A> or related APIs. You must not call this function from a thread created with another threading library or or from within a <A class=link title="struct GThreadPool" href="https://developer.gnome.org/glib/stable/glib-Thread-Pools.html#GThreadPool"><SPAN class=type>GThreadPool</SPAN></A>.</P>
<DIV class=refsect3><A name=id-1.4.3.7.9.8></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>retval</P></TD>
<TD class=parameter_description>
<P>the return value of this thread</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-thread-self></A>
<H3>g_thread_self&nbsp;()</H3><PRE class=programlisting><A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=returnvalue>GThread</SPAN></A>&nbsp;*
g_thread_self (<EM class=parameter><CODE><SPAN class=type>void</SPAN></CODE></EM>);</PRE>
<P>This functions returns the <A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A> corresponding to the current thread. Note that this function does not increase the reference count of the returned struct.</P>
<P>This function will return a <A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A> even for threads that were not created by GLib (i.e. those created by other threading APIs). This may be useful for thread identification purposes (i.e. comparisons) but you must not use GLib functions (such as <A class=link title=g_thread_join&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-join"><CODE class=function>g_thread_join()</CODE></A>) on these threads.</P>
<DIV class=refsect3><A name=id-1.4.3.7.10.6></A>
<H4>Returns</H4>
<P>the <A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A> representing the current thread</P>
<P></P></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-mutex-init></A>
<H3>g_mutex_init&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_mutex_init (<EM class=parameter><CODE><A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> *mutex</CODE></EM>);</PRE>
<P>Initializes a <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> so that it can be used.</P>
<P>This function is useful to initialize a mutex that has been allocated on the stack, or as part of a larger structure. It is not necessary to initialize a mutex that has been statically allocated.</P>
<DIV class=informalexample>
<TABLE class=listing_frame border=0 cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD class=listing_lines align=right><PRE>1
2
3
4
5
6
7
8
9</PRE></TD>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwc">typedef</SPAN> <SPAN class="gtkdoc kwb">struct</SPAN> <SPAN class="gtkdoc opt">{</SPAN>
  GMutex m<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc opt">...</SPAN>
<SPAN class="gtkdoc opt">}</SPAN> Blob<SPAN class="gtkdoc opt">;</SPAN>

Blob <SPAN class="gtkdoc opt">*</SPAN>b<SPAN class="gtkdoc opt">;</SPAN>

b <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Memory-Allocation.html#g-new">g_new</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>Blob<SPAN class="gtkdoc opt">,</SPAN> <SPAN class=number>1</SPAN><SPAN class="gtkdoc opt">);</SPAN>
<SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-init">g_mutex_init</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>b<SPAN class="gtkdoc opt">-&gt;</SPAN>m<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>To undo the effect of <A class=link title=g_mutex_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-init"><CODE class=function>g_mutex_init()</CODE></A> when a mutex is no longer needed, use <A class=link title=g_mutex_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-clear"><CODE class=function>g_mutex_clear()</CODE></A>.</P>
<P>Calling <A class=link title=g_mutex_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-init"><CODE class=function>g_mutex_init()</CODE></A> on an already initialized <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> leads to undefined behaviour.</P>
<DIV class=refsect3><A name=id-1.4.3.7.11.10></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>mutex</P></TD>
<TD class=parameter_description>
<P>an uninitialized <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-mutex-clear></A>
<H3>g_mutex_clear&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_mutex_clear (<EM class=parameter><CODE><A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> *mutex</CODE></EM>);</PRE>
<P>Frees the resources allocated to a mutex with <A class=link title=g_mutex_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-init"><CODE class=function>g_mutex_init()</CODE></A>.</P>
<P>This function should not be used with a <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> that has been statically allocated.</P>
<P>Calling <A class=link title=g_mutex_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-clear"><CODE class=function>g_mutex_clear()</CODE></A> on a locked mutex leads to undefined behaviour.</P>
<P>Sine: 2.32</P>
<DIV class=refsect3><A name=id-1.4.3.7.12.8></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>mutex</P></TD>
<TD class=parameter_description>
<P>an initialized <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-mutex-lock></A>
<H3>g_mutex_lock&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_mutex_lock (<EM class=parameter><CODE><A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> *mutex</CODE></EM>);</PRE>
<P>Locks <EM class=parameter><CODE>mutex</CODE></EM> . If <EM class=parameter><CODE>mutex</CODE></EM> is already locked by another thread, the current thread will block until <EM class=parameter><CODE>mutex</CODE></EM> is unlocked by the other thread.</P>
<P><A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> is neither guaranteed to be recursive nor to be non-recursive. As such, calling <A class=link title=g_mutex_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-lock"><CODE class=function>g_mutex_lock()</CODE></A> on a <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> that has already been locked by the same thread results in undefined behaviour (including but not limited to deadlocks).</P>
<DIV class=refsect3><A name=id-1.4.3.7.13.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>mutex</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-mutex-trylock></A>
<H3>g_mutex_trylock&nbsp;()</H3><PRE class=programlisting><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A>
g_mutex_trylock (<EM class=parameter><CODE><A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> *mutex</CODE></EM>);</PRE>
<P>Tries to lock <EM class=parameter><CODE>mutex</CODE></EM> . If <EM class=parameter><CODE>mutex</CODE></EM> is already locked by another thread, it immediately returns <A class=link title=FALSE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#FALSE:CAPS"><CODE class=literal>FALSE</CODE></A>. Otherwise it locks <EM class=parameter><CODE>mutex</CODE></EM> and returns <A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A>.</P>
<P><A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> is neither guaranteed to be recursive nor to be non-recursive. As such, calling <A class=link title=g_mutex_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-lock"><CODE class=function>g_mutex_lock()</CODE></A> on a <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> that has already been locked by the same thread results in undefined behaviour (including but not limited to deadlocks or arbitrary return values).</P>
<DIV class=refsect3><A name=id-1.4.3.7.14.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>mutex</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.14.7></A>
<H4>Returns</H4>
<P><A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A> if <EM class=parameter><CODE>mutex</CODE></EM> could be locked</P>
<P></P></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-mutex-unlock></A>
<H3>g_mutex_unlock&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_mutex_unlock (<EM class=parameter><CODE><A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> *mutex</CODE></EM>);</PRE>
<P>Unlocks <EM class=parameter><CODE>mutex</CODE></EM> . If another thread is blocked in a <A class=link title=g_mutex_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-lock"><CODE class=function>g_mutex_lock()</CODE></A> call for <EM class=parameter><CODE>mutex</CODE></EM> , it will become unblocked and can lock <EM class=parameter><CODE>mutex</CODE></EM> itself.</P>
<P>Calling <A class=link title=g_mutex_unlock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-unlock"><CODE class=function>g_mutex_unlock()</CODE></A> on a mutex that is not locked by the current thread leads to undefined behaviour.</P>
<DIV class=refsect3><A name=id-1.4.3.7.15.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>mutex</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=G-LOCK-DEFINE:CAPS></A>
<H3>G_LOCK_DEFINE()</H3><PRE class=programlisting>#define G_LOCK_DEFINE(name)    
</PRE>
<P>The <SPAN class=type>G_LOCK_</SPAN> macros provide a convenient interface to <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A>. <A class=link title=G_LOCK_DEFINE() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK-DEFINE:CAPS"><SPAN class=type>G_LOCK_DEFINE</SPAN></A> defines a lock. It can appear in any place where variable definitions may appear in programs, i.e. in the first block of a function or outside of functions. The <EM class=parameter><CODE>name</CODE></EM> parameter will be mangled to get the name of the <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A>. This means that you can use names of existing variables as the parameter - e.g. the name of the variable you intend to protect with the lock. Look at our <CODE class=function>give_me_next_number()</CODE> example using the <A class=link title=G_LOCK() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK:CAPS"><SPAN class=type>G_LOCK</SPAN></A> macros:</P>
<P>Here is an example for using the <A class=link title=G_LOCK() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK:CAPS"><SPAN class=type>G_LOCK</SPAN></A> convenience macros:</P>
<DIV class=informalexample>
<TABLE class=listing_frame border=0 cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD class=listing_lines align=right><PRE>1
2
3
4
5
6
7
8
9
10
11
12
13
14</PRE></TD>
<TD class=listing_code><PRE class=programlisting><SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK-DEFINE:CAPS">G_LOCK_DEFINE</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>current_number<SPAN class="gtkdoc opt">);</SPAN>

<SPAN class="gtkdoc kwb">int</SPAN>
<SPAN class=function>give_me_next_number</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class="gtkdoc kwb">static int</SPAN> current_number <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc kwb">int</SPAN> ret_val<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK:CAPS">G_LOCK</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>current_number<SPAN class="gtkdoc opt">);</SPAN>
  ret_val <SPAN class="gtkdoc opt">=</SPAN> current_number <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function>calc_next_number</SPAN> <SPAN class="gtkdoc opt">(</SPAN>current_number<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-UNLOCK:CAPS">G_UNLOCK</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>current_number<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=keyword>return</SPAN> ret_val<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<DIV class=refsect3><A name=id-1.4.3.7.16.8></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>name</P></TD>
<TD class=parameter_description>
<P>the name of the lock</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=G-LOCK-DEFINE-STATIC:CAPS></A>
<H3>G_LOCK_DEFINE_STATIC()</H3><PRE class=programlisting>#define G_LOCK_DEFINE_STATIC(name)
</PRE>
<P>This works like <A class=link title=G_LOCK_DEFINE() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK-DEFINE:CAPS"><SPAN class=type>G_LOCK_DEFINE</SPAN></A>, but it creates a static object.</P>
<DIV class=refsect3><A name=id-1.4.3.7.17.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>name</P></TD>
<TD class=parameter_description>
<P>the name of the lock</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=G-LOCK-EXTERN:CAPS></A>
<H3>G_LOCK_EXTERN()</H3><PRE class=programlisting>#define G_LOCK_EXTERN(name)    
</PRE>
<P>This declares a lock, that is defined with <A class=link title=G_LOCK_DEFINE() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK-DEFINE:CAPS"><SPAN class=type>G_LOCK_DEFINE</SPAN></A> in another module.</P>
<DIV class=refsect3><A name=id-1.4.3.7.18.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>name</P></TD>
<TD class=parameter_description>
<P>the name of the lock</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=G-LOCK:CAPS></A>
<H3>G_LOCK()</H3><PRE class=programlisting>#define G_LOCK(name)
</PRE>
<P>Works like <A class=link title=g_mutex_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-lock"><CODE class=function>g_mutex_lock()</CODE></A>, but for a lock defined with <A class=link title=G_LOCK_DEFINE() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK-DEFINE:CAPS"><SPAN class=type>G_LOCK_DEFINE</SPAN></A>.</P>
<DIV class=refsect3><A name=id-1.4.3.7.19.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>name</P></TD>
<TD class=parameter_description>
<P>the name of the lock</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=G-TRYLOCK:CAPS></A>
<H3>G_TRYLOCK()</H3><PRE class=programlisting>#define G_TRYLOCK(name)
</PRE>
<P>Works like <A class=link title=g_mutex_trylock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-trylock"><CODE class=function>g_mutex_trylock()</CODE></A>, but for a lock defined with <A class=link title=G_LOCK_DEFINE() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK-DEFINE:CAPS"><SPAN class=type>G_LOCK_DEFINE</SPAN></A>.</P>
<DIV class=refsect3><A name=id-1.4.3.7.20.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>name</P></TD>
<TD class=parameter_description>
<P>the name of the lock</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.20.6></A>
<H4>Returns</H4>
<P><A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A>, if the lock could be locked.</P>
<P></P></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=G-UNLOCK:CAPS></A>
<H3>G_UNLOCK()</H3><PRE class=programlisting>#define G_UNLOCK(name)
</PRE>
<P>Works like <A class=link title=g_mutex_unlock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-unlock"><CODE class=function>g_mutex_unlock()</CODE></A>, but for a lock defined with <A class=link title=G_LOCK_DEFINE() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-LOCK-DEFINE:CAPS"><SPAN class=type>G_LOCK_DEFINE</SPAN></A>.</P>
<DIV class=refsect3><A name=id-1.4.3.7.21.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>name</P></TD>
<TD class=parameter_description>
<P>the name of the lock</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-rec-mutex-init></A>
<H3>g_rec_mutex_init&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_rec_mutex_init (<EM class=parameter><CODE><A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A> *rec_mutex</CODE></EM>);</PRE>
<P>Initializes a <A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A> so that it can be used.</P>
<P>This function is useful to initialize a recursive mutex that has been allocated on the stack, or as part of a larger structure.</P>
<P>It is not necessary to initialise a recursive mutex that has been statically allocated.</P>
<DIV class=informalexample>
<TABLE class=listing_frame border=0 cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD class=listing_lines align=right><PRE>1
2
3
4
5
6
7
8
9</PRE></TD>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwc">typedef</SPAN> <SPAN class="gtkdoc kwb">struct</SPAN> <SPAN class="gtkdoc opt">{</SPAN>
  GRecMutex m<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc opt">...</SPAN>
<SPAN class="gtkdoc opt">}</SPAN> Blob<SPAN class="gtkdoc opt">;</SPAN>

Blob <SPAN class="gtkdoc opt">*</SPAN>b<SPAN class="gtkdoc opt">;</SPAN>

b <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Memory-Allocation.html#g-new">g_new</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>Blob<SPAN class="gtkdoc opt">,</SPAN> <SPAN class=number>1</SPAN><SPAN class="gtkdoc opt">);</SPAN>
<SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-init">g_rec_mutex_init</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>b<SPAN class="gtkdoc opt">-&gt;</SPAN>m<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Calling <A class=link title=g_rec_mutex_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-init"><CODE class=function>g_rec_mutex_init()</CODE></A> on an already initialized <A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A> leads to undefined behaviour.</P>
<P>To undo the effect of <A class=link title=g_rec_mutex_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-init"><CODE class=function>g_rec_mutex_init()</CODE></A> when a recursive mutex is no longer needed, use <A class=link title=g_rec_mutex_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-clear"><CODE class=function>g_rec_mutex_clear()</CODE></A>.</P>
<DIV class=refsect3><A name=id-1.4.3.7.22.11></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>rec_mutex</P></TD>
<TD class=parameter_description>
<P>an uninitialized <A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-rec-mutex-clear></A>
<H3>g_rec_mutex_clear&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_rec_mutex_clear (<EM class=parameter><CODE><A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A> *rec_mutex</CODE></EM>);</PRE>
<P>Frees the resources allocated to a recursive mutex with <A class=link title=g_rec_mutex_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-init"><CODE class=function>g_rec_mutex_init()</CODE></A>.</P>
<P>This function should not be used with a <A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A> that has been statically allocated.</P>
<P>Calling <A class=link title=g_rec_mutex_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-clear"><CODE class=function>g_rec_mutex_clear()</CODE></A> on a locked recursive mutex leads to undefined behaviour.</P>
<P>Sine: 2.32</P>
<DIV class=refsect3><A name=id-1.4.3.7.23.8></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>rec_mutex</P></TD>
<TD class=parameter_description>
<P>an initialized <A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-rec-mutex-lock></A>
<H3>g_rec_mutex_lock&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_rec_mutex_lock (<EM class=parameter><CODE><A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A> *rec_mutex</CODE></EM>);</PRE>
<P>Locks <EM class=parameter><CODE>rec_mutex</CODE></EM> . If <EM class=parameter><CODE>rec_mutex</CODE></EM> is already locked by another thread, the current thread will block until <EM class=parameter><CODE>rec_mutex</CODE></EM> is unlocked by the other thread. If <EM class=parameter><CODE>rec_mutex</CODE></EM> is already locked by the current thread, the 'lock count' of <EM class=parameter><CODE>rec_mutex</CODE></EM> is increased. The mutex will only become available again when it is unlocked as many times as it has been locked.</P>
<DIV class=refsect3><A name=id-1.4.3.7.24.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>rec_mutex</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-rec-mutex-trylock></A>
<H3>g_rec_mutex_trylock&nbsp;()</H3><PRE class=programlisting><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A>
g_rec_mutex_trylock (<EM class=parameter><CODE><A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A> *rec_mutex</CODE></EM>);</PRE>
<P>Tries to lock <EM class=parameter><CODE>rec_mutex</CODE></EM> . If <EM class=parameter><CODE>rec_mutex</CODE></EM> is already locked by another thread, it immediately returns <A class=link title=FALSE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#FALSE:CAPS"><CODE class=literal>FALSE</CODE></A>. Otherwise it locks <EM class=parameter><CODE>rec_mutex</CODE></EM> and returns <A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A>.</P>
<DIV class=refsect3><A name=id-1.4.3.7.25.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>rec_mutex</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.25.6></A>
<H4>Returns</H4>
<P><A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A> if <EM class=parameter><CODE>rec_mutex</CODE></EM> could be locked</P>
<P></P></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-rec-mutex-unlock></A>
<H3>g_rec_mutex_unlock&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_rec_mutex_unlock (<EM class=parameter><CODE><A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A> *rec_mutex</CODE></EM>);</PRE>
<P>Unlocks <EM class=parameter><CODE>rec_mutex</CODE></EM> . If another thread is blocked in a <A class=link title=g_rec_mutex_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-lock"><CODE class=function>g_rec_mutex_lock()</CODE></A> call for <EM class=parameter><CODE>rec_mutex</CODE></EM> , it will become unblocked and can lock <EM class=parameter><CODE>rec_mutex</CODE></EM> itself.</P>
<P>Calling <A class=link title=g_rec_mutex_unlock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-unlock"><CODE class=function>g_rec_mutex_unlock()</CODE></A> on a recursive mutex that is not locked by the current thread leads to undefined behaviour.</P>
<DIV class=refsect3><A name=id-1.4.3.7.26.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>rec_mutex</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-rw-lock-init></A>
<H3>g_rw_lock_init&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_rw_lock_init (<EM class=parameter><CODE><A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A> *rw_lock</CODE></EM>);</PRE>
<P>Initializes a <A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A> so that it can be used.</P>
<P>This function is useful to initialize a lock that has been allocated on the stack, or as part of a larger structure. It is not necessary to initialise a reader-writer lock that has been statically allocated.</P>
<DIV class=informalexample>
<TABLE class=listing_frame border=0 cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD class=listing_lines align=right><PRE>1
2
3
4
5
6
7
8
9</PRE></TD>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwc">typedef</SPAN> <SPAN class="gtkdoc kwb">struct</SPAN> <SPAN class="gtkdoc opt">{</SPAN>
  GRWLock l<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc opt">...</SPAN>
<SPAN class="gtkdoc opt">}</SPAN> Blob<SPAN class="gtkdoc opt">;</SPAN>

Blob <SPAN class="gtkdoc opt">*</SPAN>b<SPAN class="gtkdoc opt">;</SPAN>

b <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Memory-Allocation.html#g-new">g_new</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>Blob<SPAN class="gtkdoc opt">,</SPAN> <SPAN class=number>1</SPAN><SPAN class="gtkdoc opt">);</SPAN>
<SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-init">g_rw_lock_init</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>b<SPAN class="gtkdoc opt">-&gt;</SPAN>l<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>To undo the effect of <A class=link title=g_rw_lock_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-init"><CODE class=function>g_rw_lock_init()</CODE></A> when a lock is no longer needed, use <A class=link title=g_rw_lock_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-clear"><CODE class=function>g_rw_lock_clear()</CODE></A>.</P>
<P>Calling <A class=link title=g_rw_lock_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-init"><CODE class=function>g_rw_lock_init()</CODE></A> on an already initialized <A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A> leads to undefined behaviour.</P>
<DIV class=refsect3><A name=id-1.4.3.7.27.10></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>rw_lock</P></TD>
<TD class=parameter_description>
<P>an uninitialized <A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-rw-lock-clear></A>
<H3>g_rw_lock_clear&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_rw_lock_clear (<EM class=parameter><CODE><A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A> *rw_lock</CODE></EM>);</PRE>
<P>Frees the resources allocated to a lock with <A class=link title=g_rw_lock_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-init"><CODE class=function>g_rw_lock_init()</CODE></A>.</P>
<P>This function should not be used with a <A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A> that has been statically allocated.</P>
<P>Calling <A class=link title=g_rw_lock_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-clear"><CODE class=function>g_rw_lock_clear()</CODE></A> when any thread holds the lock leads to undefined behaviour.</P>
<P>Sine: 2.32</P>
<DIV class=refsect3><A name=id-1.4.3.7.28.8></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>rw_lock</P></TD>
<TD class=parameter_description>
<P>an initialized <A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-rw-lock-writer-lock></A>
<H3>g_rw_lock_writer_lock&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_rw_lock_writer_lock (<EM class=parameter><CODE><A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A> *rw_lock</CODE></EM>);</PRE>
<P>Obtain a write lock on <EM class=parameter><CODE>rw_lock</CODE></EM> . If any thread already holds a read or write lock on <EM class=parameter><CODE>rw_lock</CODE></EM> , the current thread will block until all other threads have dropped their locks on <EM class=parameter><CODE>rw_lock</CODE></EM> .</P>
<DIV class=refsect3><A name=id-1.4.3.7.29.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>rw_lock</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-rw-lock-writer-trylock></A>
<H3>g_rw_lock_writer_trylock&nbsp;()</H3><PRE class=programlisting><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A>
g_rw_lock_writer_trylock (<EM class=parameter><CODE><A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A> *rw_lock</CODE></EM>);</PRE>
<P>Tries to obtain a write lock on <EM class=parameter><CODE>rw_lock</CODE></EM> . If any other thread holds a read or write lock on <EM class=parameter><CODE>rw_lock</CODE></EM> , it immediately returns <A class=link title=FALSE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#FALSE:CAPS"><CODE class=literal>FALSE</CODE></A>. Otherwise it locks <EM class=parameter><CODE>rw_lock</CODE></EM> and returns <A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A>.</P>
<DIV class=refsect3><A name=id-1.4.3.7.30.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>rw_lock</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.30.6></A>
<H4>Returns</H4>
<P><A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A> if <EM class=parameter><CODE>rw_lock</CODE></EM> could be locked</P>
<P></P></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-rw-lock-writer-unlock></A>
<H3>g_rw_lock_writer_unlock&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_rw_lock_writer_unlock (<EM class=parameter><CODE><A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A> *rw_lock</CODE></EM>);</PRE>
<P>Release a write lock on <EM class=parameter><CODE>rw_lock</CODE></EM> .</P>
<P>Calling <A class=link title=g_rw_lock_writer_unlock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-writer-unlock"><CODE class=function>g_rw_lock_writer_unlock()</CODE></A> on a lock that is not held by the current thread leads to undefined behaviour.</P>
<DIV class=refsect3><A name=id-1.4.3.7.31.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>rw_lock</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-rw-lock-reader-lock></A>
<H3>g_rw_lock_reader_lock&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_rw_lock_reader_lock (<EM class=parameter><CODE><A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A> *rw_lock</CODE></EM>);</PRE>
<P>Obtain a read lock on <EM class=parameter><CODE>rw_lock</CODE></EM> . If another thread currently holds the write lock on <EM class=parameter><CODE>rw_lock</CODE></EM> or blocks waiting for it, the current thread will block. Read locks can be taken recursively.</P>
<P>It is implementation-defined how many threads are allowed to hold read locks on the same lock simultaneously.</P>
<DIV class=refsect3><A name=id-1.4.3.7.32.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>rw_lock</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-rw-lock-reader-trylock></A>
<H3>g_rw_lock_reader_trylock&nbsp;()</H3><PRE class=programlisting><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A>
g_rw_lock_reader_trylock (<EM class=parameter><CODE><A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A> *rw_lock</CODE></EM>);</PRE>
<P>Tries to obtain a read lock on <EM class=parameter><CODE>rw_lock</CODE></EM> and returns <A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A> if the read lock was successfully obtained. Otherwise it returns <A class=link title=FALSE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#FALSE:CAPS"><CODE class=literal>FALSE</CODE></A>.</P>
<DIV class=refsect3><A name=id-1.4.3.7.33.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>rw_lock</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.33.6></A>
<H4>Returns</H4>
<P><A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A> if <EM class=parameter><CODE>rw_lock</CODE></EM> could be locked</P>
<P></P></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-rw-lock-reader-unlock></A>
<H3>g_rw_lock_reader_unlock&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_rw_lock_reader_unlock (<EM class=parameter><CODE><A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A> *rw_lock</CODE></EM>);</PRE>
<P>Release a read lock on <EM class=parameter><CODE>rw_lock</CODE></EM> .</P>
<P>Calling <A class=link title=g_rw_lock_reader_unlock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-reader-unlock"><CODE class=function>g_rw_lock_reader_unlock()</CODE></A> on a lock that is not held by the current thread leads to undefined behaviour.</P>
<DIV class=refsect3><A name=id-1.4.3.7.34.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>rw_lock</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-cond-init></A>
<H3>g_cond_init&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_cond_init (<EM class=parameter><CODE><A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> *cond</CODE></EM>);</PRE>
<P>Initialises a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> so that it can be used.</P>
<P>This function is useful to initialise a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> that has been allocated as part of a larger structure. It is not necessary to initialise a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> that has been statically allocated.</P>
<P>To undo the effect of <A class=link title=g_cond_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-init"><CODE class=function>g_cond_init()</CODE></A> when a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> is no longer needed, use <A class=link title=g_cond_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-clear"><CODE class=function>g_cond_clear()</CODE></A>.</P>
<P>Calling <A class=link title=g_cond_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-init"><CODE class=function>g_cond_init()</CODE></A> on an already-initialised <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> leads to undefined behaviour.</P>
<DIV class=refsect3><A name=id-1.4.3.7.35.8></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>cond</P></TD>
<TD class=parameter_description>
<P>an uninitialized <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-cond-clear></A>
<H3>g_cond_clear&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_cond_clear (<EM class=parameter><CODE><A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> *cond</CODE></EM>);</PRE>
<P>Frees the resources allocated to a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> with <A class=link title=g_cond_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-init"><CODE class=function>g_cond_init()</CODE></A>.</P>
<P>This function should not be used with a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> that has been statically allocated.</P>
<P>Calling <A class=link title=g_cond_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-clear"><CODE class=function>g_cond_clear()</CODE></A> for a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> on which threads are blocking leads to undefined behaviour.</P>
<DIV class=refsect3><A name=id-1.4.3.7.36.7></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>cond</P></TD>
<TD class=parameter_description>
<P>an initialised <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-cond-wait></A>
<H3>g_cond_wait&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_cond_wait (<EM class=parameter><CODE><A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> *cond</CODE></EM>,
             <EM class=parameter><CODE><A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> *mutex</CODE></EM>);</PRE>
<P>Atomically releases <EM class=parameter><CODE>mutex</CODE></EM> and waits until <EM class=parameter><CODE>cond</CODE></EM> is signalled. When this function returns, <EM class=parameter><CODE>mutex</CODE></EM> is locked again and owned by the calling thread.</P>
<P>When using condition variables, it is possible that a spurious wakeup may occur (ie: <A class=link title=g_cond_wait&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-wait"><CODE class=function>g_cond_wait()</CODE></A> returns even though <A class=link title=g_cond_signal&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-signal"><CODE class=function>g_cond_signal()</CODE></A> was not called). It's also possible that a stolen wakeup may occur. This is when <A class=link title=g_cond_signal&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-signal"><CODE class=function>g_cond_signal()</CODE></A> is called, but another thread acquires <EM class=parameter><CODE>mutex</CODE></EM> before this thread and modifies the state of the program in such a way that when <A class=link title=g_cond_wait&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-wait"><CODE class=function>g_cond_wait()</CODE></A> is able to return, the expected condition is no longer met.</P>
<P>For this reason, <A class=link title=g_cond_wait&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-wait"><CODE class=function>g_cond_wait()</CODE></A> must always be used in a loop. See the documentation for <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> for a complete example.</P>
<DIV class=refsect3><A name=id-1.4.3.7.37.7></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>cond</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>mutex</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> that is currently locked</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-cond-timed-wait></A>
<H3>g_cond_timed_wait&nbsp;()</H3><PRE class=programlisting><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A>
g_cond_timed_wait (<EM class=parameter><CODE><A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> *cond</CODE></EM>,
                   <EM class=parameter><CODE><A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> *mutex</CODE></EM>,
                   <EM class=parameter><CODE><A class=link title="struct GTimeVal" href="https://developer.gnome.org/glib/stable/glib-Date-and-Time-Functions.html#GTimeVal"><SPAN class=type>GTimeVal</SPAN></A> *abs_time</CODE></EM>);</PRE>
<DIV class=warning>
<P><CODE class=literal>g_cond_timed_wait</CODE> has been deprecated since version 2.32 and should not be used in newly-written code.</P>
<P>Use <A class=link title=g_cond_wait_until&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-wait-until"><CODE class=function>g_cond_wait_until()</CODE></A> instead.</P></DIV>
<P>Waits until this thread is woken up on <EM class=parameter><CODE>cond</CODE></EM> , but not longer than until the time specified by <EM class=parameter><CODE>abs_time</CODE></EM> . The <EM class=parameter><CODE>mutex</CODE></EM> is unlocked before falling asleep and locked again before resuming.</P>
<P>If <EM class=parameter><CODE>abs_time</CODE></EM> is <A class=link title=NULL href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#NULL:CAPS"><CODE class=literal>NULL</CODE></A>, <A class=link title=g_cond_timed_wait&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-timed-wait"><CODE class=function>g_cond_timed_wait()</CODE></A> acts like <A class=link title=g_cond_wait&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-wait"><CODE class=function>g_cond_wait()</CODE></A>.</P>
<P>This function can be used even if <A class=link title=g_thread_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Deprecated-Thread-APIs.html#g-thread-init"><CODE class=function>g_thread_init()</CODE></A> has not yet been called, and, in that case, will immediately return <A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A>.</P>
<P>To easily calculate <EM class=parameter><CODE>abs_time</CODE></EM> a combination of <A class=link title=g_get_current_time&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Date-and-Time-Functions.html#g-get-current-time"><CODE class=function>g_get_current_time()</CODE></A> and <A class=link title=g_time_val_add&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Date-and-Time-Functions.html#g-time-val-add"><CODE class=function>g_time_val_add()</CODE></A> can be used.</P>
<DIV class=refsect3><A name=id-1.4.3.7.38.9></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>cond</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>mutex</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> that is currently locked</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>abs_time</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GTimeVal" href="https://developer.gnome.org/glib/stable/glib-Date-and-Time-Functions.html#GTimeVal"><SPAN class=type>GTimeVal</SPAN></A>, determining the final time</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.38.10></A>
<H4>Returns</H4>
<P><A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A> if <EM class=parameter><CODE>cond</CODE></EM> was signalled, or <A class=link title=FALSE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#FALSE:CAPS"><CODE class=literal>FALSE</CODE></A> on timeout</P>
<P></P></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-cond-wait-until></A>
<H3>g_cond_wait_until&nbsp;()</H3><PRE class=programlisting><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A>
g_cond_wait_until (<EM class=parameter><CODE><A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> *cond</CODE></EM>,
                   <EM class=parameter><CODE><A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> *mutex</CODE></EM>,
                   <EM class=parameter><CODE><A class=link title=gint64 href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gint64"><SPAN class=type>gint64</SPAN></A> end_time</CODE></EM>);</PRE>
<P>Waits until either <EM class=parameter><CODE>cond</CODE></EM> is signalled or <EM class=parameter><CODE>end_time</CODE></EM> has passed.</P>
<P>As with <A class=link title=g_cond_wait&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-wait"><CODE class=function>g_cond_wait()</CODE></A> it is possible that a spurious or stolen wakeup could occur. For that reason, waiting on a condition variable should always be in a loop, based on an explicitly-checked predicate.</P>
<P><A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A> is returned if the condition variable was signalled (or in the case of a spurious wakeup). <A class=link title=FALSE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#FALSE:CAPS"><CODE class=literal>FALSE</CODE></A> is returned if <EM class=parameter><CODE>end_time</CODE></EM> has passed.</P>
<P>The following code shows how to correctly perform a timed wait on a condition variable (extending the example presented in the documentation for <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A>):</P>
<DIV class=informalexample>
<TABLE class=listing_frame border=0 cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD class=listing_lines align=right><PRE>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</PRE></TD>
<TD class=listing_code><PRE class=programlisting>gpointer
<SPAN class=function>pop_data_timed</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  gint64 end_time<SPAN class="gtkdoc opt">;</SPAN>
  gpointer data<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-lock">g_mutex_lock</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>data_mutex<SPAN class="gtkdoc opt">);</SPAN>

  end_time <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Date-and-Time-Functions.html#g-get-monotonic-time">g_get_monotonic_time</A></SPAN> <SPAN class="gtkdoc opt">() +</SPAN> <SPAN class=number>5</SPAN> <SPAN class="gtkdoc opt">*</SPAN> G_TIME_SPAN_SECOND<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class=keyword>while</SPAN> <SPAN class="gtkdoc opt">(!</SPAN>current_data<SPAN class="gtkdoc opt">)</SPAN>
    <SPAN class=keyword>if</SPAN> <SPAN class="gtkdoc opt">(!</SPAN><SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-wait-until">g_cond_wait_until</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>data_cond<SPAN class="gtkdoc opt">, &amp;</SPAN>data_mutex<SPAN class="gtkdoc opt">,</SPAN> end_time<SPAN class="gtkdoc opt">))</SPAN>
      <SPAN class="gtkdoc opt">{</SPAN>
        <SPAN class="gtkdoc slc">// timeout has passed.</SPAN>
        <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-unlock">g_mutex_unlock</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>data_mutex<SPAN class="gtkdoc opt">);</SPAN>
        <SPAN class=keyword>return</SPAN> NULL<SPAN class="gtkdoc opt">;</SPAN>
      <SPAN class="gtkdoc opt">}</SPAN>

  <SPAN class="gtkdoc slc">// there is data for us</SPAN>
  data <SPAN class="gtkdoc opt">=</SPAN> current_data<SPAN class="gtkdoc opt">;</SPAN>
  current_data <SPAN class="gtkdoc opt">=</SPAN> NULL<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-unlock">g_mutex_unlock</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>data_mutex<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=keyword>return</SPAN> data<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>Notice that the end time is calculated once, before entering the loop and reused. This is the motivation behind the use of absolute time on this API -- if a relative time of 5 seconds were passed directly to the call and a spurious wakeup occurred, the program would have to start over waiting again (which would lead to a total wait time of more than 5 seconds).</P>
<DIV class=refsect3><A name=id-1.4.3.7.39.11></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>cond</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>mutex</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> that is currently locked</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>end_time</P></TD>
<TD class=parameter_description>
<P>the monotonic time to wait until</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.39.12></A>
<H4>Returns</H4>
<P><A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A> on a signal, <A class=link title=FALSE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#FALSE:CAPS"><CODE class=literal>FALSE</CODE></A> on a timeout</P>
<P></P></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-cond-signal></A>
<H3>g_cond_signal&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_cond_signal (<EM class=parameter><CODE><A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> *cond</CODE></EM>);</PRE>
<P>If threads are waiting for <EM class=parameter><CODE>cond</CODE></EM> , at least one of them is unblocked. If no threads are waiting for <EM class=parameter><CODE>cond</CODE></EM> , this function has no effect. It is good practice to hold the same lock as the waiting thread while calling this function, though not required.</P>
<DIV class=refsect3><A name=id-1.4.3.7.40.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>cond</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-cond-broadcast></A>
<H3>g_cond_broadcast&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_cond_broadcast (<EM class=parameter><CODE><A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> *cond</CODE></EM>);</PRE>
<P>If threads are waiting for <EM class=parameter><CODE>cond</CODE></EM> , all of them are unblocked. If no threads are waiting for <EM class=parameter><CODE>cond</CODE></EM> , this function has no effect. It is good practice to lock the same mutex as the waiting threads while calling this function, though not required.</P>
<DIV class=refsect3><A name=id-1.4.3.7.41.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>cond</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=G-PRIVATE-INIT:CAPS></A>
<H3>G_PRIVATE_INIT()</H3><PRE class=programlisting>#define G_PRIVATE_INIT(notify)
</PRE>
<P>A macro to assist with the static initialisation of a <A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A>.</P>
<P>This macro is useful for the case that a <A class=link title=GDestroyNotify&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Datasets.html#GDestroyNotify"><SPAN class=type>GDestroyNotify</SPAN></A> function should be associated the key. This is needed when the key will be used to point at memory that should be deallocated when the thread exits.</P>
<P>Additionally, the <A class=link title=GDestroyNotify&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Datasets.html#GDestroyNotify"><SPAN class=type>GDestroyNotify</SPAN></A> will also be called on the previous value stored in the key when <A class=link title=g_private_replace&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-private-replace"><CODE class=function>g_private_replace()</CODE></A> is used.</P>
<P>If no <A class=link title=GDestroyNotify&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Datasets.html#GDestroyNotify"><SPAN class=type>GDestroyNotify</SPAN></A> is needed, then use of this macro is not required -- if the <A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A> is declared in static scope then it will be properly initialised by default (ie: to all zeros). See the examples below.</P>
<DIV class=informalexample>
<TABLE class=listing_frame border=0 cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD class=listing_lines align=right><PRE>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</PRE></TD>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwb">static</SPAN> GPrivate name_key <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-PRIVATE-INIT:CAPS">G_PRIVATE_INIT</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>g_free<SPAN class="gtkdoc opt">);</SPAN>

<SPAN class="gtkdoc slc">// return value should not be freed</SPAN>
<SPAN class="gtkdoc kwb">const</SPAN> gchar <SPAN class="gtkdoc opt">*</SPAN>
<SPAN class=function>get_local_name</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class=keyword>return</SPAN> <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-private-get">g_private_get</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>name_key<SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class="gtkdoc kwb">void</SPAN>
<SPAN class=function>set_local_name</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">const</SPAN> gchar <SPAN class="gtkdoc opt">*</SPAN>name<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-private-replace">g_private_replace</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>name_key<SPAN class="gtkdoc opt">,</SPAN> <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-String-Utility-Functions.html#g-strdup">g_strdup</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>name<SPAN class="gtkdoc opt">));</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>


<SPAN class="gtkdoc kwb">static</SPAN> GPrivate count_key<SPAN class="gtkdoc opt">;</SPAN>   <SPAN class="gtkdoc slc">// no free function</SPAN>

gint
<SPAN class=function>get_local_count</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class=keyword>return</SPAN> <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Type-Conversion-Macros.html#GPOINTER-TO-INT:CAPS">GPOINTER_TO_INT</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-private-get">g_private_get</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>count_key<SPAN class="gtkdoc opt">));</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class="gtkdoc kwb">void</SPAN>
<SPAN class=function>set_local_count</SPAN> <SPAN class="gtkdoc opt">(</SPAN>gint count<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-private-set">g_private_set</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>count_key<SPAN class="gtkdoc opt">,</SPAN> <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Type-Conversion-Macros.html#GINT-TO-POINTER:CAPS">GINT_TO_POINTER</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>count<SPAN class="gtkdoc opt">));</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<DIV class=refsect3><A name=id-1.4.3.7.42.10></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>notify</P></TD>
<TD class=parameter_description>
<P>a <A class=link title=GDestroyNotify&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Datasets.html#GDestroyNotify"><SPAN class=type>GDestroyNotify</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-private-get></A>
<H3>g_private_get&nbsp;()</H3><PRE class=programlisting><A class=link title=gpointer href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=returnvalue>gpointer</SPAN></A>
g_private_get (<EM class=parameter><CODE><A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A> *key</CODE></EM>);</PRE>
<P>Returns the current value of the thread local variable <EM class=parameter><CODE>key</CODE></EM> .</P>
<P>If the value has not yet been set in this thread, <A class=link title=NULL href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#NULL:CAPS"><CODE class=literal>NULL</CODE></A> is returned. Values are never copied between threads (when a new thread is created, for example).</P>
<DIV class=refsect3><A name=id-1.4.3.7.43.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>key</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.43.7></A>
<H4>Returns</H4>
<P>the thread-local value</P>
<P></P></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-private-set></A>
<H3>g_private_set&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_private_set (<EM class=parameter><CODE><A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A> *key</CODE></EM>,
               <EM class=parameter><CODE><A class=link title=gpointer href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=type>gpointer</SPAN></A> value</CODE></EM>);</PRE>
<P>Sets the thread local variable <EM class=parameter><CODE>key</CODE></EM> to have the value <EM class=parameter><CODE>value</CODE></EM> in the current thread.</P>
<P>This function differs from <A class=link title=g_private_replace&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-private-replace"><CODE class=function>g_private_replace()</CODE></A> in the following way: the <A class=link title=GDestroyNotify&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Datasets.html#GDestroyNotify"><SPAN class=type>GDestroyNotify</SPAN></A> for <EM class=parameter><CODE>key</CODE></EM> is not called on the old value.</P>
<DIV class=refsect3><A name=id-1.4.3.7.44.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>key</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>value</P></TD>
<TD class=parameter_description>
<P>the new value</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-private-replace></A>
<H3>g_private_replace&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_private_replace (<EM class=parameter><CODE><A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A> *key</CODE></EM>,
                   <EM class=parameter><CODE><A class=link title=gpointer href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=type>gpointer</SPAN></A> value</CODE></EM>);</PRE>
<P>Sets the thread local variable <EM class=parameter><CODE>key</CODE></EM> to have the value <EM class=parameter><CODE>value</CODE></EM> in the current thread.</P>
<P>This function differs from <A class=link title=g_private_set&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-private-set"><CODE class=function>g_private_set()</CODE></A> in the following way: if the previous value was non-<A class=link title=NULL href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#NULL:CAPS"><CODE class=literal>NULL</CODE></A> then the <A class=link title=GDestroyNotify&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Datasets.html#GDestroyNotify"><SPAN class=type>GDestroyNotify</SPAN></A> handler for <EM class=parameter><CODE>key</CODE></EM> is run on it.</P>
<DIV class=refsect3><A name=id-1.4.3.7.45.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>key</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A></P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>value</P></TD>
<TD class=parameter_description>
<P>the new value</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-once></A>
<H3>g_once()</H3><PRE class=programlisting>#define             g_once(once, func, arg)</PRE>
<P>The first call to this routine by a process with a given <A class=link title="struct GOnce" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnce"><SPAN class=type>GOnce</SPAN></A> struct calls <EM class=parameter><CODE>func</CODE></EM> with the given argument. Thereafter, subsequent calls to <A class=link title=g_once() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once"><CODE class=function>g_once()</CODE></A> with the same <A class=link title="struct GOnce" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnce"><SPAN class=type>GOnce</SPAN></A> struct do not call <EM class=parameter><CODE>func</CODE></EM> again, but return the stored result of the first call. On return from <A class=link title=g_once() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once"><CODE class=function>g_once()</CODE></A>, the status of <EM class=parameter><CODE>once</CODE></EM> will be <A class=link href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-ONCE-STATUS-READY:CAPS"><CODE class=literal>G_ONCE_STATUS_READY</CODE></A>.</P>
<P>For example, a mutex or a thread-specific data key must be created exactly once. In a threaded environment, calling <A class=link title=g_once() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once"><CODE class=function>g_once()</CODE></A> ensures that the initialization is serialized across multiple threads.</P>
<P>Calling <A class=link title=g_once() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once"><CODE class=function>g_once()</CODE></A> recursively on the same <A class=link title="struct GOnce" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnce"><SPAN class=type>GOnce</SPAN></A> struct in <EM class=parameter><CODE>func</CODE></EM> will lead to a deadlock.</P>
<DIV class=informalexample>
<TABLE class=listing_frame border=0 cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD class=listing_lines align=right><PRE>1
2
3
4
5
6
7
8
9</PRE></TD>
<TD class=listing_code><PRE class=programlisting>gpointer
<SPAN class=function>get_debug_flags</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class="gtkdoc kwb">static</SPAN> GOnce my_once <SPAN class="gtkdoc opt">=</SPAN> G_ONCE_INIT<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once">g_once</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>my_once<SPAN class="gtkdoc opt">,</SPAN> parse_debug_flags<SPAN class="gtkdoc opt">,</SPAN> NULL<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=keyword>return</SPAN> my_once<SPAN class="gtkdoc opt">.</SPAN>retval<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<DIV class=refsect3><A name=id-1.4.3.7.46.9></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>once</P></TD>
<TD class=parameter_description>
<P>a <A class=link title="struct GOnce" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnce"><SPAN class=type>GOnce</SPAN></A> structure</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>func</P></TD>
<TD class=parameter_description>
<P>the <A class=link title=GThreadFunc&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThreadFunc"><SPAN class=type>GThreadFunc</SPAN></A> function associated to <EM class=parameter><CODE>once</CODE></EM> . This function is called only once, regardless of the number of times it and its associated <A class=link title="struct GOnce" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnce"><SPAN class=type>GOnce</SPAN></A> struct are passed to <A class=link title=g_once() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once"><CODE class=function>g_once()</CODE></A>.</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>arg</P></TD>
<TD class=parameter_description>
<P>data to be passed to <EM class=parameter><CODE>func</CODE></EM> </P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.4</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-once-init-enter></A>
<H3>g_once_init_enter&nbsp;()</H3><PRE class=programlisting><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A>
g_once_init_enter (<EM class=parameter><CODE>volatile <SPAN class=type>void</SPAN> *location</CODE></EM>);</PRE>
<P>Function to be called when starting a critical initialization section. The argument <EM class=parameter><CODE>location</CODE></EM> must point to a static 0-initialized variable that will be set to a value other than 0 at the end of the initialization section. In combination with <A class=link title=g_once_init_leave&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once-init-leave"><CODE class=function>g_once_init_leave()</CODE></A> and the unique address <EM class=parameter><CODE>value_location</CODE></EM> , it can be ensured that an initialization section will be executed only once during a program's life time, and that concurrent threads are blocked until initialization completed. To be used in constructs like this:</P>
<DIV class=informalexample>
<TABLE class=listing_frame border=0 cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD class=listing_lines align=right><PRE>1
2
3
4
5
6
7
8
9
10</PRE></TD>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwb">static</SPAN> gsize initialization_value <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">;</SPAN>

<SPAN class=keyword>if</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once-init-enter">g_once_init_enter</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>initialization_value<SPAN class="gtkdoc opt">))</SPAN>
  <SPAN class="gtkdoc opt">{</SPAN>
    gsize setup_value <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=number>42</SPAN><SPAN class="gtkdoc opt">;</SPAN> <SPAN class="gtkdoc slc">// initialization code here</SPAN>

    <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once-init-leave">g_once_init_leave</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>initialization_value<SPAN class="gtkdoc opt">,</SPAN> setup_value<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class="gtkdoc opt">}</SPAN>

<SPAN class="gtkdoc slc">// use initialization_value here</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<DIV class=refsect3><A name=id-1.4.3.7.47.7></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>location</P></TD>
<TD class=parameter_description>
<P>location of a static initializable variable containing 0</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.47.8></A>
<H4>Returns</H4>
<P><A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A> if the initialization section should be entered, <A class=link title=FALSE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#FALSE:CAPS"><CODE class=literal>FALSE</CODE></A> and blocks otherwise</P>
<P></P></DIV>
<P class=since>Since 2.14</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-once-init-leave></A>
<H3>g_once_init_leave&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_once_init_leave (<EM class=parameter><CODE>volatile <SPAN class=type>void</SPAN> *location</CODE></EM>,
                   <EM class=parameter><CODE><A class=link title=gsize href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gsize"><SPAN class=type>gsize</SPAN></A> result</CODE></EM>);</PRE>
<P>Counterpart to <A class=link title=g_once_init_enter&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once-init-enter"><CODE class=function>g_once_init_enter()</CODE></A>. Expects a location of a static 0-initialized initialization variable, and an initialization value other than 0. Sets the variable to the initialization value, and releases concurrent threads blocking in <A class=link title=g_once_init_enter&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-once-init-enter"><CODE class=function>g_once_init_enter()</CODE></A> on this initialization variable.</P>
<DIV class=refsect3><A name=id-1.4.3.7.48.5></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>location</P></TD>
<TD class=parameter_description>
<P>location of a static initializable variable containing 0</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>result</P></TD>
<TD class=parameter_description>
<P>new non-0 value for *<EM class=parameter><CODE>value_location</CODE></EM> </P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.14</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-bit-lock></A>
<H3>g_bit_lock&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_bit_lock (<EM class=parameter><CODE>volatile <A class=link title=gint href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gint"><SPAN class=type>gint</SPAN></A> *address</CODE></EM>,
            <EM class=parameter><CODE><A class=link title=gint href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gint"><SPAN class=type>gint</SPAN></A> lock_bit</CODE></EM>);</PRE>
<P>Sets the indicated <EM class=parameter><CODE>lock_bit</CODE></EM> in <EM class=parameter><CODE>address</CODE></EM> . If the bit is already set, this call will block until <A class=link title=g_bit_unlock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-bit-unlock"><CODE class=function>g_bit_unlock()</CODE></A> unsets the corresponding bit.</P>
<P>Attempting to lock on two different bits within the same integer is not supported and will very probably cause deadlocks.</P>
<P>The value of the bit that is set is (1u &lt;&lt; <EM class=parameter><CODE>bit</CODE></EM> ). If <EM class=parameter><CODE>bit</CODE></EM> is not between 0 and 31 then the result is undefined.</P>
<P>This function accesses <EM class=parameter><CODE>address</CODE></EM> atomically. All other accesses to <EM class=parameter><CODE>address</CODE></EM> must be atomic in order for this function to work reliably.</P>
<DIV class=refsect3><A name=id-1.4.3.7.49.8></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>address</P></TD>
<TD class=parameter_description>
<P>a pointer to an integer</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>lock_bit</P></TD>
<TD class=parameter_description>
<P>a bit value between 0 and 31</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.24</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-bit-trylock></A>
<H3>g_bit_trylock&nbsp;()</H3><PRE class=programlisting><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A>
g_bit_trylock (<EM class=parameter><CODE>volatile <A class=link title=gint href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gint"><SPAN class=type>gint</SPAN></A> *address</CODE></EM>,
               <EM class=parameter><CODE><A class=link title=gint href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gint"><SPAN class=type>gint</SPAN></A> lock_bit</CODE></EM>);</PRE>
<P>Sets the indicated <EM class=parameter><CODE>lock_bit</CODE></EM> in <EM class=parameter><CODE>address</CODE></EM> , returning <A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A> if successful. If the bit is already set, returns <A class=link title=FALSE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#FALSE:CAPS"><CODE class=literal>FALSE</CODE></A> immediately.</P>
<P>Attempting to lock on two different bits within the same integer is not supported.</P>
<P>The value of the bit that is set is (1u &lt;&lt; <EM class=parameter><CODE>bit</CODE></EM> ). If <EM class=parameter><CODE>bit</CODE></EM> is not between 0 and 31 then the result is undefined.</P>
<P>This function accesses <EM class=parameter><CODE>address</CODE></EM> atomically. All other accesses to <EM class=parameter><CODE>address</CODE></EM> must be atomic in order for this function to work reliably.</P>
<DIV class=refsect3><A name=id-1.4.3.7.50.8></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>address</P></TD>
<TD class=parameter_description>
<P>a pointer to an integer</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>lock_bit</P></TD>
<TD class=parameter_description>
<P>a bit value between 0 and 31</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.50.9></A>
<H4>Returns</H4>
<P><A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A> if the lock was acquired</P>
<P></P></DIV>
<P class=since>Since 2.24</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-bit-unlock></A>
<H3>g_bit_unlock&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_bit_unlock (<EM class=parameter><CODE>volatile <A class=link title=gint href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gint"><SPAN class=type>gint</SPAN></A> *address</CODE></EM>,
              <EM class=parameter><CODE><A class=link title=gint href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gint"><SPAN class=type>gint</SPAN></A> lock_bit</CODE></EM>);</PRE>
<P>Clears the indicated <EM class=parameter><CODE>lock_bit</CODE></EM> in <EM class=parameter><CODE>address</CODE></EM> . If another thread is currently blocked in <A class=link title=g_bit_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-bit-lock"><CODE class=function>g_bit_lock()</CODE></A> on this same bit then it will be woken up.</P>
<P>This function accesses <EM class=parameter><CODE>address</CODE></EM> atomically. All other accesses to <EM class=parameter><CODE>address</CODE></EM> must be atomic in order for this function to work reliably.</P>
<DIV class=refsect3><A name=id-1.4.3.7.51.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>address</P></TD>
<TD class=parameter_description>
<P>a pointer to an integer</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>lock_bit</P></TD>
<TD class=parameter_description>
<P>a bit value between 0 and 31</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.24</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-pointer-bit-lock></A>
<H3>g_pointer_bit_lock&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_pointer_bit_lock (<EM class=parameter><CODE>volatile <SPAN class=type>void</SPAN> *address</CODE></EM>,
                    <EM class=parameter><CODE><A class=link title=gint href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gint"><SPAN class=type>gint</SPAN></A> lock_bit</CODE></EM>);</PRE>
<P>This is equivalent to g_bit_lock, but working on pointers (or other pointer-sized values).</P>
<P>For portability reasons, you may only lock on the bottom 32 bits of the pointer.</P>
<DIV class=refsect3><A name=id-1.4.3.7.52.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>address</P></TD>
<TD class=parameter_description>
<P>a pointer to a <SPAN class=type>gpointer-sized</SPAN> value</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>lock_bit</P></TD>
<TD class=parameter_description>
<P>a bit value between 0 and 31</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.30</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-pointer-bit-trylock></A>
<H3>g_pointer_bit_trylock&nbsp;()</H3><PRE class=programlisting><A class=link title=gboolean href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gboolean"><SPAN class=returnvalue>gboolean</SPAN></A>
g_pointer_bit_trylock (<EM class=parameter><CODE>volatile <SPAN class=type>void</SPAN> *address</CODE></EM>,
                       <EM class=parameter><CODE><A class=link title=gint href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gint"><SPAN class=type>gint</SPAN></A> lock_bit</CODE></EM>);</PRE>
<P>This is equivalent to g_bit_trylock, but working on pointers (or other pointer-sized values).</P>
<P>For portability reasons, you may only lock on the bottom 32 bits of the pointer.</P>
<DIV class=refsect3><A name=id-1.4.3.7.53.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>address</P></TD>
<TD class=parameter_description>
<P>a pointer to a <SPAN class=type>gpointer-sized</SPAN> value</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>lock_bit</P></TD>
<TD class=parameter_description>
<P>a bit value between 0 and 31</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=refsect3><A name=id-1.4.3.7.53.7></A>
<H4>Returns</H4>
<P><A class=link title=TRUE href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#TRUE:CAPS"><CODE class=literal>TRUE</CODE></A> if the lock was acquired</P>
<P></P></DIV>
<P class=since>Since 2.30</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-pointer-bit-unlock></A>
<H3>g_pointer_bit_unlock&nbsp;()</H3><PRE class=programlisting><SPAN class=returnvalue>void</SPAN>
g_pointer_bit_unlock (<EM class=parameter><CODE>volatile <SPAN class=type>void</SPAN> *address</CODE></EM>,
                      <EM class=parameter><CODE><A class=link title=gint href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gint"><SPAN class=type>gint</SPAN></A> lock_bit</CODE></EM>);</PRE>
<P>This is equivalent to g_bit_unlock, but working on pointers (or other pointer-sized values).</P>
<P>For portability reasons, you may only lock on the bottom 32 bits of the pointer.</P>
<DIV class=refsect3><A name=id-1.4.3.7.54.6></A>
<H4>Parameters</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=parameters_name width=150></COL>
<COL class=parameters_description></COL>
<COL class=parameters_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=parameter_name>
<P>address</P></TD>
<TD class=parameter_description>
<P>a pointer to a <SPAN class=type>gpointer-sized</SPAN> value</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR>
<TR>
<TD class=parameter_name>
<P>lock_bit</P></TD>
<TD class=parameter_description>
<P>a bit value between 0 and 31</P></TD>
<TD class=parameter_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.30</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=g-get-num-processors></A>
<H3>g_get_num_processors&nbsp;()</H3><PRE class=programlisting><A class=link title=guint href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#guint"><SPAN class=returnvalue>guint</SPAN></A>
g_get_num_processors (<EM class=parameter><CODE><SPAN class=type>void</SPAN></CODE></EM>);</PRE>
<P>Determine the approximate number of threads that the system will schedule simultaneously for this process. This is intended to be used as a parameter to <A class=link title=g_thread_pool_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Thread-Pools.html#g-thread-pool-new"><CODE class=function>g_thread_pool_new()</CODE></A> for CPU bound tasks and similar cases.</P>
<DIV class=refsect3><A name=id-1.4.3.7.55.5></A>
<H4>Returns</H4>
<P>Number of schedulable threads, always greater than 0</P>
<P></P></DIV>
<P class=since>Since 2.36</P></DIV></DIV>
<DIV class=refsect1><A name=glib-Threads.other_details></A>
<H2>Types and Values</H2>
<DIV class=refsect2><A name=G-THREAD-ERROR:CAPS></A>
<H3>G_THREAD_ERROR</H3><PRE class=programlisting>#define G_THREAD_ERROR g_thread_error_quark ()
</PRE>
<P>The error domain of the GLib thread subsystem.</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=GThreadError></A>
<H3>enum GThreadError</H3>
<P>Possible errors of thread related functions.</P>
<DIV class=refsect3><A name=id-1.4.3.8.3.4></A>
<H4>Members</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=enum_members_name width=300></COL>
<COL class=enum_members_description></COL>
<COL class=enum_members_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=enum_member_name>
<P><A name=G-THREAD-ERROR-AGAIN:CAPS></A>G_THREAD_ERROR_AGAIN</P></TD>
<TD class=enum_member_description>
<P>a thread couldn't be created due to resource shortage. Try again later.</P></TD>
<TD class=enum_member_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=GThread></A>
<H3>GThread</H3><PRE class=programlisting>typedef struct {
} GThread;
</PRE>
<P>The <A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A> struct represents a running thread. This struct is returned by <A class=link title=g_thread_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-new"><CODE class=function>g_thread_new()</CODE></A> or <A class=link title=g_thread_try_new&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-try-new"><CODE class=function>g_thread_try_new()</CODE></A>. You can obtain the <A class=link title=GThread href="https://developer.gnome.org/glib/stable/glib-Threads.html#GThread"><SPAN class=type>GThread</SPAN></A> struct representing the current thread by calling <A class=link title=g_thread_self&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-self"><CODE class=function>g_thread_self()</CODE></A>.</P>
<P>GThread is refcounted, see <A class=link title=g_thread_ref&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-ref"><CODE class=function>g_thread_ref()</CODE></A> and <A class=link title=g_thread_unref&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-unref"><CODE class=function>g_thread_unref()</CODE></A>. The thread represented by it holds a reference while it is running, and <A class=link title=g_thread_join&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-join"><CODE class=function>g_thread_join()</CODE></A> consumes the reference that it is given, so it is normally not necessary to manage GThread references explicitly.</P>
<P>The structure is opaque -- none of its fields may be directly accessed.</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=GMutex></A>
<H3>union GMutex</H3>
<P>The <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> struct is an opaque data structure to represent a mutex (mutual exclusion). It can be used to protect data against shared access.</P>
<P>Take for example the following function:</P>
<DIV class=informalexample>
<TABLE class=listing_frame border=0 cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD class=listing_lines align=right><PRE>1
2
3
4
5
6
7
8
9
10
11</PRE></TD>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwb">int</SPAN>
<SPAN class=function>give_me_next_number</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class="gtkdoc kwb">static int</SPAN> current_number <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class="gtkdoc slc">// now do a very complicated calculation to calculate the new</SPAN>
  <SPAN class="gtkdoc slc">// number, this might for example be a random number generator</SPAN>
  current_number <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function>calc_next_number</SPAN> <SPAN class="gtkdoc opt">(</SPAN>current_number<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=keyword>return</SPAN> current_number<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>It is easy to see that this won't work in a multi-threaded application. There current_number must be protected against shared access. A <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> can be used as a solution to this problem:</P>
<DIV class=informalexample>
<TABLE class=listing_frame border=0 cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD class=listing_lines align=right><PRE>1
2
3
4
5
6
7
8
9
10
11
12
13</PRE></TD>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwb">int</SPAN>
<SPAN class=function>give_me_next_number</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class="gtkdoc kwb">static</SPAN> GMutex mutex<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc kwb">static int</SPAN> current_number <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc kwb">int</SPAN> ret_val<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-lock">g_mutex_lock</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>mutex<SPAN class="gtkdoc opt">);</SPAN>
  ret_val <SPAN class="gtkdoc opt">=</SPAN> current_number <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function>calc_next_number</SPAN> <SPAN class="gtkdoc opt">(</SPAN>current_number<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-unlock">g_mutex_unlock</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>mutex<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=keyword>return</SPAN> ret_val<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>Notice that the <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> is not initialised to any particular value. Its placement in static storage ensures that it will be initialised to all-zeros, which is appropriate.</P>
<P>If a <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> is placed in other contexts (eg: embedded in a struct) then it must be explicitly initialised using <A class=link title=g_mutex_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-init"><CODE class=function>g_mutex_init()</CODE></A>.</P>
<P>A <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> should only be accessed via g_mutex_ functions.</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=GRecMutex></A>
<H3>struct GRecMutex</H3><PRE class=programlisting>struct GRecMutex {
};
</PRE>
<P>The GRecMutex struct is an opaque data structure to represent a recursive mutex. It is similar to a <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> with the difference that it is possible to lock a GRecMutex multiple times in the same thread without deadlock. When doing so, care has to be taken to unlock the recursive mutex as often as it has been locked.</P>
<P>If a <A class=link title="struct GRecMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRecMutex"><SPAN class=type>GRecMutex</SPAN></A> is allocated in static storage then it can be used without initialisation. Otherwise, you should call <A class=link title=g_rec_mutex_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-init"><CODE class=function>g_rec_mutex_init()</CODE></A> on it and <A class=link title=g_rec_mutex_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rec-mutex-clear"><CODE class=function>g_rec_mutex_clear()</CODE></A> when done.</P>
<P>A GRecMutex should only be accessed with the g_rec_mutex_ functions.</P>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=GRWLock></A>
<H3>struct GRWLock</H3><PRE class=programlisting>struct GRWLock {
};
</PRE>
<P>The GRWLock struct is an opaque data structure to represent a reader-writer lock. It is similar to a <A class=link title="union GMutex" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GMutex"><SPAN class=type>GMutex</SPAN></A> in that it allows multiple threads to coordinate access to a shared resource.</P>
<P>The difference to a mutex is that a reader-writer lock discriminates between read-only ('reader') and full ('writer') access. While only one thread at a time is allowed write access (by holding the 'writer' lock via <A class=link title=g_rw_lock_writer_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-writer-lock"><CODE class=function>g_rw_lock_writer_lock()</CODE></A>), multiple threads can gain simultaneous read-only access (by holding the 'reader' lock via <A class=link title=g_rw_lock_reader_lock&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-reader-lock"><CODE class=function>g_rw_lock_reader_lock()</CODE></A>).</P>
<P>Here is an example for an array with access functions:</P>
<DIV class=informalexample>
<TABLE class=listing_frame border=0 cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD class=listing_lines align=right><PRE>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</PRE></TD>
<TD class=listing_code><PRE class=programlisting>GRWLock lock<SPAN class="gtkdoc opt">;</SPAN>
GPtrArray <SPAN class="gtkdoc opt">*</SPAN>array<SPAN class="gtkdoc opt">;</SPAN>

gpointer
<SPAN class=function>my_array_get</SPAN> <SPAN class="gtkdoc opt">(</SPAN>guint index<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  gpointer retval <SPAN class="gtkdoc opt">=</SPAN> NULL<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=keyword>if</SPAN> <SPAN class="gtkdoc opt">(!</SPAN>array<SPAN class="gtkdoc opt">)</SPAN>
    <SPAN class=keyword>return</SPAN> NULL<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-reader-lock">g_rw_lock_reader_lock</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>lock<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class=keyword>if</SPAN> <SPAN class="gtkdoc opt">(</SPAN>index <SPAN class="gtkdoc opt">&lt;</SPAN> array<SPAN class="gtkdoc opt">-&gt;</SPAN>len<SPAN class="gtkdoc opt">)</SPAN>
    retval <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Pointer-Arrays.html#g-ptr-array-index">g_ptr_array_index</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>array<SPAN class="gtkdoc opt">,</SPAN> index<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-reader-unlock">g_rw_lock_reader_unlock</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>lock<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=keyword>return</SPAN> retval<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

<SPAN class="gtkdoc kwb">void</SPAN>
<SPAN class=function>my_array_set</SPAN> <SPAN class="gtkdoc opt">(</SPAN>guint index<SPAN class="gtkdoc opt">,</SPAN> gpointer data<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-writer-lock">g_rw_lock_writer_lock</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>lock<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=keyword>if</SPAN> <SPAN class="gtkdoc opt">(!</SPAN>array<SPAN class="gtkdoc opt">)</SPAN>
    array <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Pointer-Arrays.html#g-ptr-array-new">g_ptr_array_new</A></SPAN> <SPAN class="gtkdoc opt">();</SPAN>

  <SPAN class=keyword>if</SPAN> <SPAN class="gtkdoc opt">(</SPAN>index <SPAN class="gtkdoc opt">&gt;=</SPAN> array<SPAN class="gtkdoc opt">-&gt;</SPAN>len<SPAN class="gtkdoc opt">)</SPAN>
    <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Pointer-Arrays.html#g-ptr-array-set-size">g_ptr_array_set_size</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>array<SPAN class="gtkdoc opt">,</SPAN> index<SPAN class="gtkdoc opt">+</SPAN><SPAN class=number>1</SPAN><SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Pointer-Arrays.html#g-ptr-array-index">g_ptr_array_index</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>array<SPAN class="gtkdoc opt">,</SPAN> index<SPAN class="gtkdoc opt">) =</SPAN> data<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-writer-unlock">g_rw_lock_writer_unlock</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>lock<SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>This example shows an array which can be accessed by many readers (the <CODE class=function>my_array_get()</CODE> function) simultaneously, whereas the writers (the <CODE class=function>my_array_set()</CODE> function) will only be allowed one at a time and only if no readers currently access the array. This is because of the potentially dangerous resizing of the array. Using these functions is fully multi-thread safe now.</P>
<P>If a <A class=link title="struct GRWLock" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GRWLock"><SPAN class=type>GRWLock</SPAN></A> is allocated in static storage then it can be used without initialisation. Otherwise, you should call <A class=link title=g_rw_lock_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-init"><CODE class=function>g_rw_lock_init()</CODE></A> on it and <A class=link title=g_rw_lock_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-rw-lock-clear"><CODE class=function>g_rw_lock_clear()</CODE></A> when done.</P>
<P>A GRWLock should only be accessed with the g_rw_lock_ functions.</P>
<P class=since>Since 2.32</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=GCond></A>
<H3>struct GCond</H3><PRE class=programlisting>struct GCond {
};
</PRE>
<P>The <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> struct is an opaque data structure that represents a condition. Threads can block on a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> if they find a certain condition to be false. If other threads change the state of this condition they signal the <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A>, and that causes the waiting threads to be woken up.</P>
<P>Consider the following example of a shared variable. One or more threads can wait for data to be published to the variable and when another thread publishes the data, it can signal one of the waiting threads to wake up to collect the data.</P>
<P>Here is an example for using GCond to block a thread until a condition is satisfied:</P>
<DIV class=informalexample>
<TABLE class=listing_frame border=0 cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD class=listing_lines align=right><PRE>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</PRE></TD>
<TD class=listing_code><PRE class=programlisting>gpointer current_data <SPAN class="gtkdoc opt">=</SPAN> NULL<SPAN class="gtkdoc opt">;</SPAN>
GMutex data_mutex<SPAN class="gtkdoc opt">;</SPAN>
GCond data_cond<SPAN class="gtkdoc opt">;</SPAN>

<SPAN class="gtkdoc kwb">void</SPAN>
<SPAN class=function>push_data</SPAN> <SPAN class="gtkdoc opt">(</SPAN>gpointer data<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-lock">g_mutex_lock</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>data_mutex<SPAN class="gtkdoc opt">);</SPAN>
  current_data <SPAN class="gtkdoc opt">=</SPAN> data<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-signal">g_cond_signal</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>data_cond<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-unlock">g_mutex_unlock</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>data_mutex<SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">}</SPAN>

gpointer
<SPAN class=function>pop_data</SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">void</SPAN><SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  gpointer data<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-lock">g_mutex_lock</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>data_mutex<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class=keyword>while</SPAN> <SPAN class="gtkdoc opt">(!</SPAN>current_data<SPAN class="gtkdoc opt">)</SPAN>
    <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-wait">g_cond_wait</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>data_cond<SPAN class="gtkdoc opt">, &amp;</SPAN>data_mutex<SPAN class="gtkdoc opt">);</SPAN>
  data <SPAN class="gtkdoc opt">=</SPAN> current_data<SPAN class="gtkdoc opt">;</SPAN>
  current_data <SPAN class="gtkdoc opt">=</SPAN> NULL<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class=function><A href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-mutex-unlock">g_mutex_unlock</A></SPAN> <SPAN class="gtkdoc opt">(&amp;</SPAN>data_mutex<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=keyword>return</SPAN> data<SPAN class="gtkdoc opt">;</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>Whenever a thread calls <CODE class=function>pop_data()</CODE> now, it will wait until current_data is non-<A class=link title=NULL href="https://developer.gnome.org/glib/stable/glib-Standard-Macros.html#NULL:CAPS"><CODE class=literal>NULL</CODE></A>, i.e. until some other thread has called <CODE class=function>push_data()</CODE>.</P>
<P>The example shows that use of a condition variable must always be paired with a mutex. Without the use of a mutex, there would be a race between the check of <EM class=parameter><CODE>current_data</CODE></EM> by the while loop in <CODE class=function>pop_data()</CODE> and waiting. Specifically, another thread could set <EM class=parameter><CODE>current_data</CODE></EM> after the check, and signal the cond (with nobody waiting on it) before the first thread goes to sleep. <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> is specifically useful for its ability to release the mutex and go to sleep atomically.</P>
<P>It is also important to use the <A class=link title=g_cond_wait&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-wait"><CODE class=function>g_cond_wait()</CODE></A> and <A class=link title=g_cond_wait_until&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-wait-until"><CODE class=function>g_cond_wait_until()</CODE></A> functions only inside a loop which checks for the condition to be true. See <A class=link title=g_cond_wait&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-wait"><CODE class=function>g_cond_wait()</CODE></A> for an explanation of why the condition may not be true even after it returns.</P>
<P>If a <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> is allocated in static storage then it can be used without initialisation. Otherwise, you should call <A class=link title=g_cond_init&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-init"><CODE class=function>g_cond_init()</CODE></A> on it and <A class=link title=g_cond_clear&nbsp;() href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-cond-clear"><CODE class=function>g_cond_clear()</CODE></A> when done.</P>
<P>A <A class=link title="struct GCond" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GCond"><SPAN class=type>GCond</SPAN></A> should only be accessed via the g_cond_ functions.</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=GPrivate></A>
<H3>struct GPrivate</H3><PRE class=programlisting>struct GPrivate {
};
</PRE>
<P>The <A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A> struct is an opaque data structure to represent a thread-local data key. It is approximately equivalent to the <CODE class=function>pthread_setspecific()</CODE>/<CODE class=function>pthread_getspecific()</CODE> APIs on POSIX and to <CODE class=function>TlsSetValue()</CODE>/<CODE class=function>TlsGetValue()</CODE> on Windows.</P>
<P>If you don't already know why you might want this functionality, then you probably don't need it.</P>
<P><A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A> is a very limited resource (as far as 128 per program, shared between all libraries). It is also not possible to destroy a <A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A> after it has been used. As such, it is only ever acceptable to use <A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A> in static scope, and even then sparingly so.</P>
<P>See <A class=link title=G_PRIVATE_INIT() href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-PRIVATE-INIT:CAPS"><CODE class=function>G_PRIVATE_INIT()</CODE></A> for a couple of examples.</P>
<P>The <A class=link title="struct GPrivate" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GPrivate"><SPAN class=type>GPrivate</SPAN></A> structure should be considered opaque. It should only be accessed via the g_private_ functions.</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=GOnce></A>
<H3>struct GOnce</H3><PRE class=programlisting>struct GOnce {
  volatile GOnceStatus status;
  volatile gpointer retval;
};
</PRE>
<P>A <A class=link title="struct GOnce" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnce"><SPAN class=type>GOnce</SPAN></A> struct controls a one-time initialization function. Any one-time initialization function must have its own unique <A class=link title="struct GOnce" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnce"><SPAN class=type>GOnce</SPAN></A> struct.</P>
<DIV class=refsect3><A name=id-1.4.3.8.10.5></A>
<H4>Members</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=struct_members_name width=300></COL>
<COL class=struct_members_description></COL>
<COL class=struct_members_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=struct_member_name>
<P>volatile&nbsp;<A class=link title="enum GOnceStatus" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnceStatus"><SPAN class=type>GOnceStatus</SPAN></A>&nbsp;<EM class=structfield><CODE><A name=GOnce.status></A>status</CODE></EM>;</P></TD>
<TD class=struct_member_description>
<P>the status of the <A class=link title="struct GOnce" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnce"><SPAN class=type>GOnce</SPAN></A></P></TD>
<TD class=struct_member_annotations>&nbsp;</TD></TR>
<TR>
<TD class=struct_member_name>
<P>volatile&nbsp;<A class=link title=gpointer href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=type>gpointer</SPAN></A>&nbsp;<EM class=structfield><CODE><A name=GOnce.retval></A>retval</CODE></EM>;</P></TD>
<TD class=struct_member_description>
<P>the value returned by the call to the function, if <EM class=parameter><CODE>status</CODE></EM> is <A class=link href="https://developer.gnome.org/glib/stable/glib-Threads.html#G-ONCE-STATUS-READY:CAPS"><CODE class=literal>G_ONCE_STATUS_READY</CODE></A></P></TD>
<TD class=struct_member_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.4</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=GOnceStatus></A>
<H3>enum GOnceStatus</H3>
<P>The possible statuses of a one-time initialization function controlled by a <A class=link title="struct GOnce" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnce"><SPAN class=type>GOnce</SPAN></A> struct.</P>
<DIV class=refsect3><A name=id-1.4.3.8.11.4></A>
<H4>Members</H4>
<DIV class=informaltable>
<TABLE border=0 width="100%">
<COLGROUP>
<COL class=enum_members_name width=300></COL>
<COL class=enum_members_description></COL>
<COL class=enum_members_annotations width=200></COL></COLGROUP>
<TBODY>
<TR>
<TD class=enum_member_name>
<P><A name=G-ONCE-STATUS-NOTCALLED:CAPS></A>G_ONCE_STATUS_NOTCALLED</P></TD>
<TD class=enum_member_description>
<P>the function has not been called yet.</P></TD>
<TD class=enum_member_annotations>&nbsp;</TD></TR>
<TR>
<TD class=enum_member_name>
<P><A name=G-ONCE-STATUS-PROGRESS:CAPS></A>G_ONCE_STATUS_PROGRESS</P></TD>
<TD class=enum_member_description>
<P>the function call is currently in progress.</P></TD>
<TD class=enum_member_annotations>&nbsp;</TD></TR>
<TR>
<TD class=enum_member_name>
<P><A name=G-ONCE-STATUS-READY:CAPS></A>G_ONCE_STATUS_READY</P></TD>
<TD class=enum_member_description>
<P>the function has been called.</P></TD>
<TD class=enum_member_annotations>&nbsp;</TD></TR></TBODY></TABLE></DIV></DIV>
<P class=since>Since 2.4</P></DIV>
<HR>
</HR>
<DIV class=refsect2><A name=G-ONCE-INIT:CAPS></A>
<H3>G_ONCE_INIT</H3><PRE class=programlisting>#define G_ONCE_INIT { G_ONCE_STATUS_NOTCALLED, NULL }
</PRE>
<P>A <A class=link title="struct GOnce" href="https://developer.gnome.org/glib/stable/glib-Threads.html#GOnce"><SPAN class=type>GOnce</SPAN></A> must be initialized with this macro before it can be used.</P>
<DIV class=informalexample>
<TABLE class=listing_frame border=0 cellSpacing=0 cellPadding=0>
<TBODY>
<TR>
<TD class=listing_lines align=right><PRE>1</PRE></TD>
<TD class=listing_code><PRE class=programlisting>GOnce my_once <SPAN class="gtkdoc opt">=</SPAN> G_ONCE_INIT<SPAN class="gtkdoc opt">;</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P class=since>Since 2.4</P></DIV></DIV>
<DIV class=refsect1><A name=glib-Threads.see-also></A>
<H2>See Also</H2>
<P><A class=link title="struct GThreadPool" href="https://developer.gnome.org/glib/stable/glib-Thread-Pools.html#GThreadPool"><SPAN class=type>GThreadPool</SPAN></A>, <A class=link title=GAsyncQueue href="https://developer.gnome.org/glib/stable/glib-Asynchronous-Queues.html#GAsyncQueue"><SPAN class=type>GAsyncQueue</SPAN></A></P></DIV>