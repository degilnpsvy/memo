<SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">For quads, this is (roughly) what we&#8217;re expecting &#8211; except for some flipped diagonals, which I&#8217;ll get to in a minute. But the triangle is a completely different beast. It&#8217;s got a very different topology from the &#8220;natural&#8221; tessellation I showed above, including a different number of vertices (12 instead of 10). Clearly, there&#8217;s something funny going on here &#8211; and that something happens to be related to the way transitions between different tessellation levels are handled.</SPAN>
<P></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Making ends meet</SPAN></B></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The elephant in the room is handling transitions between patches. Tessellating a single triangle (or quad) is easy, but we want to be able to determine tessellation factors per-patch, because we only want to spend triangles where we need them &#8211; and not waste tons of triangles on some distant (and possibly backface-culled) parts of the mesh. Additionally, we want to be able to do this quickly and ideally without extra memory usage; that means a global fix-up post-pass or something of that caliber is out of the question.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The solution &#8211; which you&#8217;ve already encountered if you&#8217;ve written a Hull or Domain shader &#8211; is to make all of the actual tessellation work purely local and push the burden of ensuring watertightness for the resulting mesh down to the shaders. This is a topic all by itself and requires, among other things,&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqpkPTKjKgVMokarbRyjRs1mcWXGw0gf2a8zJYKScr2wuMOXQMeVUr9DsshYNb&amp;b=3"><B>great care in the Domain Shader code</B></A>; I&#8217;ll skip all the details about expression evaluation in shaders and stick with the basics. The basic mechanism is that each patch has multiple tessellation factors (TFs), which are computed in the Hull Shader: one or two for the actual inside of the patch, plus one for each edge. The TFs for the inside of the patch can be chosen freely; but if two patches share an edge, they&#8217;d better compute the exact same TFs along that edge, or there will be cracks. The hardware doesn&#8217;t care &#8211; it will process each patch by itself. If you do everything correctly, you&#8217;ll get a nice watertight mesh, otherwise &#8211; well, that&#8217;s your problem. All the HW needs to make sure is that it&#8217;s&nbsp;<I>possible</I>&nbsp;to get watertight meshes, preferably with reasonable efficiency. That by itself turns out to be tricky in some places; I&#8217;ll get to that later.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">So, here are some new reference patches &#8211; this time with different TFs along each edge so we can see how that works:</SPAN>