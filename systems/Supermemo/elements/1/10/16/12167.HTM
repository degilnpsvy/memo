<B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Fractional tessellation factors and overall pipeline flow</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">So far, I&#8217;ve only talked about integer TFs. In two of the so-called &#8220;partitioning types&#8221;, namely &#8220;Integer&#8221; and &#8220;Pow2&#8243;, that&#8217;s all the Tessellator sees. If the shader generates a non-integer (or, respectively, non-power-of-2) TF, it will simply get rounded up to the next acceptable value. More interesting are the remaining two partitioning types: Fractional-odd and Fractional-even tessellation. Instead of jumping from tessellation factor to tessellation factor (which would cause visible pops), new vertices start out at the same position as an existing vertex in the mesh and then gradually move to their new positions as the TF increases.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">For example, with fractional-odd tessellation, if you were to use an inner TF of 3.001 for the above triangle, the resulting mesh would look very much like the mesh for a TF of 3 &#8211; but topologically, it&#8217;d be the same as if the TF was 5, i.e. it&#8217;s a patch with 3 concentric rings, even though the middle ring is very narrow. Then as the TF gets closer to 5, the middle ring expands until it is eventually at its final position for TF 5. Once you raise the TF past 5, the mesh will be topologically the same as is the TF was 7, but again with a number of almost-degenerate triangles in the middle, and so forth. Fractional-even tessellation uses the same principle, just with even TFs.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The output of the tessellator then consists of two things: First, the positions of the tessellated vertices in domain coordinates, and second, the corresponding connectivity information &#8211; basically an index buffer.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Now, with the basic function of the fixed-function tessellator unit explained, let&#8217;s step back and see what we need to do to actually churn out primitives: First, we need to input a bunch of input control points comprising a patch into the Hull Shader. The HS then computes output control points and &#8220;patch constants&#8221; (both of which get passed down to the Domain Shader), plus all Tessellation Factors (which are essentially just more patch constants). Then we run the fixed-function tessellator, which gives us a bunch of Domain Positions to run the Domain Shader at, plus the associated indices. After we&#8217;ve run the DS, we then do another round of primitive assembly, and then send the primitives either down to the GS pipeline (if it&#8217;s active) or Viewport transform, Clip and Cull (if not).</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">So let&#8217;s look a bit into the HS stage.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Hull Shader execution</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Like&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqt1PNYS2wXo0waqqb2SlkindZTHc4wKCFoG8Yfj822QqTd2lBJEwpvCwthIkBRQbLemoF5au3VYCTVF6wZE9aHNtePsb%2BmYFlpwVOVLoojBt%2BynA%3D&amp;b=3"><B>Geometry Shaders</B></A>, Hull Shaders work on full (patch) primitives as input &#8211; with all the input buffering headaches that causes. How much of a headache entirely depends on the type of input patch. If the patch type is something like a cubic B&#233;zier patch, we need 4&#215;4 = 16 input points&nbsp;<I>per patch</I>&nbsp;and might just produce a single quad of output (or even none at all, if the patch is culled); clearly, that&#8217;s a somewhat awkward amount of data to work with, and doesn&#8217;t lend itself to very efficient shading. On the other hand, if tessellation takes plain triangles as input (which a lot of people do), input buffering is pretty tame and not likely to be a source of problems or bottlenecks.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">More importantly, unlike Geometry Shaders (which run for every primitive), Hull Shaders don&#8217;t run all that often &#8211; they run once&nbsp;<I>per patch</I>, and as long as there&#8217;s any actual tessellation going on (even at modest TFs), we have way less patches than we have output triangles. In other words, even when HS input is somewhat inefficient, it&#8217;s less of an issue than in the GS case simply because we don&#8217;t hit it that often.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The other nice attribute of Hull Shaders is that, unlike Geometry Shaders, they don&#8217;t have a variable amount of output data; they produce a fixed amount of control points, each which a fixed amount of associated attributes, plus a fixed amount of patch constants. All of this is statically known at compile time; no dynamic run-time buffer management necessary. If we Hull Shade 16 hulls at a time, we know exactly where the data for each hull will end up before we even start executing the shader. That&#8217;s definitely an advantage over Geometry Shaders; for lots of Geometry Shaders, it&#8217;s possible to know statically how many output vertices will be generated (for example because all the control flow leading to&nbsp;emit&nbsp;/&nbsp;cut&nbsp;instructions can be statically evaluated at compile time), and for all of them, there&#8217;s a guaranteed maximum number of output vertices, but for HS, we have a guaranteed fixed amount of output data, no additional analysis required. In short, there&#8217;s no problems with output buffer management, other than the fact that, again depending on the primitive type, we might need lots of output buffer space which limits the amount of parallelism we can achieve (due to memory/register constraints).</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Finally, Hull Shaders are somewhat special in the way they are compiled in D3D11; all other shader types basically consist of one block of code (with some subroutines maybe), but Hull Shaders are generated factored into multiple phases, each of which can consist of multiple (independent) threads of execution. The details are mainly of interest to driver and shader compiler programmers, but suffice it to say that your average HS comes packaged in a form that exposes lots of latent parallelism, if there is any. It certainly seems like Microsoft was really keen to avoid the bottlenecks that plague Geometry Shaders this time around.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Anyway, Hull Shaders produce a bunch of output per patch; most of it is just kept around until the corresponding Domain Shaders run, except for the TFs, which get sent to the tessellator unit. If any of the TFs are less than or equal to zero (or NaN), the patch is culled, and the corresponding control points and patch constants silently get thrown away. Otherwise, the Tessellator (which implements the functionality described above) kicks in, reads the just-shaded patches, and starts churning out domain point positions and triangle indices, and we need to get ready for DS execution.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Domain Shaders</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Just like for&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqt1PNYS2wXo0waqqb2SlkindZTHc4wKCFoG8Yfj822wmTd2lBJEwpvCwthIkBRQbLemoF5au3VYCTVF6wZE9aHNtePsb%2BmYFlpwVOVLoojBt81Q%3D%3D&amp;b=3"><B>Vertex Shading</B></A>&nbsp;way back, we want to gather multiple domain vertices into one batch that we shade together and then pass on the PA. The fixed-function tessellator can take care of this: &#8220;just&#8221; handle it along with producing vertex positions and indices (I put the &#8220;just&#8221; in quotes here because this does involve some amount of bookkeeping).</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">In terms of input and output, Domain Shaders are very simple indeed: the only input they get that actually varies per vertex is the domain point u and v coordinates (w, when used, doesn&#8217;t need to be computed or passed in by the tesselator; since&nbsp;u + v + w = 1, it can be computed as&nbsp;w = 1 - u - v). Everything else is either patch constants, control points (all of which are the same across a patch) or constant buffers. And output is basically the same as for Vertex Shaders.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">In short, once we get to the DS, life is good; the data flow is almost as simple as for VS, which is a path we know how to run efficiently. This is perhaps the biggest advantage of the D3D11 tessellation pipeline over Geometry Shaders: the actual triangle amplification doesn&#8217;t happen in a shader, where we waste precious ALU cycles and need to keep buffer space for a worst-case estimate of vertices, but in a localized element (the tessellator) that is basically a state machine, gets very little input (a few TFs) and produces very compact output (effectively an index buffer, plus a 2D coordinate per output vertex). Because of this, we need way less memory for buffering, and can keep our Shader Units busy with actual shading work instead of housekeeping.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">And that&#8217;s it for this post &#8211; next up: Compute Shaders, aka the final part in my original outline for this series! Until then.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Final remarks</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">As usual, I cut a few corners. There&#8217;s the &#8220;isoline&#8221; patch type, which I didn&#8217;t go into at all (if there&#8217;s any demand for this, I can write it up). The Tessellator has all kinds of symmetry and precision requirements; as far as vertex domain positions are concerned, you can basically expect bit-exact results between the different HW vendors, because the D3D11 spec really nails this bit down. What&#8217;s intentionally not nailed down is the order in which vertices or triangles are produced &#8211; an implementation can do what it wants there, provided it does so consistently (i.e. the same input has to produce the same output, always). There&#8217;s a bunch of subtle constraints that go into this too &#8211; for example, all domain positions written by the Tessellator need to have both u and 1-u (and also v and 1-v) exactly representable as float; there&#8217;s a bunch of necessary conditions like this so that Domain Shaders can then produce watertight meshes (this rule in particular is important so that a shared edge AB between two patches, which is AB to one patch and BA to the other, can get tessellated the same way for both patches).</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Writing Domain Shaders so they actually can&#8217;t produce cracks is tricky and requires great care; I intentionally sidestep the topic because it&#8217;s outside the scope of this series. Another much more trivial issue that I didn&#8217;t mention is the winding order of triangles generated by the Tessellator (answer: it&#8217;s up to the App &#8211; both clockwise and counterclockwise are supported).</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The description of Input/Output buffering for Hull and Domain shaders is somewhat terse, but it&#8217;s very similar to stages we&#8217;ve already seen, so I&#8217;d rather keep it short and avoid extra clutter; re-read the posts on Vertex Shaders and Geometry Shaders if this was too fast.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Finally, because the Tesselation pipeline can feed into the GS, there&#8217;s the question of whether it can generate adjacency information. For the &#8220;inside&#8221; of patches this would be conceivable (just more indices for the Tessellator unit to write), but it gets ugly fast once you reach patch edges, since cross-patch adjacency needs exactly the kind of global &#8220;mesh awareness&#8221; that the Tessellation pipeline design tries so hard to avoid. So, long story short, no, the tessellator will not produce adjacency information for the GS, just plain triangles.</SPAN>