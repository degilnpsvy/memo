<B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">A trip through the Graphics Pipeline 2011, part&nbsp;13</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">October 9, 2011</SPAN></P>
<p><I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">This post is part of the series&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqt1PNYS2wXo0waqqb2SlkindZTHc4wKCFoG8Yfj822wOTd2lBJEwpvCwthIkBRQbLemoF5au3VYCTVF6wZE9aHNtePsb%2BmYFlpwVOTbU%2BnU5g&amp;b=3"><B>&#8220;A trip through the Graphics Pipeline 2011&#8243;</B></A>.</SPAN></I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Welcome back to what&#8217;s going to be the last &#8220;official&#8221; part of this series &#8211; I&#8217;ll do more GPU-related posts in the future, but this series is long enough already. We&#8217;ve been touring all the regular parts of the graphics pipeline, down to different levels of detail. Which leaves one major new feature introduced in DX11 out: Compute Shaders. So that&#8217;s gonna be my topic this time around.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Execution environment</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">For this series, the emphasis has been on overall dataflow at the architectural level, not shader execution (which is explained well elsewhere). For the stages so far, that meant focusing on the input piped into and output produced by each stage; the way the internals work was usually dictated by the shape of the data. Compute shaders are different &#8211; they&#8217;re running by themselves, not as part of the graphics pipeline, so the surface area of their interface is much smaller.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">In fact, on the input side, there&#8217;s not really any buffers for input data at all. The only input Compute Shaders get, aside from API state such as the bound Constant Buffers and resources, is their thread index. There&#8217;s a tremendous potential for confusion here, so here&#8217;s the most important thing to keep in mind: a &#8220;thread&#8221; is the atomic unit of dispatch in the CS environment, and it&#8217;s a substantially different beast from the threads provided by the OS that you probably associate with the term. CS threads have their own identity and registers, but they don&#8217;t have their own Program Counter (Instruction Pointer) or stack, nor are they scheduled individually.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">In fact, &#8220;threads&#8221; in CS take the place that individual vertices had during&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqt1PNYS2wXo0waqqb2SlkindZTHc4wKCFoG8Yfj822wmTd2lBJEwpvCwthIkBRQbLemoF5au3VYCTVF6wZE9aHNtePsb%2BmYFlpwVOVLoojBt81Q%3D%3D&amp;b=3"><B>Vertex Shading</B></A>, or individual pixels during&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqt1PNYS2wXo0waqqb2SlkindZTHc4wKCFoG8Yfj822gqTd2lBJEwpvCwthIkBRQbLemoF5au3VYCTVF6wZE9aHNtePsb%2BmYFlpwVOVLoojBt31Q%3D%3D&amp;b=3"><B>Pixel Shading</B></A>. And they get treated the same way: assemble a bunch of them (usually, somewhere between 16 and 64) into a &#8220;Warp&#8221; or &#8220;Wavefront&#8221; and let them run the same code in lockstep. CS threads don&#8217;t get scheduled &#8211; Warps and Wavefronts do (I&#8217;ll stick with &#8220;Warp&#8221; for the rest of this article; mentally substitute &#8220;Wavefront&#8221; for AMD). To hide latency, we don&#8217;t switch to a different &#8220;thread&#8221; (in CS parlance), but to a different Warp, i.e. a different bundle of threads. Single threads inside a Warp can&#8217;t take branches individually; if at least one thread in such a bundle wants to execute a certain piece of code, it gets processed by all the threads in the bundle &#8211; even if most threads then end up throwing the results away. In short, CS &#8220;threads&#8221; are more like SIMD lanes than like the threads you see elsewhere in programming; keep that in mind.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">That explains the &#8220;thread&#8221; and &#8220;warp&#8221; levels. Above that is the &#8220;thread group&#8221; level, which deals with &#8211; who would&#8217;ve thought? &#8211; groups of threads. The size of a thread group is specified during shader compilation. In DX11, a thread group can contain anywhere between 1 and 1024 threads, and the thread group size is specified not as a single number but as a 3-tuple giving thread x, y, and z coordinates. This numbering scheme is mostly for the convenience of shader code that addresses 2D or 3D resources, though it also allows for traversal optimizations. At the macro level, CS execution is dispatched in multiples of thread groups; thread group IDs in D3D11 again use 3D group IDs, same as thread IDs, and for pretty much the same reasons.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Thread IDs &#8211; which can be passed in in various forms, depending on what the shader prefers &#8211; are the only input to Compute Shaders that&#8217;s not the same for all threads; quite different from the other shader types we&#8217;ve seen before. This is just the tip of the iceberg, though.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Thread Groups</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The above description makes it sound like thread groups are a fairly arbitrary middle level in this hierarchy. However, there&#8217;s one important bit missing that makes thread groups very special indeed: Thread Group Shared Memory (TGSM). On DX11 level hardware, compute shaders have access to 32k of TGSM, which is basically a scratchpad for communication between threads in the same group. This is the primary (and fastest) way by which different CS threads can communicate.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">So how is this implemented in hardware? It&#8217;s quite simple: all threads (well, Warps really) within a thread group get executed by the same shader unit. The shader unit then simply has at least 32k (usually a bit more) of local memory. And because all grouped threads share the same shader unit (and hence the same set of ALUs etc.), there&#8217;s no need to include complicated arbitration or synchronization mechanisms for shared memory access: only one Warp can access memory in any given cycle, because only one Warp gets to issue instructions in any cycle! Now, of course this process will usually be pipelined, but that doesn&#8217;t change the basic invariant: per shader unit, we have exactly one piece of TGSM; accessing TGSM might require multiple pipeline stages, but actual reads from (or writes to) TGSM will only happen inside one pipeline stage, and the memory accesses during that cycle all come from within the same Warp.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">However, this is not yet enough for actual shared-memory communication. The problem is simple: The above invariant guarantees that there&#8217;s only one set of accesses to TGSM per cycle even when we don&#8217;t add any interlocks to prevent concurrent access. This is nice since it makes the hardware simpler and faster. It does not guarantee that memory accesses happen in any particular order from the perspective of the shader program, however, since Warps can be scheduled more or less randomly; it all depends on who is runnable (not waiting for memory access / texture read completion) at certain points in time. Somewhat more subtle, precisely because the whole process is pipelined, it might take some cycles for writes to TGSM to become &#8220;visible&#8221; to reads; this happens when the actual read and write operations to TGSM occur in different pipeline stages (or different phases of the same stage). So we still need some kind of synchronization mechanism. Enter barriers. There&#8217;s different types of barriers, but they&#8217;re composed of just three fundamental components:</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: 'Times New Roman'"><SPAN style="mso-list: Ignore">1.<SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Group Synchronization</SPAN></I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">. A Group Synchronization Barrier forces all threads inside the current group to reach the barrier before any of them may consume past it. Once a Warp reaches such a barrier, it will be flagged as non-runnable, same as if it was waiting for a memory or texture access to complete. Once the last Warp reaches the barrier, the remaining Warps will be reactivated. This all happens at the Warp scheduling level; it adds additional scheduling constraints, which may cause stalls, but there&#8217;s no need for atomic memory transactions or anything like that; other than lost utilization at the micro level, this is a reasonably cheap operation.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: 'Times New Roman'"><SPAN style="mso-list: Ignore">2.<SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Group Memory Barriers</SPAN></I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">. Since all threads within a group run on the same shader unit, this basically amounts to a pipeline flush, to ensure that all pending shared memory operations are completed. There&#8217;s no need to synchronize with resources external to the current shader unit, which means it&#8217;s again reasonably cheap.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: 'Times New Roman'"><SPAN style="mso-list: Ignore">3.<SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Device Memory Barriers</SPAN></I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">. This blocks all threads within a group until all memory accesses have completed &#8211; either direct or indirect (e.g. via texture samples). As explained earlier in this series, memory accesses and texture samples on GPUs have long latencies &#8211; think more than 600, and often above 1000 cycles &#8211; so this kind of barrier will really hurt.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">DX11 offers different types of barriers that combine several of the above components into one atomic unit; the semantics should be obvious.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Unordered Access Views</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">We&#8217;ve now dealt with CS input and learned a bit about CS execution. But where do we put our output data? The answer has the unwieldy name &#8220;unordered access views&#8221;, or UAVs for short. An UAV seems somewhat similar to render targets in Pixel Shaders (and UAVs can in fact be used in addition to render targets in Pixel Shaders), but there&#8217;s some very important semantic differences:</SPAN></P>
<UL style="MARGIN-TOP: 0cm" type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l1 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Most importantly, as the same suggests, access to UAVs is &#8220;unordered&#8221;, in the sense that the API does not guarantee accesses to become visible in any particular order. When rendering primitives, quads are guaranteed to be Z-tested, blended and written back in API order (as discussed in detail in&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqt1PNYS2wXo0waqqb2SlkindZTHc4wKCFoG8Yfj822giTd2lBJEwpvCwthIkBRQbLemoF5au3VYCTVF6wZE9aHNtePsb%2BmYFlpwVOVLoojBt21Q%3D%3D&amp;b=3"><B>part 9 of this series</B></A>), or at least produce the same results as if they were &#8211; which takes substantial effort. UAVs make no such effort &#8211; UAV accesses happen immediately as they&#8217;re encountered in the shader, which may be very different from API order. They&#8217;re not&nbsp;<I>completely</I>&nbsp;unordered, though; while there&#8217;s no guaranteed order of operations within an API call, the API and driver will still collaborate to make sure that perceived sequential ordering is preserved across API calls. Thus, if you have a complex Compute Shader (or Pixel Shader) writing to an UAV immediately followed by a second (simpler) CS that reads from the same underlying resource, the second CS will see the finished results, never some partially-written output.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l1 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">UAVs support random access. A Pixel Shader can only write to one location per render target &#8211; its corresponding pixel. The same Pixel Shader can write to arbitrary locations in whatever UAVs it has bound.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l1 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">UAVs support atomic operations. In the classic Pixel Pipeline, there&#8217;s no need; we guarantee there&#8217;s never any collisions anyway. But with the free-form execution provided by UAVs, different threads might be trying to access a piece of memory at the same time, and we need synchronization mechanisms to deal with this.</SPAN></LI></UL>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">So from a &#8220;CPU programmer&#8221;&#8216;s point of view, UAVs correspond to regular RAM in a shared-memory multiprocessing system; they&#8217;re windows into memory. More interesting is the issue of atomic operations; this is one area where current GPUs diverge considerably from CPU designs.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Atomics</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">In current CPUs, most of the magic for shared memory processing is handled by the memory hierarchy (i.e. caches). To write to a piece of memory, the active core must first assert exclusive ownership of the corresponding cache line. This is accomplished using what&#8217;s called a &#8220;cache coherency protocol&#8221;, usually&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqtFqKcze%2BWdMiYbGehzRznisARnM8wN%2FwwhdoPnp2n1XfeSg%3D&amp;b=3"><B>MESI</B></A>&nbsp;and descendants. The details are tangential to this article; what matters is that because writing to memory entails acquiring exclusive ownership, there&#8217;s never a risk of two cores simultaneously trying to write to the some location. In such a model, atomic operations can be implemented by holding exclusive ownership for the duration of the operation; if we had exclusive ownership for the whole time, there&#8217;s no chance that someone else was trying to write to the same location while we were performing the atomic operation. Again, the actual details of this get hairy pretty fast (especially as soon as things like paging, interrupts and exceptions get involved), but the 30000-feet-view will suffice for the purposes of this article.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">In this type of model, atomic operations are performed using the regular Core ALUs and load/store units, and most of the &#8220;interesting&#8221; work happens in the caches. The advantage is that atomic operations are (more or less) regular memory accesses, albeit with some extra requirements. There&#8217;s a couple of problems, though: most importantly, the standard implementation of cache coherency, &#8220;snooping&#8221;, requires that all agents in the protocol talk to each other, which has serious scalability issues. There are ways around this restriction (mainly using so-called Directory-based Coherency protocols), but they add additional complexity and latency to memory accesses. Another issue is that all locks and memory transactions really happen at the cache line level; if two unrelated but frequently-updated variables share the same cache line, it can end up &#8220;ping-ponging&#8221; between multiple cores, causing tons of coherency transactions (and associated slowdown). This problem is called &#8220;false sharing&#8221;. Software can avoid it by making sure unrelated fields don&#8217;t fall into the same cache line; but on GPUs, neither the cache line size nor the memory layout during execution is known or controlled by the application, so this problem would be more serious.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Current GPUs avoid this problem by structuring their memory hierarchy differently. Instead of handling atomic operations inside the shader units (which again raises the &#8220;who owns which memory&#8221; issue), there&#8217;s dedicated atomic units that directly talk to a shared lowest-level cache hierarchy. There&#8217;s only one such cache, so the issue of coherency doesn&#8217;t come up; either the cache line is present in the cache (which means it&#8217;s current) or it isn&#8217;t (which means the copy in memory is current). Atomic operations consist of first bringing the respective memory location into the cache (if it isn&#8217;t there already), then performing the required read-modify-write operation directly on the cache contents using a dedicated integer ALU on the atomic units. While an atomic unit is busy on a memory location, all other accesses to that location will stall. Since there&#8217;s multiple atomic units, it&#8217;s necessary to make sure they never try to access the same memory location at the same time; one easy way to accomplish this is to make each atomic unit &#8220;own&#8221; a certain set of addresses (statically &#8211; not dynamically as with cache line ownership). This is done by computing the index of the responsible atomic unit as some hash function of the memory address to be accessed. (Note that I can&#8217;t confirm this is how current GPUs do; I&#8217;ve found little detail on how the atomic units work in official docs).</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">If a shader unit wants to perform an atomic operation to a given memory address, it first needs to determine which atomic unit is responsible, wait until it is ready to accept new commands, and then submit the operation (and potentially wait until it is finished if the result of the atomic operation is required). The atomic unit might only be processing one command at a time, or it might have a small FIFO of outstanding requests; and of course there&#8217;s all kinds of allocation and queuing details to get right so that atomic operation processing is reasonably fair so that shader units will always make progress. Again, I won&#8217;t go into further detail here.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">One final remark is that, of course, outstanding atomic operations count as &#8220;device memory&#8221; accesses, same as memory/texture reads and UAV writes; shader units need to keep track of their outstanding atomic operations and make sure they&#8217;re finished when they hit device memory access barriers.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Structured buffers and append/consume buffers</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Unless I missed something, these two buffer types are the last CS-related features I haven&#8217;t talked about yet. And, well, from a hardware perspective, there&#8217;s not that much to talk about, really. Structured buffers are more of a hint to the driver-internal shader compiler than anything else; they give the driver some hint as to how they&#8217;re going to be used &#8211; namely, they consist of elements with a fixed stride that are likely going to be accessed together &#8211; but they still compile down to regular memory accesses in the end. The structured buffer part may bias the driver&#8217;s decision of their position and layout in memory, but it does not add any fundamentally new functionality to the model.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Append/consume buffers are similar; they could be implemented using the existing atomic instructions. In fact, they kind of are, except the append/consume pointers aren&#8217;t at an explicit location in the resource, they&#8217;re side-band data outside the resource that are accessed using special atomic instructions. (And similarly to structured buffers, the fact that their usage is declared as append/consume buffer allows the driver to pick their location in memory appropriately).</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Wrap-up.</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">And&#8230; that&#8217;s it. No more previews for the next part, this series is done :), though that doesn&#8217;t mean I&#8217;m done with it. I have some restructuring and partial rewriting to do &#8211; these blog posts are raw and unproofed, and I intend to go over them and turn it into a single document. In the meantime, I&#8217;ll be writing about other stuff here. I&#8217;ll try to incorporate the feedback I got so far &#8211; if there&#8217;s any other questions, corrections or comments, now&#8217;s the time to tell me! I don&#8217;t want to nail down the ETA for the final cleaned-up version of this series, but I&#8217;ll try to get it down well before the end of the year. We&#8217;ll see. Until then, thanks for reading!</SPAN>