<B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Some final memory bits and pieces</SPAN></B> 
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Honestly, we&#8217;re&nbsp;<I>very very</I>&nbsp;close to actually seeing 3D commands now! So close you can almost taste them. But there&#8217;s one more thing we need to get out of the way first. Because now <FONT class=extract>we have two kinds of memory &#8211; (local) video memory and mapped system memory. One is about a day&#8217;s worth of travel to the north, the other is a week&#8217;s journey to the south along the PCI Express highway.</FONT> Which road do we pick?</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The easiest solution: Just add an extra address line that tells you which way to go. This is simple, works just fine and has been done plenty of times. Or maybe you&#8217;re on a unified memory architecture, like some game consoles (but not PCs). In that case, there&#8217;s no choice; there&#8217;s just&nbsp;<I>the memory</I>, which is where you go, period. If you want something fancier, you add a MMU (memory management unit), which gives you a fully virtualized address space and allows you to pull nice tricks like having frequently accessed parts of a texture in video memory (where they&#8217;re fast), some other parts in system memory, and most of it not mapped at all &#8211; to be conjured up from thing air, or, more usually, by a magic disk read that will only take about 50 years or so &#8211; and by the way, this is not hyperbole; if you stay with the &#8220;memory access = 1 day&#8221; metaphor, that&#8217;s really how long a single HD read takes. A quite fast one at that. Disks suck. But I digress.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">So, MMU. It also allows you to defragment your video memory address space without having to actually copy stuff around when you start running out of video memory. Nice thing, that. And it makes it much easier to have multiple processes share the same GPU. It&#8217;s definitely allowed to have one, but I&#8217;m not actually sure if it&#8217;s a requirement or not, even though it&#8217;s certainly really nice to have (anyone care to help me out here? I&#8217;ll update the article if I get clarification on this, but tbh right now I just can&#8217;t be arsed to look it up). Anyway, a MMU/virtual memory is not really something you can just add on the side (not in an architecture with caches and memory consistency concerns anyway), but it really isn&#8217;t specific to any particular stage &#8211; I have to mention it somewhere, so I just put it here.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">There&#8217;s also a DMA engine that can copy memory around without having to involve any of our precious 3D hardware/shader cores. Usually, this can at least copy between system memory and video memory (in both directions). It often can also copy from video memory to video memory (and if you have to do any VRAM defragmenting, this is a useful thing to have). It usually can&#8217;t do system memory to system memory copies, because this is a GPU, not a memory copying unit &#8211; do your system memory copies on the CPU where they don&#8217;t have to pass through PCIe in both directions!</SPAN></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Update</SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">: I&#8217;ve drawn a&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqpkPTKji0QsE1ZK2MyjMvnWFYUX4ywPXF5HFQPn1Ghl%2FReTZMeE8p9g%3D%3D&amp;b=3"><B>picture</B></A>&nbsp;(link since this layout is too narrow to put big diagrams in the text). This also shows some more details &#8211; by now your GPU has multiple memory controllers, each of which controls multiple memory banks, with a fat hub in the front. Whatever it takes to get that bandwidth. :)</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Okay, checklist. We have a command buffer prepared on the CPU. We have the PCIe host interface, so the CPU can actually tell us about this, and write its address to some register. We have the logic to turn that address into a load that will actually return data &#8211; if it&#8217;s from system memory it goes through PCIe, if we decide we&#8217;d rather have the command buffer in video memory, the KMD can set up a DMA transfer so neither the CPU nor the shader cores on the GPU need to actively worry about it. And then we can get the data from our copy in video memory through the memory subsystem. All paths accounted for, we&#8217;re set and finally ready to look at some commands!</SPAN>