<B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt"><FONT class=extract>The kernel-mode driver (KMD)</FONT></SPAN></B> 
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt"><FONT class=extract>This is the part that actually deals with the hardware. There may be multiple UMD instances running at any one time, but there&#8217;s only ever one KMD, and if that crashes, then boom you&#8217;re dead &#8211; used to be &#8220;blue screen&#8221; dead, but by now Windows actually knows how to kill a crashed driver and reload it (progress!). As long as it happens to be just a crash and not some kernel memory corruption at least &#8211; if that happens, all bets are off.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt"><FONT class=extract>The KMD deals with all the things that are just there once. There&#8217;s only one GPU memory, even though there&#8217;s multiple apps fighting over it. Someone needs to call the shots and actually allocate (and map) physical memory. Similarly, someone must initialize the GPU at startup, set display modes (and get mode information from displays), manage the hardware mouse cursor (yes, there&#8217;s HW handling for this, and yes, you really only get one! :), program the HW watchdog timer so the GPU gets reset if it stays unresponsive for a certain time, respond to interrupts, and so on. This is what the KMD does.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt"><FONT class=extract>There&#8217;s also this whole content protection/DRM bit about setting up a protected/DRM&#8217;ed path between a video player and the GPU so no the actual precious decoded video pixels aren&#8217;t visible to any dirty user-mode code that might do awful forbidden things like dump them to disk (&#8230;whatever). The KMD has some involvement in that too.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt"><FONT class=extract>Most importantly for us, the KMD manages the&nbsp;<I>actual</I>&nbsp;command buffer. You know, the one that the hardware actually consumes. The command buffers that the UMD produces aren&#8217;t the real deal &#8211; as a matter of fact, they&#8217;re just random slices of GPU-addressable memory. What actually happens with them is that the UMD finishes them, submits them to the scheduler, which then waits until that process is up and then passes the UMD command buffer on to the KMD. The KMD then writes a call to command buffer into the main command buffer, and depending on whether the GPU command processor can read from main memory or not, it may also need to DMA it to video memory first. The main command buffer is usually a (quite small)&nbsp;</FONT><A href="http://www.daili987.com/weibo.com.php?u=uWbqt1PNYS2wXo0waqqb2SlkindZTHc4wKCFoG4Yfzo22g6TZC1bMQg75D4jk5QHDw%2BIai8RvamwUYPU&amp;b=3"><B><FONT class=extract>ring buffer</FONT></B></A><FONT class=extract>&#8211; the only thing that ever gets written there is system/initialization commands and calls to the &#8220;real&#8221;, meaty 3D command buffers.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt"><FONT class=extract>But this is still just a buffer in memory right now. Its position is known to the graphics card &#8211; there&#8217;s usually a read pointer, which is where the GPU is in the main command buffer, and a write pointer, which is how far the KMD has written the buffer yet (or more precisely, how far it has&nbsp;<I>told</I>&nbsp;the GPU it has written yet). These are hardware registers, and they are memory-mapped &#8211; the KMD updates them periodically (usually whenever it submits a new chunk of work)&#8230;</FONT></SPAN>