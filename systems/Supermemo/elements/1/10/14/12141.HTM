<B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">A trip through the Graphics Pipeline 2011, part&nbsp;4</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">July 4, 2011</SPAN></P>
<p><I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">This post is part of the series&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqt1PNYS2wXo0waqqb2SlkindZTHc4wKCFoG8Yfj822wOTd2lBJEwpvCwthIkBRQbLemoF5au3VYCTVF6wZE9aHNtePsb%2BmYFlpwVOTbU%2BnU5g&amp;b=3"><B>&#8220;A trip through the Graphics Pipeline 2011&#8243;</B></A>.</SPAN></I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Welcome back. Last part was about vertex shaders, with some coverage of GPU shader units in general. Mostly, they&#8217;re just vector processors, but they have access to one resource that doesn&#8217;t exist in other vector architectures: Texture samplers. They&#8217;re an integral part of the GPU pipeline and are complicated (and interesting!) enough to warrant their own article, so here goes.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Texture state</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Before we start with the actual texturing operations, let&#8217;s have a look at the API state that drives texturing. In the D3D11 part, this is composed of 3 distinct parts:</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: 'Times New Roman'"><SPAN style="mso-list: Ignore">1.<SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The sampler state. Filter mode, addressing mode, max anisotropy, stuff like that. This controls how texture sampling is done in a general way.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: 'Times New Roman'"><SPAN style="mso-list: Ignore">2.<SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The underlying texture resource. This boils down to a pointer to the raw texture bits in memory. The resource also determines whether it&#8217;s a single texture or a texture array, what multisample format the texture has (if any), and the physical layout of the texture bits &#8211; i.e. at the resource level, it&#8217;s not yet decided how the values in memory are to be interpreted exactly, but their memory layout is nailed down.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: 'Times New Roman'"><SPAN style="mso-list: Ignore">3.<SPAN style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp; </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The shader resource view (SRV for short). This determines how the texture bits are to be interpreted by the sampler. In D3D10+, the resource view links to the underlying resource, so you never specify the resource explicitly.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Most of the time, you will create a texture resource with a given format, let&#8217;s say RGBA, 8 bits per component, and then just create a matching SRV. But you can also create a texture as &#8220;8 bits per component, typeless&#8221; and then have several different SRVs for the same resource that read the underlying data in different formats, e.g. once as UNORM8_SRGB (unsigned 8-bit value in sRGB space that gets mapped to float 0..1) and once as UINT8 (unsigned 8-bit integer).</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Creating the extra SRV seems like an annoying extra step at first, but the point is that this allows the API runtime to do all type checking at SRV creation time; if you get a valid SRV back, that means the SRV and resource formats are compatible, and no further type checking needs to be done while that SRV exists. In other words, it&#8217;s all about API efficiency here.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Anyway, at the hardware level, what this boils down to is just a bag of state associated with a texture sampling operation &#8211; sampler state, texture/format to use, etc. &#8211; that needs to get kept somewhere (see&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqt1PNYS2wXo0waqqb2SlkindZTHc4wKCFoG8Yfj822wiTd2lBJEwpvCwthIkBRQbLemoF5au3VYCTVF6wZE9aHNtePsb%2BmYFlpwVOVLoojBt91Q%3D%3D&amp;b=3"><B>part 2</B></A>&nbsp;for an explanation of various ways to manage state in a pipelined architecture). So again, there&#8217;s various methods, from &#8220;pipeline flush every time any state changes&#8221; to &#8220;just go completely stateless in the sampler and send the full set along with every texture request&#8221;, with various options inbetween. It&#8217;s nothing you need to worry about &#8211; this is the kind of thing where HW architects whip up a cost-benefit analysis, simulate a few workloads and then take whichever method comes out ahead &#8211; but it&#8217;s worth repeating: as PC programmer, don&#8217;t assume the HW adheres to any particular model.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Don&#8217;t assume that texture switches are expensive &#8211; they might be fully pipelined with stateless texture samplers so they&#8217;re basically free. But don&#8217;t assume they&#8217;re completely free either &#8211; maybe they are not fully pipelined or there&#8217;s a cap on the maximum number of different sets of texture states in the pipeline at any given time. Unless you&#8217;re on a console with fixed hardware (or you hand-optimize your engine for every generation of graphics HW you&#8217;re targeting), there&#8217;s just no way to tell. So when optimizing, do the obvious stuff &#8211; sort by material where possible to avoid unnecessary state changes and the like &#8211; which certainly saves you some API work at the very least, and then leave it at that. Don&#8217;t do anything fancy based on any particular model of what the HW is doing, because it can (and will!) change in the blink of an eye between HW generations.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Anatomy of a texture request</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">So, how much information do we need to send along with a texture sample request? It depends on the texture type and which kind of sampling instruction we&#8217;re using. For now, let&#8217;s assume a 2D texture. What information do we need to send if we want to do a 2D texture sample with, say, up to 4x anisotropic sampling?</SPAN></P>
<UL style="MARGIN-TOP: 0cm" type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l3 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The 2D texture coordinates &#8211; 2 floats, and sticking with the D3D terminology in this series, I&#8217;m going to call them u/v and not s/t.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l3 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The partial derivatives of u and v along the screen &#8220;x&#8221; direction:&nbsp;<v:shapetype id=_x0000_t75 stroked="f" filled="f" path="m@4@5l@4@11@9@11@9@5xe" o:preferrelative="t" o:spt="75" coordsize="21600,21600"> <v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:connecttype="rect" gradientshapeok="t" o:extrusionok="f"></v:path><o:lock aspectratio="t" v:ext="edit"></o:lock></v:shapetype><v:shape id=_x0000_i1025 style="WIDTH: 24pt; HEIGHT: 24pt" alt="\frac{\partial u}{\partial x}" type="#_x0000_t75"></v:shape>,&nbsp;<v:shape id=_x0000_i1026 style="WIDTH: 24pt; HEIGHT: 24pt" alt="\frac{\partial v}{\partial x}" type="#_x0000_t75"></v:shape>.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l3 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Similarly, we need the partial derivative in the &#8220;y&#8221; direction too:&nbsp;<v:shape id=_x0000_i1027 style="WIDTH: 24pt; HEIGHT: 24pt" alt="\frac{\partial u}{\partial y}" type="#_x0000_t75"></v:shape>,&nbsp;<v:shape id=_x0000_i1028 style="WIDTH: 24pt; HEIGHT: 24pt" alt="\frac{\partial v}{\partial y}" type="#_x0000_t75"></v:shape>.</SPAN></LI></UL>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">So, that&#8217;s 6 floats for a fairly pedestrian 2D sampling request (of the&nbsp;SampleGradvariety) &#8211; probably more than you thought. The 4 gradient values are used both for mipmap selection and to choose the size and shape of the anisotropic filtering kernel. You can also use texture sampling instructions that explicitly specify a mipmap level (in HLSL, that would be&nbsp;SampleLevel) &#8211; these don&#8217;t need the gradients, just a single value containing the LOD parameter, but they also can&#8217;t do anisotropic filtering &#8211; the best you&#8217;ll get is trilinear! Anyway, let&#8217;s stay with those 6 floats for a while. That sure seems like a lot. Do we really need to send them along with every texture request?</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The answer is: depends. In everything but Pixel Shaders, the answer is yes, we really have to (if we want anisotropic filtering that is). In Pixel Shaders, turns out we don&#8217;t; there&#8217;s a trick that allows Pixel Shaders to give you gradient instructions (where you can compute some value and then ask the hardware &#8220;what is the approximate screen-space gradient of this value?&#8221;), and that same trick can be employed by the texture sampler to get all the required partial derivatives just from the coordinates. So for a PS 2D &#8220;sample&#8221; instruction, you really only need to send the 2 coordinates which imply the rest, provided you&#8217;re willing to do some more math in the sampler units.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Just for kicks: What&#8217;s the worst-case number of parameters required for a single texture sample? In the current D3D11 pipeline, it&#8217;s a&nbsp;SampleGrad&nbsp;on a Cubemap array. Let&#8217;s see the tally:</SPAN></P>
<UL style="MARGIN-TOP: 0cm" type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo3; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">3D texture coordinates &#8211; u, v, w: 3 floats.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo3; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Cubemap array index: one int (let&#8217;s just bill that at the same cost as a float here).</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo3; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Gradient of (u,v,w) in the screen x and y directions: 6 floats.</SPAN></LI></UL>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">For a total of 10 values&nbsp;<I>per pixel sampled</I>&nbsp;&#8211; that&#8217;s 40 bytes if you actually store it like that. Now, you might decide that you don&#8217;t need full 32 bits for all of this (it&#8217;s probably overkill for the array index and gradients), but it&#8217;s still a lot of data to be sending around.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">In fact, let&#8217;s check what kind of bandwidth we&#8217;re talking about here. Let&#8217;s assume that most of our textures are 2D (with a few cubemaps thrown in), that most of our texture sampling requests come from the Pixel Shader with little to no texture samples in the Vertex Shader, and that the regular&nbsp;Sample-type requests are the most frequent, followed by&nbsp;SampleLevel&nbsp;(all of this is pretty typical for actual rendering you see in games). That means the average number of 32-bit floats values sent per pixel will be somewhere between 2 (u+v) and 3 (u+v+w / u+v+lod), let&#8217;s say 2.5, or 10 bytes.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Assume a medium resolution &#8211; say, 1280&#215;720, which is about 0.92 million pixels. How many texture samples does your average game pixel shader have? I&#8217;d say at least 3. Let&#8217;s say we have a modest amount of overdraw, so during the 3D rendering phase, we touch each pixel on the screen roughly twice. And then we finish it off with a few texture-heavy full-screen passes to do post-processing. That probably adds at least another 6 samples per pixel, taking into account that some of that postprocessing will be done at a lower resolution. Add it all up and we have 0.92 * (3*2 + 6) = about 11 million texture samples per frame, which at 30 fps is about 330 million a second. At 10 bytes per request, that&#8217;s 3.3 GB/s&nbsp;<I>just for texture request payloads</I>. Lower bound, since there&#8217;s some extra overhead involved (we&#8217;ll get to that in a second). Note that I&#8217;m *cough* erring &#8220;a bit&#8221; on the low side with all of these numbers :). An actual modern game on a good DX11 card will run in significantly higher resolution, with more complex shaders than I listed, comparable amount of overdraw or even somewhat less (deferred shading/lighting to the rescue!), higher frame rate, and way more complex postprocessing &#8211; go ahead, do a quick back-of-the-envelope calculation how much texture request bandwidth a decent-quality SSAO pass in quarter-resolution with bilateral upsampling takes&#8230;</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Point being, this whole texture bandwidth thing is not something you can just hand-wave away. The texture samplers aren&#8217;t part of the shader cores, they&#8217;re separate units some distance away on the chip, and shuffling multiple gigabytes per second around isn&#8217;t something that just happens by itself. This is an actual architectural issue &#8211; and it&#8217;s a good thing we don&#8217;t use&nbsp;SampleGrad&nbsp;on Cubemap arrays for everything :)</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">But who asks for a single texture sample?</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The answer is of course:&nbsp;<I>No one</I>. Our texture requests are coming from shader units, which we know process somewhere between 16 and 64 pixels / vertices / control points / &#8230; at once. So our shaders won&#8217;t be sending individual texture samples, they&#8217;ll dispatch a bunch of them at once. This time, I&#8217;ll use 16 as the number &#8211; simply because the 32 I chose last time is non-square, which just seems weird when talking about 2D texture requests. So, 16 texture requests at once &#8211; build that texture request payload, add some command fields at the start so the sampler knows what to do, add some more fields so the sampler knows which texture and sampler state to use (again, see the remarks above on state), and send that off to a texture sampler somewhere.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">This will take a while.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">No, seriously. Texture samplers have a seriously long pipeline (we&#8217;ll soon see why); a texture sampling operation takes&nbsp;<I>way</I>&nbsp;too long for a shader unit to just sit idle for all that time. Again, say it with me:&nbsp;<I>throughput</I>. So what happens is that on a texture sample, a shader unit will just quietly switch to another thread/batch and do some other work, then switch back a while later when the results are there. Works just fine as long as there&#8217;s enough independent work for the shader units to do!</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">And once the texture coordinates arrive&#8230;</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Well, there&#8217;s a bunch of computations to be done first: (In here and the following, I&#8217;m assuming a simple bilinear sample; trilinear and anisotropic take some more work, see below).</SPAN></P>
<UL style="MARGIN-TOP: 0cm" type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l1 level1 lfo4; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">If this is a&nbsp;Sample&nbsp;or&nbsp;SampleBias-type request, calculate texture coordinate gradients first.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l1 level1 lfo4; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">If no explicit mip level was given, calculate the mip level to be sampled from the gradients and add the LOD bias if specified.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l1 level1 lfo4; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">For each resulting sample position, apply the address modes (wrap / clamp / mirror etc.) to get the right position in the texture to sample from, in normalized [0,1] coordinates.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l1 level1 lfo4; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">If this is a cubemap, we also need to determine which cube face to sample from (based on the absolute values and signs of the u/v/w coordinates), and do a division to project the coordinates onto the unit cube so they are in the [-1,1] interval. We also need to drop one of the 3 coordinates (based on the cube face) and scale/bias the other 2 so they&#8217;re in the same [0,1] normalized coordinate space we have for regular texture samples.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l1 level1 lfo4; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Next, take the [0,1] normalized coordinates and convert them into fixed-point pixel coordinates to sample from &#8211; we need some fractional bits for the bilinear interpolation.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l1 level1 lfo4; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Finally, from the integer x/y/z and texture array index, we can now compute the address to read texels from. Hey, at this point, what&#8217;s a few more multiplies and adds among friends?</SPAN></LI></UL>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">If you think it sounds bad summed up like that, let me take remind you that this is a simplified view. The above summary doesn&#8217;t even cover fun issues such as texture borders or sampling cubemap edges/corners. Trust me, it may sound bad now, but if you were to actually write out the code for everything that needs to happen here, you&#8217;d be positively horrified. Good thing we have dedicated hardware to do it for us. :) Anyway, we now have a memory address to get data from. And wherever there&#8217;s memory addresses, there&#8217;s a cache or two nearby.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Texture cache</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Everyone seems to be using a two-level texture cache these days. The second-level cache is a completely bog-standard cache that happens to cache memory containing texture data. The first-level cache is not quite as standard, because it&#8217;s got additional smarts. It&#8217;s also smaller than you probably expect &#8211; on the order of 4-8kb per sampler. Let&#8217;s cover the size first, because it tends to come as a surprise to most people.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The thing is this: Most texture sampling is done in Pixel Shaders with mip-mapping enabled, and the mip level for sampling is specifically chosen to make the screen pixel:texel ratio roughly 1:1 &#8211; that&#8217;s the whole point. But this means that, unless you happen to hit the exact same location in a texture again and again, each texture sampling operation will miss about 1 texel on average &#8211; the actual measured value with bilinear filtering is around 1.25 misses/request (if you track pixels individually). This value stays more or less unchanged for a long time even as you change texture cache size, and then drops dramatically as soon as your texture cache is large enough to contain the whole texture (which usually is between a few hundred kilobytes and several megabytes, totally unrealistic sizes for a L1 cache).</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Point being,&nbsp;<I>any</I>&nbsp;texture cache whatsoever is a massive win (since it drops you down from about 4 memory accesses per bilinear sample down to 1.25). But unlike with a CPU or shared memory for shader cores, there&#8217;s very little gain in going from say 4k of cache to 16k; we&#8217;re streaming larger texture data through the cache no matter what.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Second point: Because of the 1.25 misses/sample average, texture sampler pipelines need to be long enough to sustain a full read from memory per sample without stalling. Let me phrase that differently: texture sampler pipes are long enough to not stall for a memory read&nbsp;<I>even though it takes 400-800 cycles</I>. That&#8217;s one seriously long pipeline right there &#8211; and it really is a pipeline in the literal sense, handing data from one pipeline register to the next for a few hundred cycles without any processing until the memory read is completed.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">So, small L1 cache, long pipeline. What about the &#8220;additional smarts&#8221;? Well, there&#8217;s compressed texture formats. The ones you see on PC &#8211; S3TC aka DXTC aka BC1-3, then BC4 and 5 which were introduced with D3D10 and are just variations on DXT, and finally BC6H and 7 which were introduced with D3D11 &#8211; are all block-based methods that encode blocks of 4&#215;4 pixels individually. If you decode them during texture sampling, that means you need to be able to decode up to 4 such blocks (if your 4 bilinear sample points happen to land in the worst-case configuration of straddling 4 blocks) per cycle and get a single pixel from each. That, frankly, just sucks. So instead, the 4&#215;4 blocks are decoded when it&#8217;s brought into the L1 cache: in the case of BC3 (aka DXT5), you fetch one 128-bit block from texture L2, and then decode that into 16 pixels in the texture cache. And suddenly, instead of having to partially decode up to 4 blocks per sample, you now only need to decode 1.25/(4*4) = about 0.08 blocks per sample, at least if your texture access patterns are coherent enough to hit the other 15 pixels you decoded alongside the one you actually asked for :). Even if you only end up using part of it before it goes out of L1 again, that&#8217;s still a massive improvement. Nor is this technique limited to DXT blocks; you can handle most of the differences between the &gt;50 different texture formats required by D3D11 in your cache fill path, which is hit about a third as often as the actual pixel read path &#8211; nice. For example, things like UNORM sRGB textures can be handled by converting the sRGB pixels into a 16-bit integer/channel (or 16-bit float/channel, or even 32-bit float if you want) in the texture cache. Filtering then operates on that, properly, in linear space. Mind that this does end up increasing the footprint of texels in the L1 cache, so you might want to increase L1 texture size; not because you need to cache more texels, but because the texels you cache are fatter. As usual, it&#8217;s a trade-off.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Filtering</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">And at this point, the actual bilinear filtering process is fairly straightforward. Grab 4 samples from the texture cache, use the fractional positions to blend between them. That&#8217;s a few more of our usual standby, the multiply-accumulate unit. (Actually a lot more &#8211; we&#8217;re doing this for 4 channels at the same time&#8230;)</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Trilinear filtering? Two bilinear samples and another linear interpolation. Just add some more multiply-accumulates to the pile.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Anisotropic filtering? Now that actually takes some extra work earlier in the pipe, roughly at the point where we originally computed the mip-level to sample from. What we do is look at the gradients to determine not just the area but also the shape of a screen pixel in texel space; if it&#8217;s roughly as wide as it is high, we just do a regular bilinear/trilinear sample, but if it&#8217;s elongated in one direction, we do several samples across that line and blend the results together. This generates several sample positions, so we end up looping through the full bilinear/trilinear pipeline several times, and the actual way the samples are placed and their relative weights are computed is a closely guarded secret for each hardware vendor; they&#8217;ve been hacking at this problem for years, and by now both converged on something pretty damn good at reasonable hardware cost. I&#8217;m not gonna speculate what it is they&#8217;re doing; truth be told, as a graphics programmer, you just don&#8217;t need to care about the underlying anisotropic filtering algorithm as long as it&#8217;s not broken and produces either terrible artifacts or terrible slowdowns.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Anyway, aside from the setup and the sequencing logic to loop over the required samples, this does not add a significant amount of computation to the pipe. At this point we have enough multiply-accumulate units to compute the weighted sum involved in anisotropic filtering without a lot of extra hardware in the actual filtering stage. :)</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Texture returns</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">And now we&#8217;re almost at the end of the texture sampler pipe. What&#8217;s the result of all this? Up to 4 values (r, g, b, a) per texture sample requested. Unlike texture requests where there&#8217;s significant variation in the size of requests, here the most common case by far is just the shader consuming all 4 values. Mind you, sending 4 floats back is nothing to sneeze at from a bandwidth point of view, and again you might want to shave bits in some case. If your shader is sampling a 32-bit float/channel texture, you&#8217;d better return 32-bit floats, but if it&#8217;s reading a 8-bit UNORM SRGB texture, 32 bit returns are just overkill, and you can save bandwidth by using a smaller format on the return path.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">And that&#8217;s it &#8211; the shader unit now has its texture sampling results back and can resume working on the batch you submitted &#8211; which concludes this part. See you again in the next installment, when I talk about the work that needs to be done before we can actually start rasterizing primitives.&nbsp;<B>Update</B>: And here&#8217;s a&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqpkPTKji0QsE1ZK2MyjMvnWFYUX4ywPXF5HFDK3BtnkjZSTdUO1U19HYvhoE%3D&amp;b=3"><B>picture</B></A>&nbsp;of the texture sampling pipeline, including an amusing mistake that I&#8217;ve fixed in post like a pro!</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The usual post-script</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">This time, no big disclaimers. The numbers I mentioned in the bandwidth example are honestly just made up on the spot since I couldn&#8217;t be arsed to look up some actual figures for current games :), but other than that, what I describe here should be pretty close to what&#8217;s on your GPU right now, even though I hand-waved past some of the corner cases in filtering and such (mainly because the details are more nauseating than they are enlightening).</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">As for texture L1 cache containing decompressed texture data, to the best of my knowledge this is accurate for current hardware. Some older HW would keep some formats compressed even in L1 texture cache, but because of the &#8220;1.25 misses/sample for a large range of cache sizes&#8221; rule, that&#8217;s not a big win and probably not worth the complexity. I think that stuff&#8217;s all gone now.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">An interesting bit are embedded/power-optimized graphics chips, e.g. PowerVR; I&#8217;ll not go into these kinds of chips much in this series since my focus here is on the high-performance parts you see in PCs, but I have some notes about them in the comments for previous parts if you&#8217;re interested. Anyway, the PVR chips have their own texture compression format that&#8217;s not block-based and very tightly integrated with their filtering hardware, so I would assume that they do keep their textures compressed even in L1 texture cache (actually, I don&#8217;t know if they even have a second cache level!). It&#8217;s an interesting method and probably at a fairly sweet spot in terms of useful work done per area and energy consumed. But I think the &#8220;depack to L1 cache&#8221; method gives higher throughput overall, and as I can&#8217;t mention often enough, it&#8217;s all about throughput on high-end PC GPUs :)</SPAN>