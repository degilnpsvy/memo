<B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">A trip through the Graphics Pipeline 2011, part&nbsp;6</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">July 6, 2011</SPAN></P>
<p><I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">This post is part of the series&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqt1PNYS2wXo0waqqb2SlkindZTHc4wKCFoG8Yfj822wOTd2lBJEwpvCwthIkBRQbLemoF5au3VYCTVF6wZE9aHNtePsb%2BmYFlpwVOTbU%2BnU5g&amp;b=3"><B>&#8220;A trip through the Graphics Pipeline 2011&#8243;</B></A>.</SPAN></I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Welcome back. This time we&#8217;re actually gonna see triangles being rasterized &#8211; finally! But before we can rasterize triangles, we need to do triangle setup, and before I can discuss triangle setup, I need to explain what we&#8217;re setting things up&nbsp;<I>for</I>; in other words, let&#8217;s talk hardware-friendly triangle rasterization algorithms.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">How&nbsp;<I>not</I>&nbsp;to render a triangle</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">First, a little heads-up to people who&#8217;ve been at this game long enough to have written their own optimized software texture mappers: First, you&#8217;re probably used to thinking of triangle rasterizers as this amalgamated blob that does a bunch of things at once: trace the triangle shape, interpolate u and v coordinates (or, for perspective correct mapping, u/z, v/z and 1/z), do the Z-buffer test (and for perspective correct mapping, you probably used a 1/z buffer instead), and then do the actual texturing (plus shading), all in one big loop that&#8217;s meticulously scheduled and probably uses all available registers. You know the kind of thing I&#8217;m talking about, right? Yeah, forget about that here. This is hardware. In hardware, you package things up into nice tidy little modules that are easy to design and test in isolation. In hardware, the &#8220;triangle rasterizer&#8221; is a block that tells you what (sub-)pixels a triangle covers; in some cases, it&#8217;ll also give you barycentric coordinates of those pixels inside the triangle. But that&#8217;s it. No u&#8217;s or v&#8217;s &#8211; not even 1/z&#8217;s. And certainly no texturing and shading, through with the dedicated texture and shader units that should hardly come as a surprise.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Second, if you&#8217;ve written your own triangle mappers &#8220;back in the day&#8221;, you probably used an incremental scanline rasterizer of the kind described in Chris Hecker&#8217;s&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqslzWbS29VcAsYKrRyjRs1kkeXHswg%2F7U%2FztYO3tGv1%2FffipcNUQ1zhk3go8XTguV&amp;b=3"><B>series on Perspective Texture Mapping</B></A>. That happens to be a great way to do it in sofware on processors without SIMD units, but it doesn&#8217;t map well to modern processors with fast SIMD units, and even worse to hardware &#8211; not that it&#8217;s stopped people from trying. In particular, there&#8217;s a certain dated game console standing in the corner trying very hard to look nonchalant right now. The one with that triangle rasterizer that had&nbsp;<I>really</I>&nbsp;fast guard-band clipping on the bottom and right edges of the screen, and not so fast guard-band clipping for the top and left edges (that, my friends, is what we call a &#8220;tell&#8221;). Just saying.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">So, what&#8217;s bad about that algorithm for hardware? First, it really rasterizes triangles scan-line by scan-line. For reasons that will become obvious once I get to Pixel Shading, we want our rasterizer to output in groups of 2&#215;2 pixels (so-called &#8220;quads&#8221; &#8211; not to be confused with the &#8220;quad&#8221; primitive that&#8217;s been decomposed into a pair of triangles at this stage in the pipeline). This is all kinds of awkward with the scan-line algorithm because not only do we now need to run two &#8220;instances&#8221; of it in parallel, they also each start at the first pixel covered by the triangle in their respective scan lines, which may be pretty far apart and doesn&#8217;t nicely lead to generating the 2&#215;2 quads we&#8217;d like to get. It&#8217;s also hard to parallelize efficiently, not symmetrical in the x and y directions &#8211; which means a triangle that&#8217;s 8 pixels wide and 100 pixels stresses very different parts of the rasterizer than a triangle that&#8217;s 100 pixels wide and 8 pixels high. Really annoying because now you have to make the &#8220;x&#8221; and &#8220;y&#8221; stepping &#8220;loops&#8221; equally fast in order to avoid bottlenecks &#8211; but we do all our work on the &#8220;y&#8221; steps, the loop in &#8220;x&#8221; is trivial! As said, it&#8217;s a mess.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">A better way</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">A much simpler (and more hardware-friendly) way to rasterize triangles was presented in a 1988&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqsl3QYS2wVdE%2FK7GM3XVxinFZSnwgwOTc9ClTIWs2j1XLeChaN0Fm9Tcsy9dEDF%2FIPyxR%2FfvrAMbJDBuxLE8OHttCZo7vzcMwq0QHQg%3D%3D&amp;b=3"><B>paper</B></A>&nbsp;by Pineda. The general approach can be summarized in 2 sentences: the signed distance to a line can be computed with a 2D dot product (plus an add) &#8211; just as a signed distance to a plane can be compute with a 3D dot product (plus add). And the interior of a triangle can be defined as the set of all points that are on the correct side of all three edges. So&#8230; just loop over all candidate pixels and test whether they&#8217;re actually inside the triangle. That&#8217;s it. That&#8217;s the basic algorithm.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Note that when we move e.g. one pixel to the right, we add one to X and leave Y the same. Our edge equations have the form E(X, Y) = aX + bY + c , with a, b, c being per-triangle constants, so for X+1 it will be E(X+1, Y) = a(X+1) + bY + c = E(X, Y) +a. In other words, once you have the values of the edge equations at a given point, the values of the edge equations for adjacent pixels are just a few adds away. Also note that this is absolutely trivial to parallelize: say you want to rasterize 8&#215;8 = 64 pixels at once, as AMD hardware likes to do (or at least the Xbox 360 does, according to the 3rd edition of&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqo1HFaCq8XcY1YLabzClol2NZTHc4wPDa%2FjUZJnx0hw%3D%3D&amp;b=3"><B>Real-time Rendering</B></A>). Well, you just compute ia + jb for&nbsp;0&lt;=i, j&lt;=7&nbsp;once for each triangle (and edge) and keep that in registers; then, to rasterize a 8&#215;8 block of pixels, you just compute the 3 edge equation for the top-left corner, fire off 8&#215;8 parallel adds of the constants we&#8217;ve just computed, and then test the resulting sign bits to see whether each of the 8&#215;8 pixels is inside or outside that edge. Do that for 3 edges, and presto, one 8&#215;8 block of a triangle rasterized in a truly embarrassingly parallel fashion, and with nothing more complicated than a bunch of integer adders! And by the way, this is why there&#8217;s snapping to a fixed-point grid in the previous part &#8211; so we can use integer math here. Integer adders are much,&nbsp;<I>much</I>&nbsp;simpler than any floating-point math unit. And of course we can choose the width of the adders just right to support the viewport sizes we want, with sufficient subpixel precision, and probably a 2x-4x factor on top of that so we get a decently-sized guard band.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">By the way, there&#8217;s another thorny bit here, which is fill rules; you need to have tie-breaking rules to ensure that for any pair of triangles sharing an edge, no pixel near that edge will ever be skipped or rasterized twice. D3D and OpenGL both use the so-called &#8220;top-left&#8221; fill rule; the details are explained in the respective manuals. I won&#8217;t talk about it here except to note that with this kind of integer rasterizer, it boils down to subtracting 1 from the constant term on some edges during triangle setup. That makes it guaranteed watertight, no fuss at all &#8211; compare with the kind of contortions Chris has to go through in his article to make this work properly! Sometimes things just come together beautifully.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">We have a problem though: How do we find out which 8&#215;8 blocks of pixels to test against? Pineda mentions two strategies: 1) just scanning over the whole bounding box of the triangle, or 2) a smarter scheme that stops to &#8220;turn around&#8221; once it notices that it didn&#8217;t hit any triangle samples anymore. Well, that&#8217;s just fine if you&#8217;re testing one pixel at a time. But we&#8217;re doing 8&#215;8 pixels now! Doing 64 parallel adds only to find out at the very end that exactly none of them hit any pixels whatsoever is a&nbsp;<I>lot</I>&nbsp;of wasted work. So&#8230; don&#8217;t do that!</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">What we need around here is more hierarchy</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">What I&#8217;ve just described is what the &#8220;fine&#8221; rasterizer does (the one that actually outputs sample coverage). Now, to avoid wasted work at the pixel level, what we do is add another rasterizer in front of it that doesn&#8217;t rasterize the triangle into pixels, but &#8220;tiles&#8221; &#8211; our 8&#215;8 blocks (<A href="http://www.daili987.com/weibo.com.php?u=uWbqoVHLdDKwHsA0ZLGThzZojSoSS216iuDc8j1fL2Y2iVPeOTRRMAopoG1om4UXTRyLb2EL5ryhUg%3D%3D&amp;b=3"><B>This</B></A>&nbsp;paper by McCormack and McNamara has some details, as does Greene&#8217;s&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqsl3QYS2wVdE%2FK7GM3XVxinFZSnwgwOTc9ClTIWs2j1XLeChaN0Fm9Tcsy9dEDF%2FIPyxR%2BfnrBcbPCxuxLE8OHttCZo7vzcMwq0QHQg%3D%3D&amp;b=3"><B>&#8220;Hierarchical Polygon Tiling with Coverage Masks&#8221;</B></A>&nbsp;that takes the idea to its logical conclusion). Rasterizing edge equations into covered tiles works very similarly to rasterizing pixels; what we do is compute lower and upper bounds for the edge equations over full tiles; since the edge equations are linear, such extrema occur on the boundary of the tile &#8211; in fact, it&#8217;s enough to loop at the 4 corner points, and from the signs of the &#8216;a&#8217; and &#8216;b&#8217; terms in the edge equation, we can determine which corner. Bottom line, it&#8217;s really not much more expensive than what we already discussed, and needs exactly the same machinery &#8211; a few parallel integer adders. As a bonus, if we evaluate the edge equations at one corner of the tile anyway, we might as well just pass that through to the fine rasterizer: it needs one reference value per 8&#215;8 block, remember? Very nice.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">So what we do now is run a &#8220;coarse&#8221; rasterizer first that tells us which tiles might be covered by the triangle. This rasterizer can be made smaller (8&#215;8 at this level really seems like overkill!), and it doesn&#8217;t need to be as fast (because it&#8217;s only run for each 8&#215;8 block). In other words, at this level, the cost of discovering empty blocks is correspondingly lower.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">We can think this idea further, as in Greene&#8217;s paper or Mike Abrash&#8217;s description of<A href="http://www.daili987.com/weibo.com.php?u=uWbqtUbAazy3Q40karXQyClikW0DSnshmuDQvD9ZKiV9jknVcSoaZBRuo2h1wNZG&amp;b=3"><B>Rasterization on Larrabee</B></A>, and do a full hierarchical rasterizer. But with a hardware rasterizer, there&#8217;s little to no point: it actually&nbsp;<I>increases</I>&nbsp;the amount of work done for small triangles (unless you can skip levels of the hierarchy, but that&#8217;s not how you design HW dataflows!), and if you have a triangle that&#8217;s large enough to actually produce significant rasterization work, the architecture I describe should already be fast enough to generate pixel locations faster than the shader units can consume them.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">In fact, the actual problem here isn&#8217;t big triangles in the first place; they are easy to deal with efficiently for pretty much any algorithm (certainly including scan-line rasterizers). The problem is small triangles! Even if you have a bunch of tiny triangles that generate 0 or 1 visible pixels, you still need to go through triangle setup (that I<I>still</I>&nbsp;haven&#8217;t described, but we&#8217;re getting close), at least one step of coarse rasterization, and then at least one fine rasterization step for an 8&#215;8 block. With tiny triangles, it&#8217;s easy to get either triangle setup or coarse rasterization bound.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">One thing to note is that with this kind of algorithm, slivers (long, very thin triangles) are seriously bad news &#8211; you need to traverse tons of tiles and only get very few covered pixels for each of them. So, well, they&#8217;re slow. Avoid them when you can.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">So what does triangle setup do?</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Well, now that I&#8217;ve described what the rasterization algorithm is, we just need to look what per-edge constants we used throughout; that&#8217;s exactly what we need to set up during triangle setup.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">In our case, the list is this:</SPAN></P>
<UL style="MARGIN-TOP: 0cm" type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The edge equations &#8211; a, b, c for all 3 triangle edges.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Some of the derived values, like the ia + jb for&nbsp;0&lt;=i, j&lt;=7 &nbsp;that I mentioned; note that you wouldn&#8217;t actually store a full 8&#215;8 matrix of these in hardware, certainly not if you&#8217;re gonna add another value to it anyway. The best way to do this is in HW probably to just compute the ia&nbsp;and&nbsp;jb, use a&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqtFqKcze%2BWdMiYbGehzRznisARnM8wNHU4yxOY3t4nV%2FjdyBRM1c%3D&amp;b=3"><B>Carry-save adder</B></A>(aka 3:2 reducer, I wrote about them&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqt1PNYS2wXo0waqqb2SlkindZTHc4wKCFoG4YfjA22QmTdSVHJFx04jkzk8sVRgqDfHFNqaKhGZGNWE%2BiLlZdC5NQPty2xNI2%2FVEHCa07lEMqiXA%3D&amp;b=3"><B>before</B></A>) to reduce the&nbsp;ia + jb + c expression to a single sum, and then finish that off with a regular adder. Or something similar, anyway.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Which reference corner of the tiles to use to get the upper/lower bounds of the edge equations for coarse rasterizer.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The initial value of the edge equations at the first reference point for the coarse rasterizer (adjusted for fill rule).</SPAN></LI></UL>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">&#8230;so that&#8217;s what triangle setup computes. It boils down to several large integer multiplies for the edge equations and their initial values, a few smaller multiplies for the step values, and some cheap combinatorial logic for the rest.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Other rasterization issues and pixel output</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">One thing I didn&#8217;t mention so far is the scissor rect. That&#8217;s just a screen-aligned rectangle that masks pixels; no pixel outside that rect will be generated by the rasterizer. This is fairly easy to implement &#8211; the coarse rasterizer can just reject tiles that don&#8217;t overlap the scissor rect outright, and the fine rasterizer ANDs all generated coverage masks with the &#8220;rasterized&#8221; scissor rectangle (where &#8220;rasterization&#8221; here boils down to a one integer compare per row and column and some bitwise ANDs). Simple stuff, moving on.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Another issue is multisample antialiasing. What changes is now you have to test more samples per pixel &#8211; as of DX11, HW needs to support at least 8x MSAA. Note that the sample locations inside each pixel aren&#8217;t on a regular grid (which is badly behaved for near-horizontal or near-vertical edges), but dispersed to give good results across a wide range of multiple edge orientations. These irregular sample locations are a total pain to deal with in a scanline rasterizer (another reason not to use them!) but very easy to support in a Pineda-style algorithm: it boils down to computing a few more per-edge offsets in triangle setup and multiple additions/sign tests per pixel instead of just one.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">For, say 4x MSAA, you can do two things in an 8&#215;8 rasterizer: you can treat each sample as a distinct &#8220;pixel&#8221;, which means your effective tile size is now 4&#215;4 actual screen pixels after the MSAA resolve and each block of 2&#215;2 locations in the fine rast grid now corresponds to one pixel after resolve, or you can stick with 8&#215;8 actual pixels and just run through it four times. 8&#215;8 seems a bit large to me, so I&#8217;m assuming that AMD does the former. Other MSAA levels work analogously.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Anyway, we now have a fine rasterizer that gives us locations of 8&#215;8 blocks plus a coverage mask in each block. Great, but it&#8217;s just half of the story &#8211; current hardware also does early Z and hierarchical Z testing (if possible) before running pixel shaders, and the Z processing is interwoven with actual rasterization. But for didactic reasons it seemed better to split this up; so in the next part, I&#8217;ll be talking about the various types of Z processing, Z compression, and some more triangle setup &#8211; so far we&#8217;ve just covered setup for rasterization, but there&#8217;s also various interpolated quantities we want for Z and pixel shading, and they need to be set up too! Until then.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Caveats</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">I&#8217;ve linked to a few rasterization algorithms that I think are representative of various approaches (they also happen to be all on the Web). There&#8217;s a lot more. I didn&#8217;t even try to give you a comprehensive introduction into the subject here; that would be a (lengthy!) serious of posts on its own &#8211; and rather dull after a fashion, I fear.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Another implicit assumption in this article (I&#8217;ve stated this multiple times, but this is one of the places to remind you) is that we&#8217;re on high-end PC hardware; a lot of parts, particularly in the mobile/embedded range, are so-called&nbsp;<I>tile renderers</I>, which partition the screen into tiles and render each of them individually. These are&nbsp;<I>not</I>&nbsp;the same as the 8&#215;8 tiles for rasterization I used throughout this article. Tiled renderes need at least another &#8220;ultra-coarse&#8221; rasterization stage that runs early and finds out which of the (large) tiles are covered by each triangle; this stage is usually called &#8220;binning&#8221;. Tiled renderers work differently and have different design parameters than the &#8220;sort-last&#8221; architectures (that&#8217;s the official name) I describe here. When I&#8217;m done with the D3D11 pipeline (and that&#8217;s still a ways off!) I might throw in a post or two on tiled renderers (if there&#8217;s interest), but right now I&#8217;m just ignoring them, so be advised that e.g. the PowerVR chips you so often find in smartphones handle some of this differently.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The 8&#215;8 blocking (other block sizes have the same problem) means that triangles smaller than a certain size, or with inconvenient aspect ratios, take a lot more rasterization work than you would think, and get crappy utilization during the process. I&#8217;d love to be able to tell you that there&#8217;s a magic algorithm that&#8217;s easy to parallelize<I>and</I>&nbsp;good with slivers and the like, but if there is I don&#8217;t know it, and since there&#8217;s still regular reminders by the HW vendors that slivers are bad, apparently neither do they. So for the time being, this just seems to be a fact of life with HW rasterization. Maybe someone will come up with a great solution for this eventually.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The &#8220;edge function lower bound&#8221; thing I described for coarse rast works fine, but generates false positives in certain cases (false positives in the sense that it asks for fine rasterization in blocks that don&#8217;t actually cover any pixels). There&#8217;s tricks to reduce this, but again, detecting some of the rarer cases is trickier / more expensive than just rasterizing the occasional fine block that doesn&#8217;t have any pixels lit. Another trade-off.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Finally the blocks used during rasterization are often snapped on a grid (why that would help will become clearer in the next part). If that&#8217;s the case, even a triangle that just covers 2 pixels might straddle 2 tiles and make you rasterize two 8&#215;8 blocks. More inefficiency.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The point is this: Yes, all this is fairly simple and elegant, but it&#8217;s not perfect, and actual rasterization for actual triangles is nowhere near theoretical peak rasterization rates (which always assume that all of the fine blocks are completely filled). Keep that in mind.</SPAN>