<HEAD></HEAD>
<BODY><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">A trip through the Graphics Pipeline 2011, part&nbsp;5</SPAN></B>
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">July 5, 2011</SPAN></P>
<P><I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">This post is part of the series&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqt1PNYS2wXo0waqqb2SlkindZTHc4wKCFoG8Yfj822wOTd2lBJEwpvCwthIkBRQbLemoF5au3VYCTVF6wZE9aHNtePsb%2BmYFlpwVOTbU%2BnU5g&amp;b=3"><B>&#8220;A trip through the Graphics Pipeline 2011&#8243;</B></A>.</SPAN></I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt"></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">After the last post about texture samplers, we&#8217;re now back in the 3D frontend. We&#8217;re done with vertex shading, so now we can start actually rendering stuff, right? Well, not quite. You see, there&#8217;s a bunch still left to do before we actually start rasterizing primitives. So much so in fact that we&#8217;re not going to see any rasterization in this post &#8211; that&#8217;ll have to wait until next time.</SPAN></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Primitive Assembly</SPAN></B></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">When we left the vertex pipeline, we had just gotten a block of shaded vertices back from the shader units, with the implicit promise that this block contains an integral number of primitives &#8211; i.e., we don&#8217;t allow triangles, lines or patches to be split across multiple blocks. This is important, because it means we can truly treat each block independently and never need to buffer more than one block of shader output &#8211; we can, of course, but we don&#8217;t have to.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The next step is to assemble all the vertices belonging to a single primitive (hence &#8220;primitive assembly&#8221;). If that primitive happens to be a point, this just reads exactly one vertex and passes it on. If it&#8217;s lines, it reads two vertices. If it&#8217;s triangles, three. And so on for patches with larger numbers of control points.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">In short, all that happens here is that we gather vertices. We can either do this by reading the original index buffer and keeping a copy of our vertex index-&gt;cache position map around (as I described), or we can store the indices for the fully expanded primitives along with the shaded vertex data, which might take a bit more space for the output buffer but means we don&#8217;t have to read the indices again here. Either way works fine.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">And now we have expanded out all the vertices that make up a primitive. In other words, we now have complete triangles, not just a bunch of vertices. So can we rasterize them already? Not quite.</SPAN></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Viewport culling and clipping</SPAN></B></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Oh yeah, that. Yeah, I guess we&#8217;d better do that first, huh? This is one part of pipeline that really does exactly what you&#8217;d expect, pretty much the way you would expect it too (i.e. the way it&#8217;s explained in the docs). So I&#8217;m not gonna explain polygon clipping in general here, you can look that up in any computer graphics textbook, although most make a terrible mess of it; if you want a good explanation, use Jim Blinn&#8217;s (chapter 13 of&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqpkPTKj%2B4Udkoa%2FacxjYus20aAlo5hvzb4nN0IXp3jkiRUTZUJk0w8itopo8ERwKPYGdPrLzqBcXOBQvzegcEWQ%3D%3D&amp;b=3"><B>this book</B></A>), although you probably want to pass on his alternative [0,w] clip space these days, to avoid confusion if nothing else.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Anyway, clipping. The short version is this: Your vertex shader returns vertex positions on homogeneous clip space. Clip space is chosen to make the equations that describe the view frustum as simple as possible; in the case of D3D, they are&nbsp;<?xml:namespace prefix = v /><v:shapetype id=_x0000_t75 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"> <v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"></v:path><?xml:namespace prefix = o /><o:lock v:ext="edit" aspectratio="t"></o:lock></v:shapetype><v:shape id=_x0000_i1028 style="WIDTH: 24pt; HEIGHT: 24pt" type="#_x0000_t75" alt="-w \le x \le w"></v:shape>,&nbsp;<v:shape id=_x0000_i1029 style="WIDTH: 24pt; HEIGHT: 24pt" type="#_x0000_t75" alt="-w \le y \le w"></v:shape>,&nbsp;<v:shape id=_x0000_i1030 style="WIDTH: 24pt; HEIGHT: 24pt" type="#_x0000_t75" alt="0 \le z \le w"></v:shape>, and&nbsp;<v:shape id=_x0000_i1031 style="WIDTH: 24pt; HEIGHT: 24pt" type="#_x0000_t75" alt="0 < w"></v:shape>; note that all the last equation really does is exclude the homogeneous point (0,0,0,0), which is something of a degenerate case.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">We first need to find out if the triangle is partially or even completely outside any of these clip planes. This can be done very efficiently using&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqtFqKcze%2BWdMiYbGehzRznisARnM8wNHa%2BTtZa00rzgKMM30GBVAt%2BT03mocaRg%3D%3D&amp;b=3"><B>Cohen-Sutherland</B></A>-style out-codes. You compute the clip out-code (or just clip-code) for each vertex (this can be done at vertex shading time and stored along with the positions, for example). Then, for each primitive, the bitwise AND of the clip-codes will tell you all the view-frustum planes that&nbsp;<I>all</I>&nbsp;vertices in the primitive are on the wrong side of (if there&#8217;s any, that means the primitive is completely outside the view frustum and can be thrown away), and the bitwise OR of the clip-codes will tell you the planes that you need to clip the primitive against. Given the clipcodes, all this is just a few gates worth of hardware &#8211; simple stuff.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Additionally, the shaders can also generate a set of &#8220;cull distances&#8221; (a triangle will be discarded if any one cull distance for all vertices is less than zero), and a set of &#8220;clip distances&#8221; (which define additional clipping planes). These get considered for primitive rejection/clip testing too.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The actual clipping process, if invoked, can take one of two forms: we can either use an actual polygon clipping algorithm (which adds extra vertices and triangles), or we can add the clipping planes as extra edge equations to the rasterizer (if that sounds like gibberish to you, wait until the next part where I explain rasterization &#8211; it&#8217;ll ask make sense eventually). The latter is more elegant and doesn&#8217;t require an actual polygon clipper at all, but we need to be able to handle all normalized 32-bit floating point values as valid vertex coordinates; there might be a trick for building a fast HW rasterizer that does this, but it seems tricky to say the least. So I&#8217;m assuming there&#8217;s an actual clipper, with all that involves (generation of extra triangles etc). This is a nuisance, but it&#8217;s also very infrequent (more so than you think, I&#8217;ll get to that in a second), so it&#8217;s not a big deal. Not sure if that&#8217;s special hardware either, or if that path grabs a shader unit to do the actual clipping; depends on whether dispatching a new vertex shading load at this stage is awkward or not, how big a dedicated clipping unit is, and how many of them you need. I don&#8217;t know the answer to these questions, but at least from the performance side of things, it doesn&#8217;t much matter: we don&#8217;t really clip that often. That&#8217;s because we can use guard-band clipping.</SPAN></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Guard-band clipping</SPAN></B></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The name is something of a misnomer; it&#8217;s not a fancy way of doing clipping. In fact, it&#8217;s quite the opposite: a straight-forward way of not doing clipping. :)</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The underlying idea is very simple: Most primitives that are partially outside the left, right, top and bottom clip planes don&#8217;t need to be clipped at all. Triangle rasterization on GPUs works by, in effect, scanning over the full screen area (or more precisely, the scissor rect) and asking for every pixel: &#8220;is this pixel covered by the current triangle?&#8221; (In reality it&#8217;s a bit more complicated and way more efficient than that, but that&#8217;s the general idea). And that works just as well for triangles completely within the viewport as it does for triangles that extend past, say, the right and top clipping planes. As long as our triangle coverage test is reliable, we don&#8217;t need to clip against the left, right, top and bottom planes at all!</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">That test is usually done in integer arithmetic with some fixed precision. And eventually, as you move say one triangle vertex further and further out, you&#8217;ll get integer overflows and wrong test results. I think we can all agree that the rasterizer producing pixels that aren&#8217;t actually inside the triangle is, at the very least, extremely offensive behavior and should be illegal! Which it in fact is &#8211; hardware that does this is in violation of the spec.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">There&#8217;s two solutions for this problem: The first is to make sure that your triangle tests never, ever generate the wrong results, no matter how your input triangle looks. If you manage that, then you don&#8217;t ever need to clip against the aforementioned four planes. This is called &#8220;infinite guard-band&#8221; because, well, the guard-band is effectively infinite. Solution two is to clip triangles eventually, just as they&#8217;re about to go outside the safe range where the rasterizer calculations can&#8217;t overflow. For example, say that your rasterizer has enough internal bits to deal with integer triangle coordinates that have&nbsp;<v:shape id=_x0000_i1026 style="WIDTH: 24pt; HEIGHT: 24pt" type="#_x0000_t75" alt="-32768 \le X \le 32767"></v:shape>,&nbsp;<v:shape id=_x0000_i1027 style="WIDTH: 24pt; HEIGHT: 24pt" type="#_x0000_t75" alt="-32768 \le Y \le 32767"></v:shape>&nbsp;(note I&#8217;m using capital X and Y to denote screen-space positions; I&#8217;ll stick with this convention). You still do your viewport cull test (i.e. &#8220;is this triangle outside the view frustum&#8221;) with the regular view planes, but only actually clip against the guard-band clip planes which are chosen so that after the projection and viewport transforms, the resulting coordinates are in the safe range. I guess it&#8217;s time for an image:</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">&nbsp;</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt"><v:shape id=_x0000_i1025 style="WIDTH: 314.25pt; HEIGHT: 331.5pt" type="#_x0000_t75"><v:imagedata src="file:///C:\DOCUME~1\DONPOP~1\LOCALS~1\Temp\msohtml1\01\clip_image002.png" o:title="guardband_clip"></v:imagedata></v:shape></SPAN></P>
<P><I><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Guard-band clipping</SPAN></I></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">The small white rectangle with blue outline that&#8217;s roughly in the middle represents our viewport, while the big salmon-colored area around it is our guard band. It looks like a small viewport in this image, but I actually picked a huge one so you can see anything! With our -32768 .. 32767 guard-band clip range, that viewport would be about 5500 pixels wide &#8211; yes, that&#8217;s some huge triangles right there :). Anyway, the triangles show off some of the important cases. The yellow triangle is the most common case &#8211; a triangle that extends outside the viewport but not the guard band. This just gets passed straight through, no further processing necessary. The green triangle is fully within the guard band, but outside the viewport region, so it would never get here &#8211; it&#8217;s been rejected above by the viewport cull. The blue triangle extends outside the guard-band clip region and would need to be clipped, but again it&#8217;s fully outside the viewport region and gets rejected by the viewport cull. Finally, the purple triangle extends both inside the viewport and outside the guard band, and so actually needs to be clipped.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">As you can see, the kinds of triangles you need to actually have to clip against the four side planes are pretty extreme. As said, it&#8217;s infrequent &#8211; don&#8217;t worry about it.</SPAN></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Aside: Getting clipping right</SPAN></B></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">None of this should be terribly surprising; nor should it sound too difficult, at least if you&#8217;re familiar with the algorithms. But the devil&#8217;s in the details, always. Here&#8217;s some of the non-obvious rules the triangle clipper has to obey in practice. If it ever breaks<I>any</I>&nbsp;of these rules, there&#8217;s cases where it will produce cracks between adjacent triangles that share an edge. This isn&#8217;t allowed.</SPAN></P>
<UL style="MARGIN-TOP: 0cm" type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Vertex positions that are inside the view frustum must be preserved, bit-exact, by the clipper.</SPAN> 
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Clipping an edge AB against a plane must produce the same results, bit-exact, as clipping the edge BA (orientation reversed) against that plane. (This can be ensured by either making the math completely symmetric, or always clipping an edge in the same direction, say from the outside in).</SPAN> 
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Primitives that are clipped against multiple planes must always clip against planes in the same order. (Either that or clip against all planes at once)</SPAN> 
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">If you use a guard band, you&nbsp;<I>must</I>&nbsp;clip against the guard band planes; you can&#8217;t use a guard band for some triangles but then clip against the original viewport planes if you actually need to clip. Again, failing to do this will cause cracks &#8211; and if I remember correctly there was actually a piece of graphics hardware in the bad old days that shipped with this bug enshrined in silicon. Oops. :)</SPAN></LI></UL>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Those pesky near and far planes</SPAN></B></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Okay, so we have a really nice quick solution for the 4 side planes, but what about near and far? Particularly the near plane is bothersome, since with all the stuff that&#8217;s only slightly outside the viewport handled, that&#8217;s the plane we do most of our clipping for. So what can we do? A z guard band? But how would that work &#8211; we&#8217;re not actually rasterizing along the z axis at all! In fact, it&#8217;s just some value we interpolate over the triangle, damn!</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">On the plus side, though, it&#8217;s just some value we interpolate over the triangle. And in fact the z-near test (<v:shape id=_x0000_i1032 style="WIDTH: 24pt; HEIGHT: 24pt" type="#_x0000_t75" alt="Z < 0"></v:shape>) is&nbsp;<I>really easy</I>&nbsp;to do once you interpolate Z &#8211; it&#8217;s just the sign bit. z-far (<v:shape id=_x0000_i1033 style="WIDTH: 24pt; HEIGHT: 24pt" type="#_x0000_t75" alt="Z > 1"></v:shape>) is an extra compare though (not I&#8217;m using Z not z here, i.e. these are &#8220;screen&#8221; or post-projection coordinates). But still, we&#8217;re doing Z-compares per pixel anyway (Z test!), so it&#8217;s not a big extra expense. It depends, but doing z-clip this way is definitely an option. And you need to be able to skip z-near/z-far clipping if you want to support things like NVidias &#8216;depth clamp&#8217; OpenGL extension; in fact, I would argue the existence of that extension is a pretty good hint that they&#8217;re doing this, or at least used to for a while.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">So we&#8217;re down to one of the regular clip planes:&nbsp;<v:shape id=_x0000_i1034 style="WIDTH: 24pt; HEIGHT: 24pt" type="#_x0000_t75" alt="0 < w"></v:shape>. Can we get rid of this one too? The answer is yes, with a rasterization algorithm that works in homogeneous coordinates, e.g.&nbsp;<A href="http://www.daili987.com/weibo.com.php?u=uWbqpkPTKj2mHtYpZvaazS4uh2sbTnY6wOLU4TtFPScrj1KRYjZceQ%3D%3D&amp;b=3"><B>this one</B></A>. I&#8217;m not sure whether hardware uses that one though. It&#8217;s nice an elegant, but it seems like it would be hard to obey the (very strict!) D3D11 rasterization rules to the letter using that algorithm. But maybe there&#8217;s some cool tricks that I&#8217;m not aware of. Anyway, that&#8217;s about it with clipping.</SPAN></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Projection and viewport transform</SPAN></B></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Projection just takes the x, y and z coordinates and divides them by w (unless you&#8217;re using a homogeneous rasterizer which doesn&#8217;t actually project &#8211; but I&#8217;ll ignore that possibility in the following). This gives us normalized device coordinates, or NDCs, between -1 and 1. We then apply the viewport transform which maps the projected x and y to pixel coordinates (which I&#8217;ll call X and Y) and the projected z into the range [0,1] (I&#8217;ll call this value Z), such that at the z-near plane Z=0 and at the z-far plane Z=1.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">At this point, we also snap pixels to fractional coordinates on the sub-pixel grid. As of D3D11, hardware is required to have exactly 8 bits of subpixel precision for triangle coordinates. This snapping turns some&nbsp;<I>very</I>&nbsp;thin slivers (which would otherwise cause problems) into degenerate triangles (which don&#8217;t need to be rendered at all).</SPAN></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Back-face and other triangle culling</SPAN></B></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Once we have X and Y for all vertices, we can calculate the signed triangle area using a cross product of the edge vectors. If the area is negative, the triangle is wound counter-clockwise (here, negative areas correspond to counter-clockwise because we&#8217;re now in the pixel coordinate space, and in D3D pixel space y increases downwards not upwards, so signs are inverted). If the area is positive, it&#8217;s wound clockwise. If it&#8217;s zero, it&#8217;s degenerate and doesn&#8217;t cover any pixels, so it can be safely culled. At this point, we know the triangle orientation so we can do back-face culling (if enabled).</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">And that&#8217;s it! We&#8217;re now ready for rasterization&#8230; almost. Actually we have to do triangle setup first. But doing that requires some knowledge of how rasterization will be performed, so I&#8217;ll put that off until the next part&#8230; see you then!</SPAN></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Final remarks</SPAN></B></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Again, I skipped some parts and simplified others, so here&#8217;s the usual reminder that things are a bit more complicated in reality: For example, I pretended that you just use the regular homogeneous clipping algorithm. Mostly, you do &#8211; but you can have some vertex shader attributes flagged as using screen-space linear instead of perspective-correct interpolation. Now, the regular homogeneous clip always does perspective-correct interpolation; in the case of screen-space linear attributes, you actually need to do some extra work to make it not perspective-correct. :)</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">I talk about primitives some of the time, but mostly I&#8217;m just focusing on triangles here. Points and lines aren&#8217;t hard, but let&#8217;s be honest, they&#8217;re not what we&#8217;re here for either. You can work out the details if you&#8217;re interested. :)</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">There&#8217;s tons of rasterization algorithms out there, some of which (like Olanos 2DH method that I cited) allow you to skip nearly all clipping, but as I mentioned, D3D11 has very strict requirements on the triangle rasterizer so there&#8217;s not much wiggle room for HW implementations; I&#8217;m not sure if those methods can be tweaked to exactly follow the spec (there&#8217;s a lot of subtle points that I&#8217;ll cover next time). So here and in the following I&#8217;m assuming you can&#8217;t do the ultra-sleek thing; then again, the not-quite-so-sleek approaches I&#8217;m running with have slightly less math per pixel in the rasterizer, so they might win for HW implementations anyway. And of course I might be missing the magic pixie dust right around the corner that solves all of these problems. That occurs surprisingly often in graphics. If you know an awesome solution, give me a shout in the comments!</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 12.0pt">Lastly, the triangle culling I&#8217;m describing here is the bare minimum; for example, the class of triangles that will generate zero pixels upon rasterization is much larger than just zero-area tris, and if you can find it out quickly enough (or with few enough gates), you can drop the triangle immediately and don&#8217;t need to go through triangle setup. This is the last point where you can cull cheaply before going through triangle setup and at least some rasterization &#8211; finding other ways to early-reject tris pays off handsomely here.</SPAN></P></BODY>