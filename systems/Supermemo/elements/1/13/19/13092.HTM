<DIV class=navheader style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<TABLE width="100%" summary="Navigation header">
<TBODY>
<TR>
<TH align=middle colSpan=3>10.10.&nbsp;Top-down Programming and Stubs</TH></TR>
<TR>
<TD align=left width="20%"><A accessKey=p href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch10s09.html">Prev</A>&nbsp;</TD>
<TH align=middle width="60%">Chapter&nbsp;10.&nbsp;Subprogram Calls and the Stack</TH>
<TD align=right width="20%">&nbsp;<A accessKey=n href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch10s11.html">Next</A></TD></TR></TBODY></TABLE>
<HR>
</DIV>
<DIV class=section title="10.10.&nbsp;Top-down Programming and Stubs" style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=id286963291></A>10.10.&nbsp;Top-down Programming and Stubs</H2></DIV></DIV></DIV>
<P>When designing and implementing something, it is generally preferable to start at the most abstract level, and work down from there. For example, when designing and building a house, we prefer to start by deciding what kind of house we want. This in turn helps us determine how many floors, the rooms on each floor, and eventually what kind of building materials we'll need. This is the top-down approach.</P>
<P>The bottom-up approach begins with the materials we have available and determines the higher level features based on what's possible with what we have. For example, if we start by deciding that our house will be made of snow, mud, or straw, this will strongly influence the type of house we end up with.</P>
<P>The top-down approach doesn't prevent us from using pre-existing components at any level of the design or implementation. It merely allows the design to dictate the components, rather than vice-versa.</P>
<P>These principals apply to computer programs as well as to houses. In order to end up with a program that closely matches our needs, it is preferable to begin at the highest level of abstraction (what the program does and how is is used), and let that determine how the more detailed levels are designed and implemented.</P>
<P>In the implementation stage, the top-down approach involves writing the main program first, along with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>stub</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=indexterm name=id286963307></A>each subprogram called by main. A stub is simply an empty subprogram which has a complete<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>interface</EM></SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>signature</EM></SPAN>, but no real code inside. The interface, or signature, refers to the argument list and return value. (These are the only features of a subprogram that other subprograms should be concerned with.)<A class=indexterm name=id286963318></A><A class=indexterm name=id286963322></A></P>
<P>The program consisting of a complete main calling one or more stubs can be compiled to weed out the syntax errors, and also tested to ensure that the subprogram interfaces work properly. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>testable stub</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=indexterm name=id286963332></A>will return a value which indicates that all arguments were received. For example, consider the following program:</P><PRE class=programlisting>import java.io.*;

class stub
{
    // Stub for 2nd level of abstraction to allow testing of 1st
    public static double power(double base, double exponent)
    {
	return base + exponent;
    }
    
    // 1st level of abstraction: main program
    public static void main(String args[])
    {
	double  base = 3.14, exponent;
	
	for (exponent = 0.5; exponent &lt;= 5.0; exponent += 0.5)
	{
	    System.out.printf("%f ^ %f = %f\n",
		base, exponent, power(base, exponent));
	}
	return;
    }
}
</PRE>
<P>This program contains a stub for power(), which compiles, executes, and returns a value indicating that the arguments base and exponent were received properly. The code to actually compute the power will be added later when implementing the second level of abstraction. The stub allows the implementation of the main program to be tested before beginning the implementation of the subprograms called by the main program. After testing with the stub, we now know that the main program works properly. If we encounter errors while implementing power() we don't need to look for bugs in the main program, so the debugging process will be much simpler.</P></DIV>
<DIV class=navfooter style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<HR>

<TABLE width="100%" summary="Navigation footer">
<TBODY>
<TR>
<TD align=left width="40%"><A accessKey=p href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch10s09.html">Prev</A>&nbsp;</TD>
<TD align=middle width="20%"><A accessKey=u href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch10.html">Up</A></TD>
<TD align=right width="40%">&nbsp;<A accessKey=n href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch10s11.html">Next</A></TD></TR>
<TR>
<TD vAlign=top align=left width="40%">10.9.&nbsp;Coding Practice&nbsp;</TD>
<TD align=middle width="20%"><A accessKey=h href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/index.html">Home</A></TD>
<TD vAlign=top align=right width="40%">&nbsp;10.11.&nbsp;Homework</TD></TR></TBODY></TABLE></DIV>