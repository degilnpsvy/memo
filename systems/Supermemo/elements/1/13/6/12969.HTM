<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 5 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Basic Types and Operations</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>Now that you've seen classes and objects in action, it's a good time to look at Scala's basic types and operations in more depth. If you're familiar with Java, you'll be glad to find that Java's basic types and operators have the same meaning in Scala. However there are some interesting differences that will make this chapter worthwhile reading even if you're an experienced Java developer. Because some of the aspects of Scala covered in this chapter are essentially the same in Java, we've inserted notes indicating what Java developers can safely skip, to expedite your progress.</P>
<P>In this chapter, you'll get an overview of Scala's basic types, including<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>s and the value types<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Long</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Short</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Byte</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Float</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Char</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN>. You'll learn the operations you can perform on these types, including how operator precedence works in Scala expressions. You'll also learn how implicit conversions can "enrich" variants of these basic types, giving you additional operations beyond those supported by Java.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=5.1></A>5.1 Some basic types<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#5.1">link</A>]</SPAN></H3>
<P>Several fundamental types of Scala, along with the ranges of values instances of these types may have, are shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#tab:valtypes">Table 5.1</A>. Collectively, types<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Byte</SPAN>,<A id=i1013322880-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Short</SPAN>,<A id=i1149344948-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>,<A id=i517506535-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Long</SPAN>,<A id=i-149056780-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Char</SPAN><A id=i1377752142-1></A>are called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">integral types</EM>.<A id=i-1495655539-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The integral types plus<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Float</SPAN><A id=i-1609149804-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN><A id=i-265180023-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>are called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">numeric types</EM>.<A id=i-404482804-1></A></P>
<P><A name=tab:valtypes></A></P>
<H5>Table 5.1 - Some basic types<A id=i608338568-1></A></H5>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Value type</SPAN></SPAN></TD>
<TD style="BORDER-TOP: black thin solid">
<DIV align=center><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Range</SPAN></SPAN></DIV></TD></TR>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Byte</SPAN></SPAN></TD>
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: small">8-bit signed two's complement integer (-2<SUP>7</SUP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to 2<SUP>7</SUP><SPAN class=Apple-converted-space>&nbsp;</SPAN>- 1, inclusive)</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Short</SPAN></SPAN></TD>
<TD><SPAN style="FONT-SIZE: small">16-bit signed two's complement integer (-2<SUP>15</SUP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to 2<SUP>15</SUP><SPAN class=Apple-converted-space>&nbsp;</SPAN>- 1, inclusive)</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN></SPAN></TD>
<TD><SPAN style="FONT-SIZE: small">32-bit signed two's complement integer (-2<SUP>31</SUP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to 2<SUP>31</SUP><SPAN class=Apple-converted-space>&nbsp;</SPAN>- 1, inclusive)</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN></SPAN></TD>
<TD><SPAN style="FONT-SIZE: small">64-bit signed two's complement integer (-2<SUP>63</SUP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to 2<SUP>63</SUP><SPAN class=Apple-converted-space>&nbsp;</SPAN>- 1, inclusive)</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Char</SPAN></SPAN></TD>
<TD><SPAN style="FONT-SIZE: small">16-bit unsigned Unicode character (0 to 2<SUP>16</SUP><SPAN class=Apple-converted-space>&nbsp;</SPAN>- 1, inclusive)</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN></SPAN></TD>
<TD><SPAN style="FONT-SIZE: small">a sequence of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Char</SPAN>s</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Float</SPAN></SPAN></TD>
<TD><SPAN style="FONT-SIZE: small">32-bit IEEE 754 single-precision float</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN></SPAN></TD>
<TD><SPAN style="FONT-SIZE: small">64-bit IEEE 754 double-precision float</SPAN></TD></TR>
<TR class=bottomline style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TD style="BORDER-BOTTOM: black thin solid"><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN></SPAN></TD>
<TD style="BORDER-BOTTOM: black thin solid"><SPAN style="FONT-SIZE: small"><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN></SPAN></TD></TR></TBODY></TABLE>
<P>Other than<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>, which resides in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang</SPAN>, all of the types shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#tab:valtypes">Table 5.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>are members of package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#footnote5-1">[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, the full name of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Int</SPAN>. However, given that all the members of package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are automatically imported into every Scala source file, you can just use the simple names (<I>i.e.</I>, names like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN>,<A id=i1148427104-1></A><SPAN class=code>Char</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><A id=i-1230806839-1></A>) everywhere.</P>
<DIV class=note style="PADDING-RIGHT: 20px; PADDING-LEFT: 20px; PADDING-BOTTOM: 5px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px">
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Note</H4>You can in fact currently use lower case aliases<A id=i-768099765-1></A><A id=i-621629083-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>for Scala value types, which correspond to Java's primitive types. For example, you can say<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in a Scala program. But keep in mind they both mean exactly the same thing:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Int</SPAN>. The recommended style that arose from the experience of the Scala community is to always use the upper case form, which is what we do in this book. In honor of this community-driven choice, the lower case variants may be deprecated or even removed in a future version of Scala, so you would be wise indeed to go with the community flow and say<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>, not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>int</SPAN>, in your Scala code.</DIV>
<P>Savvy Java developers will note that Scala's basic types have the exact same ranges as the corresponding types in Java. This enables the Scala compiler to transform instances of Scala<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g1985162377"><EM style="FONT-STYLE: italic">value types</EM></A>, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>, down to Java primitive types in the bytecodes it produces.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=5.2></A>5.2 Literals<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#5.2">link</A>]</SPAN></H3>
<P><A name=sec:literals></A></P>
<P>All of the basic types listed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#tab:valtypes">Table 5.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be written with<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g182460591"><EM style="FONT-STYLE: italic">literals</EM></A>. A literal is a way to write a constant value directly in code.<A id=i1361311140-1></A></P>
<DIV class=pointofinterest>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Fast track for Java programmers</H3>
<P>The syntax of most literals shown in this section are exactly the same as in Java, so if you're a Java master, you can safely skip much of this section. The two differences you should read about are Scala's literals for raw strings and symbols, which are described starting<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#sec:string-literals">here</A>.</P></DIV>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Integer literals</H4>
<P>Integer literals for the types<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Long</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Short</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Byte</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>come in three forms: decimal, hexadecimal, and octal. The way an integer literal begins indicates the base of the number. If the number begins with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0X</SPAN>, it is hexadecimal (base 16), and may contain<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>through<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>9</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as well as upper or lowercase digits<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>through<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>F</SPAN>. Some examples are:<A id=i-168837784-1></A><A id=i208067142-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;hex&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0x5</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">hex:&nbsp;Int&nbsp;=&nbsp;5</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;hex2&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0x00FF</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">hex2:&nbsp;Int&nbsp;=&nbsp;255</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;magic&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0xcafebabe</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">magic:&nbsp;Int&nbsp;=&nbsp;-889275714</SPAN>
</PRE>
<P>Note that the Scala shell always prints integer values in base 10, no matter what literal form you may have used to initialize it. Thus the interpreter displays the value of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hex2</SPAN>variable you initialized with literal<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0x00FF</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as decimal 255. (Of course, you don't need to take our word for it. A good way to start getting a feel for the language is to try these statements out in the interpreter as you read this chapter.) If the number begins with a zero, it is octal (base 8), and may, therefore, only contain digits<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>through<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>7</SPAN>. Some examples are:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;oct&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">035</SPAN>&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;(35&nbsp;octal&nbsp;is&nbsp;29&nbsp;decimal)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">oct:&nbsp;Int&nbsp;=&nbsp;29</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;nov&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0777</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">nov:&nbsp;Int&nbsp;=&nbsp;511</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;dec&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0321</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">dec:&nbsp;Int&nbsp;=&nbsp;209</SPAN>
</PRE>
<P>If the number begins with a non-zero digit, and is otherwise undecorated, it is decimal (base 10). For example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;dec1&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">31</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">dec1:&nbsp;Int&nbsp;=&nbsp;31</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;dec2&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">255</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">dec2:&nbsp;Int&nbsp;=&nbsp;255</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;dec3&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">20</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">dec3:&nbsp;Int&nbsp;=&nbsp;20</SPAN>
</PRE>
<P>If an integer literal ends in an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>L</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>l</SPAN>, it is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Long</SPAN>, otherwise it is an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>. Some examples of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Long</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>integer literals are:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;prog&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0XCAFEBABEL</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">prog:&nbsp;Long&nbsp;=&nbsp;3405691582</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;tower&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">35L</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">tower:&nbsp;Long&nbsp;=&nbsp;35</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;of&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">31l</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">of:&nbsp;Long&nbsp;=&nbsp;31</SPAN>
</PRE>
<P>If an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>literal is assigned to a variable of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Short</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Byte</SPAN>, the literal is treated as if it were a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Short</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Byte</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type so long as the literal value is within the valid range for that type. For example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;little:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Short</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">367</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">little:&nbsp;Short&nbsp;=&nbsp;367</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;littler:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Byte</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">38</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">littler:&nbsp;Byte&nbsp;=&nbsp;38</SPAN>
</PRE>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Floating point literals</H4>
<P>Floating point literals are made up of decimal digits, optionally containing a decimal point, and optionally followed by an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>E</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and an exponent. Some examples of floating-point literals are:<A id=i1661236620-1></A><A id=i2064554715-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;big&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.2345</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">big:&nbsp;Double&nbsp;=&nbsp;1.2345</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bigger&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.2345e1</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">bigger:&nbsp;Double&nbsp;=&nbsp;12.345</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;biggerStill&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">123E45</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">biggerStill:&nbsp;Double&nbsp;=&nbsp;1.23E47</SPAN>
</PRE>
<P>Note that the exponent portion means the power of 10 by which the other portion is multiplied. Thus, 1.2345e1 is 1.2345<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>times</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>10<SUP>1</SUP>, which is 12.345. If a floating-point literal ends in an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>F</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN>, it is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Float</SPAN>, otherwise it is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>. Optionally, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>floating-point literal can end in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>D</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>d</SPAN>. Some examples of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Float</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>literals are:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;little&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.2345F</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">little:&nbsp;Float&nbsp;=&nbsp;1.2345</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;littleBigger&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3e5f</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">littleBigger:&nbsp;Float&nbsp;=&nbsp;300000.0</SPAN>
</PRE>
<P>That last value expressed as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>could take these (and other) forms:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;anotherDouble&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3e5</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">anotherDouble:&nbsp;Double&nbsp;=&nbsp;300000.0</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;yetAnother&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3e5D</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">yetAnother:&nbsp;Double&nbsp;=&nbsp;300000.0</SPAN>
</PRE>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Character literals</H4>
<P>Character literals are composed of any Unicode character between single quotes, such as:<A id=i1377637053-1></A><A id=i2027394259-1></A><A id=i-197420869-1></A><A id=i-2096980664-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;a&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'A'</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">a:&nbsp;Char&nbsp;=&nbsp;A</SPAN>
</PRE>
<P>In addition to providing an explicit character between the single quotes, you can provide an octal or hex number for the character code point preceded by a backslash. The octal number must be between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>'\0'</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>'\377'</SPAN>. For example, the Unicode character code point for the letter A is 101 octal. Thus:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;c&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'\101'</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">c:&nbsp;Char&nbsp;=&nbsp;A</SPAN>
</PRE>
<P>A character literal can also be given as a general Unicode character consisting of four hex digits and preceded by a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\u</SPAN>, as in:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;d&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'\u0041'</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">d:&nbsp;Char&nbsp;=&nbsp;A</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;f&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'\u0044'</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">f:&nbsp;Char&nbsp;=&nbsp;D</SPAN>
</PRE>In fact, such Unicode characters can appear anywhere in a Scala program. For instance you could also write an identifier like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;B\u0041\u0044&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">BAD:&nbsp;Int&nbsp;=&nbsp;1</SPAN>
</PRE>This identifier is treated as identical to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BAD</SPAN>, the result of expanding the two Unicode characters in the code above. In general, it is a bad idea to name identifiers like this, because it is hard to read. Rather, this syntax is intended to allow Scala source files that include non-ASCII Unicode characters to be represented in ASCII. 
<P>Finally, there are also a few character literals represented by special escape sequences, shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#tab:specchar">Table 5.2</A>. For example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;backslash&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'\\'</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">backslash:&nbsp;Char&nbsp;=&nbsp;\</SPAN>
</PRE>
<P></P>
<P><A name=tab:specchar></A></P>
<H5>Table 5.2 - Special character literal escape sequences<A id=i-1682237230-1></A><A id=i576133849-1></A></H5>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Literal</SPAN></SPAN></TD>
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Meaning</SPAN></SPAN></TD></TR>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN class=code>\n</SPAN></TD>
<TD style="BORDER-TOP: black thin solid">line feed (<SPAN class=code>\u000A</SPAN>)</TD></TR>
<TR class="">
<TD><SPAN class=code>\b</SPAN></TD>
<TD>backspace (<SPAN class=code>\u0008</SPAN>)</TD></TR>
<TR class="">
<TD><SPAN class=code>\t</SPAN></TD>
<TD>tab (<SPAN class=code>\u0009</SPAN>)</TD></TR>
<TR class="">
<TD><SPAN class=code>\f</SPAN></TD>
<TD>form feed (<SPAN class=code>\u000C</SPAN>)</TD></TR>
<TR class="">
<TD><SPAN class=code>\r</SPAN></TD>
<TD>carriage return (<SPAN class=code>\u000D</SPAN>)</TD></TR>
<TR class="">
<TD><SPAN class=code>\"</SPAN></TD>
<TD>double quote (<SPAN class=code>\u0022</SPAN>)</TD></TR>
<TR class="">
<TD><SPAN class=code>\'</SPAN></TD>
<TD>single quote (<SPAN class=code>\u0027</SPAN>)</TD></TR>
<TR class=bottomline style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TD style="BORDER-BOTTOM: black thin solid"><SPAN class=code>\\</SPAN></TD>
<TD style="BORDER-BOTTOM: black thin solid">backslash (<SPAN class=code>\u005C</SPAN>)</TD></TR></TBODY></TABLE></DIV>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">String literals</H4>
<P><A name=sec:string-literals></A></P>
<P>A string literal is composed of characters surrounded by double quotes:<A id=i-2068973913-1></A><A id=i1483927337-1></A><A id=i1349528476-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;hello&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">hello:&nbsp;java.lang.String&nbsp;=&nbsp;hello</SPAN>
</PRE>The syntax of the characters within the quotes is the same as with character literals. For example:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;escapes&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"\\\"\'"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">escapes:&nbsp;java.lang.String&nbsp;=&nbsp;\"'</SPAN>
</PRE>
<P></P>
<P>Because this syntax is awkward for strings that contain a lot of escape sequences or strings that span multiple lines, Scala includes a special syntax for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">raw strings</SPAN>.<A id=i-1493588176-1></A><A id=i1433882250-1></A><A id=i943241332-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You start and end a raw string with three double quotation marks in a row (<SPAN class=code>"""</SPAN>). The interior of a raw string may contain any characters whatsoever, including newlines, quotation marks, and special characters, except of course three quotes in a row. For example, the following program prints out a message using a raw string:<A id=i-1356616527-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"""Welcome&nbsp;to&nbsp;Ultamix&nbsp;3000.</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">Type&nbsp;"HELP"&nbsp;for&nbsp;help."""</SPAN>)
</PRE>Running this code does not produce quite what is desired, however: 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Welcome&nbsp;to&nbsp;Ultamix&nbsp;3000.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;"HELP"&nbsp;for&nbsp;help.</SPAN>
</PRE>The issue is that the leading spaces before the second line are included in the string! To help with this common situation, you can call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stripMargin</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on strings.<A id=i-696378315-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>To use this method, put a pipe character (<SPAN class=code>|</SPAN>) at the front of each line, and then call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stripMargin</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the whole string:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"""|Welcome&nbsp;to&nbsp;Ultamix&nbsp;3000.</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">|Type&nbsp;"HELP"&nbsp;for&nbsp;help."""</SPAN>.stripMargin)
</PRE>Now the code behaves as desired:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Welcome&nbsp;to&nbsp;Ultamix&nbsp;3000.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Type&nbsp;"HELP"&nbsp;for&nbsp;help.</SPAN>
</PRE>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Symbol literals</H4>
<P>A symbol literal is written<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>'</SPAN><EM style="FONT-STYLE: italic">ident</EM>, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">ident</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be any alphanumeric identifier. Such literals are mapped to instances of the predefined class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Symbol</SPAN>. Specifically, the literal<SPAN class=code>'cymbal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be expanded by the compiler to a factory method invocation:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Symbol("cymbal")</SPAN>. Symbol literals are typically used in situations where you would use just an identifier in a dynamically<A id=i2012339474-4></A><A id=i716433724-4></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>typed language.<A id=i-2064511954-1></A><A id=i386345772-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For instance, you might want to define a method that updates a record in a database:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;updateRecordByName(r:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Symbol</SPAN>,&nbsp;value:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;code&nbsp;goes&nbsp;here</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">updateRecordByName:&nbsp;(Symbol,Any)Unit</SPAN>
</PRE>The method takes as parameters a symbol indicating the name of a record field and a value with which the field should be updated in the record. In a dynamically typed language, you could invoke this operation passing an undeclared field identifier to the method, but in Scala this would not compile:<A id=i138103638-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;updateRecordByName(favoriteAlbum,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"OK&nbsp;Computer"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:6:&nbsp;error:&nbsp;not&nbsp;found:&nbsp;value&nbsp;favoriteAlbum</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateRecordByName(favoriteAlbum,&nbsp;"OK&nbsp;Computer")</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^&nbsp;&nbsp;</SPAN>
</PRE>
<P></P>
<P>Instead, and almost as concisely, you can pass a symbol literal:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;updateRecordByName(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'favoriteAlbum</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"OK&nbsp;Computer"</SPAN>)
</PRE>There is not much you can do with a symbol, except find out its name:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;s&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'aSymbol</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">s:&nbsp;Symbol&nbsp;=&nbsp;'aSymbol</SPAN>
  <BR>  scala&gt;&nbsp;s.name
  <SPAN class=output style="COLOR: rgb(90,0,0)">res20:&nbsp;String&nbsp;=&nbsp;aSymbol</SPAN>
</PRE>Another thing that's noteworthy is that symbols are<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">interned</SPAN>. If you write the same symbol literal twice, both expressions will refer to the exact same<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Symbol</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Boolean literals</H4>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type has two literals,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>:<A id=i-2062178222-1></A><A id=i594122396-1></A><A id=i907417652-1></A><A id=i1304901727-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bool&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">bool:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;fool&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">fool:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>
<P>That's all there is to it. You are now literally<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#footnote5-2">[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>an expert in Scala.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=5.3></A>5.3 Operators are methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#5.3">link</A>]</SPAN></H3>
<P><A name=sec:operators></A></P>
<P>Scala provides a rich set of operators for its basic types. As mentioned in previous chapters, these operators are actually just a nice syntax for ordinary method calls. For example,<SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>really means the same thing as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(1).+(2)</SPAN>.<A id=i-614149608-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In other words, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that takes an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and returns an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>result. This<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is invoked when you add two<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>s:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;sum&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Scala&nbsp;invokes&nbsp;(1).+(2)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">sum:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
</PRE>
<P>To prove this to yourself, you can<SPAN class=Apple-converted-space>&nbsp;</SPAN>write the expression explicitly as a method invocation:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;sumMore&nbsp;=&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>).+(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">sumMore:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
</PRE>
<P>In fact,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains several<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">overloaded</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods that take different parameter types.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#footnote5-3">[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has another method, also named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>, that takes and returns a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Long</SPAN>. If you add a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Long</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>, this alternate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method will be invoked, as in:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;longSum&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2L</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Scala&nbsp;invokes&nbsp;(1).+(2L)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">longSum:&nbsp;Long&nbsp;=&nbsp;3</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>symbol is an operator&#8212;an infix operator to be specific.<A id=i145517742-1></A><A id=i-74898194-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Operator notation is not limited to methods like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that look like operators in other languages. You can use<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">any</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in operator notation.<A id=i-1126677335-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has a method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>indexOf</SPAN>, that takes one<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Char</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>indexOf</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method searches the string for the first occurrence of the specified character, and returns its index or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if it doesn't find the character. You can use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>indexOf</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an operator, like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;s&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello,&nbsp;world!"</SPAN>&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">s:&nbsp;java.lang.String&nbsp;=&nbsp;Hello,&nbsp;world!</SPAN>
  <BR>  scala&gt;&nbsp;s&nbsp;indexOf&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'o'</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Scala&nbsp;invokes&nbsp;s.indexOf('o')</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;Int&nbsp;=&nbsp;4</SPAN>
</PRE>
<P>In addition,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>offers an overloaded<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>indexOf</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that takes two parameters, the character for which to search and an index at which to start. (The other<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>indexOf</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, shown previously, starts at index zero, the beginning of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>.) Even though this<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>indexOf</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method takes two arguments, you can use it in operator notation. But whenever you call a method that takes multiple arguments using operator notation, you have to place those arguments in parentheses. For example, here's how you use this other<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>indexOf</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>form as an operator (continuing from the previous example):</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;s&nbsp;indexOf&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'o'</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Scala&nbsp;invokes&nbsp;s.indexOf('o',&nbsp;5)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;Int&nbsp;=&nbsp;8</SPAN>
</PRE>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Any method can be an operator</H3>
<P>In Scala operators are not special language syntax: any method can be an operator. What makes a method an operator is how you<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">use</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>it. When you write "<SPAN class=code>s.indexOf('o')</SPAN>",<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>indexOf</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not an operator. But when you write "<SPAN class=code>s</SPAN>&nbsp;<SPAN class=code>indexOf</SPAN>&nbsp;<SPAN class=code>'o'</SPAN>",<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>indexOf</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">is</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>an operator, because you're using it in operator notation.</P></DIV>
<P>So far, you've seen examples of<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">infix</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator notation, which means the method to invoke sits between the object and the parameter or parameters you wish to pass to the method, as in "<SPAN class=code>7</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>2</SPAN>". Scala also has two other operator notations: prefix and postfix. In prefix notation, you put the method name before the object on which you are invoking the method, for example, the `<SPAN class=code>-</SPAN>' in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-7</SPAN>. In postfix notation, you put the method after the object, for example, the "<SPAN class=code>toLong</SPAN>" in "<SPAN class=code>7</SPAN>&nbsp;<SPAN class=code>toLong</SPAN>".</P>
<P>In contrast to the infix operator notation&#8212;in which operators take two operands, one to the left and the other to the right&#8212;prefix and postfix operators are<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">unary</EM>: they take just one operand.<A id=i-1088310403-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In prefix notation, the operand is to the right of the operator.<A id=i711311856-1></A><A id=i-2117778892-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Some examples of prefix operators are<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-2.0</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>!found</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN>0xFF</SPAN>. As with the infix operators, these prefix operators are a shorthand way of invoking methods. In this case, however, the name of the method has "<SPAN class=code>unary_</SPAN>" prepended to the operator character. For instance, Scala will transform the expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-2.0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into the method invocation "<SPAN class=code>(2.0).unary_-</SPAN>". You can demonstrate this to yourself by typing the method call both via operator notation and explicitly:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">2.0</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Scala&nbsp;invokes&nbsp;(2.0).unary_-</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;Double&nbsp;=&nbsp;-2.0</SPAN>
  <BR>  scala&gt;&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">2.0</SPAN>).unary_-
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;Double&nbsp;=&nbsp;-2.0</SPAN>
</PRE>
<P>The only identifiers that can be used as prefix operators are<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>!</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>. Thus, if you define a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unary_!</SPAN>, you could invoke that method on a value or variable of the appropriate type using prefix operator notation, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>!p</SPAN>. But if you define a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unary_*</SPAN>, you wouldn't be able to use prefix operator notation, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>isn't one of the four identifiers that can be used as prefix operators. You could invoke the method normally, as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p.unary_*</SPAN>, but if you attempted to invoke it via<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*p</SPAN>, Scala will parse it as if you'd written<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*.p</SPAN>, which is probably not what you had in mind!<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#footnote5-4">[4]</A></P>
<P>Postfix operators are methods that take no arguments, when they are invoked without a dot or parentheses. In Scala, you can leave off empty parentheses on method calls.<A id=i-1718164274-1></A><A id=i1976561855-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The convention is that you include parentheses if the method has side effects, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println()</SPAN>, but you can leave them off if the method has no side effects, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toLowerCase</SPAN>invoked on a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;s&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello,&nbsp;world!"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">s:&nbsp;java.lang.String&nbsp;=&nbsp;Hello,&nbsp;world!</SPAN>
  <BR>  scala&gt;&nbsp;s.toLowerCase&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;java.lang.String&nbsp;=&nbsp;hello,&nbsp;world!</SPAN>
</PRE>
<P>In this latter case of a method that requires no arguments, you can alternatively leave off the dot and use postfix operator notation:<A id=i797797395-1></A><A id=i-1299180525-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;s&nbsp;toLowerCase
  <SPAN class=output style="COLOR: rgb(90,0,0)">res5:&nbsp;java.lang.String&nbsp;=&nbsp;hello,&nbsp;world!</SPAN>
</PRE>
<P>In this case,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toLowerCase</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used as a postfix operator on the operand<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s</SPAN>.</P>
<P>To see what operators you can use with Scala's basic types, therefore, all you really need to do is look at the methods declared in the type's classes in the Scala API documentation. Given that this is a Scala tutorial, however, we'll give you a quick tour of most of these methods in the next few sections.</P>
<DIV class=pointofinterest>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Fast track for Java programmers</H3>
<P>Many aspects of Scala described in the remainder of this chapter are the same as in Java. If you're a Java guru in a rush, you can safely skip to<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#sec:equality">Section 5.7</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#sec:equality">here</A>, which describes how Scala differs from Java in the area of object equality.</P></DIV>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=5.4></A>5.4 Arithmetic operations<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#5.4">link</A>]</SPAN></H3>
<P>You can invoke arithmetic methods via infix operator notation for<A id=i63774984-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>addition (<SPAN class=code>+</SPAN>),<A id=i983413923-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>subtraction (<SPAN class=code>-</SPAN>)<A id=i716347441-1></A>, multiplication (<SPAN class=code>*</SPAN>)<A id=i-1513393110-1></A>, division (<SPAN class=code>/</SPAN>)<A id=i1085968089-1></A>, and remainder (<SPAN class=code>%</SPAN>)<A id=i277713802-1></A>, on any numeric type. Here are some examples:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.2</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2.3</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res6:&nbsp;Double&nbsp;=&nbsp;3.5</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>&nbsp;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res7:&nbsp;Int&nbsp;=&nbsp;2</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'b'</SPAN>&nbsp;-&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'a'</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res8:&nbsp;Int&nbsp;=&nbsp;1</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2L</SPAN>&nbsp;*&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3L</SPAN>&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res9:&nbsp;Long&nbsp;=&nbsp;6</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">11</SPAN>&nbsp;/&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res10:&nbsp;Int&nbsp;=&nbsp;2</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">11</SPAN>&nbsp;%&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res11:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">11.0f</SPAN>&nbsp;/&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4.0f</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res12:&nbsp;Float&nbsp;=&nbsp;2.75</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">11.0</SPAN>&nbsp;%&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4.0</SPAN>&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res13:&nbsp;Double&nbsp;=&nbsp;3.0</SPAN>
</PRE>
<P>When both the left and right operands are integral types (<SPAN class=code>Int</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Long</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Byte</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Short</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Char</SPAN>), the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>/</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator will tell you the whole number portion of the quotient, excluding any remainder. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>%</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator indicates the remainder of an implied integer division.</P>
<P>The floating-point remainder you get with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>%</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not the one defined by the IEEE 754 standard. The IEEE 754 remainder uses rounding division, not truncating division, in calculating the remainder, so it is quite different from the integer remainder operation. If you really want an IEEE 754 remainder, you can call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>IEEEremainder</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Math</SPAN>, as in:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;Math.IEEEremainder(<SPAN class=literal style="COLOR: rgb(205,123,0)">11.0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4.0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res14:&nbsp;Double&nbsp;=&nbsp;-1.0</SPAN>
</PRE>
<P>The numeric types also offer unary prefix operators<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unary_+</SPAN>) and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unary_-</SPAN>), which allow you to indicate a literal number is positive or negative, as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-3</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+4.0</SPAN>. If you don't specify a unary<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN>, a literal number is interpreted as positive. Unary<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>exists solely for symmetry with unary<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN>, but has no effect. The unary<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can also be used to negate a variable. Here are some examples:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;neg&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;+&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">neg:&nbsp;Int&nbsp;=&nbsp;-2</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;y&nbsp;=&nbsp;+<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">y:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
  <BR>  scala&gt;&nbsp;-neg
  <SPAN class=output style="COLOR: rgb(90,0,0)">res15:&nbsp;Int&nbsp;=&nbsp;2</SPAN>
</PRE>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=5.5></A>5.5 Relational and logical operations<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#5.5">link</A>]</SPAN></H3>
<P>You can compare numeric types with relational methods greater than<A id=i-1517365894-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<SPAN class=code>&gt;</SPAN>)<A id=i1603867875-1></A>, less than (<SPAN class=code>&lt;</SPAN>)<A id=i1911627354-1></A>, greater than or equal to (<SPAN class=code>&gt;=</SPAN>)<A id=i-1287376184-1></A>, and less than or equal to (<SPAN class=code>&lt;=</SPAN>)<A id=i-299474407-1></A>, which yield a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>result. In addition, you can use the unary `<SPAN class=code>!</SPAN>' operator (the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unary_!</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method) to invert a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>value.<A id=i1211007643-1></A><A id=i1148427104-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Here are a few examples:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res16:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;&lt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res17:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.0</SPAN>&nbsp;&lt;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.0</SPAN>&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res18:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3.5f</SPAN>&nbsp;&gt;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3.6f</SPAN>&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res19:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'a'</SPAN>&nbsp;&gt;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'A'</SPAN>&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res20:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;thisIsBoring&nbsp;=&nbsp;!<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">thisIsBoring:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;!thisIsBoring&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res21:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>
<P>The logical methods, logical-and (<SPAN class=code>&amp;&amp;</SPAN>) and logical-or (<SPAN class=code>||</SPAN>), take<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operands in infix notation<A id=i-206208280-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and yield a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>result. For example:<A id=i-1437722857-1></A><A id=i-893626619-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;toBe&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">toBe:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;question&nbsp;=&nbsp;toBe&nbsp;||&nbsp;!toBe
  <SPAN class=output style="COLOR: rgb(90,0,0)">question:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;paradox&nbsp;=&nbsp;toBe&nbsp;&amp;&amp;&nbsp;!toBe
  <SPAN class=output style="COLOR: rgb(90,0,0)">paradox:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>
<P>The logical-and and logical-or operations are<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">short-circuited</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>as in Java: expressions<A id=i682407483-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>built from these operators are only evaluated as far as needed to determine the result. In other words, the right-hand side of logical-and and logical-or expressions won't be evaluated if the left-hand side determines the result. For example, if the left-hand side of a logical-and expression evaluates to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>, the result of the expression will definitely be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>, so the right-hand side is not evaluated. Likewise, if the left-hand side of a logical-or expression evaluates to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>, the result of the expression will definitely be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>, so the right-hand side is not evaluated. For example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;salt()&nbsp;=&nbsp;{&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"salt"</SPAN>);&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">salt:&nbsp;()Boolean</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;pepper()&nbsp;=&nbsp;{&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"pepper"</SPAN>);&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">pepper:&nbsp;()Boolean</SPAN>
  <BR>  scala&gt;&nbsp;pepper()&nbsp;&amp;&amp;&nbsp;salt()
  <SPAN class=output style="COLOR: rgb(90,0,0)">pepper</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">salt</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res22:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;salt()&nbsp;&amp;&amp;&nbsp;pepper()&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">salt</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res23:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>In the first expression,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pepper</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>salt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are invoked, but in the second, only<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>salt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is invoked. Given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>salt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>, there's no need to call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pepper</SPAN>. 
<P></P>
<DIV class=note style="PADDING-RIGHT: 20px; PADDING-LEFT: 20px; PADDING-BOTTOM: 5px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px">
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Note</H4>
<P>You may be wondering how short-circuiting can work given operators are just methods. Normally, all arguments are evaluated before entering a method, so how can a method avoid evaluating its second argument? The answer is that all Scala methods have a facility for delaying the evaluation of their arguments, or even declining to evaluate them at all. The facility is called<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-1173919606"><EM style="FONT-STYLE: italic">by-name parameters</EM></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and is discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#sec:by-name-parameters">Section 9.5</A>.</P></DIV>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=5.6></A>5.6 Bitwise operations<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#5.6">link</A>]</SPAN></H3>
<P>Scala enables you to perform operations on individual bits of integer types with several bitwise methods.<A id=i-1867892596-1></A><A id=i-169049836-1></A><A id=i608439332-1></A><A id=i-788169784-1></A><A id=i1085931200-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The bitwise methods are: bitwise-and (<SPAN class=code>&amp;</SPAN>), bitwise-or (<SPAN class=code>|</SPAN>), and bitwise-xor (<SPAN class=code>^</SPAN>).<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#footnote5-5">[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The unary bitwise complement operator (<SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>, the method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unary_<SPAN style="FONT-SIZE: large">~</SPAN></SPAN>), inverts each bit in its operand. For example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;&amp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res24:&nbsp;Int&nbsp;=&nbsp;0</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;|&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res25:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;^&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res26:&nbsp;Int&nbsp;=&nbsp;2</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res27:&nbsp;Int&nbsp;=&nbsp;-2</SPAN>
</PRE>The first expression,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>&amp;</SPAN>&nbsp;<SPAN class=code>2</SPAN>, bitwise-ands each bit in 1 (0001) and 2 (0010), which yields 0 (0000). The second expression,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>|</SPAN>&nbsp;<SPAN class=code>2</SPAN>, bitwise-ors each bit in the same operands, yielding 3 (0011). The third expression,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>^</SPAN>&nbsp;<SPAN class=code>3</SPAN>, bitwise-xors each bit in 1 (0001) and 3 (0011), yielding 2 (0010). The final expression,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN>1</SPAN>, inverts each bit in 1 (0001), yielding -2, which in binary looks like 11111111111111111111111111111110. 
<P>Scala integer types also offer three shift methods: shift left (<SPAN class=code>&lt;&lt;</SPAN>), shift right (<SPAN class=code>&gt;&gt;</SPAN>), and<A id=i-1251371832-1></A><A id=i-1409237921-1></A><A id=i472230236-1></A><A id=i-365724318-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>unsigned shift right (<SPAN class=code>&gt;&gt;&gt;</SPAN>). The shift methods, when used in infix operator notation, shift the integer value on the left of the operator by the amount specified by the integer value on the right. Shift left and unsigned shift right fill with zeroes as they shift. Shift right fills with the highest bit (the sign bit) of the left-hand value as it shifts. Here are some examples:<A id=i1037331510-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;&gt;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">31</SPAN>&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res28:&nbsp;Int&nbsp;=&nbsp;-1</SPAN>
  <BR>  scala&gt;&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;&gt;&gt;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">31</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res29:&nbsp;Int&nbsp;=&nbsp;1</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;&lt;&lt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res30:&nbsp;Int&nbsp;=&nbsp;4</SPAN>
</PRE>
<P>-1 in binary is 11111111111111111111111111111111. In the first example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-1</SPAN>&nbsp;<SPAN class=code>&gt;&gt;</SPAN>&nbsp;<SPAN class=code>31</SPAN>, -1 is shifted to the right 31 bit positions. Since an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>consists of 32 bits, this operation effectively moves the leftmost bit over until it becomes the rightmost bit.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#footnote5-6">[6]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Since the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method fills with ones as it shifts right, because the leftmost bit of -1 is 1, the result is identical to the original left operand, 32 one bits, or -1. In the second example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-1</SPAN>&nbsp;<SPAN class=code>&gt;&gt;&gt;</SPAN>&nbsp;<SPAN class=code>31</SPAN>, the leftmost bit is again shifted right until it is in the rightmost position, but this time filling with zeroes along the way. Thus the result this time is binary 00000000000000000000000000000001, or 1. In the final example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>&lt;&lt;</SPAN>&nbsp;<SPAN class=code>2</SPAN>, the left operand, 1, is shifted left two positions (filling in with zeroes), resulting in binary 00000000000000000000000000000100, or 4.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=5.7></A>5.7 Object equality<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#5.7">link</A>]</SPAN></H3>
<P><A name=sec:equality></A></P>
<P>If you want to compare two objects for equality, you can use either<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN>, or its inverse<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>!=</SPAN>.<A id=i46092869-1></A><A id=i307189229-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Here are a few simple examples:<A id=i-1583721442-1></A><A id=i1095465388-1></A><A id=i15383763-1></A><A id=i-1108611945-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res31:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;!=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res32:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res33:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>These operations actually apply to all objects, not just basic types. For example, you can use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to compare lists:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)&nbsp;==&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res34:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)&nbsp;==&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">6</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res35:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>Going further, you can compare two objects that have different types:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.0</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res36:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)&nbsp;==&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res37:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>You can even compare against<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN>, or against things that might be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN>. No exception will be thrown:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)&nbsp;==&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">null</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res38:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">null</SPAN>&nbsp;==&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res39:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>
<P></P>
<P>As you see,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has been carefully crafted so that you get just the equality comparison you want in most cases. This is accomplished with a very simple rule: first check the left side for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN>, and if it is not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN>, call the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.<A id=i-342464093-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a method, the precise comparison you get depends on the type of the left-hand argument. Since there is an automatic null check, you do not have to do the check yourself.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#footnote5-7">[7]</A></P>
<P>This kind of comparison will yield<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on different objects, so long as their contents are the same and their<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is written to be based on contents. For example, here is a comparison between two strings that happen to have the same five letters in them:<A id=i307189229-2></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"he"</SPAN>+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"llo"</SPAN>)&nbsp;==&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res40:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>
<P></P>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">How Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>differs from Java's</H3>
<P>In Java, you can use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to compare both primitive<A id=i-383144457-1></A><A id=i1422354335-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and reference types. On primitive types, Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>compares value equality,<A id=i1877185224-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>as in Scala. On reference types, however, Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>compares<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g1293228591"><EM style="FONT-STYLE: italic">reference equality</EM></A>, which means the two variables point to the same object on the JVM's heap. Scala provides a facility for comparing reference equality, as well, under the name<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eq</SPAN>. However,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and its opposite,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ne</SPAN>, only apply to objects that directly map to Java objects. The full details about<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=code>ne</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are given in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scalas-hierarchy.html#sec:scalas-class-hierarchy">Sections 11.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scalas-hierarchy.html#sec:impl-primitives"><SPAN class=Apple-converted-space>&nbsp;</SPAN>11.2</A>. Also, see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html">Chapter 28</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>on how to write a good<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.<A id=i-795280463-1></A><A id=i2030434891-1></A><A id=i-1620977796-1></A><A id=i1319501024-1></A><A id=i1544052809-1></A></P></DIV>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=5.8></A>5.8 Operator precedence and associativity<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#5.8">link</A>]</SPAN></H3>
<P><A name=sec:precedence></A></P>
<P>Operator precedence determines which parts of an expression are evaluated before the other parts. For example, the expression<A id=i1955596960-1></A><A id=i2084616098-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>7</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>evaluates to 16, not 28, because the * operator has a higher precedence than the + operator. Thus the multiplication<SPAN class=Apple-converted-space>&nbsp;</SPAN>part of the expression is evaluated before the addition<SPAN class=Apple-converted-space>&nbsp;</SPAN>part. You can of course use parentheses in expressions to clarify evaluation order or to override precedence. For example, if you really wanted the result of the expression above to be 28, you could write the expression like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  (<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)&nbsp;*&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">7</SPAN>
</PRE>
<P>Given that Scala doesn't have operators, per se, just a way to use methods in operator notation, you may be wondering how operator precedence works. Scala decides precedence based on the first character of the methods used in operator notation (there's one exception to this rule, which will be discussed below). If the method name starts with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN>, for example, it will have a higher precedence than a method that starts with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>. Thus<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>7</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be evaluated as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>(2</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>7)</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>+++</SPAN>&nbsp;<SPAN class=code>b</SPAN>&nbsp;<SPAN class=code>***</SPAN>&nbsp;<SPAN class=code>c</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(in which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>c</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are variables, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+++</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>***</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are methods) will be evaluated<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>+++</SPAN>&nbsp;<SPAN class=code>(b</SPAN>&nbsp;<SPAN class=code>***</SPAN>&nbsp;<SPAN class=code>c)</SPAN>, because the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>***</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method has a higher precedence than the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+++</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.</P>
<P><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#tab:opprec">Table 5.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#tab:opprec">here</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows the precedence given to the first character of a method in decreasing order of precedence, with characters on the same line having the same precedence. The higher a character is in this table, the higher the precedence of methods that start with that character. Here's an example that illustrates the influence of precedence:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;&lt;&lt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res41:&nbsp;Int&nbsp;=&nbsp;32</SPAN>
</PRE>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;&lt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method starts with the character<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;</SPAN>, which appears lower in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#tab:opprec">Table 5.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>than the character<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>, which is the first and only character of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. Thus<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;&lt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will have lower precedence than<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>, and the expression will be evaluated by first invoking the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, then the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;&lt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>&lt;&lt;</SPAN>&nbsp;<SPAN class=code>(2</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>2)</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>4</SPAN>, by our math, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>&lt;&lt;</SPAN>&nbsp;<SPAN class=code>4</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>yields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>32</SPAN>. Here's another example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;&lt;&lt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res42:&nbsp;Int&nbsp;=&nbsp;16</SPAN>
</PRE>
<P>Since the first characters are the same as in the previous example, the methods will be invoked in the same order. First the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method will be invoked, then the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;&lt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. So<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>2</SPAN>will again yield<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>4</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>4</SPAN>&nbsp;<SPAN class=code>&lt;&lt;</SPAN>&nbsp;<SPAN class=code>2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is 16.</P>
<P><A name=tab:opprec></A></P>
<H5>Table 5.3 - Operator precedence<A id=i-1002965951-1></A><A id=i-1679614205-1></A></H5>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid">(all other special characters)</TD></TR>
<TR class="">
<TD><SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>%</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>-</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>:</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>=</SPAN>&nbsp;<SPAN class=code>!</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>&lt;</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>&amp;</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>^</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>|</SPAN></TD></TR>
<TR class="">
<TD>(all letters)</TD></TR>
<TR class=bottomline style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TD style="BORDER-BOTTOM: black thin solid">(all assignment operators)</TD></TR></TBODY></TABLE></DIV>
<P>The one exception to the precedence rule, alluded to above, concerns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">assignment operators</SPAN>, which end in an equals character. If an operator ends in an equals character<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(=)</SPAN>, and the operator is not one of the comparison operators<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;=</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;=</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>!=</SPAN>, then the precedence of the operator is the same as that of simple assignment<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(=)</SPAN>. That is, it is lower than the precedence of any other operator. For instance:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  x&nbsp;*=&nbsp;y&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
</PRE>means the same as:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  x&nbsp;*=&nbsp;(y&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
</PRE>because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is classified as an assignment operator whose precedence is lower than<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>, even though the operator's first character is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN>, which would suggest a precedence higher than<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>. 
<P></P>
<P>When multiple operators of the same precedence appear side by side in an expression, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">associativity</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the operators<A id=i1109054020-1></A><A id=i1812392602-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>determines the way operators are grouped. The associativity of an operator in Scala is determined by its<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">last</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>character. As mentioned<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#note:colonmethod">here</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html">Chapter 3</A>, any method that ends in a `<SPAN class=code>:</SPAN>' character is invoked on its right operand, passing in the left operand. Methods that end in any other character are the other way around. They are invoked on their left operand, passing in the right operand. So<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>b</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>yields<SPAN class=code>a.*(b)</SPAN>, but<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>:::</SPAN>&nbsp;<SPAN class=code>b</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>yields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b.:::(a)</SPAN>.<A id=i-1085593547-2></A></P>
<P>No matter what associativity an operator has, however, its operands are always evaluated left to right. So if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an expression that is not just a simple reference to an immutable value, then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>:::</SPAN>&nbsp;<SPAN class=code>b</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is more precisely treated as the following block:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  {&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x&nbsp;=&nbsp;a;&nbsp;b.:::(x)&nbsp;}
</PRE>In this block<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is still evaluated before<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b</SPAN>, and then the result of this evaluation is passed as an operand to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. 
<P></P>
<P>This associativity rule also plays a role when multiple operators of the same precedence appear side by side. If the methods end in `<SPAN class=code>:</SPAN>', they are grouped right to left; otherwise, they are grouped left to right. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>:::</SPAN>&nbsp;<SPAN class=code>b</SPAN>&nbsp;<SPAN class=code>:::</SPAN>&nbsp;<SPAN class=code>c</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is treated as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>:::</SPAN>&nbsp;<SPAN class=code>(b</SPAN>&nbsp;<SPAN class=code>:::</SPAN>&nbsp;<SPAN class=code>c)</SPAN>. But<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>b</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>c</SPAN>, by contrast, is treated as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(a</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>b)</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>c</SPAN>.</P>
<P>Operator precedence is part of the Scala language. You needn't be afraid to use it. Nevertheless, it is good style to use parentheses to clarify what operators are operating upon what expressions. Perhaps the only precedence you can truly count on other programmers knowing without looking up is that multiplicative operators,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>/</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>%</SPAN>, have a higher precedence than the additive ones<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN>. Thus even if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>b</SPAN>&nbsp;<SPAN class=code>&lt;&lt;</SPAN>&nbsp;<SPAN class=code>c</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>yields the result you want without parentheses, the extra clarity you get by writing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(a</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>b)</SPAN>&nbsp;<SPAN class=code>&lt;&lt;</SPAN>&nbsp;<SPAN class=code>c</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>may reduce the frequency with which your peers utter your name in operator notation, for example, by shouting in disgust, "<SPAN class=code>bills</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>!*&amp;^%<SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>code!</SPAN>".<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#footnote5-8">[8]</A></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=5.9></A>5.9 Rich wrappers<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#5.9">link</A>]</SPAN></H3>
<P><A name=sec:rich-wrappers></A></P>
<P>You can invoke many more methods on Scala's basic types than were described in the previous sections. A few examples are shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#tab:richops">Table 5.4</A>. These methods are available via<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">implicit conversions</EM>, a technique that will be described in detail in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html">Chapter 21</A>.<A id=i-108634082-1></A><A id=i681737575-1></A><A id=i807731316-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>All you need to know for now is that for each basic type described in this chapter, there is also a "rich wrapper" that provides several additional methods. To see all the available methods on the basic types, therefore, you should look at the API documentation on the rich wrapper for each basic type. Those classes are listed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#tab:richclasses">Table 5.5</A>.</P>
<P><A name=tab:richops></A></P>
<H5>Table 5.4 - Some rich operations<A id=i-256644535-2></A><A id=i-2103371977-1></A><A id=i574171488-2></A><A id=i-995240575-1></A><A id=i1813550033-1></A></H5>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Code</SPAN></SPAN></TD>
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Result</SPAN></SPAN></TD></TR>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN></SPAN>&nbsp;<SPAN class=code>max</SPAN>&nbsp;<SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN></SPAN></TD>
<TD style="BORDER-TOP: black thin solid"><SPAN class=code>5</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN></SPAN>&nbsp;<SPAN class=code>min</SPAN>&nbsp;<SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN></SPAN></TD>
<TD><SPAN class=code>0</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>-<SPAN class=literal style="COLOR: rgb(205,123,0)">2.7</SPAN></SPAN>&nbsp;<SPAN class=code>abs</SPAN></TD>
<TD><SPAN class=code>2.7</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>-<SPAN class=literal style="COLOR: rgb(205,123,0)">2.7</SPAN></SPAN>&nbsp;<SPAN class=code>round</SPAN></TD>
<TD><SPAN class=code>-3L</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">1.5</SPAN></SPAN>&nbsp;<SPAN class=code>isInfinity</SPAN></TD>
<TD><SPAN class=code>false</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1.0</SPAN></SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)</SPAN>&nbsp;<SPAN class=code>isInfinity</SPAN></TD>
<TD><SPAN class=code>true</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN></SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">6</SPAN></SPAN></TD>
<TD><SPAN class=code>Range(4,</SPAN>&nbsp;<SPAN class=code>5,</SPAN>&nbsp;<SPAN class=code>6)</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"bob"</SPAN></SPAN>&nbsp;<SPAN class=code>capitalize</SPAN></TD>
<TD><SPAN class=code>"Bob"</SPAN></TD></TR>
<TR class=bottomline style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TD style="BORDER-BOTTOM: black thin solid"><SPAN class=code><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"robert"</SPAN></SPAN>&nbsp;<SPAN class=code>drop</SPAN>&nbsp;<SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN></SPAN></TD>
<TD style="BORDER-BOTTOM: black thin solid"><SPAN class=code>"bert"</SPAN></TD></TR></TBODY></TABLE></DIV>
<P><A name=tab:richclasses></A></P>
<H5>Table 5.5 - Rich wrapper classes</H5>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Basic type</SPAN></SPAN></TD>
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Rich wrapper</SPAN></SPAN></TD></TR>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Byte</SPAN></SPAN></TD>
<TD style="BORDER-TOP: black thin solid"><SPAN class=code>scala.runtime.RichByte</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Short</SPAN></SPAN></TD>
<TD><SPAN class=code>scala.runtime.RichShort</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN></SPAN></TD>
<TD><SPAN class=code>scala.runtime.RichInt</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Char</SPAN></SPAN></TD>
<TD><SPAN class=code>scala.runtime.RichChar</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN></SPAN></TD>
<TD><SPAN class=code>scala.runtime.RichString</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Float</SPAN></SPAN></TD>
<TD><SPAN class=code>scala.runtime.RichFloat</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN></SPAN></TD>
<TD><SPAN class=code>scala.runtime.RichDouble</SPAN></TD></TR>
<TR class=bottomline style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TD style="BORDER-BOTTOM: black thin solid"><SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN></SPAN></TD>
<TD style="BORDER-BOTTOM: black thin solid"><SPAN class=code>scala.runtime.RichBoolean</SPAN></TD></TR></TBODY></TABLE></DIV>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=5.10></A>5.10 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#5.10">link</A>]</SPAN></H3>
<P>The main take-aways from this chapter are that operators in Scala are method calls, and that implicit conversions to rich variants exist for Scala's basic types that add even more useful methods. In the next chapter, we'll show you what it means to design objects in a functional style that gives new implementations of some of the operators that you have seen in this chapter.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 5:</H4>
<P><A name=footnote5-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Packages, which were briefly described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#step2">Step 2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html">Chapter 2</A>, will be covered in depth in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html">Chapter 13</A>.</P>
<P><A name=footnote5-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>figuratively speaking</P>
<P><A name=footnote5-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Overloaded</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods have the same name but different argument types. More on method overloading in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html#sec:method-overloading">Section 6.11</A>.</P>
<P><A name=footnote5-4>[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>All is not necessarily lost, however. There is an extremely slight chance your program with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>might compile as C++.</P>
<P><A name=footnote5-5>[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The bitwise-xor method performs an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">exclusive or</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>on its operands. Identical bits yield a 0. Different bits yield a 1. Thus<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0011</SPAN>&nbsp;<SPAN class=code>^</SPAN>&nbsp;<SPAN class=code>0101</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>yields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0110</SPAN></P>
<P><A name=footnote5-6>[6]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The leftmost bit in an integer type is the sign bit. If the leftmost bit is 1, the number is negative. If 0, the number is positive.</P>
<P><A name=footnote5-7>[7]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The automatic check does not look at the right-hand side, but any reasonable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method should return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if its argument is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN>.</P>
<P><A name=footnote5-8>[8]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>By now you should be able to figure out that given this code, the Scala compiler would invoke<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(bills.!*&amp;^%<SPAN style="FONT-SIZE: large">~</SPAN>(code)).!()</SPAN>.</P></DIV>