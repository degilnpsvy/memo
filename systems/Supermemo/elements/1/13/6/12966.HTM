<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 3 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Next Steps in Scala</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>This chapter continues the previous chapter's introduction to Scala. In this chapter, we'll introduce some more advanced features. When you complete this chapter, you should have enough knowledge to enable you to start writing useful scripts in Scala. As with the previous chapter, we recommend you try out these examples as you go. The best way to get a feel for Scala is to start writing Scala code.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=step7></A>Step 7. Parameterize arrays with types<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#step7">link</A>]</SPAN></H3>
<P>In Scala, you can instantiate objects, or class instances, using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN>. When you instantiate an object in Scala, you can<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">parameterize</EM><A id=i1621984850-1></A><A id=i-676617420-1></A><A id=i534686151-1></A><A id=i-780439702-1></A><A id=i1292813002-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>it with values and types. Parameterization means "configuring" an instance when you create it. You parameterize an instance with values by passing objects to a constructor<A id=i-1995954247-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in parentheses. For example, the following Scala code instantiates a new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.math.BigInteger</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and parameterizes it with the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"12345"</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;big&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">java.math.BigInteger</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"12345"</SPAN>)
</PRE>
<P>You parameterize an instance with types by specifying one or more types in square brackets. An example is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:param-array">Listing 3.1</A>. In this example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greetStrings</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a value of type<SPAN class=code>Array[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(an "array of string") that is initialized to length 3 by parameterizing it with the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>3</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the first line of code. If you run the code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:param-array">Listing 3.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a script, you'll see yet another<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Hello,</SPAN>&nbsp;<SPAN class=code>world!</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>greeting. Note that when you parameterize an instance with both a type and a value, the type comes first in its square brackets, followed by the value in parentheses.</P>
<P><A name=lst:param-array></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;greetStrings&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <BR>  &nbsp;&nbsp;greetStrings(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello"</SPAN>
  &nbsp;&nbsp;greetStrings(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">",&nbsp;"</SPAN>
  &nbsp;&nbsp;greetStrings(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"world!\n"</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(i&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;to&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;print(greetStrings(i))
</PRE>
<H5>Listing 3.1 - Parameterizing an array with a type.</H5>
<DIV class=note style="PADDING-RIGHT: 20px; PADDING-LEFT: 20px; PADDING-BOTTOM: 5px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px">
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Note</H4>
<P>Although the code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:param-array">Listing 3.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>demonstrates important concepts, it does not show the recommended way to create and initialize an array in Scala. You'll see a better way in<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-array">Listing 3.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-array">here</A>.</P></DIV>
<P>Had you been in a more explicit mood, you could have<SPAN class=Apple-converted-space>&nbsp;</SPAN>specified the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greetStrings</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>explicitly like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;greetStrings:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
</PRE>
<P>Given Scala's type inference, this line of code is semantically equivalent to the actual first line of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:param-array">Listing 3.1</A>. But this form demonstrates that while the type parameterization portion (the type names in square brackets) forms part of the type of the instance, the value parameterization part (the values in parentheses) does not. The type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greetStrings</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=code>Array[String]</SPAN>, not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String](3)</SPAN>.</P>
<P>The next three lines of code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:param-array">Listing 3.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>initialize each element of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greetStrings</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>array:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  greetStrings(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello"</SPAN>
  greetStrings(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">",&nbsp;"</SPAN>
  greetStrings(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"world!\n"</SPAN>
</PRE>
<P>As mentioned previously, arrays<A id=i1726482861-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala are accessed by placing the index inside parentheses, not square brackets as in Java. Thus the zeroth element of the array is<SPAN class=code>greetStrings(0)</SPAN>, not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greetStrings[0]</SPAN>.</P>
<P>These three lines of code illustrate an important concept to understand about Scala concerning the meaning of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><A id=i-1513931462-1></A>. When you define a variable with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>, the variable can't be reassigned, but the object to which it refers could potentially still be changed. So in this case, you couldn't reassign<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greetStrings</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to a different array;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greetStrings</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will always point to the same<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instance with which it was initialized. But you<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">can</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>change the elements of that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>over time, so the array itself is mutable.</P>
<P>The final two lines in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:param-array">Listing 3.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>contain a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression that prints out each<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greetStrings</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>array element in turn:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(i&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;to&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  &nbsp;&nbsp;print(greetStrings(i))
</PRE>
<P>The first line of code in this<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression illustrates another general rule of Scala: if a method takes only one parameter, you can<A id=i574171488-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>call it without a dot or parentheses.<A id=i-614149608-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>to</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in this example is actually a method that takes one<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument. The code<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code>2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is transformed into the method call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(0).to(2)</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#footnote3-1">[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Note that this syntax only works if you explicitly specify the receiver of the method call. You cannot write "<SPAN class=code>println</SPAN>&nbsp;<SPAN class=code>10</SPAN>", but you can write "<SPAN class=code>Console</SPAN>&nbsp;<SPAN class=code>println</SPAN>&nbsp;<SPAN class=code>10</SPAN>".</P>
<P>Scala doesn't technically have operator overloading,<A id=i-189261806-1></A><A id=i2049320438-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>because it doesn't actually have operators in the traditional sense. Instead, characters such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>/</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be used in method names. Thus, when you typed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into the Scala interpreter in Step 1, you were actually invoking a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>, passing in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a parameter. As illustrated in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#fig:operator-notation">Figure 3.1</A>, you could alternatively have written<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>using traditional method invocation syntax,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(1).+(2)</SPAN>.</P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:operator-notation></A>
<P><IMG alt="image images/operatorNotation50.jpg" src="http://www.artima.com/pins1ed/images/operatorNotation50.jpg"></P></DIV>
<H5>Figure 3.1 - All operations are method calls in Scala.</H5>
<P>Another important idea illustrated by this example will give you insight into why arrays are accessed with parentheses<A id=i580437291-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala. Scala has fewer special cases than Java. Arrays are simply instances of classes like any other class in Scala. When you apply parentheses surrounding one or more values to a variable, Scala will transform the code into an invocation of a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><A id=i1032551708-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>on that variable. So<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greetStrings(i)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>gets transformed into<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greetStrings.apply(i)</SPAN>. Thus accessing an element of an array in Scala is simply a method call like any other.<A id=i-1841919811-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This principle is not restricted to arrays: any application of an object to some arguments in parentheses will be transformed to an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method call. Of course this will compile only if that type of object actually defines an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. So it's not a special case; it's a general rule.</P>
<P>Similarly, when an assignment is made to a variable to which parentheses and one or more arguments have been applied, the compiler will transform that into an invocation of an<SPAN class=code>update</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that takes the arguments in parentheses as well as the object to the right of the equals sign.<A id=i1392004210-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  greetStrings(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello"</SPAN>&nbsp;
</PRE>
<P>will be transformed into:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  greetStrings.update(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello"</SPAN>)
</PRE>
<P>Thus, the following is semantically equivalent to the code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:param-array">Listing 3.1</A>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;greetStrings&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <BR>  greetStrings.update(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello"</SPAN>)
  greetStrings.update(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">",&nbsp;"</SPAN>)
  greetStrings.update(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"world!\n"</SPAN>)
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(i&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0.</SPAN>to(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>))
  &nbsp;&nbsp;print(greetStrings.apply(i))
</PRE>
<P>Scala achieves a conceptual simplicity by treating everything, from arrays to expressions, as objects with methods. You don't have to remember special cases, such as the differences in Java between primitive and their corresponding wrapper types, or between arrays and regular objects. Moreover, this uniformity does not incur a significant performance cost. The Scala compiler uses Java arrays, primitive types<A id=i-1876955136-1></A><A id=i-1448312026-1></A>, and native arithmetic where possible in the compiled code.<A id=i884498802-2></A><A id=i341425106-1></A></P>
<P>Although the examples you've seen so far in this step compile and run just fine, Scala provides a more concise way to create and initialize arrays that you would normally use. It looks as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-array">Listing 3.2</A>. This code creates a new array of length three, initialized to the passed strings,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"zero"</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"one"</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"two"</SPAN>. The compiler infers the type of the array to be<SPAN class=code>Array[String]</SPAN>, because you passed strings to it.</P>
<P><A name=lst:init-array></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numNames&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"zero"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"one"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"two"</SPAN>)
</PRE>
<H5>Listing 3.2 - Creating and initializing an array.</H5>
<P>What<A id=i-1162394563-1></A><A id=i1766069577-1></A><A id=i1302049027-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>you're actually doing in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-array">Listing 3.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is calling a factory<A id=i-640194953-1></A><A id=i1891034327-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>method,<A id=i-1125093732-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN>, which creates and returns the new array.<A id=i-930370406-1></A><A id=i-1249757433-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method takes a variable number of arguments<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#footnote3-2">[2]</A><A id=i-1544402352-1></A><A id=i-580179190-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and is defined on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">companion object</EM>.<A id=i228947968-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You'll learn more about companion objects in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/classes-and-objects.html#sec:singleton-objects">Section 4.3</A>. If you're a Java programmer, you can think of this as calling a static method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN>. A more verbose way to call the same<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numNames2&nbsp;=&nbsp;Array.apply(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"zero"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"one"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"two"</SPAN>)
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=step8></A>Step 8. Use lists<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#step8">link</A>]</SPAN></H3>
<P>One of the big ideas of the functional style of programming is that methods should<A id=i102982549-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>not have side effects.<A id=i18918201-2></A><A id=i-86904923-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>A method's only act should be to compute and return a value. Some benefits gained when you take this approach are that methods become less entangled, and therefore more reliable and reusable. Another benefit (in a statically typed language) is that everything that goes into and out of a method is checked by a type checker, so logic errors are more likely to manifest themselves as type errors. Applying this functional philosophy to the world of objects means making objects immutable.<A id=i2043021322-1></A><A id=i-124569956-1></A></P>
<P>As you've seen, a Scala array is a mutable sequence of objects that all share the same type. An<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains only strings, for example. Although you can't change the length of an array after it is instantiated, you can change its element values. Thus, arrays are mutable objects.</P>
<P>For an immutable sequence of objects that share the same type you can use Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><A id=i882498454-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. As with arrays, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains only strings. Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.List</SPAN>, differs from Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.util.List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type in that Scala<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>s are always immutable (whereas Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>s can be mutable). More generally, Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is designed to enable a functional style of programming. Creating a list is easy.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-list">Listing 3.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows how:</P>
<P><A name=lst:init-list></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;oneTwoThree&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
</PRE>
<H5>Listing 3.3 - Creating and initializing a list.</H5>
<P>The<A id=i-797883688-1></A><A id=i-625874522-1></A><A id=i457962676-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-list">Listing 3.3</A><A id=i486535256-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>establishes a new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>oneTwoThree</SPAN>, initialized with a new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Int]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the integer elements 1, 2, and 3.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#footnote3-3">[3]</A><A id=i19484993-1></A><A id=i1305057997-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>s are immutable,<A id=i124289382-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>they behave a bit like Java strings: when you call a method on a list that might seem by its name to imply the list will mutate, it instead creates and returns a new list with the new value. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has a method named `<SPAN class=code>:::</SPAN>'<A id=i55390901-1></A><A id=i-1839436249-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>for list concatenation. Here's how you use it:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;oneTwo&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;threeFour&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;oneTwoThreeFour&nbsp;=&nbsp;oneTwo&nbsp;:::&nbsp;threeFour
  println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">""</SPAN>+&nbsp;oneTwo&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;and&nbsp;"</SPAN>+&nbsp;threeFour&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;were&nbsp;not&nbsp;mutated."</SPAN>)
  println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Thus,&nbsp;"</SPAN>+&nbsp;oneTwoThreeFour&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;is&nbsp;a&nbsp;new&nbsp;list."</SPAN>)
</PRE>
<P>If you run this script, you'll see:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">List(1,&nbsp;2)&nbsp;and&nbsp;List(3,&nbsp;4)&nbsp;were&nbsp;not&nbsp;mutated.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Thus,&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4)&nbsp;is&nbsp;a&nbsp;new&nbsp;list.</SPAN>
</PRE>
<P>Perhaps the most common operator you'll use with lists is `<SPAN class=code>::</SPAN>',<A id=i1674095775-1></A><A id=i620923488-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which is pronounced "cons."<A id=i1411857630-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Cons prepends a new element to the beginning of an existing list, and returns the resulting list. For example, if you run this script:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;twoThree&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;oneTwoThree&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;::&nbsp;twoThree
  println(oneTwoThree)
</PRE>
<P>You'll see:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">List(1,&nbsp;2,&nbsp;3)</SPAN>
</PRE>
<DIV class=note style="PADDING-RIGHT: 20px; PADDING-LEFT: 20px; PADDING-BOTTOM: 5px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px">
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Note</H4>In the expression "<SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>twoThree</SPAN>",<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a method of its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">right</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operand, the list,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>twoThree</SPAN>. You might suspect there's something amiss with the associativity<A id=i-1085593547-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, but it is actually a simple rule to remember: If a method is used in operator notation, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>b</SPAN>, the method is invoked on the left operand, as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a.*(b)</SPAN>&#8212;unless the method name ends in a colon. If the method name ends in a colon, the method is invoked on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">right</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>operand. Therefore, in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>twoThree</SPAN>, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is invoked on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>twoThree</SPAN>, passing in<SPAN class=code>1</SPAN>, like this:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>twoThree.::(1)</SPAN>. Operator associativity will be described in more detail in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#sec:precedence">Section 5.8</A>.<A name=note:colonmethod></A><A id=i192988404-1></A><A id=i-1491182453-1></A></DIV>
<P>Given that a shorthand way to specify an empty list is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN>,<A id=i1899558990-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>one way to initialize new lists is to string together elements with the cons operator, with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as the last element.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#footnote3-4">[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, the following script will produce the same output as the previous one, "<SPAN class=code>List(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3)</SPAN>":</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;oneTwoThree&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;::&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;::&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>&nbsp;::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>
  println(oneTwoThree)
</PRE>Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is packed with useful methods, many of which are shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#tab:listmethods">Table 3.1</A>. The full power of lists will be revealed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html">Chapter 16</A><A id=i51698754-1></A><A id=i-1815843466-1></A>. 
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Why not append to lists?</H3>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not offer an append operation, because the time it takes to append to a list grows linearly with the size of the list, whereas prepending with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes constant time. Your options if you want to build a list by appending elements is to prepend them, then when you're done call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverse</SPAN>; or use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN>, a mutable list that does offer an append operation, and when you're done call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#sec:the-listbuffer-class">Section 22.2</A>.</DIV>
<P><A name=tab:listmethods></A></P>
<H5>Some<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods and usages<A id=i-262118592-1></A></H5>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline bottomline" style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TH><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">What it is</SPAN></SPAN></TH>
<TH>
<DIV align=center><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">What it does</SPAN></SPAN></DIV></TH></TR>
<TR class="">
<TD><SPAN class=code>List()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN></TD>
<TD>The empty<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>List("Cool",</SPAN>&nbsp;<SPAN class=code>"tools",</SPAN>&nbsp;<SPAN class=code>"rule")</SPAN></TD>
<TD>Creates a new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the three values<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Cool"</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"tools"</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"rule"</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>val</SPAN>&nbsp;<SPAN class=code>thrill</SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code>"Will"</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>"fill"</SPAN>&nbsp;<SPAN class=code>::</SPAN><BR><SPAN class=code>"until"</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>Nil</SPAN></TD>
<TD>Creates a new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the three values<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Will"</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"fill"</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"until"</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>List("a",</SPAN>&nbsp;<SPAN class=code>"b")</SPAN>&nbsp;<SPAN class=code>:::</SPAN>&nbsp;<SPAN class=code>List("c",</SPAN>&nbsp;<SPAN class=code>"d")</SPAN></TD>
<TD>Concatenates two lists (returns a new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with values<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"a"</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"b"</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"c"</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"d"</SPAN>)</TD></TR>
<TR class="">
<TD><SPAN class=code>thrill(2)</SPAN></TD>
<TD>Returns the element at index 2 (zero based) of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"until"</SPAN>)</TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.count(s</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>s.length</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>4)</SPAN></TD>
<TD>Counts the number of string elements in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that have length 4 (returns 2)<A id=i607267229-1></A><A id=i-1852559773-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.drop(2)</SPAN></TD>
<TD>Returns the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list without its first 2 elements (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List("until")</SPAN>)<A id=i-673511213-1></A><A id=i1464293147-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.dropRight(2)</SPAN></TD>
<TD>Returns the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list without its rightmost 2 elements (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List("Will")</SPAN>)<A id=i915202043-1></A><A id=i-981552191-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.exists(s</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>s</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>"until")</SPAN></TD>
<TD>Determines whether a string element exists in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that has the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"until"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>)<A id=i339085162-1></A><A id=i-1529560696-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.filter(s</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>s.length</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>4)</SPAN></TD>
<TD>Returns a list of all elements, in order, of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list that have length 4 (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List("Will",</SPAN>&nbsp;<SPAN class=code>"fill")</SPAN>)<A id=i1807572102-1></A><A id=i-1514694492-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.forall(s</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN><BR><SPAN class=code>s.endsWith("l"))</SPAN></TD>
<TD>Indicates whether all elements in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list end with the letter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"l"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>)<A id=i260029766-1></A><A id=i-1508992668-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.foreach(s</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>print(s))</SPAN></TD>
<TD>Executes the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>print</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>statement on each of the strings in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list (prints<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Willfilluntil"</SPAN>)<A id=i331113560-1></A><A id=i465975966-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.foreach(print)</SPAN></TD>
<TD>Same as the previous, but more concise (also prints<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Willfilluntil"</SPAN>)</TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.head</SPAN></TD>
<TD>Returns the first element in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Will"</SPAN>)<A id=i-735890706-1></A><A id=i1464399372-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.init</SPAN></TD>
<TD>Returns a list of all but the last element in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List("Will",</SPAN>&nbsp;<SPAN class=code>"fill")</SPAN>)<A id=i-1293540834-1></A><A id=i1464438076-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.isEmpty</SPAN></TD>
<TD>Indicates whether the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list is empty (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>)<A id=i1657074897-1></A><A id=i-1093268841-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.last</SPAN></TD>
<TD>Returns the last element in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"until"</SPAN>)<A id=i1113811620-1></A><A id=i1464515266-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.length</SPAN></TD>
<TD>Returns the number of elements in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list (returns 3)<A id=i1353349876-1></A><A id=i-1346566126-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.map(s</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>s</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>"y")</SPAN></TD>
<TD>Returns a list resulting from adding a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"y"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to each string element in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List("Willy",</SPAN>&nbsp;<SPAN class=code>"filly",</SPAN>&nbsp;<SPAN class=code>"untily")</SPAN>)<A id=i395196522-1></A><A id=i1986906032-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.mkString(",</SPAN>&nbsp;<SPAN class=code>")</SPAN></TD>
<TD>Makes a string with the elements of the list (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Will,</SPAN>&nbsp;<SPAN class=code>fill,</SPAN>&nbsp;<SPAN class=code>until"</SPAN>)<A id=i1357784029-1></A><A id=i746937723-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.remove(s</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>s.length</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>4)</SPAN></TD>
<TD>Returns a list of all elements, in order, of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">except those</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>that have length 4 (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List("until")</SPAN>)<A id=i1676197778-1></A><A id=i-1174813264-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.reverse</SPAN></TD>
<TD>Returns a list containing all elements of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list in reverse order (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List("until",</SPAN>&nbsp;<SPAN class=code>"fill",</SPAN>&nbsp;<SPAN class=code>"Will")</SPAN>)<A id=i1817641200-1></A><A id=i-2051462346-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>thrill.sort((s,</SPAN>&nbsp;<SPAN class=code>t)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN><BR><SPAN class=code>s.charAt(0).toLowerCase</SPAN>&nbsp;<SPAN class=code>&lt;</SPAN><BR><SPAN class=code>t.charAt(0).toLowerCase)</SPAN></TD>
<TD>Returns a list containing all elements of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list in alphabetical order of the first character lowercased (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List("fill",</SPAN>&nbsp;<SPAN class=code>"until",</SPAN>&nbsp;<SPAN class=code>"Will")</SPAN>)<A id=i532902316-1></A><A id=i1464737226-1></A></TD></TR>
<TR class=bottomline style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TD style="BORDER-BOTTOM: black thin solid"><SPAN class=code>thrill.tail</SPAN></TD>
<TD style="BORDER-BOTTOM: black thin solid">Returns the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>thrill</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list minus its first element (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List("fill",</SPAN>&nbsp;<SPAN class=code>"until")</SPAN>)<A id=i849842526-1></A><A id=i1464753276-1></A></TD></TR></TBODY></TABLE>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=step9></A>Step 9. Use tuples<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#step9">link</A>]</SPAN></H3>
<P>Another useful container object is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">tuple</EM>. Like lists, tuples are<A id=i-2050968957-1></A><A id=i-1857258168-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>immutable, but unlike lists, tuples can contain different types of elements. Whereas a list might be a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Int]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or a<SPAN class=code>List[String]</SPAN>, a tuple could contain both an integer and a string at the same time. Tuples are very useful, for example, if you need to return multiple objects from a method. Whereas in Java<A id=i651595778-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>you would often create a JavaBean-like<A id=i1133571489-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>class to hold the multiple return values,<A id=i2120520132-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala you can simply return a tuple. And it is simple: to instantiate a new tuple that holds some objects, just place the objects in parentheses, separated by commas. Once you have a tuple instantiated, you can access its elements individually with a dot, underscore, and the one-based index of the element. An example is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-tuple">Listing 3.4</A>:</P>
<P><A name=lst:init-tuple></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;pair&nbsp;=&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">99</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Luftballons"</SPAN>)
  &nbsp;&nbsp;println(pair._1)
  &nbsp;&nbsp;println(pair._2)
</PRE>
<H5>Listing 3.4 - Creating and using a tuple.</H5>
<P>In the first line of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-tuple">Listing 3.4</A>, you create a new tuple that contains the integer 99, as its first element, and the string,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Luftballons"</SPAN>, as its second element. Scala infers the type of the tuple to be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tuple2[Int,</SPAN>&nbsp;<SPAN class=code>String]</SPAN>, and gives that type to the variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pair</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as well. In the second line, you access the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field, which will produce the first element, 99. The "<SPAN class=code>.</SPAN>" in the second line is the same dot you'd use to access a field or invoke a method. In this case you are accessing a field named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_1</SPAN>.<A id=i-837880330-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>If you run this script, you'll see:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">99</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Luftballons</SPAN>
</PRE>
<P>The actual type of a tuple depends on the number of elements it contains and the types of those elements. Thus, the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(99,</SPAN>&nbsp;<SPAN class=code>"Luftballons")</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tuple2[Int,</SPAN>&nbsp;<SPAN class=code>String]</SPAN>. The type of<SPAN class=code>('u',</SPAN>&nbsp;<SPAN class=code>'r',</SPAN>&nbsp;<SPAN class=code>"the",</SPAN>&nbsp;<SPAN class=code>1,</SPAN>&nbsp;<SPAN class=code>4,</SPAN>&nbsp;<SPAN class=code>"me")</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tuple6[Char,</SPAN>&nbsp;<SPAN class=code>Char,</SPAN>&nbsp;<SPAN class=code>String,</SPAN>&nbsp;<SPAN class=code>Int,</SPAN>&nbsp;<SPAN class=code>Int,</SPAN>&nbsp;<SPAN class=code>String]</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#footnote3-5">[5]</A></P>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Accessing the elements of a tuple</H3>You may be wondering why you can't access the elements of a tuple like the elements of a list, for example, with "<SPAN class=code>pair(0)</SPAN>". The reason is that a list's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method always returns the same type, but each element of a tuple may be a different type:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can have one result type,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>another, and so on. These<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_N</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>numbers are one-based, instead of zero-based, because starting with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a tradition set by other languages with statically typed tuples,<A id=i-188293365-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>such as Haskell and ML.</DIV>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=step10></A>Step 10. Use sets and maps<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#step10">link</A>]</SPAN></H3>
<P>Because Scala aims to help you take advantage of both functional<A id=i1434668372-1></A><A id=i-1837133869-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and imperative styles,<A id=i148663933-1></A><A id=i49218492-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>its collections libraries make a point to differentiate between mutable and immutable collection classes. For example, arrays are always mutable, whereas lists are always immutable. When it comes to sets and maps, Scala also provides mutable and immutable alternatives, but in a different way. For sets<A id=i-472072085-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and maps,<A id=i-1702928719-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Scala models mutability in the class hierarchy.</P>
<P>For example, the Scala API contains a base<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">trait</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>for sets,<A id=i3526737-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>where a trait is similar to a Java interface. (You'll find out more about traits in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html">Chapter 12</A>.) Scala then provides two subtraits, one for mutable sets and another for immutable sets. As you can see in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#fig:set-hierarchy">Figure 3.2</A>, these three traits all share the same simple name,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN>. Their fully qualified names differ, however, because each resides in a different package. Concrete set classes in the Scala API, such as the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashSet</SPAN><A id=i1649804972-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>classes shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#fig:set-hierarchy">Figure 3.2</A>, extend either the mutable or immutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait. (Although in Java you "implement" interfaces, in Scala you "extend" or "mix in" traits.<A id=i-1672969622-1></A>) Thus, if you want to use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashSet</SPAN>, you can choose between mutable and immutable varieties depending upon your needs. The default way to create a set is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-immutable-set">Listing 3.5</A>:<A id=i1277661430-1></A><A id=i1124278062-1></A><A id=i-1634739460-1></A><A id=i1868251958-1></A><A name=lst:init-immutable-set></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;jetSet&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Boeing"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Airbus"</SPAN>)
  &nbsp;&nbsp;jetSet&nbsp;+=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Lear"</SPAN>
  &nbsp;&nbsp;println(jetSet.contains(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Cessna"</SPAN>))
</PRE>
<H5>Listing 3.5 - Creating, initializing, and using an immutable set.<A id=i1504035872-1></A></H5>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:set-hierarchy></A>
<P><IMG alt="image images/sets53.jpg" src="http://www.artima.com/pins1ed/images/sets53.jpg"></P></DIV>
<H5>Figure 3.2 - Class hierarchy for Scala sets.<A id=i-1161517801-1></A><A id=i894901459-1></A><A id=i-702923198-1></A></H5>
<P>In the first line of code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-immutable-set">Listing 3.5</A>, you define a new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>jetSet</SPAN>, and initialize it with an immutable set containing the two strings,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Boeing"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Airbus"</SPAN>. As this example shows, you can create sets in Scala similarly to how you create lists and arrays: by invoking a factory method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>companion object. In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-immutable-set">Listing 3.5</A>, you invoke<SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the companion object for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.immutable.Set</SPAN>, which returns an instance of a default, immutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN>. The Scala compiler infers<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>jetSet</SPAN>'s type to be the immutable<SPAN class=code>Set[String]</SPAN>.</P>
<P>To add a new element to a set, you call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the set<A id=i-734113406-1></A>, passing in the new element. Both mutable and immutable sets offer a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, but their behavior differs. Whereas a mutable set will add the element to itself, an immutable set will create and return a new set with the element added. In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-immutable-set">Listing 3.5</A>, you're working with an immutable set, thus the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>invocation will yield a brand new set. Although mutable sets offer an actual<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, immutable sets do not<A id=i518995282-1></A>. In this case, the second line of code, "<SPAN class=code>jetSet</SPAN>&nbsp;<SPAN class=code>+=</SPAN>&nbsp;<SPAN class=code>"Lear"</SPAN>", is essentially a shorthand for:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  jetSet&nbsp;=&nbsp;jetSet&nbsp;+&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Lear"</SPAN>
</PRE>Thus, in the second line of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-immutable-set">Listing 3.5</A>, you reassign the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>jetSet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a new set containing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Boeing"</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Airbus"</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Lear"</SPAN>. Finally, the last line of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-immutable-set">Listing 3.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>prints out whether or not the set contains the string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Cessna"</SPAN>. (As you'd expect, it prints<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>.) 
<P></P>
<P>If you want a mutable set, you'll need to use an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">import</EM>, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-mutable-set">Listing 3.6</A>:<A id=i1926037870-1></A></P>
<P><A name=lst:init-mutable-set></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable.Set
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;movieSet&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hitch"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Poltergeist"</SPAN>)
  &nbsp;&nbsp;movieSet&nbsp;+=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Shrek"</SPAN>
  &nbsp;&nbsp;println(movieSet)&nbsp;
</PRE>
<H5>Listing 3.6 - Creating, initializing, and using a mutable set.<A id=i1504035872-2></A></H5>
<P>In<A id=i-875218022-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>the first line of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-mutable-set">Listing 3.6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>you import the mutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN>. As with Java, an import statement allows you to use a simple name, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN>, instead of the longer, fully qualified name.<A id=i-2107109778-1></A>As a result, when you say<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the third line, the compiler knows you mean<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.mutable.Set</SPAN>. On that line, you initialize<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>movieSet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a new mutable set that contains the strings<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Hitch"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Poltergeist"</SPAN>. The subsequent line adds<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Shrek"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the mutable set by calling the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method on the set, passing in the string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Shrek"</SPAN>. As mentioned previously,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an actual method defined on mutable sets. Had you wanted to, instead of writing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>movieSet</SPAN>&nbsp;<SPAN class=code>+=</SPAN>&nbsp;<SPAN class=code>"Shrek"</SPAN>, therefore, you could have written<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>movieSet.+=("Shrek")</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#footnote3-6">[6]</A></P>
<P>Although the default set implementations produced by the mutable and immutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>factory methods shown thus far will likely be sufficient for most situations, occasionally you may want an explicit set class. Fortunately, the syntax is similar. Simply import that class you need, and use the factory method on its companion object. For example, if you need an immutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashSet</SPAN>, you could do this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.immutable.HashSet
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;hashSet&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HashSet</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Tomatoes"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Chilies"</SPAN>)
  println(hashSet&nbsp;+&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Coriander"</SPAN>)
</PRE>
<P>Another<A id=i3344023-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>useful collection class in Scala is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>. As with sets, Scala provides mutable and<A id=i-2121468463-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>immutable versions of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>, using a class hierarchy. As you can see in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#fig:map-hierarchy">Figure 3.3</A>, the class hierarchy for maps looks a lot like the one for sets. There's a base<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection</SPAN>, and two subtrait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>s: a mutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.mutable</SPAN>and an immutable one in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.immutable</SPAN>.</P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:map-hierarchy></A>
<P><IMG alt="image images/maps53.jpg" src="http://www.artima.com/pins1ed/images/maps53.jpg"></P></DIV>
<H5>Figure 3.3 - Class hierarchy for Scala maps.<A id=i691333469-1></A><A id=i-335955175-1></A><A id=i-703105912-1></A></H5>
<P>Implementations of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>, such as the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashMap</SPAN>s shown in the class hierarchy in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#fig:map-hierarchy">Figure 3.3</A>, extend either the mutable or immutable trait. You can create and initialize maps using factory methods similar to those used for arrays, lists, and sets. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-mutable-map">Listing 3.7</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a mutable map in action:</P>
<P><A name=lst:init-mutable-map></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable.Map
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;treasureMap&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map[Int, String]</SPAN>()
  &nbsp;&nbsp;treasureMap&nbsp;+=&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Go&nbsp;to&nbsp;island."</SPAN>)
  &nbsp;&nbsp;treasureMap&nbsp;+=&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Find&nbsp;big&nbsp;X&nbsp;on&nbsp;ground."</SPAN>)
  &nbsp;&nbsp;treasureMap&nbsp;+=&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Dig."</SPAN>)
  &nbsp;&nbsp;println(treasureMap(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>))
</PRE>
<H5>Listing 3.7 - Creating, initializing, and using a mutable map.<A id=i1682530400-1></A></H5>
<P>On the first line of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-mutable-map">Listing 3.7</A>, you import the mutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>. You then define a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>treasureMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and initialize it with an empty mutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that has integer keys and string values. The map is empty because you pass nothing to the factory method (the parentheses in "<SPAN class=code>Map[Int,</SPAN>&nbsp;<SPAN class=code>String]()</SPAN>" are empty).<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#footnote3-7">[7]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>On the next three lines you add key/value pairs to the map using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods.<A id=i1457-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>As illustrated previously,<SPAN class=Apple-converted-space>&nbsp;</SPAN>the Scala compiler transforms a binary operation expression like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>"Go</SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code>island."</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(1).-&gt;("Go</SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code>island.")</SPAN>. Thus, when you say<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>"Go</SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code>island."</SPAN>, you are actually calling a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on an integer with the value 1, passing in a string with the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Go</SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code>island."</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>This<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which you can invoke on any object in a Scala program, returns a two-element tuple<A id=i1796651421-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>containing the key and value.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#footnote3-8">[8]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You then pass this tuple to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method of the map object to which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>treasureMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>refers. Finally, the last line prints the value that corresponds to the key<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>treasureMap</SPAN>. If you run this code, it will print:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  Find&nbsp;big&nbsp;X&nbsp;on&nbsp;ground.
</PRE>
<P></P>
<P>If you prefer an immutable map, no import is necessary, as immutable is the default map. An example is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-immutable-map">Listing 3.8</A>:<A id=i1124095348-1></A><A id=i-1948600164-1></A><A id=i-809004496-1></A></P>
<P><A name=lst:init-immutable-map></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;romanNumeral&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"I"</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"II"</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"III"</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"IV"</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"V"</SPAN>
  &nbsp;&nbsp;)
  &nbsp;&nbsp;println(romanNumeral(<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>))
</PRE>
<H5>Listing 3.8 - Creating, initializing, and using an immutable map.<A id=i1503853158-1></A><A id=i-1742365636-1></A></H5>
<P>Given there are no imports, when you say<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the first line of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-immutable-map">Listing 3.8</A>, you'll get the default: a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.immutable.Map</SPAN>. You pass five key/value tuples to the map's factory method, which returns an immutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>containing the passed key/value pairs. If you run the code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-immutable-map">Listing 3.8</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>it will print "<SPAN class=code>IV</SPAN>".</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=step11></A>Step 11. Learn to recognize the functional style<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#step11">link</A>]</SPAN></H3>
<P><A name=sec:importance-of-vals></A></P>
<P>As mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html">Chapter 1</A>, Scala allows you to program in an imperative style,<A id=i975391822-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>but encourages you to adopt a more functional style.<A id=i-1384669019-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>If you are coming to Scala from an imperative background&#8212;for example, if you are a Java programmer&#8212;one of the main challenges you may face when learning Scala is figuring out how to program in the functional style. We realize this style might be unfamiliar at first, and in this book we try hard to guide you through the transition. It will require some work on your part, and we encourage you to make the effort. If you come from an imperative background, we believe that learning to program in a functional style will not only make you a better Scala programmer, it will expand your horizons and make you a better programmer in general.</P>
<P>The first step is to recognize the difference between the two styles in code. One telltale sign is that if code contains any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s, it is probably in an imperative style. If the code contains no<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s at all&#8212;<I>i.e.</I>, it contains<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">only</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s&#8212;it is probably in a functional style. One way to move towards a functional style, therefore, is to try to program without<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s<A id=i-96078285-1></A>.</P>
<P>If you're coming from an imperative background, such as Java, C++, or C#, you may think of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a regular variable and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a special kind of variable.<A id=i-687482648-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>On the other hand, if you're coming from a functional background, such as Haskell, OCaml, or Erlang<A id=i2012001632-2></A><A id=i916374005-2></A><A id=i337211374-1></A><A id=i-140820978-1></A><A id=i-1496851060-3></A><A id=i-1028679267-3></A>, you might think of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a regular variable and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as akin to blasphemy. The Scala perspective, however, is that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are just two different tools in your toolbox, both useful, neither inherently evil. Scala encourages you to lean towards<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s, but ultimately reach for the best tool given the job at hand. Even if you agree with this balanced philosophy, however, you may still find it challenging at first to figure out how to get rid of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s in your code.</P>
<P>Consider the following<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loop example, adapted<SPAN class=Apple-converted-space>&nbsp;</SPAN>from<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html">Chapter 2</A>, which uses a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and is therefore in the imperative style:<A id=i-334114095-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;printArgs(args:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Unit</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;i&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">while</SPAN>&nbsp;(i&nbsp;&lt;&nbsp;args.length)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(args(i))
  &nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  &nbsp;&nbsp;}
  }
</PRE>You can transform this bit of code into a more functional style by getting rid of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>, for example, like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;printArgs(args:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Unit</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(arg&nbsp;&lt;-&nbsp;args)
  &nbsp;&nbsp;&nbsp;&nbsp;println(arg)
  }
</PRE>or this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;printArgs(args:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Unit</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;args.foreach(println)
  }
</PRE>
<P></P>
<P>This example illustrates one benefit of programming with fewer<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s. The refactored (more functional) code is clearer, more concise, and less error-prone than the original (more imperative) code. The reason Scala encourages a functional style, in fact, is that the functional style can help you write more understandable, less error-prone code<A id=i-1761697159-1></A>.</P>
<P>You can go even further, though. The refactored<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printArgs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is not<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">purely</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>functional, because it has side effects&#8212;in this case, its side effect<A id=i18918201-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is printing to the standard output stream. The telltale sign of a function with side effects is that its result type is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN>. If a function isn't returning any interesting value, which is what a result type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>means,<A id=i-1581694980-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>the only way that function can make a difference in the world is through some kind of side effect. A more functional approach would be to define a method that formats the passed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>args</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for printing, but just returns the formatted string, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:format-args">Listing 3.9</A>.</P>
<P><A name=lst:format-args></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;formatArgs(args:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>)&nbsp;=&nbsp;args.mkString(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"\n"</SPAN>)
</PRE>
<H5>Listing 3.9 - A function without side effects or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s.</H5>
<P>Now you're really functional: no side effects or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s in sight. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mkString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method<A id=i-625240033-1></A>, which you can call on any iterable collection (including arrays, lists, sets, and maps), returns a string consisting of the result of calling<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on each element, separated by the passed string. Thus if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>args</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains three elements<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"zero"</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"one"</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"two"</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formatArgs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"zero\none\ntwo"</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN>Of course, this function doesn't actually print anything out like the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printArgs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods did, but you can easily pass its result to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to accomplish that:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  println(formatArgs(args))
</PRE>
<P></P>
<P>Every useful program is likely to have side effects of some form, because otherwise it wouldn't be able to provide value to the outside world. Preferring methods without side effects<A id=i255589052-1></A>encourages you to design programs where side-effecting code is minimized. One benefit of this approach is that it can help make your programs easier to test<A id=i-1422446064-1></A>. For example, to test any of the three<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printArgs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods shown earlier in this section, you'd need to redefine<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println</SPAN>, capture the output passed to it, and make sure it is what you expect. By contrast, you could test<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formatArgs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>simply by checking its result<A id=i-2030836876-1></A>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;res&nbsp;=&nbsp;formatArgs(<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"zero"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"one"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"two"</SPAN>))
  assert(res&nbsp;==&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"zero\none\ntwo"</SPAN>)
</PRE>Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>assert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method checks the passed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and if it is false, throws<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AssertionError</SPAN>.<A id=i1445339835-1></A><A id=i-176392533-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>If the passed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is true,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>assert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>just returns quietly. You'll learn more about assertions and testing in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/assertions-and-unit-testing.html">Chapter 14</A>. 
<P></P>
<P>That said, bear in mind that neither<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s nor side effects are inherently evil. Scala is not a pure functional language that forces you to program everything in the functional style. Scala is a hybrid imperative/functional language. You may find that in some situations an imperative style is a better fit for the problem at hand, and in such cases you should not hesitate to use it. To help you learn how to program without<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s, however, we'll show you many specific examples of code with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s and how to transform those<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s in<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/builtin-control-structures.html">Chapter 7</A>.</P>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">A balanced attitude for Scala programmers</H3>
<P>Prefer<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s, immutable objects, and methods without side effects. Reach for them first. Use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s, mutable objects, and methods with side effects when you have a specific need and justification for them.<A id=i1618156815-1></A></P></DIV>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=step12></A>Step 12. Read lines from a file<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#step12">link</A>]</SPAN></H3>
<P>Scripts that perform small, everyday tasks often need to process lines in files. In this section, you'll build a script that reads lines from a file, and prints them out prepended with the number of characters in each line. The first version is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:from-file-first">Listing 3.10</A>:<A id=i539380770-1></A><A id=i972936021-1></A><A id=i855616002-1></A></P>
<P><A name=lst:from-file-first></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.io.Source
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(args.length&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(line&nbsp;&lt;-&nbsp;Source.fromFile(args(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)).getLines)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(line.length&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>+&nbsp;line)
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;Console.err.println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Please&nbsp;enter&nbsp;filename"</SPAN>)
</PRE>
<H5>Listing 3.10 - Reading lines from a file.<A id=i-1925017016-1></A></H5>
<P>This script starts with an import of a class named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Source</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.io</SPAN>.<A id=i835817156-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It then checks to see if at least one argument was specified on the command line. If so, the first argument is interpreted as a filename to open and process. The expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Source.fromFile(args(0))</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>attempts to open the specified file and returns a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Source</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object, on which you call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getLines</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getLines</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method<A id=i1243928720-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator[String]</SPAN>, which provides one line on each iteration, including the end-of-line character. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression iterates through these lines and prints for each the length of the line, a space, and the line itself. If there were no arguments supplied on the command line, the final else clause will print a message to the standard error stream. If you place this code in a file named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>countchars1.scala</SPAN>, and run it on itself with<A id=i517167387-1></A>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;countchars1.scala&nbsp;countchars1.scala
</PRE>You should see:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  23&nbsp;import&nbsp;scala.io.Source
  1&nbsp;
  23&nbsp;if&nbsp;(args.length&nbsp;&gt;&nbsp;0)&nbsp;{
  1&nbsp;
  50&nbsp;&nbsp;&nbsp;for&nbsp;(line&nbsp;&lt;-&nbsp;Source.fromFile(args(0)).getLines)
  36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(line.length&nbsp;+"&nbsp;"+&nbsp;line)
  2&nbsp;}
  5&nbsp;else
  47&nbsp;&nbsp;&nbsp;Console.err.println("Please&nbsp;enter&nbsp;filename")
</PRE>Although the script in its current form prints out the needed information, you may wish to line up the numbers, right adjusted, and add a pipe character, so that the output looks instead like:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  23&nbsp;|&nbsp;import&nbsp;scala.io.Source
  &nbsp;1&nbsp;|&nbsp;
  23&nbsp;|&nbsp;if&nbsp;(args.length&nbsp;&gt;&nbsp;0)&nbsp;{
  &nbsp;1&nbsp;|&nbsp;
  50&nbsp;|&nbsp;&nbsp;&nbsp;for&nbsp;(line&nbsp;&lt;-&nbsp;Source.fromFile(args(0)).getLines)
  34&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(line.length&nbsp;+"&nbsp;"+&nbsp;line)
  &nbsp;2&nbsp;|&nbsp;}
  &nbsp;5&nbsp;|&nbsp;else
  47&nbsp;|&nbsp;&nbsp;&nbsp;Console.err.println("Please&nbsp;enter&nbsp;filename")
</PRE>To accomplish this, you can iterate through the lines twice. The first time through you'll determine the maximum width required by any line's character count. The second time through you'll print the output, using the maximum width calculated previously. Because you'll be iterating through the lines twice, you may as well assign them to a variable:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;lines&nbsp;=&nbsp;Source.fromFile(args(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)).getLines.toList
</PRE>The final<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is required because the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getLines</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method returns an iterator. Once you've iterated through an iterator, it is spent. By transforming it into a list via the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>call, you gain the ability to iterate as many times as you wish, at the cost of storing all lines from the file in memory at once. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>lines</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable, therefore, references a list of strings that contains the contents of the file specified on the command line. 
<P></P>
<P>Next, because you'll be calculating the width of each line's character count twice, once per iteration, you might factor that expression out into a small function, which calculates the character width of the passed string's length:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;widthOfLength(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&nbsp;s.length.toString.length
</PRE>With this function, you could calculate the maximum width like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;maxWidth&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(line&nbsp;&lt;-&nbsp;lines)
  &nbsp;&nbsp;maxWidth&nbsp;=&nbsp;maxWidth.max(widthOfLength(line))
</PRE>Here you iterate through each line with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression, calculate the character width of that line's length, and, if it is larger than the current maximum, assign it to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxWidth</SPAN>, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>that was initialized to 0. (The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>max</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method,<A id=i-256644535-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which you can invoke on any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>, returns the greater of the value on which it was invoked and the value passed to it.) Alternatively, if you prefer to find the maximum without<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s, you could first find the longest line like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;longestLine&nbsp;=&nbsp;lines.reduceLeft(
  &nbsp;&nbsp;(a,&nbsp;b)&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(a.length&nbsp;&gt;&nbsp;b.length)&nbsp;a&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;b&nbsp;
  )&nbsp;
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reduceLeft</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method<A id=i2086106882-1></A><A id=i1836203449-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>applies the passed function to the first two elements in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>lines</SPAN>, then applies it to the result of the first application and the next element in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>lines</SPAN>, and so on, all the way through the list. On each such application, the result will be the longest line encountered so far, because the passed function,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(a,</SPAN>&nbsp;<SPAN class=code>b)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>if</SPAN>&nbsp;<SPAN class=code>(a.length</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>b.length)</SPAN>&nbsp;<SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>else</SPAN>&nbsp;<SPAN class=code>b</SPAN>, returns the longest of the two passed strings. "<SPAN class=code>reduceLeft</SPAN>" will return the result of the last application of the function, which in this case will be the longest string element contained in<SPAN class=code>lines</SPAN>. 
<P></P>
<P>Given this result, you can calculate the maximum width by passing the longest line to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>widthOfLength</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;maxWidth&nbsp;=&nbsp;widthOfLength(longestLine)
</PRE>
<P></P>
<P>All that remains is to print out the lines with proper formatting. You can do that like this<A id=i-880685326-1></A>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(line&nbsp;&lt;-&nbsp;lines)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numSpaces&nbsp;=&nbsp;maxWidth&nbsp;-&nbsp;widthOfLength(line)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;padding&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>&nbsp;*&nbsp;numSpaces
  &nbsp;&nbsp;print(padding&nbsp;+&nbsp;line.length&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;|&nbsp;"</SPAN>+&nbsp;line)
  }
</PRE>In this<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression, you once again iterate through the lines. For each line, you first calculate the number of spaces required before the line length and assign it to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numSpaces</SPAN>. Then you create a string containing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numSpaces</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>spaces with the expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"</SPAN>&nbsp;<SPAN class=code>"</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>numSpaces</SPAN>. Finally, you print out the information with the desired formatting. The entire script looks as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:from-file-last">Listing 3.11</A>: 
<P></P>
<P><A name=lst:from-file-last></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.io.Source
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;widthOfLength(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&nbsp;s.length.toString.length
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(args.length&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;lines&nbsp;=&nbsp;Source.fromFile(args(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)).getLines.toList
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;longestLine&nbsp;=&nbsp;lines.reduceLeft(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a,&nbsp;b)&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(a.length&nbsp;&gt;&nbsp;b.length)&nbsp;a&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;b&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;maxWidth&nbsp;=&nbsp;widthOfLength(longestLine)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(line&nbsp;&lt;-&nbsp;lines)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numSpaces&nbsp;=&nbsp;maxWidth&nbsp;-&nbsp;widthOfLength(line)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;padding&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>&nbsp;*&nbsp;numSpaces
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(padding&nbsp;+&nbsp;line.length&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;|&nbsp;"</SPAN>+&nbsp;line)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;Console.err.println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Please&nbsp;enter&nbsp;filename"</SPAN>)
</PRE>
<H5>Listing 3.11 - Printing formatted character counts for the lines of a file.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Conclusion</H3>
<P>With the knowledge you've gained in this chapter, you should already be able to get started using Scala for small tasks, especially scripts. In future chapters, we will dive into more detail in these topics, and introduce other topics that weren't even hinted at here.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 3:</H4>
<P><A name=footnote3-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>to</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method actually returns not an array but a different kind of sequence, containing the values 0, 1, and 2, which the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression iterates over. Sequences and other collections will be described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html">Chapter 17</A>.</P>
<P><A name=footnote3-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Variable-length argument lists, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">repeated parameters</EM>, are described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#sec:repeated-parameters">Section 8.8</A>.</P>
<P><A name=footnote3-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You don't need to say<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN>&nbsp;<SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>because "<SPAN class=code>List.apply()</SPAN>" is defined as a factory method on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">companion object</EM>. You'll read more on companion objects in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/classes-and-objects.html#sec:singleton-objects">Section 4.3</A>.</P>
<P><A name=footnote3-4>[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The reason you need<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>at the end is that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined on class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. If you try to just say<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>3</SPAN>, it won't compile because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>3</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>, which doesn't have a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.</P>
<P><A name=footnote3-5>[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Although conceptually you could create tuples of any length, currently the Scala library only defines them up to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tuple22</SPAN>.</P>
<P><A name=footnote3-6>[6]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Because the set in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-mutable-set">Listing 3.6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is mutable, there is no need to reassign<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>movieSet</SPAN>, which is why it can be a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>. By contrast, using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the immutable set in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-immutable-set">Listing 3.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>required reassigning<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>jetSet</SPAN>, which is why it must be a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>.<A id=i877592417-1></A></P>
<P><A name=footnote3-7>[7]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The explicit type parameterization,<A id=i-219390285-2></A><A id=i-24732165-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>"<SPAN class=code>[Int,</SPAN>&nbsp;<SPAN class=code>String]</SPAN>", is required in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-mutable-map">Listing 3.7</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>because without any values passed to the factory method, the compiler is unable to infer the map's type parameters. By contrast, the compiler can infer the type parameters from the values passed to the map factory shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#lst:init-immutable-map">Listing 3.8</A>, thus no explicit type parameters are needed.</P>
<P><A name=footnote3-8>[8]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The Scala mechanism that allows you to invoke<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on any object,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">implicit conversion</EM>, will be covered in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html">Chapter 21</A>.</P></DIV>