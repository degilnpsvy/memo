<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 1 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">A Scalable Language</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>The name Scala stands for "scalable language." The language is so named because it was designed to grow with the demands of its users. You can apply Scala to a wide range of programming tasks, from writing small scripts to building large systems.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-1">[1]</A></P>
<P>Scala is easy to get into. It runs on the standard Java platform and interoperates<A id=i648458520-1></A><A id=i239541118-1></A><A id=i1157110682-1></A><A id=i1003002536-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>seamlessly with all Java libraries. It's quite a good language for writing scripts that pull together Java components. But it can apply its strengths even more when used for building large systems and frameworks of reusable components.</P>
<P>Technically, Scala is a blend of object-oriented and functional programming concepts in a statically typed language<A id=i-1150036974-1></A><A id=i717865003-1></A>. The fusion of object-oriented and functional programming shows up in many different aspects of Scala; it is probably more pervasive than in any other widely used language. The two programming styles have complementary strengths when it comes to scalability. Scala's functional programming constructs make it easy to build interesting things quickly from simple parts. Its object-oriented constructs make it easy to structure larger systems and to adapt them to new demands. The combination of both styles in Scala makes it possible to express new kinds of programming patterns and component abstractions. It also leads to a legible and concise programming style. And because it is so malleable, programming in Scala can be a lot of fun.</P>
<P>This initial chapter answers the question, "Why Scala?" It gives a high-level view of Scala's design and the reasoning behind it. After reading the chapter you should have a basic feel for what Scala is and what kinds of tasks it might help you accomplish. Although this book is a Scala tutorial, this chapter isn't really part of the tutorial. If you're eager to start writing some Scala code, you should jump ahead to<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html">Chapter 2</A>.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=1.1></A>1.1 A language that grows on you<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#1.1">link</A>]</SPAN></H3>
<P><A name=sec:a-language-that-grows-on-you></A></P>
<P>Programs of different sizes tend to require different programming constructs. Consider, for example, the following small Scala program:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;capital&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"US"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Washington"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"France"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Paris"</SPAN>)
  <BR>  capital&nbsp;+=&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Japan"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Tokyo"</SPAN>)
  <BR>  println(capital(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"France"</SPAN>))&nbsp;
</PRE>This program sets up a map from countries to their capitals, modifies the map by adding a new binding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>("Japan"</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>"Tokyo")</SPAN>, and prints the capital associated with the country France.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-2">[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The notation in this example is high-level, to the point, and not cluttered with extraneous semicolons or type annotations.<A id=i-2107785776-1></A><A id=i1449766718-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Indeed, the feel is that of a modern "scripting" language like Perl,<A id=i389811529-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Python,<A id=i-1190645252-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>or Ruby.<A id=i-1999895874-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>One common characteristic of these languages, which is relevant for the example above, is that they each support an "associative map" construct<A id=i733051324-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the syntax of the language. 
<P></P>
<P>Associative maps are very useful because they help keep programs legible and concise. However, sometimes you might not agree with their "one size fits all" philosophy, because you need to control the properties of the maps you use in your program in a more fine-grained way. Scala gives you this fine-grained control if you need it, because maps in Scala are not language syntax. They are library abstractions that you can extend and adapt.</P>
<P>In the above program, you'll get a default<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>implementation, but you can easily change that. You could for example specify a particular implementation, such as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or a<SPAN class=code>TreeMap</SPAN>, or you could specify that the map should be thread-safe, by<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">mixing in</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SynchronizedMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g110621198"><EM style="FONT-STYLE: italic">trait</EM></A>. You<A id=i181041576-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>could specify a default value for the map, or you could override any other method of the map you create. In each case, you can use the same easy access syntax for maps as in the example above.</P>
<P>This example shows that Scala can give you both convenience and flexibility. Scala has a set of convenient constructs that help you get started quickly and let you program in a pleasantly concise style. At the same time, you have the assurance that you will not outgrow the language. You can always tailor the program to your requirements, because everything is based on library modules that you can select and adapt as needed.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Growing new types</H4>
<P><A name=sec:growing-new-types></A></P>
<P>Eric Raymond<A id=i-1761921411-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>introduced the cathedral and bazaar as two metaphors of software development.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-3">[3]</A><A id=i-1761921411-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The cathedral is a near-perfect building that takes a long time to build. Once built, it stays unchanged for a long time. The bazaar, by contrast, is adapted and extended each day by the people working in it. In Raymond's work the bazaar is a metaphor for open-source software development. Guy Steele noted in a talk on "growing a language" that the same distinction can be applied to language design.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-4">[4]</A><A id=i1916394333-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Scala is much more like a bazaar than a cathedral, in the sense that it is designed to be extended and adapted by the people programming in it. Instead of providing all constructs you might ever need in one "perfectly complete" language, Scala puts the tools for building such constructs into your hands.<A id=i294325658-1></A></P>
<P>Here's an example. Many applications need a type of integer that can become arbitrarily large without overflow or "wrap-around" of arithmetic operations. Scala defines such a type in library class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.BigInt</SPAN>.<A id=i1989635823-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Here is the definition of a method using that type, which calculates the factorial of a passed integer value:<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-5">[5]</A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;factorial(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BigInt</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BigInt</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;x&nbsp;*&nbsp;factorial(x&nbsp;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
</PRE>Now, if you call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>factorial(30)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>you would get:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=literal style="COLOR: rgb(205,123,0)">265252859812191058636308480000000</SPAN>
</PRE><SPAN class=code>BigInt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>looks like a built-in type, because you can use integer literals and operators such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with values of that type. Yet it is just a class that happens to be defined in Scala's standard library.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-6">[6]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>If the class were missing, it would be straightforward for any Scala programmer to write an implementation, for instance, by wrapping Java's class<SPAN class=code>java.math.BigInteger</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(in fact that's how Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BigInt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class is implemented).<A id=i1854396478-1></A> 
<P></P>
<P>Of course, you could also use Java's class directly. But the result is not nearly as pleasant, because although Java allows you to create new types, those types don't feel much like native language support:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;java.math.BigInteger
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;factorial(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BigInteger</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BigInteger</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;==&nbsp;BigInteger.ZERO)
  &nbsp;&nbsp;&nbsp;&nbsp;BigInteger.ONE
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;x.multiply(factorial(x.subtract(BigInteger.ONE)))
</PRE><SPAN class=code>BigInt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is representative<SPAN class=Apple-converted-space>&nbsp;</SPAN>of many other number-like types&#8212;big decimals, complex numbers, rational numbers, confidence intervals, polynomials&#8212;the list goes on. Some programming languages implement some of these types natively. For instance, Lisp,<A id=i-503250946-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Haskell,<A id=i-1250113500-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and Python<A id=i-1190645252-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>implement big integers; Fortran<A id=i1138419364-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and Python implement complex numbers. But any language that attempted to implement all of these abstractions at the same time would simply become too big to be manageable. What's more, even if such a language were to exist, some applications would surely benefit from other number-like types that were not supplied. So the approach of attempting to provide everything in one language doesn't scale very well. Instead, Scala allows users to grow and adapt the language in the directions they need by defining easy-to-use libraries that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">feel</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>like native language support. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Growing new control constructs</H4>
<P>The previous example demonstrates that Scala lets you add new types that can be used as conveniently as built-in types. The same extension principle also applies to control structures. This kind of extensibility is illustrated by Scala's API for "actor-based" concurrent programming.</P>
<P>As multicore<A id=i-1206501288-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>processors proliferate in the coming years, achieving acceptable performance may increasingly require that you exploit more<A id=i-2128194469-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>parallelism in your applications. Often, this will mean rewriting your code so that computations are distributed over several concurrent threads. Unfortunately, creating dependable multi-threaded applications has proven challenging in practice. Java's threading model is built around shared memory and locking, a model that is often difficult to reason about, especially as systems scale up in size and complexity. It is hard to be sure you don't have a race condition or deadlock lurking&#8212;something that didn't show up during testing, but<A id=i503639951-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>might just show up in production. An arguably safer alternative is a message passing architecture such as the "actors" approach used by the Erlang<A id=i-1028679267-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>programming language.<A id=i-122023144-1></A></P>
<P>Java comes with a rich, thread-based concurrency library. Scala programs can use it like any other Java API. However, Scala also offers an additional library that essentially implements Erlang's actor model.<A id=i-1422944994-1></A><A id=i1338746414-1></A></P>
<P>Actors are concurrency abstractions that can be implemented on top of threads. They communicate by sending messages to each other. An actor can perform two basic operations, message send and receive. The send operation, denoted by an exclamation point<A id=i1971465955-1></A><A id=i-1037720528-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<SPAN class=code>!</SPAN>),<SPAN class=Apple-converted-space>&nbsp;</SPAN>sends a message to an actor. Here's an example in which the actor is named<SPAN class=code>recipient</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  recipient&nbsp;!&nbsp;msg
</PRE>A send is asynchronous; that is, the sending actor can proceed immediately, without waiting for the message to be received and processed. Every actor has a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">mailbox</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in which incoming messages are queued. An actor handles messages that have arrived in its mailbox via a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>block:<A id=i1209206976-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  receive&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Msg1</SPAN>&nbsp;=&gt;&nbsp;...&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;handle&nbsp;Msg1</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Msg2</SPAN>&nbsp;=&gt;&nbsp;...&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;handle&nbsp;Msg2</SPAN>
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;...</SPAN>
  }
</PRE>A receive block consists of a number of cases that each query the mailbox with a message pattern. The first message in the mailbox that matches any of the cases is selected, and the corresponding action is performed on it. If the mailbox does not contain any messages that match one of the given cases, the actor suspends and waits for further incoming messages. 
<P></P>
<P>As an example, here is a simple Scala actor implementing a checksum calculator service:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  actor&nbsp;{&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;sum&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  &nbsp;&nbsp;loop&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;receive&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Data</SPAN>(bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;sum&nbsp;+=&nbsp;hash(bytes)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">GetSum</SPAN>(requester)&nbsp;=&gt;&nbsp;requester&nbsp;!&nbsp;sum
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  }
</PRE>This actor 
<P></P>
<P>first defines a local variable named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with initial value zero. It then repeatedly waits in a loop for messages, using a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>statement. If it receives a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Data</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>message, it adds a hash of the sent<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bytes</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable. If it receives a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>GetSum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>message, it sends the current value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>back to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>requester</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>using the message send<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>requester</SPAN>&nbsp;<SPAN class=code>!</SPAN>&nbsp;<SPAN class=code>sum</SPAN>. The<SPAN class=code>requester</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field is embedded in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>GetSum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>message; it usually refers<SPAN class=Apple-converted-space>&nbsp;</SPAN>to the actor that made the request.</P>
<P>We don't expect you to understand fully the actor example at this point. Rather, what's significant about this example for the topic of scalability is that neither<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>actor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>nor<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>loop</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>nor<SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>nor message send (<SPAN class=code>!</SPAN>) are built-in operations in Scala. Even though<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>actor</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>loop</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>look and act very much like built-in control constructs such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops, they are in fact methods defined in Scala's actors library. Likewise, even though `<SPAN class=code>!</SPAN>' looks like a built-in operator, it too is just a method defined in the actors library. All four of these constructs are completely independent of the Scala programming language.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>block and send (<SPAN class=code>!</SPAN>) syntax look in Scala much like they look in Erlang, but in Erlang, these constructs are built into the language. Scala also implements most of Erlang's other concurrent programming constructs, such as monitoring failed actors and time-outs. All in all, actors have turned out to be a very pleasant means for expressing concurrent and distributed computations. Even though they are defined in a library, actors feel like an integral part of the Scala language.</P>
<P>This example illustrates that you can "grow" the Scala language in new directions even as specialized as concurrent programming. To be sure, you need good architects and programmers to do this. But the crucial thing is that it is feasible&#8212;you can design and implement abstractions in Scala that address radically new application domains, yet still feel like native language support.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=1.2></A>1.2 What makes Scala scalable?<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#1.2">link</A>]</SPAN></H3>
<P>Scalability is influenced by many factors, ranging from syntax details<A id=i741587120-1></A><A id=i-885663216-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>to component abstraction constructs. If we were forced to name just one aspect of Scala that helps scalability, though, we'd pick its combination of object-oriented and functional programming (well, we cheated, that's really two aspects, but they are intertwined).</P>
<P>Scala goes further than all other well-known languages in fusing object-oriented and functional programming into a uniform language design. For instance, where other languages might have objects and functions as two different concepts, in Scala a function value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">is</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>an object. Function types are classes that can be inherited by subclasses. This might seem nothing more than an academic nicety, but it has deep consequences for scalability. In fact the actor concept shown previously could not have been implemented without this unification of functions and objects. This section gives an overview of Scala's way of blending object-oriented and functional concepts.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Scala is object-oriented</H4>
<P>Object-oriented programming has been immensely successful. Starting<A id=i717865003-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>from Simula<A id=i1623537733-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the mid-60's and Smalltalk in the 70's, it is now available in more languages than not. In some domains objects have taken over completely. While there is not a precise definition of what object-oriented means, there is clearly something about objects that appeals to programmers.</P>
<P>In principle, the motivation for object-oriented programming is very simple: all but the most trivial programs need some sort of structure. The most straightforward way to do this is to put data and operations into some form of containers. The great idea of object-oriented programming is to make these containers fully general, so that they can contain operations as well as data, and that they are themselves values that can be stored in other containers, or passed as parameters to operations. Such containers are called objects. Alan Kay,<A id=i438821039-1></A>the inventor of Smalltalk,<A id=i-817657147-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>remarked that in this way the simplest object has the same construction principle as a full computer: it combines data with operations under a formalized interface.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-7">[7]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>So objects have a lot to do with language scalability: the same techniques apply to the construction of small as well as large programs.</P>
<P>Even though object-oriented programming has been mainstream for a long time, there are relatively few languages that have followed Smalltalk in pushing this construction principle to its logical conclusion. For instance, many languages admit values that are not objects, such as the primitive values in Java. Or they allow static fields and methods that are not members of any object. These deviations from the pure idea of object-oriented programming look quite harmless at first, but they have an annoying tendency to complicate things and limit scalability.</P>
<P>By contrast, Scala is an object-oriented language in pure form: every value is an object and every operation is a method call. For example, when you say<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala, you are actually invoking a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defined in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>. You can define methods with operator-like names that clients of your API can then use in operator notation. This is how the designer of Scala's actors API enabled you to use expressions such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>requester</SPAN>&nbsp;<SPAN class=code>!</SPAN>&nbsp;<SPAN class=code>sum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in the previous example: `<SPAN class=code>!</SPAN>' is a method of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Actor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class.</P>
<P>Scala is more advanced than most other languages when it comes to composing objects. An example is Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">traits</SPAN>. Traits are like interfaces in Java, but they can also have method implementations and even fields. Objects are constructed by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">mixin composition</SPAN>, which takes the members of a class and adds the members of a number of traits to them. In this way, different aspects of classes can be encapsulated in different traits. This looks a bit like multiple inheritance, but differs when it comes to the details. Unlike a class, a trait can add some new functionality to an unspecified superclass. This makes traits more "pluggable" than classes. In particular, it avoids the classical "diamond inheritance" problems of multiple inheritance, which arise when the same class is inherited via several different paths.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Scala is functional</H4>
<P>In addition to being a pure object-oriented language, Scala is also a<A id=i1689782844-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>full-blown functional language. The ideas of functional programming are older than (electronic) computers. Their foundation was laid in Alonzo Church's<A id=i1963891034-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>lambda calculus,<A id=i651664117-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which he developed in the 1930s. The first functional programming language was Lisp,<A id=i-503250946-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which dates from the late 50s. Other popular functional languages are Scheme,<A id=i1475575635-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>SML,<A id=i-175084922-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Erlang,<A id=i-1028679267-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Haskell,<A id=i-1250113500-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>OCaml,<A id=i-1496851060-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and F#.<A id=i724459531-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For a long time, functional programming has been a bit on the sidelines, popular in academia, but not that widely used in industry. However, recent years have seen an increased interest in functional programming languages and techniques.</P>
<P>Functional programming is guided by two main ideas.<A id=i-1849814556-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The first idea is that functions are first-class values.<A id=i-1098728772-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In a functional language, a function is a value of the same status as, say, an integer or a string. You can pass functions as arguments to other functions, return them as results from functions, or store them in variables. You can also define a function inside another function, just as you can define an integer value inside a function. And you can define functions without giving them a name, sprinkling your code with function literals as easily as you might write integer literals like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>42</SPAN>.</P>
<P>Functions that are first-class values provide a convenient means for abstracting over operations and creating new control structures.<A id=i14092899-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This generalization of functions provides great expressiveness, which often leads to very legible and concise programs. It also plays an important role for scalability. As an example, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN><A id=i1209206976-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>construct shown previously in the actor example is an invocation of a method that takes a function as argument. The code inside the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>construct is a function that is passed unexecuted into the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN>method.</P>
<P>In most traditional languages, by contrast, functions are not values. Languages that do have function values often relegate them to second-class status. For example, the function pointers of C<A id=i395906709-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and C++<A id=i916374005-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>do not have the same status as non-functional values in those languages: function pointers can only refer to global functions, they do not allow you to define first-class nested functions that refer to some values in their environment. Nor do they allow you to define unnamed function literals.</P>
<P>The second main idea of functional programming is that the operations of a program should map input values to output values rather than change data in place. To see the difference, consider the implementation of strings in Ruby<A id=i-1999895874-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and in Java.<A id=i2012001632-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In Ruby, a string is an array of characters. Characters in a string can be changed individually. For instance you can change a semicolon character in a string to a period inside the same string object. In Java and Scala, on the other hand, a string is a sequence of characters in the mathematical sense. Replacing a character in a string using an expression like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s.replace(';',</SPAN>&nbsp;<SPAN class=code>'.')</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>yields a new string object, which is different from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s</SPAN>. Another way of expressing this is that strings are immutable<A id=i507699202-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java whereas they are mutable in Ruby. So looking at just strings, Java is a functional language, whereas Ruby is not. Immutable data structures are one of the cornerstones of functional programming. The Scala libraries define many more immutable data types on top of those found in the Java APIs. For instance, Scala has immutable lists, tuples, maps, and sets.</P>
<P>Another way of stating this second idea of functional programming is that methods should not have any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">side effects</SPAN>.<A id=i18918201-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>They should communicate with their environment only by taking arguments and returning results. For instance, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>replace</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class fits this description. It takes a string and two characters and yields a new string where all occurrences of one character are replaced by the other. There is no other effect of calling<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>replace</SPAN>. Methods like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>replace</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are called<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-1825668081"><EM style="FONT-STYLE: italic">referentially transparent</EM></A>,<A id=i-1825668081-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which means that for any given input the method call could be replaced by its result without affecting the program's semantics.</P>
<P>Functional languages encourage immutable data structures and referentially transparent methods. Some functional languages even require them. Scala gives you a choice. When you want to, you can write in an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">imperative</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>style, which is what programming with mutable data and side effects is called. But Scala generally makes it easy to avoid imperative constructs when you want, because good functional alternatives exist.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=1.3></A>1.3 Why Scala?<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#1.3">link</A>]</SPAN></H3>
<P>Is Scala for you? You will have to see and decide for yourself. We have found that there are actually many reasons besides scalability to like programming in Scala. Four of the most important aspects will be discussed in this section: compatibility, brevity, high-level abstractions, and advanced static typing.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Scala is compatible</H4>
<P>Scala doesn't require you to leap backwards off the Java platform to<A id=i239541118-2></A><A id=i1128780868-1></A><A id=i1003002536-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>step forward from the Java language. It allows you to add value to existing code&#8212;to build on what you already have&#8212;because it was designed for seamless interoperability with Java.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-8">[8]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Scala programs compile to JVM bytecodes. Their run-time performance is usually on par with<A id=i1751980831-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Java programs. Scala code can call Java methods, access Java fields, inherit from Java classes, and implement Java interfaces. None of this requires special syntax, explicit interface descriptions, or glue code. In fact, almost all Scala code makes heavy use of Java libraries, often without programmers being aware of this fact.</P>
<P>Another aspect of full interoperability is that Scala heavily re-uses Java types. Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>s are represented as Java primitive integers of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>int</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Float</SPAN>s are represented as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>float</SPAN>s,<SPAN class=code>Boolean</SPAN>s as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>boolean</SPAN>s, and so on. Scala arrays are mapped to Java arrays. Scala also re-uses many of the standard Java library types. For instance, the type of a string literal<SPAN class=code>"abc"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.String</SPAN>, and a thrown exception must be a subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Throwable</SPAN>.</P>
<P>Scala not only re-uses Java's types, but also "dresses them up" to make them nicer. For instance, Scala's strings support methods like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toInt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toFloat</SPAN>, which convert the string to an integer or<A id=i183513387-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>floating-point number. So you can write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>str.toInt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Integer.parseInt(str)</SPAN>. How can this be achieved without breaking interoperability? Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class certainly has no<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toInt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method! In fact, Scala has a very general solution to solve this tension between advanced library design and interoperability. Scala lets you define<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">implicit conversions</SPAN>,<A id=i456777265-1></A><A id=i-1068906551-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which are always applied when types would not normally match up, or when non-existing members are selected. In the case above, when looking for a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toInt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method on a string, the Scala compiler will find no such member of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>, but it will find an implicit conversion that converts a Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to an instance of the Scala class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RichString</SPAN>, which does define such a member. The conversion will then be applied implicitly before performing the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toInt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation.</P>
<P>Scala code can also be invoked from Java code. This is sometimes a bit more subtle, because Scala is a richer language than Java, so some of Scala's more advanced features need to be encoded before they can be mapped to Java.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combining-scala-and-java.html">Chapter 29</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>explains the details.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Scala is concise</H4>
<P>Scala programs tend to be short. Scala programmers have reported<A id=i-486479055-1></A><A id=i-1605476771-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>reductions in number of lines of up to a factor of ten compared to Java. These might be extreme cases. A more conservative estimate would be that a typical Scala program should have about half the number of lines of the same program written in Java. Fewer lines of code mean not only less typing, but also less effort at reading and understanding programs and fewer possibilities of defects. There are several factors that contribute to this reduction in lines of code.</P>
<P>First, Scala's syntax avoids some of the boilerplate that burdens Java programs. For instance, semicolons are optional in Scala and are usually left out. There are also several other areas where Scala's syntax is less noisy. As an example, compare how you write classes and constructors in Java and Scala. In Java, a class with a constructor often looks like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  //&nbsp;this&nbsp;is&nbsp;Java
  class&nbsp;MyClass&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;index;
  &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;MyClass(int&nbsp;index,&nbsp;String&nbsp;name)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.index&nbsp;=&nbsp;index;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  }
</PRE>
<P></P>
<P>In Scala, you would likely write this instead:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">MyClass</SPAN>(index:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)
</PRE>
<P>Given this code, the Scala compiler will produce a class that has two private instance variables, an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>index</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>name</SPAN>, and a constructor that takes initial values for those variables as parameters. The code of this constructor will initialize the two instance variables with the values passed as parameters. In short, you get essentially the same functionality as the more verbose Java version.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-9">[9]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The Scala class is quicker to write, easier to read, and most importantly, less error prone than the Java class.</P>
<P>Scala's type inference is another factor that contributes to its conciseness. Repetitive type information can be left out, so programs become less cluttered and more readable.</P>
<P>But probably the most important key to compact code is code you don't have to write because it is done in a library for you. Scala gives you many tools to define powerful libraries that let you capture and factor out common behavior. For instance, different aspects of library classes can be separated out into traits, which can then be mixed together in flexible ways. Or, library methods can be parameterized with operations, which lets you define constructs that are, in effect, your own control structures. Together, these constructs allow the definition of libraries that are both high-level and flexible to use.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Scala is high-level</H4>
<P><A name=subsec:scala-is-high-level></A></P>
<P>Programmers are constantly grappling with complexity.<A id=i1993414356-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>To program productively, you must understand the code on which you are working. Overly complex code has been the downfall of many a software project. Unfortunately, important software usually has complex requirements. Such complexity can't be avoided; it must instead be managed.</P>
<P>Scala helps you manage complexity by letting you raise the level of abstraction in the interfaces you design and use. As an example, imagine you have a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>name</SPAN>, and you want to find out whether or not that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains an upper case character. In Java, you might write this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  //&nbsp;this&nbsp;is&nbsp;Java
  boolean&nbsp;nameHasUpperCase&nbsp;=&nbsp;false;
  for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;name.length();&nbsp;++i)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Character.isUpperCase(name.charAt(i)))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nameHasUpperCase&nbsp;=&nbsp;true;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  }
</PRE>
<P></P>
<P>Whereas in Scala, you could write this:<A id=i-1394554846-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;nameHasUpperCase&nbsp;=&nbsp;name.exists(_.isUpperCase)&nbsp;
</PRE>
<P>The Java code treats strings as low-level entities that are stepped through character by character in a loop. The Scala code treats the same strings as higher-level sequences of characters that can be queried with<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-1348032073"><EM style="FONT-STYLE: italic">predicates</EM></A>.<A id=i1160678812-1></A><A id=i-468400421-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Clearly the Scala code is much shorter and&#8212;for trained eyes&#8212;easier to understand than the Java code. So the Scala code weighs less heavily on the total complexity budget. It also gives you less opportunity to make mistakes.</P>
<P>The predicate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_.isUpperCase</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an example of a function literal in Scala.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-10">[10]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It describes a function that takes a character argument (represented by the underscore character), and tests whether it is an upper case letter.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-11">[11]</A></P>
<P>In principle, such control abstractions are possible in Java as well. You'd need to define an interface that contains a method with the abstracted functionality. For instance, if you wanted to support querying over strings, you might invent an interface, named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CharacterProperty</SPAN>, which has just one method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hasProperty</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  //&nbsp;this&nbsp;is&nbsp;Java
  interface&nbsp;CharacterProperty&nbsp;{
  &nbsp;&nbsp;boolean&nbsp;hasProperty(char&nbsp;ch);
  }
</PRE>With that interface you could formulate a method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java: It takes a string and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CharacterProperty</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and returns true if there's a character in the string that satisfies the property. You could then invoke<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as follows:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  //&nbsp;this&nbsp;is&nbsp;Java
  exists(name,&nbsp;new&nbsp;CharacterProperty()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;hasProperty(char&nbsp;ch)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Character.isUpperCase(ch);
  &nbsp;&nbsp;&nbsp;&nbsp;}
  });
</PRE>However, all this feels rather heavy. So heavy, in fact, that most Java programmers would not bother. They would just write out the loops and live with the increased complexity in their code. On the other hand, function literals in Scala are really lightweight, so they are used frequently. As you get to know Scala better you'll find more and more opportunities to define and use your own control abstractions. You'll find that this helps avoid code duplication and thus keeps your programs shorter and clearer.<A id=i-1950695486-1></A> 
<P></P>
<P>Scala's functional programming style also offers high-level<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">reasoning principles</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for programming. The key idea is that functions are referentially transparent&#8212;a function application is characterized only by its result. You can, therefore, freely exchange a function application with the function's right hand side (<I>i.e.</I>, its body, which follows the equals sign) without worrying about any hidden side effects. This principle gives many useful laws that you can employ to better understand or to refactor your code. As an example, take once more the<SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method described above. This method should satisfy the following law: for every sequence<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and for every pair of predicates<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>it should hold that</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  s.exists(p)&nbsp;||&nbsp;s.exists(q)&nbsp;==&nbsp;s.exists(x&nbsp;=&gt;&nbsp;p(x)&nbsp;||&nbsp;q(x))&nbsp;
</PRE>That is, querying the same sequence with two predicates<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and or-ing the results is the same as querying with a single predicate that tests at the same time for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN>. A law like this is clearly useful for writing and refactoring programs. However, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>had side effects, it would in general not be correct to assume such a law because the left hand side executes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>twice for each sequence element whereas the right hand side executes it only once per element. So this is an example where purely functional code leads to more laws that are useful for understanding and refactoring your code. 
<P></P>
<P>The functional programming style also eliminates aliasing problems encountered in imperative programming. Aliasing happens when multiple variables refer to the same object. It gives rise to some thorny questions and complications. For instance, does changing a field<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>r.x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>also affect<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s.x</SPAN>? It does if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>r</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>refer to the same object. In practice it is often very difficult to trace such aliases. Immutable data, on the other hand, can be shared freely, because a copy is indistinguishable from a shared reference. This advantage is particularly crucial when writing concurrent code. (This is why Java has immutable strings.)</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Scala is statically typed</H4>
<P>A static type system classifies variables and expressions according to<A id=i587655017-1></A><A id=i1417392593-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>the kinds of values they hold and compute. Scala stands out as a language with a very advanced static type system. Starting from a system of nested class types much like Java's, it allows you to parameterize types with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">generics</SPAN>, to combine types using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">intersections</SPAN>, and to hide details of types using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">abstract types</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-12">[12]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>These give a strong foundation for building and composing your own types, so that you can design interfaces that are at the same time safe and flexible to use.</P>
<P>If you like dynamic languages such as Perl, Python, Ruby, or Groovy,<A id=i716433724-2></A><A id=i2012339474-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>you might find it a bit strange that Scala's static type system is listed as one of its strong points. After all, the absence of a static type system has been cited by some as a major advantage of dynamic languages. The most common arguments against static types are that they make programs too verbose, prevent programmers from expressing themselves as they wish, and make impossible certain patterns of dynamic modifications of software systems. However, often these arguments do not go against the idea of static types in general, but against specific type systems, which are perceived to be too verbose or too inflexible. For instance, Alan Kay, the inventor of the Smalltalk language, once remarked: "I'm not against types, but I don't know of any type systems that aren't a complete pain, so I still like dynamic typing."<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-13">[13]</A></P>
<P>We<SPAN class=Apple-converted-space>&nbsp;</SPAN>hope to convince you in this book that Scala's type system is far from being a "complete pain." In fact, it addresses nicely two of the usual concerns about static typing: verbosity is avoided through type inference and flexibility is gained through pattern matching and several new ways to write and compose types. With these impediments out of the way, the classical benefits of static type systems can be better appreciated. Among the most important of these benefits are verifiable properties of program abstractions, safe refactorings, and better documentation.</P>
<P><B><SPAN style="FONT-STYLE: italic">Verifiable properties.</SPAN></B><SPAN class=Apple-converted-space>&nbsp;</SPAN>Static type systems can prove the absence<A id=i-1604465616-1></A><A id=i-1721532539-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>of certain run-time errors. For instance, they can prove properties like: booleans are never added to integers; private variables are not accessed from outside their class; functions are applied to the right number of arguments; only strings are ever added to a set of strings.</P>
<P>Other kinds of errors are not detected by today's static type systems. For instance, they will usually not detect non-terminating functions, array bounds violations, or divisions by zero. They will also not detect that your program does not conform to its specification (assuming there is a spec, that is!). Static type systems have therefore been dismissed by some as not being very useful. The argument goes that since such type systems can only detect simple errors, whereas unit tests provide more extensive coverage, why bother with static types at all? We believe that these arguments miss the point. Although a static type system certainly cannot<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">replace</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>unit testing, it can reduce the number of unit tests needed by taking care of some properties that would otherwise need to be tested. Likewise, unit testing can not replace static typing. After all, as Edsger Dijkstra said,<A id=i-765987414-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>testing can only prove the presence of errors, never their absence.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-14">[14]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>So the guarantees that static typing gives may be simple, but they are real guarantees of a form no amount of testing can deliver.</P>
<P><B><SPAN style="FONT-STYLE: italic">Safe refactorings.</SPAN></B><SPAN class=Apple-converted-space>&nbsp;</SPAN>A static type system provides a safety<A id=i1149458246-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>net that lets you make changes to a codebase with a high degree of confidence. Consider for instance a refactoring that adds an additional parameter to a method. In a statically typed language you can do the change, re-compile your system and simply fix all lines that cause a type error. Once you have finished with this, you are sure to have found all places that need to be changed. The same holds for many other simple refactorings like changing a method name, or moving methods from one class to another. In all cases a static type check will provide enough assurance that the new system works just like the old.</P>
<P><B><SPAN style="FONT-STYLE: italic">Documentation.</SPAN></B><SPAN class=Apple-converted-space>&nbsp;</SPAN>Static types are program documentation that is checked by the compiler for correctness. Unlike a normal comment, a type annotation<A id=i-2107785776-2></A><A id=i1449766718-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>can never be out of date (at least not if the source file that contains it has recently passed a compiler). Furthermore, compilers and integrated development environments can make use of type annotations to provide better context help. For instance, an integrated development environment can display all the members available for a selection by determining the static type of the expression on which the selection is made and looking up all members of that type.</P>
<P>Even though static types are generally useful for program documentation, they can sometimes be annoying when they clutter the program. Typically, useful documentation is what readers of a program cannot easily derive by themselves. In a method definition like:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;f(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&nbsp;...&nbsp;&nbsp;
</PRE>it's useful to know that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN>'s argument should be a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>. On the other hand, at least one of the two annotations in the following example is annoying:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HashMap[Int, String]</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HashMap[Int, String]</SPAN>()
</PRE>Clearly, it should be enough to say just once that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>s as keys and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>s as values; there's no need to repeat the same phrase twice. 
<P></P>
<P>Scala has a very sophisticated type inference system that lets you omit almost all<A id=i-219390285-1></A><A id=i-24732165-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>type information that's usually considered annoying.<SPAN class=Apple-converted-space>&nbsp;</SPAN>In the previous example, the following two less annoying alternatives would work just as well:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HashMap[Int, String]</SPAN>()
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map[Int, String]</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HashMap</SPAN>()&nbsp;
</PRE>Type inference in Scala can go quite far. In fact, it's not uncommon for user code to have no explicit types at all. Therefore, Scala programs often look a bit like programs written in a dynamically typed<A id=i716433724-3></A><A id=i2012339474-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>scripting language. This holds particularly for client application code, which glues together pre-written library components. It's less true for the library components themselves, because these often employ fairly sophisticated types to allow flexible usage patterns. This is only natural. After all, the type signatures of the members that make up the interface of a reusable component should be explicitly given, because they constitute an essential part of the contract between the component and its clients. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=1.4></A>1.4 Scala's roots<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#1.4">link</A>]</SPAN></H3>
<P>Scala's design has been influenced by many programming languages and<A id=i-1148185415-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>ideas in programming language research. In fact, only a few features of Scala are genuinely new; most have been already applied in some form in other languages. Scala's innovations come primarily from how its constructs are put together. In this section, we list the main influences on Scala's design. The list cannot be exhaustive&#8212;there are simply too many smart ideas around in programming language design to enumerate them all here.</P>
<P>At the surface level, Scala adopts a large part of the syntax of Java and C#, which in turn borrowed most of their syntactic conventions from C and C++. Expressions, statements, and blocks are mostly as in Java, as is the syntax of classes, packages and imports.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-15">[15]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Besides syntax, Scala adopts other elements of Java, such as its basic types, its class libraries, and its execution model.</P>
<P>Scala also owes much to other languages. Its uniform object model was pioneered by Smalltalk and taken up subsequently by Ruby. Its idea of universal nesting (almost every construct in Scala can be nested inside any other construct) is also present in Algol, Simula, and, more recently in Beta and gbeta. Its uniform access principle for method invocation and field selection comes from Eiffel. Its approach to functional programming is quite similar in spirit to the ML family of languages, which has SML, OCaml, and F# as prominent members. Many higher-order functions in Scala's standard library are also present in ML or Haskell. Scala's implicit parameters were motivated by Haskell's type classes; they achieve analogous results in a more classical object-oriented setting. Scala's actor-based concurrency library was heavily inspired by Erlang.</P>
<P>Scala is not the first language to emphasize scalability and extensibility. The historic root of extensible languages that can span different application areas is Peter Landin's 1966 paper<A id=i-440292728-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>"The Next 700 Programming Languages."<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-16">[16]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>(The language described in this paper, Iswim, stands beside Lisp as one of the pioneering functional languages.) The specific idea of treating an infix operator as a function can be traced back to Iswim and Smalltalk. Another important idea is to permit a function literal (or block) as a parameter, which enables libraries to define control structures. Again, this goes back to Iswim and Smalltalk. Smalltalk and Lisp both have<SPAN class=Apple-converted-space>&nbsp;</SPAN>a flexible syntax that has been applied extensively for building internal domain-specific languages.<A id=i-837225081-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>C++ is another scalable language that can be adapted and extended through operator overloading and its template system; compared to Scala it is built on a lower-level, more systems-oriented core. Scala is also not the first language to integrate functional and object-oriented programming, although it probably goes furthest in this direction. Other languages that have integrated some elements of functional programming into OOP include Ruby, Smalltalk, and Python. On the Java platform, Pizza,<A id=i-1058604016-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Nice,<A id=i-241957733-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and Multi-Java<A id=i-1250478654-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>have all extended a Java-like core with functional ideas. There are also primarily functional languages that have acquired an object system; examples are OCaml, F#, and PLT-Scheme.<A id=i-1496851060-2></A><A id=i724459531-2></A><A id=i383911262-1></A></P>
<P>Scala has also contributed some innovations to the field of programming languages. For instance, its abstract types provide a more object-oriented alternative to generic types, its traits allow for flexible component assembly, and its extractors provide a representation-independent way to do pattern matching. These innovations have been presented in papers at programming language conferences in recent years.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#footnote1-17">[17]</A></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=1.5></A>1.5 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#1.5">link</A>]</SPAN></H3>
<P>In this chapter, we gave you a glimpse of what Scala is and how it might help you in your programming. To be sure, Scala is not a silver bullet that will magically make you more productive. To advance, you will need to apply Scala artfully, and that will require some learning and practice. If you're coming to Scala from Java, the most challenging aspects of learning Scala may involve Scala's type system (which is richer than Java's) and its support for functional programming. The goal of this book is to guide you gently up Scala's learning curve, one step at a time. We think you'll find it a rewarding intellectual experience that will expand your horizons and make you think differently about program design. Hopefully, you will also gain pleasure and inspiration from programming in Scala.</P>
<P>In the next chapter, we'll get you started writing some Scala code.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 1:</H4>
<P><A name=footnote1-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Scala is pronounced<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">skah-lah</EM>.<A id=i-269622320-1></A><A id=i341209608-1></A></P>
<P><A name=footnote1-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Please bear with us if you don't understand all details of this program. They will be explained in the next two chapters.</P>
<P><A name=footnote1-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Raymond,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">The Cathedral and the Bazaar</EM>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#raymond:cathedral">raymond:cathedral</A></P>
<P><A name=footnote1-4>[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Steele, "Growing a language."<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#steele:growing">steele:growing</A><A id=i-1799668152-1></A></P>
<P><A name=footnote1-5>[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>factorial(x)</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x!</SPAN>&nbsp;in mathematical notation, is the result of computing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>...</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>x</SPAN>, with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0!</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defined to be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>.</P>
<P><A name=footnote1-6>[6]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Scala comes with a standard library, some of which will be covered in this book. For more information, you can also consult the library's Scaladoc documentation, which is available in the distribution and online at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>http://www.scala-lang.org</SPAN>.</P>
<P><A name=footnote1-7>[7]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Kay, "The Early History of Smalltalk."<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#kay:early">kay:early</A></P>
<P><A name=footnote1-8>[8]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>There is also a Scala variant that runs on the .NET platform, but the JVM variant currently has better support.<A id=i77181-1></A></P>
<P><A name=footnote1-9>[9]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The only real difference is that the instance variables produced in the Scala case will be final. You'll learn how to make them non-final in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#sec:parametric-fields">Section 10.6</A>.</P>
<P><A name=footnote1-10>[10]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>A function literal can be called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">predicate</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>if its result type is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN>.</P>
<P><A name=footnote1-11>[11]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This use of the underscore as a placeholder for arguments is described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#sec:placeholder-syntax">Section 8.5</A>.</P>
<P><A name=footnote1-12>[12]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Generics are discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html">Chapter 19</A>, intersections in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html">Chapter 12</A>, and abstract types in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html">Chapter 20</A>.</P>
<P><A name=footnote1-13>[13]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Kay, in an email on the meaning of object-oriented programming.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#kay:dynamic">kay:dynamic</A></P>
<P><A name=footnote1-14>[14]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Dijkstra, "Notes on Structured Programming," 7.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#dijkstra:notes">dijkstra:notes</A></P>
<P><A name=footnote1-15>[15]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The major deviation from Java concerns the syntax for type annotations&#8212;it's "<SPAN class=code>variable:</SPAN>&nbsp;<SPAN class=code>Type</SPAN>" instead of "<SPAN class=code>Type</SPAN>&nbsp;<SPAN class=code>variable</SPAN>" in Java. Scala's postfix type syntax resembles Pascal, Modula-2, or Eiffel.<A id=i-357661779-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The main reason for this deviation has to do with type inference, which often lets you omit the type of a variable or the return type of a method. Using the "<SPAN class=code>variable:</SPAN>&nbsp;<SPAN class=code>Type</SPAN>" syntax this is easy&#8212;just leave out the colon and the type. But in C-style "<SPAN class=code>Type</SPAN>&nbsp;<SPAN class=code>variable</SPAN>" syntax you cannot simply leave off the type&#8212;there would be no marker to start the definition anymore. You'd need some alternative keyword to be a placeholder for a missing type (C# 3.0, which does some type inference, uses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for this purpose). Such an alternative keyword feels more ad-hoc and less regular than Scala's approach.</P>
<P><A name=footnote1-16>[16]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Landin, "The Next 700 Programming Languages."<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#landin:next">landin:next</A></P>
<P><A name=footnote1-17>[17]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For more information, see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#odersky-et-al:ecoop03">odersky-et-al:ecoop03</A>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#odersky:sca">odersky:sca</A>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#scala:ecoop07">scala:ecoop07</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the bibliography.</P></DIV>