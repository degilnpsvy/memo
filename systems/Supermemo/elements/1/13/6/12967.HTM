<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 2 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">First Steps in Scala</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>It's time to write some Scala code. Before we start on the in-depth Scala tutorial, we put in two chapters that will give you the big picture of Scala, and most importantly, get you writing code. We encourage you to actually try out all the code examples presented in this chapter and the next as you go. The best way to start learning Scala is to program in it.</P>
<P>To run the examples in this chapter, you should have a standard Scala installation. To get one, go to<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.scala-lang.org/downloads">http://www.scala-lang.org/downloads</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and follow the directions for your platform.<A id=i314057734-1></A><A id=i840520690-1></A>You can also use a Scala plug-in for Eclipse<A id=i-1327804143-1></A>, IntelliJ<A id=i933444833-1></A>, or NetBeans<A id=i-899073402-1></A><A id=i-1715822447-1></A>, but for the steps in this chapter, we'll assume you're using the Scala distribution from<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scala-lang.org">scala-lang.org</A>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#footnote2-1">[1]</A></P>
<P>If you are a veteran programmer new to Scala, the next two chapters should give you enough understanding to enable you to start writing useful programs in Scala. If you are less experienced, some of the material may seem a bit mysterious to you. But don't worry. To get you up to speed quickly, we had to leave out some details. Everything will be explained in a less "fire hose" fashion in later chapters. In addition, we inserted quite a few footnotes in these next two chapters<SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN>point you to later sections of the book where you'll find more detailed explanations.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=step1></A>Step 1. Learn to use the Scala interpreter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#step1">link</A>]</SPAN></H3>
<P>The easiest way to get started with Scala is by using the Scala<A id=i-2008009094-1></A><A id=i-162949284-1></A><A id=i-2032368478-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>interpreter, an interactive "shell" for writing Scala expressions and programs. Simply type an expression into the interpreter and it will evaluate the expression and print the resulting value. The interactive shell for Scala is simply called<A id=i1638768746-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN>. You use it by typing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>at a command prompt:<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#footnote2-2">[2]</A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala
  <SPAN class=output style="COLOR: rgb(90,0,0)">Welcome&nbsp;to&nbsp;Scala&nbsp;version&nbsp;2.7.2.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Type&nbsp;in&nbsp;expressions&nbsp;to&nbsp;have&nbsp;them&nbsp;evaluated.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Type&nbsp;:help&nbsp;for&nbsp;more&nbsp;information.</SPAN>
  <BR>  scala&gt;&nbsp;
</PRE>
<P></P>
<P>After you type an expression, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>2</SPAN>, and hit enter:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
</PRE>
<P>The interpreter will print:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
</PRE>
<P>This line includes:</P>
<UL>
<LI>an automatically generated or user-defined name to refer to the computed value (<SPAN class=code>res0</SPAN>, which means result 0), 
<LI>a colon (<SPAN class=code>:</SPAN>), followed by the type of the expression (<SPAN class=code>Int</SPAN>), 
<LI>an equals sign (<SPAN class=code>=</SPAN>), 
<LI>the value resulting from evaluating the expression (<SPAN class=code>3</SPAN>).</LI></UL>
<P>The type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>names the class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN>. Packages in Scala are similar to packages in Java: they partition the global namespace<A id=i374717171-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and provide a mechanism for information hiding.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#footnote2-3">[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Values of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>correspond to Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>values. More generally, all of Java's primitive types have corresponding classes in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>package. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>corresponds to Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>boolean</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Float</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>corresponds to Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>float</SPAN>. And when you compile your Scala code to Java bytecodes, the Scala compiler will use Java's primitive types where possible to give you the performance benefits<A id=i884498802-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the primitive types.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>resX</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>identifier may be used in later lines. For instance, since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>res0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was set to 3 previously,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>res0</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>3</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>9</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;res0&nbsp;*&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;Int&nbsp;=&nbsp;9</SPAN>
</PRE>
<P></P>
<P>To print the necessary, but not sufficient,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Hello,</SPAN>&nbsp;<SPAN class=code>world!</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>greeting, type:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello,&nbsp;world!"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">Hello,&nbsp;world!</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function prints the passed string to the standard output, similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>System.out.println</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java. 
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=step2></A>Step 2. Define some variables<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#step2">link</A>]</SPAN></H3>
<P>Scala has two kinds of variables,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s.<A id=i-717204901-1></A><A id=i646151360-1></A><A id=i-1545622202-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is similar to a final variable in Java. Once initialized, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can never be reassigned. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>, by contrast, is similar to a non-final variable in Java. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be reassigned throughout its lifetime. Here's a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition:<A id=i61-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;msg&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello,&nbsp;world!"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">msg:&nbsp;java.lang.String&nbsp;=&nbsp;Hello,&nbsp;world!</SPAN>
</PRE>This statement introduces<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a name for the string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Hello,</SPAN>&nbsp;<SPAN class=code>world!"</SPAN>. The type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.String</SPAN>, because Scala strings are implemented by Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. 
<P></P>
<P>If you're used to declaring variables in Java, you'll notice one striking difference here: neither<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>nor<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>appear anywhere in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition. This example illustrates<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">type inference</EM>, Scala's ability to figure out types you leave off. In this case, because you initialized<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a string literal, Scala inferred the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>. When the Scala interpreter (or compiler) can infer types, it is often best to let it do so rather than fill the code with unnecessary, explicit type annotations.<A id=i-2107785776-3></A><A id=i1449766718-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You can, however, specify a type explicitly if you wish, and sometimes you probably should. An explicit type annotation can both ensure the Scala compiler infers the type you intend, as well as serve as useful documentation for future readers of the code. In contrast to Java, where you specify a variable's type before its name, in Scala you specify a variable's type after its name, separated by a colon.<A id=i-1836523111-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;msg2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">java.lang.String</SPAN>&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello&nbsp;again,&nbsp;world!"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">msg2:&nbsp;java.lang.String&nbsp;=&nbsp;Hello&nbsp;again,&nbsp;world!</SPAN>
</PRE>
<P>Or, since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>types are visible with their simple names<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#footnote2-4">[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala programs, simply:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;msg3:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello&nbsp;yet&nbsp;again,&nbsp;world!"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">msg3:&nbsp;String&nbsp;=&nbsp;Hello&nbsp;yet&nbsp;again,&nbsp;world!</SPAN>
</PRE>
<P>Going back to the original<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msg</SPAN>, now that it is defined, you can use it as you'd expect, for example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;println(msg)
  <SPAN class=output style="COLOR: rgb(90,0,0)">Hello,&nbsp;world!</SPAN>
</PRE>
<P>What you can't do with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msg</SPAN>, given that it is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>, not a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>, is reassign it.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#footnote2-5">[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, see how the interpreter complains when you attempt the following:<A id=i1301665902-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;msg&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Goodbye&nbsp;cruel&nbsp;world!"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:5:&nbsp;error:&nbsp;reassignment&nbsp;to&nbsp;val</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg&nbsp;=&nbsp;"Goodbye&nbsp;cruel&nbsp;world!"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P>If reassignment is what you want, you'll need to use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>, as in:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;greeting&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello,&nbsp;world!"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">greeting:&nbsp;java.lang.String&nbsp;=&nbsp;Hello,&nbsp;world!</SPAN>
</PRE>
<P>Since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greeting</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>not a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>, you can reassign it later. If you are feeling grouchy later, for example, you could change your<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greeting</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;greeting&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Leave&nbsp;me&nbsp;alone,&nbsp;world!"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">greeting:&nbsp;java.lang.String&nbsp;=&nbsp;Leave&nbsp;me&nbsp;alone,&nbsp;world!</SPAN>
</PRE>
<P>To enter something into the interpreter that spans multiple lines, just keep typing after the first line. If the code you typed so far is not complete, the interpreter will respond with a vertical bar on the next line.</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;multiLine&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"This&nbsp;is&nbsp;the&nbsp;next&nbsp;line."</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">multiLine:&nbsp;java.lang.String&nbsp;=&nbsp;This&nbsp;is&nbsp;the&nbsp;next&nbsp;line.</SPAN>
</PRE>
<P></P>
<P>If you realize you have typed something wrong, but the interpreter is still waiting for more input, you can escape by pressing enter twice:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;oops&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">You&nbsp;typed&nbsp;two&nbsp;blank&nbsp;lines.&nbsp;&nbsp;Starting&nbsp;a&nbsp;new&nbsp;command.</SPAN>
  <BR>  scala&gt;
</PRE>
<P></P>
<P>In the rest of the book, we'll leave out the vertical bars to make the code easier to read (and easier to copy and paste from the PDF eBook into the interpreter).</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=step3></A>Step 3. Define some functions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#step3">link</A>]</SPAN></H3>
<P><A name=sec:define-some-functions></A></P>
<P>Now that you've worked with Scala variables, you'll probably want to write some functions. Here's how you do that in Scala:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;max(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;&gt;&nbsp;y)&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;y
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">max:&nbsp;(Int,Int)Int</SPAN>
</PRE>Function definitions start with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN>.<A id=i1764649166-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The function's name, in this case<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>max</SPAN>, is followed by a comma-separated list of parameters in parentheses. A type annotation must follow every function parameter, preceded by a colon, because the Scala compiler (and interpreter, but from now on we'll just say compiler) does not infer function parameter types. In this example, the function named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>max</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes two parameters,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN>, both of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>. After the close parenthesis of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>max</SPAN>'s parameter list you'll find another "<SPAN class=code>:</SPAN>&nbsp;<SPAN class=code>Int</SPAN>" type annotation. This one defines the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-595246755"><EM style="FONT-STYLE: italic">result type</EM></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<A id=i-595246755-1></A><A id=i-1437134274-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>max</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function itself.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#footnote2-6">[6]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Following the function's result type is an equals sign and pair of curly braces that contain the body of the function. In this case, the body contains a single<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression,<A id=i-1395149224-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which selects either<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN>, whichever is greater, as the result of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>max</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function. As demonstrated here, Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression can result in a value, similar to Java's ternary operator. For example, the Scala expression "<SPAN class=code>if</SPAN>&nbsp;<SPAN class=code>(x</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>y)</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>else</SPAN>&nbsp;<SPAN class=code>y</SPAN>" behaves similarly to "<SPAN class=code>(x</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>y)</SPAN>&nbsp;<SPAN class=code>?</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>:</SPAN>&nbsp;<SPAN class=code>y</SPAN>" in Java. The equals sign that precedes the body of a function hints that in the functional world view, a function defines an expression that results in a value. The basic structure of a function is illustrated in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#fig:method-form">Figure 2.1</A>. 
<P></P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:method-form></A>
<P><IMG alt="image images/methodForm90.jpg" src="http://www.artima.com/pins1ed/images/methodForm90.jpg"></P></DIV>
<H5>Figure 2.1 - The basic form of a function definition in Scala.<A id=i-1058128094-1></A></H5>
<P>Sometimes the Scala compiler will require you to specify the result type of a function. If the function is<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g1165780018"><EM style="FONT-STYLE: italic">recursive</EM></A>,<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#footnote2-7">[7]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>for example, you must explicitly specify the function's result type. In the case of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>max</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>however, you may leave the result type off and the compiler will infer it.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#footnote2-8">[8]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Also, if a function consists of just one statement, you can optionally leave off the curly braces. Thus, you could alternatively write the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>max</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;max2(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;&gt;&nbsp;y)&nbsp;x&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;y
  <SPAN class=output style="COLOR: rgb(90,0,0)">max2:&nbsp;(Int,Int)Int</SPAN>
</PRE>
<P>Once you have defined a function, you can call it by name, as in:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;max(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res6:&nbsp;Int&nbsp;=&nbsp;5</SPAN>
</PRE>
<P>Here's the definition of a function that takes no parameters and returns no interesting result:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;greet()&nbsp;=&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello,&nbsp;world!"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">greet:&nbsp;()Unit</SPAN>
</PRE>When you define the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greet()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function, the interpreter will respond with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greet:</SPAN>&nbsp;<SPAN class=code>()Unit</SPAN>. "<SPAN class=code>greet</SPAN>" is, of course, the name of the function. The empty parentheses indicate the function takes no parameters. And<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greet</SPAN>'s result type. A result type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>indicates the function returns no interesting value. Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type is similar to Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>void</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type, and in fact every<SPAN class=code>void</SPAN>-returning method in Java is mapped to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN>-returning method in Scala. Methods with the result type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN>, therefore, are only executed for their side effects. In the case of<SPAN class=code>greet()</SPAN>, the side effect is a friendly greeting printed to the standard output. 
<P>In the next step, you'll place Scala code in a file and run it as a script. If you wish to exit the interpreter, you can do so by entering<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:quit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:q</SPAN>.</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;:quit
  $
</PRE>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=step4></A>Step 4. Write some Scala scripts<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#step4">link</A>]</SPAN></H3>
<P>Although Scala is designed to help programmers build very large-scale systems, it also scales<A id=i1047419434-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>down nicely to scripting. A script is just a sequence of statements in a file that will be executed sequentially. Put this into a file named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hello.scala</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello,&nbsp;world,&nbsp;from&nbsp;a&nbsp;script!"</SPAN>)
</PRE>
<P>then run:<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#footnote2-9">[9]</A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;hello.scala
</PRE>
<P>And you should get yet another greeting:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Hello,&nbsp;world,&nbsp;from&nbsp;a&nbsp;script!</SPAN>
</PRE>
<P>Command line arguments<A id=i337914190-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>to a Scala script are available via a Scala array named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>args</SPAN>.<A id=i515731402-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In Scala, arrays are zero based, and you access an element by specifying an index in parentheses. So the first element in a Scala array named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>steps</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>steps(0)</SPAN>, not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>steps[0]</SPAN>, as in Java. To try this out, type the following into a new file named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>helloarg.scala</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Say&nbsp;hello&nbsp;to&nbsp;the&nbsp;first&nbsp;argument</SPAN>
  println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello,&nbsp;"</SPAN>+&nbsp;args(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"!"</SPAN>)
</PRE>
<P>then run:<A id=i1342830375-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;helloarg.scala&nbsp;planet
</PRE>
<P>In this command,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"planet"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is passed as a command line argument, which is accessed in the script as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>args(0)</SPAN>. Thus, you should see:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Hello,&nbsp;planet!</SPAN>
</PRE>
<P>Note that this script included a comment. The Scala compiler will ignore characters between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>//</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the next end of line and any characters between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>/*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*/</SPAN>. This example also shows<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>s being concatenated with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator. This works as you'd expect. The expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Hello,</SPAN>&nbsp;<SPAN class=code>"+"world!"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will result in the string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Hello,</SPAN>&nbsp;<SPAN class=code>world!"</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#footnote2-10">[10]</A></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=step5></A>Step 5. Loop with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN>; decide with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#step5">link</A>]</SPAN></H3>
<P>To try out a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN>, type the following<A id=i852231328-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>into a file named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printargs.scala</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;i&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">while</SPAN>&nbsp;(i&nbsp;&lt;&nbsp;args.length)&nbsp;{
  &nbsp;&nbsp;println(args(i))
  &nbsp;&nbsp;i&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  }
</PRE>
<P></P>
<DIV class=note style="PADDING-RIGHT: 20px; PADDING-LEFT: 20px; PADDING-BOTTOM: 5px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px">
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Note</H4>
<P>Although the examples in this section help explain<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops, they do not demonstrate the best Scala style. In the next section, you'll see better approaches that avoid iterating through arrays with indexes.</P></DIV>
<P>This script starts with a variable definition,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>&nbsp;<SPAN class=code>i</SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code>0</SPAN>. Type inference gives<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>i</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Int</SPAN>, because that is the type of its initial value,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>construct on the next line causes the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g93832333"><EM style="FONT-STYLE: italic">block</EM></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>(the code between the curly braces) to be repeatedly executed until the boolean expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>i</SPAN>&nbsp;<SPAN class=code>&lt;</SPAN>&nbsp;<SPAN class=code>args.length</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is false.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>args.length</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>gives the length of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>args</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>array. The block contains two statements, each indented two spaces, the recommended indentation style for Scala. The first statement,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println(args(i))</SPAN>, prints out the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>i</SPAN>th command line argument. The second statement,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>i</SPAN>&nbsp;<SPAN class=code>+=</SPAN>&nbsp;<SPAN class=code>1</SPAN>, increments<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>i</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by one. Note that Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>++i</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>i++</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>don't work in Scala. To increment in Scala, you need to say either<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>i</SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code>i</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>i</SPAN>&nbsp;<SPAN class=code>+=</SPAN>&nbsp;<SPAN class=code>1</SPAN>.<A id=i-1984818667-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Run this script with the following command:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;printargs.scala&nbsp;Scala&nbsp;is&nbsp;fun
</PRE>
<P>And you should see:<FONT color=white>$sn1234$</FONT></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Scala</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">is</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">fun</SPAN>
</PRE>
<P>For even more fun, type the following code into a new file with the name<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>echoargs.scala</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;i&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">while</SPAN>&nbsp;(i&nbsp;&lt;&nbsp;args.length)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(i&nbsp;!=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;print(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>)
  &nbsp;&nbsp;print(args(i))
  &nbsp;&nbsp;i&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  }
  println()
</PRE>
<P>In this version, you've replaced the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>call with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>print</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>call, so that all the arguments will be printed out on the same line. To make this readable, you've inserted a single space before each argument except the first via the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN>&nbsp;<SPAN class=code>(i</SPAN>&nbsp;<SPAN class=code>!=</SPAN>&nbsp;<SPAN class=code>0)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>construct. Since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>i</SPAN>&nbsp;<SPAN class=code>!=</SPAN>&nbsp;<SPAN class=code>0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the first time through the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loop, no space will get printed before the initial argument. Lastly, you've added one more<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the end, to get a line return after printing out all the arguments. Your output will be very pretty indeed. If you run this script with the following command:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;echoargs.scala&nbsp;Scala&nbsp;is&nbsp;even&nbsp;more&nbsp;fun
</PRE>
<P>You'll get:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Scala&nbsp;is&nbsp;even&nbsp;more&nbsp;fun</SPAN>
</PRE>
<P>Note that in Scala, as in Java, you must put the boolean expression for a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in parentheses. (In other words, you can't say in Scala things like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN>&nbsp;<SPAN class=code>i</SPAN>&nbsp;<SPAN class=code>&lt;</SPAN>&nbsp;<SPAN class=code>10</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as you can in a language such as Ruby.<A id=i-1395149224-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You must say<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN>&nbsp;<SPAN class=code>(i</SPAN>&nbsp;<SPAN class=code>&lt;</SPAN>&nbsp;<SPAN class=code>10)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala.) Another similarity to Java is that if a block has only one statement, you can optionally leave off the curly braces, as demonstrated by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>statement in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>echoargs.scala</SPAN>. And although you haven't seen any of them, Scala does use semicolons to separate statements as in Java, except that in Scala the semicolons are very often optional, giving some welcome relief to your right little finger. If you had been in a more verbose mood, therefore, you could have written the<SPAN class=code>echoargs.scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>script as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;i&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>;
  <SPAN class=vem style="COLOR: rgb(0,0,230)">while</SPAN>&nbsp;(i&nbsp;&lt;&nbsp;args.length)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(i&nbsp;!=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;print(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>);
  &nbsp;&nbsp;}
  &nbsp;&nbsp;print(args(i));
  &nbsp;&nbsp;i&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>;
  }
  println();
</PRE>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=step6></A>Step 6. Iterate with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#step6">link</A>]</SPAN></H3>
<P>Although you may not have realized it, when you wrote the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops in the previous step, you were programming in an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">imperative</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>style. In the imperative style, which is the style you normally use with languages like Java, C++, and C, you give one imperative command at a time, iterate with loops, and often mutate state shared between different functions. Scala enables you to program imperatively, but as you get to know Scala better, you'll likely often find yourself programming in a more<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">functional</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>style. In fact, one of the main aims of this book is to help you become as comfortable with the functional style as you are with imperative style.</P>
<P>One of the main characteristics of a functional language is that functions are first class constructs, and that's very true in Scala. For example, another (far more concise) way to print each command line argument is:<A id=i1367928747-1></A><A id=i2142910787-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  args.foreach(arg&nbsp;=&gt;&nbsp;println(arg))
</PRE>
<P>In this code, you call the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>args</SPAN>, and pass in a function. In this case, you're passing in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g1911543911"><EM style="FONT-STYLE: italic">function literal</EM></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that takes one parameter named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arg</SPAN>. The body of the function is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println(arg)</SPAN>. If you type the above code into a new file named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pa.scala</SPAN>, and execute with the command:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;pa.scala&nbsp;Concise&nbsp;is&nbsp;nice
</PRE>
<P>You should see:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Concise</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">is</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">nice</SPAN>
</PRE>
<P>In the previous example, the Scala interpreter infers the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>, since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the element type of the array on which you're calling<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN>. If you'd prefer to be more explicit, you can mention the type name, but when you do you'll need to wrap the argument portion in parentheses (which is the normal form of the syntax anyway):</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  args.foreach((arg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&gt;&nbsp;println(arg))
</PRE>
<P>Running this script has the same behavior as the previous one.</P>
<P>If you're in the mood for more conciseness instead of more explicitness, you can take advantage of a special shorthand in Scala. If a function literal consists of one statement that takes a single argument, you need not explicitly name and specify the argument.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#footnote2-11">[11]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Thus, the following code also works:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  args.foreach(println)
</PRE>
<P>To summarize, the syntax for a function literal is a list of named parameters, in parentheses, a right arrow, and then the body of the function. This syntax is illustrated in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#fig:function-literal">Figure 2.2</A>.</P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:function-literal></A>
<P><IMG alt="image images/functionLiteral60.jpg" src="http://www.artima.com/pins1ed/images/functionLiteral60.jpg"></P></DIV>
<H5>Figure 2.2 - The syntax of a function literal in Scala.<A id=i-995341786-1></A></H5>
<P>Now, by this point you may be wondering what happened to those trusty<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops you have been accustomed to using in imperative languages such as Java or C. In an effort to guide you in a functional direction, only a functional relative of the imperative<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic"><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression</EM>) is available in Scala.<A id=i-207940604-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>While you won't see their full power and expressiveness until you reach (or peek ahead to)<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/builtin-control-structures.html#sec:for-expressions">Section 7.3</A>, we'll give you a glimpse here. In a new file named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>forargs.scala</SPAN>, type the following:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(arg&nbsp;&lt;-&nbsp;args)
  &nbsp;&nbsp;println(arg)
</PRE>
<P>The parentheses after the "<SPAN class=code>for</SPAN>" contain<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arg</SPAN>&nbsp;<SPAN class=code>&lt;-</SPAN>&nbsp;<SPAN class=code>args</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#footnote2-12">[12]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>To the right of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;-</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>symbol is the familiar<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>args</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>array.<A id=i-880746692-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>To the left of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;-</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is "<SPAN class=code>arg</SPAN>", the name of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>, not a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>. (Because it is always a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>, you just write "<SPAN class=code>arg</SPAN>" by itself, not "<SPAN class=code>val</SPAN>&nbsp;<SPAN class=code>arg</SPAN>".) Although<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>may seem to be a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>, because it will get a new value on each iteration, it really is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can't be reassigned inside the body of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. Instead, for each element of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>args</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>array, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">new</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be created and initialized to the element value, and the body of the<SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be executed.</P>
<P>If you run the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>forargs.scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>script with the command:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;forargs.scala&nbsp;for&nbsp;arg&nbsp;in&nbsp;args
</PRE>
<P>You'll see:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">for</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">arg</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">in</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">args</SPAN>
</PRE>Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression can do much more than this, but this example is enough to get you started. We'll show you more about<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/builtin-control-structures.html#sec:for-expressions">Section 7.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/for-expressions-revisited.html">Chapter 23</A>. 
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Conclusion</H3>
<P>In this chapter, you learned some Scala basics and, hopefully, took advantage of the opportunity to write a bit of Scala code. In the next chapter, we'll continue this introductory overview and get into more advanced topics.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 2:</H4>
<P><A name=footnote2-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>We tested the examples in this book with Scala version 2.7.2.</P>
<P><A name=footnote2-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>If you're using Windows, you'll need to type the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>command into the "Command Prompt" DOS box.</P>
<P><A name=footnote2-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>If you're not familiar with Java packages, you can think of them as providing a full name for classes. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a member of package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN>, "<SPAN class=code>Int</SPAN>" is the class's simple name, and "<SPAN class=code>scala.Int</SPAN>" is its full name. The details of packages are explained in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html">Chapter 13</A>.</P>
<P><A name=footnote2-4>[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The simple name of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>.</P>
<P><A name=footnote2-5>[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In the interpreter, however, you can<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">define</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>a new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a name that was already used before. This mechanism is explained<SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/builtin-control-structures.html#sec:variable-scope">Section 7.7</A>.</P>
<P><A name=footnote2-6>[6]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In Java, the type of the value returned from a method is its return type<A id=i-1544421334-1></A><A id=i-1437104303-1></A>. In Scala, that same concept is called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">result type</EM>.</P>
<P><A name=footnote2-7>[7]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>A function is recursive if it calls itself.</P>
<P><A name=footnote2-8>[8]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Nevertheless, it is often a good idea to indicate function result types explicitly, even when the compiler doesn't require it. Such type annotations can make the code easier to read, because the reader need not study the function body to figure out the inferred result type.</P>
<P><A name=footnote2-9>[9]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You can run scripts without typing "<SPAN class=code>scala</SPAN>" on Unix and Windows using a "pound-bang" syntax, which is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scala-scripts-on-unix-and-windows.html">Appendix A</A>.</P>
<P><A name=footnote2-10>[10]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You can also put spaces around the plus operator, as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Hello,</SPAN>&nbsp;<SPAN class=code>"</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>"world!"</SPAN>. In this book, however, we'll leave the space off between `<SPAN class=code>+</SPAN>' and string literals.</P>
<P><A name=footnote2-11>[11]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This shorthand, called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">partially applied function</EM>, is described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#sec:partially-applied-functions">Section 8.6</A>.</P>
<P><A name=footnote2-12>[12]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You can say "in" for the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;-</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>symbol. You'd read<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN>&nbsp;<SPAN class=code>(arg</SPAN>&nbsp;<SPAN class=code>&lt;-</SPAN>&nbsp;<SPAN class=code>args)</SPAN>, therefore, as "for arg in args."</P></DIV>