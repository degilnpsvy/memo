<DIV class=navheader style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<TABLE width="100%" summary="Navigation header">
<TBODY>
<TR>
<TH align=middle colSpan=3>2.5.&nbsp;The Unix Command Line</TH></TR>
<TR>
<TD align=left width="20%"><A accessKey=p href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch02s04.html">Prev</A>&nbsp;</TD>
<TH align=middle width="60%">Chapter&nbsp;2.&nbsp;Enough Unix to Make You Dangerous</TH>
<TD align=right width="20%">&nbsp;<A accessKey=n href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch02s06.html">Next</A></TD></TR></TBODY></TABLE>
<HR>
</DIV>
<DIV class=section title="2.5.&nbsp;The Unix Command Line" style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=id286953123></A>2.5.&nbsp;The Unix Command Line</H2></DIV></DIV></DIV>
<DIV class=section title="2.5.1.&nbsp;The Shell">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286953126></A>2.5.1.&nbsp;The Shell</H3></DIV></DIV></DIV>
<P>This section covers the basics of the Unix command-line-interface (CLI), also known as the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>shell</EM>. The shell is a command interpreter that provides instant access to hundreds or thousands of Unix commands, provided that you know what they are. Don't worry, you need only know a small number of Unix commands to get started. Knowing more commands will make you more efficient, but you can learn most of them at a relaxed pace over time. Knowledge of a few dozen Unix commands is enough to make you fairly efficient with the command line.</P>
<P>While the Unix world also offers many choices for<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>graphical user interfaces (GUIs)</EM>, the command-line is a far more powerful interface for seasoned users. Although a GUI is easier for a novice to utilize without training, GUIs become a hindrance as you gain knowledge and experience, since the process of navigating many levels of menus is time-consuming.</P>
<P>When using the Unix command line, the shell prints a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>prompt</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>to indicate that it is waiting for you to type the next command. This text uses the simple string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=quote>&#8220;<SPAN class=quote>unix:</SPAN>&#8221;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a sample shell prompt, indicating that what follows is a Unix command.</P>
<P>A `#' following a command marks the beginning of a comment. All Unix shells ignore any text following a `#'.</P></DIV>
<DIV class=section title="2.5.2.&nbsp;Unix Commands">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286953150></A>2.5.2.&nbsp;Unix Commands</H3></DIV></DIV></DIV>
<P>Unix commands are programs that we can run by typing their names at the shell prompt, possibly followed by additional information:</P><PRE class=programlisting>	    unix: ls
	    unix: pwd
	    unix: cd /etc
	    </PRE>
<P>A complete Unix command consists of the command name, and possibly one or more<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>arguments</EM>, which are additional words or symbols separated from the command and each other by<EM class=glossterm>white space</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>(spaces or tabs).</P><PRE class=programlisting>	    unix: cd /etc
		  ^    ^
		  |   Argument
		Command
	    </PRE>
<P>Unix commands are either "internal" or "external".</P>
<P>External commands are separate programs that could be written in any language. When you run an external command, you are typing the filename of a program, possibly followed by one or more arguments. When an external command is executed, a new process is created, which is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>child</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the shell (command interpreter). The shell locates the program (usually by looking for the file in /bin, /usr/bin, and a few other places), and runs the program as a new process. The shell then waits for the child process to finish before printing a new prompt and accepting another command. For example, when you type</P><PRE class=programlisting>	    unix: ls
	    </PRE>
<P>The shell locates and runs the program contained in the file /bin/ls, and waits for the ls command to finish before accepting the next command.</P>
<P>Internal commands are part of the shell. Internal commands exist for two reasons:</P>
<DIV class=itemizedlist>
<UL class=itemizedlist type=disc>
<LI class=listitem>Some commands, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=command><STRONG>cd (change current working directory)</STRONG></SPAN>, are meant to alter the environment of the shell. Remember that each process has its own current working directory. Since an external command executes as separate child process, and a child process cannot alter the environment of its parent, an external command cannot change the current working directory for the shell. It is therefore impossible to implement a cd command as an external program, and it must be part of the shell itself.</LI>
<LI class=listitem>Locating an external program, loading it from disk, and starting a new process take time. A command that is part of the shell will start up faster, so internal commands are also used in some cases just to improve speed.</LI></UL></DIV></DIV>
<DIV class=section title="2.5.3.&nbsp;Common Unix Commands">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286953294></A>2.5.3.&nbsp;Common Unix Commands</H3></DIV></DIV></DIV>
<P>This section provides a brief summary of many common Unix commands. The goal of this section is to make readers aware of a core set of Unix commands, not to explain them in detail. The Unix system consists of thousands of different commands, each of which has many features. Significant knowledge of the Unix commands can only come from experience. Beginners are advised against trying to learn too much by brute-force reading. Instead, you should learn the basic features of a small set of common commands in order to become confident with the Unix system, and pick up more commands and details a little at a time. Even the most experienced Unix users learn new things about Unix commands every day.</P>
<P>All common Unix commands are documented within the Unix system itself, as well as on the Internet. This makes it easy to learn new details of familiar commands, and learn about entirely new commands as you work with the Unix system.</P>
<P>For a detailed description of the usage and options for a given command, you can use the Unix<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=command><STRONG>man</STRONG></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>command. The man command displays detailed information about Unix commands on the terminal screen. The information is formatted according to a standard template called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>man page</EM>. You can then navigate the man page using the following keys:</P>
<DIV class=table><A name=id286953310></A>
<P class=title><B>Table&nbsp;2.1.&nbsp;Man Command Keys</B></P>
<DIV class=table-contents>
<TABLE summary="Man Command Keys" border=1>
<COLGROUP>
<COL>
<COL></COLGROUP>
<THEAD>
<TR>
<TH align=left>Key</TH>
<TH align=left>Action</TH></TR></THEAD>
<TBODY>
<TR>
<TD align=left>space</TD>
<TD align=left>Next page</TD></TR>
<TR>
<TD align=left>b</TD>
<TD align=left>Previous page</TD></TR>
<TR>
<TD align=left>Enter/Return</TD>
<TD align=left>Next line</TD></TR>
<TR>
<TD align=left>q</TD>
<TD align=left>Quit</TD></TR>
<TR>
<TD align=left>/</TD>
<TD align=left>Search</TD></TR>
<TR>
<TD align=left>n</TD>
<TD align=left>Next (repeat search)</TD></TR></TBODY></TABLE></DIV></DIV><BR class=table-break>
<P>For example, to view all the details of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=command><STRONG>ls</STRONG></SPAN>, enter:</P><PRE class=programlisting>	    unix: man ls
	    </PRE>
<P>You can even use man to learn about man:</P><PRE class=programlisting>	    unix: man man
	    </PRE>
<P>Each man page contains several standard sections. The sections most important for beginners are as follows:</P>
<DIV class=itemizedlist>
<UL class=itemizedlist type=disc>
<LI class=listitem>SYNOPSIS - Shows the basic structure of the command, i.e. how it should be typed at the shell prompt.</LI>
<LI class=listitem>DESCRIPTION - An overview of how the command works.</LI>
<LI class=listitem>OPTIONS - A detailed list of the command-line arguments and options for controlling how the command behaves.</LI>
<LI class=listitem>SEE ALSO - This is probably the best way to discover new Unix commands related to a subject.</LI></UL></DIV>
<P>apropos, man -k</P>
<P>Not always the best</P>
<DIV class=section title="ls - List">
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=id286953390></A>ls - List</H4></DIV></DIV></DIV><PRE class=programlisting>		unix: ls            # Just shows filenames
		unix: ls -al        # Shows attributes of files
		unix: ls /home/CS   # Shows /home/CS instead of cwd
	    
		1. How would you list the contents of /etc?
	    
		    ls /etc
	    
		2. How would you get a long listing of ./Prog1
	    
		    ls -l Prog1
	    
		    or
	    
		    ls -l ./Prog1
		</PRE></DIV>
<DIV class=section title="ls - List">
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=id286953396></A>ls - List</H4></DIV></DIV></DIV><PRE class=programlisting>		unix: ls
		unix: ls -al
		unix: ls /home/CS
	    
		1. How would you list the contents of /etc?
	    
		    ls /etc
	    
		2. How would you get a long-listing of ./Prog1
	    
		    ls Prog1
	    
		    or
	    
		    ls ./Prog1
		</PRE></DIV>
<DIV class=section title="cd, pushd, popd - Change Directory">
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=id286953401></A>cd, pushd, popd - Change Directory</H4></DIV></DIV></DIV><PRE class=programlisting>		unix: cd           # Goes back to home directory
		unix: cd Prog1     # Goes to ./Prog1
		unix: cd /tmp      # Goes to /tmp
		</PRE>
<P>If you need to switch to another directory for a bit and then come back to the current one, you can use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>directory stack</EM>.</P><PRE class=programlisting>		unix: pushd /tmp   # Goes to /tmp
		unix: popd         # Returns to cwd before last pushd
		</PRE></DIV>
<DIV class=section title="pwd - Print Working Directory">
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=id286953417></A>pwd - Print Working Directory</H4></DIV></DIV></DIV>
<P>What is the output?</P><PRE class=programlisting>		unix: cd
		unix: pwd
		</PRE></DIV>
<DIV class=section title="more - Interactive File Viewer">
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=id286953425></A>more - Interactive File Viewer</H4></DIV></DIV></DIV><PRE class=programlisting>		unix: more prog1.mal
		
		    space = next page
		    return = next line
		    b = previous page
		    q = quit
		</PRE></DIV>
<DIV class=section title="man - View Online Manual">
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=id286953431></A>man - View Online Manual</H4></DIV></DIV></DIV><PRE class=programlisting>		unix: man ls
		unix: man rm
		unix: man pwd
		unix: man man
		unix: man f90
		unix: man spim
		</PRE></DIV>
<DIV class=section title="apropos - Search Manuals for Keywords">
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=id286953436></A>apropos - Search Manuals for Keywords</H4></DIV></DIV></DIV><PRE class=programlisting>		unix: apropos compile
		</PRE></DIV>
<DIV class=section title="rm - Remove Files">
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=id286953442></A>rm - Remove Files</H4></DIV></DIV></DIV><PRE class=programlisting>		unix: rm a.out
		unix: rm core
		unix: rm -rf Directory
		</PRE>
<DIV class=caution title=Caution style="MARGIN-LEFT: 0.5in; MARGIN-RIGHT: 0.5in">
<H3 class=title>Caution</H3>Never use a full pathname following<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=command><STRONG>rm -rf</STRONG></SPAN>. If you accidentally hit enter before you finish typing the pathname, you'll be very sorry.</DIV></DIV>
<DIV class=section title="rmdir - Remove Directory">
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=id286953452></A>rmdir - Remove Directory</H4></DIV></DIV></DIV><PRE class=programlisting>		unix: rmdir Prog
		</PRE></DIV>
<DIV class=section title="mkdir - Make Directory">
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=id286953458></A>mkdir - Make Directory</H4></DIV></DIV></DIV><PRE class=programlisting>		unix: mkdir Prog02
		</PRE></DIV></DIV>
<DIV class=section title="2.5.4.&nbsp;Shell Scripts">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286953463></A>2.5.4.&nbsp;Shell Scripts</H3></DIV></DIV></DIV>
<P>A shell script is a text file containing a sequence of Unix commands. Any time you want to run the same sequence of commands more than once, it is wise to put them into a script:</P><PRE class=programlisting>	    unix: ape cleanup
	    
	    #!/bin/csh
	    
	    rm *.o
	    rm core
	    </PRE>
<P>Then the script can be run just like any other Unix command:</P><PRE class=programlisting>	    unix: ./cleanup
	    </PRE></DIV>
<DIV class=section title="2.5.5.&nbsp;Shell and Environment Variables">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286953478></A>2.5.5.&nbsp;Shell and Environment Variables</H3></DIV></DIV></DIV>
<P>Every process running under Unix has a block of memory called the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>environment</EM>, which contains a set of string variables inherited from the parent process. The parent process of a Unix command you type is the shell.</P>
<P>One example of an environment variable is the TERM variable mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=xref title="2.2.&nbsp;Logging In" href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch02s02.html">Section&nbsp;2.2, &#8220;Logging In&#8221;</A>.</P>
<P>The complete list of environment variables for your shell process can be listed by running the printenv command:</P><PRE class=programlisting>	    unix: printenv
	    </PRE>
<P>In C-shell and T-shell, an environment variable can be changed using the setenv command:</P><PRE class=programlisting>	    unix: setenv TERM xterm
	    </PRE>
<P>The shell also maintains a list of its own variables, which are similar to environment variables, but which are stored separately, and are not inherited by child processes. Shell variables in C-shell and T-shell are both listed and altered with the set command:</P><PRE class=programlisting>	    unix: set
	    prompt  Darwin %m %n %~ %h: 
	    savehist    400
	    term    xterm
	    uid     4000
	    user    bacon
	    </PRE>
<P>Shell variables are generally used to control shell behavior, such as what the shell prints as a prompt, how many previous commands to remember, etc. Some shell variables also mirror environment variables such as TERM.</P><PRE class=programlisting>	    unix: set prompt="newprompt&gt;"
	    newprompt&gt;
	    </PRE>
<P>Most shell and environment variables are set by your "startup script", which contains a list of commands that are executed when you start up a new shell, i.e. when you remotely log in or open a terminal window. The usual startup script for C-shell and T-shell is ~/.cshrc. For Bourne shell, Korn shell, and Bourne-again shell users, the common startup script is .profile. Bash users may also use .bash_profile instead.</P>
<P>If you modify your .cshrc file and want to test it, you can type "source ~/.cshrc". This causes the current shell process to run the commands in ~/.cshrc again, and avoids the need to log out and log back in just to run the startup script again.</P></DIV>
<DIV class=section title="2.5.6.&nbsp;The Command Path">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286953513></A>2.5.6.&nbsp;The Command Path</H3></DIV></DIV></DIV>
<P>The environment variable PATH contains a list of directories containing program files. When you type a command at the shell prompt, the shell searches these directories for the command.</P>
<P>The PATH variable is almost always set by your startup script. If you want to change your PATH, edit the startup script and change the line setting the PATH variable.</P>
<P>It's a common practice and a good idea to add the directory ~/bin to your PATH in your startup script. You can put your commonly used programs and shell scripts in this directory, and run them from any current working directory.</P></DIV>
<DIV class=section title=2.5.7.&nbsp;Wildcards>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286953523></A>2.5.7.&nbsp;Wildcards</H3></DIV></DIV></DIV>
<P>Wildcards are used to specify multiple file or directory names that match a pattern. The '*' wildcard matches any number of characters in the name.</P><PRE class=programlisting>	    unix: ls *.mal     # List all files ending in ".mal"
	    unix: rm *.out     # Remove all files ending in ".out"
	    unix: ls [a-z]*    # List all files beginning with a lc letter
	    unix: ls [A-Z]*    # List all files beginning with a uc letter
	    unix: ls [A-Za-z]* # List all files beginning with a letter
	    </PRE>
<P>More information on wildcards can be found in the csh man page:</P><PRE class=programlisting>	    unix: man csh
	    </PRE></DIV>
<DIV class=section title=2.5.8.&nbsp;Streams>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286953534></A>2.5.8.&nbsp;Streams</H3></DIV></DIV></DIV>
<P>A stream is where characters flow into or out of process. Streams are created when a process opens a file or device. In Unix, every process is born with three streams already open.</P>
<DIV class=table><A name=stream_table></A>
<P class=title><B>Table&nbsp;2.2.&nbsp;Standard Streams</B></P>
<DIV class=table-contents>
<TABLE summary="Standard Streams" border=1>
<COLGROUP>
<COL>
<COL></COLGROUP>
<THEAD>
<TR>
<TH align=left>Stream</TH>
<TH align=left>Defaults To</TH></TR></THEAD>
<TBODY>
<TR>
<TD align=left>Standard Input</TD>
<TD align=left>Keyboard</TD></TR>
<TR>
<TD align=left>Standard Output</TD>
<TD align=left>Terminal Screen</TD></TR>
<TR>
<TD align=left>Standard Error</TD>
<TD align=left>Terminal Screen</TD></TR></TBODY></TABLE></DIV></DIV><BR class=table-break></DIV>
<DIV class=section title=2.5.9.&nbsp;Redirection>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286953609></A>2.5.9.&nbsp;Redirection</H3></DIV></DIV></DIV>
<P>Standard streams can be "redirected" (detached from default device and attached to a different file or device). Note that redirection is performed by the SHELL, before the command begins executing. As a result, a Unix command is usually unaware that it's standard streams have been redirected.</P>
<P>Examples:</P><PRE class=programlisting>	    unix: ls          - prints list of files in CWD to stdout
	    unix: ls /home    - prints list of files in /home to stdout
	    unix: g++ file.cc - compiles program to a.out, prints errors to stderr
	    </PRE>
<P>Unix shell performs redirection before starting the process:</P><PRE class=programlisting>	    Redirects stdout to outfile errors still go to screen:
	    
	    unix: ls /home &gt; outfile
	    
	    Redirects both output and errors to outfile
	    
	    unix: ls &gt;&amp; outfile
	    
	    Read input from keyboard
	    
	    unix: a.out
    
	    Read input from input.txt instead of keyboard
	    
	    unix: a.out &lt; input.txt
	    
	    Read input from input.txt and send standard output to output.txt
	    
	    unix: a.out &lt; input.txt &gt; output.txt
    
	    Save error messages from a compile to errors.txt
	    
	    unix: g++ file.cc &gt;&amp; errors.txt
	    
	    View error messages
	    
	    unix: more errors.txt
	    
	    (Note: If you program intelligently, there will never be so many
	    errors that you need to use "more" to view them.)
	    </PRE></DIV>
<DIV class=section title=2.5.10.&nbsp;Pipes>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286953623></A>2.5.10.&nbsp;Pipes</H3></DIV></DIV></DIV>
<P>Pipes are an extension of redirection for multitasking systems (systems that can run multiple processes at the same time)</P>
<P>A pipe redirects stdout and/or stderr of one process to stdin of another process. For example, suppose we want to view the listing of a directory with many files. We could redirect it to a file, and then use more:</P><PRE class=programlisting>	    unix: ls &gt; file-list.txt
	    unix: more file-list.txt
	    </PRE>We can accomplish the same thing with a single command and no extra file using a pipe:<PRE class=programlisting>	    unix: ls | more
	    </PRE>
<P>A filter program is any program that can take input from stdin and send output to stdout and/or stderr. Filter programs can utilize pipes from the Unix shell. They usually read from standard input if no input file is given, and write to standard output if no output file is given.</P>
<P>The more command below sees a single command line argument,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=quote>&#8220;<SPAN class=quote>file.txt</SPAN>&#8221;</SPAN>, and assumes it is the input file to be opened and displayed.</P><PRE class=programlisting>	    unix: more file.txt
	    </PRE>
<P>The more command below does not see any command-line arguments, since the shell strips away the &lt; and the string that follows. The shell opens file.txt, and attaches the stream to the standard input of the child process running more.</P><PRE class=programlisting>	    unix: more &lt; file.txt
	    </PRE>
<P>Filtering output with a pipe</P><PRE class=programlisting>	    unix: ls | more           -   redirects stdout of 'ls' process to
				    stdin of 'more' process
				    (pipes ls stdout through more)
	    unix: ls /home |&amp; more    -   pipes stdout and stderr through more
	    </PRE>
<P>You can use any number of pipes in a single command:</P><PRE class=programlisting>	    unix: ls /dev | more
	    unix: ls /dev | grep tty          # outputs too many filenames to read
	    unix: ls /dev | grep tty | more
	    </PRE></DIV></DIV>
<DIV class=navfooter style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<HR>

<TABLE width="100%" summary="Navigation footer">
<TBODY>
<TR>
<TD align=left width="40%"><A accessKey=p href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch02s04.html">Prev</A>&nbsp;</TD>
<TD align=middle width="20%"><A accessKey=u href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch02.html">Up</A></TD>
<TD align=right width="40%">&nbsp;<A accessKey=n href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch02s06.html">Next</A></TD></TR>
<TR>
<TD vAlign=top align=left width="40%">2.4.&nbsp;Unix Basics&nbsp;</TD>
<TD align=middle width="20%"><A accessKey=h href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/index.html">Home</A></TD>
<TD vAlign=top align=right width="40%">&nbsp;2.6.&nbsp;Homework</TD></TR></TBODY></TABLE></DIV>