<DIV class=navheader style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<TABLE width="100%" summary="Navigation header">
<TBODY>
<TR>
<TH align=middle colSpan=3>3.2.&nbsp;Language Types</TH></TR>
<TR>
<TD align=left width="20%"><A accessKey=p href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch03.html">Prev</A>&nbsp;</TD>
<TH align=middle width="60%">Chapter&nbsp;3.&nbsp;Software Development</TH>
<TD align=right width="20%">&nbsp;<A accessKey=n href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch03s03.html">Next</A></TD></TR></TBODY></TABLE>
<HR>
</DIV>
<DIV class=section title="3.2.&nbsp;Language Types" style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=id286953870></A>3.2.&nbsp;Language Types</H2></DIV></DIV></DIV>
<P>Programming languages are categorized into several types:</P>
<DIV class=section title="3.2.1.&nbsp;Machine Language">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286953879></A>3.2.1.&nbsp;Machine Language</H3></DIV></DIV></DIV>
<P>A machine language is a set of binary codes which is used to direct the activities of a Central Processing Unit (CPU).</P>
<P>Everything a computer does is the result of running machine language programs. No matter what language you use to program, the computer hardware is ultimately running machine language in order to execute your program.</P>
<P>Individual codes in the machine language are known as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>instructions</EM></SPAN>. Hence, a machine language is also known as an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>instruction set</EM></SPAN>. Each instruction consists of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>operation code (opcode for short)</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and possibly some operands. For example, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>add</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction contains a binary opcode that causes the CPU to initiate a sequence of operations to add two numbers, and usually two or three operands that specify where to get the two numbers to be added, and where to store the result.</P>
<P>The CPU reads instructions from memory, and the bits in the instruction trigger "switches" in the CPU, causing it to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>execute</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the instruction. For example, when the MIPS microprocessor reads the machine instruction</P><PRE class=programlisting>	    00000000010000110001100000100000
	    </PRE>
<P>this causes the processor to add the contents of registers 2 and 3, and store the result back into register 3. The meaning of each bit in this instruction is depicted in<A class=xref title="Table&nbsp;3.1.&nbsp;Example MIPS Instruction" href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch03s02.html#minst">Table&nbsp;3.1, &#8220;Example MIPS Instruction&#8221;</A></P>
<P></P>
<DIV class=table><A name=minst></A>
<P class=title><B>Table&nbsp;3.1.&nbsp;Example MIPS Instruction</B></P>
<DIV class=table-contents>
<TABLE summary="Example MIPS Instruction" border=1>
<COLGROUP>
<COL>
<COL>
<COL>
<COL>
<COL>
<COL></COLGROUP>
<THEAD>
<TR>
<TH align=left>opcode</TH>
<TH align=left>source1</TH>
<TH align=left>source2</TH>
<TH align=left>destination</TH>
<TH align=left>unused</TH>
<TH align=left>opcode continued</TH></TR></THEAD>
<TBODY>
<TR>
<TD align=left>000000</TD>
<TD align=left>00010</TD>
<TD align=left>00011</TD>
<TD align=left>00011</TD>
<TD align=left>00000</TD>
<TD align=left>100000</TD></TR>
<TR>
<TD align=left>add</TD>
<TD align=left>register 2</TD>
<TD align=left>register 3</TD>
<TD align=left>register 3</TD>
<TD align=left>-</TD>
<TD align=left>add</TD></TR></TBODY></TABLE></DIV></DIV>
<P><BR class=table-break></P>
<P>A CPU<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>architecture</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined by its instruction set. For example, the Intel x86 family of architectures has a specific set of instructions, with variations that have evolved over time (8086, 8088, 80286, 80386, 80486, Pentium, Xeon, Core Duo, etc.) The x86 architectures have a completely different instruction set than the MIPS architecture, the ARM architecture, the PowerPC architecture, and so on.</P>
<P>The architecture is separate from the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>implementation</EM></SPAN>. For example, Intel and AMD (Advanced Micro Devices) are two separate companies that make implementations of the x86 architectures. Some popular Intel implementations include the Core Duo, Xeon, Nehalem, etc. Some AMD x86 implementations include the Athlon, Duron, Sempron, etc. While the circuit diagrams of all these processors are very different from each other, they all implement the basic x86 instruction set.</P>
<P>The fact that machine language is specific to one architecture presents an obvious problem: Programs written for one architecture have to be completely rewritten in order to run on a different architecture, i.e. they are not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>portable</EM></SPAN>. Program development and maintenance is enormously time consuming, and therefore expensive. The solution to this problem is discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=xref title="3.2.3.&nbsp;High Level Languages (HLLs)" href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch03s02.html#hll">Section&nbsp;3.2.3, &#8220;High Level Languages (HLLs)&#8221;</A>.</P>
<P>In addition to the lack of portability, machine language programs tend to be very long, since the machine instructions are quite primitive. Most machine instructions can only perform a single, simple operation such as adding two numbers. It may take a sequence of dozens of instructions to evaluate a simple polynomial.</P></DIV>
<DIV class=section title="3.2.2.&nbsp;Assembly Language">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286954041></A>3.2.2.&nbsp;Assembly Language</H3></DIV></DIV></DIV>
<P>To program in machine language, one would have to memorize or look up binary codes for opcodes and operands in order to read or write the instructions. This process is far too tedious and error prone to allow for productive (or enjoyable) programming.</P>
<P>One of the first things early programmers did to make the job easier is create a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>mnemonic</EM></SPAN>, or symbolic form of machine language that is easier to read. For example, instead of writing</P><PRE class=programlisting>	    00000000010000110001100000100000
	    </PRE>
<P>a programmer could write</P><PRE class=programlisting>	    add     $3, $2, $3
	    </PRE>
<P>which is obviously much easier on the eyes and brain.</P>
<P>Assembly language also makes it possible for the programmer to use named variables instead of binary addresses, label program elements, and define macros. The assembler, which translates the assembly language to machine language, can also check the program for errors.</P>
<P>However, the CPU can't understand this mnemonic form, so it has to be translated, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>assembled</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into machine language before the computer can run it. Hence, it was given the name<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>assembly language</EM></SPAN>. The set of assembly language instructions is generally a close, but not exact match to the machine language. When designing assembly languages, programmers often add some simple features to make programming a little easier than a 1-to-1 mapping to machine language would provide. For example, some machine instructions may be given more than one assembly instruction name to help make programs more readable, and some assembly instructions may actually translate to a sequence of machine instructions instead of just one. Assembly instructions that don't translate exactly to one machine instruction are known as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>pseudo-instructions</EM></SPAN>.</P>
<P>While assembly language is much easier to read and write than machine language, it still suffers from two major problems:</P>
<DIV class=itemizedlist>
<UL class=itemizedlist type=disc>
<LI class=listitem>It is still specific to one architecture, i.e. it is not portable.</LI>
<LI class=listitem>The instructions are still very primitive, so the programs are long and difficult to follow.</LI></UL></DIV>
<P></P></DIV>
<DIV class=section title="3.2.3.&nbsp;High Level Languages (HLLs)">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=hll></A>3.2.3.&nbsp;High Level Languages (HLLs)</H3></DIV></DIV></DIV>
<DIV class=section title=Overview>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=id286954101></A>Overview</H4></DIV></DIV></DIV>
<P>Early programmers quickly realized that it should be feasible to automate the process of writing certain types of machine or assembly code. Programs often contain sequences of instructions that evaluate mathematical expressions, perform repetitive execution, make decisions, print out numbers and text, etc.</P>
<P>Wouldn't it be nice if we had a program that could take a mathematical expression and write the machine code to evaluate it for us? What if it could also write the necessary code to input and output numbers?</P>
<P>In the 1950's, a team at IBM led by John Backus set out to do just that, and their efforts produced the first major high-level language, FORTRAN. The program that performed the translation to machine language was named a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>compiler</EM></SPAN>.</P>
<P>FORTRAN made it much easier to write programs, since we could now write a one-line algebraic expressions and let the compiler convert it to a long sequence of machine instructions. We could write a single<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>print</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>statement instead of the hundreds of machine instructions that it represents.</P>
<P>In addition to making our programs much shorter and easier to understand, FORTRAN paved the way for another major benefit:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>portability</EM></SPAN>. We could now write programs in FORTRAN, and by modifying the compiler to output code for different CPU architectures, we could run the same program on any computer without significant modification.</P></DIV>
<DIV class=section title="Program Execution">
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=id286954134></A>Program Execution</H4></DIV></DIV></DIV>
<P>Languages are often classified according to how they are executed. There are two major categories, although many languages don't fit either category perfectly. These categories and several example languages are discussed below.</P>
<DIV class=section title=Compiled>
<DIV class=titlepage>
<DIV>
<DIV>
<H5 class=title><A name=id286954142></A>Compiled</H5></DIV></DIV></DIV>
<P>A program written in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>compiled</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>language is first translated to machine language by another program called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>compiler</EM>. The compiler<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>parses</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>each statement in the program and outputs an equivalent sequence of machine or assembly instructions. For example:</P><PRE class=programlisting>		    # Compiler input high-level language source code
		    y = a + b * c - d / a
		    </PRE><PRE class=programlisting>		    # Compiler output (assembly language)
		    mul     product1, b, c
		    div     quotient1, d, a
		    add     sum1, a, product1
		    sub     y, sum1, quotient1
		    </PRE>
<P>Parsing involves first breaking it into<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>tokens</EM></SPAN>, which are small pieces such as variable names, keywords, and operators. It then looks at the sequence of tokens to figure out what the statement means.</P>
<P>The machine language is stored in another file called an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>executable</EM></SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>binary</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>file. The executable file can be loaded into memory and executed directly by the CPU of any computer using the same architecture and operating system as the one used to compile the program.</P>
<P>Most Unix commands are actually the names of executable files stored in a "bin" directory such as /bin or /usr/bin. (The directory name "bin" is short for binary.) In DOS and Windows, the names of executable files usually have a ".exe" or ".com" extension.</P>
<P>Compile-time and run-time</P></DIV>
<DIV class=section title=Interpreted>
<DIV class=titlepage>
<DIV>
<DIV>
<H5 class=title><A name=id286954193></A>Interpreted</H5></DIV></DIV></DIV>
<P>A program written in an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>interpreted</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>language is never translated to machine language. Instead, the program is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>interpreted</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and executed by another program called an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>interpreter</EM></SPAN>.</P>
<P>Like a compiler, an interpreter parses each statement in the source program, but instead of translating it to machine language, it simply executes the statement as soon as it determined the meaning.</P></DIV>
<DIV class=section title="Comparison of Compiled and Interpreted Languages">
<DIV class=titlepage>
<DIV>
<DIV>
<H5 class=title><A name=id286954215></A>Comparison of Compiled and Interpreted Languages</H5></DIV></DIV></DIV>
<P>Since a compiled program is translated in advance, compiled programs have the following advantages:</P>
<DIV class=itemizedlist>
<UL class=itemizedlist type=disc>
<LI class=listitem>
<P>The executables run as fast as possible, since they are executed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>natively</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(directly) by the CPU.</P>
<P>All of the expensive parsing of the source code is done before the program begins executing, and need only be done once. After that, the machine language produced by the compiler runs with no further need for the source code.</P></LI>
<LI class=listitem>There is no need to have a compiler on every computer that runs the executable. The compiler need only be present on the developer's computer, and the executables produced can be run on any computer with the same architecture and operating system.</LI></UL></DIV>
<P>The interpreter performs much of the same work as a compiler. For each statement in a program, a compiler and interpreter both parse the code.</P>
<P>At this point, the compiler and the interpreter diverge. Once the meaning of a statement is determined, the compiler outputs equivalent machine language to another file to be executed after compilation is finished. The interpreter, on the other hand, does not translate to machine language, but immediately executes the statement.</P>
<P>Programs written in interpreted languages run far slower than the same program written in a compiled language. This is due to the fact that an interpreted program is being parsed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>while it is executing</EM></SPAN>, whereas the compiler does all the parsing before execution begins. The sequence of events in an interpreted program is:</P><PRE class=screen>		    | parse | execute | parse | execute | ...
		    </PRE>
<P>For a compiled program, the sequence is:</P><PRE class=screen>		    | parse | translate | parse | translate | ... | execute |
		    </PRE>
<P>Parsing a statement is a complex process that often takes much longer than executing the statement, so more time is actually spent interpreting the program than doing the work it's meant for. Many statements in the interpreter must be executed in order to execute one statement in the interpreted program it is running.</P>
<P>Another disadvantage of interpreted languages is that the interpreter must be installed on every computer that runs the program. Compilers need only be installed on the machine where the program is compiled. Since the executable contains machine language, it will run on any computer with the same architecture and a binary compatible operating system. Some x86-based Unix operating systems can run each other's executables, even though they have a slightly different format. Some can also run certain Windows executables directly, provided the WINE API is installed.</P>
<P>The main advantage that is often cited for interpreted programs is that you don't have to wait for it to compile before you can test it. This fact is vastly overrated, however, since compilation generally doesn't take very long. Modern computers can compile many thousands of lines of code per second. In addition, a well-designed software project need only recompile a small portion of the program in order to generate a new executable after minor changes. Hence, the startup time for a compiled program isn't much different from that of an interpreted program.</P>
<P>Interpreters do have another advantage, however. Interpreter can act as an "overseer", and perform complex housekeeping and debugging operations that can be difficult to insert into a compiled executable. For this reason, there have historically been some C development suites that provided both a C compiler and a C interpreter for debugging.</P>
<P>Also, execution speed often doesn't matter much. So-called "scripting languages", which are used to write short programs to automate execution of other programs, don't need to be fast, since they are short, and most of the work is actually done by the other programs they execute.</P>Table<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=xref title="Table&nbsp;3.2.&nbsp;Selection Sort of 50,000 Integers" href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch03s02.html#exe_speed">Table&nbsp;3.2, &#8220;Selection Sort of 50,000 Integers&#8221;</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>summarizes the difference in execution speed between several languages.
<DIV class=table><A name=exe_speed></A>
<P class=title><B>Table&nbsp;3.2.&nbsp;Selection Sort of 50,000 Integers</B></P>
<DIV class=table-contents>
<TABLE summary="Selection Sort of 50,000 Integers" border=1>
<COLGROUP>
<COL>
<COL>
<COL></COLGROUP>
<THEAD>
<TR>
<TH align=left>Language</TH>
<TH align=left>Execution method</TH>
<TH align=left>Time (seconds)</TH></TR></THEAD>
<TBODY>
<TR>
<TD align=left>GNU C</TD>
<TD align=left>Compiled</TD>
<TD align=left>4.01</TD></TR>
<TR>
<TD align=left>GNU C++</TD>
<TD align=left>Compiled</TD>
<TD align=left>4.07</TD></TR>
<TR>
<TD align=left>GNU Fortran</TD>
<TD align=left>Compiled</TD>
<TD align=left>5.23</TD></TR>
<TR>
<TD align=left>Java+JIT</TD>
<TD align=left>Mixed</TD>
<TD align=left>6.14</TD></TR>
<TR>
<TD align=left>Matlab</TD>
<TD align=left>Interpreted</TD>
<TD align=left>44.39</TD></TR>
<TR>
<TD align=left>Java without JIT</TD>
<TD align=left>Byte-code Interpreted</TD>
<TD align=left>64.74</TD></TR>
<TR>
<TD align=left>Perl</TD>
<TD align=left>Interpreted</TD>
<TD align=left>589</TD></TR>
<TR>
<TD align=left>C-shell</TD>
<TD align=left>Interpreted</TD>
<TD align=left>178,500 (extrapolated)</TD></TR></TBODY></TABLE></DIV></DIV><BR class=table-break>
<P>Execution times can vary significantly with different compilers and different algorithms. The sample of times above should only be viewed as a rough estimate.</P>
<P>Generally speaking, if execution speed matters, use a compiled language. If it doesn't, then use the most convenient language for the job.</P>
<P>Most interpreted languages have built-in routines that can perform common task efficiently. For example, the Perl interpreter is written in C, and has a built-in sort function that is also written in C and compiled into the Perl package. Hence, a good Perl programmer would not implement a sort function in Perl. Matlab has many built-in functions for processing matrices. These functions are written in compiled languages, mostly C and Fortran, and hence run at near optimal speed.</P>
<P>However, no language can provide more than a small fraction of all the functions needed by all users, so if you're coding in an interpreted language, you will eventually need to implement algorithms in it, or find a way to incorporate code written in a compiled language. The latter is complicated, and you may find it easier to implement the entire project in a compiled language. Furthermore, most programmers never become fully aware of the built-in routines available in a language, and end up implementing equivalent functionality that is far less efficient.</P>
<P>Choosing the wrong language for a large project can be extremely costly.</P>
<P>If 1000 people use the software, and each of them wastes 10 minutes a day waiting for the software unnecessarily, then 1000 * 10 minutes = 166 man-hours per day are wasted because of poor software performance. If the average user is paid $25 per hour including benefits, then 166 * $25 = $4,125 is lost each day.</P>
<P>If you find that performance is unacceptable, you may end up rewriting the entire program in a compiled language.</P>
<P>This happens frequently with Matlab programs, which are often rewritten in C, C++, or Fortran. Most such programs are small, so this is usually more of a nuisance than a catastrophe. Nevertheless, it causes big delays in product release or research publication. Matlab is much more than a programming language, and provides a wealth of useful tools for engineering and scientific research. However, the interpreted language included with the Matlab system is orders of magnitude slower than a compiled language such as Fortran.</P>
<P>RPM (the Redhat Package Manager, now called RPM Package Manager) is a grand example. This is a large and sophisticated software installation tool that was originally written in Perl, well-developed and tested through several major versions, and then completely rewritten in C to improve performance.</P>
<P>Rewriting software is a colossal waste of precious man-hours that could be used to develop<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>new</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>code. There is already (and probably always will be) a severe shortage of good programmers, so it is important to ensure that their valuable time is well spent.</P>
<P>The rewrite of RPM was done by volunteers donating their time to an open source project. Rewriting software while getting paid raises concerns of competency and ethics as well. Should programmers be paid to rewrite software if they made a poor choice of language the first time around? Managers must trust computer professionals to make technical decisions that they themselves are not qualified for. It is therefore the responsibility of the computer professional to become knowledgeable (on their own) before making important decisions for the company.</P></DIV>
<DIV class=section title="Languages that Don't Completely Fit Either Model">
<DIV class=titlepage>
<DIV>
<DIV>
<H5 class=title><A name=id286954501></A>Languages that Don't Completely Fit Either Model</H5></DIV></DIV></DIV>
<P>The Java language doesn't quite fit the definition of either compiled or interpreted. Although Java programs must be "compiled" to a .class file before they can be executed, the .class file does not contain actual machine language. Instead, it contains Java byte code, which is interpreted by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>Java Virtual Machine (JVM)</EM></SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=indexterm name=id286954512></A><A class=indexterm name=id286954516></A>The Java byte code is a sort of pseudo machine language, which can be interpreted very efficiently. This is why Java even without the just-in-time (JIT) compiler is much faster than the other interpreted languages.</P>
<P>Without the JIT compiler, Java falls cleanly into the category of an interpreted language. With the JIT compiler enabled, strange and complicated things happen when a Java program is executed. The first time each element of a Java program is executed, the JIT compiler converts the Java byte code to the native<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=indexterm name=id286954523></A><A class=indexterm name=id286954528></A>machine language of the machine running the JVM. This causes the execution to go even slower, since the JVM is now parsing, executing, and translating the code before moving on to the next element. However, the next time the same element is executed (assuming it's inside a loop), the native machine code is executed, so it runs at roughly the same speed that it would had it been written in a compiled language. Note that the JIT compiler never outputs a machine code executable. The compilation is performed while the program is being interpreted, and the resulting machine code is kept in memory.</P>
<P>Many other interpreted languages are actually<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>crunched</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to a simpler binary format that is more efficient to interpret, before execution begins. Strings such as "for", "while", and "switch" in a Perl program are reduced to binary integers, which can be identified with a single compare instruction, where as identifying the original string form requires a loop to compare all the characters. This reduces run time significantly, but as the table above demonstrates, it still does not come close to a compiled language for execution speed.</P></DIV></DIV></DIV>
<DIV class=section title="3.2.4.&nbsp;Open Standard vs. Proprietary">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286954542></A>3.2.4.&nbsp;Open Standard vs. Proprietary</H3></DIV></DIV></DIV>
<P>Open standard languages are usually preferable for the long-term.</P>
<P>Open standard languages include C, C++, Fortran, Perl, PHP, Python, Ruby, and many more. There are usually multiple vendors as well as free open source implementations for compilers and interpreters, and they can be used on most common hardware (PowerPC, MIPS, x86, etc.) and operating systems (BSD, Linux, Mac, Windows, etc.).</P>
<P>Proprietary languages include Matlab, Labview, PIC Basic, etc. Proprietary languages are often attractive in the short-term due to specific features that meet a particular need, but they have some major drawbacks.</P>
<P>They can only be purchased from one vendor. Support and pricing from that vendor will vary over time. While support and cost may be reasonable now, the company may decide in the future that the product is not profitable, and support for new versions of the operating system could be poor or non-existent. The company could go out of business, and the product could be completely discontinued.</P>
<P>Once you have invested many man-hours in developing software in a proprietary language, you are at the mercy of the vendor in order to keep the software current.</P>
<P>Proprietary languages can only be used on hardware and operating systems that the vendor deems profitable. Most vendors only support one or two platforms, and the quality of support decays with the popularity of the platform. E.g., many companies offer full support for Windows, limited support for Mac, minimal support for Linux, and no support for anything else. If you need to run some Windows-only software, and some Mac-only software, you will need to maintain both Windows and Mac installations.</P></DIV>
<DIV class=section title="3.2.5.&nbsp;Criteria for Selecting a Language">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286954569></A>3.2.5.&nbsp;Criteria for Selecting a Language</H3></DIV></DIV></DIV>
<P>The computer science field is full of religious devotion to languages. Some programmers will insist that Python is better than Perl, C++ is better than Java, or vice versa.</P>
<P>When selecting a language, use objective criteria, and ignore hype from devotees. Many of the arguments you will hear are subjective, but there are objective criteria for language selection:</P>
<DIV class=itemizedlist>
<UL class=itemizedlist type=disc>
<LI class=listitem>Is it compiled or interpreted?</LI>
<LI class=listitem>What is the general execution speed?</LI>
<LI class=listitem>Is it proprietary or open standard?</LI>
<LI class=listitem>Is it portable across different hardware and operating systems, or will you be locked into using one platform in order to keep your code running?</LI></UL></DIV></DIV>
<DIV class=section title="3.2.6.&nbsp;Creeping Feature Syndrome">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286954598></A>3.2.6.&nbsp;Creeping Feature Syndrome</H3></DIV></DIV></DIV>
<P>During the 1960s, many new languages evolved, and the push was to add more and more capabilities. This led to languages such as ADA, PL/I, and COBOL, and eventually the notion of<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>creeping feature syndrome</EM>, which is the proliferation of too many features that don't add significant value to the product. ( We see this in cars today, which are full of gadgets that drive up the price and really aren't much help to the driver. )</P>
<P>Around 1970, Dennis Ritchie at Bell Labs developed the C language. The design philosophy was minimalist, aimed at avoiding creeping feature syndrome. As a result, C includes only features that could not be provided as subprograms. For example, C has no built-in I/O statements, and only minimal built-in support for strings. Simple operations like string comparison and string assignment are carried out by library functions which are not part of the C language, and in fact are written in C:</P><PRE class=programlisting>	    /* See if name is "Bob" */
	    if ( strcmp(name, "Bob") == 0 )
	    {
	    }
	    
	    strlcpy(name, "Bob", NAME_MAX);
	    </PRE>
<P>Ritchie noted that providing support for features like I/O and strings complicates the language grammar significantly, and provides only superficial advantage to the programmer. The ability to write</P><PRE class=programlisting>	    if ( name == "Bob" )
	    {
	    }
	    </PRE>
<P>instead of using<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE class=function>strcmp()</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>serves only to make the code a little prettier. It's impossible to create a language with all the features desired by every programmer, so ultimately it's more important to provide extensibility than intrinsic features. The ability to create libraries of subprograms is the common solution across most languages. Library functions can be fixed, enhanced, and replaced without the need to upgrade the compiler or interpreter.</P>
<P>Unfortunately, the lessons of the 1960s appear to have been lost on the next generation after Ritchie's, and we're now seeing another proliferation of feature-loaded languages being developed. Be skeptical about languages that promise to cut your development time in half. It may work out for small projects, but as the project grows, you will begin to discover which critical features are<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>not</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>there.</P>
<P>A high-level tool such as Matlab is not a replacement for general purpose programming languages. Most researchers will eventually will need to do general software development, so it would be wise to maintain your general programming skills in a compiled language. For this very reason, Matlab has the ability to integrate C and Fortran code into Matlab programs, so that users can write efficient extensions adding features that Matlab doesn't provide. You may want to think about whether it's better to build a large project using a mixture of two languages, or keep it cleaner and simpler by using the general-purpose language for all of it.</P></DIV></DIV>
<DIV class=navfooter style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<HR>

<TABLE width="100%" summary="Navigation footer">
<TBODY>
<TR>
<TD align=left width="40%"><A accessKey=p href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch03.html">Prev</A>&nbsp;</TD>
<TD align=middle width="20%"><A accessKey=u href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch03.html">Up</A></TD>
<TD align=right width="40%">&nbsp;<A accessKey=n href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch03s03.html">Next</A></TD></TR>
<TR>
<TD vAlign=top align=left width="40%">Chapter&nbsp;3.&nbsp;Software Development&nbsp;</TD>
<TD align=middle width="20%"><A accessKey=h href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/index.html">Home</A></TD>
<TD vAlign=top align=right width="40%">&nbsp;3.3.&nbsp;Engineering Product Life Cycle</TD></TR></TBODY></TABLE></DIV>