<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 20 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Abstract Members</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>A member of a class or trait is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">abstract</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the member does not have a complete definition in the class.<A id=i785070065-1></A><A id=i184187235-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Abstract members are intended to be implemented in subclasses of the class in which they are declared. This idea is found in many object-oriented languages. For instance, Java lets you declare abstract methods. Scala also lets you declare such methods, as you saw in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#sec:abstract-classes">Section 10.2</A>. But Scala goes beyond that and implements the idea in its full generality: besides methods, you can also declare abstract fields and even abstract types as members of classes and traits.</P>
<P>In this chapter we'll describe all four kinds of abstract member:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s, methods, and types. Along the way we'll discuss pre-initialized fields, lazy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s, path-dependent types, and enumerations.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=20.1></A>20.1 A quick tour of abstract members<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#20.1">link</A>]</SPAN></H3>
<P>The following trait declares one of each kind of abstract member: an abstract type (<SPAN class=code>T</SPAN>), method (<SPAN class=code>transform</SPAN>),<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<SPAN class=code>initial</SPAN>), and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<SPAN class=code>current</SPAN>):<A id=i-1463644999-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Abstract</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;T
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;transform(x:&nbsp;T):&nbsp;T
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;initial:&nbsp;T
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;current:&nbsp;T
  }
</PRE>A concrete implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Abstract</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>needs to fill in definitions for each of its abstract members. Here is an example implementation that provides these definitions:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Concrete</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Abstract</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;T&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;transform(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&nbsp;x&nbsp;+&nbsp;x
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;initial&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hi"</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;current&nbsp;=&nbsp;initial
  }
</PRE>The implementation gives a concrete meaning to the type name<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by defining it as an alias of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>.<A id=i1803174454-1></A><A id=i22781976-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>transform</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation concatenates a given string with itself, and the<SPAN class=code>initial</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>current</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>values are both set to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"hi"</SPAN>. 
<P></P>
<P>This example gives you a rough first idea of what kinds of abstract members exist in Scala. The remainder of the chapter will present the details and explain what the new forms of abstract members, as well as type members in general, are good for.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=20.2></A>20.2 Type members<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#20.2">link</A>]</SPAN></H3>
<P><A name=sec:abstract-vals></A></P>
<P>As you can see from the example in the previous section, the term<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">abstract type</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala means a type<A id=i1886198323-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>declared (with the "<SPAN class=code>type</SPAN>" keyword) to be a member of a class or trait, without specifying a definition.<A id=i475521275-1></A><A id=i-1569140754-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Classes themselves may be abstract, and traits are by definition abstract, but neither of these are what are referred to as<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">abstract types</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala. An abstract type in Scala is always a member of some class or trait, such as type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Abstract</SPAN>.</P>
<P>You can think of a non-abstract (or, "concrete") type member, such as type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Concrete</SPAN>, as a way to define a new name, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">alias</EM>, for a type.<A id=i22781976-2></A><A id=i1803174454-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Concrete</SPAN>, for example, the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is given the alias<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. As a result, anywhere<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>appears in the definition of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Concrete</SPAN>, it means<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>. This includes the parameter and result types of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>transform</SPAN>,<SPAN class=code>initial</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>current</SPAN>, which mention<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>when they are declared in supertrait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Abstract</SPAN>. Thus, when class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Concrete</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>implements these methods, those<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>s are interpreted to mean<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>.</P>
<P>One reason to use a type member is to define a short, descriptive alias<A id=i22781976-3></A><A id=i1803174454-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>for a type whose real name is more verbose, or less obvious in meaning, than the alias. Such type members can help clarify the code of a class or trait. The other main use of type members is to declare abstract types that must be defined in subclasses. This use, which was demonstrated in the previous section, will be described in detail later in this chapter.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=20.3></A>20.3 Abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#20.3">link</A>]</SPAN></H3>
<P><A name=sec:abstract-vals></A></P>
<P>An abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>declaration has a form like:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;initial:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>
</PRE>It gives a name and type for a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>, but not its value.<A id=i1727592746-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This value has to be provided by a concrete<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition in a subclass. For instance, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Concrete</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>implemented the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>using:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;initial&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hi"</SPAN>
</PRE>You use an abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>declaration in a class when you do not know the correct value in the class, but you do know that the variable will have an unchangeable value in each instance of the class. 
<P></P>
<P>An abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>declaration resembles an abstract parameterless<A id=i1692897037-1></A><A id=i748048051-1></A><A id=i84167179-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>method declaration such as:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;initial:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>
</PRE>Client code would refer to both the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the method in exactly the same way,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>obj.initial</SPAN>. However, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>initial</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>, the client is guaranteed that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>obj.initial</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will yield the same value every time it is referenced. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>initial</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>were an abstract method, that guarantee would not hold, because in that case<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>initial</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>could be implemented by a concrete method that returns a different value every time it's called. 
<P></P>
<P>In other words, an abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>constrains its legal implementation: any implementation must be a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition; it may not be a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN>. Abstract method declarations, on the other hand, may be implemented by both concrete method definitions and concrete<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definitions. Given the abstract class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:bad-apple">Listing 20.1</A>, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be a legal subclass implementation, but class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BadApple</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would not.<A name=lst:bad-apple></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fruit</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;v:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;`v'&nbsp;for&nbsp;value</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;m:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;`m'&nbsp;for&nbsp;method</SPAN>
  }
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Apple</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fruit</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;v:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;m:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;OK&nbsp;to&nbsp;override&nbsp;a&nbsp;`def'&nbsp;with&nbsp;a&nbsp;`val'</SPAN>
  }
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BadApple</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fruit</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;v:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;ERROR:&nbsp;cannot&nbsp;override&nbsp;a&nbsp;`val'&nbsp;with&nbsp;a&nbsp;`def'</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;m:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>
  }
</PRE>
<H5>Listing 20.1 - Overriding abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s and parameterless methods.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=20.4></A>20.4 Abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#20.4">link</A>]</SPAN></H3>
<P>Like an abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>, an abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>declares just a name and a type, but not an initial value<A id=i-464180816-1></A>. For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:abstract-vars">Listing 20.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AbstractTime</SPAN>, which declares two abstract variables named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hour</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>minute</SPAN>:</P>
<P><A name=lst:abstract-vars></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractTime</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;hour:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;minute:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 20.2 - Declaring abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s.</H5>
<P>What is the meaning of abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hour</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>minute</SPAN>? You saw in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#sec:properties">Section 18.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s declared as members of classes come equipped with getter and setter methods<A id=i553650449-2></A><A id=i-1969580643-3></A>. This holds for abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s as well. If you declare an abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hour</SPAN>, for example, you implicitly declare an abstract getter method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hour</SPAN>, and an abstract setter method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hour_=</SPAN>. There's no reassignable field to be defined&#8212;that will come in subclasses that define the concrete implementation of the abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>. For instance, the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AbstractTime</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:abstract-vars">Listing 20.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is exactly equivalent to the definition shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:abstract-vars-expanded">Listing 20.3</A>.<A name=lst:abstract-vars-expanded></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractTime</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hour:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;getter&nbsp;for&nbsp;`hour'</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hour_=(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;setter&nbsp;for&nbsp;`hour'</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;minute:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;getter&nbsp;for&nbsp;`minute'</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;minute_=(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;setter&nbsp;for&nbsp;`minute'</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 20.3 - How abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s are expanded into getters and setters.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=20.5></A>20.5 Initializing abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#20.5">link</A>]</SPAN></H3>
<P><A name=sec:val-init></A></P>
<P>Abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s sometimes play a role analogous to superclass parameters: they let you provide details in a subclass that are missing in a superclass. This is particularly important for traits, because traits don't have a constructor to which you could pass<A id=i-1985442764-1></A><A id=i-280981118-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameters. So the usual notion of parameterizing a trait works via abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s that are implemented in subclasses.<A id=i1371895904-1></A><A id=i-1767979071-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>As an example, consider a reformulation of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html">Chapter 6</A>, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html#lst:overloaded-methods">Listing 6.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html#lst:overloaded-methods">here</A>, as a trait:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RationalTrait</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numerArg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denomArg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;
  }&nbsp;
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class from<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html">Chapter 6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>had two parameters:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>n</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for the numerator of the rational number, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>d</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for the denominator. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RationalTrait</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait given here defines instead two abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numerArg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denomArg</SPAN>. To instantiate a concrete instance of that trait, you need to implement the abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definitions. Here's an example:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RationalTrait</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numerArg&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denomArg&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  }
</PRE>Here the keyword<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>appears in front of a trait name,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RationalTrait</SPAN>, which is followed by a class body in curly braces. This expression yields an instance of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-113939451"><EM style="FONT-STYLE: italic">anonymous class</EM></A>that mixes in the trait and is defined by the body<A id=i-2121626765-1></A><A id=i-899295719-1></A>. This particular anonymous class instantiation has an effect analogous to the instance creation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN>&nbsp;<SPAN class=code>Rational(1,</SPAN>&nbsp;<SPAN class=code>2)</SPAN>. The analogy is not perfect, however. There's a subtle difference concerning the order in which expressions are initialized. When you write:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>(expr1,&nbsp;expr2)
</PRE>the two expressions,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr2</SPAN>, are evaluated before class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is initialized, so the values of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are available for the initialization of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN>. For traits, however, the situation is the opposite. When you write:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RationalTrait</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numerArg&nbsp;=&nbsp;expr1
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denomArg&nbsp;=&nbsp;expr2
  }
</PRE>the expressions,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr2</SPAN>, are evaluated as part of the initialization of the anonymous class, but the anonymous class is initialized<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">after</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RationalTrait</SPAN>. So the values of<SPAN class=code>numerArg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denomArg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are not available during the initialization of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RationalTrait</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(more precisely, a selection of either value would yield the default value for type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>, 0). For the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RationalTrait</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>given previously, this is not a problem, because the trait's initialization does not make use of values<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numerArg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denomArg</SPAN>. However, it does become a problem in the variant of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RationalTrait</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:rational-trait">Listing 20.4</A>, which defines normalized numerators and denominators: 
<P></P>
<P><A name=lst:rational-trait></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RationalTrait</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numerArg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denomArg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;require(denomArg&nbsp;!=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;g&nbsp;=&nbsp;gcd(numerArg,&nbsp;denomArg)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numer&nbsp;=&nbsp;numerArg&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denom&nbsp;=&nbsp;denomArg&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;gcd(a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;b:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(b&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;a&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;gcd(b,&nbsp;a&nbsp;%&nbsp;b)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"/"</SPAN>+&nbsp;denom
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 20.4 - A trait that uses its abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s.</H5>
<P>If you try to instantiate this trait with some numerator and denominator expressions that are not simple literals, you'll get an exception:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">x:&nbsp;Int&nbsp;=&nbsp;2</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RationalTrait</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numerArg&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denomArg&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">java.lang.IllegalArgumentException:&nbsp;requirement&nbsp;failed</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;scala.Predef$.require(Predef.scala:107)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;RationalTrait$class.$init$(&lt;console&gt;:7)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;$anon$1.&lt;init&gt;(&lt;console&gt;:7)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....</SPAN>
</PRE>The exception in this example was thrown because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denomArg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>still had its default value of 0 when class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RationalTrait</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was initialized, which caused the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>require</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>invocation to fail. 
<P></P>
<P>This example demonstrates that initialization order is not the same for class parameters and abstract fields.<A id=i-1695985614-1></A><A id=i-17530359-1></A><A id=i-1356458045-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>A class parameter argument is evaluated<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">before</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>it is passed to the class constructor (unless the parameter is by-name). An implementing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition in a subclass, by contrast, is evaluated only<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">after</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the superclass has been initialized.</P>
<P>Now that you understand why abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s behave differently from parameters, it would be good to know what can be done about this. Is it possible to define a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RationalTrait</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that can be initialized robustly, without fearing errors due to uninitialized fields? In fact, Scala offers two alternative solutions to this problem,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">pre-initialized fields</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">lazy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s</SPAN>. They are presented in the remainder of this section.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Pre-initialized fields</H4>
<P>The first solution, pre-initialized fields, lets you initialize a field of a subclass before the superclass is called.<A id=i-1387085847-1></A><A id=i483675481-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>To do this, simply place the field definition in braces before the superclass constructor call. As an example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:pre-init-anon-class">Listing 20.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows another attempt to create an instance of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RationalTrait</SPAN>. As you see from this example, the initialization section comes before the mention of the supertrait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RationalTrait</SPAN>. Both are separated by<SPAN class=Apple-converted-space>&nbsp;</SPAN>a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>with</SPAN>.</P>
<P><A name=lst:pre-init-anon-class></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numerArg&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denomArg&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;*&nbsp;x&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RationalTrait</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;res15:&nbsp;java.lang.Object&nbsp;with&nbsp;RationalTrait&nbsp;=&nbsp;1/2</SPAN>
</PRE>
<H5>Listing 20.5 - Pre-initialized fields in an anonymous class expression.</H5>
<P><A name=lst:pre-init-fields-object></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;twoThirds&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numerArg&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denomArg&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>
  &nbsp;&nbsp;}&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RationalTrait</SPAN>
</PRE>
<H5>Listing 20.6 - Pre-initialized fields in an object definition.</H5>
<P>Pre-initialized fields are not restricted to anonymous classes; they can also be used in objects or named subclasses. Two examples are shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:pre-init-fields-object">Listings 20.6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:pre-init-fields-class">and 20.7</A>. As you can see from these examples, the pre-initialization section comes in each case after the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>extends</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword of the defined object or class. Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RationalClass</SPAN>, shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:pre-init-fields-class">Listing 20.7</A>, exemplifies a general schema of how class parameters can be made available for the initialization of a supertrait.</P>
<P>Because pre-initialized fields are initialized before the superclass constructor is called, their initializers cannot refer to the object that's being constructed. Consequently, if such an initializer refers to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN>, the reference goes to the object containing the class or object that's being constructed, not the constructed object itself. Here's an example:<A id=i988779894-2></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numerArg&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denomArg&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.numerArg&nbsp;*&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RationalTrait</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:8:&nbsp;error:&nbsp;value&nbsp;numerArg&nbsp;is&nbsp;not&nbsp;a</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;of&nbsp;object&nbsp;$iw</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;denomArg&nbsp;=&nbsp;this.numerArg&nbsp;*&nbsp;2</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P><A name=lst:pre-init-fields-class></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RationalClass</SPAN>(n:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;d:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numerArg&nbsp;=&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denomArg&nbsp;=&nbsp;d
  &nbsp;&nbsp;}&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RationalTrait</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;+&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RationalClass</SPAN>)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RationalClass</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 20.7 - Pre-initialized fields in a class definition.</H5>
<P>The example did not compile because the reference<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this.numerArg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was looking for a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numerArg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field in the object containing the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(which in this case was the synthetic object named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>$iw</SPAN>, into which the interpreter puts user input lines). Once more, pre-initialized fields behave in this respect like class constructor arguments.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Lazy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s</H4>
<P>You can use pre-initialized fields to simulate precisely the initialization behavior of class constructor arguments. Sometimes, however, you might prefer to let the system itself sort out how things should be initialized. This can be achieved by making your<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definitions<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">lazy</EM>. If you prefix a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>lazy</SPAN><A id=i1386009102-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier, the initializing expression on the right-hand side will only be evaluated the first time the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used.</P>
<P>For an example, define an object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Demo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Demo</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x&nbsp;=&nbsp;{&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"initializing&nbsp;x"</SPAN>);&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"done"</SPAN>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">defined&nbsp;module&nbsp;Demo</SPAN>
</PRE>Now, first refer to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Demo</SPAN>, then to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Demo.x</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Demo</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">initializing&nbsp;x</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res19:&nbsp;Demo.type&nbsp;=&nbsp;Demo$@97d1ff</SPAN>
  <BR>  scala&gt;&nbsp;Demo.x
  <SPAN class=output style="COLOR: rgb(90,0,0)">res20:&nbsp;java.lang.String&nbsp;=&nbsp;done</SPAN>
</PRE>As you can see, the moment you use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Demo</SPAN>, its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field becomes initialized. The initialization of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>forms part of the initialization of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Demo</SPAN>. The situation changes, however, if you define the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field to be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>lazy</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Demo</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lazy&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x&nbsp;=&nbsp;{&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"initializing&nbsp;x"</SPAN>);&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"done"</SPAN>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">defined&nbsp;module&nbsp;Demo</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Demo</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res21:&nbsp;Demo.type&nbsp;=&nbsp;Demo$@d81341</SPAN>
  <BR>  scala&gt;&nbsp;Demo.x
  <SPAN class=output style="COLOR: rgb(90,0,0)">initializing&nbsp;x</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res22:&nbsp;java.lang.String&nbsp;=&nbsp;done</SPAN>
</PRE>Now, initializing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Demo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not involve initializing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>. The initialization of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be deferred until the first time<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used. 
<P></P>
<P><A name=lst:init-trait-lazy-vals></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LazyRationalTrait</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numerArg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denomArg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;lazy&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numer&nbsp;=&nbsp;numerArg&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;lazy&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denom&nbsp;=&nbsp;denomArg&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"/"</SPAN>+&nbsp;denom
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;lazy&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;g&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require(denomArg&nbsp;!=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcd(numerArg,&nbsp;denomArg)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;gcd(a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;b:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(b&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;a&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;gcd(b,&nbsp;a&nbsp;%&nbsp;b)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 20.8 - Initializing a trait with lazy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s.</H5>
<P>This is similar to the situation where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined as a parameterless method, using a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN>. However, unlike a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>a lazy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is never evaluated more than once<A id=i-861970308-1></A><A id=i3314548-1></A>. In fact, after the first evaluation of a lazy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the result of the evaluation is stored, to be reused when the same<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used subsequently.</P>
<P>Looking at this example, it seems that objects like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Demo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>themselves behave like lazy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s, in that they are also initialized on demand, the first time they are used. This is correct. In fact an object definition can be seen as a shorthand for the definition of a lazy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with an anonymous class that describes the object's contents.</P>
<P>Using lazy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s, you could reformulate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RationalTrait</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:init-trait-lazy-vals">Listing 20.8</A>. In the new trait definition, all concrete fields are defined<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>lazy</SPAN>. Another change with respect to the previous definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RationalTrait</SPAN>, shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:rational-trait">Listing 20.4</A>, is that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>require</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause was moved from the body of the trait to the initializer of the private field,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>g</SPAN>, which computes the greatest common divisor of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numerArg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denomArg</SPAN>. With these changes, there's nothing that remains to be done when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LazyRationalTrait</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is initialized; all initialization code is now part of the right-hand side of a lazy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>. Therefore, it is safe to initialize the abstract fields of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LazyRationalTrait</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>after the class is defined. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">x:&nbsp;Int&nbsp;=&nbsp;2</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LazyRationalTrait</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numerArg&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denomArg&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;java.lang.Object&nbsp;with&nbsp;LazyRationalTrait&nbsp;=&nbsp;1/2</SPAN>
</PRE>No pre-initialization is needed. It's instructive to trace the sequence of initializations that lead to the string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1/2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be printed in the code above: 
<P></P>
<OL>
<LI>First, a fresh instance of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LazyRationalTrait</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>gets created, and the initialization code of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LazyRationalTrait</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is run. This initialization code is empty&#8212;none of the fields of<SPAN class=code>LazyRationalTrait</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is as yet initialized. 
<LI>Next, the primary constructor of the anonymous subclass defined by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression is executed. This involves the initialization of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numerArg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denomArg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>4</SPAN>. 
<LI>Next, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is invoked on the constructed object by the interpreter, so that the resulting value can be printed. 
<LI>Next, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field is accessed for the first time by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LazyRationalTrait</SPAN>, so its initializer is evaluated. 
<LI>The initializer of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>accesses the private field,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>g</SPAN>, so<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>g</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is evaluated next. This evaluation accesses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numerArg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denomArg</SPAN>, which were defined in Step 2. 
<LI>Next, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method accesses the value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denom</SPAN>, which causes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denom</SPAN>'s evaluation. The evaluation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denom</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>accesses the values of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denomArg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>g</SPAN>. The initializer of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>g</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field is not re-evaluated, because it was already evaluated in Step 5. 
<LI>Finally, the result string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"1/2"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is constructed and printed.</LI></OL>Note that the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>g</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>comes textually after the definitions of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denom</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LazyRationalTrait</SPAN>. Nevertheless, because all three values are lazy,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>g</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>gets initialized before the initialization of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denom</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is completed. This shows an important property of lazy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s: the textual order of their definitions does not matter, because values get initialized on demand. Therefore, lazy vals can free you as a programmer from having to think hard how to arrange<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definitions to ensure that everything is defined when it is needed. 
<P>However, this advantage holds only as long as the initialization of lazy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s neither produces side effects nor depends on them. In the presence of side effects, initialization order starts to matter. And then it can be quite difficult to trace in what order initialization code is run, as the previous example has demonstrated. So lazy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s are an ideal complement to functional objects, where the order of initializations does not matter, as long as everything gets initialized eventually<A id=i-1860042908-1></A>. They are less well suited for code that's predominantly imperative.</P>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Lazy functional languages</H3>
<P>Scala is by no means the first language to have exploited the perfect match of lazy definitions and functional code. In fact, there is a category of "lazy functional programming languages" in which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">every</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>value and parameter is initialized lazily<A id=i-748662080-1></A>. The best known member of this class of languages is Haskell<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#haskell98">haskell98</A><A id=i-156161824-1></A>.</P></DIV>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=20.6></A>20.6 Abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>type</SPAN>s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#20.6">link</A>]</SPAN></H3>
<P><A name=sec:abstract-types></A></P>
<P>In the beginning of this chapter, you saw, "<SPAN class=code>type</SPAN>&nbsp;<SPAN class=code>T</SPAN>", an abstract type declaration<A id=i-332843517-1></A><A id=i669006587-1></A>. The rest of this chapter discusses what such an abstract type declaration means and what it's good for. Like all other abstract declarations, an abstract type declaration is a placeholder for something that will be defined concretely in subclasses. In this case, it is a type that will be defined further down the class hierarchy. So<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>above refers to a type that is at yet unknown at the point where it is declared. Different subclasses can provide different realizations of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>.</P>
<P>Here is a well-known example where abstract types show up naturally. Suppose you are given the task of modeling the eating habits of animals. You might start with a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Food</SPAN>and a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Food</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;eat(food:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Food</SPAN>)
  }
</PRE>You might then attempt to specialize these two classes to a class of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cow</SPAN>s that eat<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Grass</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Grass</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Food</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cow</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;eat(food:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Grass</SPAN>)&nbsp;{}&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;This&nbsp;won't&nbsp;compile</SPAN>
  }
</PRE>However, if you tried to compile the new classes, you'd get the following compilation errors:<A id=i-1458364982-1></A><A id=i934798591-2></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">BuggyAnimals.scala:7:&nbsp;error:&nbsp;class&nbsp;Cow&nbsp;needs&nbsp;to&nbsp;be</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">abstract,&nbsp;since&nbsp;method&nbsp;eat&nbsp;in&nbsp;class&nbsp;Animal&nbsp;of&nbsp;type</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;(Food)Unit&nbsp;is&nbsp;not&nbsp;defined</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">class&nbsp;Cow&nbsp;extends&nbsp;Animal&nbsp;{</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">BuggyAnimals.scala:8:&nbsp;error:&nbsp;method&nbsp;eat&nbsp;overrides&nbsp;nothing</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;override&nbsp;def&nbsp;eat(food:&nbsp;Grass)&nbsp;{}</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P>What happened is that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cow</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not override the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN>, because its parameter type is different&#8212;it's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Grass</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cow</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>vs.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Food</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN>.</P>
<P>Some people have argued that the type system is unnecessarily strict in refusing these classes. They have said that it should be OK to specialize a parameter of a method in a subclass. However, if the classes were allowed as written, you could get yourself in unsafe situations very quickly. For instance, the following script would pass the type checker:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Food</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;eat(food:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Food</SPAN>)
  }
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Grass</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Food</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cow</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;eat(food:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Grass</SPAN>)&nbsp;{}&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;This&nbsp;won't&nbsp;compile,</SPAN>
  }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;but&nbsp;if&nbsp;it&nbsp;did,...</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fish</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Food</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bessy:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cow</SPAN>
  bessy&nbsp;eat&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fish</SPAN>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;...you&nbsp;could&nbsp;feed&nbsp;fish&nbsp;to&nbsp;cows.</SPAN>
</PRE>The program would compile if the restriction were eased, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cow</SPAN>s are<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN>s and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN>s do have an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that accepts any kind of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Food</SPAN>, including<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fish</SPAN>. But surely it would do a cow no good to eat a fish! 
<P></P>
<P>What you need to do instead is apply some more precise modeling.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN>s do eat<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Food</SPAN>, but what kind of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Food</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>each<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>eats depends on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN>. This can be neatly expressed with an abstract type, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:suitablefood-abstract-type">Listing 20.9</A>:</P>
<P><A name=lst:suitablefood-abstract-type></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Food</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SuitableFood</SPAN>&nbsp;&lt;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Food</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;eat(food:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SuitableFood</SPAN>)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 20.9 - Modeling suitable food with an abstract type.</H5>
<P>With the new class definition, an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can eat only food that's suitable. What food is suitable cannot be determined at the level of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. That's why<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SuitableFood</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is modeled as an abstract type. The type has an upper bound,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Food</SPAN>, which is expressed by the "<SPAN class=code>&lt;:</SPAN>&nbsp;<SPAN class=code>Food</SPAN>" clause. This means that any concrete instantiation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SuitableFood</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(in a subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN>) must be a subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Food</SPAN>. For example, you would not be able to instantiate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SuitableFood</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>IOException</SPAN>.</P>
<P><A name=lst:suitable-cow></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Grass</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Food</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cow</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SuitableFood</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Grass</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;eat(food:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Grass</SPAN>)&nbsp;{}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 20.10 - Implementing an abstract type in a subclass.</H5>
<P>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defined, you can now progress to cows, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:suitable-cow">Listing 20.10</A>. Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cow</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fixes its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SuitableFood</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Grass</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and also defines a concrete<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method for this kind of food. These new class definitions compile without errors. If you tried to run the "cows-that-eat-fish" counterexample with the new class definitions, you would get the following compiler error:<A id=i-677980410-4></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fish</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Food</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">defined&nbsp;class&nbsp;Fish</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bessy:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cow</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">bessy:&nbsp;Animal&nbsp;=&nbsp;Cow@674bf6</SPAN>
  <BR>  scala&gt;&nbsp;bessy&nbsp;eat&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fish</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:10:&nbsp;error:&nbsp;type&nbsp;mismatch;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Fish</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;required:&nbsp;bessy.SuitableFood</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bessy&nbsp;eat&nbsp;(new&nbsp;Fish)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=20.7></A>20.7 Path-dependent types<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#20.7">link</A>]</SPAN></H3>
<P><A name=sec:path-dependent-types></A></P>
<P>Have a look at the last error message: What's interesting about it is the<A id=i419165808-1></A><A id=i-2033041288-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>type required by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bessy.SuitableFood</SPAN>. This type consists of an object reference,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bessy</SPAN>, which is followed by a type field,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SuitableFood</SPAN>, of the object. So this shows that objects in Scala can have types as members. The meaning of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bessy.SuitableFood</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is "the type<SPAN class=code>SuitableFood</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that is a member of the object referenced from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bessy</SPAN>," or alternatively, the type of food that's suitable for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bessy</SPAN>. A type like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bessy.SuitableFood</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">path-dependent type</SPAN>. The word "path" here means a reference to an object. It could be a single name, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bessy</SPAN>, or a longer access path, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>farm.barn.bessy.SuitableFood</SPAN>, where each of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>farm</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>barn</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bessy</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are variables (or singleton object names) that refer to objects.</P>
<P>As the term "path-dependent type" says, the type depends on the path: in general, different paths give rise to different types. For instance, say you defined classes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>DogFood</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=code>Dog</SPAN>, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">DogFood</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Food</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dog</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SuitableFood</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">DogFood</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;eat(food:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">DogFood</SPAN>)&nbsp;{}
  }
</PRE>If you attempted to feed a dog with food fit for a cow, your code would not compile:<A id=i-677980410-5></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bessy&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cow</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">bessy:&nbsp;Cow&nbsp;=&nbsp;Cow@10cd6d</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;lassie&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dog</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">bootsie:&nbsp;Dog&nbsp;=&nbsp;Dog@d11fa6</SPAN>
  <BR>  scala&gt;&nbsp;lassie&nbsp;eat&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">bessy.SuitableFood</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:13:&nbsp;error:&nbsp;type&nbsp;mismatch;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Grass</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;required:&nbsp;DogFood</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lassie&nbsp;eat&nbsp;(new&nbsp;bessy.SuitableFood)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>The problem here is that the type of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SuitableFood</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object passed to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bessy.SuitableFood</SPAN>, is incompatible with the parameter type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eat</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>lassie.SuitableFood</SPAN>. The case would be different for two<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dog</SPAN>s however. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dog</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SuitableFood</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type is defined to be an alias for class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>DogFood</SPAN>, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SuitableFood</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>types of two<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dog</SPAN>s are in fact the same. As a result, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dog</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instance named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>lassie</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>could actually eat the suitable food of a different<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dog</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instance (which we'll name<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bootsie</SPAN>):</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bootsie&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dog</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">bootsie:&nbsp;Dog&nbsp;=&nbsp;Dog@54ca71</SPAN>
  <BR>  scala&gt;&nbsp;lassie&nbsp;eat&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">bootsie.SuitableFood</SPAN>)
</PRE>
<P></P>
<P>A path-dependent type resembles the syntax for an inner class type in Java<A id=i1051202392-1></A>, but there is a crucial difference: a path-dependent type names an outer<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">object</SPAN>, whereas an inner class type names an outer<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">class</SPAN>. Java-style inner class types can also be expressed in Scala, but they are written differently. Consider these two classes,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Outer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Inner</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Outer</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Inner</SPAN>
  }
</PRE>In Scala, the inner class is addressed using the expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Outer#Inner</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Outer.Inner</SPAN>. The `<SPAN class=code>.</SPAN>' syntax is reserved for objects.<A id=i-1229370884-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, imagine you instantiate two objects of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Outer</SPAN>, like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;o1&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Outer</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;o2&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Outer</SPAN>
</PRE>Here<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>o1.Inner</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>o2.Inner</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are two path-dependent types<A id=i1286205047-1></A><A id=i-1290990775-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>(and they are different types). Both of these types conform to (are subtypes of) the more general type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Outer#Inner</SPAN>, which represents the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Inner</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class with an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">arbitrary</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>outer object of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Outer</SPAN>. By contrast, type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>o1.Inner</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>refers to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Inner</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">specific</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>outer object (the one referenced from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>o1</SPAN>). Likewise, type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>o2.Inner</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>refers to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Inner</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class with a different, specific outer object (the one referenced from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>o2</SPAN>). 
<P></P>
<P>In Scala, as in Java, inner class instances hold a reference to an enclosing outer class instance. This allows an inner class, for example, to access members of its outer class. Thus you can't instantiate an inner class without in some way specifying an outer class instance. One way to do this is to instantiate the inner class inside the body of the outer class. In this case, the current outer class instance (referenced from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN>) will be used. Another way is to use a path-dependent type. For example, because the type,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>o1.Inner</SPAN>, names a specific outer object, you can instantiate it:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">o1.Inner</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;o1.Inner&nbsp;=&nbsp;Outer$Inner@13727f</SPAN>
</PRE>The resulting inner object will contain a reference to its outer object, the object referenced from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>o1</SPAN>. By contrast, because the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Outer#Inner</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not name any specific instance of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Outer</SPAN>, you can't create an instance of it:<A id=i-480808313-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Outer</SPAN>#<SPAN class=typename style="COLOR: rgb(103,0,154)">Inner</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:6:&nbsp;error:&nbsp;Outer&nbsp;is&nbsp;not&nbsp;a&nbsp;legal&nbsp;prefix&nbsp;for</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;a&nbsp;constructor</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Outer#Inner</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=20.8></A>20.8 Enumerations<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#20.8">link</A>]</SPAN></H3>
<P><A name=sec:enums></A></P>
<P>An interesting application of path-dependent types is found in Scala's support for enumerations. Some other languages, including Java and C#, have enumerations as a built-in language construct to define new types. Scala does not need special syntax for enumerations<A id=i-469710704-1></A><A id=i1297750808-1></A>. Instead, there's a class in its standard library,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Enumeration</SPAN><A id=i-1102794201-1></A>. To create a new enumeration, you define an object that extends this class, as in the following example, which defines a new enumeration of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Color</SPAN>s:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Color</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Enumeration</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Red</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Value</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Green</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Value</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Blue</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Value</SPAN>
  }
</PRE>Scala lets you also shorten several successive<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definitions with the same right-hand side. Equivalently to the above you could write:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Color</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Enumeration</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Red</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Green</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Blue</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Value</SPAN>
  }
</PRE>This object definition provides three values:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Color.Red</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Color.Green</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Color.Blue</SPAN>. You could also import everything in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Color</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;Color._
</PRE>and then just use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Red</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Green</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Blue</SPAN>. But what is the type of these values?<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Enumeration</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defines an inner class named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Value</SPAN>, and the same-named parameterless<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method returns a fresh instance of that class.<A id=i-1232708119-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This means that a value such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Color.Red</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Color.Value</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Color.Value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the type of all enumeration values defined in object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Color</SPAN>. It's a path-dependent type, with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Color</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>being the path and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>being the dependent type. What's significant about this is that it is a completely new type, different from all other types. In particular, if you would define another enumeration, such as:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Direction</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Enumeration</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">North</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">East</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">South</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">West</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Value</SPAN>
  }
</PRE>then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Direction.Value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be different from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Color.Value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>because the path parts of the two types differ. 
<P></P>
<P>Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Enumeration</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class also offers many other features found in the enumeration designs of other languages. You can associate names with enumeration values by using a different overloaded variant of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Direction</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Enumeration</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">North</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Value</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"North"</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">East</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Value</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"East"</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">South</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Value</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"South"</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">West</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Value</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"West"</SPAN>)
  }
</PRE>You can step through all values of an enumeration with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN>, or use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(d&nbsp;&lt;-&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Direction</SPAN>)&nbsp;print(d&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">North&nbsp;East&nbsp;South&nbsp;West&nbsp;</SPAN>
</PRE>Values of an enumeration are numbered from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN>, and you can find out the number of an enumeration value by its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>id</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;Direction.East.id
  <SPAN class=output style="COLOR: rgb(90,0,0)">res5:&nbsp;Int&nbsp;=&nbsp;1</SPAN>
</PRE>It's also possible to go the other way, from a non-negative integer number to the value that has this number as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>id</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in an enumeration:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Direction</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res6:&nbsp;Direction.Value&nbsp;=&nbsp;East</SPAN>
</PRE>This should be enough to get you started with enumerations. You can find more information in the Scaladoc comments of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Enumeration</SPAN>. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=20.9></A>20.9 Case study: Currencies<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#20.9">link</A>]</SPAN></H3>
<P><A name=sec:currencies></A></P>
<P>The rest of this chapter presents a case study that explains how abstract types can be used in Scala. The task is to design a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN>. A typical instance of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would represent an amount of money in dollars, euros, yen, or some other currency. It should be possible to do some arithmetic on currencies. For instance, you should be able to add two amounts of the same currency. Or you should be able to multiply a currency amount by a factor representing an interest rate.</P>
<P>These thoughts lead to the following first design for a currency class:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;A&nbsp;first&nbsp;(faulty)&nbsp;design&nbsp;of&nbsp;the&nbsp;Currency&nbsp;class</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;amount:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;designation:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;amount&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>+&nbsp;designation
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;+&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;...
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;*&nbsp;(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;...
  }
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>amount</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of a currency is the number of currency units it represents. This is a field of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Long</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>so that very large amounts of money such as the market capitalization of Google or Microsoft can be represented. It's left abstract here, waiting to be defined when a subclass talks about concrete amounts of money. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>designation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of a currency is a string that identifies it. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>indicates an amount and a designation. It would yield results such as:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  79&nbsp;USD
  11000&nbsp;Yen
  99&nbsp;Euro&nbsp;
</PRE>Finally, there are methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>, for adding currencies, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN>, for multiplying a currency with a floating-point number. You can create a concrete currency value by supplying concrete<SPAN class=code>amount</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>designation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>values, like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;amount&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">79L</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;designation&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"USD"</SPAN>
  }
</PRE>This design would be OK if all we wanted to model was a single currency such as only dollars or only euros. But it fails once we need to deal with several currencies. Assume you model dollars and euros as two subclasses of class currency:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;designation&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"USD"</SPAN>
  }
  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Euro</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;designation&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Euro"</SPAN>
  }
</PRE>At first glance this looks reasonable. But it would let you add dollars to euros. The result of such an addition would be of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN>. But it would be a funny currency that was made up of a mix of euros and dollars. What you want instead is a more specialized version of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method: when implemented in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN>, it should take<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments and yield a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>result; when implemented in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Euro</SPAN>, it should take<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Euro</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments and yield a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Euro</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>result. So the type of the addition method would change depending on which class you are in. Nonetheless, you would like to write the addition method just once, not each time a new currency is defined. 
<P></P>
<P>In Scala, there's a simple technique to deal with situations like this: if something is not known at the point where a class is defined, make it abstract in the class. This applies to both values and types. In the case of currencies, the exact argument and result type of the addition method are not known, so it is a good candidate for an abstract type. This would lead to the following sketch of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AbstractCurrency</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;A&nbsp;second&nbsp;(still&nbsp;imperfect)&nbsp;design&nbsp;of&nbsp;the&nbsp;Currency&nbsp;class</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;&lt;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;amount:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;designation:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;amount&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>+&nbsp;designation
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;+&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;...
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;*&nbsp;(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;...
  }
</PRE>The only differences from the previous situation are that the class is now called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AbstractCurrency</SPAN>, and that it contains an abstract type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN>, which represents the real currency in question. Each concrete subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AbstractCurrency</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would need to fix the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type to refer to the concrete subclass itself, thereby "tying the knot." 
<P></P>
<P>For instance, here is a new version of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN>, which now extends class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AbstractCurrency</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;designation&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"USD"</SPAN>
  }
</PRE>This design is workable, but it is still not perfect. One problem is hidden by the ellipses that indicate the missing method definitions of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AbstractCurrency</SPAN>. In particular, how should addition be implemented in this class? It's easy enough to calculate the correct amount of the new currency as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this.amount</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>that.amount</SPAN>, but how would you convert the amount into a currency of the right type? You might try something like:<A id=i-1457961297-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;+&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;amount&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.amount&nbsp;+&nbsp;that.amount
  }
</PRE>However, this would not compile:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">error:&nbsp;class&nbsp;type&nbsp;required</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;def&nbsp;+&nbsp;(that:&nbsp;Currency):&nbsp;Currency&nbsp;=&nbsp;new&nbsp;Currency&nbsp;{</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>One of the restrictions of Scala's treatment of abstract types is that you can neither create an instance of an abstract type, nor have an abstract type as a supertype of another class.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#footnote20-1">[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>So the compiler would refuse the example code above that attempted to instantiate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN>.</P>
<P>However, you can work around this restriction using a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">factory method</SPAN>. Instead of creating an instance of an abstract type directly, declare an abstract method that does it. Then, wherever the abstract type is fixed to be some concrete type, you also need to give a concrete implementation of the factory method.<A id=i-1125093732-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AbstractCurrency</SPAN>, this would look as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;&lt;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;abstract&nbsp;type</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;make(amount:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;factory&nbsp;method</SPAN>
  &nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;rest&nbsp;of&nbsp;class</SPAN>
  }
</PRE>A design like this could be made to work, but it looks rather suspicious. Why place the factory method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">inside</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AbstractCurrency</SPAN>? This looks dubious, for at least two reasons. First, if you have some amount of currency (say, one dollar), you also hold in your hand the ability to make more of the same currency, using code such as:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  myDollar.make(<SPAN class=literal style="COLOR: rgb(205,123,0)">100</SPAN>)&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;here&nbsp;are&nbsp;a&nbsp;hundred&nbsp;more!</SPAN>
</PRE>In the age of color copying this might be a tempting scenario, but hopefully not one which you would be able to do for very long without being caught. The second problem with this code is that you can make more<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>objects if you already have a reference to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object, but how do you get the first object of a given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN>? You'd need another creation method, which does essentially the same job as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>make</SPAN>. So you have a case of code duplication, which is a sure sign of a code smell. 
<P></P>
<P>The solution, of course, is to move the abstract type and the factory method outside class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AbstractCurrency</SPAN>. You need to create another class that contains the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AbstractCurrency</SPAN>class, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type, and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>make</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>factory method. We'll call this a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyZone</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyZone</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;&lt;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;make(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;amount:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;designation:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;amount&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>+&nbsp;designation
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;+&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.amount&nbsp;+&nbsp;that.amount)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;*&nbsp;(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make((<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.amount&nbsp;*&nbsp;x).toLong)
  &nbsp;&nbsp;}
  }
</PRE>An example of a concrete<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyZone</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the US. You could define this as follows:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;US&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyZone</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;designation&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"USD"</SPAN>
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;make(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN>)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;amount&nbsp;=&nbsp;x&nbsp;}
  }
</PRE>Here,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>US</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an object that extends<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyZone</SPAN>. It defines a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN>, which is a subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AbstractCurrency</SPAN>. So the type of money in this zone is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>US.Dollar</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>US</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object also fixes the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be an alias for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN>, and it gives an implementation of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>make</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>factory method to return a dollar amount. 
<P></P>
<P>This is a workable design. There are only a few refinements to be added. The first refinement concerns subunits. So far, every currency was measured in a single unit: dollars, euros, or yen. However, most currencies have subunits: for instance, in the US, it's dollars and cents. The most straightforward way to model cents is to have the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>amount</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field in<SPAN class=code>US.Currency</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>represent cents instead of dollars. To convert back to dollars, it's useful to introduce a field<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyUnit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyZone</SPAN>, which contains the amount of one standard unit in that currency:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyZone</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;...&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyUnit</SPAN>:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;
  }&nbsp;
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>US</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object could define the quantities<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cent</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyUnit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:us-currency-zone">Listing 20.11</A>.<A name=lst:us-currency-zone></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;US&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyZone</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;designation&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"USD"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;make(cents:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN>)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;amount&nbsp;=&nbsp;cents
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cent</SPAN>&nbsp;=&nbsp;make(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>&nbsp;=&nbsp;make(<SPAN class=literal style="COLOR: rgb(205,123,0)">100</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyUnit</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 20.11 - The US currency zone.</H5>
<P>This definition is just like the previous definition of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>US</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object, except that it adds three new fields. The field<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cent</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>represents an amount of 1<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>US.Currency</SPAN>. It's an object analogous to a one-cent coin. The field<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>represents an amount of 100<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>US.Currency</SPAN>. So the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>US</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object now defines the name<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in two ways. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">type</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(defined by the abstract inner class named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN>) represents the generic name of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>valid in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>US</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>currency zone. By contrast, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(referenced from the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field named<SPAN class=code>Dollar</SPAN>) represents a single US dollar, analogous to a one-dollar bill. The third field definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyUnit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>specifies that the standard currency unit in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>US</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>zone is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN>(<I>i.e.</I>, the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN>, referenced from the field, not the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN>).</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>also needs to be adapted to take subunits into account. For instance, the sum of ten dollars and twenty three cents should print as a decimal number: 10.23 USD. To achieve this, you could implement<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;
  &nbsp;&nbsp;((amount.toDouble&nbsp;/&nbsp;CurrencyUnit.amount.toDouble)
  &nbsp;&nbsp;&nbsp;formatted&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"%."</SPAN>+&nbsp;decimals(CurrencyUnit.amount)&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"f"</SPAN>)
  &nbsp;&nbsp;&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>+&nbsp;designation)
</PRE>Here,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formatted</SPAN><A id=i-1143614518-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a method that Scala makes available on several classes, including<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#footnote20-2">[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formatted</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method returns<A id=i1886523229-1></A><A id=i1659928775-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>the string that results from formatting the original string on which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formatted</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was invoked according to a format string passed as the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formatted</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method's right-hand operand. The syntax of format strings passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formatted</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the same as that of Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String.format</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. For instance, the format string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>%.2f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>formats a number with two decimal digits. The format string used in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown previously is assembled by calling the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>decimals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyUnit.amount</SPAN>. This method returns the number of decimal digits of a decimal power minus one. For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>decimals(10)</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>decimals(100)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>, and so on. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>decimals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is implemented by a simple recursion:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;decimals(n:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(n&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;+&nbsp;decimals(n&nbsp;/&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
</PRE><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:europe-japan">Listing 20.12</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows some other currency zones:<A name=lst:europe-japan></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Europe</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyZone</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Euro</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;designation&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"EUR"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Euro</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;make(cents:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN>)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Euro</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;amount&nbsp;=&nbsp;cents
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cent</SPAN>&nbsp;=&nbsp;make(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Euro</SPAN>&nbsp;=&nbsp;make(<SPAN class=literal style="COLOR: rgb(205,123,0)">100</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyUnit</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Euro</SPAN>
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Japan</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyZone</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Yen</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;designation&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"JPY"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Yen</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;make(yen:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN>)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Yen</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;amount&nbsp;=&nbsp;yen
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Yen</SPAN>&nbsp;=&nbsp;make(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyUnit</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Yen</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 20.12 - Currency zones for Europe and Japan.</H5>
<P>As another refinement you can add a currency conversion feature to the model. As a first step, you could write a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Converter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object that contains applicable exchange rates between currencies, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:currency-converter">Listing 20.13</A>.<A name=lst:currency-converter></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Converter</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;exchangeRate&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"USD"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"USD"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.0</SPAN>&nbsp;&nbsp;&nbsp;,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"EUR"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0.7596</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"JPY"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.211</SPAN>&nbsp;,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"CHF"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.223</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"EUR"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"USD"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.316</SPAN>&nbsp;,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"EUR"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.0</SPAN>&nbsp;&nbsp;&nbsp;,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"JPY"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.594</SPAN>&nbsp;,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"CHF"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.623</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"JPY"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"USD"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0.8257</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"EUR"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0.6272</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"JPY"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.0</SPAN>&nbsp;&nbsp;&nbsp;,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"CHF"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.018</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"CHF"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"USD"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0.8108</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"EUR"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0.6160</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"JPY"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0.982</SPAN>&nbsp;,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"CHF"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1.0</SPAN>&nbsp;&nbsp;)
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 20.13 - A converter object with an exchange rates map.</H5>
<P>Then, you could add a conversion method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>from</SPAN>, to class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN>, which converts from a given source currency into the current<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Currency</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;from(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyZone</SPAN>#<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;make(Math.round(
  &nbsp;&nbsp;&nbsp;&nbsp;other.amount.toDouble&nbsp;*&nbsp;Converter.exchangeRate
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(other.designation)(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.designation)))
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>from</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method takes an arbitrary currency as argument. This is expressed by its formal parameter type,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyZone#AbstractCurrency</SPAN>, which indicates that the argument passed as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>other</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>must be an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AbstractCurrency</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type in some arbitrary and unknown<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyZone</SPAN>. It produces its result by multiplying the amount of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>other</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>currency with the exchange rate between the other and the current currency.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#footnote20-3">[3]</A> 
<P></P>
<P>The final version of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyZone</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#lst:CurrencyZone">Listing 20.14</A>.</P>
<P><A name=lst:CurrencyZone></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyZone</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;&lt;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;make(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;amount:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;designation:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;+&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.amount&nbsp;+&nbsp;that.amount)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;*&nbsp;(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make((<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.amount&nbsp;*&nbsp;x).toLong)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;-&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.amount&nbsp;-&nbsp;that.amount)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;/&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make((<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.amount&nbsp;/&nbsp;that).toLong)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;/&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.amount.toDouble&nbsp;/&nbsp;that.amount
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;from(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyZone</SPAN>#<SPAN class=typename style="COLOR: rgb(103,0,154)">AbstractCurrency</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make(Math.round(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other.amount.toDouble&nbsp;*&nbsp;Converter.exchangeRate
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(other.designation)(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.designation)))
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;decimals(n:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Long</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(n&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;+&nbsp;decimals(n&nbsp;/&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((amount.toDouble&nbsp;/&nbsp;CurrencyUnit.amount.toDouble)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatted&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"%."</SPAN>+&nbsp;decimals(CurrencyUnit.amount)&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"f"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>+&nbsp;designation)
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CurrencyUnit</SPAN>:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Currency</SPAN>
  }
</PRE>
<H5>Listing 20.14 - The full code of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyZone</SPAN>.</H5>
<P>You can test the class in the Scala command shell. We'll assume that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyZone</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class and all concrete<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyZone</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>objects are defined in a package<SPAN class=code>org.stairwaybook.currencies</SPAN>. The first step is to import everything in this package into the command shell:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;org.stairwaybook.currencies._
</PRE>You can then do some currency conversions:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Japan.Yen</SPAN>&nbsp;from&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">US.Dollar</SPAN>&nbsp;*&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">100</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res16:&nbsp;Japan.Currency&nbsp;=&nbsp;12110&nbsp;JPY</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Europe.Euro</SPAN>&nbsp;from&nbsp;res16
  <SPAN class=output style="COLOR: rgb(90,0,0)">res17:&nbsp;Europe.Currency&nbsp;=&nbsp;75.95&nbsp;EUR</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">US.Dollar</SPAN>&nbsp;from&nbsp;res17
  <SPAN class=output style="COLOR: rgb(90,0,0)">res18:&nbsp;US.Currency&nbsp;=&nbsp;99.95&nbsp;USD</SPAN>
</PRE>The fact that we obtain almost the same amount after three conversions implies that these are some pretty good exchange rates! 
<P></P>
<P>You can also add up values of the same currency:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">US.Dollar</SPAN>&nbsp;*&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">100</SPAN>&nbsp;+&nbsp;res18
  <SPAN class=output style="COLOR: rgb(90,0,0)">res19:&nbsp;currencies.US.Currency&nbsp;=&nbsp;199.95</SPAN>
</PRE>On the other hand, you cannot add amounts of different currencies:<A id=i-677980410-6></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">US.Dollar</SPAN>&nbsp;+&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Europe.Euro</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:7:&nbsp;error:&nbsp;type&nbsp;mismatch;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;currencies.Europe.Euro</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;required:&nbsp;currencies.US.Currency</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;US.Dollar&nbsp;+&nbsp;Europe.Euro</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>By preventing the addition of two values with different units (in this case, currencies), the type abstraction has done its job. It prevents us from performing calculations that are unsound. Failures to convert correctly between different units may seem like trivial bugs, but they have caused many serious systems faults. An example is the crash of the Mars Climate Orbiter spacecraft on September 23, 1999, which was caused because one engineering team used metric units while another used English units. If units had been coded in the same way as currencies are coded in this chapter, this error would have been detected by a simple compilation run. Instead, it caused the crash of the orbiter after a near ten-month voyage.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=20.10></A>20.10 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#20.10">link</A>]</SPAN></H3>
<P>Scala offers systematic and very general support for object-oriented abstraction. It enables you to not only abstract over methods, but also over values, variables, and types. This chapter has shown how to take advantage of abstract members. They support a simple yet effective principle for systems structuring: when designing a class, make everything that is not yet known into an abstract member. The type system will then drive the development of your model, just as you saw with the currency case study. It does not matter whether the unknown is a type, method, variable or value. In Scala, all of these can be declared abstract.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 20:</H4>
<P><A name=footnote20-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>There's some promising recent research on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">virtual classes</SPAN>, which would allow this, but virtual classes are not currently supported in Scala.</P>
<P><A name=footnote20-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Scala uses rich wrappers, described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#sec:rich-wrappers">Section 5.9</A>, to make<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formatted</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>available.</P>
<P><A name=footnote20-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>By the way, in case you think you're getting a bad deal on Japanese yen, the exchange rates convert currencies based on their<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CurrencyZone</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>amounts. Thus, 1.211 is the exchange rate between US cents to Japanese yen.</P></DIV>