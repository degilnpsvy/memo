<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 21 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Implicit Conversions and Parameters</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>There's a fundamental difference between your own code and libraries<SPAN class=Apple-converted-space>&nbsp;</SPAN>of other people: you can change or extend your own code as you wish, but if you want to use someone else's libraries, you usually have to take them as they are.</P>
<P>A number of constructs have sprung up in programming languages to alleviate this problem. Ruby<A id=i-1999895874-4></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>has modules, and Smalltalk<A id=i-817657147-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>lets packages add to each other's classes. These are very powerful, but also dangerous, in that you modify the behavior of a class for an entire application, some parts of which you might not know. C# 3.0 has static extension methods<A id=i1246302635-1></A>, which are more local, but also more restrictive in that you can only add methods, not fields, to a class, and you can't make a class implement new interfaces.</P>
<P>Scala's answer is implicit conversions and parameters.<A id=i-174456078-1></A><A id=i-1068906551-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>These can make existing libraries much more pleasant to deal with by letting you leave out tedious, obvious details that obscure the interesting parts of your code. Used tastefully, this results in code that is focused on the interesting, non-trivial parts of your program. This chapter shows you how implicits work, and presents some of the most common ways they are used.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=21.1></A>21.1 Implicit conversions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#21.1">link</A>]</SPAN></H3>
<P>Before delving into the details of implicit conversions, take a look at a typical example of their use. One of the central collection traits in Scala is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq[T]</SPAN>, which describes random access sequences over elements of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN>s have most of the utility methods that you know from arrays or lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>take</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drop</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>,<SPAN class=code>exists</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mkString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are just some examples. To make a new random access sequence, all you must do is extend trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN>. You only need to define two methods that are abstract in the trait:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>length</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN>. You then get implementations of all the other useful methods in the trait "for free."</P>
<P>So far so good. This works fine if you are about to define new classes, but what about existing ones? Maybe you'd like to also treat classes in other people's libraries as random access sequences, even if the designers of those libraries had not thought of making their classes extend<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN>. For instance, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java would make a fine<SPAN class=code>RandomAccessSeq[Char]</SPAN>, except that unfortunately Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class does not inherit from Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait.</P>
<P>In situations like this, implicits can help. To make a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>appear to be a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN>, you can define an implicit conversion from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to an adapter class that actually is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;stringWrapper(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RandomAccessSeq[Char]</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;length&nbsp;=&nbsp;s.length
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(i:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&nbsp;s.charAt(i)
  &nbsp;&nbsp;}
</PRE>That's it.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#footnote21-1">[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The implicit conversion is just a normal method. The only thing that's special is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>implicit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier at the start<A id=i-425423387-2></A>. You can apply the conversion explicitly to transform<SPAN class=code>String</SPAN>s to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN>s:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;stringWrapper(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc123"</SPAN>)&nbsp;exists&nbsp;(_.isDigit)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>But you can also leave out the conversion and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">still</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>get the same behavior:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc123"</SPAN>&nbsp;exists&nbsp;(_.isDigit)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>What goes on here under the covers is that the Scala compiler inserts the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stringWrapper</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>conversion for you. So in effect it rewrites the last expression above to the one before. But on the surface, it's as if Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>s had acquired all the useful methods of trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN>. 
<P></P>
<P>This aspect of implicits is similar to extension methods in C#, which also allow you to add new methods to existing classes. However, implicits can be far more concise than extension methods. For instance, we only needed to define the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>length</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stringWrapper</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>conversion, and we got all other methods in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for free. With extension methods you'd need to define every one of these methods again. This duplication makes code harder to write, and, more importantly, harder to maintain. Imagine someone adds a new method to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>sometime in the future. If all you have is extension methods, you'd have to chase down all<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN>"copycats" one by one, and add the new method in each. If you forget one of the copycats, your system would become inconsistent. Talk about a maintenance nightmare! By contrast, with Scala's implicits, all conversions would pick up the newly added method automatically.</P>
<P>Another advantage of implicit conversions is that they support conversions into the target type, a type that's<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">needed</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>at some point in the code.<A id=i-1383613518-1></A><A id=i-1726424555-1></A><A id=i746333869-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For instance, suppose you write a method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printWithSpaces</SPAN>, which prints all characters in a given random access sequence with spaces in between them:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;printWithSpaces(seq:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RandomAccessSeq[Char]</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;seq&nbsp;mkString&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>
</PRE>Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>s are implicitly convertible to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN>s, you can pass a string to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printWithSpaces</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;printWithSpaces(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"xyz"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;String&nbsp;=&nbsp;x&nbsp;y&nbsp;z</SPAN>
</PRE>The last expression is equivalent to the following one, where the conversion shows up explicitly:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;printWithSpaces(stringWrapper(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"xyz"</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;String&nbsp;=&nbsp;x&nbsp;y&nbsp;z</SPAN>
</PRE>
<P></P>
<P>This section has shown you some of the power of implicit conversions, and how they let you "dress up" existing libraries. In the next sections you'll learn the rules that determine when implicit conversions are tried and how they are found.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=21.2></A>21.2 Rules for implicits<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#21.2">link</A>]</SPAN></H3>
<P><A name=sec:rules-for-implicits></A></P>
<P>Implicit definitions are those that the compiler is allowed to insert into a program in order to fix any of its type errors. For example, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not type check, then the compiler might change it to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert(x)</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN>, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is some available implicit conversion. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>changes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into something that has a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, then this change might fix a program so that it type checks and runs correctly. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>really is just a simple conversion function, then leaving it out of the source code can be a clarification.</P>
<P>Implicit conversions are governed by the following general rules:</P>
<P><B>Marking Rule: Only definitions marked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>implicit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are available.</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>implicit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword is used to mark which declarations the compiler may use as implicits. You can use it to mark any variable, function, or object definition. Here's an example of an implicit function definition:<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#footnote21-2">[2]</A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;intToString(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&nbsp;x.toString
</PRE>The compiler will only change<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert(x)</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is marked as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>implicit</SPAN>. This way, you avoid the confusion that would result if the compiler picked random functions that happen to be in scope and inserted them as "conversions." The compiler will only select among the definitions you have explicitly marked as implicit. 
<P></P>
<P><B>Scope Rule: An inserted implicit conversion must be in scope as a single identifier, or be associated with the source or target type of the conversion.</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>The Scala compiler will only consider implicit conversions that are in scope.<A id=i1011304421-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>To make an implicit conversion available, therefore, you must in some way bring it into scope. Moreover, with one exception, the implicit conversion must be in scope<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">as a single identifier</EM>. The compiler will not insert a conversion of the form<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someVariable.convert</SPAN>. For example, it will not expand<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someVariable.convert(x)</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN>. If you want to make<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someVariable.convert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>available as an implicit, therefore, you would need to import it, which would make it available as a single identifier. Once imported, the compiler would be free to apply it as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert(x)</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN>. In fact, it is common for libraries to include a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Preamble</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object including a number of useful implicit conversions. Code that uses the library can then do a single "<SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>Preamble._</SPAN>" to access the library's implicit conversions.</P>
<P>There's one exception to the "single identifier" rule. The compiler will also look for implicit definitions in the companion object of the source or expected target types of the conversion<A id=i1755659460-1></A>. For example, if you're attempting to pass a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object to a method that takes a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Euro</SPAN>, the source type is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the target type is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Euro</SPAN>. You could, therefore, package an implicit conversion from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Euro</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the companion object of either class,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Euro</SPAN>. Here's an example in which the implicit definition is placed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN>'s companion object:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;dollarToEuro(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Euro</SPAN>&nbsp;=&nbsp;...
  }
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Dollar</SPAN>&nbsp;{&nbsp;...&nbsp;}
</PRE>In this case, the conversion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>dollarToEuro</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is said to be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">associated</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN>. The compiler will find such an associated conversion every time it needs to convert from an instance of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Dollar</SPAN>. There's no need to import the conversion separately into your program. 
<P></P>
<P>The Scope Rule helps with modular reasoning. When you read code in a file, the only things you need to consider from other files are those that are either imported or are explicitly referenced through a fully qualified name. This benefit is at least as important for implicits as for explicitly written code. If implicits took effect system-wide, then to understand a file you would have to know about every implicit introduced anywhere in the program!</P>
<P><B>Non-Ambiguity Rule: An implicit conversion is only inserted if there is no other possible conversion to insert.</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>If the compiler has two options to fix<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN>, say using either<SPAN class=code>convert1(x)</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert2(x)</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN>, then it will report an error and refuse to choose between them. It would be possible to define some kind of "best match" rule that prefers some conversions over others. However, such choices lead to really obscure code. Imagine the compiler chooses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert2</SPAN>, but you are new to the file and are only aware of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert1</SPAN>&#8212;you could spend a lot of time thinking a different conversion had been applied!</P>
<P>In cases like this, one option is to remove one of the imported implicits so that the ambiguity is removed. If you prefer<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert2</SPAN>, then remove the import of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert1</SPAN>. Alternatively, you can write your desired conversion explicitly:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert2(x)</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN>.</P>
<P><B>One-at-a-time Rule: Only one implicit is tried.</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>The compiler will never rewrite<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>convert1(convert2(x))</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN>. Doing so would cause compile times to increase dramatically on erroneous code, and it would increase the difference between what the programmer writes and what the program actually does. For sanity's sake, the compiler does not insert further implicit conversions when it is already in the middle of trying another implicit. However, it's possible to circumvent this restriction by having implicits take implicit parameters, which will be described later in this chapter<A id=i-568821387-2></A>.</P>
<P><B>Explicits-First Rule: Whenever code type checks as it is written, no implicits are attempted.</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>The compiler will not change code that already works. A corollary of this rule is that you can always replace implicit identifiers by explicit ones, thus making the code longer but with less apparent ambiguity. You can trade between these choices on a case-by-case basis. Whenever you see code that seems repetitive and verbose, implicit conversions can help you decrease the tedium. Whenever code seems terse to the point of obscurity, you can insert conversions explicitly. The amount of implicits you leave the compiler to insert is ultimately a matter of style.<BR></P>
<P><B>Naming an implicit conversion.</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>Implicit conversions can have arbitrary names. The name of an implicit conversion matters only in two situations: if you want to write it explicitly in a method application, and for determining which implicit conversions are available at any place in the program.</P>
<P>To illustrate the second point, say you have an object with two implicit conversions:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">MyConversions</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;stringWrapper(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RandomAccessSeq[Char]</SPAN>&nbsp;=&nbsp;...
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;intToString(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=&nbsp;...
  }
</PRE>In your application, you want to make use of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stringWrapper</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>conversion, but you don't want integers to be converted automatically to strings by means of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>intToString</SPAN>conversion. You can achieve this by importing only one conversion, but not the other:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;MyConversions.stringWrapper
  ...&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;code&nbsp;making&nbsp;use&nbsp;of&nbsp;stringWrapper</SPAN>
</PRE>In this example, it was important that the implicit conversions had names, because only that way could you selectively import one and not the other. 
<P></P>
<P><B>Where implicits are tried.</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>There are three places implicits are used in the language: conversions to an expected type, conversions of the receiver of a selection, and implicit parameters. Implicit conversions to an expected type let you use one type in a context where a different type is expected. For example, you might have a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and want to pass it to a method that requires a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq[Char]</SPAN>. Conversions of the receiver let you adapt the receiver of a method call,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, the object on which a method is invoked, if the method is not applicable on the original type. An example is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"abc".exists</SPAN>, which is converted to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stringWrapper("abc").exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>because the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is not available on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>s but is available on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN>s. Implicit parameters, on the other hand, are usually used to provide more information to the called function about what the caller wants. Implicit parameters are especially useful with generic functions, where the called function might otherwise know nothing at all about the type of one or more arguments. Each of the following three sections will discuss one of these three kinds of implicits.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=21.3></A>21.3 Implicit conversion to an expected type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#21.3">link</A>]</SPAN></H3>
<P>Implicit conversion to an expected type is the first place the compiler will use implicits. The rule is simple. Whenever the compiler sees an X, but needs a Y, it will look for an implicit function that converts X to Y. For example, normally a double cannot be used as an integer, because it loses precision:<A id=i-677980410-7></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;i:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3.5</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:5:&nbsp;error:&nbsp;type&nbsp;mismatch;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Double(3.5)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;required:&nbsp;Int</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;i:&nbsp;Int&nbsp;=&nbsp;3.5</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>However, you can define an implicit conversion to smooth this over:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;doubleToInt(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>)&nbsp;=&nbsp;x.toInt
  <SPAN class=output style="COLOR: rgb(90,0,0)">doubleToInt:&nbsp;(Double)Int</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;i:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3.5</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">i:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
</PRE>What happens here is that the compiler sees a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>, specifically<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>3.5</SPAN>, in a context where it requires an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>. So far, the compiler is looking at an ordinary type error. Before giving up, though, it searches for an implicit conversion from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>. In this case, it finds one:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>doubleToInt</SPAN>, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>doubleToInt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in scope as a single identifier. (Outside the interpreter, you might bring<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>doubleToInt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into scope via an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>import</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or possibly through inheritance.) The compiler then inserts a call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>doubleToInt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>automatically. Behind the scenes, the code becomes:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;i:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;doubleToInt(<SPAN class=literal style="COLOR: rgb(205,123,0)">3.5</SPAN>)
</PRE>This is literally an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">implicit</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>conversion. You did not explicitly ask for conversion. Instead, you marked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>doubleToInt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an available implicit conversion by bringing it into scope as a single identifier, and then the compiler automatically used it when it needed to convert from a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>. 
<P></P>
<P>Converting<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>s to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>s might raise some eyebrows, because it's a dubious idea to have something that causes a loss in precision happen invisibly. So this is not really a conversion we recommend. It makes much more sense to go the other way, from some more constrained type to a more general one. For instance, an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be converted without loss of precision to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>, so an implicit conversion from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>makes sense. In fact, that's exactly what happens. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Predef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object, which is implicitly imported into every Scala program, defines implicit conversions that convert "smaller" numeric types to "larger" ones. For instance, you will find in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Predef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the following conversion:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;int2double(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>&nbsp;=&nbsp;x.toDouble
</PRE>That's why in Scala<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>values can be stored in variables of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>. There's no special rule in the type system for this; it's just an implicit conversion that gets applied.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#footnote21-3">[3]</A> 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=21.4></A>21.4 Converting the receiver<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#21.4">link</A>]</SPAN></H3>
<P>Implicit conversions also apply to the receiver of a method call, the object on which the method is invoked. This kind of implicit conversion has two main uses. First, receiver conversions allow smoother integration of a new class into an existing class hierarchy. And second, they support writing domain-specific languages (DSLs) within the language.<A id=i49254319-1></A></P>
<P>To see how it works, suppose you write down<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>obj.doIt</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>obj</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not have a member named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>doIt</SPAN>. The compiler will try to insert conversions before giving up. In this case, the conversion needs to apply to the receiver,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>obj</SPAN>. The compiler will act as if the expected "type" of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>obj</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>were "has a member named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>doIt</SPAN>." This "has a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>doIt</SPAN>" type is not a normal Scala type, but it is there conceptually and is why the compiler will insert an implicit conversion in this case.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Interoperating with new types</H4>
<P>As mentioned previously, one major use of receiver conversions is allowing smoother integration of new with existing types. In particular, they allow you to enable client programmers to use instances of existing types as if they were instances of your new type. Take, for example, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html#lst:overloaded-methods">Listing 6.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html#lst:overloaded-methods">here</A>. Here's a snippet of that class again:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>(n:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;d:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  &nbsp;&nbsp;...
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;+&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>&nbsp;=&nbsp;...
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;+&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>&nbsp;=&nbsp;...
  }
</PRE>
<P></P>
<P>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has two overloaded variants of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which take<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN>s and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>s, respectively, as arguments. So you can either add two rational numbers or a rational number and an integer:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;oneHalf&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">oneHalf:&nbsp;Rational&nbsp;=&nbsp;1/2</SPAN>
  <BR>  scala&gt;&nbsp;oneHalf&nbsp;+&nbsp;oneHalf
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;Rational&nbsp;=&nbsp;1/1</SPAN>
  <BR>  scala&gt;&nbsp;oneHalf&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res5:&nbsp;Rational&nbsp;=&nbsp;3/2</SPAN>
</PRE>What about an expression like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>oneHalf</SPAN>, however? This expression is tricky because the receiver,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>, does not have a suitable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. So the following gives an error:<A id=i1859455133-1></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;+&nbsp;oneHalf
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:6:&nbsp;error:&nbsp;overloaded&nbsp;method&nbsp;value&nbsp;+&nbsp;with</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">alternatives&nbsp;(Double)Double&nbsp;&lt;and&gt;&nbsp;...&nbsp;cannot&nbsp;be&nbsp;applied</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">to&nbsp;(Rational)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+&nbsp;oneHalf</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P>To allow this kind of mixed arithmetic, you need to define an implicit conversion from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;intToRational(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>(x,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">intToRational:&nbsp;(Int)Rational</SPAN>
</PRE>With the conversion in place, converting the receiver does the trick:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;+&nbsp;oneHalf
  <SPAN class=output style="COLOR: rgb(90,0,0)">res6:&nbsp;Rational&nbsp;=&nbsp;3/2</SPAN>
</PRE>What happens behind the scenes here is that Scala compiler first tries to type check the expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>oneHalf</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as it is. This fails because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has several<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods, but none that takes a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument. Next, the compiler searches for an implicit conversion from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to another type that has a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method which can be applied to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN>. It finds your conversion and applies it, which yields:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  intToRational(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)&nbsp;+&nbsp;oneHalf
</PRE>In this case, the compiler found the implicit conversion function because you entered its definition into the interpreter, which brought it into scope for the remainder of the interpreter session. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Simulating new syntax</H4>
<P>The other major use of implicit conversions is to simulate adding new syntax. Recall that you can make a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>using syntax like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"one"</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"two"</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"three"</SPAN>)
</PRE>Have you wondered how the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is supported?<A id=i-767942027-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It's not syntax! Instead,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a method of the class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrowAssoc</SPAN>, a class defined inside the standard Scala preamble (<SPAN class=code>scala.Predef</SPAN>). The preamble also defines an implicit conversion from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrowAssoc</SPAN>. When you write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>"one"</SPAN>, the compiler inserts a conversion from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrowAssoc</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>so that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-&gt;</SPAN>method can be found. Here are the relevant definitions:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;scala
  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Predef</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrowAssoc[A]</SPAN>(x:&nbsp;A)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;-&gt;&nbsp;[B](y:&nbsp;B):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tuple2[A, B]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tuple2</SPAN>(x,&nbsp;y)
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;any2ArrowAssoc[A](x:&nbsp;A):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrowAssoc[A]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrowAssoc</SPAN>(x)
  &nbsp;&nbsp;...
  }
</PRE>This "rich wrappers" pattern is common in libraries that provide syntax-like extensions to the language, so you should be ready to recognize the pattern when you see it.<A id=i807731316-2></A><A id=i681737575-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Whenever you see someone calling methods that appear not to exist in the receiver class, they are probably using implicits. Similarly, if you see a class named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RichSomething</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>e.g.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RichInt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=code>RichString</SPAN>, that class is likely adding syntax-like methods to type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Something</SPAN>. 
<P></P>
<P>You have already seen this rich wrappers pattern for the basic types described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html">Chapter 5</A>. As you can now see, these rich wrappers apply more widely, often letting you get by with an internal DSL defined as a library where programmers in other languages might feel the need to develop an external DSL.<A id=i367427817-1></A></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=21.5></A>21.5 Implicit parameters<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#21.5">link</A>]</SPAN></H3>
<P>The remaining place the compiler inserts implicits is within argument lists.<A id=i-568821387-3></A><A id=i-1127720187-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The compiler will sometimes replace<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someCall(a)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someCall(a)(b)</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN>&nbsp;<SPAN class=code>SomeClass(a)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=code>new</SPAN>&nbsp;<SPAN class=code>SomeClass(a)(b)</SPAN>, thereby adding a missing parameter list to complete a function call. It is the entire last curried parameter list that's supplied, not just the last parameter. For example, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someCall</SPAN>'s missing last parameter list takes three parameters, the compiler might replace<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someCall(a)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someCall(a)(b,</SPAN>&nbsp;<SPAN class=code>c,</SPAN>&nbsp;<SPAN class=code>d)</SPAN>. For this usage, not only must the inserted identifiers, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>c</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>d</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(b,</SPAN>&nbsp;<SPAN class=code>c,</SPAN>&nbsp;<SPAN class=code>d)</SPAN>, be marked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>implicit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>where they are defined, but also the last parameter list in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someCall</SPAN>'s or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someClass</SPAN>'s definition must be marked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>implicit</SPAN>.</P>
<P>Here's a simple example. Suppose you have a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PreferredPrompt</SPAN>, which encapsulates a shell prompt string (such as, say<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"$</SPAN>&nbsp;<SPAN class=code>"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"&gt;</SPAN>&nbsp;<SPAN class=code>"</SPAN>) that is preferred by a user:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PreferredPrompt</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;preference:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)
</PRE>Also, suppose you have a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Greeter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which takes two parameter lists. The first parameter list takes a string user name, and the second parameter list takes a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PreferredPrompt</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Greeter</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;greet(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)(<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;prompt:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PreferredPrompt</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Welcome,&nbsp;"</SPAN>+&nbsp;name&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">".&nbsp;The&nbsp;system&nbsp;is&nbsp;ready."</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;println(prompt.preference)
  &nbsp;&nbsp;}
  }
</PRE>The last parameter list is marked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>implicit</SPAN>, which means it can be supplied implicitly. But you can still provide the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>prompt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>explicitly, like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bobsPrompt&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PreferredPrompt</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"relax&gt;&nbsp;"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">bobsPrompt:&nbsp;PreferredPrompt&nbsp;=&nbsp;PreferredPrompt@ece6e1</SPAN>
  <BR>  scala&gt;&nbsp;Greeter.greet(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Bob"</SPAN>)(bobsPrompt)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">Welcome,&nbsp;Bob.&nbsp;The&nbsp;system&nbsp;is&nbsp;ready.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">relax&gt;&nbsp;</SPAN>
</PRE>
<P></P>
<P>To let the compiler supply the parameter implicitly, you must first define a variable of the expected type, which in this case is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PreferredPrompt</SPAN>. You could do this, for example, in a preferences object:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">JoesPrefs</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;prompt&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PreferredPrompt</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Yes,&nbsp;master&gt;&nbsp;"</SPAN>)
  }
</PRE>Note that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>itself is marked implicit. If it wasn't, the compiler would not use it to supply the missing parameter list. It will also not use it if it isn't in scope as a single identifier. For example:<A id=i-1437022486-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;Greeter.greet(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Joe"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:7:&nbsp;error:&nbsp;no&nbsp;implicit&nbsp;argument&nbsp;matching&nbsp;parameter</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;type&nbsp;PreferredPrompt&nbsp;was&nbsp;found.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greeter.greet("Joe")</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>Once you bring it into scope via an import, however, it will be used to supply the missing parameter list:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;JoesPrefs._&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;JoesPrefs._</SPAN>
  <BR>  scala&gt;&nbsp;Greeter.greet(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Joe"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">Welcome,&nbsp;Joe.&nbsp;The&nbsp;system&nbsp;is&nbsp;ready.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Yes,&nbsp;master&gt;&nbsp;</SPAN>
</PRE>
<P></P>
<P>Note that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>implicit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword applies to an entire parameter list, not to individual parameters.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:multiple-implicit-params">Listing 21.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an example in which the last parameter list of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Greeter</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greet</SPAN>method, which is again marked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>implicit</SPAN>, has two parameters:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>prompt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PreferredPrompt</SPAN>) and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drink</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PreferredDrink</SPAN>):</P>
<P><A name=lst:multiple-implicit-params></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PreferredPrompt</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;preference:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PreferredDrink</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;preference:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Greeter</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;greet(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)(<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;prompt:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PreferredPrompt</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drink:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PreferredDrink</SPAN>)&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Welcome,&nbsp;"</SPAN>+&nbsp;name&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">".&nbsp;The&nbsp;system&nbsp;is&nbsp;ready."</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;print(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"But&nbsp;while&nbsp;you&nbsp;work,&nbsp;"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"why&nbsp;not&nbsp;enjoy&nbsp;a&nbsp;cup&nbsp;of&nbsp;"</SPAN>+&nbsp;drink.preference&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"?"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;println(prompt.preference)
  &nbsp;&nbsp;}
  }
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">JoesPrefs</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;prompt&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PreferredPrompt</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Yes,&nbsp;master&gt;&nbsp;"</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;drink&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PreferredDrink</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"tea"</SPAN>)
  }
</PRE>
<H5>Listing 21.1 - An implicit parameter list with multiple parameters.</H5>
<P>Singleton object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>JoesPrefs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:multiple-implicit-params">Listing 21.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>declares two implicit<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>prompt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PreferredPrompt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drink</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PreferredDrink</SPAN>. As before, however, so long as these are not in scope as single identifiers, they won't be used to fill in a missing parameter list to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>greet</SPAN>:<A id=i-1437022486-2></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;Greeter.greet(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Joe"</SPAN>)&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:8:&nbsp;error:&nbsp;no&nbsp;implicit&nbsp;argument&nbsp;matching&nbsp;parameter</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;type&nbsp;PreferredPrompt&nbsp;was&nbsp;found.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greeter.greet("Joe")</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>You can bring both implicit<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s into scope with an import:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;JoesPrefs._
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;JoesPrefs._</SPAN>
</PRE>Because both<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>prompt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drink</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are now in scope as single identifiers, you can use them to supply the last parameter list explicitly, like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;Greeter.greet(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Joe"</SPAN>)(prompt,&nbsp;drink)
  <SPAN class=output style="COLOR: rgb(90,0,0)">Welcome,&nbsp;Joe.&nbsp;The&nbsp;system&nbsp;is&nbsp;ready.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">But&nbsp;while&nbsp;you&nbsp;work,&nbsp;why&nbsp;not&nbsp;enjoy&nbsp;a&nbsp;cup&nbsp;of&nbsp;tea?</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Yes,&nbsp;master&gt;&nbsp;</SPAN>
</PRE>And because all the rules for implicit parameters are now met, you can alternatively let the Scala compiler supply<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>prompt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drink</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for you by leaving off the last parameter list:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;Greeter.greet(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Joe"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">Welcome,&nbsp;Joe.&nbsp;The&nbsp;system&nbsp;is&nbsp;ready.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">But&nbsp;while&nbsp;you&nbsp;work,&nbsp;why&nbsp;not&nbsp;enjoy&nbsp;a&nbsp;cup&nbsp;of&nbsp;tea?</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Yes,&nbsp;master&gt;&nbsp;</SPAN>
</PRE>
<P></P>
<P>One thing to note about the previous examples is that we didn't use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>prompt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drink</SPAN>, even though ultimately it was a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that each of them provided through their<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>preference</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fields. Because the compiler selects implicit parameters by matching types of parameters against types of values in scope, implicit parameters usually have "rare" or "special" enough types that accidental matches are unlikely. For example, the types<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PreferredPrompt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PreferredDrink</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:multiple-implicit-params">Listing 21.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>were defined solely to serve as implicit parameter types. As a result, it is unlikely that implicit variables of these types will be in scope if they aren't intended to be used as implicit parameters to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Greeter.greet</SPAN>.</P>
<P>Another thing to know about implicit parameters is that they are perhaps most often used to provide information about a type mentioned<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">explicitly</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>in an earlier parameter list, similar to the type classes of Haskell. As an example, consider the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxListUpBound</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:max-list-take-one">Listing 21.2</A>, which returns the maximum element of the passed list:</P>
<P><A name=lst:max-list-take-one></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;maxListUpBound[T&nbsp;&lt;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ordered[T]</SPAN>](elements:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>):&nbsp;T&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">IllegalArgumentException</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"empty&nbsp;list!"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;maxRest&nbsp;=&nbsp;maxListUpBound(rest)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;&gt;&nbsp;maxRest)&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;maxRest
  &nbsp;&nbsp;&nbsp;&nbsp;}
</PRE>
<H5>Listing 21.2 - A function with an upper bound.</H5>
<P>The signature of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxListUpBound</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is similar to that of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderedMergeSort</SPAN>, shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:upper-bound-sort">Listing 19.12</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:upper-bound-sort">here</A>: it takes a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as its argument, and specifies via an upper bound that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>must be a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered[T]</SPAN>. As mentioned at the end of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#sec:upper-bounds">Section 19.8</A>, one weakness with this approach is that you can't use the function with lists whose element type isn't already a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN>. For example, you couldn't use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxListUpBound</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function to find the maximum of a list of integers, because class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not a subtype of<SPAN class=code>Ordered[Int]</SPAN>.</P>
<P>Another, more general way to organize<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxListUpBound</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be to require a separate, second argument, in addition to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument: a function that converts a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to an<SPAN class=code>Ordered[T]</SPAN>. This approach is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:max-list-take-two">Listing 21.3</A>. In this example, the second argument,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderer</SPAN>, is placed in a separate argument list and marked implicit.</P>
<P><A name=lst:max-list-take-two></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;maxListImpParm[T](elements:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;orderer:&nbsp;T&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ordered[T]</SPAN>):&nbsp;T&nbsp;=
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">IllegalArgumentException</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"empty&nbsp;list!"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;maxRest&nbsp;=&nbsp;maxListImpParm(rest)(orderer)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(orderer(x)&nbsp;&gt;&nbsp;maxRest)&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;maxRest
  &nbsp;&nbsp;&nbsp;&nbsp;}
</PRE>
<H5>Listing 21.3 - A function with an implicit parameter.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter in this example is used to describe the ordering of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>s. In the body of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxListImpParm</SPAN>, this ordering is used in two places: a recursive call to<SPAN class=code>maxListImpParm</SPAN>, and an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression that checks whether the head of the list is larger than the maximum element of the rest of the list.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxListImpParm</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function, shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:max-list-take-two">Listing 21.3</A>, is an example of an implicit parameter used to provide more information about a type mentioned explicitly in an earlier parameter list. To be specific, the implicit parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderer</SPAN>, of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Ordered[T]</SPAN>, provides more information about type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>&#8212;in this case, how to order<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>s. Type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]</SPAN>, the type of parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elements</SPAN>, which appears in the earlier parameter list. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elements</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>must always be provided explicitly in any invocation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxListImpParm</SPAN>, the compiler will know<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>at compile time, and can therefore determine whether an implicit definition of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Ordered[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in scope. If so, it can pass in the second parameter list,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderer</SPAN>, implicitly.</P>
<P>This pattern is so common that the standard Scala library provides implicit "orderer" methods for many common types. You could therefore use this<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxListImpParm</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method with a variety of types:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;maxListImpParm(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>,<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res10:&nbsp;Int&nbsp;=&nbsp;10</SPAN>
  <BR>  scala&gt;&nbsp;maxListImpParm(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1.5</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5.2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">10.7</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3.14159</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res11:&nbsp;Double&nbsp;=&nbsp;10.7</SPAN>
  <BR>  scala&gt;&nbsp;maxListImpParm(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"one"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"two"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"three"</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res12:&nbsp;java.lang.String&nbsp;=&nbsp;two</SPAN>
</PRE>In the first case, the compiler inserted an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>s; in the second case, for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>s; in the third case, for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>s. 
<P></P>
<P><B>A style rule for implicit parameters</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>As a style rule, it is best to use a custom named type in the types of implicit parameters. For example, the types of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>prompt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drink</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the previous example was not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>, but<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PreferredPrompt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PreferredDrink</SPAN>, respectively. As a counterexample, consider that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxListImpParm</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function could just as well have been written with the following type signature:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;maxListPoorStyle[T](elments:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;orderer:&nbsp;(T,&nbsp;T)&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>):&nbsp;T
</PRE>To use this version of the function, though, the caller would have to supply an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(T,</SPAN>&nbsp;<SPAN class=code>T)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Boolean</SPAN>. This is a fairly generic type that includes any function from two<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>s to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN>. It does not indicate anything at all about what the type is for; it could be an equality test, a less-than test, a greater-than test, or something else entirely. 
<P></P>
<P>The actual code for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxListImpParm</SPAN>, given in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:max-list-take-two">Listing 21.3</A>, shows better style.<SPAN class=Apple-converted-space>&nbsp;</SPAN>It uses an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Ordered[T]</SPAN>. The word<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in this type indicates exactly what the implicit parameter is used for: it is for ordering elements of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. Because this<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type is more explicit, it becomes no trouble to add implicit conversions for this type in the standard library. To contrast, imagine the chaos that would ensue if you added an implicit of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(T,</SPAN>&nbsp;<SPAN class=code>T)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the standard library, and the compiler started sprinkling it around in people's code. You would end up with code that compiles and runs, but that does fairly arbitrary tests against pairs of items!</P>
<P>Thus the style rule: use at least one role-determining name within the type of an implicit parameter.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=21.6></A>21.6 View bounds<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#21.6">link</A>]</SPAN></H3>
<P><A name=sec:view-bounds></A></P>
<P>The previous example had an opportunity to use an implicit but did not. Note that when you use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>implicit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on a parameter, then not only will the compiler try to<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">supply</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>that parameter with an implicit value, but the compiler will also<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">use</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>that parameter as an available implicit in the body of the method! Thus, both uses of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>within the body of the method can be left out.</P>
<P><A name=lst:max-list-take-three></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;maxList[T](elements:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;orderer:&nbsp;T&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ordered[T]</SPAN>):&nbsp;T&nbsp;=
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">IllegalArgumentException</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"empty&nbsp;list!"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;maxRest&nbsp;=&nbsp;maxList(rest)&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;(orderer)&nbsp;is&nbsp;implicit</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;&gt;&nbsp;maxRest)&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;orderer(x)&nbsp;is&nbsp;implicit</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;maxRest
  &nbsp;&nbsp;&nbsp;&nbsp;}
</PRE>
<H5>Listing 21.4 - A function that uses an implicit parameter internally.</H5>
<P>When the compiler examines the code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:max-list-take-three">Listing 21.4</A>, it will see that the types do not match up. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not have a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, and so<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>maxRest</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not work. The compiler will not immediately stop, however. It will first look for implicit conversions to repair the code. In this case, it will notice that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is available, so it can convert the code to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderer(x)</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>maxRest</SPAN>. Likewise for the expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxList(rest)</SPAN>, which can be converted to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxList(rest)(ordered)</SPAN>. After these two insertions of implicits, the method fully type checks.</P>
<P>Look closely at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxList</SPAN>. There is not a single mention of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter in the text of the method. All uses of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are implicit. Surprisingly, this coding pattern is actually fairly common. The implicit parameter is used only for conversions, and so it can itself be used implicitly.</P>
<P>Now, because the parameter name is never used explicitly, the name could have been anything. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would behave identically if you left its body alone but changed the parameter name:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;maxList[T](elements:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;converter:&nbsp;T&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ordered[T]</SPAN>):&nbsp;T&nbsp;=
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;same&nbsp;body...</SPAN>
</PRE>For that matter, it could just as well be:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;maxList[T](elements:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;iceCream:&nbsp;T&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ordered[T]</SPAN>):&nbsp;T&nbsp;=
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;same&nbsp;body...</SPAN>
</PRE>Because this pattern is common, Scala lets you leave out the name of this parameter and shorten the method header by using a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">view bound</EM>.<A id=i-427110256-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Using a view bound, you would write the signature of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:max-list-view-bound">Listing 21.5</A>.<A name=lst:max-list-view-bound></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;maxList[T&nbsp;&lt;%&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ordered[T]</SPAN>](elements:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>):&nbsp;T&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;elements&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">IllegalArgumentException</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"empty&nbsp;list!"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;::&nbsp;rest&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;maxRest&nbsp;=&nbsp;maxList(rest)&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;(orderer)&nbsp;is&nbsp;implicit</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;&gt;&nbsp;maxRest)&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;orderer(x)&nbsp;is&nbsp;implicit</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;maxRest
  &nbsp;&nbsp;&nbsp;&nbsp;}
</PRE>
<H5>Listing 21.5 - A function with a view bound.</H5>
<P>You can think of "<SPAN class=code>T</SPAN>&nbsp;<SPAN class=code>&lt;%</SPAN>&nbsp;<SPAN class=code>Ordered[T]</SPAN>" as saying, "I can use any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>,<A id=i-1194997031-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>so long as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">can be treated as an</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered[T]</SPAN>." This is different from saying that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">is an</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered[T]</SPAN>, which is what an upper bound, "<SPAN class=code>T</SPAN>&nbsp;<SPAN class=code>&lt;:</SPAN>&nbsp;<SPAN class=code>Ordered[T]</SPAN>", would say. For example, even though class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered[Int]</SPAN>, you could still pass a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Int]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>so long as an implicit conversion from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered[Int]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is available. Moreover, if type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>happens to already be an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered[T]</SPAN>, you can still pass a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxList</SPAN>. The compiler will use an implicit<EM style="FONT-STYLE: italic">identity function</EM>,<A id=i-227104031-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>declared in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Predef</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;identity[A](x:&nbsp;A):&nbsp;A&nbsp;=&nbsp;x
</PRE>In this case, the conversion is a no-op; it simply returns the object it is given. 
<P></P>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">View bounds and upper bounds</H3>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxListUpBound</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function, of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:max-list-take-one">Listing 21.2</A>, specifies that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">is an</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with its upper bound,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>&nbsp;<SPAN class=code>&lt;:</SPAN>&nbsp;<SPAN class=code>Ordered[T]</SPAN>. By contrast, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function, of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:max-list-view-bound">Listing 21.5</A>, specifies that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">can be treated as an</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with its view bound,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>&nbsp;<SPAN class=code>&lt;%</SPAN>&nbsp;<SPAN class=code>Ordered[T]</SPAN>. If you compare the code of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxListUpBound</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with that of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxList</SPAN>, you'll find that the only non-cosmetic difference between the two is that the upper bound symbol,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;:</SPAN>, is changed to a view bound symbol,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;%</SPAN>. But<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>maxList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:max-list-view-bound">Listing 21.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>can work with many more types.</P></DIV>
<P><A name=lst:example></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Mocha</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Application</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PreferredDrink</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;preference:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;pref&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PreferredDrink</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"mocha"</SPAN>)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;enjoy(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)(<SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;drink:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PreferredDrink</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Welcome,&nbsp;"</SPAN>+&nbsp;name)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">".&nbsp;Enjoy&nbsp;a&nbsp;"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(drink.preference)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"!"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;enjoy(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"reader"</SPAN>)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 21.6 - Sample code that uses an implicit parameter.</H5>
<P><A name=lst:print:typer></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scalac&nbsp;-<SPAN class=typename style="COLOR: rgb(103,0,154)">Xprint</SPAN>:typer&nbsp;mocha.scala
  <SPAN class=output style="COLOR: rgb(90,0,0)">[[syntax&nbsp;trees&nbsp;at&nbsp;end&nbsp;of&nbsp;typer]]<SPAN class=comment style="COLOR: rgb(76,76,76)"></SPAN>
//&nbsp;Scala&nbsp;source:&nbsp;mocha.scala</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">package&nbsp;&lt;empty&gt;&nbsp;{</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;final&nbsp;object&nbsp;Mocha&nbsp;extends&nbsp;java.lang.Object&nbsp;with&nbsp;Application</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;ScalaObject&nbsp;{</SPAN>
  <BR>  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)"></SPAN>
//&nbsp;...</SPAN>
  <BR>  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;private[this]&nbsp;val&nbsp;pref:&nbsp;Mocha.PreferredDrink&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Mocha.this.PreferredDrink("mocha");</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;implicit&nbsp;&lt;stable&gt;&nbsp;&lt;accessor&gt;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;pref:&nbsp;Mocha.PreferredDrink&nbsp;=&nbsp;Mocha.this.pref;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;enjoy(name:&nbsp;String)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(implicit&nbsp;drink:&nbsp;Mocha.PreferredDrink):&nbsp;Unit&nbsp;=&nbsp;{</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.this.Predef.print("Welcome,&nbsp;".+(name));</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.this.Predef.print(".&nbsp;Enjoy&nbsp;a&nbsp;");</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.this.Predef.print(drink.preference);</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scala.this.Predef.println("!")</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;};</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;Mocha.this.enjoy("reader")(Mocha.this.pref)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;}</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">}</SPAN>
</PRE>
<H5>Listing 21.7 - Sample code after type checking and insertion of implicits.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=21.7></A>21.7 Debugging implicits<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#21.7">link</A>]</SPAN></H3>
<P>Implicits are an extremely powerful feature in Scala, but one which is sometimes difficult to get right and to debug. This section contains a few tips for debugging implicits.</P>
<P>Sometimes you might wonder why the compiler did not find an implicit conversion that you think should apply. In that case it helps to write the conversion out explicitly. If that also gives an error message, you then know why the compiler could not apply your implicit. For instance, assume that you mistakenly took<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stringWrapper</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be a conversion from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>s to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>s, instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RandomAccessSeq</SPAN>s. You would wonder why the following does not work:<A id=i-677980410-8></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;chars:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Char]</SPAN>&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"xyz"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:12:&nbsp;error:&nbsp;type&nbsp;mismatch;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;java.lang.String("xyz")</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;required:&nbsp;List[Char]</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;chars:&nbsp;List[Char]&nbsp;=&nbsp;"xyz"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>In that case it helps to write the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stringWrapper</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>conversion explicitly, to find out what went wrong:<A id=i-677980410-9></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;chars:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Char]</SPAN>&nbsp;=&nbsp;stringWrapper(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"xyz"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:12:&nbsp;error:&nbsp;type&nbsp;mismatch;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;java.lang.Object&nbsp;with&nbsp;RandomAccessSeq[Char]</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;required:&nbsp;List[Char]</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;chars:&nbsp;List[Char]&nbsp;=&nbsp;stringWrapper("xyz")</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>With this, you have found the cause of the error:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stringWrapper</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has the wrong return type. On the other hand, it's also possible that inserting the conversion explicitly will make the error go away. In that case you know that one of the other rules (such as the Scope Rule) was preventing the implicit from being applied.</P>
<P>When you are debugging a program, it can sometimes help to see what implicit conversions the compiler is inserting. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-Xprint:typer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>option to the compiler is useful for this. If you run<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scalac</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with this option, then the compiler will show you what your code looks like after all implicit conversions have been added by the type checker. An example is shown in<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:example">Listing 21.6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:print:typer">Listing 21.7</A>. If you look at the last statement in each of these listings, you'll see that the second parameter list to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>enjoy</SPAN>, which was left off in the code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:example">Listing 21.6</A>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  enjoy(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"reader"</SPAN>)
</PRE>was inserted by the compiler, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#lst:print:typer">Listing 21.7</A>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Mocha.this.enjoy("reader")(Mocha.this.pref)</SPAN>
</PRE>
<P></P>
<P>If you are brave, try<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN>&nbsp;<SPAN class=code>-Xprint:typer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to get an interactive shell that prints out the post-typing source code it uses internally. If you do so, be prepared to see an enormous amount of boilerplate surrounding the meat of your code.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=21.8></A>21.8 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#21.8">link</A>]</SPAN></H3>
<P>Implicits are a powerful, code-condensing feature of Scala. This chapter has shown you Scala's rules about implicits, and it has shown you several common programming situations where you can profit from using implicits.</P>
<P>As a word of warning, implicits can make code confusing if they are used too frequently. Thus, before adding a new implicit conversion, first ask whether you can achieve a similar effect through other means, such as inheritance, mixin composition, or method overloading. If all of these fail, however, and you feel like a lot of your code is still tedious and redundant, then implicits might just be able to help you out.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 21:</H4>
<P><A name=footnote21-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In fact, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Predef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object already defines a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stringWrapper</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>conversion with similar functionality, so in practice you can use this conversion instead of defining your own.</P>
<P><A name=footnote21-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Variables and singleton objects marked implicit can be used as<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">implicit parameters</EM>. This use case will be described later in this chapter.</P>
<P><A name=footnote21-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The Scala compiler backend will treat the conversion specially, however, translating it to a special "<SPAN class=code>i2d</SPAN>" bytecode. So the compiled image is the same as in Java.</P></DIV>