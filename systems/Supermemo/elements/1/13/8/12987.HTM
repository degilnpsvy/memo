<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 23 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">For Expressions Revisited</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html">Chapter 16</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>demonstrated that higher-order functions such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>provide powerful constructions for dealing with lists. But sometimes the level of abstraction required by these functions makes a program a bit hard to understand. Here's an example. Say you are given a list of persons, each defined as an instance of a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Person</SPAN>. Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Person</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has fields indicating the person's name, whether (s)he is male, and his/her children. Here's the class definition:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isMale:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>*)
</PRE>Here's a list of some sample<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>person</SPAN>s:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;lara&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Lara"</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bob&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Bob"</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;julie&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Julie"</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>,&nbsp;lara,&nbsp;bob)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;persons&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(lara,&nbsp;bob,&nbsp;julie)
</PRE>Now, say you want to find out the names of all pairs of mothers and their children in that list. Using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>, you can formulate the following query:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;persons&nbsp;filter&nbsp;(p&nbsp;=&gt;&nbsp;!p.isMale)&nbsp;flatMap&nbsp;(p&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p.children&nbsp;map&nbsp;(c&nbsp;=&gt;&nbsp;(p.name,&nbsp;c.name))))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res5:&nbsp;List[(String,&nbsp;String)]&nbsp;=&nbsp;List((Julie,Lara),</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;(Julie,Bob))</SPAN>
</PRE>The query does its job, but it's not exactly trivial to write or understand. Is there a simpler way? In fact, there is. Remember the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/builtin-control-structures.html#sec:for-expressions">Section 7.3</A><A id=i-207940604-3></A>? Using a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN>expression, the same example can be written as follows:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(p&nbsp;&lt;-&nbsp;persons;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;!p.isMale;&nbsp;c&nbsp;&lt;-&nbsp;p.children)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;(p.name,&nbsp;c.name)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res6:&nbsp;List[(String,&nbsp;String)]&nbsp;=&nbsp;List((Julie,Lara),</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;(Julie,Bob))</SPAN>
</PRE>The result of this expression is exactly the same as the result of the previous expression. What's more, most readers of the code would likely find the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression much clearer than the previous query, which used the higher-order functions,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN><A id=i-482121133-1></A>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><A id=i-1499753963-1></A>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><A id=i-713351569-1></A>. 
<P></P>
<P>However, the two queries are not as dissimilar as it might seem. In fact, it turns out that the Scala compiler will translate the second query into the first one. More generally, all<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN>expressions that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>yield</SPAN><A id=i-1534065145-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>a result are translated by the compiler into combinations of invocations of the higher-order methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>. All<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops without<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>yield</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are translated into a smaller set of higher-order functions: just<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><A id=i-493461951-1></A>.</P>
<P>In this chapter, you'll find out first about the precise rules of writing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions. After that, you'll see how they can make combinatorial problems easier to solve. Finally, you'll learn how<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions are translated, and how as a result,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions can help you "grow" the Scala language into new application domains.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=23.1></A>23.1 For expressions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/for-expressions-revisited.html#23.1">link</A>]</SPAN></H3>
<P>Generally, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression is of the form:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(&nbsp;<SPAN style="FONT-STYLE: italic">seq</SPAN>&nbsp;)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>
</PRE>Here,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">seq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a sequence of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">generators</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">definitions</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">filters</SPAN>, with semicolons between successive elements. An example is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(p&nbsp;&lt;-&nbsp;persons;&nbsp;n&nbsp;=&nbsp;p.name;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(n&nbsp;startsWith&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"To"</SPAN>))&nbsp;
  <SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;n
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression above contains one generator, one definition, and one filter. As mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/builtin-control-structures.html#sec:for-expressions">Section 7.3</A>, you can also enclose the sequence in braces instead of parentheses, then the semicolons become optional:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;{
  &nbsp;&nbsp;p&nbsp;&lt;-&nbsp;persons&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;a&nbsp;generator</SPAN>
  &nbsp;&nbsp;n&nbsp;=&nbsp;p.name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;a&nbsp;definition</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(n&nbsp;startsWith&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"To"</SPAN>)&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;a&nbsp;filter</SPAN>
  }&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;n
</PRE>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">generator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is of the form:<A id=i1422302298-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN style="FONT-STYLE: italic">pat</SPAN>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>
</PRE>The expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>typically returns a list, even though you will see later that this can be generalized. The pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">pat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>gets matched one-by-one against all elements of that list.<A id=i-1272952554-2></A><A id=i371386352-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>If the match succeeds, the variables in the pattern get bound to the corresponding parts of the element, just the way it is described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html">Chapter 15</A>. But if the match fails, no<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MatchError</SPAN>is thrown.<A id=i797126047-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Instead, the element is simply discarded from the iteration. 
<P></P>
<P>In the most common case, the pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">pat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is just a variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">x</SPAN>, as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-STYLE: italic">x</SPAN></SPAN>&nbsp;<SPAN class=code>&lt;-</SPAN>&nbsp;<SPAN class=code><SPAN style="FONT-STYLE: italic">expr</SPAN></SPAN>. In that case, the variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>simply iterates over all elements returned by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">expr</SPAN>.</P>
<P>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">definition</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is of the form:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN style="FONT-STYLE: italic">pat</SPAN>&nbsp;=&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>
</PRE>This definition binds the pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">pat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">expr</SPAN>. So it has the same effect as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">x</SPAN>&nbsp;=&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>
</PRE>The most common case is again where the pattern is a simple variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>e.g.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-STYLE: italic">x</SPAN></SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code><SPAN style="FONT-STYLE: italic">expr</SPAN></SPAN>. This defines<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a name for the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">expr</SPAN>. 
<P></P>
<P>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is of the form:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>
</PRE>Here,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an expression of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN>.<A id=i331566550-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The filter drops from the iteration all elements for which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>. 
<P></P>
<P>Every<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression starts with a generator. If there are several generators in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression, later generators vary more rapidly than earlier ones. You can verify this easily with the following simple test:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(x&nbsp;&lt;-&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>);&nbsp;y&nbsp;&lt;-&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"one"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"two"</SPAN>))&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;(x,&nbsp;y)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;List[(Int,&nbsp;java.lang.String)]&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;List((1,one),&nbsp;(1,two),&nbsp;(2,one),&nbsp;(2,two))</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=23.2></A>23.2 The n-queens problem<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/for-expressions-revisited.html#23.2">link</A>]</SPAN></H3>
<P>A particularly suitable application area of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions are combinatorial puzzles. An example of such a puzzle is the 8-queens problem: Given a standard chess-board, place eight queens such that no queen is in check from any other (a queen can check another piece if they are on the same column, row, or diagonal). To find a solution to this problem, it's actually simpler to generalize it to chess-boards of arbitrary size. Hence, the problem is to place<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>N</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>queens on a chess-board of<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>N</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>\<I>times</I><SPAN class=Apple-converted-space>&nbsp;</SPAN><I>N</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>squares, where the size<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>N</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>is arbitrary. We'll start numbering cells at one, so the upper-left cell of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>N</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>\<I>times</I><SPAN class=Apple-converted-space>&nbsp;</SPAN><I>N</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>board has coordinate (1, 1), and the lower-right cell has coordinate (<I>N</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>N</I>).</P>
<P>To solve the N-queens problem, note that you need to place a queen in each row. So you could place queens in successive rows, each time checking that a newly placed queen is not in check from any other queens that have already been placed. In the course of this search, it might arrive that a queen that needs to be placed in row<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>k</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be in check in all fields of that row from queens in row 1 to<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>k</I>-1. In that case, you need to abort that part of the search in order to continue with a different configuration of queens in columns 1 to<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>k</I>-1.</P>
<P>An imperative solution to this problem would place queens one by one, moving them around on the board. But it looks difficult to come up with a scheme that really tries all possibilities.</P>
<P>A more functional approach represents a solution directly, as a value. A solution consists of a list of coordinates, one for each queen placed on the board.</P>
<P>Note, however, that a full solution can not be found in a single step. It needs to be built up gradually, by occupying successive rows with queens.</P>
<P>This suggests a recursive algorithm. Assume you have already generated all solutions of placing<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>k</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>queens on a board of size<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>N</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>\<I>times</I><SPAN class=Apple-converted-space>&nbsp;</SPAN><I>N</I>, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>k</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>is less than<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>N</I>. Each such solution can be presented by a list of length<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>k</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>of coordinates<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(row,</SPAN>&nbsp;<SPAN class=code>column)</SPAN>, where both row and column numbers range from 1 to<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>N</I>. It's convenient to treat these partial solution lists as stacks, where the coordinates of the queen in row<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>k</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>come first in the list, followed by the coordinates of the queen in row<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>k</I>-1, and so on. The bottom of the stack is the coordinate of the queen placed in the first row of the board. All solutions together are represented as a list of lists, with one element for each solution.</P>
<P>Now, to place the next queen in row<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>k</I>+1, generate all possible extensions of each previous solution by one more queen. This yields another list of solution lists, this time of length<I>k</I>+1. Continue the process until you have obtained all solutions of the size of the chess-board<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>N</I>. This algorithmic idea is embodied in function<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>placeQueens</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>below:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;queens(n:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[List[(Int, Int)]]</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;placeQueens(k:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[List[(Int, Int)]]</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(k&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>())
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queens&nbsp;&lt;-&nbsp;placeQueens(k&nbsp;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;to&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queen&nbsp;=&nbsp;(k,&nbsp;column)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;isSafe(queen,&nbsp;queens)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;queen&nbsp;::&nbsp;queens
  <BR>  &nbsp;&nbsp;placeQueens(n)
  }
</PRE>The outer function<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>queens</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the program above simply calls<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>placeQueens</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the size of the board<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>n</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as its argument. The task of the function application<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>placeQueens(k)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is to generate all partial solutions of length<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>k</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in a list. Every element of the list is one solution, represented by a list of length<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>k</SPAN>. So<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>placeQueens</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns a list of lists. 
<P></P>
<P>If the parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>k</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>placeQueens</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN>, this means that it needs to generate all solutions of placing zero queens on zero rows. There is exactly one such solution: place no queen at all. This is represented as a solution by the empty list. So if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>k</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is zero,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>placeQueens</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(List())</SPAN>, a list consisting of a single element that is the empty list. Note that this is quite different from the empty list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List()</SPAN>. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>placeQueens</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List()</SPAN>, this means<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">no solutions</SPAN>, instead of a single solution consisting of no placed queens.</P>
<P>In the other case, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>k</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not zero, all the work of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>placeQueens</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is done in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. The first generator of that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression iterates through all solutions of placing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>k</SPAN>&nbsp;<SPAN class=code>-</SPAN>&nbsp;<SPAN class=code>1</SPAN>queens on the board. The second generator iterates through all possible<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>column</SPAN>s on which the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>k</SPAN>'th queen might be placed. The third part of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression defines the newly considered<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>queen</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>position to be the pair consisting of row<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>k</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and each produced<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>column</SPAN>. The fourth part of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression is a filter which checks with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isSafe</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>whether the new queen is safe from check of all previous queens (the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isSafe</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be discussed a bit later).</P>
<P>If the new queen is not in check from any other queens, it can form part of a partial solution, so<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>placeQueens</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>generates with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>queen</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>queens</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>a new solution. If the new queen is not safe from check, the filter returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>, so no solution is generated.</P>
<P>The only remaining bit is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isSafe</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which is used to check whether a given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>queen</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in check from any other element in a list of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>queens</SPAN>. Here is its definition:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isSafe(queen:&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>),&nbsp;queens:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[(Int, Int)]</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;queens&nbsp;forall&nbsp;(q&nbsp;=&gt;&nbsp;!inCheck(queen,&nbsp;q))
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;inCheck(q1:&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>),&nbsp;q2:&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>))&nbsp;=&nbsp;
  &nbsp;&nbsp;q1._1&nbsp;==&nbsp;q2._1&nbsp;||&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;same&nbsp;row</SPAN>
  &nbsp;&nbsp;q1._2&nbsp;==&nbsp;q2._2&nbsp;||&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;same&nbsp;column</SPAN>
  &nbsp;&nbsp;(q1._1&nbsp;-&nbsp;q2._1).abs&nbsp;==&nbsp;(q1._2&nbsp;-&nbsp;q2._2).abs&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;on&nbsp;diagonal</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isSafe</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method expresses that a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>queen</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is safe with respect to some other<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>queens</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if it is not in check from any other queen. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>inCheck</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method expresses that queens<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=code>q2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are mutually in check. It returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in one of three cases: 
<P></P>
<OL>
<LI>If the two queens have the same row coordinate, 
<LI>If the two queens have the same column coordinate, 
<LI>If the two queens are on the same diagonal,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, the difference between their rows and the difference between their columns are the same.</LI></OL>The first case, that the two queens have the same row coordinate, cannot happen in the application because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>placeQueens</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>already takes care to place each queen in a different row. So you could remove the test without changing the functionality of the program as a whole. 
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=23.3></A>23.3 Querying with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/for-expressions-revisited.html#23.3">link</A>]</SPAN></H3>
<P><A name=sec:for-queries></A></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>notation is essentially equivalent to common operations of database query languages<A id=i1851175608-1></A>. For instance, say you are given a database named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>books</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN>represented as a list of books, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Book</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Book</SPAN>(title:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;authors:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>*)
</PRE>Here is a small example database, represented as an in-memory list:<A id=i471924076-2></A><A id=i-1712702061-2></A><A id=i1109104818-1></A><A id=i-601321358-1></A><A id=i134333723-1></A><A id=i875843663-1></A><A id=i1916394333-2></A><A id=i-1202190098-1></A><A id=i1512661551-2></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;books:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Book]</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Book</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Structure&nbsp;and&nbsp;Interpretation&nbsp;of&nbsp;Computer&nbsp;Programs"</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Abelson,&nbsp;Harold"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Sussman,&nbsp;Gerald&nbsp;J."</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Book</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Principles&nbsp;of&nbsp;Compiler&nbsp;Design"</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Aho,&nbsp;Alfred"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Ullman,&nbsp;Jeffrey"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Book</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Programming&nbsp;in&nbsp;Modula-2"</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Wirth,&nbsp;Niklaus"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Book</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Elements&nbsp;of&nbsp;ML&nbsp;Programming"</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Ullman,&nbsp;Jeffrey"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Book</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"The&nbsp;Java&nbsp;Language&nbsp;Specification"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Gosling,&nbsp;James"</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Joy,&nbsp;Bill"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Steele,&nbsp;Guy"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Bracha,&nbsp;Gilad"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;)
</PRE>Then, to find the titles of all books whose author's last name is "Gosling":<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(b&nbsp;&lt;-&nbsp;books;&nbsp;a&nbsp;&lt;-&nbsp;b.authors
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;a&nbsp;startsWith&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Gosling"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;b.title
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;List[String]&nbsp;=&nbsp;List(The&nbsp;Java&nbsp;Language&nbsp;Specification)</SPAN>
</PRE>Or, to find the titles of all books that have the string "Program" in their title:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(b&nbsp;&lt;-&nbsp;books&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(b.title&nbsp;indexOf&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Program"</SPAN>)&nbsp;&gt;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;b.title
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;List[String]&nbsp;=&nbsp;List(Structure&nbsp;and&nbsp;Interpretation&nbsp;of</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Computer&nbsp;Programs,&nbsp;Programming&nbsp;in&nbsp;Modula-2,&nbsp;Elements</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;ML&nbsp;Programming)</SPAN>
</PRE>Or, to find the names of all authors that have written at least two books in the database:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(b1&nbsp;&lt;-&nbsp;books;&nbsp;b2&nbsp;&lt;-&nbsp;books&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;b1&nbsp;!=&nbsp;b2;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1&nbsp;&lt;-&nbsp;b1.authors;&nbsp;a2&nbsp;&lt;-&nbsp;b2.authors&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;a1&nbsp;==&nbsp;a2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;a1
  <SPAN class=output style="COLOR: rgb(90,0,0)">res5:&nbsp;List[String]&nbsp;=&nbsp;List(Ullman,&nbsp;Jeffrey,&nbsp;Ullman,&nbsp;Jeffrey)</SPAN>
</PRE>The last solution is not yet perfect, because authors will appear several times in the list of results. You still need to remove duplicate authors from result lists. This can be achieved with the following function:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;removeDuplicates[A](xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[A]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[A]</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(xs.isEmpty)&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs.head&nbsp;::&nbsp;removeDuplicates(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs.tail&nbsp;filter&nbsp;(x&nbsp;=&gt;&nbsp;x&nbsp;!=&nbsp;xs.head)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">removeDuplicates:&nbsp;[A](List[A])List[A]</SPAN>
  <BR>  scala&gt;&nbsp;removeDuplicates(res5)
  res6:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[java.lang.String]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Ullman</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Jeffrey</SPAN>)
</PRE>It's worth noting that the last expression in method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>removeDuplicates</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be equivalently expressed using a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  xs.head&nbsp;::&nbsp;removeDuplicates(
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(x&nbsp;&lt;-&nbsp;xs.tail&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;x&nbsp;!=&nbsp;xs.head)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;x
  )
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=23.4></A>23.4 Translation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/for-expressions-revisited.html#23.4">link</A>]</SPAN></H3>
<P>Every<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression can be expressed in terms of the three higher-order functions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>. This section describes the translation scheme, which is also used by the Scala compiler.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Translating<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions with one generator</H4>
<P>First, assume you have a simple<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<I>x</I>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_1)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2
</PRE>where<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>x</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a variable. Such an expression is translated to:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN style="FONT-STYLE: italic">expr</SPAN>_1.map(<I>x</I>&nbsp;=&gt;&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2)
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Translating<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions starting with a generator and a filter</H4>
<P>Now, consider<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions that combine a leading generator with some other elements. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression of the form:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<I>x</I>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_1&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_3
</PRE>is translated to:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<I>x</I>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_1&nbsp;filter&nbsp;(<I>x</I>&nbsp;=&gt;&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2))&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_3
</PRE>This translation gives another<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression that is shorter by one element than the original, because an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>element is transformed into an application of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the first generator expression. The translation then continues with this second expression, so in the end you obtain:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN style="FONT-STYLE: italic">expr</SPAN>_1&nbsp;filter&nbsp;(<I>x</I>&nbsp;=&gt;&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2)&nbsp;map&nbsp;(<I>x</I>&nbsp;=&gt;&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_3)
</PRE>The same translation scheme also applies if there are further elements following the filter. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">seq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an arbitrary sequence of generators, definitions and filters, then:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<I>x</I>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_1&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2;&nbsp;<SPAN style="FONT-STYLE: italic">seq</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_3
</PRE>is translated to:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<I>x</I>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_1&nbsp;filter&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2;&nbsp;<SPAN style="FONT-STYLE: italic">seq</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_3
</PRE>Then translation continues with the second expression, which is again shorter by one element than the original one. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Translating<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions starting with two generators</H4>
<P>The next case handles<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions that start with two filters, as in:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<I>x</I>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_1;&nbsp;<I>y</I>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2;&nbsp;<SPAN style="FONT-STYLE: italic">seq</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_3
</PRE>Again, assume that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">seq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an arbitrary sequence of generators, definitions and filters. In fact,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">seq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>might also be empty, and in that case there would not be a semicolon after<SPAN class=code><SPAN style="FONT-STYLE: italic">expr</SPAN>_2</SPAN>. The translation scheme stays the same in each case. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression above is translated to an application of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN style="FONT-STYLE: italic">expr</SPAN>_1.flatMap(<I>x</I>&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<I>y</I>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2;&nbsp;<SPAN style="FONT-STYLE: italic">seq</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_3)
</PRE>This time, there is another<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression in the function value passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>. That<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression (which is again simpler by one element than the original) is in turn translated with the same rules. 
<P></P>
<P>The three translation schemes given so far are sufficient to translate all<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions that contain just generators and filters, and where generators bind only simple variables. Take for instance the query, "find all authors who have published at least two books," from<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/for-expressions-revisited.html#sec:for-queries">Section 23.3</A>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(b1&nbsp;&lt;-&nbsp;books;&nbsp;b2&nbsp;&lt;-&nbsp;books&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;b1&nbsp;!=&nbsp;b2;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1&nbsp;&lt;-&nbsp;b1.authors;&nbsp;a2&nbsp;&lt;-&nbsp;b2.authors&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;a1&nbsp;==&nbsp;a2)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;a1
</PRE>This query translates to the following<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>/<SPAN class=code>flatMap</SPAN>/<SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>combination:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  books&nbsp;flatMap&nbsp;(b1&nbsp;=&gt;
  &nbsp;&nbsp;books&nbsp;filter&nbsp;(b2&nbsp;=&gt;&nbsp;b1&nbsp;!=&nbsp;b2)&nbsp;flatMap&nbsp;(b2&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;b1.authors&nbsp;flatMap&nbsp;(a1&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b2.authors&nbsp;filter&nbsp;(a2&nbsp;=&gt;&nbsp;a1&nbsp;==&nbsp;a2)&nbsp;map&nbsp;(a2&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1))))
</PRE>The translation scheme presented so far does not yet handle generators that that bind whole patterns instead of simple variables. It also does not yet cover definitions. These two aspects will be explained in the next two sub-sections. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Translating patterns in generators</H4>
<P>The translation scheme becomes more complicated if the left hand side of generator is a pattern,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">pat</SPAN>, other than a simple variable. Still relatively easy to handle is the case where the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression binds a tuple of variables. In that case, almost the same scheme as for single variables applies. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression of the form:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;((<I>x_1</I>,&nbsp;...,&nbsp;<I>x_n</I>)&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_1)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2
</PRE>translates to:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN style="FONT-STYLE: italic">expr</SPAN>_1.map&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;(<I>x_1</I>,&nbsp;...,&nbsp;<I>x_n</I>)&nbsp;=&gt;&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2&nbsp;}
</PRE>Things become a bit more involved if the left hand side of the generator is an arbitrary pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">pat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of a single variable or a tuple. In this case:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<SPAN style="FONT-STYLE: italic">pat</SPAN>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_1)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2
</PRE>translates to:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN style="FONT-STYLE: italic">expr</SPAN>_1&nbsp;filter&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">pat</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  }&nbsp;map&nbsp;{&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">pat</SPAN>&nbsp;=&gt;&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2
  }
</PRE>That is, the generated items are first filtered and only those that match<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">pat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are mapped. Therefore, it's guaranteed that a pattern-matching generator will never throw a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MatchError</SPAN><A id=i797126047-2></A> 
<P>The scheme above only treated the case where the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression contains a single pattern-matching generator. Analogous rules apply if the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression contains other generators, filters, or definitions. Because these additional rules don't add much new insight, they are omitted from discussion here. If you are interested,<SPAN class=Apple-converted-space>&nbsp;</SPAN>you can look them up in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Scala Language Specification</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#sls">sls</A>.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Translating definitions</H4>
<P>The last missing situation is where a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression contains embedded definitions. Here's a typical case:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<I>x</I>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_1;&nbsp;<I>y</I>&nbsp;=&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2;&nbsp;<SPAN style="FONT-STYLE: italic">seq</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_3
</PRE>Assume again that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">seq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a (possibly empty) sequence of generators, definitions, and filters. This expression is translated to the following one:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;((<I>x</I>,&nbsp;<I>y</I>)&nbsp;&lt;-&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<I>x</I>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_1)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;(<I>x</I>,&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2);&nbsp;<SPAN style="FONT-STYLE: italic">seq</SPAN>)&nbsp;
  <SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_3
</PRE>So you see that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-STYLE: italic">expr</SPAN>_2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is evaluated each time there is a new<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>x</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>value being generated. This re-evaluation is necessary, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-STYLE: italic">expr</SPAN>_2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>might refer to<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>x</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>and so needs to be re-evaluated for changing values of<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>x</I>. For you as a programmer the conclusion is that it's probably not a good idea to have definitions embedded in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions that do not refer to variables bound by some preceding generator, because re-evaluating such expressions would be wasteful. For instance, instead of:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(x&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;to&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1000</SPAN>;&nbsp;y&nbsp;=&nbsp;expensiveComputationNotInvolvingX)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;x&nbsp;*&nbsp;y
</PRE>it's usually better to write:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;y&nbsp;=&nbsp;expensiveComputationNotInvolvingX
  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(x&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;to&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1000</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;x&nbsp;*&nbsp;y
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Translating<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops</H4>
<P>The previous subsections showed how<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions that contain a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>yield</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are translated.<A id=i-382847944-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>What about<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops that simply perform a side effect without returning anything? Their translation is similar, but simpler than<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions. In principle, wherever the previous translation scheme used a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the translation, the translation scheme for<SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops uses just a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN>. For instance, the expression:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<I>x</I>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_1)&nbsp;<SPAN style="FONT-STYLE: italic">body</SPAN>
</PRE>translates to:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN style="FONT-STYLE: italic">expr</SPAN>_1&nbsp;foreach&nbsp;(<I>x</I>&nbsp;=&gt;&nbsp;<SPAN style="FONT-STYLE: italic">body</SPAN>)
</PRE>A larger example is the expression:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<I>x</I>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_1;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2;&nbsp;<I>y</I>&nbsp;&lt;-&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_3)&nbsp;<SPAN style="FONT-STYLE: italic">body</SPAN>
</PRE>This expression translates to:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN style="FONT-STYLE: italic">expr</SPAN>_1&nbsp;filter&nbsp;(<I>x</I>&nbsp;=&gt;&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_2)&nbsp;foreach&nbsp;(<I>x</I>&nbsp;=&gt;
  &nbsp;&nbsp;<SPAN style="FONT-STYLE: italic">expr</SPAN>_3&nbsp;foreach&nbsp;(<I>y</I>&nbsp;=&gt;&nbsp;<SPAN style="FONT-STYLE: italic">body</SPAN>))
</PRE>For example, the following expression sums up all elements of a matrix represented as a list of lists:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;sum&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(xs&nbsp;&lt;-&nbsp;xss;&nbsp;x&nbsp;&lt;-&nbsp;xs)&nbsp;sum&nbsp;+=&nbsp;x
</PRE>This loop is translated into two nested<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>applications:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;sum&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  xss&nbsp;foreach&nbsp;(xs&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;xs&nbsp;foreach&nbsp;(x&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;x))
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=23.5></A>23.5 Going the other way<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/for-expressions-revisited.html#23.5">link</A>]</SPAN></H3>
<P>The previous section showed that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions can be translated into applications of the higher-order functions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>. In fact, you could equally well go the other way: every application of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be represented as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. Here are implementations of the three methods in terms of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions. The methods are contained in an object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Demo</SPAN>, to distinguish them from the standard operations on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>s. To be concrete, the three functions all take a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as parameter, but the translation scheme would work just as well with other collection types:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Demo</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;map[A,&nbsp;B](xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[A]</SPAN>,&nbsp;f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[B]</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(x&nbsp;&lt;-&nbsp;xs)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;f(x)
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;flatMap[A,&nbsp;B](xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[A]</SPAN>,&nbsp;f:&nbsp;A&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[B]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[B]</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(x&nbsp;&lt;-&nbsp;xs;&nbsp;y&nbsp;&lt;-&nbsp;f(x))&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;y
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filter[A](xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[A]</SPAN>,&nbsp;p:&nbsp;A&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[A]</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(x&nbsp;&lt;-&nbsp;xs&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;p(x))&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;x
  }
</PRE>Not surprisingly, the translation of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression used in the body of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Demo.map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will produce a call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. Similarly,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Demo.flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Demo.filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>translate to<SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. 
<P></P>
<P>So this little demonstration has shown that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions really are equivalent in their expressiveness to applications of the three functions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=23.6></A>23.6 Generalizing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/for-expressions-revisited.html#23.6">link</A>]</SPAN></H3>
<P>Because the translation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions only relies on the presence of methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>, it is possible to apply the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>notation to a large class of data types.</P>
<P>You have already seen<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions over lists and arrays. These are supported because lists, as well as arrays, define operations<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>. Because they define a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method as well,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops over these data types are also possible.</P>
<P>Besides lists and arrays, there are also many other types in the Scala standard library that support the same four methods and therefore allow<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions. Examples are ranges, iterators, streams, and all implementations of sets.<A id=i-47073124-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It's also perfectly possible for your own data types to support<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions by defining the necessary methods. To support the full range of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops, you need to define<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as methods of your data type. But it's also possible to define a subset of these methods, and thereby support a subset of all possible<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions or loops. Here are the precise rules:</P>
<UL>
<LI>If your type defines just<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>, it allows<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions consisting of a single generator. 
<LI>If it defines<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as well as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>, it allows<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions consisting of several generators. 
<LI>If it defines<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN>, it allows<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops (both with single and multiple generators). 
<LI>If it defines<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>, it allows for filter expressions starting with an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression.</LI></UL>The translation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions happens before type checking.<A id=i-1430360982-1></A><A id=i746576009-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This allows for maximal flexibility, because it is only required that the result of expanding a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression type checks. Scala defines no typing rules for the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions themselves, and does not require<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to have any particular type signatures. 
<P>Nevertheless, there is a typical setup that captures the most common intention of the higher order methods to which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions translate. Say you have a parameterized class,<SPAN class=code>C</SPAN>, which typically would stand for some sort of collection. Then it's quite natural to pick the following type signatures for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;C[A]&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;C[B]
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;flatMap[B](f:&nbsp;A&nbsp;=&gt;&nbsp;C[B]):&nbsp;C[B]
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filter(p:&nbsp;A&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>):&nbsp;C[A]
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;foreach(b:&nbsp;A&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Unit</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Unit</SPAN>
  }
</PRE>That is, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function takes a function from the collection's element type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to some other type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>B</SPAN>. It produces a new collection of the same kind<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN>, but with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>B</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as the element type. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method takes a function<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to some<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN>-collection of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>B</SPAN>s and produces a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN>-collection of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>B</SPAN>s. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method takes a predicate function from the collection's element type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN>. It produces a collection of the same type as the one on which it is invoked. Finally, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method takes a function from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN>, and produces a<SPAN class=code>Unit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>result. 
<P></P>
<P>Concentrating on just the first three functions, the following facts are noteworthy. In functional programming, there's a general concept called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">monad</SPAN>, which can explain a large number of types with computations, ranging from collections, to computations with state and I/O, backtracking computations, and transactions, to name but a few.<A id=i-1068505564-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You can formulate functions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on a monad, and, if you do, they end up having exactly the types given above. Furthermore, you can characterize every monad by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>, plus a "unit" constructor that produces a monad from an element value. In an object-oriented language, this "unit" constructor is simply an instance constructor or a factory method. Therefore,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be seen as an object-oriented version of the functional concept of monad. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions are equivalent to applications of these three methods, they can be seen as syntax for monads.</P>
<P>All this suggests that the concept of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression is something more general than just iteration over a collection, and indeed it is. For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions also play an important role in asynchronous I/O, or as an alternative notation for optional values. Watch out in the Scala libraries for occurrences of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>&#8212;wherever they are present,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions suggest themselves as a concise way of manipulating elements of the type.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=23.7></A>23.7 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/for-expressions-revisited.html#23.7">link</A>]</SPAN></H3>
<P>In this chapter, you were given a peek under the hood of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops. You learned that they translate into applications of a standard set of higher-order methods. As a consequence of this, you saw that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions are really much more general than mere iterations over collections, and that you can design your own classes to support them.</P></DIV>