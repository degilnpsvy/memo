<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 22 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Implementing Lists</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>Lists have been ubiquitous in this book. Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is probably the most commonly used structured data type in Scala.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html">Chapter 16</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>showed you how to use lists.<A id=i2054390305-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This chapter "opens up the covers" and explains a bit how lists are implemented in Scala.</P>
<P>Knowing the internals of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class is useful for several reasons. You gain a better idea of the relative efficiency of list operations, which will help you in writing fast and compact code using lists. You also learn a toolbox of techniques that you can apply in the design of your own libraries. Finally, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class is a sophisticated application of Scala's type system in general and its genericity concepts in particular. So studying class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will deepen your knowledge in these areas.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=22.1></A>22.1 The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class in principle<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#22.1">link</A>]</SPAN></H3>
<P><A name=sec:list-impl-principle></A></P>
<P>Lists are not "built-in" as a language construct in Scala; they are defined by an abstract class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>package, which comes with two subclasses for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><A id=i304418243-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN>.<A id=i1899558990-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In the following we present a quick tour through class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. This section presents a somewhat simplified account of the class, compared to its real implementation in the Scala standard library, which is covered in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#sec:list-impl-practice">Section 22.3</A>.</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;scala
  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[+T]</SPAN>&nbsp;{
</PRE><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an abstract class, so you cannot define elements by calling the empty<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>constructor. For instance the expression "<SPAN class=code>new</SPAN>&nbsp;<SPAN class=code>List</SPAN>" would be illegal. The class has a type parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in front of this type parameter specifies that lists are covariant, as discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html">Chapter 19</A><A id=i-588033271-1></A>. Because of this property, you can assign a value of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Int]</SPAN>, say, to a variable of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Any]</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;xs&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">xs:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;ys:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Any]</SPAN>&nbsp;=&nbsp;xs
  <SPAN class=output style="COLOR: rgb(90,0,0)">ys:&nbsp;List[Any]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</SPAN>
</PRE>All list operations can be defined in terms of three basic methods:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isEmpty:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;head:&nbsp;T
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;tail:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>
</PRE>These three methods are all abstract in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><A id=i1657074897-3></A><A id=i-735890706-3></A><A id=i849842526-3></A>. They are defined in the subobject<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the subclass<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN>. The hierarchy for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#fig:list-hierarchy">Figure 22.1</A>. 
<P></P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:list-hierarchy></A>
<P><IMG alt="image images/listHierarchy53.jpg" src="http://www.artima.com/pins1ed/images/listHierarchy53.jpg"></P></DIV>
<H5>Figure 22.1 - Class hierarchy for Scala lists.<A id=i-490886053-1></A><A id=i-322128956-1></A><A id=i164593921-1></A></H5>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object</H4>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object defines an empty list.<A id=i1899558990-4></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Its definition is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#lst:nil-definition">Listing 22.1</A>.<A name=lst:nil-definition></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Nothing]</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isEmpty&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;head:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nothing</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">NoSuchElementException</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"head&nbsp;of&nbsp;empty&nbsp;list"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;tail:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Nothing]</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">NoSuchElementException</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"tail&nbsp;of&nbsp;empty&nbsp;list"</SPAN>)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 22.1 - The definition of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>singleton object.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object inherits from type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Nothing]</SPAN>. Because of covariance, this means that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is compatible with every instance of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type.</P>
<P>The three abstract methods of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are implemented in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object in a straightforward way: the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isEmpty</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods both throw an exception. Note that throwing an exception is not only reasonable, but practically the only possible thing to do for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN>: Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nothing</SPAN>, the result type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>must be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nothing</SPAN>. Since there is no value of this type, this means that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>cannot return a normal value. It has to return abnormally by throwing an exception.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#footnote22-1">[1]</A></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class</H4>
<P>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN>, pronounced "cons" for "construct," represents non-empty lists.<A id=i55390901-3></A><A id=i-1839436249-3></A><A id=i1411857630-4></A><A id=i1732245321-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It's named that way in order to support pattern matching with the infix<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><A id=i1357014823-1></A>. You have seen in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#sec:list-patterns">Section 16.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that every infix operation in a pattern is treated as a constructor application of the infix operator to its arguments. So the pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is treated as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::(x,</SPAN>&nbsp;<SPAN class=code>xs)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a case class. Here is the definition of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">final</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;::[T](hd:&nbsp;T,&nbsp;tl:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;head&nbsp;=&nbsp;hd
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;tail&nbsp;=&nbsp;tl
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isEmpty:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  }
</PRE>The implementation of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class is straightforward. It takes two parameters<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hd</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tl</SPAN>, representing the head and the tail of the list to be constructed. The definitions of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method simply return the corresponding parameter. In fact, this pattern can be abbreviated by letting the parameters directly implement the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods of the superclass<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>, as in the following equivalent but shorter definition of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">final</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;::[T](head:&nbsp;T,&nbsp;tail:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isEmpty:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  }
</PRE>This works because every case class parameter is implicitly also a field of the class (it's like the parameter declaration was prefixed with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>).<A id=i1467639728-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Recall from<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#sec:abstract-vals">Section 20.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that Scala allows you to implement an abstract parameterless method such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a field.<A id=i748048051-2></A><A id=i1692897037-2></A><A id=i84167179-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>So the code above directly uses the parameters<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as implementations of the abstract methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that were inherited from class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Some more methods</H4>
<P>All other<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods can be written using the basic three. For instance:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;length:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(isEmpty)&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;+&nbsp;tail.length
</PRE>or:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;drop(n:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(isEmpty)&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(n&nbsp;&lt;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;tail.drop(n&nbsp;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
</PRE>or:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;map[U](f:&nbsp;T&nbsp;=&gt;&nbsp;U):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[U]</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(isEmpty)&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;f(head)&nbsp;::&nbsp;tail.map(f)
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">List construction</H4>
<P>The list construction methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are special. Because they end in a colon, they are bound to their right operand. That is, an operation such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is treated as the method call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs.::(x)</SPAN>, not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x.::(xs)</SPAN>. In fact,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x.::(xs)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would not make sense, as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is of the list element type, which can be arbitrary, so we cannot assume that this type would have a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.</P>
<P>For this reason, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method should take an element value and yield a new list. What is the required type of the element value? You might be tempted to say, it should be the same as the list's element type, but in fact this is more restrictive than necessary. To see why, consider this class hierarchy:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fruit</SPAN>&nbsp;
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Apple</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fruit</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Orange</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fruit</SPAN>
</PRE><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#lst:supertype-cons">Listing 22.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows what happens when you construct lists of fruit:<A name=lst:supertype-cons></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;apples&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Apple</SPAN>&nbsp;::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;apples:&nbsp;List[Apple]&nbsp;=&nbsp;List(Apple@585fa9)</SPAN>
  <BR>  &nbsp;&nbsp;scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;fruits&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Orange</SPAN>&nbsp;::&nbsp;apples
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;fruits:&nbsp;List[Fruit]&nbsp;=&nbsp;List(Orange@cd6798,&nbsp;Apple@585fa9)</SPAN>
</PRE>
<H5>Listing 22.2 - Prepending a supertype element to a subtype list.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apples</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>value is treated as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN>s, as expected. However, the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>fruits</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows that it's still possible to add an element of a different type to that list. The element type of the resulting list is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruit</SPAN>, which is the most precise common supertype of the original list element type (<I>i.e.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN>) and the type of the element to be added (<I>i.e.</I>,<SPAN class=code>Orange</SPAN>). This flexibility is obtained by defining the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method (cons) as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#lst:cons-method-def">Listing 22.3</A>.<A name=lst:cons-method-def></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;::[U&nbsp;&gt;:&nbsp;T](x:&nbsp;U):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[U]</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;scala.::(x,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)
</PRE>
<H5>Listing 22.3 - The definition of method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(cons) in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>.</H5>
<P>Note that the method is itself polymorphic&#8212;it takes a type parameter named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN>. Furthermore,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is constrained in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>[U</SPAN>&nbsp;<SPAN class=code>&gt;:</SPAN>&nbsp;<SPAN class=code>T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be a supertype of the list element type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. The element to be added is required to be of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the result is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[U]</SPAN>.</P>
<P>With the formulation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#lst:cons-method-def">Listing 22.3</A>, you can check how the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>fruits</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#lst:supertype-cons">Listing 22.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>works out type-wise: in that definition the type parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is instantiated to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruit</SPAN>. The lower-bound constraint of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is satisfied, because the list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apples</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Apple]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a supertype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN>. The argument to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=code>new</SPAN>&nbsp;<SPAN class=code>Orange</SPAN>, which conforms to type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruit</SPAN>. Therefore, the method application is type-correct with result type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Fruit]</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#fig:more-fruit">Figure 22.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>illustrates the structure of the lists that result from executing the code shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#lst:cons-method-def">Listing 22.3</A>.</P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:more-fruit></A>
<P><IMG alt="image images/moreFruit.jpg" src="http://www.artima.com/pins1ed/images/moreFruit.jpg"></P></DIV>
<H5>Figure 22.2 - The structure of the Scala lists shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#lst:supertype-cons">Listing 22.2</A>.<A id=i-1313439186-1></A></H5>
<P>In fact, the polymorphic definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the lower bound<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not only convenient; it is also necessary to render the definition of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type-correct. This is because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>s are defined to be covariant<A id=i-1469695991-2></A>. Assume for a moment that we had defined<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;A&nbsp;thought&nbsp;experiment&nbsp;(which&nbsp;wouldn't&nbsp;work)</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;::(x:&nbsp;T):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;scala.::(x,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)
</PRE>You saw in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html">Chapter 19</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that method parameters count as contravariant positions, so the list element type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in contravariant position in the definition above. But then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>cannot be declared covariant in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. The lower bound<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>[U</SPAN>&nbsp;<SPAN class=code>&gt;:</SPAN>&nbsp;<SPAN class=code>T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>thus kills two birds with one stone: it removes a typing problem, and it leads to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that's more flexible to use. 
<P></P>
<P>The list concatenation method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined in a similar way to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN>, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#lst:concatenate-def">Listing 22.4</A>.<A name=lst:concatenate-def></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;:::[U&nbsp;&gt;:&nbsp;T](prefix:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[U]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[U]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(prefix.isEmpty)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;prefix.head&nbsp;::&nbsp;prefix.tail&nbsp;:::&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>
</PRE>
<H5>Listing 22.4 - The definition of method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>.</H5>
<P>Like cons, concatenation is polymorphic. The result type is "widened" as necessary to include the types of all list elements. Note also that again the order of the arguments is swapped between an infix operation and an explicit method call. Because both<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>end in a colon, they both bind to the right and are both right associative. For instance, the<SPAN class=code>else</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>part of the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#lst:concatenate-def">Listing 22.4</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains infix operations of both<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:::</SPAN>. These infix operations can be expanded to equivalent method calls as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  prefix.head&nbsp;::&nbsp;prefix.tail&nbsp;:::&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>
  &nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;<SPAN class=rm style="FONT-FAMILY: serif">(because <SPAN class=code>::</SPAN> and <SPAN class=code>:::</SPAN> are right-associative)</SPAN>
  <BR>  prefix.head&nbsp;::&nbsp;(prefix.tail&nbsp;:::&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)
  &nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;<SPAN class=rm style="FONT-FAMILY: serif">(because <SPAN class=code>::</SPAN> binds to the right)</SPAN>
  <BR>  (prefix.tail&nbsp;:::&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>).::(prefix.head)
  &nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;<SPAN class=rm style="FONT-FAMILY: serif">(because <SPAN class=code>:::</SPAN> binds to the right)</SPAN>
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.:::(prefix.tail).::(prefix.head)
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=22.2></A>22.2 The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#22.2">link</A>]</SPAN></H3>
<P><A name=sec:the-listbuffer-class></A></P>
<P>The typical access pattern for a list is recursive. For instance, to increment every element of a list without using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>you could write:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;incAll(xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>&nbsp;=&nbsp;xs&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;::&nbsp;incAll(xs1)
  }
</PRE>One shortcoming of this program pattern is that it is not tail recursive<A id=i2133301138-2></A>. Note that the recursive call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>incAll</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>above occurs inside a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation. Therefore each recursive call requires a new stack frame. On today's virtual machines this means that you cannot<A id=i10962622-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>apply<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>incAll</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to lists of much more than about 30,000 to 50,000 elements. This is a pity. 
<P></P>
<P>How do you write a version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>incAll</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that can work on lists of arbitrary size (as much as heap-capacity allows)? One approach is to use a loop:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(x&nbsp;&lt;-&nbsp;xs)&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;??</SPAN>
</PRE>But what should go in the loop body? Note that where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>incAll</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>above constructs the list by prepending elements to the result of the recursive call, the loop needs to append new elements at the end of the result list. One, very inefficient possibility is to use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:::</SPAN>, the list append operator:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;result&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>()&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;a&nbsp;very&nbsp;inefficient&nbsp;approach</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(x&nbsp;&lt;-&nbsp;xs)&nbsp;result&nbsp;=&nbsp;result&nbsp;:::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  result
</PRE>This has terrible efficiency, though. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes time proportional to the length of its first operand, the whole operation takes time proportional to the square of the length of the list. This is clearly unacceptable. 
<P></P>
<P>A better alternative is to use a list buffer. List buffers let you<A id=i-737429794-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>accumulate the elements of a list. To do this, you use an operation such as "<SPAN class=code>buf</SPAN>&nbsp;<SPAN class=code>+=</SPAN>&nbsp;<SPAN class=code>elem</SPAN>", which appends the element<SPAN class=code>elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>at the end of the list buffer<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>buf</SPAN>. Once you are done appending elements, you can turn the buffer into a list using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation.</P>
<P><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a class in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.mutable</SPAN><A id=i-1815843466-3></A>. To use the simple name only, you can import<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from its package:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable.ListBuffer
</PRE>Using a list buffer, the body of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>incAll</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can now be written as follows:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;buf&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ListBuffer[Int]</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(x&nbsp;&lt;-&nbsp;xs)&nbsp;buf&nbsp;+=&nbsp;x&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  buf.toList
</PRE>This is a very efficient way to build lists. In fact, the list buffer implementation is organized so that both the append operation (<SPAN class=code>+=</SPAN>)<A id=i714754650-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation take (very short) constant time.<A id=i-1804214425-1></A> 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=22.3></A>22.3 The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class in practice<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#22.3">link</A>]</SPAN></H3>
<P><A name=sec:list-impl-practice></A></P>
<P>The implementations of list methods given in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#sec:list-impl-principle">Section 22.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>are concise and clear, but suffer from the same stack overflow problem as the non-tail recursive implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>incAll</SPAN>. Therefore, most methods in the real implementation of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>avoid recursion and use loops with list buffers instead. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#lst:map-definition">Listing 22.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows the real implementation of<SPAN class=code>map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>:<A name=lst:map-definition></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">final</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;map[U](f:&nbsp;T&nbsp;=&gt;&nbsp;U):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[U]</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;b&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ListBuffer[U]</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;these&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">while</SPAN>&nbsp;(!these.isEmpty)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;+=&nbsp;f(these.head)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;these&nbsp;=&nbsp;these.tail
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;b.toList
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 22.5 - The definition of method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>.</H5>
<P>This revised implementation traverses the list with a simple loop, which is highly efficient. A tail recursive implementation would be<A id=i-666165524-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>similarly efficient, but a general recursive implementation would be slower and less scalable. But what about the operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b.toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>at the end? What is its complexity? In fact, the call to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method takes only a small number of cycles, which is independent of the length of the list.</P>
<P>To understand why, take a second look at class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN>, which constructs non-empty lists. In practice, this class does not quite correspond to its idealized definition given previously in<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#sec:list-impl-principle">Section 22.1</A>. The real definition is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#lst:class-doublecolon-definition">Listing 22.6</A>.<A name=lst:class-doublecolon-definition></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">final</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;::[U](hd:&nbsp;U,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>[scala]&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;tl:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[U]</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[U]</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;head&nbsp;=&nbsp;hd
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;tail&nbsp;=&nbsp;tl
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isEmpty:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 22.6 - The definition of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>.</H5>
<P>There's one peculiarity: the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tl</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>! This means that it is possible to modify the tail of a list after the list is constructed. However, because the variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tl</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has the modifier<SPAN class=code>private[scala]</SPAN>, it can be accessed only from within package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN>. Client code outside this package can neither read nor write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tl</SPAN>.</P>
<P>Since the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class is contained in a subpackage of package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.mutable</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can access the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tl</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field of a cons cell. In fact the elements of a list buffer are represented as a list and appending new elements involves a modification of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tl</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field of the last<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>cell in that list. Here's the start of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;scala.collection.immutable
  <SPAN class=vem style="COLOR: rgb(0,0,230)">final</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ListBuffer[T]</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Buffer[T]</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;start:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;last0:&nbsp;::[T]&nbsp;=&nbsp;_
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;exported:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;...
</PRE>You see three private fields that characterize a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN>: 
<P></P>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="">
<TD><SPAN class=code>start</SPAN></TD>
<TD>points to the list of all elements stored in the buffer</TD></TR>
<TR class="">
<TD><SPAN class=code>last0</SPAN></TD>
<TD>points to the last<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>cell in that list</TD></TR>
<TR class="">
<TD><SPAN class=code>exported</SPAN></TD>
<TD>indicates whether the buffer has been turned into</TD></TR>
<TR class="">
<TD></TD>
<TD>a list using a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation</TD></TR></TBODY></TABLE>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation is very simple:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toList:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;exported&nbsp;=&nbsp;!start.isEmpty
  &nbsp;&nbsp;start
  }
</PRE>It returns the list of elements referred to by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>start</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and also sets<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exported</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if that list is nonempty. So<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is very efficient, because it does not copy the list which is stored in a<SPAN class=code>ListBuffer</SPAN>. But what happens if the list is further extended after the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation? Of course, once a list is returned from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN>, it must be immutable. However, appending to the<SPAN class=code>last0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>element will modify the list which is referred to by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>start</SPAN>. 
<P></P>
<P>To maintain the correctness of the list buffer operations, you need to work on a fresh list instead. This is achieved by the first line in the implementation of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;+=&nbsp;(x:&nbsp;T)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(exported)&nbsp;copy()
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(start.isEmpty)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;last0&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;scala.::(x,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;start&nbsp;=&nbsp;last0
  &nbsp;&nbsp;}&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;last1&nbsp;=&nbsp;last0
  &nbsp;&nbsp;&nbsp;&nbsp;last0&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;scala.::(x,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;last1.tl&nbsp;=&nbsp;last0
  &nbsp;&nbsp;}
  }
</PRE>You see that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>copies the list pointed to by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>start</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exported</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is true. So, in the end, there is no free lunch. If you want to go from lists which can be extended at the end to immutable lists, there needs to be some copying. However, the implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is such that copying is necessary only for list buffers that are further extended after they have been turned into lists. This case is quite rare in practice. Most use cases of list buffers add elements incrementally and then do one<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation at the end. In such cases, no copying is necessary. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=22.4></A>22.4 Functional on the outside<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#22.4">link</A>]</SPAN></H3>
<P>The previous section showed key elements of the implementation of Scala's<A id=i-381431720-1></A><A id=i536175291-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>classes. You saw that lists are purely functional on the "outside" but have an imperative implementation using list buffers on the "inside." This is a typical strategy in Scala programming: trying to combine purity with efficiency by carefully delimiting the effects of impure operations.<A id=i-1924040307-1></A><A id=i982015373-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You might ask, why insist on purity? Why not just open up the definition of lists, making the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field, and maybe also the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field, mutable? The disadvantage of such an approach is that it would make programs much more fragile. Note that constructing lists with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>re-uses the tail of the constructed list. So when you write:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;ys&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;::&nbsp;xs
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;zs&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;::&nbsp;xs
</PRE>the tails of lists<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ys</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>zs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are shared; they point to the same data structure. This is essential for efficiency; if the list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was copied every time you added a new element onto it, this would be much slower. Because sharing is pervasive, changing list elements, if it were possible, would be quite dangerous. For instance, taking the code above, if you wanted to truncate list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ys</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to its first two elements by writing:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  ys.drop(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>).tail&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;can't&nbsp;do&nbsp;this&nbsp;in&nbsp;Scala!</SPAN>
</PRE>you would also truncate lists<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>zs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a side effect. Clearly, it would be quite difficult to keep track of what gets changed. That's why Scala opts for pervasive sharing and no mutation for lists. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class still allows you to build up lists imperatively and incrementally, if you wish to. But since list buffers are not lists, the types keep mutable buffers and immutable lists separate. 
<P></P>
<P>The design of Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is quite similar to what's done in Java's pair of classes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>StringBuffer</SPAN>. This is no coincidence. In both situations the designers wanted to maintain a pure immutable data structure but also wanted to provide an efficient way to construct this structure incrementally. For Java and Scala strings,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>StringBuffer</SPAN>s (or, in Java 5,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>StringBuilder</SPAN>s) provide a way to construct a string incrementally. For Scala's lists, you have a choice: You can either construct lists incrementally by adding elements to the beginning of a list using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN>, or you use a list buffer for adding elements to the end. Which one is preferable depends on the situation. Usually,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>lends itself well to recursive algorithms in the divide-and-conquer style. List buffers are often used in a more traditional loop-based style.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=22.5></A>22.5 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#22.5">link</A>]</SPAN></H3>
<P>In this chapter, you saw how lists are implemented in Scala.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is one of the most heavily used data structures in Scala, and it has a refined implementation.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>'s two subclasses,<SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN>, are both case classes. Instead of recursing through this structure, however, many core list methods are implemented using a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN>, in turn, is carefully implemented so that it can efficiently build lists without allocating extraneous memory. It is functional on the outside, but uses mutation internally to speed up the common case where a buffer is discarded after<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is been called. After studying all of this, you now know the list classes inside and out, and you might have learned an implementation trick or two.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 22:</H4>
<P><A name=footnote22-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>To be precise, the types would also permit for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to always go into an infinite loop instead of throwing an exception, but this is clearly not what's wanted.</P></DIV>