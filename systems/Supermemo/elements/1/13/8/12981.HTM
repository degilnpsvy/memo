<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 17 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Collections</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>Scala has a rich collections library. You've already seen the most commonly used collection types in previous chapters&#8212;arrays, lists, sets, and maps&#8212;but there is more to the story. In this chapter, we'll start by giving an overview of how these types relate to each other in the collections inheritance hierarchy. We'll also briefly describe these and various other collection types that you may occasionally want to use, including discussing their tradeoffs of speed, space, and requirements on input data.<A id=i1853891989-1></A></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=17.1></A>17.1 Overview of the library<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#17.1">link</A>]</SPAN></H3>
<P>The Scala collections library involves many classes and traits. As a result, it can be challenging to get a big picture of the library by browsing the Scaladoc documentation. In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#fig:collections-hierarchy">Figure 17.1</A>, we show just the traits you need to know about to understand the big picture.</P>
<P>The main trait is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable</SPAN>,<A id=i328792320-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which is the supertrait of both mutable and immutable variations of sequences (<SPAN class=code>Seq</SPAN>s), sets, and maps. Sequences are ordered collections, such as arrays and lists. Sets contain at most one of each object, as determined by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. Maps contain a collection of keys mapped to values.</P>
<P><SPAN class=code>Iterable</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is so named because it represents collection objects that can produce an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN><A id=i1724581734-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>via a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elements</SPAN><A id=i1465360794-1></A>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;elements:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Iterator[A]</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in this example is the type parameter to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN>, which indicates the type of element objects contained in the collection. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returned by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elements</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is parameterized by the same type. An<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable[Int]</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elements</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, for example, will produce an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator[Int]</SPAN>. 
<P></P>
<P><SPAN class=code>Iterable</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>provides dozens of useful concrete methods, all implemented in terms of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returned by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elements</SPAN>, which is the sole abstract method in trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable</SPAN>. Among the methods defined in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are many higher-order methods, most of which you've already seen in previous chapters. Some examples are<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>find</SPAN>. These higher-order methods provide concise ways to iterate through collections for specific purposes, such as to transform each element and produce a new collection (the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>method) or find the first occurrence of an element given a predicate (the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>find</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method).</P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:collections-hierarchy></A>
<P><IMG alt="image images/collections.jpg" src="http://www.artima.com/pins1ed/images/collections.jpg"></P></DIV>
<H5>Figure 17.1 - Class hierarchy for Scala collections.<A id=i-1854640549-1></A><A id=i-1691199868-1></A><A id=i1751340543-1></A></H5>
<P>An<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has many of the same methods as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable</SPAN>, including the higher-order ones, but does not belong to the same hierarchy. As shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#fig:iterator-hierarchy">Figure 17.2</A>, trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>extends<SPAN class=code>AnyRef</SPAN>. The difference between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is that trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>represents types that can be iterated over (<I>i.e.</I>, collection types), whereas trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the mechanism used to perform an iteration. Although an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be iterated over multiple times, an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be used just once. Once you've iterated through a collection with an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN>, you can't reuse it. If you need to iterate through the same collection again, you'll need to call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elements</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on that collection to obtain a new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN>.</P>
<P>The many concrete methods provided by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are implemented in terms of two abstract methods,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>next</SPAN><A id=i1108447773-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hasNext</SPAN>:<A id=i390091735-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hasNext:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;next:&nbsp;A
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hasNext</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method indicates whether any elements remain in the iteration. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>next</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method returns the next element. 
<P></P>
<P>Although most of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>implementations you are likely to encounter will represent collections of a finite size,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can also be used to represent infinite collections. The<SPAN class=code>Iterator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returned from an infinite collection could, for example, calculate and return the next digit of &#960; each time its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>next</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method was invoked.</P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:iterator-hierarchy></A>
<P><IMG alt="image images/iterator.jpg" src="http://www.artima.com/pins1ed/images/iterator.jpg"></P></DIV>
<H5>Figure 17.2 - Class hierarchy for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN>.<A id=i128022489-1></A><A id=i1562158708-1></A></H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=17.2></A>17.2 Sequences<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#17.2">link</A>]</SPAN></H3>
<P><A name=sec:sequences></A></P>
<P>Sequences, classes that inherit from trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Seq</SPAN>,<A id=i-1529225491-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>let you work with groups of data lined up in order. Because the elements are ordered, you can ask for the first element, second element, 103rd element, and so on. In this section, we'll give you a quick tour of the most important sequences.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Lists</H4>
<P>Perhaps the most important sequence type to know about<SPAN class=Apple-converted-space>&nbsp;</SPAN>is class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>,<A id=i882498454-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>the immutable linked-list described in detail in the previous chapter. Lists support fast addition and removal of items to the beginning of the list, but they do not provide fast access to arbitrary indexes because the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A id=i-394736131-1></A>implementation must iterate through the list linearly.</P>
<P>This combination of features might sound odd, but they hit a sweet spot that works well for many algorithms. The fast addition and removal of initial elements means that pattern matching works well, as described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html">Chapter 15</A>. The immutability of lists helps you develop correct, efficient algorithms because you never need to make copies of a list. Here's a short example showing how to initialize a list and access its head and tail:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;colors&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"red"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"blue"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"green"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">colors:&nbsp;List[java.lang.String]&nbsp;=&nbsp;List(red,&nbsp;blue,&nbsp;green)</SPAN>
  <BR>  scala&gt;&nbsp;colors.head
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;java.lang.String&nbsp;=&nbsp;red</SPAN>
  <BR>  scala&gt;&nbsp;colors.tail
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;List[java.lang.String]&nbsp;=&nbsp;List(blue,&nbsp;green)</SPAN>
</PRE>For an introduction to lists see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#step8">Step 8</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html">Chapter 3</A>, and for the details on using lists, see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html">Chapter 16</A>. Lists will also be discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html">Chapter 22</A>, which provides insight into how lists are implemented in Scala. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Arrays</H4>
<P>Arrays allow you to hold a sequence of elements and efficiently access an element at an arbitrary position,<A id=i341425106-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>both to get or update the element, with a zero-based index.<A id=i-1409164998-2></A><A id=i916713681-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Here's how you create an array whose size you know, but for which you don't yet know the element values:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;fiveInts&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[Int]</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">fiveInts:&nbsp;Array[Int]&nbsp;=&nbsp;Array(0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0)</SPAN>
</PRE>Here's how you initialize an array when you do know the element values:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;fiveToOne&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">fiveToOne:&nbsp;Array[Int]&nbsp;=&nbsp;Array(5,&nbsp;4,&nbsp;3,&nbsp;2,&nbsp;1)</SPAN>
</PRE>As mentioned previously, arrays are accessed in Scala by placing an index in parentheses, not square brackets as in Java. Here's an example of both accessing and updating an array element:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;fiveInts(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;=&nbsp;fiveToOne(<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>)
  <BR>  scala&gt;&nbsp;fiveInts
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0)</SPAN>
</PRE>Scala arrays are represented in the same way as Java arrays. So, you can seamlessly use existing Java methods that return arrays.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#footnote17-1">[1]</A> 
<P></P>
<P>You have seen arrays in action many times in previous chapters. The basics are in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#step7">Step 7</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html">Chapter 3</A>. Several examples of iterating through the elements of an array with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN>expression are shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/builtin-control-structures.html#sec:for-expressions">Section 7.3</A>. Arrays also figure prominently in the two-dimensional layout library of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html">Chapter 10</A>.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">List buffers</H4>
<P>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>provides fast access to the head of the list, but not the end. Thus, when you need to build a list by appending to the end, you should consider building the list backwards by prepending elements to the front, then when you're done, calling<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverse</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to get the elements in the order you need.</P>
<P>Another alternative, which avoids the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverse</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation, is to use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN>.<A id=i-1815843466-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a mutable object (contained in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.mutable</SPAN>), which can<A id=i-737429794-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>help you build lists more efficiently when you need to append.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>provides constant time append and prepend operations. You append elements with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator,<A id=i714754650-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and prepend them with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+:</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator.<A id=i-42012992-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>When you're done building, you can obtain a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by invoking<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><A id=i-330065859-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN>. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable.ListBuffer
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.collection.mutable.ListBuffer</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;buf&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ListBuffer[Int]</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">buf:&nbsp;scala.collection.mutable.ListBuffer[Int]&nbsp;=&nbsp;ListBuffer()</SPAN>
  <BR>  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <BR>  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <BR>  scala&gt;&nbsp;buf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res11:&nbsp;scala.collection.mutable.ListBuffer[Int]</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;=&nbsp;ListBuffer(1,&nbsp;2)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>&nbsp;+:&nbsp;buf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res12:&nbsp;scala.collection.mutable.Buffer[Int]</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;=&nbsp;ListBuffer(3,&nbsp;1,&nbsp;2)</SPAN>
  <BR>  scala&gt;&nbsp;buf.toList
  <SPAN class=output style="COLOR: rgb(90,0,0)">res13:&nbsp;List[Int]&nbsp;=&nbsp;List(3,&nbsp;1,&nbsp;2)</SPAN>
</PRE>
<P></P>
<P>Another reason to use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is to prevent the potential for stack overflow.<A id=i-981382311-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>If you can build a list in the desired order by prepending, but the recursive algorithm that would be required is not tail recursive, you can use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loop and a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead. You'll see<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>being used in this way in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#sec:the-listbuffer-class">Section 22.2</A>.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Array buffers</H4>
<P>An<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is like an array, except that you can additionally add and remove elements from the beginning and end of the sequence<A id=i1906553817-1></A>. All<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operations are available, though they are a little slower due to a layer of wrapping in the implementation. The new addition and removal operations are constant time on average, but occasionally require linear time due to the implementation needing to allocate a new array to hold the buffer's contents.</P>
<P>To use an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayBuffer</SPAN>, you must first import it from the mutable collections package:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable.ArrayBuffer
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.collection.mutable.ArrayBuffer</SPAN>
</PRE>When you create an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayBuffer</SPAN>, you must specify a type parameter, but need not specify a length. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will adjust the allocated space automatically as needed:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;buf&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayBuffer[Int]</SPAN>()
  <SPAN class=output style="COLOR: rgb(90,0,0)">buf:&nbsp;scala.collection.mutable.ArrayBuffer[Int]&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;ArrayBuffer()</SPAN>
</PRE>You can append to an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:<A id=i-69907863-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">12</SPAN>
  <BR>  scala&gt;&nbsp;buf&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">15</SPAN>
  <BR>  scala&gt;&nbsp;buf
  <SPAN class=output style="COLOR: rgb(90,0,0)">res16:&nbsp;scala.collection.mutable.ArrayBuffer[Int]&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;ArrayBuffer(12,&nbsp;15)</SPAN>
</PRE>All the normal array methods are available. For example, you can ask an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>its length, or you can retrieve an element by its index:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;buf.length
  <SPAN class=output style="COLOR: rgb(90,0,0)">res17:&nbsp;Int&nbsp;=&nbsp;2</SPAN>
  <BR>  scala&gt;&nbsp;buf(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res18:&nbsp;Int&nbsp;=&nbsp;12</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Queues</H4>
<P>If you need a first-in-first-out sequence, you can use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><A id=i-705909367-1></A>. Scala's collection library provides both mutable and immutable variants of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN>. Here's how you can create an empty immutable queue:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.immutable.Queue
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.collection.immutable.Queue</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;empty&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[Int]</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">empty:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue()</SPAN>
</PRE>You can append an element to an immutable queue with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>enqueue</SPAN><A id=i432237508-1></A>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;has1&nbsp;=&nbsp;empty.enqueue(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">has1:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue(1)</SPAN>
</PRE>To append multiple elements to a queue, call enqueue with a collection as its argument:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;has123&nbsp;=&nbsp;has1.enqueue(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">has123:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue(1,2,3)</SPAN>
</PRE>To remove an element from the head of the queue, you use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>dequeue</SPAN><A id=i2031764716-1></A>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;(element,&nbsp;has23)&nbsp;=&nbsp;has123.dequeue
  <SPAN class=output style="COLOR: rgb(90,0,0)">element:&nbsp;Int&nbsp;=&nbsp;1</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">has23:&nbsp;scala.collection.immutable.Queue[Int]&nbsp;=&nbsp;Queue(2,3)</SPAN>
</PRE>On immutable queues, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>dequeue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method returns a pair (a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tuple2</SPAN>) consisting of the element at the head of the queue, and the rest of the queue with the head element removed. 
<P></P>
<P>You use a mutable queue similarly to how you use an immutable one, but instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>enqueue</SPAN>, you use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>++=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operators to append. Also, on a mutable queue, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>dequeue</SPAN>method will just remove the head element from the queue and return it. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable.Queue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.collection.mutable.Queue</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;queue&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[String]</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">queue:&nbsp;scala.collection.mutable.Queue[String]&nbsp;=&nbsp;Queue()</SPAN>
  <BR>  scala&gt;&nbsp;queue&nbsp;+=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a"</SPAN>
  <BR>  scala&gt;&nbsp;queue&nbsp;++=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"b"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"c"</SPAN>)
  <BR>  scala&gt;&nbsp;queue
  <SPAN class=output style="COLOR: rgb(90,0,0)">res21:&nbsp;scala.collection.mutable.Queue[String]&nbsp;=&nbsp;Queue(a,&nbsp;b,&nbsp;c)</SPAN>
  <BR>  scala&gt;&nbsp;queue.dequeue
  <SPAN class=output style="COLOR: rgb(90,0,0)">res22:&nbsp;String&nbsp;=&nbsp;a</SPAN>
  <BR>  scala&gt;&nbsp;queue
  <SPAN class=output style="COLOR: rgb(90,0,0)">res23:&nbsp;scala.collection.mutable.Queue[String]&nbsp;=&nbsp;Queue(b,&nbsp;c)</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Stacks</H4>
<P>If you need a last-in-first-out sequence, you can use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Stack</SPAN>,<A id=i-1444208192-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which also comes in both mutable and immutable versions in the Scala collections library. You push an element onto a stack with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>push</SPAN><A id=i710285503-1></A>, pop an element with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pop</SPAN><A id=i668387510-1></A>, and peek at the top of the stack without removing it with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>top</SPAN><A id=i949484730-1></A>. Here's an example of a mutable stack:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable.Stack
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.collection.mutable.Stack</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;stack&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Stack[Int]</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">stack:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack()</SPAN>
  <BR>  scala&gt;&nbsp;stack.push(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  <BR>  scala&gt;&nbsp;stack
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(1)</SPAN>
  <BR>  scala&gt;&nbsp;stack.push(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <BR>  scala&gt;&nbsp;stack
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(1,&nbsp;2)</SPAN>
  <BR>  scala&gt;&nbsp;stack.top
  <SPAN class=output style="COLOR: rgb(90,0,0)">res8:&nbsp;Int&nbsp;=&nbsp;2</SPAN>
  <BR>  scala&gt;&nbsp;stack
  <SPAN class=output style="COLOR: rgb(90,0,0)">res9:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(1,&nbsp;2)</SPAN>
  <BR>  scala&gt;&nbsp;stack.pop&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res10:&nbsp;Int&nbsp;=&nbsp;2</SPAN>
  <BR>  scala&gt;&nbsp;stack&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res11:&nbsp;scala.collection.mutable.Stack[Int]&nbsp;=&nbsp;Stack(1)</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Strings (via<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RichString</SPAN>)</H4>
<P>One other sequence to be aware of is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RichString</SPAN>, which is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Seq[Char]</SPAN>. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Predef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has an implicit conversion from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RichString</SPAN><A id=i875531717-1></A>, you can treat any string as a<SPAN class=code>Seq[Char]</SPAN>. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hasUpperCase(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&nbsp;s.exists(_.isUpperCase)
  <SPAN class=output style="COLOR: rgb(90,0,0)">hasUpperCase:&nbsp;(String)Boolean</SPAN>
  <BR>  scala&gt;&nbsp;hasUpperCase(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Robert&nbsp;Frost"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res14:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;hasUpperCase(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"e&nbsp;e&nbsp;cummings"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res15:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>In this example, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><A id=i1531663089-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is invoked on the string named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hasUpperCase</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method body. Because no method named "<SPAN class=code>exists</SPAN>" is declared in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>itself, the Scala compiler will implicitly convert<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RichString</SPAN>, which has the method. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method treats the string as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Seq[Char]</SPAN>, and will return true if any of the characters are upper case.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#footnote17-2">[2]</A> 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=17.3></A>17.3 Sets and maps<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#17.3">link</A>]</SPAN></H3>
<P>You have already seen the basics of sets and maps in previous chapters, starting<A id=i3526737-2></A><A id=i3344023-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#step10">Step 10</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html">Chapter 3</A>. In this section, we'll give more insight into their use and show you a few more examples.</P>
<P>As mentioned previously, the Scala collections library offers both mutable and immutable versions of sets and maps. The hierarchy for sets is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#fig:set-hierarchy">Figure 3.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#fig:set-hierarchy">here</A>, and the hierarchy for maps is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#fig:map-hierarchy">Figure 3.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#fig:map-hierarchy">here</A>. As these diagrams show, the simple names<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are used by three traits each, residing in different packages.</P>
<P>By default when you write "<SPAN class=code>Set</SPAN>" or "<SPAN class=code>Map</SPAN>" you get an immutable object. If you want the mutable variant, you need to do an explicit import. Scala gives you easier access to the immutable variants, as a gentle encouragement to prefer them over their mutable counterparts. The easy access is provided via the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Predef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object, which is implicitly imported into every Scala source file.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#lst:predef-set-map">Listing 17.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows the relevant definitions.<A name=lst:predef-set-map></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Predef</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set[T]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">scala.collection.immutable.Set[T]</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map[K, V]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">scala.collection.immutable.Map[K, V]</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">scala.collection.immutable.Set</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">scala.collection.immutable.Map</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;...</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 17.1 - Default map and set definitions in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Predef</SPAN>.</H5>
<P>The "<SPAN class=code>type</SPAN>" keyword<A id=i-1569140754-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Predef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to define<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as aliases for the longer fully qualified names of the immutable set and map traits.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#footnote17-3">[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are initialized to refer to the singleton objects for the immutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>. So<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Predef.Map</SPAN>, which is defined to be the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.immutable.Map</SPAN>. This holds both for the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object.</P>
<P>If you want to use both mutable and immutable sets or maps in the same source file, one approach is to import the name of the package that contains the mutable variants:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.collection.mutable</SPAN>
</PRE>You can continue to refer to the immutable set as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN>, as before, but can now refer to the mutable set as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mutable.Set</SPAN>. Here's an example:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;mutaSet&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">mutable.Set</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">mutaSet:&nbsp;scala.collection.mutable.Set[Int]&nbsp;=&nbsp;Set(3,&nbsp;1,&nbsp;2)</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Using sets</H4>
<P>The key characteristic of sets is that they will ensure that at most one of each object, as determined by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><A id=i1401108821-1></A>, will be contained in the set at any one time. As an example, we'll use a set to count the number of different words in a string.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>split</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can separate a string into words<A id=i-456038910-1></A>, if you specify spaces and punctuation as word separators. The regular expression "<SPAN class=code>[</SPAN>&nbsp;<SPAN class=code>!,.]+</SPAN>" will suffice: it indicates the string should be split at each place that one or more space and/or punctuation characters exist:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;text&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"See&nbsp;Spot&nbsp;run.&nbsp;Run,&nbsp;Spot.&nbsp;Run!"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">text:&nbsp;java.lang.String&nbsp;=&nbsp;See&nbsp;Spot&nbsp;run.&nbsp;Run,&nbsp;Spot.&nbsp;Run!</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;wordsArray&nbsp;=&nbsp;text.split(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"[&nbsp;!,.]+"</SPAN>)&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">wordsArray:&nbsp;Array[java.lang.String]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;Array(See,&nbsp;Spot,&nbsp;run,&nbsp;Run,&nbsp;Spot,&nbsp;Run)</SPAN>
</PRE>To count the distinct words, you can convert them to the same case and then add them to a set. Because sets exclude duplicates, each distinct word will appear exactly one time in the set. First, you can create an empty set using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>empty</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method provided on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>companion objects:<A id=i1582603163-1></A><A id=i1868251958-2></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;words&nbsp;=&nbsp;mutable.Set.empty[<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>]
  <SPAN class=output style="COLOR: rgb(90,0,0)">words:&nbsp;scala.collection.mutable.Set[String]&nbsp;=&nbsp;Set()</SPAN>
</PRE>Then, just iterate through the words with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression, convert each word to lower case, and add it to the mutable set with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(word&nbsp;&lt;-&nbsp;wordsArray)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;words&nbsp;+=&nbsp;word.toLowerCase
  <BR>  scala&gt;&nbsp;words
  <SPAN class=output style="COLOR: rgb(90,0,0)">res25:&nbsp;scala.collection.mutable.Set[String]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Set(spot,&nbsp;run,&nbsp;see)</SPAN>
</PRE>Thus, the text contained exactly three distinct words: spot, run, and see. The most commonly used methods on both mutable and immutable sets are shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#tab:set-operations">Table 17.1</A>. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Using maps</H4>
<P>Maps let you associate a value with each element of the collection. Using a map looks similar to using an array, except that instead of indexing with integers counting from 0, you can use any kind of key<A id=i3344023-3></A>. If you import the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.mutable</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>package, you can create an empty mutable map like this:<A id=i-1094653291-1></A><A id=i-809004496-2></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;map&nbsp;=&nbsp;mutable.Map.empty[<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>]
  <SPAN class=output style="COLOR: rgb(90,0,0)">map:&nbsp;scala.collection.mutable.Map[String,Int]&nbsp;=&nbsp;Map()</SPAN>
</PRE>
<P></P>
<P><A name=tab:set-operations></A></P>
<H5>Common operations for sets<A id=i51742212-1></A></H5>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline bottomline" style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TH><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">What it is</SPAN></SPAN></TH>
<TH>
<DIV align=center><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">What it does</SPAN></SPAN></DIV></TH></TR>
<TR class="">
<TD><SPAN class=code>val</SPAN>&nbsp;<SPAN class=code>nums</SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code>Set(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3)</SPAN></TD>
<TD>Creates an immutable set (<SPAN class=code>nums.toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3)</SPAN>)</TD></TR>
<TR class="">
<TD><SPAN class=code>nums</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>5</SPAN></TD>
<TD>Adds an element (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3,</SPAN>&nbsp;<SPAN class=code>5)</SPAN>)<A id=i811921304-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums</SPAN>&nbsp;<SPAN class=code>-</SPAN>&nbsp;<SPAN class=code>3</SPAN></TD>
<TD>Removes an element (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set(1,</SPAN>&nbsp;<SPAN class=code>2)</SPAN>)<A id=i1994870477-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums</SPAN>&nbsp;<SPAN class=code>++</SPAN>&nbsp;<SPAN class=code>List(5,</SPAN>&nbsp;<SPAN class=code>6)</SPAN></TD>
<TD>Adds multiple elements (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3,</SPAN>&nbsp;<SPAN class=code>5,</SPAN>&nbsp;<SPAN class=code>6)</SPAN>)<A id=i527242564-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums</SPAN>&nbsp;<SPAN class=code>--</SPAN>&nbsp;<SPAN class=code>List(1,</SPAN>&nbsp;<SPAN class=code>2)</SPAN></TD>
<TD>Removes multiple elements (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set(3)</SPAN>)<A id=i649808695-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums</SPAN>&nbsp;<SPAN class=code>**</SPAN>&nbsp;<SPAN class=code>Set(1,</SPAN>&nbsp;<SPAN class=code>3,</SPAN>&nbsp;<SPAN class=code>5,</SPAN>&nbsp;<SPAN class=code>7)</SPAN></TD>
<TD>Takes the intersection of two sets (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set(1,</SPAN>&nbsp;<SPAN class=code>3)</SPAN>)<A id=i1740588383-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums.size</SPAN></TD>
<TD>Returns the size of the set (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>3</SPAN>)<A id=i-217240950-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums.contains(3)</SPAN></TD>
<TD>Checks for inclusion (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>)<A id=i1685795628-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>scala.collection.mutable</SPAN></TD>
<TD>Makes the mutable collections easy to access</TD></TR>
<TR class="">
<TD><SPAN class=code>val</SPAN>&nbsp;<SPAN class=code>words</SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;<SPAN class=code></SPAN><BR><SPAN class=code>mutable.Set.empty[String]</SPAN></TD>
<TD>Creates an empty, mutable set (<SPAN class=code>words.toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set()</SPAN>)<A id=i1582603163-2></A></TD></TR>
<TR class="">
<TD><SPAN class=code>words</SPAN>&nbsp;<SPAN class=code>+=</SPAN>&nbsp;<SPAN class=code>"the"</SPAN></TD>
<TD>Adds an element (<SPAN class=code>words.toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set(the)</SPAN>)<A id=i1314992430-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>words</SPAN>&nbsp;<SPAN class=code>-=</SPAN>&nbsp;<SPAN class=code>"the"</SPAN></TD>
<TD>Removes an element, if it exists (<SPAN class=code>words.toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set()</SPAN>)<A id=i1816671796-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>words</SPAN>&nbsp;<SPAN class=code>++=</SPAN>&nbsp;<SPAN class=code>List("do",</SPAN>&nbsp;<SPAN class=code>"re",</SPAN>&nbsp;<SPAN class=code>"mi")</SPAN></TD>
<TD>Adds multiple elements (<SPAN class=code>words.toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set(do,</SPAN>&nbsp;<SPAN class=code>re,</SPAN>&nbsp;<SPAN class=code>mi)</SPAN>)<A id=i-1693046362-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>words</SPAN>&nbsp;<SPAN class=code>--=</SPAN>&nbsp;<SPAN class=code>List("do",</SPAN>&nbsp;<SPAN class=code>"re")</SPAN></TD>
<TD>Removes multiple elements (<SPAN class=code>words.toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set(mi)</SPAN>)<A id=i20218631-1></A></TD></TR>
<TR class=bottomline style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TD style="BORDER-BOTTOM: black thin solid"><SPAN class=code>words.clear</SPAN></TD>
<TD style="BORDER-BOTTOM: black thin solid">Removes all elements (<SPAN class=code>words.toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set()</SPAN>)<A id=i1343184347-1></A></TD></TR></TBODY></TABLE>
<P>Note that when you create a map, you must specify two types. The first type is for the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">keys</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the map, the second for the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">values</EM>. In this case, the keys are strings and the values are integers.</P>
<P>Setting entries in a map looks similar to setting entries in an array:<A id=i648989597-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;map(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>)&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  <BR>  scala&gt;&nbsp;map(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"there"</SPAN>)&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  <BR>  scala&gt;&nbsp;map
  <SPAN class=output style="COLOR: rgb(90,0,0)">res28:&nbsp;scala.collection.mutable.Map[String,Int]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Map(hello&nbsp;-&gt;&nbsp;1,&nbsp;there&nbsp;-&gt;&nbsp;2)</SPAN>
</PRE>Likewise, reading a map is similar to reading an array:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;map(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res29:&nbsp;Int&nbsp;=&nbsp;1</SPAN>
</PRE>
<P></P>
<P>Putting it all together, here is a method that counts the number of times each word occurs in a string:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;countWords(text:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;counts&nbsp;=&nbsp;mutable.Map.empty[<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>]
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(rawWord&nbsp;&lt;-&nbsp;text.split(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"[&nbsp;,!.]+"</SPAN>))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;word&nbsp;=&nbsp;rawWord.toLowerCase
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;oldCount&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(counts.contains(word))&nbsp;counts(word)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counts&nbsp;+=&nbsp;(word&nbsp;-&gt;&nbsp;(oldCount&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counts
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">countWords:&nbsp;(String)scala.collection.mutable.Map[String,Int]</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)"></SPAN>
  <BR>  scala&gt;&nbsp;countWords(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"See&nbsp;Spot&nbsp;run!&nbsp;Run,&nbsp;Spot.&nbsp;Run!"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res30:&nbsp;scala.collection.mutable.Map[String,Int]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Map(see&nbsp;-&gt;&nbsp;1,&nbsp;run&nbsp;-&gt;&nbsp;3,&nbsp;spot&nbsp;-&gt;&nbsp;2)</SPAN>
</PRE>Given these counts, you can see that this text talks a lot about running, but not so much about seeing. 
<P></P>
<P>The way this code works is that a mutable map, named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>counts</SPAN>, maps each word to the number of times it occurs in the text. For each word in the text, the word's old count is looked up, that count is incremented by one, and the new count is saved back into<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>counts</SPAN>. Note the use of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contains</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to check whether a word has been seen yet or not. If<SPAN class=code>counts.contains(word)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not true, then the word has not yet been seen and zero is used for the count.</P>
<P>Many of the most commonly used methods on both mutable and immutable maps are shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#tab:map-operations">Table 17.2</A>.</P>
<P><A name=tab:map-operations></A></P>
<H5>Common operations for maps<A id=i-498146178-1></A></H5>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline bottomline" style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TH><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">What it is</SPAN></SPAN></TH>
<TH>
<DIV align=center><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">What it does</SPAN></SPAN></DIV></TH></TR>
<TR class="">
<TD><SPAN class=code>val</SPAN>&nbsp;<SPAN class=code>nums</SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code>Map("i"</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>1,</SPAN>&nbsp;<SPAN class=code>"ii"</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>2)</SPAN></TD>
<TD>Creates an immutable map (<SPAN class=code>nums.toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map(i</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>1,</SPAN>&nbsp;<SPAN class=code>ii</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>2)</SPAN>)</TD></TR>
<TR class="">
<TD><SPAN class=code>nums</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"vi"</SPAN></SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">6</SPAN>)</SPAN></TD>
<TD>Adds an entry (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map(i</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>1,</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ii</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>vi</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>6)</SPAN>)<A id=i-1879414184-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums</SPAN>&nbsp;<SPAN class=code>-</SPAN>&nbsp;<SPAN class=code><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"ii"</SPAN></SPAN></TD>
<TD>Removes an entry (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map(i</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>1)</SPAN>)<A id=i-696465011-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums</SPAN>&nbsp;<SPAN class=code>++</SPAN>&nbsp;<SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"iii"</SPAN></SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,</SPAN>&nbsp;<SPAN class=code><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"v"</SPAN></SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)</SPAN></TD>
<TD>Adds multiple entries (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map(i</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>1,</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ii</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>iii</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>3,</SPAN>&nbsp;<SPAN class=code>v</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>5)</SPAN>)<A id=i2130874372-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums</SPAN>&nbsp;<SPAN class=code>--</SPAN>&nbsp;<SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"i"</SPAN>,</SPAN>&nbsp;<SPAN class=code><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"ii"</SPAN>)</SPAN></TD>
<TD>Removes multiple entries (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map()</SPAN>)<A id=i-2041526793-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums.size</SPAN></TD>
<TD>Returns the size of the map (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>)</TD></TR>
<TR class="">
<TD><SPAN class=code>nums.contains(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"ii"</SPAN>)</SPAN></TD>
<TD>Checks for inclusion (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>)<A id=i-626462467-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"ii"</SPAN>)</SPAN></TD>
<TD>Retrieves the value at a specified key (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>)<A id=i648989597-2></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums.keys</SPAN></TD>
<TD>Returns the keys (returns an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>over the strings<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"i"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"ii"</SPAN>)<A id=i1213467709-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums.keySet</SPAN></TD>
<TD>Returns the keys as a set (returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set(i,</SPAN>&nbsp;<SPAN class=code>ii)</SPAN>)<A id=i891405326-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums.values</SPAN></TD>
<TD>Returns the values (returns an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>over the integers<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>)<A id=i-546077233-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>nums.isEmpty</SPAN></TD>
<TD>Indicates whether the map is empty (returns false)<A id=i-576053426-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN></SPAN>&nbsp;<SPAN class=code>scala.collection.mutable</SPAN></TD>
<TD>Makes the mutable collections easy to access</TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN></SPAN>&nbsp;<SPAN class=code>words</SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><BR><SPAN class=code>mutable.Map.empty[<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,</SPAN>&nbsp;<SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>]</SPAN></TD>
<TD>Creates an empty, mutable map<A id=i-1094653291-2></A></TD></TR>
<TR class="">
<TD><SPAN class=code>words</SPAN>&nbsp;<SPAN class=code>+=</SPAN>&nbsp;<SPAN class=code>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"one"</SPAN></SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)</SPAN></TD>
<TD>Adds a map entry from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"one"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<SPAN class=code>words.toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map(one</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>1)</SPAN>)<A id=i1314809716-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>words</SPAN>&nbsp;<SPAN class=code>-=</SPAN>&nbsp;<SPAN class=code><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"one"</SPAN></SPAN></TD>
<TD>Removes a map entry, if it exists (<SPAN class=code>words.toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map()</SPAN>)<A id=i1816489082-1></A></TD></TR>
<TR class="">
<TD><SPAN class=code>words</SPAN>&nbsp;<SPAN class=code>++=</SPAN>&nbsp;<SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"one"</SPAN></SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,</SPAN>&nbsp;<SPAN class=code></SPAN><BR><SPAN class=code><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"two"</SPAN></SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,</SPAN>&nbsp;<SPAN class=code><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"three"</SPAN></SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code><SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)</SPAN></TD>
<TD>Adds multiple map entries (<SPAN class=code>words.toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map(one</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>1,</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>two</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>three</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>3)</SPAN>)<A id=i-1693229076-1></A></TD></TR>
<TR class=bottomline style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TD style="BORDER-BOTTOM: black thin solid"><SPAN class=code>words</SPAN>&nbsp;<SPAN class=code>--=</SPAN>&nbsp;<SPAN class=code><SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"one"</SPAN>,</SPAN>&nbsp;<SPAN class=code><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"two"</SPAN>)</SPAN></TD>
<TD style="BORDER-BOTTOM: black thin solid">Removes multiple objects (<SPAN class=code>words.toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map(three</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>3)</SPAN>)<A id=i20035917-1></A></TD></TR></TBODY></TABLE>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Default sets and maps</H4>
<P>For most uses, the implementations of mutable and immutable sets and maps provided by<A id=i1372944617-1></A><A id=i1372761903-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set()</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.mutable.Map()</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>etc.</I>, factories will likely be sufficient. The implementations provided by these factories use a fast lookup algorithm, usually involving a hashtable, so they can quickly decide whether or not an object is in the collection.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.mutable.Set()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>factory method, for example, returns a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.mutable.HashSet</SPAN>, which uses a hashtable internally. Similarly, the<SPAN class=code>scala.collection.mutable.Map()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>factory returns a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.mutable.HashMap</SPAN>.</P>
<P>The story for immutable sets and maps is a bit more involved. The class returned by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.immutable.Set()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>factory method, for example, depends on how many elements you pass to it, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#tab:default-sets">Table 17.3</A>. For sets with fewer than five elements, a special class devoted exclusively to sets of each particular size is used, to maximize performance. Once you request a set that has five or more elements in it, however, the factory method will return immutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashSet</SPAN>.</P>
<P><A name=tab:default-sets></A></P>
<H5>Table 17.3 - Default immutable set implementations</H5>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Number of elements</SPAN></SPAN></TD>
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Implementation</SPAN></SPAN></TD></TR>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid">0</TD>
<TD style="BORDER-TOP: black thin solid"><SPAN class=code>scala.collection.immutable.EmptySet</SPAN></TD></TR>
<TR class="">
<TD>1</TD>
<TD><SPAN class=code>scala.collection.immutable.Set1</SPAN></TD></TR>
<TR class="">
<TD>2</TD>
<TD><SPAN class=code>scala.collection.immutable.Set2</SPAN></TD></TR>
<TR class="">
<TD>3</TD>
<TD><SPAN class=code>scala.collection.immutable.Set3</SPAN></TD></TR>
<TR class="">
<TD>4</TD>
<TD><SPAN class=code>scala.collection.immutable.Set4</SPAN></TD></TR>
<TR class="">
<TD>5 or more</TD>
<TD><SPAN class=code>scala.collection.immutable.HashSet</SPAN></TD></TR></TBODY></TABLE></DIV>
<P>Similarly, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.immutable.Map()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>factory method will return a different class depending on how many key-value pairs you pass to it, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#tab:default-maps">Table 17.4</A>. As with sets, for immutable maps with fewer than five elements, a special class devoted exclusively to maps of each particular size is used, to maximize performance. Once a map has five or more key-value pairs in it, however, an immutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used.</P>
<P><A name=tab:default-maps></A></P>
<H5>Table 17.4 - Default immutable map implementations</H5>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Number of elements</SPAN></SPAN></TD>
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Implementation</SPAN></SPAN></TD></TR>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid">0</TD>
<TD style="BORDER-TOP: black thin solid"><SPAN class=code>scala.collection.immutable.EmptyMap</SPAN></TD></TR>
<TR class="">
<TD>1</TD>
<TD><SPAN class=code>scala.collection.immutable.Map1</SPAN></TD></TR>
<TR class="">
<TD>2</TD>
<TD><SPAN class=code>scala.collection.immutable.Map2</SPAN></TD></TR>
<TR class="">
<TD>3</TD>
<TD><SPAN class=code>scala.collection.immutable.Map3</SPAN></TD></TR>
<TR class="">
<TD>4</TD>
<TD><SPAN class=code>scala.collection.immutable.Map4</SPAN></TD></TR>
<TR class="">
<TD>5 or more</TD>
<TD><SPAN class=code>scala.collection.immutable.HashMap</SPAN></TD></TR></TBODY></TABLE></DIV>
<P>The default immutable implementation classes shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#tab:default-sets">Tables 17.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#tab:default-maps">and 17.4</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>work together to give you maximum performance. For example, if you add an element to an<SPAN class=code>EmptySet</SPAN>, it will return a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set1</SPAN>. If you add an element to that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set1</SPAN>, it will return a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set2</SPAN>. If you then remove an element from the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set2</SPAN>, you'll get another<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set1</SPAN>.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Sorted sets and maps</H4>
<P>On occasion you may need a set or map whose iterator returns elements in a particular order. For this purpose, the Scala collections library provides traits<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SortedSet</SPAN><A id=i849148531-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=code>SortedMap</SPAN>.<A id=i1172619245-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>These traits are implemented by classes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeSet</SPAN><A id=i300430876-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeMap</SPAN>,<A id=i623901590-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which use a red-black tree to keep elements (in the case of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeSet</SPAN>) or keys (in the case of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeMap</SPAN>) in order. The order is determined by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><A id=i2068605051-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait, which the element type of the set, or key type of the map, must either mix in or be implicitly convertable to. These classes only come in immutable variants. Here are some<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeSet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>examples:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.immutable.TreeSet
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.collection.immutable.TreeSet</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;ts&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">TreeSet</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">9</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">8</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">7</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">6</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">ts:&nbsp;scala.collection.immutable.SortedSet[Int]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Set(0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;cs&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">TreeSet</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'f'</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'u'</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'n'</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">cs:&nbsp;scala.collection.immutable.SortedSet[Char]&nbsp;=&nbsp;Set(f,&nbsp;n,&nbsp;u)</SPAN>
</PRE>And here are a few<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>examples:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.immutable.TreeMap
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.collection.immutable.TreeMap</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;tm&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">TreeMap</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'x'</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'x'</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'x'</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">tm:&nbsp;scala.collection.immutable.SortedMap[Int,Char]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Map(1&nbsp;-&gt;&nbsp;x,&nbsp;3&nbsp;-&gt;&nbsp;x,&nbsp;4&nbsp;-&gt;&nbsp;x)</SPAN>
  <BR>  scala&gt;&nbsp;tm&nbsp;+=&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'x'</SPAN>)
  <BR>  scala&gt;&nbsp;tm
  <SPAN class=output style="COLOR: rgb(90,0,0)">res38:&nbsp;scala.collection.immutable.SortedMap[Int,Char]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Map(1&nbsp;-&gt;&nbsp;x,&nbsp;2&nbsp;-&gt;&nbsp;x,&nbsp;3&nbsp;-&gt;&nbsp;x,&nbsp;4&nbsp;-&gt;&nbsp;x)</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Synchronized sets and maps</H4>
<P>In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#sec:a-language-that-grows-on-you">Section 1.1</A>, we mentioned that if you needed a thread-safe map,<A id=i181041576-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>you could mix the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SynchronizedMap</SPAN><A id=i809670518-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait into whatever particular map implementation you desired. For example, you could mix<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SynchronizedMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashMap</SPAN>, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#lst:synchronized-map">Listing 17.2</A>. This example begins with an import of two traits,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SynchronizedMap</SPAN>, and one class,<SPAN class=code>HashMap</SPAN>, from package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.mutable</SPAN>. The rest of the example is the definition of singleton object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MapMaker</SPAN>, which declares one method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>makeMap</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>makeMap</SPAN>method declares its result type to be a mutable map of string keys to string values.</P>
<P><A name=lst:synchronized-map></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable.{<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SynchronizedMap</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HashMap</SPAN>}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">MapMaker</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;makeMap:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map[String, String]</SPAN>&nbsp;=&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HashMap[String, String]</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SynchronizedMap[String, String]</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;default(key:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Why&nbsp;do&nbsp;you&nbsp;want&nbsp;to&nbsp;know?"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 17.2 - Mixing in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SynchronizedMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait.</H5>
<P>The first statement inside the body of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>makeMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>constructs a new mutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that mixes in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SynchronizedMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HashMap[String, String]</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>
  &nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SynchronizedMap[String, String]</SPAN>
</PRE>Given this code, the Scala compiler will generate a synthetic subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that mixes in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SynchronizedMap</SPAN>, and create (and return) an instance of it. This synthetic class will also override a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>default</SPAN>, because of this code:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;default(key:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=
  &nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Why&nbsp;do&nbsp;you&nbsp;want&nbsp;to&nbsp;know?"</SPAN>
</PRE>If you ask a map to give you the value for a particular key, but it doesn't have a mapping for that key, you'll by default get a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>NoSuchElementException</SPAN>. If you define a new map class and override the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>default</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, however, your new map will return the value returned by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>default</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>when queried with a non-existent key. Thus, the synthetic<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>subclass generated by the compiler from the code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#lst:synchronized-map">Listing 17.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>will return the somewhat curt response string,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Why</SPAN>&nbsp;<SPAN class=code>do</SPAN>&nbsp;<SPAN class=code>you</SPAN>&nbsp;<SPAN class=code>want</SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code>know?"</SPAN>, when queried with a non-existent key. 
<P></P>
<P>Because the mutable map returned by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>makeMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method mixes in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SynchronizedMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait, it can be used by multiple threads at once. Each access to the map will be synchronized. Here's an example of the map being used, by one thread, in the interpreter:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;capital&nbsp;=&nbsp;MapMaker.makeMap&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">capital:&nbsp;scala.collection.mutable.Map[String,String]&nbsp;=&nbsp;Map()</SPAN>
  <BR>  scala&gt;&nbsp;capital&nbsp;++&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"US"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Washington"</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Paris"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"France"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Japan"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Tokyo"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;scala.collection.mutable.Map[String,String]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Map(Paris&nbsp;-&gt;&nbsp;France,&nbsp;US&nbsp;-&gt;&nbsp;Washington,&nbsp;Japan&nbsp;-&gt;&nbsp;Tokyo)</SPAN>
  <BR>  scala&gt;&nbsp;capital(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Japan"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;String&nbsp;=&nbsp;Tokyo</SPAN>
  <BR>  scala&gt;&nbsp;capital(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"New&nbsp;Zealand"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;String&nbsp;=&nbsp;Why&nbsp;do&nbsp;you&nbsp;want&nbsp;to&nbsp;know?</SPAN>
  <BR>  scala&gt;&nbsp;capital&nbsp;+=&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"New&nbsp;Zealand"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Wellington"</SPAN>)
  <BR>  scala&gt;&nbsp;capital(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"New&nbsp;Zealand"</SPAN>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;String&nbsp;=&nbsp;Wellington</SPAN>
</PRE>
<P></P>
<P>You can create synchronized sets similarly to the way you create synchronized maps. For example, you could create a synchronized<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashSet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by mixing in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SynchronizedSet</SPAN><A id=i486199804-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;synchroSet&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">mutable.HashSet[Int]</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">mutable.SynchronizedSet[Int]</SPAN>
</PRE>
<P></P>
<P>Finally, if you are thinking of using synchronized collections, you may also wish to consider the concurrent collections of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.util.concurrent</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead. Alternatively, you may prefer to use unsynchronized collections with Scala actors<A id=i-1422944994-2></A>. Actors will be covered in detail in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html">Chapter 30</A>.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=17.4></A>17.4 Selecting mutable versus immutable collections<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#17.4">link</A>]</SPAN></H3>
<P>For some problems, mutable collections work better, and for others, immutable collections work better.<A id=i1445844177-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>When in doubt, it is better to start with an immutable collection and change it later if you need to, because immutable collections can be easier to reason about than mutable ones.</P>
<P>It can also sometimes be worthwhile to go the opposite way. If you find some code that uses mutable collections becoming complicated and hard to reason about, consider whether it would help to change some of the collections to immutable alternatives<A id=i650543080-1></A>. In particular, if you find yourself worrying about making copies of mutable collections in just the right places, or thinking a lot about who "owns" or "contains" a mutable collection, consider switching some of the collections to their immutable counterparts.</P>
<P>Besides being potentially easier to reason about, immutable collections can usually be stored more compactly than mutable ones if the number of elements stored in the collection is small. For instance an empty mutable map in its default representation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes up about 80 bytes and about 16 more are added for each entry that's added to it. An empty immutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a single object that's shared between all references, so referring to it essentially costs just a single pointer field. What's more, the Scala collections library currently stores immutable maps and sets with up to four entries in a single object, which typically takes up between 16 and 40 bytes, depending on the number of entries stored in the collection.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#footnote17-4">[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>So for small maps and sets, the immutable versions are much more compact than the mutable ones. Given that many collections are small, switching them to be immutable can give important space savings and performance advantages.</P>
<P>To make it easier to switch from immutable to mutable collections, and vice versa, Scala provides some syntactic sugar. Even though immutable sets and maps do not support a true<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, Scala gives a useful alternate interpretation to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN>. Whenever you write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>+=</SPAN>&nbsp;<SPAN class=code>b</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not support a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN>, Scala will try interpreting it as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>b</SPAN>. For example, immutable sets do not support a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator:<A id=i1301665902-2></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;people&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Nancy"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Jane"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">people:&nbsp;scala.collection.immutable.Set[java.lang.String]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Set(Nancy,&nbsp;Jane)</SPAN>
  <BR>  scala&gt;&nbsp;people&nbsp;+=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Bob"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:6:&nbsp;error:&nbsp;reassignment&nbsp;to&nbsp;val</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;people&nbsp;+=&nbsp;"Bob"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>If you declare<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>people</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>, instead of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>, however, then the collection can be "updated" with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation, even though it is immutable. First, a new collection will be created, and then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>people</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be reassigned to refer to the new collection:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;people&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Nancy"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Jane"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">people:&nbsp;scala.collection.immutable.Set[java.lang.String]&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Set(Nancy,&nbsp;Jane)</SPAN>
  <BR>  scala&gt;&nbsp;people&nbsp;+=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Bob"</SPAN>
  <BR>  scala&gt;&nbsp;people
  <SPAN class=output style="COLOR: rgb(90,0,0)">res42:&nbsp;scala.collection.immutable.Set[java.lang.String]&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Set(Nancy,&nbsp;Jane,&nbsp;Bob)</SPAN>
</PRE>After this series of statements, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>people</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable refers to a new immutable set, which contains the added string,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Bob"</SPAN>. The same idea applies to any method ending in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=</SPAN>, not just the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. Here's the same syntax used with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator, which removes an element from a set, and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>++=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator, which adds a collection of elements to a set:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;people&nbsp;-=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Jane"</SPAN>
  <BR>  scala&gt;&nbsp;people&nbsp;++=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Tom"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Harry"</SPAN>)
  <BR>  scala&gt;&nbsp;people
  <SPAN class=output style="COLOR: rgb(90,0,0)">res45:&nbsp;scala.collection.immutable.Set[java.lang.String]&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Set(Nancy,&nbsp;Bob,&nbsp;Tom,&nbsp;Harry)</SPAN>
</PRE>To see how this is useful, consider again the following<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>example from<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#sec:a-language-that-grows-on-you">Section 1.1</A>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;capital&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"US"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Washington"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"France"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Paris"</SPAN>)
  capital&nbsp;+=&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Japan"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Tokyo"</SPAN>)
  println(capital(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"France"</SPAN>))&nbsp;
</PRE>This code uses immutable collections. If you want to try using mutable collections instead, all that is necessary is to import the mutable version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>, thus overriding the default import of the immutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable.Map&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;only&nbsp;change&nbsp;needed!</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;capital&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"US"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Washington"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"France"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Paris"</SPAN>)
  capital&nbsp;+=&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Japan"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Tokyo"</SPAN>)
  println(capital(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"France"</SPAN>))&nbsp;
</PRE>Not all examples are quite that easy to convert, but the special treatment of methods ending in an equals sign will often reduce the amount of code that needs changing. 
<P></P>
<P>By the way, this syntactic treatment works on any kind of value, not just collections. For example, here it is being used on floating-point numbers:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;roughlyPi&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3.0</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">roughlyPi:&nbsp;Double&nbsp;=&nbsp;3.0</SPAN>
  <BR>  scala&gt;&nbsp;roughlyPi&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0.1</SPAN>
  <BR>  scala&gt;&nbsp;roughlyPi&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0.04</SPAN>
  <BR>  scala&gt;&nbsp;roughlyPi
  <SPAN class=output style="COLOR: rgb(90,0,0)">res48:&nbsp;Double&nbsp;=&nbsp;3.14</SPAN>
</PRE>The effect of this expansion is similar to Java's assignment operators<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+=</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-=</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*=</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>etc.</I>, but it is more general because every operator ending in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be converted. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=17.5></A>17.5 Initializing collections<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#17.5">link</A>]</SPAN></H3>
<P>As you've seen previously, the most common way to create and initialize a collection is to pass the initial elements to a factory method on the companion object of your chosen collection. You just place the elements in parentheses after the companion object name, and the Scala compiler will transform that to an invocation of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method on that companion object:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'a'</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'b'</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'c'</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;scala.collection.immutable.Set[Char]&nbsp;=&nbsp;Set(a,&nbsp;b,&nbsp;c)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.collection.mutable</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">mutable.Map</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hi"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"there"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;scala.collection.mutable.Map[java.lang.String,Int]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Map(hi&nbsp;-&gt;&nbsp;2,&nbsp;there&nbsp;-&gt;&nbsp;5)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1.0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2.0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3.0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;Array[Double]&nbsp;=&nbsp;Array(1.0,&nbsp;2.0,&nbsp;3.0)</SPAN>
</PRE>
<P></P>
<P>Although most often you can let the Scala compiler infer the element type of a collection from the elements passed to its factory method, sometimes you may want to create a collection but specify a different type from the one the compiler would choose. This is especially an issue with mutable collections. Here's an example:<A id=i-677980410-2></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.collection.mutable</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;stuff&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">mutable.Set</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">42</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">stuff:&nbsp;scala.collection.mutable.Set[Int]&nbsp;=&nbsp;Set(42)</SPAN>
  <BR>  scala&gt;&nbsp;stuff&nbsp;+=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abracadabra"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:7:&nbsp;error:&nbsp;type&nbsp;mismatch;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;java.lang.String("abracadabra")</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;required:&nbsp;Int</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stuff&nbsp;+=&nbsp;"abracadabra"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>The problem here is that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stuff</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was given an element type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>. If you want it to have an element type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>, you need to say so explicitly by putting the element type in square brackets, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;stuff&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">mutable.Set[Any]</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">42</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">stuff:&nbsp;scala.collection.mutable.Set[Any]&nbsp;=&nbsp;Set(42)</SPAN>
</PRE>
<P></P>
<P>Another special situation is if you want to initialize a collection with another collection. For example, imagine you have a list, but you want a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeSet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>containing the elements in the list. Here's the list:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;colors&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"blue"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"yellow"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"red"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"green"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">colors:&nbsp;List[java.lang.String]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;List(blue,&nbsp;yellow,&nbsp;red,&nbsp;green)</SPAN>
</PRE>You cannot pass the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>colors</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list to the factory method for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeSet</SPAN>:<A id=i-1802169132-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.immutable.TreeSet
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.collection.immutable.TreeSet</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;treeSet&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">TreeSet</SPAN>(colors)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:6:&nbsp;error:&nbsp;no&nbsp;implicit&nbsp;argument&nbsp;matching</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;parameter&nbsp;type&nbsp;(List[java.lang.String])&nbsp;=&gt;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;Ordered[List[java.lang.String]]&nbsp;was&nbsp;found.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;treeSet&nbsp;=&nbsp;TreeSet(colors)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>Instead, you'll need to create an empty<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeSet[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and add to it the elements of the list with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeSet</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>++</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;treeSet&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">TreeSet[String]</SPAN>()&nbsp;++&nbsp;colors
  <SPAN class=output style="COLOR: rgb(90,0,0)">treeSet:&nbsp;scala.collection.immutable.SortedSet[String]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;Set(blue,&nbsp;green,&nbsp;red,&nbsp;yellow)</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Converting to array or list</H4>
<P>If you need to initialize a list or array with another collection, on the other hand, it is quite straightforward. As you've seen previously, to initialize a new list with another collection, simply invoke<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><A id=i-1723195748-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>on that collection<A id=i1406547745-1></A><A id=i-218379511-1></A>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;treeSet.toList
  <SPAN class=output style="COLOR: rgb(90,0,0)">res54:&nbsp;List[String]&nbsp;=&nbsp;List(blue,&nbsp;green,&nbsp;red,&nbsp;yellow)</SPAN>
</PRE>Or, if you need an array, invoke<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toArray</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;treeSet.toArray
  <SPAN class=output style="COLOR: rgb(90,0,0)">res55:&nbsp;Array[String]&nbsp;=&nbsp;Array(blue,&nbsp;green,&nbsp;red,&nbsp;yellow)</SPAN>
</PRE>Note that although the original<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>colors</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list was not sorted, the elements in the list produced by invoking<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeSet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are in alphabetical order. When you invoke<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=code>toArray</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on a collection, the order of the elements in the resulting list or array will be the same as the order of elements produced by an iterator obtained by invoking<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elements</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on that collection. Because a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeSet[String]</SPAN>'s iterator will produce strings in alphabetical order, those strings will appear in alphabetical order in the list resulting from invoking<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeSet</SPAN>. 
<P></P>
<P>Keep in mind, however, that conversion to lists or arrays usually requires copying all of the elements of the collection, and thus may be slow for large collections. Sometimes you need to do it, though, due to an existing API. Further, many collections only have a few elements anyway, in which case there is only a small speed penalty.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Converting between mutable and immutable sets and maps</H4>
<P>Another situation that may arise occasionally is the need to convert a mutable set or map to an immutable one, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>vice versa</I>. To accomplish this, you can use the technique shown previously to initialize a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeSet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the elements of a list. If you have a mutable collection, and want to convert it to a immutable one, for example, create an empty immutable collection and add the elements of the mutable one via the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>++</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator. Here's how you'd convert the immutable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TreeSet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from the previous example to a mutable set, and back again to an immutable one:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.collection.mutable</SPAN>
  <BR>  scala&gt;&nbsp;treeSet
  <SPAN class=output style="COLOR: rgb(90,0,0)">res5:&nbsp;scala.collection.immutable.SortedSet[String]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Set(blue,&nbsp;green,&nbsp;red,&nbsp;yellow)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;mutaSet&nbsp;=&nbsp;mutable.Set.empty&nbsp;++&nbsp;treeSet
  <SPAN class=output style="COLOR: rgb(90,0,0)">mutaSet:&nbsp;scala.collection.mutable.Set[String]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Set(yellow,&nbsp;blue,&nbsp;red,&nbsp;green)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;immutaSet&nbsp;=&nbsp;Set.empty&nbsp;++&nbsp;mutaSet
  <SPAN class=output style="COLOR: rgb(90,0,0)">immutaSet:&nbsp;scala.collection.immutable.Set[String]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Set(yellow,&nbsp;blue,&nbsp;red,&nbsp;green)</SPAN>
</PRE>
<P></P>
<P>You can use the same technique to convert between mutable and immutable maps:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;muta&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">mutable.Map</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"i"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"ii"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">muta:&nbsp;scala.collection.mutable.Map[java.lang.String,Int]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;Map(ii&nbsp;-&gt;&nbsp;2,&nbsp;i&nbsp;-&gt;&nbsp;1)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;immu&nbsp;=&nbsp;Map.empty&nbsp;++&nbsp;muta
  <SPAN class=output style="COLOR: rgb(90,0,0)">immu:&nbsp;scala.collection.immutable.Map[java.lang.String,Int]&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;Map(ii&nbsp;-&gt;&nbsp;2,&nbsp;i&nbsp;-&gt;&nbsp;1)</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=17.6></A>17.6 Tuples<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#17.6">link</A>]</SPAN></H3>
<P>As described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#step9">Step 9</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html">Chapter 3</A>, a tuple combines a fixed<A id=i-862490197-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>number of items together so that they can be passed around as a whole. Unlike an array or list, a tuple can hold objects with different types. Here is an example of a tuple holding an integer, a string, and the console:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  (<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Console</SPAN>)
</PRE>Tuples save you the tedium of defining simplistic data-heavy classes. Even though defining a class is already easy, it does require a certain minimum effort, which sometimes serves no purpose. Tuples save you the effort of choosing a name for the class, choosing a scope to define the class in, and choosing names for the members of the class. If your class simply holds an integer and a string, there is no clarity added by defining a class named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnIntegerAndAString</SPAN>. 
<P></P>
<P>Because tuples can combine objects of different types, tuples do not inherit from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable</SPAN>. If you find yourself wanting to group exactly one integer and exactly one string, then you want a tuple, not a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN>.</P>
<P>A common application of tuples is returning multiple values from a method.<A id=i651595778-2></A><A id=i2120520132-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, here is a method that finds the longest word in a collection and also returns its index:<A id=i-1690228669-3></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;longestWord(words:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;word&nbsp;=&nbsp;words(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;idx&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(i&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;until&nbsp;words.length)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(words(i).length&nbsp;&gt;&nbsp;word.length)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word&nbsp;=&nbsp;words(i)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;i
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;(word,&nbsp;idx)
  }
</PRE>Here is an example use of the method:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;longest&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;longestWord(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"The&nbsp;quick&nbsp;brown&nbsp;fox"</SPAN>.split(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">longest:&nbsp;(String,&nbsp;Int)&nbsp;=&nbsp;(quick,1)</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>longestWord</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function here computes two items:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>word</SPAN>, the longest word in the array, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>idx</SPAN>, the index of that word. To keep things simple, the function assumes there is at least<SPAN class=Apple-converted-space>&nbsp;</SPAN>one word in the list, and it breaks ties by choosing the word that comes earlier in the list. Once the function has chosen which word and index to return, it returns both of them together using the tuple syntax<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(word,</SPAN>&nbsp;<SPAN class=code>idx)</SPAN>. 
<P></P>
<P>To access elements of a tuple, you can use method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to access the first element,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to access the second, and so on:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;longest._1
  <SPAN class=output style="COLOR: rgb(90,0,0)">res56:&nbsp;String&nbsp;=&nbsp;quick</SPAN>
  <BR>  scala&gt;&nbsp;longest._2
  <SPAN class=output style="COLOR: rgb(90,0,0)">res57:&nbsp;Int&nbsp;=&nbsp;1</SPAN>
</PRE>
<P></P>
<P>Additionally, you can assign each element of the tuple to its own<A id=i-467993090-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable,<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#footnote17-5">[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;(word,&nbsp;idx)&nbsp;=&nbsp;longest
  <SPAN class=output style="COLOR: rgb(90,0,0)">word:&nbsp;String&nbsp;=&nbsp;quick</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">idx:&nbsp;Int&nbsp;=&nbsp;1</SPAN>
  <BR>  scala&gt;&nbsp;word
  <SPAN class=output style="COLOR: rgb(90,0,0)">res58:&nbsp;String&nbsp;=&nbsp;quick</SPAN>
</PRE>
<P>By the way, if you leave off the parentheses you get a different result:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;word,&nbsp;idx&nbsp;=&nbsp;longest
  <SPAN class=output style="COLOR: rgb(90,0,0)">word:&nbsp;(String,&nbsp;Int)&nbsp;=&nbsp;(quick,1)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">idx:&nbsp;(String,&nbsp;Int)&nbsp;=&nbsp;(quick,1)</SPAN>
</PRE>This syntax gives<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-181260432"><EM style="FONT-STYLE: italic">multiple definitions</EM></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the same expression.<A id=i1286114796-1></A><A id=i664504196-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Each variable is initialized with its own evaluation of the expression on the right-hand side. That the expression evaluates to a tuple in this case does not matter. Both variables are initialized to the tuple in its entirety. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html">Chapter 18</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>for some examples where multiple definitions are convenient. 
<P></P>
<P>As a note of warning, tuples are almost too easy to use. Tuples are<A id=i-726189942-1></A><A id=i-516778869-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>great when you combine data that has no meaning beyond "an A and a B." However, whenever the combination has some meaning, or you want to add some methods to the combination, it is better to go ahead and create a class. For example, do not use a 3-tuple for the combination of a month, a day, and a year. Make a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Date</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. It makes your intentions explicit, which both clears up the code for human readers and gives the compiler and language opportunities to help you catch mistakes.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=17.7></A>17.7 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#17.7">link</A>]</SPAN></H3>
<P>This chapter has given an overview of the Scala collections library and the most important classes and traits in it. With this foundation you should be able to work effectively with Scala collections, and know where to look in Scaladoc when you need more information. In the next chapter, we'll turn our attention from the Scala library back to the language, and discuss Scala's support for mutable objects.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 17:</H4>
<P><A name=footnote17-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The difference in variance of Scala and Java's arrays&#8212;<I>i.e.</I>, whether<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[AnyRef]</SPAN>&#8212;will be discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#sec:first-arrays">Section 19.3</A>.</P>
<P><A name=footnote17-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The code given<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html#subsec:scala-is-high-level">here</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/a-scalable-language.html">Chapter 1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>presents a similar example.</P>
<P><A name=footnote17-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>type</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword will be explained in more detail in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#sec:abstract-types">Section 20.6</A>.</P>
<P><A name=footnote17-4>[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The "single object" is an instance of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>through<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set4</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>through<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map4</SPAN>, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#tab:default-sets">Tables 17.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#tab:default-maps">and 17.4</A>.</P>
<P><A name=footnote17-5>[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This syntax is actually a special case of<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">pattern matching</EM>, as described in detail in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#sec:patterns-everywhere">Section 15.7</A>.</P></DIV>