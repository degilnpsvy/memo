<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 18 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Stateful Objects</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>In previous chapters, we put the spotlight on functional (immutable) objects. We did so because the idea of objects without any mutable state deserves to be better known.<A id=i-1391607683-1></A>However, it is also perfectly possible to define objects with mutable state in Scala. Such stateful objects often come up naturally when you want to model objects in the real world that change over time.<A id=i-767136195-1></A><A id=i-166063424-1></A></P>
<P>This chapter explains what stateful objects are, and what Scala provides in terms of syntax to express them. The second part of this chapter introduces a larger case study on discrete event simulation, which involves stateful objects as well as building an internal domain specific language (DSL) for defining digital circuits to simulate.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=18.1></A>18.1 What makes an object stateful?<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#18.1">link</A>]</SPAN></H3>
<P>You can observe the principal difference between a purely functional object and a stateful one even without looking at the object's implementation. When you invoke a method or dereference a field on some purely functional object, you will always get the same result. For instance, given a list of characters:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;cs&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'a'</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'b'</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'c'</SPAN>)
</PRE>an application of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cs.head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will always return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>'a'</SPAN>. This is the case even if there is an arbitrary number of operations on the list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>between the point where it is defined and the point where the access<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cs.head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is made. 
<P></P>
<P>For a stateful object, on the other hand, the result of a method call or field access may depend on what operations were previously performed on the object. A good example of a stateful object is a bank account.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:bank-account">Listing 18.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a simplified implementation of bank accounts:<A name=lst:bank-account></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BankAccount</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;bal:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;balance:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;bal
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;deposit(amount:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require(amount&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bal&nbsp;+=&nbsp;amount
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;withdraw(amount:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(amount&nbsp;&gt;&nbsp;bal)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bal&nbsp;-=&nbsp;amount
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}&nbsp;
</PRE>
<H5>Listing 18.1 - A mutable bank account class.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BankAccount</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class defines a private variable,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bal</SPAN>, and three public methods:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>balance</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns the current balance;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>deposit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>adds a given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>amount</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bal</SPAN>; and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>withdraw</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>tries to subtract a given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>amount</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>while assuring that the remaining balance won't be negative. The return value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>withdraw</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>indicating whether the requested funds were successfully withdrawn.</P>
<P>Even if you know nothing about the inner workings of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BankAccount</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class, you can still tell that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BankAccount</SPAN>s are stateful objects:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;account&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BankAccount</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">account:&nbsp;BankAccount&nbsp;=&nbsp;BankAccount@bf5bb7</SPAN>
  <BR>  scala&gt;&nbsp;account&nbsp;deposit&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">100</SPAN>
  <BR>  scala&gt;&nbsp;account&nbsp;withdraw&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">80</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;&nbsp;account&nbsp;withdraw&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">80</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>Note that the two final withdrawals in the previous interaction returned different results. The first withdraw operation returned<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>because the bank account contained sufficient funds to allow the withdrawal. The second operation, although the same as the first one, returned<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>, because the balance of the account had been reduced so that it no longer covered the requested funds. So, clearly bank accounts have mutable state, because the same operation can return different results at different times. 
<P></P>
<P>You might think that the statefulness of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BankAccount</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is immediately apparent because it contains a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition<A id=i176085891-1></A>. State and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s usually go hand in hand, but things are not always so clear-cut. For instance, a class might be stateful without defining or inheriting any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s because it forwards method calls to other objects that have mutable state. The reverse is also possible: A class might contain<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s and still be purely functional. An example would be a class that caches the result of an expensive operation in a field for optimization purposes. To pick an example, assume the following unoptimized class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Keyed</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with an expensive operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>computeKey</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Keyed</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;computeKey:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;...&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;this&nbsp;will&nbsp;take&nbsp;some&nbsp;time</SPAN>
  &nbsp;&nbsp;...
  }
</PRE>Provided that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>computeKey</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>neither reads nor writes any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s, you can make<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Keyed</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>more efficient by adding a cache:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">MemoKeyed</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Keyed</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;keyCache:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Option[Int]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">None</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;computeKey:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(!keyCache.isDefined)&nbsp;keyCache&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">super</SPAN>.computeKey)
  &nbsp;&nbsp;&nbsp;&nbsp;keyCache.get
  &nbsp;&nbsp;}
  }
</PRE>Using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MemoKeyed</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Keyed</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can speed up things, because the second time the result of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>computeKey</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation is requested, the value stored in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>keyCache</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field can be returned instead of running<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>computeKey</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>once again. But except for this speed gain, the behavior of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Keyed</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MemoKeyed</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is exactly the same. Consequently, if<SPAN class=code>Keyed</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is purely functional, then so is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MemoKeyed</SPAN>, even though it contains a reassignable variable. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=18.2></A>18.2 Reassignable variables and properties<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#18.2">link</A>]</SPAN></H3>
<P><A name=sec:properties></A></P>
<P>You can perform two fundamental operations on a reassignable<A id=i-926053069-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable<A id=i717358687-1></A>: get its value or set it to a new value. In libraries such as JavaBeans, these operations are often encapsulated in separate getter<A id=i-1969580643-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and setter<A id=i553650449-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods,<A id=i696953561-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which need to be defined explicitly. In Scala, every<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that is a non-private member of some object implicitly defines a getter and a setter method with it. These getters and setters are named differently from the Java convention, however. The getter of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is just named "<SPAN class=code>x</SPAN>", while its setter is named "<SPAN class=code>x_=</SPAN>"<A id=i-1901486033-1></A>.</P>
<P>For example, if it appears in a class, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;hour&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">12</SPAN>
</PRE>generates a getter, "<SPAN class=code>hour</SPAN>", and setter, "<SPAN class=code>hour_=</SPAN>", in addition to a reassignable field. The field is always marked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private[this]</SPAN>, which means it can be accessed only from the object that contains it. The getter and setter, on the other hand, get the same visibility as the original<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>. If the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition is public, so are its getter and setter, if it is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>they are also<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN>, and so on. 
<P></P>
<P>For instance, consider the class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Time</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:class-with-public-vars">Listing 18.2</A>, which defines two public<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hour</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>minute</SPAN>:</P>
<P><A name=lst:class-with-public-vars></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Time</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;hour&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">12</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;minute&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 18.2 - A class with public<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s.</H5>
<P>This implementation is exactly equivalent to the class definition shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:public-var-expansion">Listing 18.3</A>. In the definitions shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:public-var-expansion">Listing 18.3</A>, the names of the local fields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>h</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>m</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are arbitrarily chosen so as not to clash with any names already in use.</P>
<P><A name=lst:public-var-expansion></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Time</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>[<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>]&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;h&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">12</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>[<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>]&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;m&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hour:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;h
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hour_=(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{&nbsp;h&nbsp;=&nbsp;x&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;minute:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;m
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;minute_=(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{&nbsp;m&nbsp;=&nbsp;x&nbsp;}
  &nbsp;&nbsp;}&nbsp;
</PRE>
<H5>Listing 18.3 - How public<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s are expanded into getter and setter methods.</H5>
<P>An interesting aspect about this expansion of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s into getters and setters is that you can also choose to define a getter and a setter directly instead of defining a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>. By defining these access methods directly you can interpret the operations of variable access and variable assignment as you like. For instance, the variant of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Time</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:hand-written-get-set">Listing 18.4</A>contains requirements that catch all assignments to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hour</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>minute</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with illegal values.</P>
<P><A name=lst:hand-written-get-set></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Time</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>[<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>]&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;h&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">12</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>[<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>]&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;m&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">12</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hour:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;h
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hour_=&nbsp;(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;&lt;=&nbsp;x&nbsp;&amp;&amp;&nbsp;x&nbsp;&lt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">24</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;=&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;minute&nbsp;=&nbsp;m
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;minute_=&nbsp;(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;&lt;=&nbsp;x&nbsp;&amp;&amp;&nbsp;x&nbsp;&lt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">60</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}&nbsp;
</PRE>
<H5>Listing 18.4 - Defining getter and setter methods directly.</H5>
<P>Some languages have a special syntactic construct for these variable-like quantities that are not plain variables in that their getter or setter can be redefined. For instance, C# has properties, which fulfill this role. Scala's convention of always interpreting a variable as a pair of setter and getter methods gives you in effect the same capabilities as C# properties without requiring special syntax<A id=i1153498175-1></A>. Properties can serve many different purposes. In the example shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:hand-written-get-set">Listing 18.4</A>, the setters enforced an invariant, thus protecting the variable from being assigned illegal values. You could also use a property to log all accesses to getters or setters of a variable. Or you could integrate variables with events, for instance by notifying some subscriber methods each time a variable is modified (you'll see examples of this in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html">Chapter 33</A>).</P>
<P>It is also possible, and sometimes useful, to define a getter and a setter without an associated field. An example is the following class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Thermometer</SPAN>, which encapsulates a temperature variable that can be read and updated. Temperatures can be expressed in Celsius or Fahrenheit degrees. The class below allows you to get and set the temperature in either measure.<A name=lst:class-thermometer></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Thermometer</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;celsius:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Float</SPAN>&nbsp;=&nbsp;_
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;fahrenheit&nbsp;=&nbsp;celsius&nbsp;*&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">9</SPAN>&nbsp;/&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">32</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;fahrenheit_=&nbsp;(f:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Float</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;celsius&nbsp;=&nbsp;(f&nbsp;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">32</SPAN>)&nbsp;*&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>&nbsp;/&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">9</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;fahrenheit&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"F/"</SPAN>+&nbsp;celsius&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"C"</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 18.5 - Defining a getter and setter without an associated field.</H5>
<P>The first line in the body of this class defines a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>celsius</SPAN>, which will contain the temperature in degrees Celsius. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>celsius</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable is initially set to a default value by specifying `<SPAN class=code>_</SPAN>' as the "initializing value" of the variable. More precisely, an initializer<A id=i969211487-1></A><A id=i769452465-1></A><A id=i1897052361-1></A><A id=i1853080782-1></A><A id=i-388295396-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>"<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code>_</SPAN>" of a field assigns a zero value to that field. The zero value depends on the field's type. It is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for numeric types,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for booleans, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for reference types. This is the same as if the same variable was defined in Java without an initializer.</P>
<P>Note that you cannot simply leave off the "<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code>_</SPAN>" initializer in Scala. If you had written:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;celsius:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Float</SPAN>
</PRE>this would declare an abstract variable, not an uninitialized one.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#footnote18-1">[1]</A> 
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>celsius</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable definition is followed by a getter, "<SPAN class=code>fahrenheit</SPAN>", and a setter, "<SPAN class=code>fahrenheit_=</SPAN>", which access the same temperature, but in degrees Fahrenheit. There is no separate field that contains the current temperature value in Fahrenheit. Instead the getter and setter methods for Fahrenheit values automatically convert from and to degrees Celsius, respectively. Here's an example of interacting with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Thermometer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;t&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Thermometer</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">t:&nbsp;Thermometer&nbsp;=&nbsp;32.0F/0.0C</SPAN>
  <BR>  scala&gt;&nbsp;t.celsius&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">100</SPAN>
  <BR>  scala&gt;&nbsp;t
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;Thermometer&nbsp;=&nbsp;212.0F/100.0C</SPAN>
  <BR>  scala&gt;&nbsp;t.fahrenheit&nbsp;=&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">40</SPAN>
  <BR>  scala&gt;&nbsp;t
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;Thermometer&nbsp;=&nbsp;-40.0F/-40.0C</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=18.3></A>18.3 Case study: Discrete event simulation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#18.3">link</A>]</SPAN></H3>
<P>The rest of this chapter shows by way of an extended example how stateful objects can be combined with first-class function values in interesting ways. You'll see the design and implementation of a simulator for digital circuits. This task is decomposed into several subproblems, each of which is interesting individually: First, you'll see a little language for digital circuits. The definition of this language will highlight a general method for embedding domain-specific languages in a host language like Scala.<A id=i-1851490486-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Second, we'll present a simple but general framework for discrete event simulation. The main task of this framework will be to keep track of actions that are performed in simulated time. Finally, we'll show how discrete simulation programs can be structured and built. The idea of such simulations is to model physical objects by simulated objects, and to use the simulation framework to model physical time.</P>
<P>The example is taken from the classic textbook<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Structure and Interpretation of Computer Programs</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>by Abelson and Sussman<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#abelson-sussman:structure">abelson-sussman:structure</A>.<A id=i-72492243-1></A><A id=i471924076-1></A><A id=i-1712702061-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>What's different here is that the implementation language is Scala instead of Scheme, and that the various aspects of the example are structured into four software layers: one for the simulation framework, another for the basic circuit simulation package, a third for a library of user-defined circuits, and the last layer for each simulated circuit itself. Each layer is expressed as a class, and more specific layers inherit from more general ones.</P>
<DIV class=pointofinterest>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">The fast track</H3>
<P>Understanding the discrete event simulation example presented in this chapter will take some time. If you feel you want to get on with learning more Scala instead, it's safe to skip ahead to the next chapter.</P></DIV>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:gates></A>
<P><IMG alt="image images/basicgates.jpg" src="http://www.artima.com/pins1ed/images/basicgates.jpg"></P></DIV>
<H5>Figure 18.1 - Basic gates.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=18.4></A>18.4 A language for digital circuits<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#18.4">link</A>]</SPAN></H3>
<P><A name=sec:language-circuits></A></P>
<P>We'll start with a "little language" to describe digital circuits. A digital circuit is built from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">wires</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">function boxes</SPAN>. Wires carry<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">signals</SPAN>, which are transformed by function boxes. Signals are represented by booleans:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for signal-on and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for signal-off.</P>
<P><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#fig:gates">Figure 18.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows three basic function boxes (or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">gates</SPAN>):</P>
<UL>
<LI>An<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">inverter</EM>, which negates its signal. 
<LI>An<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">and-gate</EM>, which sets its output to the conjunction of its inputs. 
<LI>An<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">or-gate</EM>, which sets its output to the disjunction of its inputs.</LI></UL>These gates are sufficient to build all other function boxes. Gates have<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">delays</SPAN>, so an output of a gate will change only some time after its inputs change. 
<P>We'll describe the elements of a digital circuit by the following set of Scala classes and functions. First, there is a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Wire</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for wires. We can construct wires like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;a&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;b&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;c&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>
</PRE>or, equivalent but shorter, like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;a,&nbsp;b,&nbsp;c&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>
</PRE>Second, there are three procedures which "make" the basic gates we need:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;inverter(input:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;output:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;andGate(a1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;a2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;output:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;orGate(o1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;o2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;output:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)
</PRE>What's unusual, given the functional emphasis of Scala, is that these procedures construct the gates as a side-effect, instead of returning the constructed gates as a result. For instance, an invocation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>inverter(a,</SPAN>&nbsp;<SPAN class=code>b)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>places an inverter between the wires<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN>It turns out that this side-effecting construction makes it easier to construct complicated circuits gradually. Also, although methods most often have verb names, these have noun names that indicate which gate they are making. This reflects the declarative nature of the DSL: it should describe a circuit, not the actions of making one. 
<P></P>
<P>More complicated function boxes can be built from the basic gates. For instance, the method shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:half-adder">Listing 18.6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>constructs a half-adder. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>halfAdder</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method takes two inputs,<SPAN class=code>a</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b</SPAN>, and produces a sum,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s</SPAN>, defined by "<SPAN class=code>s</SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code>(a</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>b)</SPAN>&nbsp;<SPAN class=code>%</SPAN>&nbsp;<SPAN class=code>2</SPAN>" and a carry,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>c</SPAN>, defined by "<SPAN class=code>c</SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code>(a</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>b)</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>2</SPAN>". A diagram of the half-adder is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#fig:half-adder">Figure 18.2</A>.</P>
<P><A name=lst:half-adder></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;halfAdder(a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;b:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;c:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;d,&nbsp;e&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;orGate(a,&nbsp;b,&nbsp;d)
  &nbsp;&nbsp;&nbsp;&nbsp;andGate(a,&nbsp;b,&nbsp;c)
  &nbsp;&nbsp;&nbsp;&nbsp;inverter(c,&nbsp;e)
  &nbsp;&nbsp;&nbsp;&nbsp;andGate(d,&nbsp;e,&nbsp;s)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 18.6 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>halfAdder</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.</H5>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:half-adder></A>
<P><IMG alt="image images/halfadder.jpg" src="http://www.artima.com/pins1ed/images/halfadder.jpg"></P></DIV>
<H5>Figure 18.2 - A half-adder circuit.</H5>
<P>Note that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>halfAdder</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a parameterized function box just like the three methods that construct the primitive gates. You can use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>halfAdder</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method to construct more complicated circuits. For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:full-adder">Listing 18.7</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>defines a full, one-bit adder, shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#fig:full-adder">Figure 18.3</A>, which takes two inputs,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b</SPAN>, as well as a carry-in,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cin</SPAN>, and which produces a sum output defined by "<SPAN class=code>sum</SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code>(a</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>b</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>cin)</SPAN>&nbsp;<SPAN class=code>%</SPAN>&nbsp;<SPAN class=code>2</SPAN>" and a carry-out output defined by "<SPAN class=code>cout</SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code>(a</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>b</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>cin)</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>2</SPAN>".</P>
<P><A name=lst:full-adder></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;fullAdder(a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;b:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;cin:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;cout:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;s,&nbsp;c1,&nbsp;c2&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;halfAdder(a,&nbsp;cin,&nbsp;s,&nbsp;c1)
  &nbsp;&nbsp;&nbsp;&nbsp;halfAdder(b,&nbsp;s,&nbsp;sum,&nbsp;c2)
  &nbsp;&nbsp;&nbsp;&nbsp;orGate(c1,&nbsp;c2,&nbsp;cout)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 18.7 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>fullAdder</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.</H5>
<P>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Wire</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and functions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>inverter</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>andGate</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orGate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>represent a little language with which users can define digital circuits. It's a good example of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">internal</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>DSL, a domain specific language defined as a library in a host language instead of being implemented on its own.</P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:full-adder></A>
<P><IMG alt="image images/fulladder.jpg" src="http://www.artima.com/pins1ed/images/fulladder.jpg"></P></DIV>
<H5>Figure 18.3 - A full-adder circuit.</H5>
<P>The implementation of the circuit DSL still needs to be worked out. Since the purpose of defining a circuit in the DSL is simulating the circuit, it makes sense to base the DSL implementation on a general API for discrete event simulation. The next two sections will present first the simulation API and then the implementation of the circuit DSL on top of it.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=18.5></A>18.5 The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>API<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#18.5">link</A>]</SPAN></H3>
<P>The simulation API is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:simulation">Listing 18.8</A>. It consists of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>org.stairwaybook.simulation</SPAN>. Concrete simulation libraries inherit this class and augment it with domain-specific functionality. The elements of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class are presented in this section.</P>
<P><A name=lst:simulation></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Simulation</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Action</SPAN>&nbsp;=&nbsp;()&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Unit</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">WorkItem</SPAN>(time:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;action:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Action</SPAN>)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;curtime&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;currentTime:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;curtime
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;agenda:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[WorkItem]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;insert(ag:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[WorkItem]</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">WorkItem</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[WorkItem]</SPAN>&nbsp;=&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(ag.isEmpty&nbsp;||&nbsp;item.time&nbsp;&lt;&nbsp;ag.head.time)&nbsp;item&nbsp;::&nbsp;ag
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;ag.head&nbsp;::&nbsp;insert(ag.tail,&nbsp;item)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;afterDelay(delay:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)(block:&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Unit</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;item&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">WorkItem</SPAN>(currentTime&nbsp;+&nbsp;delay,&nbsp;()&nbsp;=&gt;&nbsp;block)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;agenda&nbsp;=&nbsp;insert(agenda,&nbsp;item)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;next()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(agenda:&nbsp;@unchecked)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;item&nbsp;::&nbsp;rest&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;agenda&nbsp;=&nbsp;rest&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curtime&nbsp;=&nbsp;item.time
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item.action()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;run()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;afterDelay(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"***&nbsp;simulation&nbsp;started,&nbsp;time&nbsp;=&nbsp;"</SPAN>+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentTime&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;***"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">while</SPAN>&nbsp;(!agenda.isEmpty)&nbsp;next()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 18.8 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class.</H5>
<P>A discrete event simulation performs user-defined<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">actions</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>at specified<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">times</EM>. The actions, which are defined by concrete simulation subclasses, all share a common type:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Action</SPAN>&nbsp;=&nbsp;()&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Unit</SPAN>
</PRE>This statement defines<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Action</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be an alias of the type of procedure that takes an empty parameter list and returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Action</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">type member</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulation</SPAN>. You can think of it as a more readable name for type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>()</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Unit</SPAN>. Type members will be described in detail in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#sec:abstract-types">Section 20.6</A>. 
<P></P>
<P>The time at which an action is performed is simulated time; it has nothing to do with the actual "wall clock" time. Simulated times are represented simply as integers. The current simulated time is kept in a private variable:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;curtime:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
</PRE>The variable has a public accessor method, which retrieves the current time:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;currentTime:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;curtime
</PRE>This combination of private variable with public accessor is used to make sure that the current time cannot be modified outside the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. After all, you don't usually want your simulation objects to manipulate the current time, except possibly if your simulation models time travel. 
<P></P>
<P>An action that needs to be executed at a specified time is called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">work item</SPAN>. Work items are implemented by the following class:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">WorkItem</SPAN>(time:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;action:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Action</SPAN>)
</PRE>We made the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>WorkItem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class a case class because of the syntactic conveniences this entails: you can use the factory method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>WorkItem</SPAN>, to create instances of the class, and you get accessors for the constructor parameters<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>time</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>action</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for free. Note also that class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>WorkItem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is nested inside class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulation</SPAN>. Nested classes in Scala are treated similarly to Java.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#sec:path-dependent-types">Section 20.7</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>will give more details. 
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class keeps an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">agenda</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of all remaining work items that have not yet been executed. The work items are sorted by the simulated time at which they have to be run:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;agenda:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[WorkItem]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>agenda</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list will be kept in the proper sorted order by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>insert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which updates it. You can see<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>insert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>being called from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>afterDelay</SPAN>, which is the only way to add a work item to the agenda:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;afterDelay(delay:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)(block:&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Unit</SPAN>)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;item&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">WorkItem</SPAN>(currentTime&nbsp;+&nbsp;delay,&nbsp;()&nbsp;=&gt;&nbsp;block)
  &nbsp;&nbsp;agenda&nbsp;=&nbsp;insert(agenda,&nbsp;item)
  }
</PRE>As the name implies, this method inserts an action (given by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>block</SPAN>) into the agenda so that it is scheduled for execution<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>delay</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>time units after the current simulation time. For instance, the following invocation would create a new work item to be executed at the simulated time,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>currentTime</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>delay</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  afterDelay(delay)&nbsp;{&nbsp;count&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;}
</PRE>The code to be executed is contained in the method's second argument. The formal parameter for this argument has type "<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Unit</SPAN>",<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, it is a computation of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>which is passed by name. Recall that by-name<SPAN class=Apple-converted-space>&nbsp;</SPAN>parameters<A id=i-1931276111-2></A><A id=i-2031769303-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>are not evaluated when passed to a method. So in the call above,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>count</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be incremented only when the simulation framework calls the action stored in the work item. Note that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>afterDelay</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a curried function. It's a good example of the principle set forward in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#sec:by-name-parameters">Section 9.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that currying can be used to make method calls look more like built-in syntax. The created work item still needs to be inserted into the agenda. This is done by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>insert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which maintains the invariant that the agenda is time-sorted:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;insert(ag:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[WorkItem]</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;item:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">WorkItem</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[WorkItem]</SPAN>&nbsp;=&nbsp;&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(ag.isEmpty&nbsp;||&nbsp;item.time&nbsp;&lt;&nbsp;ag.head.time)&nbsp;item&nbsp;::&nbsp;ag
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;ag.head&nbsp;::&nbsp;insert(ag.tail,&nbsp;item)
  }
</PRE>The core of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class is defined by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>run</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;run()&nbsp;{
  &nbsp;&nbsp;afterDelay(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"***&nbsp;simulation&nbsp;started,&nbsp;time&nbsp;=&nbsp;"</SPAN>+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentTime&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;***"</SPAN>)
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">while</SPAN>&nbsp;(!agenda.isEmpty)&nbsp;next()
  }
</PRE>This method repeatedly takes the first item in the agenda, removes it from the agenda and executes it. It does this until there are no more items left in the agenda to execute. Each step is performed by calling the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>next</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which is defined as follows:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;next()&nbsp;{
  &nbsp;&nbsp;(agenda:&nbsp;@unchecked)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;item&nbsp;::&nbsp;rest&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;agenda&nbsp;=&nbsp;rest&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curtime&nbsp;=&nbsp;item.time
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item.action()
  &nbsp;&nbsp;}
  }
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>next</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method decomposes the current agenda with a pattern match into a front item,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>item</SPAN>, and a remaining list of work items,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rest</SPAN>. It removes the front item from the current agenda, sets the simulated time<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>curtime</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the work item's time, and executes the work item's action.<A id=i1154860961-1></A> 
<P></P>
<P>Note that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>next</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be called only if the agenda is non-empty. There's no case for an empty list, so you would get a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MatchError</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>exception if you tried to run<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>next</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on an empty agenda.</P>
<P>In fact, the Scala compiler would normally warn you that you missed one of the possible patterns for a list:<A id=i-160448460-2></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Simulator.scala:19:&nbsp;warning:&nbsp;match&nbsp;is&nbsp;not&nbsp;exhaustive!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">missing&nbsp;combination&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nil</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)"></SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;agenda&nbsp;match&nbsp;{</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">one&nbsp;warning&nbsp;found</SPAN>
</PRE>In this case, the missing case is not a problem, because you know that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>next</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is called only on a non-empty agenda. Therefore, you might want to disable the warning. You saw in<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#sec:sealed-classes">Section 15.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that this can be done by adding an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@unchecked</SPAN><A id=i-1840852242-2></A><A id=i-815574504-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>annotation to the selector expression of the pattern match. That's why the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>code uses "<SPAN class=code>(agenda:</SPAN><SPAN class=code>@unchecked)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN>", not "<SPAN class=code>agenda</SPAN>&nbsp;<SPAN class=code>match</SPAN>". That's it. This seems surprisingly little code for a simulation framework. You might wonder how this framework could possibly support interesting simulations, if all it does is execute a list of work items? In fact the power of the simulation framework comes from the fact that actions stored in work items can themselves install further work items into the agenda when they are executed. That makes it possible to have long-running simulations evolve from simple beginnings. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=18.6></A>18.6 Circuit Simulation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#18.6">link</A>]</SPAN></H3>
<P>The next step is to use the simulation framework to implement the domain-specific language for circuits shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#sec:language-circuits">Section 18.4</A>. Recall that the circuit DSL consists of a class for wires and methods that create and-gates, or-gates, and inverters. These are all contained in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BasicCircuitSimulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class, which extends the simulation framework. This class is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:top-basic-circuit-simulation">Listings 18.9</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:bottom-basic-circuit-simulation">and 18.10</A>.</P>
<P><A name=lst:top-basic-circuit-simulation></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.simulation
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BasicCircuitSimulation</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Simulation</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">InverterDelay</SPAN>:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AndGateDelay</SPAN>:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">OrGateDelay</SPAN>:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;sigVal&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;actions:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Action]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;getSignal&nbsp;=&nbsp;sigVal
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;setSignal(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(s&nbsp;!=&nbsp;sigVal)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigVal&nbsp;=&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actions&nbsp;foreach&nbsp;(_&nbsp;())&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;addAction(a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Action</SPAN>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actions&nbsp;=&nbsp;a&nbsp;::&nbsp;actions
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;inverter(input:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;output:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;invertAction()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;inputSig&nbsp;=&nbsp;input.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;afterDelay(<SPAN class=typename style="COLOR: rgb(103,0,154)">InverterDelay</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;setSignal&nbsp;!inputSig&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input&nbsp;addAction&nbsp;invertAction
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;continued&nbsp;in&nbsp;Listing&nbsp;18.10...</SPAN>
</PRE>
<H5>Listing 18.9 - The first half of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BasicCircuitSimulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class.</H5>
<P><A name=lst:bottom-basic-circuit-simulation></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;...continued&nbsp;from&nbsp;Listing&nbsp;18.9</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;andGate(a1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;a2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;output:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;andAction()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;a1Sig&nbsp;=&nbsp;a1.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;a2Sig&nbsp;=&nbsp;a2.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;afterDelay(<SPAN class=typename style="COLOR: rgb(103,0,154)">AndGateDelay</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;setSignal&nbsp;(a1Sig&nbsp;&amp;&nbsp;a2Sig)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1&nbsp;addAction&nbsp;andAction
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a2&nbsp;addAction&nbsp;andAction
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;orGate(o1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;o2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;output:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;orAction()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;o1Sig&nbsp;=&nbsp;o1.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;o2Sig&nbsp;=&nbsp;o2.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;afterDelay(<SPAN class=typename style="COLOR: rgb(103,0,154)">OrGateDelay</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;setSignal&nbsp;(o1Sig&nbsp;|&nbsp;o2Sig)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o1&nbsp;addAction&nbsp;orAction
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o2&nbsp;addAction&nbsp;orAction
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;probe(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;wire:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;probeAction()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(name&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>+&nbsp;currentTime&nbsp;+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;new-value&nbsp;=&nbsp;"</SPAN>+&nbsp;wire.getSignal)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wire&nbsp;addAction&nbsp;probeAction
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 18.10 - The second half of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BasicCircuitSimulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class.</H5>
<P>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BasicCircuitSimulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>declares three abstract methods that represent the delays of the basic gates:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>InverterDelay</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AndGateDelay</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>OrGateDelay</SPAN>. The actual delays are not known at the level of this class, because they depend on the technology of circuits that are simulated. That's why the delays are left abstract in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BasicCircuitSimulation</SPAN>, so that their concrete definition is delegated to a subclass.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#footnote18-2">[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The implementation of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BasicCircuitSimulation</SPAN>'s other members is described next.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Wire</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class</H4>
<P>A wire needs to support three basic actions:</P>
<UL>
<LI>[]<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getSignal:</SPAN>&nbsp;<SPAN class=code>Boolean</SPAN>: returns the current signal on the wire. 
<LI>[]<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>setSignal(sig:</SPAN>&nbsp;<SPAN class=code>Boolean)</SPAN>: sets the wire's signal to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sig</SPAN>. 
<LI>[]<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>addAction(p:</SPAN>&nbsp;<SPAN class=code>Action)</SPAN>: attaches the specified procedure<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">actions</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the wire. The idea is that all action procedures attached to some wire will be executed every time the signal of the wire changes. Typically actions are added to a wire by components connected to the wire. An attached action is executed once at the time it is added to a wire, and after that, every time the signal of the wire changes.</LI></UL>Here is the implementation of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Wire</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;sigVal&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;actions:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Action]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;getSignal&nbsp;=&nbsp;sigVal
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;setSignal(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(s&nbsp;!=&nbsp;sigVal)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigVal&nbsp;=&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actions&nbsp;foreach&nbsp;(_&nbsp;())&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;addAction(a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Action</SPAN>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;actions&nbsp;=&nbsp;a&nbsp;::&nbsp;actions
  &nbsp;&nbsp;&nbsp;&nbsp;a()
  &nbsp;&nbsp;}
  }
</PRE>Two private variables make up the state of a wire. The variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sigVal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>represents the current signal, and the variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>actions</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>represents the action procedures currently attached to the wire. The only interesting method implementation is the one for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>setSignal</SPAN>: When the signal of a wire changes, the new value is stored in the variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sigVal</SPAN>. Furthermore, all actions attached to a wire are executed. Note the shorthand syntax for doing this: "<SPAN class=code>actions</SPAN>&nbsp;<SPAN class=code>foreach</SPAN>&nbsp;<SPAN class=code>(_</SPAN>&nbsp;<SPAN class=code>())</SPAN>" applies the function, "<SPAN class=code>_</SPAN>&nbsp;<SPAN class=code>()</SPAN>", to each element in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>actions</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list. As described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#sec:placeholder-syntax">Section 8.5</A>, the function "<SPAN class=code>_</SPAN>&nbsp;<SPAN class=code>()</SPAN>" is a shorthand for "<SPAN class=code>f</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>f</SPAN>&nbsp;<SPAN class=code>()</SPAN>",<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, it takes a function (we'll call it<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN>) and applies it to the empty parameter list. 
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>inverter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method</H4>
<P>The only effect of creating an inverter is that an action is installed on its input wire. This action is invoked once at the time the action is installed, and thereafter every time the signal on the input changes. The effect of the action is that the value of the inverter's output value is set (via<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>setSignal</SPAN>) to the inverse of its input value. Since inverter gates have delays, this change should take effect only<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>InverterDelay</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>units of simulated time after the input value has changed and the action was executed. This suggests the following implementation:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;inverter(input:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;output:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;invertAction()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;inputSig&nbsp;=&nbsp;input.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;afterDelay(<SPAN class=typename style="COLOR: rgb(103,0,154)">InverterDelay</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;setSignal&nbsp;!inputSig&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  &nbsp;&nbsp;input&nbsp;addAction&nbsp;invertAction
  }
</PRE>The effect of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>inverter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is to add<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>invertAction</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>input</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>wire. This action, when invoked, gets the input signal and installs another action that inverts the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>output</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>signal into the simulation agenda. This other action is to be executed after<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>InverterDelay</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>units of simulated time. Note how the method uses the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>afterDelay</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method of the simulation framework to create a new work item that's going to be executed in the future. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>andGate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orGate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods</H4>
<P>The implementation of and-gates is analogous to the implementation of inverters. The purpose of an and-gate is to output the conjunction of its input signals. This should happen at<SPAN class=code>AndGateDelay</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>simulated time units after any one of its two inputs changes. Hence, the following implementation:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;andGate(a1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;a2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;output:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;andAction()&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;a1Sig&nbsp;=&nbsp;a1.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;a2Sig&nbsp;=&nbsp;a2.getSignal
  &nbsp;&nbsp;&nbsp;&nbsp;afterDelay(<SPAN class=typename style="COLOR: rgb(103,0,154)">AndGateDelay</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;setSignal&nbsp;(a1Sig&nbsp;&amp;&nbsp;a2Sig)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  &nbsp;&nbsp;a1&nbsp;addAction&nbsp;andAction
  &nbsp;&nbsp;a2&nbsp;addAction&nbsp;andAction
  }
</PRE>The effect of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>andGate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is to add<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>andAction</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to both of its input wires<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a2</SPAN>. This action, when invoked, gets both input signals and installs another action that sets the<SPAN class=code>output</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>signal to the conjunction of both input signals. This other action is to be executed after<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AndGateDelay</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>units of simulated time. Note that the output has to be recomputed if either of the input wires changes. That's why the same<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>andAction</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is installed on each of the two input wires<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a2</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orGate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is implemented similarly, except it performs a logical-or instead of a logical-and. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Simulation output</H4>
<P>To run the simulator, you need a way to inspect changes of signals on wires. To accomplish this, you can simulate the action of putting a probe on a wire:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;probe(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;wire:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;probeAction()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(name&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>+&nbsp;currentTime&nbsp;+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;new-value&nbsp;=&nbsp;"</SPAN>+&nbsp;wire.getSignal)
  &nbsp;&nbsp;}
  &nbsp;&nbsp;wire&nbsp;addAction&nbsp;probeAction
  }
</PRE>The effect of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>probe</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>procedure is to install a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>probeAction</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on a given wire. As usual, the installed action is executed every time the wire's signal changes. In this case it simply prints the name of the wire (which is passed as first parameter to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>probe</SPAN>), as well as the current simulated time and the wire's new value. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Running the simulator</H4>
<P>After all these preparations, it's time to see the simulator in action. To define a concrete simulation, you need to inherit from a simulation framework class. To see something interesting, we'll create an abstract simulation class that extends<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BasicCircuitSimulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and contains method definitions for half-adders and full-adders as they were presented earlier in this chapter in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:half-adder">Listings 18.6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:full-adder">and 18.7</A>. This class, which we'll call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CircuitSimulation</SPAN>, is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:circuit-simulation">Listing 18.11</A>:<A name=lst:circuit-simulation></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.simulation
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CircuitSimulation</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BasicCircuitSimulation</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;halfAdder(a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;b:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;c:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;d,&nbsp;e&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orGate(a,&nbsp;b,&nbsp;d)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;andGate(a,&nbsp;b,&nbsp;c)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inverter(c,&nbsp;e)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;andGate(d,&nbsp;e,&nbsp;s)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;fullAdder(a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;b:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;cin:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;cout:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;s,&nbsp;c1,&nbsp;c2&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;halfAdder(a,&nbsp;cin,&nbsp;s,&nbsp;c1)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;halfAdder(b,&nbsp;s,&nbsp;sum,&nbsp;c2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orGate(c1,&nbsp;c2,&nbsp;cout)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 18.11 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CircuitSimulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class.</H5>
<P>A concrete circuit simulation will be an object that inherits from class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CircuitSimulation</SPAN>. The object still needs to fix the gate delays according to the circuit implementation technology that's simulated. Finally, you will also need to define the concrete circuit that's going to be simulated. You can do these steps interactively in the Scala interpreter:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;org.stairwaybook.simulation._
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;org.stairwaybook.simulation._</SPAN>
</PRE>First, the gate delays. Define an object (call it<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MySimulation</SPAN>) that provides some numbers:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">MySimulation</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CircuitSimulation</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">InverterDelay</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AndGateDelay</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">OrGateDelay</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">defined&nbsp;module&nbsp;MySimulation</SPAN>
</PRE>Because you are going to access the members of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MySimulation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object repeatedly, an import of the object keeps the subsequent code shorter:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;MySimulation._
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;MySimulation._</SPAN>
</PRE>Next, the circuit. Define four wires, and place probes on two of them:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;input1,&nbsp;input2,&nbsp;sum,&nbsp;carry&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">input1:&nbsp;MySimulation.Wire&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;simulator.BasicCircuitSimulation$Wire@111089b</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">input2:&nbsp;MySimulation.Wire&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;simulator.BasicCircuitSimulation$Wire@14c352e</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">sum:&nbsp;MySimulation.Wire&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;simulator.BasicCircuitSimulation$Wire@37a04c</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">carry:&nbsp;MySimulation.Wire&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;simulator.BasicCircuitSimulation$Wire@1fd10fa</SPAN>
  <BR>  scala&gt;&nbsp;probe(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"sum"</SPAN>,&nbsp;sum)
  <SPAN class=output style="COLOR: rgb(90,0,0)">sum&nbsp;0&nbsp;new-value&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;probe(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"carry"</SPAN>,&nbsp;carry)
  <SPAN class=output style="COLOR: rgb(90,0,0)">carry&nbsp;0&nbsp;new-value&nbsp;=&nbsp;false</SPAN>
</PRE>Note that the probes immediately print an output. This is a consequence of the fact that every action installed on a wire is executed a first time when the action is installed. 
<P></P>
<P>Now define a half-adder connecting the wires:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;halfAdder(input1,&nbsp;input2,&nbsp;sum,&nbsp;carry)
</PRE>Finally, set the signals, one after another, on the two input wires to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and run the simulation:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;input1&nbsp;setSignal&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  <BR>  scala&gt;&nbsp;run()
  <SPAN class=output style="COLOR: rgb(90,0,0)">***&nbsp;simulation&nbsp;started,&nbsp;time&nbsp;=&nbsp;0&nbsp;***</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">sum&nbsp;8&nbsp;new-value&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;input2&nbsp;setSignal&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  <BR>  scala&gt;&nbsp;run()
  <SPAN class=output style="COLOR: rgb(90,0,0)">***&nbsp;simulation&nbsp;started,&nbsp;time&nbsp;=&nbsp;8&nbsp;***</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">carry&nbsp;11&nbsp;new-value&nbsp;=&nbsp;true</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">sum&nbsp;15&nbsp;new-value&nbsp;=&nbsp;false</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=18.7></A>18.7 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#18.7">link</A>]</SPAN></H3>
<P>This chapter has brought together two techniques that seem at first disparate: mutable state and higher-order functions. Mutable state was used to simulate physical entities whose state changes over time. Higher-order functions were used in the simulation framework to execute actions at specified points in simulated time. They were also used in the circuit simulations as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">triggers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that associate actions with state changes. Along the way, you saw a simple way to define a domain specific language as a library. That's probably enough for one chapter!</P>
<P>If you feel like staying a bit longer, you might want to try more simulation examples. You can combine half-adders and full-adders to create larger circuits, or design new circuits from the basic gates defined so far and simulate them. In the next chapter, you'll learn about type parameterization in Scala, and see another example in which a combination of functional and imperative approaches yields a good solution.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 18:</H4>
<P><A name=footnote18-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Abstract variables will be explained in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html">Chapter 20</A>.</P>
<P><A name=footnote18-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The names of these "delay" methods start with a capital letter because they represent constants. They are methods so they can be overridden in subclasses. You'll find out how to do the same thing with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#sec:abstract-vals">Section 20.3</A>.</P></DIV>