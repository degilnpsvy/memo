<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 19 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Type Parameterization</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>In this chapter, we'll explain the details of type parameterization in Scala.<A id=i-1818778992-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Along the way we'll demonstrate some of the techniques for information hiding introduced in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html">Chapter 13</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>by means of a concrete example: the design of a class for purely functional queues. We're presenting type parameterization and information hiding together, because information hiding can be used to obtain more general type parameterization variance annotations.</P>
<P>Type parameterization allows you to write generic classes and traits<A id=i-1986667706-1></A><A id=i1515783126-1></A><A id=i1083106947-1></A><A id=i1530367874-1></A>. For example, sets are generic and take a type parameter: they are defined as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set[T]</SPAN><A id=i-906912898-1></A>. As a result, any particular set instance might be a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set[String]</SPAN>, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set[Int]</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>etc.</I>&#8212;but it must be a set of<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">something</EM>. Unlike Java, which allows raw types,<A id=i414933374-1></A><A id=i1163979645-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Scala requires that you specify type parameters. Variance defines inheritance relationships of parameterized types, such as whether a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set[String]</SPAN>, for example, is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set[AnyRef]</SPAN>.</P>
<P>The chapter contains three parts. The first part develops a data structure for purely functional queues. The second part develops techniques to hide internal representation details of this structure. The final part explains variance of type parameters and how it interacts with information hiding.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=19.1></A>19.1 Functional queues<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#19.1">link</A>]</SPAN></H3>
<P>A functional queue is a data structure with three operations:</P>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="">
<TD><SPAN class=code>head</SPAN></TD>
<TD>returns the first element of the queue</TD></TR>
<TR class="">
<TD><SPAN class=code>tail</SPAN></TD>
<TD>returns a queue without its first element</TD></TR>
<TR class="">
<TD><SPAN class=code>append</SPAN></TD>
<TD>returns a new queue with a given element</TD></TR>
<TR class="">
<TD></TD>
<TD>appended at the end</TD></TR></TBODY></TABLE>
<P>Unlike a mutable queue, a functional queue does not change its contents when an element is appended. Instead, a new queue is returned that contains the element. The goal of this chapter will be to create a class, which we'll name<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN>, that works like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;q&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">q:&nbsp;Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;3)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;q1&nbsp;=&nbsp;q&nbsp;append&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">q1:&nbsp;Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;3,&nbsp;4)</SPAN>
  <BR>  scala&gt;&nbsp;q
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;Queue[Int]&nbsp;=&nbsp;Queue(1,&nbsp;2,&nbsp;3)</SPAN>
</PRE>If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>were a mutable implementation, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation in the second input line above would affect the contents of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN>; in fact both the result,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q1</SPAN>, and the original queue,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN>, would contain the sequence<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3,</SPAN>&nbsp;<SPAN class=code>4</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>after the operation. But for a functional queue, the appended value shows up only in the result,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q1</SPAN>, not in the queue,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN>, being operated on. 
<P></P>
<P>Purely functional queues also have some similarity with lists. Both are so called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">fully persistent</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>data structures<A id=i-1691614745-1></A>, where old versions remain available even after extensions or modifications. Both support<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operations. But where a list is usually extended at the front, using a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation, a queue is extended at the end, using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN>.</P>
<P>How can this be implemented efficiently? Ideally, a functional (immutable) queue should not have a fundamentally higher overhead than an imperative (mutable) one. That is, all three operations<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should operate in constant time.</P>
<P>One simple approach to implement a functional queue would be to use a list as representation type. Then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would just translate into the same operations on the list, whereas<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be concatenation. This would give the following implementation:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SlowAppendQueue[T]</SPAN>(elems:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>)&nbsp;{&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Not&nbsp;efficient</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;head&nbsp;=&nbsp;elems.head
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;tail&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SlowAppendQueue</SPAN>(elems.tail)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;append(x:&nbsp;T)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SlowAppendQueue</SPAN>(elems&nbsp;:::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x))
  }
</PRE>The problem with this implementation is in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation. It takes time proportional to the number of elements stored in the queue. If you want constant time append, you could also try to reverse the order of the elements in the representation list, so that the last element that's appended comes first in the list. This would lead to the following implementation:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SlowHeadQueue[T]</SPAN>(smele:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>)&nbsp;{&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Not&nbsp;efficient</SPAN>
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;smele&nbsp;is&nbsp;elems&nbsp;reversed</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;head&nbsp;=&nbsp;smele.last
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;tail&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SlowHeadQueue</SPAN>(smele.init)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;append(x:&nbsp;T)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SlowHeadQueue</SPAN>(x&nbsp;::&nbsp;smele)
  }
</PRE>Now<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is constant time, but<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are not. They now take time proportional to the number of elements stored in the queue. 
<P></P>
<P>Looking at these two examples, it does not seem easy to come up with an implementation that's constant time for all three operations. In fact, it looks doubtful that this is even possible! However, by combining the two operations you can get very close. The idea is to represent a queue by two lists, called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>trailing</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list contains elements towards the front, whereas the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>trailing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list contains elements towards the back of the queue in reversed order. The contents of the whole queue are at each instant equal to "<SPAN class=code>leading</SPAN>&nbsp;<SPAN class=code>:::</SPAN>&nbsp;<SPAN class=code>trailing.reverse</SPAN>".</P>
<P>Now, to append an element, you just cons it to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>trailing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator,<A id=i1411857630-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>so<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is constant time. This means that, when an initially empty queue is constructed from successive<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operations, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>trailing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list will grow whereas the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list will stay empty. Then, before the first<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation is performed on an empty<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list, the whole<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>trailing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list is copied to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN>, reversing the order of the elements. This is done in an operation called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mirror</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:simple-functional-queues">Listing 19.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an implementation of queues that uses this approach.</P>
<P><A name=lst:simple-functional-queues></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[T]</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;leading:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;trailing:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;
  &nbsp;&nbsp;)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;mirror&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(leading.isEmpty)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue</SPAN>(trailing.reverse,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;head&nbsp;=&nbsp;mirror.leading.head
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;tail&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;q&nbsp;=&nbsp;mirror&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue</SPAN>(q.leading.tail,&nbsp;q.trailing)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;append(x:&nbsp;T)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue</SPAN>(leading,&nbsp;x&nbsp;::&nbsp;trailing)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 19.1 - A basic functional queue.</H5>
<P>What is the complexity of this implementation of queues? The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mirror</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation might take time proportional to the number of queue elements, but only if list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is empty. It returns directly if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is non-empty. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mirror</SPAN>, their complexity might be linear in the size of the queue, too. However, the longer the queue gets, the less often<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mirror</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is called. Indeed, assume a queue of length<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>with an empty<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list. Then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mirror</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has to reverse-copy a list of length<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I>. However, the next time<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mirror</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will have to do any work is once the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list is empty again, which will be the case after<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operations. This means one can "charge" each of these<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operations with one<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I>'th of the complexity of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mirror</SPAN>, which means a constant amount of work. Assuming that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operations appear with about the same frequency, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">amortized</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>complexity is hence constant for each operation. So functional queues are asymptotically just as efficient as mutable ones.</P>
<P>Now, there are some caveats that need to be attached to this argument. First, the discussion only was about asymptotic behavior, the constant factors might well be somewhat different. Second, the argument rested on the fact that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are called with about the same frequency. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is called much more often than the other two operations, the argument is not valid, as each call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>might involve a costly re-organization of the list with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mirror</SPAN>. The second caveat can be avoided; it is possible to design functional queues so that in a sequence of successive<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operations only the first one might require a re-organization. You will find out at the end of this chapter how this is done.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=19.2></A>19.2 Information hiding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#19.2">link</A>]</SPAN></H3>
<P>The implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:simple-functional-queues">Listing 19.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is now quite good with regards to<A id=i374717171-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>efficiency. You might object, though, that this efficiency is paid for by exposing a needlessly detailed implementation. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>constructor, which is globally accessible, takes two lists as parameters, where one is reversed&#8212;hardly an intuitive representation of a queue. What's needed is a way to hide this constructor from client code. In this section, we'll show you some ways to accomplish this in Scala.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Private constructors and factory methods</H4>
<P>In Java, you can hide a constructor by making it<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN>. In Scala, the primary constructor does not have an explicit definition;<A id=i2093291082-1></A><A id=i-1528003040-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>it is defined implicitly by the class parameters and body. Nevertheless, it is still possible to hide the primary constructor by adding a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier in front of the class parameter list<A id=i1958480308-1></A>, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:private-constructor">Listing 19.2</A>:</P>
<P><A name=lst:private-constructor></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[T]</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;leading:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;trailing:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>
  &nbsp;&nbsp;)&nbsp;
</PRE>
<H5>Listing 19.2 - Hiding a primary constructor by making it private.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier between the class name and its parameters indicates that the constructor of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is private: it can be accessed only from within the class itself and its companion object<A id=i-861331495-1></A>. The class name<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is still public, so you can use it as a type, but you cannot call its constructor:<A id=i-1604722710-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:6:&nbsp;error:&nbsp;constructor&nbsp;Queue&nbsp;cannot&nbsp;be&nbsp;accessed&nbsp;in&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;object&nbsp;$iw</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Queue(List(1,&nbsp;2),&nbsp;List(3))</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>Now that the primary constructor of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can no longer be called from client code, there needs to be some other way to create new queues. One possibility is to add an auxiliary constructor, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>()&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)&nbsp;
</PRE>The auxiliary constructor shown in the previous example builds an empty queue. As a refinement, the auxiliary constructor could take a list of initial queue elements:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>(elems:&nbsp;T*)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>(elems.toList,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)
</PRE>Recall that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the notation for repeated parameters, as described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#sec:repeated-parameters">Section 8.8</A>. 
<P></P>
<P>Another possibility is to add a factory method that builds a queue from such a sequence of initial elements. A neat way to do this is to define an object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that has the same name as the class being defined and contains an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:apply-factory">Listing 19.3</A>:</P>
<P><A name=lst:apply-factory></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;constructs&nbsp;a&nbsp;queue&nbsp;with&nbsp;initial&nbsp;elements&nbsp;`xs'</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply[T](xs:&nbsp;T*)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[T]</SPAN>(xs.toList,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 19.3 - An<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>factory method in a companion object.</H5>
<P>By placing this object in the same source file as class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN>, you make the object a companion object of the class. You saw in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#sec:access-modifiers">Section 13.4</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that a companion object has the same access rights as its class. Because of this, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can create a new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object, even though the constructor of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is private.</P>
<P>Note that, because the factory method is called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN>, clients can create queues with an expression such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3)</SPAN>. This expression expands to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue.apply(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>since<SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an object instead of a function. As a result,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>looks to clients as if it was a globally defined factory method. In reality, Scala has no globally visible methods; every method must be contained in an object or a class. However, using methods named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>inside global objects, you can support usage patterns that look like invocations of global methods.</P>
<P><A name=lst:type-abstract-functional-queues></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[T]</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;head:&nbsp;T
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;tail:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[T]</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;append(x:&nbsp;T):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[T]</SPAN>
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply[T](xs:&nbsp;T*):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[T]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">QueueImpl[T]</SPAN>(xs.toList,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">QueueImpl[T]</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;leading:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;trailing:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[T]</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;mirror&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(leading.isEmpty)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">QueueImpl</SPAN>(trailing.reverse,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;head:&nbsp;T&nbsp;=&nbsp;mirror.leading.head
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;tail:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">QueueImpl[T]</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;q&nbsp;=&nbsp;mirror
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">QueueImpl</SPAN>(q.leading.tail,&nbsp;q.trailing)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;append(x:&nbsp;T)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">QueueImpl</SPAN>(leading,&nbsp;x&nbsp;::&nbsp;trailing)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 19.4 - Type abstraction for functional queues.</H5>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">An alternative: private classes</H4>
<P>Private constructors and private members are one way to hide the initialization and representation of a class.<A id=i848757295-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Another, more radical way is to hide the class itself and only export a trait that reveals the public interface of the class. The code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:type-abstract-functional-queues">Listing 19.4</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>implements this design. There's a trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN>, which declares the methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN>. All three methods are implemented in a subclass<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>QueueImpl</SPAN>, which is itself a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>inner class of object<A id=i-1543098108-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN>. This exposes to clients the same information as before, but using a different technique. Instead of hiding individual constructors and methods, this version hides the whole implementation class.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=19.3></A>19.3 Variance annotations<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#19.3">link</A>]</SPAN></H3>
<P><A name=sec:first-arrays></A></P>
<P><SPAN class=code>Queue</SPAN>, as defined in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:type-abstract-functional-queues">Listing 19.4</A>, is a trait, but<A id=i1555746715-1></A><A id=i935521398-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>not a type.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not a type because it takes a type parameter. As a result, you cannot create variables of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;doesNotCompile(q:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue</SPAN>)&nbsp;{}
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:5:&nbsp;error:&nbsp;trait&nbsp;Queue&nbsp;takes&nbsp;type&nbsp;parameters</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;doesNotCompile(q:&nbsp;Queue)&nbsp;{}</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>Instead, trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>enables you to specify<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">parameterized</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>types, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[String]</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[Int]</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[AnyRef]</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;doesCompile(q:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[AnyRef]</SPAN>)&nbsp;{}
  <SPAN class=output style="COLOR: rgb(90,0,0)">doesCompile:&nbsp;(Queue[AnyRef])Unit</SPAN>
</PRE>
<P></P>
<P>Thus,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a trait, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a type.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is also called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">type constructor</EM>,<A id=i1905256393-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>because with it you can construct a type by specifying a type parameter. (This is analogous to constructing an object instance with a plain-old constructor by specifying a value parameter.) The type constructor<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>"generates" a family of types, which includes<SPAN class=code>Queue[Int]</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[String]</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[AnyRef]</SPAN>.</P>
<P>You can also say that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">generic</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait.<A id=i1530367874-2></A><A id=i-1356826384-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>(Classes and traits that take type parameters are "generic," but the types they generate are "parameterized," not generic.) The term "generic" means that you are defining many specific types with one generically written class or trait. For example, trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:type-abstract-functional-queues">Listing 19.4</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>defines a generic queue.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[Int]</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[String]</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>etc.</I>, would be the specific queues.</P>
<P>The combination of type parameters and subtyping poses some interesting questions.<A id=i-1780437500-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, are there any special subtyping relationships between members of the family of types generated by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[T]</SPAN>? More specifically, should a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>be considered a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[AnyRef]</SPAN>? Or more generally, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>S</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>, then should<SPAN class=code>Queue[S]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>be considered a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[T]</SPAN>? If so, you could say that trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g1865839257"><EM style="FONT-STYLE: italic">covariant</EM></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>(or "flexible") in its type parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><A id=i2006441693-1></A>. Or, since it just has one type parameter, you could say simply that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN>s are covariant. Covariant<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN>s would mean, for example, that you could pass a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>doesCompile</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method shown previously, which takes a value parameter of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[AnyRef]</SPAN>.</P>
<P>Intuitively, all this seems OK, since a queue of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>s looks like a special case of a queue of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>s. In Scala, however, generic types have by default<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-233237224"><EM style="FONT-STYLE: italic">nonvariant</EM></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>(or, "rigid") subtyping<A id=i1359580222-1></A>. That is, with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defined as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:type-abstract-functional-queues">Listing 19.4</A>, queues with different element types would never be in a subtype relationship. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would not be usable as a<SPAN class=code>Queue[AnyRef]</SPAN>. However, you can demand covariant (flexible) subtyping of queues by changing the first line of the definition of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[+T]</SPAN>&nbsp;{&nbsp;...&nbsp;}
</PRE>Prefixing a formal type parameter with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>indicates that subtyping is covariant (flexible) in that parameter<A id=i-1315578930-1></A>. By adding this single character, you are telling Scala that you want<SPAN class=code>Queue[String]</SPAN>, for example, to be considered a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[AnyRef]</SPAN>. The compiler will check that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined in a way that this subtyping is sound. 
<P></P>
<P>Besides<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>, there is also a prefix<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN>, which indicates<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-1356412796"><EM style="FONT-STYLE: italic">contravariant</EM></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>subtyping<A id=i973833207-1></A><A id=i900875858-1></A>. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>were defined like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[-T]</SPAN>&nbsp;{&nbsp;...&nbsp;}&nbsp;
</PRE>then if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>S</SPAN>, this would imply that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[S]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(which in the case of queues would be rather surprising!). Whether a type parameter is covariant, contravariant, or nonvariant is called the parameter's<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-1249575311"><EM style="FONT-STYLE: italic">variance</EM></A><A id=i-1249575311-1></A>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>symbols you can place next to type parameters are called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">variance annotations</EM>.<A id=i1554444807-1></A> 
<P></P>
<P>In a purely functional world, many types are naturally covariant (flexible). However, the situation changes once you introduce mutable data. To find out why, consider the simple type of one-element cells that can be read or written, shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:nonvariant-cell">Listing 19.5</A>.<A name=lst:nonvariant-cell></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cell[T]</SPAN>(init:&nbsp;T)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>[<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>]&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;current&nbsp;=&nbsp;init
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;get&nbsp;=&nbsp;current
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;set(x:&nbsp;T)&nbsp;{&nbsp;current&nbsp;=&nbsp;x&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 19.5 - A nonvariant (rigid)<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:nonvariant-cell">Listing 19.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is declared nonvariant (rigid). For the sake of argument, assume for a moment that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was declared covariant instead&#8212;<I>i.e.</I>, it was declared<SPAN class=code>class</SPAN>&nbsp;<SPAN class=code>Cell[+T]</SPAN>&#8212;and that this passed the Scala compiler. (It doesn't, and we'll explain why shortly.) Then you could construct the following problematic statement sequence:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;c1&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cell[String]</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc"</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;c2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cell[Any]</SPAN>&nbsp;=&nbsp;c1
  c2.set(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=&nbsp;c1.get&nbsp;
</PRE>Seen by itself, each of these four lines looks OK. The first line creates a cell of strings and stores it in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>c1</SPAN>. The second line defines a new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>c2</SPAN>, of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell[Any]</SPAN>, which initialized with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>c1</SPAN>. This is OK, since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN>s are assumed to be covariant. The third line sets the value of cell<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>c2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to 1. This is also OK, because the assigned value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an instance of<SPAN class=code>c2</SPAN>'s element type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>. Finally, the last line assigns the element value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>c1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into a string. Nothing strange here, as both the sides are of the same type. But taken together, these four lines end up assigning the integer<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s</SPAN>. This is clearly a violation of type soundness. 
<P></P>
<P>Which operation is to blame for the runtime fault? It must be the second one, which uses covariant subtyping. The other statements are too simple and fundamental. Thus, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">not</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>also a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>, because there are things you can do with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that you cannot do with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>. You cannot use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument on a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=code>String</SPAN>, for example.</P>
<P>In fact, were you to pass the covariant version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the Scala compiler, you would get a compile-time error:<A id=i-1072664655-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Cell.scala:7:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;T&nbsp;of&nbsp;value&nbsp;x</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;def&nbsp;set(x:&nbsp;T)&nbsp;=&nbsp;current&nbsp;=&nbsp;x</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Variance and arrays</H4>
<P>It's interesting to compare this behavior with arrays in Java. In principle, arrays are just like cells except that they can have more than one element. Nevertheless, arrays are treated as covariant in Java. You can try an example analogous to the cell interaction above with Java arrays:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  //&nbsp;this&nbsp;is&nbsp;Java
  String[]&nbsp;a1&nbsp;=&nbsp;{&nbsp;"abc"&nbsp;};
  Object[]&nbsp;a2&nbsp;=&nbsp;a1;
  a2[0]&nbsp;=&nbsp;new&nbsp;Integer(17);
  String&nbsp;s&nbsp;=&nbsp;a1[0];
</PRE>If you try out this example, you will find that it compiles, but executing the program will cause an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayStore</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>exception to be thrown when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a2[0]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is assigned to an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Integer</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Exception&nbsp;in&nbsp;thread&nbsp;"main"&nbsp;java.lang.ArrayStoreException:&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">java.lang.Integer</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;JavaArrays.main(JavaArrays.java:8)</SPAN>
</PRE>What happens here is that Java stores the element type of the array at runtime. Then, every time an array element is updated, the new element value is checked against the stored type. If it is not an instance of that type, an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayStore</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>exception is thrown.<A id=i1807481219-1></A> 
<P></P>
<P>You might ask why Java adopted this design, which seems both unsafe and expensive. When asked this question, James Gosling,<A id=i1512661551-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>the principal inventor of the Java language, answered that they wanted to have a simple means to treat arrays generically. For instance, they wanted to be able to write a method to sort all elements of an array, using a signature like the following that takes an array of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Object</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  void&nbsp;sort(<SPAN class=typename style="COLOR: rgb(103,0,154)">Object[]</SPAN>&nbsp;a,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Comparator</SPAN>&nbsp;cmp)&nbsp;{&nbsp;...&nbsp;}
</PRE>Covariance of arrays was needed so that arrays of arbitrary reference types could be passed to this<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. Of course, with the arrival of Java generics, such a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method can now be written with a type parameter, so the covariance of arrays is no longer necessary<A id=i1590614948-1></A>. For compatibility reasons, though, it has persisted in Java to this day. 
<P></P>
<P>Scala tries to be purer than Java in not treating arrays as covariant. Here's what you get if you translate the first two lines of the array example to Scala:<A id=i-677980410-3></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;a1&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">a1:&nbsp;Array[java.lang.String]&nbsp;=&nbsp;Array(abc)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;a2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[Any]</SPAN>&nbsp;=&nbsp;a1
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:5:&nbsp;error:&nbsp;type&nbsp;mismatch;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Array[java.lang.String]</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;required:&nbsp;Array[Any]</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;a2:&nbsp;Array[Any]&nbsp;=&nbsp;a1</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>What happened here is that Scala treats arrays as nonvariant (rigid), so an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not considered to conform to an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[Any]</SPAN>. However, sometimes it is necessary to interact with legacy methods in Java that use an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Object</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>array as a means to emulate a generic array. For instance, you might want to call a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method like the one described previously with an array of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>s as argument. To make this possible, Scala lets you cast an array of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>s to an array of any supertype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;a2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[Object]</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1.asInstanceOf[<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[Object]</SPAN>]
  <SPAN class=output style="COLOR: rgb(90,0,0)">a2:&nbsp;Array[java.lang.Object]&nbsp;=&nbsp;Array(abc)</SPAN>
</PRE>The cast is always legal at compile-time, and it will always succeed at run-time, because the JVM's underlying run-time model treats arrays as covariant, just as Java the language does. But you might get<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayStore</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>exceptions afterwards, again just as you would in Java. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=19.4></A>19.4 Checking variance annotations<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#19.4">link</A>]</SPAN></H3>
<P>Now that you have seen some examples where variance is unsound, you<A id=i-245097893-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>may be wondering which kind of class definitions need to be rejected and which can be accepted. So far, all violations of type soundness involved some reassignable field or array element. The purely functional implementation of queues, on the other hand, looks like a good candidate for covariance. However, the following example shows that you can "engineer" an unsound situation even if there is no reassignable field.</P>
<P>To set up the example, assume that queues as defined in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:type-abstract-functional-queues">Listing 19.4</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>are covariant. Then, create a subclass of queues that specializes the element type to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and overrides the<SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">StrangeIntQueue</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[Int]</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;append(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(Math.sqrt(x))
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">super</SPAN>.append(x)
  &nbsp;&nbsp;}
  }
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>StrangeIntQueue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>prints out the square root of its (integer) argument before doing the append proper. Now, you can write a counterexample in two lines:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[Any]</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">StrangeIntQueue</SPAN>
  x.append(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc"</SPAN>)
</PRE>The first of these two lines is valid, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>StrangeIntQueue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[Int]</SPAN>, and, assuming covariance of queues,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[Int]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[Any]</SPAN>. The second line is valid because you can append a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[Any]</SPAN>. However, taken together these two lines have the effect of applying a square root method to a string, which makes no sense. 
<P></P>
<P>Clearly it's not just mutable fields that make covariant types unsound. The problem is more general. It turns out that as soon as a generic parameter type appears as the type of a method parameter, the containing class or trait may not be covariant in that type parameter. For queues, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method violates this condition:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[+T]</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;append(x:&nbsp;T)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;...
  }
</PRE>Running a modified queue class like the one above through a Scala compiler would yield:<A id=i-1072664655-2></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Queues.scala:11:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;T&nbsp;of&nbsp;value&nbsp;x</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;def&nbsp;append(x:&nbsp;T)&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P>Reassignable fields are a special case of the rule that disallows type parameters annotated with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from being used as method parameter types. As mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#sec:properties">Section 18.2</A>, a reassignable field, "<SPAN class=code>var</SPAN>&nbsp;<SPAN class=code>x:</SPAN>&nbsp;<SPAN class=code>T</SPAN>", is treated in Scala as a getter method, "<SPAN class=code>def</SPAN>&nbsp;<SPAN class=code>x:</SPAN>&nbsp;<SPAN class=code>T</SPAN>", and a setter method, "<SPAN class=code>def</SPAN>&nbsp;<SPAN class=code>x_=(y:</SPAN>&nbsp;<SPAN class=code>T)</SPAN>"<A id=i-1969580643-2></A>. As you can see, the setter method has a parameter of the field's type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. So that type may not be covariant.</P>
<DIV class=pointofinterest>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">The fast track</H3>
<P>In the rest of this section, we'll describe the mechanism by which the Scala compiler checks variance annotations. If you're not interested in such detail right now, you can safely skip to<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#sec:lower-bounds">Section 19.5</A>. The most important thing to understand is that the Scala compiler will check any variance annotations you place on type parameters. For example, if you try to declare a type parameter to be covariant (by adding a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>), but that could lead to potential runtime errors, your program won't compile.</P></DIV>
<P>To verify correctness of variance annotations, the Scala compiler classifies all positions in a class or trait body as<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">positive</EM>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">negative</EM>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">neutral</EM>. A "position" is any location in the class (or trait, but from now on we'll just write "class") body where a type parameter may be used. Every method value parameter is a position, for example, because a method value parameter has a type, and therefore a type parameter could appear in that position. The compiler checks each use of each of the class's type parameters. Type parameters annotated with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>may only be used in positive positions, while type parameters annotated with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>may only be used in negative positions. A type parameter with no variance annotation may be used in any position, and is, therefore, the only kind of type parameter that can be used in neutral positions of the class body.</P>
<P>To classify the positions, the compiler starts from the declaration of a type parameter and then moves inward through deeper nesting levels. Positions at the top level of the declaring class are classified as positive. By default, positions at deeper nesting levels are classified the same as that at enclosing levels, but there are a handful of exceptions where the classification changes. Method value parameter positions are classified to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">flipped</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>classification relative to positions outside the method, where the flip of a positive classification is negative, the flip of a negative classification is positive, and the flip of a neutral classification is still neutral.</P>
<P>Besides method value parameter positions, the current classification is also flipped at the type parameters of methods. A classification is sometimes flipped at the type argument position of a type, such as the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Arg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C[Arg]</SPAN>, depending on the variance of the corresponding type parameter. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN>'s type parameter is annotated with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>then the classification stays the same. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN>'s type parameter is annotated with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN>, then the current classification is flipped. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN>'s type parameter has no variance annotation then the current classification is changed to neutral.</P>
<P>As a somewhat contrived example, consider the following class definition, where the variance of several positions is annotated with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>^+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(for positive) or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>^-</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(for negative):</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cat[-T, +U]</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;meow[W^-](volume:&nbsp;T^-,&nbsp;listener:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cat[U^+, T^-]</SPAN>^-)
  &nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cat[Cat[U^+, T^-]^-, U^+]</SPAN>^+
  }
</PRE>
<P></P>
<P>The positions of the type parameter,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>W</SPAN>, and the two value parameters,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>volume</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>listener</SPAN>, are all negative. Looking at the result type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>meow</SPAN>, the position of the first<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat[U,</SPAN>&nbsp;<SPAN class=code>T]</SPAN>argument is negative, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat</SPAN>'s first type parameter,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>, is annotated with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN>. The type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>inside this argument is again in positive position (two flips), whereas the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>inside that argument is still in negative position.</P>
<P>You see from this discussion that it's quite hard to keep track of variance positions. That's why it's a welcome relief that the Scala compiler does this job for you.</P>
<P>Once the variances are computed, the compiler checks that each type parameter is only used in positions that are classified appropriately. In this case,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is only used in negative positions, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is only used in positive positions. So class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is type correct.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=19.5></A>19.5 Lower bounds<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#19.5">link</A>]</SPAN></H3>
<P><A name=sec:lower-bounds></A></P>
<P>Back to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. You saw that the previous definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:type-abstract-functional-queues">Listing 19.4</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>cannot be made covariant in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>appears as a type of a parameter of the<SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, and that's a negative position.</P>
<P>Fortunately, there's a way to get unstuck: you can generalize the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method by making it polymorphic (<I>i.e.</I>, giving the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method itself a type parameter) and using a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">lower bound</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>for its type parameter.<A id=i1770535476-1></A><A id=i1742340276-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:lower-bound">Listing 19.6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a new formulation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that implements this idea.</P>
<P><A name=lst:lower-bound></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[+T]</SPAN>&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;leading:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;trailing:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;append[U&nbsp;&gt;:&nbsp;T](x:&nbsp;U)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[U]</SPAN>(leading,&nbsp;x&nbsp;::&nbsp;trailing)&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;...</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 19.6 - A type parameter with a lower bound.</H5>
<P>The new definition gives<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>a type parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN>, and with the syntax, "<SPAN class=code>U</SPAN>&nbsp;<SPAN class=code>&gt;:</SPAN>&nbsp;<SPAN class=code>T</SPAN>", defines<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as the lower bound for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN>. As a result,<A id=i-451541202-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is required to be a supertype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#footnote19-1">[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The parameter to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is now of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>, and the return value of the method is now<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[U]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[T]</SPAN>.</P>
<P>As an example, suppose there is a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with two subclasses,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Orange</SPAN>. With the new definition of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN>, it is possible to append an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Orange</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to a<SPAN class=code>Queue[Apple]</SPAN>. The result will be a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[Fruit]</SPAN>.</P>
<P>This revised definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is type correct. Intuitively, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a more specific type than expected (for example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruit</SPAN>), a call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will still work, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN>(<SPAN class=code>Fruit</SPAN>) will still be a supertype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<SPAN class=code>Apple</SPAN>).<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#footnote19-2">[2]</A></P>
<P>The new definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is arguably better than the old one, because it is more general. Unlike the old version, the new definition allows you to append an arbitrary supertype<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN>of the queue element type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. The result is then a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue[U]</SPAN>. Together with queue covariance, this gives the right kind of flexibility for modeling queues of different element types in a natural way.</P>
<P>This shows that variance annotations and lower bounds play well together. They are a good example of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">type-driven design</SPAN>, where the types of an interface guide its detailed design and implementation<A id=i819829841-1></A>. In the case of queues, you would probably not have thought of the refined implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a lower bound, but you might have decided to make queues covariant. In that case, the compiler would have pointed out the variance error for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN>. Correcting the variance error by adding a lower bound makes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN>more general and queues as a whole more usable.</P>
<P>This observation is also the main reason that Scala prefers declaration-site variance over use-site variance as it is found in Java's wildcards.<A id=i358663587-1></A><A id=i1971613366-1></A><A id=i-364469185-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>With use-site variance, you are on your own designing a class. It will be the clients of the class that need to put in the wildcards, and if they get it wrong, some important instance methods will no longer be applicable. Variance being a tricky business, users usually get it wrong, and they come away thinking that wildcards and generics are overly complicated. With definition-side variance, you express your intent to the compiler, and the compiler will double check that the methods you want available will indeed be available.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=19.6></A>19.6 Contravariance<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#19.6">link</A>]</SPAN></H3>
<P>So far in this chapter, all examples you've seen were either covariant or nonvariant. But there are also cases where contravariance is natural.<A id=i900875858-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For instance, consider the trait of output channels shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:contravariant-output-channel">Listing 19.7</A>:<A name=lst:contravariant-output-channel></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">OutputChannel[-T]</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;write(x:&nbsp;T)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 19.7 - A contravariant output channel.</H5>
<P>Here,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>OutputChannel</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined to be contravariant in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. So an output channel of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>s, say, is a subtype of an output channel of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>s. Although it may seem non-intuitive, it actually makes sense. To see why, consider what you can do with an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>OutputChannel[String]</SPAN>. The only supported operation is writing a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to it. The same operation can also be done on an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>OutputChannel[AnyRef]</SPAN>. So it is safe to substitute an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>OutputChannel[AnyRef]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>OutputChannel[String]</SPAN>. By contrast, it would not be safe to substitute an<SPAN class=code>OutputChannel[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>where an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>OutputChannel[AnyRef]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is required. After all, you can send any object to an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>OutputChannel[AnyRef]</SPAN>, whereas an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>OutputChannel[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>requires that the written values are all strings.</P>
<P>This reasoning points to a general principle in type system design: it is safe to assume that a type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of a type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if you can substitute a value of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>wherever a value of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is required. This is called the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">Liskov Substitution Principle</SPAN><A id=i1033900893-1></A>. The principle holds if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>supports the same operations as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and all of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>'s operations require less and provide more than the corresponding operations in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN>. In the case of output channels, an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>OutputChannel[AnyRef]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be a subtype of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>OutputChannel[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>because the two support the same<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>write</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation, and this operation requires less in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>OutputChannel[AnyRef]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>than in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>OutputChannel[String]</SPAN>. "Less" means the argument is only required to be an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the first case, whereas it is required to be a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the second case.</P>
<P>Sometimes covariance and contravariance are mixed in the same type. A prominent example is Scala's function traits. For instance, whenever you write the function type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>B</SPAN>, Scala expands this to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function1[A,</SPAN>&nbsp;<SPAN class=code>B]</SPAN>. The definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the standard library uses both covariance and contravariance: the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait is contravariant in the function argument type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>S</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and covariant in the result type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>,<A id=i-921885027-1></A><A id=i-1806331359-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:function-variance">Listing 19.8</A>. This satisfies the Liskov substitution principle, because arguments are something that's required, whereas results are something that's provided.</P>
<P><A name=lst:function-variance></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Function1[-S, +T]</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(x:&nbsp;S):&nbsp;T
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 19.8 - Covariance and contravariance of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function1</SPAN>s.</H5>
<P>As an example, consider the application shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:parrot-contravariance">Listing 19.9</A>. In this example, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Publication</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains one parametric field,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>title</SPAN>, of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>. Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Book</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>extends<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Publication</SPAN>and forwards its string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>title</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter to the constructor of its superclass. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Library</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>singleton object defines a set of books and a method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printBookList</SPAN>, which takes a function, named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>info</SPAN>, of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Book</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>AnyRef</SPAN>. In other words, the type of the lone parameter to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printBookList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a function that takes one<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Book</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument and returns an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>. The<SPAN class=code>Customer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>application defines a method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getTitle</SPAN>, which takes a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Publication</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as its lone parameter and returns a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>, the title of the passed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Publication</SPAN>.</P>
<P><A name=lst:parrot-contravariance></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Publication</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;title:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Book</SPAN>(title:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Publication</SPAN>(title)
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Library</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;books:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set[Book]</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Book</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Programming&nbsp;in&nbsp;Scala"</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Book</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Walden"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;printBookList(info:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Book</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AnyRef</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(book&nbsp;&lt;-&nbsp;books)&nbsp;println(info(book))
  &nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Customer</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Application</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;getTitle(p:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Publication</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=&nbsp;p.title
  &nbsp;&nbsp;&nbsp;Library.printBookList(getTitle)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 19.9 - Demonstration of function type parameter variance.</H5>
<P>Now take a look at the last line in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Customer</SPAN>. This line invokes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Library</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printBookList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method and passes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getTitle</SPAN>, wrapped in a function value:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  Library.printBookList(getTitle)
</PRE>This line of code type checks even though<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>, the function's result type, is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>, the result type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printBookList</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>info</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter. This code passes the compiler because function result types are declared to be covariant (the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:function-variance">Listing 19.8</A>). If you look inside the body of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printBookList</SPAN>, you can get a glimpse of why this makes sense. 
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printBookList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method iterates through its book list, and invokes the passed function on each book. It passes the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>result returned by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>info</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println</SPAN>, which invokes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN>on it and prints the result. This activity will work with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as well as any other subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>, which is what covariance of function result types means.</P>
<P>Now consider the parameter type of the function being passed to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printBookList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. Although<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printBookList</SPAN>'s parameter type is declared as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Book</SPAN>, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getTitle</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>we're passing in takes a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Publication</SPAN>, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">supertype</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Book</SPAN><A id=i-331888331-1></A>. The reason this works is that since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printBookList</SPAN>'s parameter type is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Book</SPAN>, the body of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>printBookList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method will only be allowed to pass a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Book</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into the function. And because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getTitle</SPAN>'s parameter type is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Publication</SPAN>, the body of that function will only be able to access on its parameter,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>, members that are declared in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Publication</SPAN>. Because any method declared in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Publication</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is also available on its subclass<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Book</SPAN>, everything should work, which is what contravariance of function parameter types means. You can see all this graphically in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#fig:contravariance">Figure 19.1</A>.</P>
<P>The code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:parrot-contravariance">Listing 19.9</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>compiles because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Publication</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Book</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>AnyRef</SPAN>, as shown in the center of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#fig:contravariance">Figure 19.1</A>. Because the result type of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function1</SPAN>is defined as covariant, the inheritance relationship of the two result types, shown at the right of the diagram, is in the same direction as that of the two functions shown in the center. By contrast, because the parameter type of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined as contravariant, the inheritance relationship of the two parameter types, shown at the left of the diagram, is in the opposite direction as that of the two functions.</P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:contravariance></A>
<P><IMG alt="image images/variance.jpg" src="http://www.artima.com/pins1ed/images/variance.jpg"></P></DIV>
<H5>Figure 19.1 - Covariance and contravariance in function type parameters.</H5>
<P><A name=lst:optimized-functional-queues></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[+T]</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>[<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>]&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;leading:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>[<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>]&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;trailing:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>
  &nbsp;&nbsp;)&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;mirror()&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(leading.isEmpty)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">while</SPAN>&nbsp;(!trailing.isEmpty)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leading&nbsp;=&nbsp;trailing.head&nbsp;::&nbsp;leading
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trailing&nbsp;=&nbsp;trailing.tail
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;head:&nbsp;T&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mirror()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leading.head&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;tail:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[T]</SPAN>&nbsp;=&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mirror()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue</SPAN>(leading.tail,&nbsp;trailing)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;append[U&nbsp;&gt;:&nbsp;T](x:&nbsp;U)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Queue[U]</SPAN>(leading,&nbsp;x&nbsp;::&nbsp;trailing)
  &nbsp;&nbsp;}</PRE>
<H5>Listing 19.10 - An optimized functional queue.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=19.7></A>19.7 Object private data<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#19.7">link</A>]</SPAN></H3>
<P><A name=variance-object-local></A></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class seen so far has a problem in that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mirror</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation might repeatedly copy the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>trailing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is called several times in a row on a list where<SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is empty. The wasteful copying could be avoided by adding some judicious side effects.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:optimized-functional-queues">Listing 19.10</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>presents a new implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN>, which performs at most one<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>trailing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>adjustment for any sequence of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operations.</P>
<P>What's different with respect to the previous version is that now<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>trailing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are reassignable variables, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mirror</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>performs the reverse copy from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>trailing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a side-effect on the current queue instead of returning a new queue. This side-effect is purely internal to the implementation of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation; since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>trailing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are private variables, the effect is not visible to clients of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN>. So by the terminology established in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html">Chapter 18</A>, the new version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Queue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>still defines purely functional objects, in spite of the fact that they now contain reassignable fields.</P>
<P>You might wonder whether this code passes the Scala type checker. After all, queues now contain two reassignable fields of the covariant parameter type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. Is this not a violation of the variance rules? It would be indeed, except for the detail that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>leading</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>trailing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>have a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private[this]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier and are thus declared to be object private.</P>
<P>As mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#sec:access-modifiers">Section 13.4</A>, object private members can be accessed only from within the object in which they are defined. It turns out that accesses to variables from the same object in which they are defined do not cause problems with variance. The intuitive explanation is that, in order to construct a case where variance would lead to type errors, you need to have a reference to a containing object that has a statically weaker type than the type the object was defined with. For accesses to object private values, however, this is impossible.</P>
<P>Scala's variance checking rules contain a special case for object private definitions.<A id=i-245097893-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Such definitions are omitted when it is checked that a type parameter with either a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN>annotation occurs only in positions that have the same variance classification. Therefore, the code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:optimized-functional-queues">Listing 19.10</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>compiles without error. On the other hand, if you had left out the<SPAN class=code>[this]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>qualifiers from the two<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifiers, you would see two type errors:<A id=i-517711887-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Queues.scala:1:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;List[T]&nbsp;of&nbsp;parameter&nbsp;of</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">setter&nbsp;leading_=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">class&nbsp;Queue[+T]&nbsp;private&nbsp;(private&nbsp;var&nbsp;leading:&nbsp;List[T],</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Queues.scala:1:&nbsp;error:&nbsp;covariant&nbsp;type&nbsp;T&nbsp;occurs&nbsp;in&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">contravariant&nbsp;position&nbsp;in&nbsp;type&nbsp;List[T]&nbsp;of&nbsp;parameter&nbsp;of</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">setter&nbsp;trailing_=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;var&nbsp;trailing:&nbsp;List[T])&nbsp;{</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=19.8></A>19.8 Upper bounds<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#19.8">link</A>]</SPAN></H3>
<P><A name=sec:upper-bounds></A></P>
<P>In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#lst:merge-sort-function">Listing 16.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#lst:merge-sort-function">here</A>, we showed a merge sort function for lists that took a comparison function as a first argument and a list to sort as a second, curried argument.<A id=i-1812239373-1></A><A id=i1036774557-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Another way you might want to organize such a sort function is by requiring the type of the list to mix in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait. As mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#sec:the-ordered-trait">Section 12.4</A>, by mixing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into a class and implementing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN>'s one abstract method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>compare</SPAN>, you<A id=i1970675952-2></A><A id=i2068605051-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>enable clients to compare instances of that class with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;=</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;=</SPAN>. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:ordered-person">Listing 19.11</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN>being mixed into a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Person</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. As a result, you can compare two persons like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;robert&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Robert"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Jones"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">robert:&nbsp;Person&nbsp;=&nbsp;Robert&nbsp;Jones</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;sally&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Sally"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Smith"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">sally:&nbsp;Person&nbsp;=&nbsp;Sally&nbsp;Smith</SPAN>
  <BR>  scala&gt;&nbsp;robert&nbsp;&lt;&nbsp;sally
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>
<P></P>
<P><A name=lst:ordered-person></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;firstName:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;lastName:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ordered[Person]</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;compare(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>)&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;lastNameComparison&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastName.compareToIgnoreCase(that.lastName)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(lastNameComparison&nbsp;!=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastNameComparison
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstName.compareToIgnoreCase(that.firstName)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;firstName&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>+&nbsp;lastName
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 19.11 - A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Person</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class that mixes in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait.</H5>
<P><A name=lst:upper-bound-sort></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;orderedMergeSort[T&nbsp;&lt;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ordered[T]</SPAN>](xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;merge(xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>,&nbsp;ys:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(xs,&nbsp;ys)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>,&nbsp;_)&nbsp;=&gt;&nbsp;ys
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;(_,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)&nbsp;=&gt;&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;(x&nbsp;::&nbsp;xs1,&nbsp;y&nbsp;::&nbsp;ys1)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;&lt;&nbsp;y)&nbsp;x&nbsp;::&nbsp;merge(xs1,&nbsp;ys)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;y&nbsp;::&nbsp;merge(xs,&nbsp;ys1)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;n&nbsp;=&nbsp;xs.length&nbsp;/&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(n&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;xs
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;(ys,&nbsp;zs)&nbsp;=&nbsp;xs&nbsp;splitAt&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;merge(orderedMergeSort(ys),&nbsp;orderedMergeSort(zs))
  &nbsp;&nbsp;}
  }
</PRE>
<H5>Listing 19.12 - A merge sort function with an upper bound.</H5>
<P>To require that the type of the list passed to your new sort function mixes in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN>, you need to<A id=i1309914799-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>use an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">upper bound</EM>. An upper bound is specified similar to a lower bound, except instead of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;:</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>symbol used for lower bounds, you use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;:</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>symbol, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:upper-bound-sort">Listing 19.12</A>. With the "<SPAN class=code>T</SPAN>&nbsp;<SPAN class=code>&lt;:</SPAN>&nbsp;<SPAN class=code>Ordered[T]</SPAN>" syntax, you indicate that the type parameter,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>, has an upper bound,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered[T]</SPAN>. This means that the element type of the list passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderedMergeSort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>must be a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN>. Thus, you could pass a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Person]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=code>orderedMergeSort</SPAN>, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Person</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>mixes in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN>. For example, consider this list:<A id=i1588987823-1></A><A id=i-604737946-1></A><A id=i717131072-1></A><A id=i438821039-2></A><A id=i2020741259-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;people&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Larry"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Wall"</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Anders"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hejlsberg"</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Guido"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"van&nbsp;Rossum"</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Alan"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Kay"</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Person</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Yukihiro"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Matsumoto"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <SPAN class=output style="COLOR: rgb(90,0,0)">people:&nbsp;List[Person]&nbsp;=&nbsp;List(Larry&nbsp;Wall,&nbsp;Anders&nbsp;Hejlsberg,</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Guido&nbsp;van&nbsp;Rossum,&nbsp;Alan&nbsp;Kay,&nbsp;Yukihiro&nbsp;Matsumoto)</SPAN>
</PRE>Because the element type of this list,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Person</SPAN>, mixes in (and is therefore a subtype of)<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered[People]</SPAN>, you can pass the list to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderedMergeSort</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;sortedPeople&nbsp;=&nbsp;orderedMergeSort(people)
  <SPAN class=output style="COLOR: rgb(90,0,0)">sortedPeople:&nbsp;List[Person]&nbsp;=&nbsp;List(Anders&nbsp;Hejlsberg,&nbsp;Alan&nbsp;Kay,</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Yukihiro&nbsp;Matsumoto,&nbsp;Guido&nbsp;van&nbsp;Rossum,&nbsp;Larry&nbsp;Wall)</SPAN>
</PRE>
<P></P>
<P>Now, although the sort function shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#lst:upper-bound-sort">Listing 19.12</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>serves as a useful illustration of upper bounds, it isn't actually the most general way in Scala to design a sort function that takes advantage the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait. For example, you couldn't use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orderedMergeSort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function to sort a list of integers, because class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered[Int]</SPAN>:<A id=i-1803074733-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;wontCompile&nbsp;=&nbsp;orderedMergeSort(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:5:&nbsp;error:&nbsp;inferred&nbsp;type&nbsp;arguments&nbsp;[Int]&nbsp;do</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;not&nbsp;conform&nbsp;to&nbsp;method&nbsp;orderedMergeSort's&nbsp;type</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parameter&nbsp;bounds&nbsp;[T&nbsp;&lt;:&nbsp;Ordered[T]]</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;wontCompile&nbsp;=&nbsp;orderedMergeSort(List(3,&nbsp;2,&nbsp;1))</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#sec:view-bounds">Section 21.6</A>, we'll show you how to use<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">implicit parameters</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">view bounds</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>to achieve a more general solution.<A id=i-568821387-1></A><A id=i-427110256-1></A></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=19.9></A>19.9 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#19.9">link</A>]</SPAN></H3>
<P>In this chapter you saw several techniques for information hiding: private constructors, factory methods, type abstraction, and object private members. You also learned how to specify data type variance and what it implies for class implementation. Finally, you saw two techniques which help in obtaining flexible variance annotations: lower bounds for method type parameters, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private[this]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>annotations for local fields and methods.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 19:</H4>
<P><A name=footnote19-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Supertype and subtype relationships are reflexive, which means a type is both a supertype and a subtype of itself. Even though<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a lower bound for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN>, you could still pass in a<SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN>.</P>
<P><A name=footnote19-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Technically, what happens is a flip occurs for lower bounds. The type parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in a negative position (1 flip), while the lower bound (<SPAN class=code>&gt;:</SPAN>&nbsp;<SPAN class=code>T</SPAN>) is in a positive position (2 flips).</P></DIV>