<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 26 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Working with XML</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>This chapter introduces Scala's support for XML.<A id=i87031-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>After discussing semi-structured data<A id=i-408699718-1></A><A id=i-158920554-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in general, it shows the essential functionality in Scala for manipulating XML: how to make nodes with XML literals, how to save and load XML to files, and how to take apart XML nodes using query methods and pattern matching. This chapter is just a brief introduction to what is possible with XML, but it shows enough to get you started.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=26.1></A>26.1 Semi-structured data<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-xml.html#26.1">link</A>]</SPAN></H3>
<P>XML is a form of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-408699718"><EM style="FONT-STYLE: italic">semi-structured data</EM></A>. It is more structured than plain strings, because it organizes the contents of the data into a tree. Plain XML is less structured than the objects of a programming language, though, as it admits free-form text between tags and it lacks a type system.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-xml.html#footnote26-1">[1]</A></P>
<P>Semi-structured data is very helpful any time you need to serialize program data for saving in a file or shipping across a network. Instead of converting structured data all the way down to bytes, you convert it to and from semi-structured data. You then use pre-existing library routines to convert between semi-structured data and binary data, saving your time for more important problems.</P>
<P>There are many forms of semi-structured data, but XML is the most widely used on the Internet. There are XML tools on most operating systems, and most programming languages have XML libraries available. Its popularity is self-reinforcing. The more tools and libraries are developed in response to XML's popularity, the more likely software engineers are to choose XML as part of their formats. If you write software that communicates over the Internet, then sooner or later you will need to interact with some service that speaks XML.</P>
<P>For all of these reasons, Scala includes special support for processing XML. This chapter shows you Scala's support for constructing XML, processing it with regular methods, and processing it with Scala's pattern matching. In addition to these nuts and bolts, the chapter shows along the way several common idioms for using XML in Scala.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=26.2></A>26.2 XML overview<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-xml.html#26.2">link</A>]</SPAN></H3>
<P>XML is built out of two basic elements,<A id=i-84923540-1></A><A id=i-1968563942-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>text<A id=i599729872-1></A><A id=i-891684874-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and tags.<A id=i599725500-1></A><A id=i-1699783286-1></A><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-xml.html#footnote26-2">[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Text is, as usual, any sequence of characters. Tags, written like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;pod&gt;</SPAN>, consist of a less-than sign, an alphanumeric label, and a greater than sign. Tags can be<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">start</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">end</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>tags. An end tag looks just like a start tag except that it has a slash just before the tag's label, like this:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;/pod&gt;</SPAN>.</P>
<P>Start and end tags must match each other, just like parentheses. Any start tag must eventually be followed by an end tag with the same label. Thus the following is illegal:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  //&nbsp;Illegal&nbsp;XML
  One&nbsp;&lt;pod&gt;,&nbsp;two&nbsp;&lt;pod&gt;,&nbsp;three&nbsp;&lt;pod&gt;&nbsp;zoo
</PRE>Further, the contents of any two matching tags must itself be valid XML. You cannot have two pairs of matching tags overlap each other:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  //&nbsp;Also&nbsp;illegal
  &lt;pod&gt;Three&nbsp;&lt;peas&gt;&nbsp;in&nbsp;the&nbsp;&lt;/pod&gt;&lt;/peas&gt;
</PRE>You could, however, write it like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &lt;pod&gt;Three&nbsp;&lt;peas&gt;&lt;/peas&gt;&nbsp;in&nbsp;the&nbsp;&lt;/pod&gt;
</PRE>Since tags are required to match in this way, XML is structured as nested<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">elements</EM>. Each pair of matching start and end tags forms an element, and elements may be nested within each other. In the above example, the entirety of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;pod&gt;Three</SPAN>&nbsp;<SPAN class=code>&lt;peas&gt;&lt;/peas&gt;</SPAN>&nbsp;<SPAN class=code>in</SPAN>&nbsp;<SPAN class=code>the</SPAN>&nbsp;<SPAN class=code>&lt;/pod&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an element, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;peas&gt;&lt;/peas&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an element nested within it. 
<P></P>
<P>Those are the basics. Two other things you should know are, first, there is a shorthand notation for a start tag followed immediately by its matching end tag. Simply write one tag with a slash put after the tag's label. Such a tag comprises an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">empty element</EM>. Using an empty element, the previous example could just as well be written as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &lt;pod&gt;Three&nbsp;&lt;peas/&gt;&nbsp;in&nbsp;the&nbsp;&lt;/pod&gt;
</PRE>Second, start tags can have<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">attributes</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>attached to them. An attribute is a name-value pair written with an equals sign in the middle.<A id=i-1944660140-1></A><A id=i2120320186-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The attribute name itself is plain, unstructured text, and the value is surrounded by either double quotes (<SPAN class=code>""</SPAN>) or single quotes (<SPAN class=code>"</SPAN>).<SPAN class=Apple-converted-space>&nbsp;</SPAN>Attributes look like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &lt;pod&nbsp;peas="3"&nbsp;strings="true"/&gt;
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=26.3></A>26.3 XML literals<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-xml.html#26.3">link</A>]</SPAN></H3>
<P>Scala lets you type in XML as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g182460591">literal</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>anywhere that an expression is valid.<A id=i-598913593-1></A><A id=i-1924909791-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Simply type a start tag and then continue writing XML content. The compile will go into an XML-input mode and will read content as XML until it sees the end tag matching the start tag you began with:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;&lt;a&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;is&nbsp;some&nbsp;XML.
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Here&nbsp;is&nbsp;a&nbsp;tag:&nbsp;&lt;atag/&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/a&gt;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;scala.xml.Elem&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;a&gt;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;is&nbsp;some&nbsp;XML.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Here&nbsp;is&nbsp;a&nbsp;tag:&nbsp;&lt;atag&gt;&lt;/atag&gt;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/a&gt;</SPAN>
</PRE>The result of this expression is of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Elem</SPAN>, meaning it is an XML element with a label ("<SPAN class=code>a</SPAN>") and children ("<SPAN class=code>This</SPAN>&nbsp;<SPAN class=code>is</SPAN>&nbsp;<SPAN class=code>some</SPAN>&nbsp;<SPAN class=code>XML</SPAN>...,"<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>etc.</I>).<A id=i583597511-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Some other important XML classes are: 
<P></P>
<UL>
<LI>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Node</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the abstract superclass of all XML node classes.<A id=i1729641978-1></A> 
<LI>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Text</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a node holding just text. For example, the "stuff" part of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;a&gt;stuff&lt;/a&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Text</SPAN>.<A id=i1739516731-1></A> 
<LI>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>NodeSeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>holds a sequence of nodes. Many methods in the XML library process<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>NodeSeq</SPAN>s in places you might expect them to process individual<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Node</SPAN>s. You can still use such methods with individual nodes, however, since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Node</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>extends from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>NodeSeq</SPAN>. This may sound weird, but it works out well for XML. You can think of an individual<SPAN class=code>Node</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a one-element<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>NodeSeq</SPAN>.<A id=i808041077-1></A></LI></UL>
<P>You are not restricted to writing out the exact XML you want, character for character. You can evaluate Scala code in the middle of an XML literal by using curly braces (<SPAN class=code>{}</SPAN>) as an escape.<A id=i1212676591-1></A><A id=i544063905-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Here is a simple example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;&lt;a&gt;&nbsp;{<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">",&nbsp;world"</SPAN>}&nbsp;&lt;/a&gt;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;scala.xml.Elem&nbsp;=&nbsp;&lt;a&gt;&nbsp;hello,&nbsp;world&nbsp;&lt;/a&gt;</SPAN>
</PRE>A braces escape can include arbitrary Scala content, including further XML literals. Thus, as the nesting level increases, your code can switch back and forth between XML and ordinary Scala code. Here's an example:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;yearMade&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1955</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">yearMade:&nbsp;Int&nbsp;=&nbsp;1955</SPAN>
  <BR>  scala&gt;&nbsp;&nbsp;&lt;a&gt;&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(yearMade&nbsp;&lt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2000</SPAN>)&nbsp;&lt;old&gt;{yearMade}&lt;/old&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">xml.NodeSeq.Empty</SPAN>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/a&gt;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;scala.xml.Elem&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;a&gt;&nbsp;&lt;old&gt;1955&lt;/old&gt;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/a&gt;</SPAN>
</PRE>If the code inside the curly braces evaluates to either an XML node or a sequence of XML nodes, those nodes are inserted directly as is. In the above example, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>yearMade</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is less than 2000, it is wrapped in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;old&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>tags and added to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;a&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>element. Otherwise, nothing is added. Note in the above example that "nothing" as an XML node is denoted with<SPAN class=code>xml.NodeSeq.Empty</SPAN>. 
<P></P>
<P>An expression inside a brace escape does not have to evaluate to an XML node. It can evaluate to any Scala value. In such a case, the result is converted to a string and inserted as a text node:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;&lt;a&gt;&nbsp;{<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>}&nbsp;&lt;/a&gt;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;scala.xml.Elem&nbsp;=&nbsp;&lt;a&gt;&nbsp;7&nbsp;&lt;/a&gt;</SPAN>
</PRE>Any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&amp;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>characters in the text will be escaped if you print the node back out:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;&lt;a&gt;&nbsp;{<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&lt;/a&gt;potential&nbsp;security&nbsp;hole&lt;a&gt;"</SPAN>}&nbsp;&lt;/a&gt;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;scala.xml.Elem&nbsp;=&nbsp;&lt;a&gt;&nbsp;&amp;lt;/a&amp;gt;potential&nbsp;security&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">hole&amp;lt;a&amp;gt;&nbsp;&lt;/a&gt;</SPAN>
</PRE>To contrast, if you create XML with low-level string operations, you will run into traps such as the following:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&lt;a&gt;"</SPAN>&nbsp;+&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&lt;/a&gt;potential&nbsp;security&nbsp;hole&lt;a&gt;"</SPAN>&nbsp;+&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&lt;/a&gt;"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res5:&nbsp;java.lang.String&nbsp;=&nbsp;&lt;a&gt;&lt;/a&gt;potential&nbsp;security&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">hole&lt;a&gt;&lt;/a&gt;</SPAN>
</PRE>What happens here is that a user-supplied string has included XML tags of its own, in this case<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;/a&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;a&gt;</SPAN>. This behavior can allow some nasty surprises for the original programmer, because it allows the user to affect the resulting XML tree outside of the space provided for the user inside the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;a&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>element. You can prevent this entire class of problems by always constructing XML using XML literals, not string appends. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=26.4></A>26.4 Serialization<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-xml.html#26.4">link</A>]</SPAN></H3>
<P>You have now seen enough of Scala's XML support to write the first part of a serializer: conversion from internal data structures to XML.<A id=i-426160987-1></A><A id=i-1549258323-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>All you need for this are XML literals and their brace escapes.</P>
<P>As an example, suppose you are implementing a database to keep track of your extensive collection of vintage Coca-Cola thermometers. You might make the following internal class to hold entries in the catalog:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CCTherm</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;description:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;yearMade:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;dateObtained:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bookPrice:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;in&nbsp;US&nbsp;cents</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;purchasePrice:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;in&nbsp;US&nbsp;cents</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;condition:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;1&nbsp;to&nbsp;10</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;description
  }
</PRE>This is a straightforward, data-heavy class that holds various pieces of information such as when the thermometer was made, when you got it, and how much you paid for it. 
<P></P>
<P>To convert instances of this class to XML, simply add a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toXML</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that uses XML literals and brace escapes, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CCTherm</SPAN>&nbsp;{
  &nbsp;&nbsp;...
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toXML&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&lt;cctherm&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;{description}&lt;/description&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;{yearMade}&lt;/yearMade&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;{dateObtained}&lt;/dateObtained&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;{bookPrice}&lt;/bookPrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;{purchasePrice}&lt;/purchasePrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;{condition}&lt;/condition&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;
  }
</PRE>
<P></P>
<P>Here is the method in action:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;therm&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CCTherm</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;description&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hot&nbsp;dog&nbsp;#5"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;yearMade&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1952</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;dateObtained&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"March&nbsp;14,&nbsp;2006"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bookPrice&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2199</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;purchasePrice&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">500</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;condition&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">9</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">therm:&nbsp;CCTherm&nbsp;=&nbsp;hot&nbsp;dog&nbsp;#5</SPAN>
  <BR>  scala&gt;&nbsp;therm.toXML
  <SPAN class=output style="COLOR: rgb(90,0,0)">res6:&nbsp;scala.xml.Elem&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;cctherm&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;hot&nbsp;dog&nbsp;#5&lt;/description&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;1952&lt;/yearMade&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;March&nbsp;14,&nbsp;2006&lt;/dateObtained&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;2199&lt;/bookPrice&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;9&lt;/condition&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;</SPAN>
</PRE>
<P></P>
<DIV class=note style="PADDING-RIGHT: 20px; PADDING-LEFT: 20px; PADDING-BOTTOM: 5px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px">
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Note</H4>The "<SPAN class=code>new</SPAN>&nbsp;<SPAN class=code>CCTherm</SPAN>" expression in the previous example works even though<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CCTherm</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an abstract class, because this syntax actually instantiates an anonymous subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CCTherm</SPAN>. Anonymous classes were described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#sec:val-init">Section 20.5</A>.</DIV>
<P>By the way, if you want to include a curly brace (`<SPAN class=code>{</SPAN>' or `<SPAN class=code>}</SPAN>') as XML text, as opposed to using them to escape to Scala code, simply write two curly braces in a row:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;&lt;a&gt;&nbsp;{{{{brace&nbsp;yourself!}}}}&nbsp;&lt;/a&gt;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res7:&nbsp;scala.xml.Elem&nbsp;=&nbsp;&lt;a&gt;&nbsp;{{brace&nbsp;yourself!}}&nbsp;&lt;/a&gt;</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=26.5></A>26.5 Taking XML apart<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-xml.html#26.5">link</A>]</SPAN></H3>
<P>Among the many methods available for the XML classes, there are three in particular that you should be aware of. They allow you to take apart XML without thinking too much about the precise way XML is represented in Scala. These methods are based on the XPath language for processing XML.<A id=i83750045-1></A><A id=i1385250650-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>As is common in Scala, you can write them directly in Scala code instead of needing to invoke an external tool.</P>
<P><B>Extracting text.</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>By calling the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>text</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method on any XML node you retrieve all of the text within that node, minus any element tags:<A id=i-620325929-1></A><A id=i-892340276-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;&lt;a&gt;Sounds&nbsp;&lt;tag/&gt;&nbsp;good&lt;/a&gt;.text
  <SPAN class=output style="COLOR: rgb(90,0,0)">res8:&nbsp;String&nbsp;=&nbsp;Sounds&nbsp;&nbsp;good</SPAN>
</PRE>Any encoded characters are decoded automatically:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;&lt;a&gt;&nbsp;input&nbsp;---&amp;gt;&nbsp;output&nbsp;&lt;/a&gt;.text
  <SPAN class=output style="COLOR: rgb(90,0,0)">res9:&nbsp;String&nbsp;=&nbsp;&nbsp;input&nbsp;---&gt;&nbsp;output&nbsp;</SPAN>
</PRE>
<P></P>
<P><B>Extracting sub-elements.</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>If you want to find a sub-element by tag name, simply call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the name of the tag:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&nbsp;~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"b"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res10:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;</SPAN>
</PRE>You can do a "deep search" and look through sub-sub-elements,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>etc.</I>, by using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\\</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator:<A id=i1322432817-1></A><A id=i32859236-1></A><A id=i583597511-2></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;&nbsp;&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&nbsp;~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"c"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res11:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;</SPAN>
  <BR>  scala&gt;&nbsp;&nbsp;&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&nbsp;\~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"c"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res12:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;&lt;c&gt;hello&lt;/c&gt;</SPAN>
  <BR>  scala&gt;&nbsp;&nbsp;&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&nbsp;~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res13:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;</SPAN>
  <BR>  scala&gt;&nbsp;&nbsp;&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&nbsp;\~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res14:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;</SPAN>
</PRE>
<P></P>
<DIV class=note style="PADDING-RIGHT: 20px; PADDING-LEFT: 20px; PADDING-BOTTOM: 5px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px">
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Note</H4>
<P>Scala uses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\\</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of XPath's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>/</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>//</SPAN>. The reason is that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>//</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>starts a comment in Scala! Thus, some other symbol has to be used, and using the other kind of slashes works well.</P></DIV>
<P><B>Extracting attributes.</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>You can extract tag attributes using the same<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\\</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods.<A id=i-1944660140-2></A><A id=i2120320186-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Simply put an at sign (<SPAN class=code>@</SPAN>) before the attribute name:<A id=i-1417487143-1></A><A id=i-2110526308-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;joe&nbsp;=&nbsp;&lt;employee
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name=<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Joe"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rank=<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"code&nbsp;monkey"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serial=<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"123"</SPAN>/&gt;
  <SPAN class=output style="COLOR: rgb(90,0,0)">joe:&nbsp;scala.xml.Elem&nbsp;=&nbsp;&lt;employee&nbsp;rank="code&nbsp;monkey"&nbsp;name="Joe"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;serial="123"&gt;&lt;/employee&gt;</SPAN>
  <BR>  scala&gt;&nbsp;&nbsp;joe&nbsp;~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"@name"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res15:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;Joe</SPAN>
  <BR>  scala&gt;&nbsp;&nbsp;joe&nbsp;~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"@serial"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res16:&nbsp;scala.xml.NodeSeq&nbsp;=&nbsp;123</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=26.6></A>26.6 Deserialization<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-xml.html#26.6">link</A>]</SPAN></H3>
<P>Using the previous methods for taking XML apart, you can now write the dual of a serializer, a parser from XML back into your internal data structures.<A id=i-1744729332-1></A><A id=i1294189452-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, you can parse back a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CCTherm</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instance by using the following code:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;fromXML(node:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">scala.xml.Node</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CCTherm</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CCTherm</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;description&nbsp;&nbsp;&nbsp;=&nbsp;(node&nbsp;~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"description"</SPAN>).text
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;yearMade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;(node&nbsp;~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"yearMade"</SPAN>).text.toInt
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;dateObtained&nbsp;&nbsp;=&nbsp;(node&nbsp;~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"dateObtained"</SPAN>).text
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bookPrice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;(node&nbsp;~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"bookPrice"</SPAN>).text.toInt
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;purchasePrice&nbsp;=&nbsp;(node&nbsp;~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"purchasePrice"</SPAN>).text.toInt
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;condition&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;(node&nbsp;~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"condition"</SPAN>).text.toInt
  &nbsp;&nbsp;}
</PRE>This code searches through an input XML node, named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>node</SPAN>, to find each of the six pieces of data needed to specify a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CCTherm</SPAN>. The data that is text is extracted with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>.text</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and left as is. Here is this method in action:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;node&nbsp;=&nbsp;therm.toXML
  <SPAN class=output style="COLOR: rgb(90,0,0)">node:&nbsp;scala.xml.Elem&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;cctherm&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;hot&nbsp;dog&nbsp;#5&lt;/description&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;1952&lt;/yearMade&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;March&nbsp;14,&nbsp;2006&lt;/dateObtained&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;2199&lt;/bookPrice&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;9&lt;/condition&gt;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;</SPAN>
  <BR>  scala&gt;&nbsp;fromXML(node)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res15:&nbsp;CCTherm&nbsp;=&nbsp;hot&nbsp;dog&nbsp;#5</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=26.7></A>26.7 Loading and saving<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-xml.html#26.7">link</A>]</SPAN></H3>
<P>There is one last part needed to write a data serializer: conversion between XML and streams of bytes. This last part is the easiest, because there are library routines that will do it all for you. You simply have to call the right routine on the right data.</P>
<P>To convert XML to a string, all you need is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN>. The presence of a workable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is why you can experiment with XML in the Scala shell. However, it is better to use a library routine and convert all the way to bytes. That way, the resulting XML can include a directive that specifies which character encoding was used. If you encode the string to bytes yourself, then the onus is on you to keep track of the character encoding.<A id=i1598423906-1></A><A id=i1840683213-1></A></P>
<P>To convert from XML to a file of bytes, you can use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>XML.saveFull</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>command.<A id=i1739851674-1></A><A id=i-368862602-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The important pieces you must choose are a file name, a node to be saved, and a character encoding. The fourth argument is whether to write an XML declaration at the top that includes the character encoding. The fifth argument is the "document type" of this XML, a subject beyond the scope of this chapter. You can specify<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to leave the document type unspecified:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala.xml.XML.saveFull(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"therm1.xml"</SPAN>,&nbsp;node,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"UTF-8"</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">null</SPAN>)
</PRE>After running the above command, the resulting file<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=texttt>therm1.xml</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>looks like the following:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &lt;?xml&nbsp;version='1.0'&nbsp;encoding='UTF-8'?&gt;
  &lt;cctherm&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;hot&nbsp;dog&nbsp;#5&lt;/description&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;1952&lt;/yearMade&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;March&nbsp;14,&nbsp;2006&lt;/dateObtained&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;2199&lt;/bookPrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;9&lt;/condition&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;
</PRE>Loading is simpler than saving, because the file includes everything the loader needs to know. Simply call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>XML.loadFile</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on a file name:<A id=i1775530286-1></A><A id=i1708565962-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;loadnode&nbsp;=&nbsp;xml.XML.loadFile(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"therm1.xml"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">loadnode:&nbsp;scala.xml.Elem&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;cctherm&gt;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;hot&nbsp;dog&nbsp;#5&lt;/description&gt;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;1952&lt;/yearMade&gt;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;March&nbsp;14,&nbsp;2006&lt;/dateObtained&gt;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;2199&lt;/bookPrice&gt;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;9&lt;/condition&gt;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;</SPAN>
  <BR>  scala&gt;&nbsp;fromXML(loadnode)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res14:&nbsp;CCTherm&nbsp;=&nbsp;hot&nbsp;dog&nbsp;#5</SPAN>
</PRE>
<P>Those are the basic methods you need. There are many variations on these loading and saving methods, including methods for reading and writing to various kinds of readers, writers, input and output streams.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=26.8></A>26.8 Pattern matching on XML<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-xml.html#26.8">link</A>]</SPAN></H3>
<P>So far you have seen how to dissect XML using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>text</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the XPath-like methods,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\\</SPAN>.<A id=i1974282179-1></A><A id=i1884986778-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>These are good when you know exactly what kind of XML structure you are taking apart. Sometimes, though, there are a few possible structures the XML could have. Maybe there are multiple kinds of records within the data, for example because you have extended your thermometer collection to include clocks and sandwich plates. Maybe you simply want to skip over any white space between tags. Whatever the reason, you can use the pattern matcher to sift through the possibilities.</P>
<P>An XML pattern looks just like an XML literal. The main difference is that if you insert a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>{}</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>escape, then the code inside the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>{}</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not an expression but a pattern.<A id=i-2088304360-1></A><A id=i1428654986-1></A><A id=i428757728-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>A pattern embedded in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>{}</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can use the full Scala pattern language, including binding new variables, performing type tests, and ignoring content using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>patterns. Here is a simple example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;proc(node:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">scala.xml.Node</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=
  &nbsp;&nbsp;node&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;&lt;a&gt;{contents}&lt;/a&gt;&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"It's&nbsp;an&nbsp;a:&nbsp;"</SPAN>+&nbsp;contents
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;&lt;b&gt;{contents}&lt;/b&gt;&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"It's&nbsp;a&nbsp;b:&nbsp;"</SPAN>+&nbsp;contents
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"It's&nbsp;something&nbsp;else."</SPAN>
  &nbsp;&nbsp;}
</PRE>
<P></P>
<P>This function has a pattern match with three cases. The first case looks for an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;a&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>element whose contents consist of a a single sub-node. It binds those contents to a variable named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and then evaluates the code to the right of the associated right arrow (<SPAN class=code>=&gt;</SPAN>). The second case does the same thing but looks for a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;b&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;a&gt;</SPAN>, and the third case matches anything not matched by any other case. Here is the function in use:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;proc(&lt;a&gt;apple&lt;/a&gt;)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res16:&nbsp;String&nbsp;=&nbsp;It's&nbsp;an&nbsp;a:&nbsp;apple</SPAN>
  scala&gt;&nbsp;proc(&lt;b&gt;banana&lt;/b&gt;)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res17:&nbsp;String&nbsp;=&nbsp;It's&nbsp;a&nbsp;b:&nbsp;banana</SPAN>
  scala&gt;&nbsp;proc(&lt;c&gt;cherry&lt;/c&gt;)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res18:&nbsp;String&nbsp;=&nbsp;It's&nbsp;something&nbsp;else.</SPAN>
</PRE>
<P></P>
<P>Most likely this function is not exactly what you want, because it looks precisely for contents consisting of a single sub-node within the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;a&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;b&gt;</SPAN>. Thus it will fail to match in cases like the following:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;proc(&lt;a&gt;a&nbsp;&lt;em&gt;red&lt;/em&gt;&nbsp;apple&lt;/a&gt;)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res19:&nbsp;String&nbsp;=&nbsp;It's&nbsp;something&nbsp;else.</SPAN>
  scala&gt;&nbsp;proc(&lt;a/&gt;)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res20:&nbsp;String&nbsp;=&nbsp;It's&nbsp;something&nbsp;else.</SPAN>
</PRE>
<P></P>
<P>If you want the function to match in cases like these, you can match against a sequence of nodes instead of a single one. The pattern for "any sequence" of XML nodes is written `<SPAN class=code>_*</SPAN>'.<A id=i521514024-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Visually, this sequence looks like the wildcard pattern (<SPAN class=code>_</SPAN>) followed by a regex-style Kleene star (<SPAN class=code>*</SPAN>). Here is the updated function that matches a sequence of sub-elements instead of a single sub-element:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;proc(node:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">scala.xml.Node</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=
  &nbsp;&nbsp;node&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;&lt;a&gt;{contents&nbsp;@&nbsp;_*}&lt;/a&gt;&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"It's&nbsp;an&nbsp;a:&nbsp;"</SPAN>+&nbsp;contents
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;&lt;b&gt;{contents&nbsp;@&nbsp;_*}&lt;/b&gt;&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"It's&nbsp;a&nbsp;b:&nbsp;"</SPAN>+&nbsp;contents
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"It's&nbsp;something&nbsp;else."</SPAN>
  &nbsp;&nbsp;}
</PRE>Notice that the result of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is bound to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable by using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>pattern described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#sec:var-binding">Section 15.2</A>. Here is the new version in action:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;proc(&lt;a&gt;a&nbsp;&lt;em&gt;red&lt;/em&gt;&nbsp;apple&lt;/a&gt;)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res21:&nbsp;String&nbsp;=&nbsp;It's&nbsp;an&nbsp;a:&nbsp;ArrayBuffer(a&nbsp;,</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&lt;em&gt;red&lt;/em&gt;,&nbsp;&nbsp;apple)</SPAN>
  scala&gt;&nbsp;proc(&lt;a/&gt;)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res22:&nbsp;String&nbsp;=&nbsp;It's&nbsp;an&nbsp;a:&nbsp;Array()</SPAN>
</PRE>
<P>As a final tip, be aware that XML patterns work very nicely with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions as a way to iterate through some parts of an XML tree while ignoring other parts.<A id=i-96590517-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, suppose you wish to skip over the white space between records in the following XML structure:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;catalog&nbsp;=
  &nbsp;&nbsp;&lt;catalog&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&lt;cctherm&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;hot&nbsp;dog&nbsp;#5&lt;/description&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;1952&lt;/yearMade&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;March&nbsp;14,&nbsp;2006&lt;/dateObtained&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;2199&lt;/bookPrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;9&lt;/condition&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&lt;cctherm&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;Sprite&nbsp;Boy&lt;/description&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;yearMade&gt;1964&lt;/yearMade&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dateObtained&gt;April&nbsp;28,&nbsp;2003&lt;/dateObtained&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bookPrice&gt;1695&lt;/bookPrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;purchasePrice&gt;595&lt;/purchasePrice&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;condition&gt;5&lt;/condition&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&lt;/cctherm&gt;
  &nbsp;&nbsp;&lt;/catalog&gt;
</PRE>Visually, it looks like there are two nodes inside the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;catalog&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>element. Actually, though, there are five. There is white space before, after, and between the two elements! If you do not consider this white space, you might incorrectly process the thermometer records as follows:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  catalog&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;&lt;catalog&gt;{therms&nbsp;@&nbsp;_*}&lt;/catalog&gt;&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(therm&nbsp;&lt;-&nbsp;therms)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"processing:&nbsp;"</SPAN>+&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(therm&nbsp;~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"description"</SPAN>).text)
  }
</PRE><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">processing:&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">processing:&nbsp;hot&nbsp;dog&nbsp;#5</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">processing:&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">processing:&nbsp;Sprite&nbsp;Boy</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">processing:&nbsp;</SPAN>
</PRE>Notice all of the lines that try to process white space as if it were a true thermometer record. What you would really like to do is ignore the white space and process only those sub-nodes that are inside a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;cctherm&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>element. You can describe this subset using the pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;cctherm&gt;{_*}&lt;/cctherm&gt;</SPAN>, and you can restrict the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression to iterating over items that match that pattern:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  catalog&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;&lt;catalog&gt;{therms&nbsp;@&nbsp;_*}&lt;/catalog&gt;&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(therm&nbsp;@&nbsp;&lt;cctherm&gt;{_*}&lt;/cctherm&gt;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;therms)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"processing:&nbsp;"</SPAN>+&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(therm&nbsp;~<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"description"</SPAN>).text)
  }
</PRE><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">processing:&nbsp;hot&nbsp;dog&nbsp;#5</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">processing:&nbsp;Sprite&nbsp;Boy</SPAN>
</PRE>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=26.9></A>26.9 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-xml.html#26.9">link</A>]</SPAN></H3>
<P>This chapter has only scratched the surface of what you can do with XML. There are many other extensions, libraries, and tools you could learn about, some customized for Scala, some made for Java but usable in Scala, and some language-neutral. What you should walk away from this chapter with is how to use semi-structured data for interchange, and how to access semi-structured data via Scala's XML support.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 26:</H4>
<P><A name=footnote26-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>There are type systems for XML, such as XML Schemas, but they are beyond the scope of this book.</P>
<P><A name=footnote26-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The full story is more complicated, but this is enough to be effective with XML.</P></DIV>