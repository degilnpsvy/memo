<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 24 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Extractors</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>By now you have probably grown accustomed to the concise way data can be decomposed and analyzed using pattern matching<A id=i-83872229-1></A>. This chapter shows you how to generalize this concept further. Until now, constructor patterns were linked to case classes. For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some(x)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a valid pattern because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a case class. Sometimes you might wish that you could write patterns like this without creating an associated case class. In fact, you might wish to be able to create your own kinds of patterns. Extractors give you a way to do so<A id=i751564495-1></A>. This chapter explains what extractors are and how you can use them to define patterns that are decoupled from an object's representation.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=24.1></A>24.1 An example: Extracting email addresses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#24.1">link</A>]</SPAN></H3>
<P>To illustrate the problem extractors solve, imagine that you need to analyze strings that represent email addresses. Given a string, you want to decide whether it is an email address or not, and, if it is, you want to access the user and domain parts of the address. The traditional way to do this uses three helper functions:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isEMail(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;domain(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;user(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>
</PRE>With these functions, you could parse a given string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as follows:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(isEMail(s))&nbsp;println(user(s)&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;AT&nbsp;"</SPAN>+&nbsp;domain(s))
  <SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"not&nbsp;an&nbsp;email&nbsp;address"</SPAN>)
</PRE>This works, but is kind of clumsy. What's more, things would become more complicated if you combined several such tests. For instance you might want to find two successive strings in a list that are both email addresses with the same user. You can try this yourself with the access functions defined previously to see what would be involved. 
<P></P>
<P>You saw already in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html">Chapter 15</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that pattern matching is ideal for attacking problems like this. Let's assume for the moment that you could match a string with a pattern:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">EMail</SPAN>(user,&nbsp;domain)
</PRE>The pattern would match if the string contained an embedded at sign (<SPAN class=code>@</SPAN>). In that case it would bind variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>user</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the part of the string before the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>domain</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the part after it. Postulating a pattern like this, the previous expression could be written more clearly like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  s&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EMail</SPAN>(user,&nbsp;domain)&nbsp;=&gt;&nbsp;println(user&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;AT&nbsp;"</SPAN>+&nbsp;domain)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"not&nbsp;an&nbsp;email&nbsp;address"</SPAN>)
  }
</PRE>The more complicated problem of finding two successive email addresses with the same user part would translate to the following pattern:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  ss&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EMail</SPAN>(u1,&nbsp;d1)&nbsp;::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EMail</SPAN>(u2,&nbsp;d2)&nbsp;::&nbsp;_&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(u1&nbsp;==&nbsp;u2)&nbsp;=&gt;&nbsp;...
  &nbsp;&nbsp;...
  }
</PRE>This is much more legible than anything that could be written with access functions. However, the problem is that strings are not case classes; they do not have a representation that conforms to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EMail(user,</SPAN>&nbsp;<SPAN class=code>domain)</SPAN>. This is where Scala's extractors come in: they let you define new patterns for pre-existing types, where the pattern need not follow the internal representation of the type. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=24.2></A>24.2 Extractors<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#24.2">link</A>]</SPAN></H3>
<P>An extractor in Scala is an object that has a method called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as one of its members<A id=i1869714895-1></A>. The purpose of that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is to match a value and take it apart. Often, the extractor object also defines a dual method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for building values, but this is not required.<A id=i-649058493-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>As an example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#lst:email-extractor">Listing 24.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an extractor object for email addresses:<A name=lst:email-extractor></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EMail</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;The&nbsp;injection&nbsp;method&nbsp;(optional)</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(user:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;domain:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&nbsp;user&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"@"</SPAN>+&nbsp;domain
  <BR>  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;The&nbsp;extraction&nbsp;method&nbsp;(mandatory)</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;unapply(str:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Option[(String, String)]</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;parts&nbsp;=&nbsp;str&nbsp;split&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"@"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(parts.length&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(parts(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>),&nbsp;parts(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>))&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">None</SPAN>
  &nbsp;&nbsp;}
  }
</PRE>
<H5>Listing 24.1 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EMail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>string extractor object.</H5>
<P>This object defines both<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method has the same meaning as always: it turns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EMail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into an object that can be applied to arguments in parentheses in the same way a method is applied. So you can write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EMail("John",</SPAN>&nbsp;<SPAN class=code>"epfl.ch")</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to construct the string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"John@epfl.ch"</SPAN>. To make this more explicit, you could also let<SPAN class=code>EMail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>inherit from Scala's function type, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EMail</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;{&nbsp;...&nbsp;}
</PRE>
<P></P>
<DIV class=note style="PADDING-RIGHT: 20px; PADDING-LEFT: 20px; PADDING-BOTTOM: 5px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px">
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Note</H4>
<P>The "<SPAN class=code>(String,</SPAN>&nbsp;<SPAN class=code>String)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>String</SPAN>" portion of the previous object declaration means the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function2[String,</SPAN>&nbsp;<SPAN class=code>String,</SPAN>&nbsp;<SPAN class=code>String]</SPAN>, which declares an abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that<SPAN class=code>EMail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>implements. As a result of this declaration, you could, for example, pass<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EMail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to a method expecting a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function2[String,</SPAN>&nbsp;<SPAN class=code>String,</SPAN>&nbsp;<SPAN class=code>String]</SPAN>.</P></DIV>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is what turns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EMail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into an extractor. In a sense, it reverses the construction process of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN>. Where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes two strings and forms an email address string out of them,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes an email address and returns potentially two strings: the user and the domain of the address. But<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>must also handle the case where the given string is not an email address. That's why<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Option</SPAN>-type over pairs of strings. Its result is either<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some(user,</SPAN>&nbsp;<SPAN class=code>domain)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>str</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an email address with the given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>user</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>domain</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parts,<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#footnote24-1">[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>None</SPAN>, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>str</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not an email address. Here are some examples:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  unapply(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"John@epfl.ch"</SPAN>)&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"John"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"epfl.ch"</SPAN>)
  unapply(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"John&nbsp;Doe"</SPAN>)&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">None</SPAN>
</PRE>Now, whenever pattern matching encounters a pattern referring to an extractor object, it invokes the extractor's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method on the selector expression. For instance, executing the code:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  selectorString&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EMail</SPAN>(user,&nbsp;domain)&nbsp;=&gt;&nbsp;...&nbsp;}
</PRE>would lead to the call:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  EMail.unapply(selectorString)
</PRE>As you saw previously, this call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EMail.unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will return either<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>None</SPAN><A id=i2129711991-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some(u,</SPAN>&nbsp;<SPAN class=code>d)</SPAN><A id=i-467709668-1></A>, for some values<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>u</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for the user part of the address and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>d</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for the domain part. In the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>None</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>case, the pattern does not match, and the system tries another pattern or fails with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MatchError</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>exception.<A id=i-2067503209-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some(u,</SPAN>&nbsp;<SPAN class=code>d)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>case, the pattern matches and its variables are bound to the elements of the returned value. In the previous match,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>user</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be bound to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>u</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>domain</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be bound to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>d</SPAN>. 
<P></P>
<P>In the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EMail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>pattern matching example, the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the selector expression,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>selectorString</SPAN>, conformed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN>'s argument type (which in the example was also<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>). This is quite common, but not necessary. It would also be possible to use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EMail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>extractor to match selector expressions for more general types. For instance, to find out whether an arbitrary value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was an email address string, you could write:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>&nbsp;=&nbsp;...
  x&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EMail</SPAN>(user,&nbsp;domain)&nbsp;=&gt;&nbsp;...&nbsp;}
</PRE>Given this code, the pattern matcher will first check whether the given value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>conforms to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>, the parameter type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EMail</SPAN>'s unapply method. If it does conform, the value is cast to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and pattern matching proceeds as before. If it does not conform, the pattern fails immediately. 
<P></P>
<P>In object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EMail</SPAN>, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is called an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">injection</SPAN>, because it takes some arguments and yields an element of a given set (in our case: the set of strings that are email addresses).<A id=i2031936124-1></A><A id=i1478477936-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is called an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">extraction</SPAN>, because it takes an element of the same set and extracts some of its parts (in our case: the user and domain substrings)<A id=i-1101999489-1></A>. Injections and extractions are often grouped together in one object, because then you can use the object's name for both a constructor and a pattern, which simulates the convention for pattern matching with case classes. However, it is also possible to define an extraction in an object without a corresponding injection. The object itself is called an<SPAN style="FONT-STYLE: italic">extractor</SPAN>, independently of whether it has an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method or not.</P>
<P>If an injection method is included, it should be the dual to the extraction method. For instance, a call of:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  EMail.unapply(EMail.apply(user,&nbsp;domain))
</PRE>should return:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(user,&nbsp;domain)
</PRE><I>i.e.</I>, the same sequence of arguments wrapped in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some</SPAN>. Going in the other direction means running first the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and then the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN>, as shown in the following code:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  EMail.unapply(obj)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(u,&nbsp;d)&nbsp;=&gt;&nbsp;EMail.apply(u,&nbsp;d)&nbsp;
  }
</PRE>In that code, if the match on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>obj</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>succeeds, you'd expect to get back that same object from the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN>. These two conditions for the duality of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are good design principles. They are not enforced by Scala, but it's recommended to keep to them when designing your extractors. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=24.3></A>24.3 Patterns with zero or one variables<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#24.3">link</A>]</SPAN></H3>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method of the previous example returned a pair of element values in the success case. This is easily generalized to patterns of more than two variables. To bind<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>N</SPAN>variables, an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would return an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>N</SPAN>-element tuple, wrapped in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some</SPAN>.</P>
<P>The case where a pattern binds just one variable is treated differently, however. There is no one-tuple in Scala. To return just one pattern element, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method simply wraps the element itself in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some</SPAN>. For example, the extractor object shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#lst:twice-extractor">Listing 24.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>defines<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for strings that consist of the same substring appearing twice in a row:<A name=lst:twice-extractor></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Twice</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=&nbsp;s&nbsp;+&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;unapply(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Option[String]</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;length&nbsp;=&nbsp;s.length&nbsp;/&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;half&nbsp;=&nbsp;s.substring(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;length)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(half&nbsp;==&nbsp;s.substring(length))&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(half)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">None</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 24.2 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Twice</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>string extractor object.</H5>
<P>It's also possible that an extractor pattern does not bind any variables. In that case the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method returns a boolean&#8212;<SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for success and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for failure. For instance, the extractor object shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#lst:uppercase-extractor">Listing 24.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>characterizes strings consisting of all uppercase characters:</P>
<P><A name=lst:uppercase-extractor></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UpperCase</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;unapply(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;s.toUpperCase&nbsp;==&nbsp;s
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 24.3 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UpperCase</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>string extractor object.</H5>
<P>This time, the extractor only defines an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN>, but not an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN>. It would make no sense to define an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN>, as there's nothing to construct.</P>
<P>The following<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>userTwiceUpper</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function applies all previously defined extractors together in its pattern matching code:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;userTwiceUpper(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&nbsp;s&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EMail</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Twice</SPAN>(x&nbsp;@&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UpperCase</SPAN>()),&nbsp;domain)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"match:&nbsp;"</SPAN>+&nbsp;x&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;in&nbsp;domain&nbsp;"</SPAN>+&nbsp;domain
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"no&nbsp;match"</SPAN>
  }
</PRE>The first pattern of this function matches strings that are email addresses whose user part consists of two occurrences of the same string in uppercase letters. For instance:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;userTwiceUpper(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"DIDI@hotmail.com"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;java.lang.String&nbsp;=&nbsp;match:&nbsp;DI&nbsp;in&nbsp;domain&nbsp;hotmail.com</SPAN>
  <BR>  scala&gt;&nbsp;userTwiceUpper(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"DIDO@hotmail.com"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;java.lang.String&nbsp;=&nbsp;no&nbsp;match</SPAN>
  <BR>  scala&gt;&nbsp;userTwiceUpper(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"didi@hotmail.com"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;java.lang.String&nbsp;=&nbsp;no&nbsp;match</SPAN>
</PRE>Note that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UpperCase</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in function<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>userTwiceUpper</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes an empty parameter list. This cannot be omitted as otherwise the match would test for equality with the object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UpperCase</SPAN>! Note also that, even though<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UpperCase()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>itself does not bind any variables, it is still possible to associate a variable with the whole pattern matched by it. To do this, you use the standard scheme of variable binding explained in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#sec:var-binding">Section 15.2</A>: the form<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x @ UpperCase()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>associates the variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the pattern matched by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UpperCase()</SPAN>. For instance, in the first<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>userTwiceUpper</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>invocation above,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was bound to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"DI"</SPAN>, because that was the value against which the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UpperCase()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>pattern was matched. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=24.4></A>24.4 Variable argument extractors<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#24.4">link</A>]</SPAN></H3>
<P>The previous extraction methods for email addresses all returned a fixed number of element values. Sometimes, this is not flexible enough. For example, you might want to match on a string representing a domain name, so that every part of the domain is kept in a different sub-pattern. This would let you express patterns such as the following:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  dom&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Domain</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"org"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"acm"</SPAN>)&nbsp;=&gt;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"acm.org"</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Domain</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"com"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"sun"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"java"</SPAN>)&nbsp;=&gt;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"java.sun.com"</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Domain</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"net"</SPAN>,&nbsp;_*)&nbsp;=&gt;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a&nbsp;.net&nbsp;domain"</SPAN>)
  }
</PRE>In this example things were arranged so that domains are expanded in reverse order&#8212;from the top-level domain down to the sub-domains. This was done so that you could better profit from sequence patterns. You saw in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#sec:pat-sequences">Section 15.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that a sequence wildcard pattern,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_*</SPAN><A id=i-563003136-1></A>, at the end of an argument list matches any remaining elements in a sequence. This feature is more useful if the top-level domain comes first, because then you can use sequence wildcards to match sub-domains of arbitrary depth. 
<P></P>
<P>The question remains how an extractor can support<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">vararg matching</SPAN><A id=i1383700270-1></A><A id=i1018791428-1></A><A id=i-1008880962-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>as shown in the previous example, where patterns can have a varying number of sub-patterns. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN>methods encountered so far are not sufficient, because they each return a fixed number of sub-elements in the success case. To handle this case, Scala lets you define a different extraction method specifically for vararg matching. This method is called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapplySeq</SPAN><A id=i1953385690-1></A>. To see how it is written, have a look at the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Domain</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>extractor, shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#lst:domain-extractor">Listing 24.4</A>:<A name=lst:domain-extractor></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Domain</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;The&nbsp;injection&nbsp;method&nbsp;(optional)</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(parts:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>*):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parts.reverse.mkString(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"."</SPAN>)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;The&nbsp;extraction&nbsp;method&nbsp;(mandatory)</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;unapplySeq(whole:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Option[Seq[String]]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(whole.split(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"\\."</SPAN>).reverse)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 24.4 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Domain</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>string extractor object.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Domain</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object defines an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapplySeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that first splits the string into parts separated by periods. This is done using Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>split</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method on strings, which takes a regular expression as its argument. The result of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>split</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an array of substrings. The result of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapplySeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is then that array with all elements reversed and wrapped in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some</SPAN>.</P>
<P>The result type of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapplySeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>must conform to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Option[Seq[T]]</SPAN>, where the element type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is arbitrary. As you saw in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html#sec:sequences">Section 17.2</A>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Seq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an important class in Scala's collection hierarchy. It's a common superclass of several classes describing different kinds of sequences:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>s,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN>s,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RichString</SPAN>, and several others.</P>
<P>For symmetry,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Domain</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>also has an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that builds a domain string from a variable argument parameter of domain parts starting with the top-level domain. As always, the<SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is optional.</P>
<P>You can use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Domain</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>extractor to get more detailed information out of email strings. For instance, to search for an email address named "tom" in some "<SPAN class=code>.com</SPAN>" domain, you could write the following function:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isTomInDotCom(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;s&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EMail</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"tom"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Domain</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"com"</SPAN>,&nbsp;_*))&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  }
</PRE>This gives the expected results:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;isTomInDotCom(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"tom@sun.com"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;isTomInDotCom(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"peter@sun.com"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;isTomInDotCom(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"tom@acm.org"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res5:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>It's also possible to return some fixed elements from an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapplySeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>together with the variable part. This is expressed by returning all elements in a tuple, where the variable part comes last, as usual. As an example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#lst:expanded-email-extractor">Listing 24.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a new extractor for emails where the domain part is already expanded into a sequence:<A name=lst:expanded-email-extractor></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ExpandedEMail</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;unapplySeq(email:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Option[(String, Seq[String])]</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;parts&nbsp;=&nbsp;email&nbsp;split&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"@"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(parts.length&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(parts(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>),&nbsp;parts(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>).split(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"\\."</SPAN>).reverse)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">None</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 24.5 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ExpandedEMail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>extractor object.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapplySeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ExpandedEMail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns an optional value of a pair (a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tuple2</SPAN>). The first element of the pair is the user part. The second element is a sequence of names representing the domain. You can match on this as usual:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;s&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"tom@support.epfl.ch"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">s:&nbsp;java.lang.String&nbsp;=&nbsp;tom@support.epfl.ch</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ExpandedEMail</SPAN>(name,&nbsp;topdom,&nbsp;subdoms&nbsp;@&nbsp;_*)&nbsp;=&nbsp;s
  <SPAN class=output style="COLOR: rgb(90,0,0)">name:&nbsp;String&nbsp;=&nbsp;tom</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">topdom:&nbsp;String&nbsp;=&nbsp;ch</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">subdoms:&nbsp;Seq[String]&nbsp;=&nbsp;List(epfl,&nbsp;support)</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=24.5></A>24.5 Extractors and sequence patterns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#24.5">link</A>]</SPAN></H3>
<P>You saw in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#sec:pat-sequences">Section 15.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that you can access the elements of a list or an array using sequence patterns such as:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
  <SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x,&nbsp;y,&nbsp;_*)
  <SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(x,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;_)
</PRE>In fact, these sequence patterns are all implemented using extractors in the standard Scala library. For instance, patterns of the form<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(...)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are possible because the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.List</SPAN>companion object is an extractor that defines an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapplySeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#lst:lists-unapply-seq">Listing 24.6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows the relevant definitions:<A name=lst:lists-unapply-seq></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;scala
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply[T](elems:&nbsp;T*)&nbsp;=&nbsp;elems.toList
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;unapplySeq[T](x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Option[Seq[T]]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(x)
  &nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 24.6 - An extractor that defines an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapplySeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object contains an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that takes a variable number of arguments.<A id=i19484993-3></A><A id=i1305057997-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>That's what lets you write expressions such as:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
  <SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
</PRE>It also contains an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapplySeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that returns all elements of the list as a sequence. That's what supports<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(...)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>patterns. Very similar definitions exist in the object<SPAN class=code>scala.Array</SPAN>. These support analogous injections and extractions for arrays. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=24.6></A>24.6 Extractors versus case classes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#24.6">link</A>]</SPAN></H3>
<P>Even though they are very useful, case classes have one shortcoming: they expose the concrete representation of data. This means that the name of the class in a constructor pattern corresponds to the concrete representation type of the selector<SPAN class=Apple-converted-space>&nbsp;</SPAN>object. If a match against<A id=i-910914787-1></A>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;C(...)
</PRE>succeeds, you know that the selector expression is an instance of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN>. 
<P></P>
<P>Extractors break this link between data representations and patterns. You have seen in the examples in this section that they enable patterns that have nothing to do with the data type of the object that's selected on. This property is called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">representation independence</SPAN>.<A id=i886727311-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In open systems of large size, representation independence is very important because it allows you to change an implementation type used in a set of components without affecting clients of these components.</P>
<P>If your component had defined and exported a set of case classes, you'd be stuck with them because client code could already contain pattern matches against these case classes. Renaming some case classes or changing the class hierarchy would affect client code. Extractors do not share this problem, because they represent a layer of indirection between a data representation and the way it is viewed by clients. You could still change a concrete representation of a type, as long as you update all your extractors with it.</P>
<P>Representation independence is an important advantage of extractors over case classes. On the other hand, case classes also have some advantages of their own over extractors. First, they are much easier to set up and to define, and they require less code. Second, they usually lead to more efficient pattern matches than extractors,<A id=i-2031931761-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>because the Scala compiler can optimize patterns over case classes much better than patterns over extractors. This is because the mechanisms of case classes are fixed, whereas an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapply</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unapplySeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in an extractor could do almost anything. Third, if your case classes inherit from a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sealed</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>base class<A id=i-1485759717-2></A>, the Scala compiler will check your pattern matches for exhaustiveness and will complain if some combination of possible values is not covered by a pattern. No such exhaustiveness checks are available for extractors.</P>
<P>So which of the two methods should you prefer for your pattern matches? It depends. If you write code for a closed application, case classes are usually preferable because of their advantages in conciseness, speed and static checking. If you decide to change your class hierarchy later, the application needs to be refactored, but this is usually not a problem. On the other hand, if you need to expose a type to unknown clients, extractors might be preferable because they maintain representation independence.</P>
<P>Fortunately, you need not decide right away. You could always start with case classes and then, if the need arises, change to extractors. Because patterns over extractors and patterns over case classes look exactly the same in Scala, pattern matches in your clients will continue to work.</P>
<P>Of course, there are also situations where it's clear from the start that the structure of your patterns does not match the representation type of your data. The email addresses discussed in this chapter were one such example. In that case, extractors are the only possible choice.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=24.7></A>24.7 Regular expressions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#24.7">link</A>]</SPAN></H3>
<P>One particularly useful application area of extractors are regular expressions.<A id=i1678705239-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Like Java, Scala provides regular expressions through a library, but extractors make it much nicer to interact with them.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Forming regular expressions</H4>
<P>Scala inherits its regular expression syntax from Java, which in turn inherits most of the features of Perl.<A id=i389811529-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>We assume you know that syntax already; if not, there are many accessible tutorials, starting with the Javadoc documentation of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.util.regex.Pattern</SPAN>. Here are just some examples that should be enough as refreshers:<BR></P>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="">
<TD><SPAN class=code>ab?</SPAN></TD>
<TD>An `<SPAN class=code>a</SPAN>', possibly followed by a `<SPAN class=code>b</SPAN>'.</TD></TR>
<TR class="">
<TD>[1em]<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\d+</SPAN></TD>
<TD>A number consisting of one or more digits represented by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\d</SPAN>.</TD></TR></TBODY></TABLE>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="">
<TD><SPAN class=code>[a-dA-D]\w*</SPAN></TD>
<TD>A word starting with a letter between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>d</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in lower or upper case, followed by a sequence of zero or more "word characters" denoted by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\w</SPAN>. (A word character is a letter, digit, or underscore.)</TD></TR>
<TR class="">
<TD>[1em]<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(-)?(\d+)(\.\d*)?</SPAN></TD>
<TD>A number consisting of an optional minus sign, followed by one or more digits, optionally followed by a period and zero or more digits. The number contains three<SPAN style="FONT-STYLE: italic">groups</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, the minus sign, the part before the decimal point, and the fractional part including the decimal point. Groups are enclosed in parentheses.</TD></TR></TBODY></TABLE>
<P>Scala's regular expression class resides in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.util.matching</SPAN>.</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.util.matching.Regex
</PRE>A new regular expression value is created by passing a string to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Regex</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>constructor<A id=i78839847-1></A>. For instance:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Decimal</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Regex</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"(-)?(\\d+)(\\.\\d*)?"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">Decimal:&nbsp;scala.util.matching.Regex&nbsp;=&nbsp;(-)?(\d+)(\.\d*)?</SPAN>
</PRE>Note that, compared to the regular expression for decimal numbers given previously, every backslash appears twice in the string above. This is because in Java and Scala a single backslash is an escape character in a string literal, not a regular character that shows up in the string. So instead of `<SPAN class=code>\</SPAN>' you need to write `<SPAN class=code>\\</SPAN>' to get a single backslash in the string. 
<P></P>
<P>If a regular expression contains many backslashes this might be a bit painful to write and to read. Scala's raw strings provide an alternative.<A id=i-2061400628-1></A><A id=i-1493588176-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>As you saw in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#sec:literals">Section 5.2</A>, a raw string is a sequence of characters between triple quotes. The difference between a raw and a normal string is that all characters in a raw string appear exactly as they are typed. This includes backslashes, which are not treated as escape characters. So you could write equivalently and somewhat more legibly:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Decimal</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Regex</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"""(-)?(\d+)(\.\d*)?"""</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">Decimal:&nbsp;scala.util.matching.Regex&nbsp;=&nbsp;(-)?(\d+)(\.\d*)?</SPAN>
</PRE>As you can see from the interpreter's output, the generated result value for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Decimal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is exactly the same as before. 
<P></P>
<P>Another, even shorter way to write a regular expression in Scala is this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Decimal</SPAN>&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"""(-)?(\d+)(\.\d*)?"""</SPAN>.r
  <SPAN class=output style="COLOR: rgb(90,0,0)">Decimal:&nbsp;scala.util.matching.Regex&nbsp;=&nbsp;(-)?(\d+)(\.\d*)?</SPAN>
</PRE>In other words, simply append a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>.r</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to a string to obtain a regular expression.<A id=i578284412-1></A><A id=i2089497449-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This is possible because there is a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>r</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RichString</SPAN>, which converts a string to a regular expression. The method is defined as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#lst:the-r-method">Listing 24.7</A>:<A name=lst:the-r-method></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;scala.runtime
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.util.matching.Regex
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RichString</SPAN>(self:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;...&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;...
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;r&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Regex</SPAN>(self)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 24.7 - How the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>r</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is defined in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RichString</SPAN>.</H5>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Searching for regular expressions</H4>
<P>You can search for occurrences of a regular expression in a string using several different operators<A id=i945174444-1></A><A id=i1535162589-1></A><A id=i1068388242-1></A>:</P>
<P><SPAN class=code>regex</SPAN>&nbsp;<SPAN class=code>findFirstIn</SPAN>&nbsp;<SPAN class=code>str</SPAN></P>
<P><BR>Finds first occurrence of regular expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>regex</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>str</SPAN>, returning the result in an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Option</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type.</P>
<P><SPAN class=code>regex</SPAN>&nbsp;<SPAN class=code>findAllIn</SPAN>&nbsp;<SPAN class=code>str</SPAN></P>
<P><BR>Finds all occurrences of regular expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>regex</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>str</SPAN>, returning the results in an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN>.</P>
<P><SPAN class=code>regex</SPAN>&nbsp;<SPAN class=code>findPrefixOf</SPAN>&nbsp;<SPAN class=code>str</SPAN></P>
<P><BR>Finds an occurrence of regular expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>regex</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>at the start of string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>str</SPAN>, returning the result in an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Option</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type.</P>
<P><BR>For instance, you could define the input sequence below and then search decimal numbers in it:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Decimal</SPAN>&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"""(-)?(\d+)(\.\d*)?"""</SPAN>.r
  <SPAN class=output style="COLOR: rgb(90,0,0)">Decimal:&nbsp;scala.util.matching.Regex&nbsp;=&nbsp;(-)?(\d+)(\.\d*)?</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;input&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"for&nbsp;-1.0&nbsp;to&nbsp;99&nbsp;by&nbsp;3"</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">input:&nbsp;java.lang.String&nbsp;=&nbsp;for&nbsp;-1.0&nbsp;to&nbsp;99&nbsp;by&nbsp;3</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(s&nbsp;&lt;-&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Decimal</SPAN>&nbsp;findAllIn&nbsp;input)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(s)
  <SPAN class=output style="COLOR: rgb(90,0,0)">-1.0</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">99</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">3</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Decimal</SPAN>&nbsp;findFirstIn&nbsp;input
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;Option[String]&nbsp;=&nbsp;Some(-1.0)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Decimal</SPAN>&nbsp;findPrefixOf&nbsp;input
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;Option[String]&nbsp;=&nbsp;None</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Extracting with regular expressions</H4>
<P>What's more, every regular expression in Scala defines an extractor. The extractor is used to identify substrings that are matched by the groups of the regular expression. For instance, you could decompose a decimal number string as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Decimal</SPAN>(sign,&nbsp;integerpart,&nbsp;decimalpart)&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-1.23"</SPAN>&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">sign:&nbsp;String&nbsp;=&nbsp;-</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">integerpart:&nbsp;String&nbsp;=&nbsp;1</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">decimalpart:&nbsp;String&nbsp;=&nbsp;.23</SPAN>
</PRE>In this example, the pattern,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Decimal(...)</SPAN>, is used in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition, as described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#sec:patterns-everywhere">Section 15.7</A>. What happens here is that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Decimal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>regular expression value defines an<SPAN class=code>unapplySeq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. That method matches every string that corresponds to the regular expression syntax for decimal numbers. If the string matches, the parts that correspond to the three groups in the regular expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(-)?(\d+)(\.\d*)?</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are returned as elements of the pattern and are then matched by the three pattern variables<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sign</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>integerpart</SPAN>, and<SPAN class=code>decimalpart</SPAN>. If a group is missing, the element value is set to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN>, as can be seen in the following example:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Decimal</SPAN>(sign,&nbsp;integerpart,&nbsp;decimalpart)&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"1.0"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">sign:&nbsp;String&nbsp;=&nbsp;null</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">integerpart:&nbsp;String&nbsp;=&nbsp;1</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">decimalpart:&nbsp;String&nbsp;=&nbsp;.0</SPAN>
</PRE>It's also possible to mix extractors with regular expression searches in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression<A id=i1523429976-1></A>. For instance, the following expression decomposes all decimal numbers it finds in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>input</SPAN>string:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">Decimal</SPAN>(s,&nbsp;i,&nbsp;d)&nbsp;&lt;-&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Decimal</SPAN>&nbsp;findAllIn&nbsp;input)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"sign:&nbsp;"</SPAN>+&nbsp;s&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">",&nbsp;integer:&nbsp;"</SPAN>+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">",&nbsp;decimal:&nbsp;"</SPAN>+&nbsp;d)
  <SPAN class=output style="COLOR: rgb(90,0,0)">sign:&nbsp;-,&nbsp;integer:&nbsp;1,&nbsp;decimal:&nbsp;.0</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">sign:&nbsp;null,&nbsp;integer:&nbsp;99,&nbsp;decimal:&nbsp;null</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">sign:&nbsp;null,&nbsp;integer:&nbsp;3,&nbsp;decimal:&nbsp;null</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=24.8></A>24.8 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html#24.8">link</A>]</SPAN></H3>
<P>In this chapter you saw how to generalize pattern matching with extractors. Extractors let you define your own kinds of patterns, which need not correspond to the type of the expressions you select on. This gives you more flexibility in the kinds of patterns you can use for matching. In effect it's like having different possible views on the same data. It also gives you a layer between a type's representation and the way clients view it. This lets you do pattern matching while maintaining representation independence, a property which is very useful in large software systems.</P>
<P>Extractors are one more element in your tool box that let you define flexible library abstractions. They are used heavily in Scala's libraries, for instance, to enable convenient regular expression matching.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 24:</H4>
<P><A name=footnote24-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>As demonstrated here, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is applied to the tuple,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(user,</SPAN>&nbsp;<SPAN class=code>domain)</SPAN>, you can leave off one pair of parentheses when passing a tuple to a function that takes a single argument. Thus,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some(user,</SPAN>&nbsp;<SPAN class=code>domain)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>means the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some((user,</SPAN>&nbsp;<SPAN class=code>domain))</SPAN>.</P></DIV>