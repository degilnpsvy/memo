<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 29 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Combining Scala and Java</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>Scala code is often used in tandem with large Java programs and<SPAN class=Apple-converted-space>&nbsp;</SPAN>frameworks.<A id=i373161214-1></A><A id=i1128780868-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Since Scala is highly compatible with Java, most of the time you can combine the languages without worrying very much. For example, standard frameworks such as Swing, Servlets, and JUnit are known to work just fine with Scala. Nonetheless, from time to time you will run into some issue with combining Java and Scala.</P>
<P>This chapter describes two aspects of combining Java and Scala. First, it discusses how Scala is translated to Java, which is especially important if you call Scala code from Java. Second, it discusses the use of Java annotations in Scala, an important feature if you want to use Scala with an existing Java framework.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=29.1></A>29.1 Using Scala from Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combining-scala-and-java.html#29.1">link</A>]</SPAN></H3>
<P>Most of the time you can think of Scala at the source code level. However, you will have a richer understanding of how the system works if you know something about its translation. Further, if you call Scala code from Java, you will need to know what Scala code looks like from a Java point of view.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">General rules</H4>
<P>Scala is implemented as a translation to standard Java bytecodes<A id=i-1806853862-1></A>. As much as possible, Scala features map directly onto the equivalent Java features. Scala classes, methods, strings, exceptions, for example, are all compiled to the same in Java bytecode as their Java counterparts.</P>
<P>To make this happen required an occasional hard choice in the design of Scala. For example, it might have been nice to resolve overloaded methods at run time, using run-time types, rather than at compile time. Such a design would break with Java's, however, making it much trickier to mesh Java and Scala. In this case, Scala stays with Java's overloading resolution, and thus Scala methods and method calls can map directly to Java methods and method calls.</P>
<P>For other features Scala has its own design. For example, traits have no equivalent in Java. Similarly, while both Scala and Java have generic types, the details of the two systems clash. For language features like these, Scala code cannot be mapped directly to a Java construct, so it must be encoded using some combination of the structures Java does have.</P>
<P>For these features that are mapped indirectly, the encoding is not fixed. There is an ongoing effort to make the translations as simple as possible, so by the time you read this, some details may be different than at the time of writing. You can find out what translation your current Scala compiler uses by examining the "<SPAN class=texttt>.class</SPAN>" files with tools like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=texttt>javap</SPAN>.</P>
<P>Those are the general rules. Consider now some special cases.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Value types</H4>
<P>A value type like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be translated in two different ways to Java.<A id=i840866566-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Whenever possible, the compiler translates a Scala<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to a Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to get better performance.<A id=i884498802-4></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Sometimes this is not possible, though, because the compiler is not sure whether it is translating an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or some other data type. For example, a particular List[Any] might hold only<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>s, but the compiler has no way to be sure.</P>
<P>In cases like this, where the compiler is unsure whether an object is a value type or not, the compiler uses objects and relies on wrapper classes. Wrapper classes such as, for example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Integer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>allow a value type to be wrapped inside a Java object and thereby manipulated by code that needs objects.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combining-scala-and-java.html#footnote29-1">[1]</A></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Singleton objects</H4>
<P>Java has no exact equivalent to a singleton object, but it does have static methods.<A id=i-1734369148-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The Scala translation of singleton objects uses a combination of static and instance methods.<A id=i-855208314-1></A>For every Scala singleton object, the compiler will create a Java class for the object with a dollar sign added to the end. For a singleton object named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>App</SPAN>, the compiler produces a Java class named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>App$</SPAN>. This class has all the methods and fields of the Scala singleton object. The Java class also has a single static field named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MODULE$</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to hold the one instance of the class that is created at run time.</P>
<P>As a full example, suppose you compile the following singleton object:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">App</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;main(args:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello,&nbsp;world!"</SPAN>)
  &nbsp;&nbsp;}
  }
</PRE>Scala will generate a Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>App$</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class with the following fields and methods: 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;javap&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">App</SPAN>$
  <SPAN class=output style="COLOR: rgb(90,0,0)">public&nbsp;final&nbsp;class&nbsp;App$&nbsp;extends&nbsp;java.lang.Object</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">implements&nbsp;scala.ScalaObject{</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;final&nbsp;App$&nbsp;MODULE$;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;{};</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;App$();</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;main(java.lang.String[]);</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;$tag();</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">}</SPAN>
</PRE>That's the translation for the general case. An important special case is if you have a "standalone" singleton object, one which does not come with a class of the same name. For example, you might have a singleton object named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>App</SPAN>, and not have any class named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>App</SPAN>. In that case, the compiler will create a Java class named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>App</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that has a static forwarder method for each method of the Scala singleton object:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;javap&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">App</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Compiled&nbsp;from&nbsp;"App.scala"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">public&nbsp;final&nbsp;class&nbsp;App&nbsp;extends&nbsp;java.lang.Object{</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;final&nbsp;int&nbsp;$tag();</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;final&nbsp;void&nbsp;main(java.lang.String[]);</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">}</SPAN>
</PRE>To contrast, if you did have a class named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>App</SPAN>, Scala would create a corresponding Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>App</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class to hold the members of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>App</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class you defined. In that case it would not add any forwarding methods for the same-named singleton object, and Java code would have to access the singleton via the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MODULE$</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. 
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Traits as interfaces</H4>
<P>Compiling any trait creates a Java interface of the same name.<A id=i286095114-1></A><A id=i1983011802-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This interface is usable as a Java type, and it lets you call methods on Scala objects through variables of that type.</P>
<P>Implementing a trait in Java is another story. In the general case it is not practical. One special case is important, however. If you make a Scala trait that includes only abstract methods, then that trait will be translated directly to a Java interface, with no other code to worry about. Essentially this means that you can write a Java interface in Scala syntax if you like.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=29.2></A>29.2 Annotations<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combining-scala-and-java.html#29.2">link</A>]</SPAN></H3>
<P><A name=sec:annotations></A></P>
<P>Scala's general annotations system is discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/annotations.html">Chapter 25</A>. This section discusses Java-specific aspects of annotations.<A id=i-311881081-1></A></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Additional effects from standard annotations</H4>
<P>Several annotations cause the compiler to emit extra information when targeting the Java platform. When the compiler sees such an annotation, it first processes it according to the general Scala rules, and then it does something extra for Java.</P>
<P><B>Deprecation</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>For any method or class marked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@deprecated</SPAN>,<A id=i-1632344653-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>the compiler will add Java's own deprecation annotation to the emitted code. Because of this, Java compilers can issue deprecation warnings when Java code accesses deprecated Scala methods.</P>
<P><B>Volatile fields</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>Likewise, any field marked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@volatile</SPAN><A id=i-882906061-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala is given the Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>volatile</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier in the emitted code. Thus, volatile fields in Scala behave exactly according to Java's semantics, and accesses to volatile fields are sequenced precisely according to the rules specified for volatile fields in the Java memory model.</P>
<P><B>Serialization</B></P>
<P>Scala's three standard serialization annotations are all translated to Java equivalents. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@serializable</SPAN><A id=i-534731536-2></A><A id=i-897281643-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>class has Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Serializable</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>interface added to it. A<SPAN class=code>@SerialVersionUID(1234L)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>annotation is converted to the following Java field definition:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Java&nbsp;serial&nbsp;version&nbsp;marker</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">final</SPAN>&nbsp;static&nbsp;long&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SerialVersionUID</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1234L</SPAN>
</PRE>Any variable marked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@transient</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is given the Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>transient</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Exceptions thrown</H4>
<P>Scala does not check that thrown exceptions are caught.<A id=i-767472144-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>That is, Scala has no equivalent to Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>throws</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>declarations on methods.<A id=i1515336401-1></A><A id=i993633856-1></A><A id=i1490895901-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>All Scala methods are translated to Java methods that declare no thrown exceptions.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combining-scala-and-java.html#footnote29-2">[2]</A></P>
<P>The reason this feature is omitted from Scala is that the Java experience with it has not been purely positive. Because annotating methods with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>throws</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clauses is a heavy burden, too many developers write code that swallows and drops exceptions, just to get the code to compile without adding all those<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>throws</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clauses. They may intend to improve the exception handling later, but experience shows that all too often time-pressed programmers will never come back and add proper exception handling. The twisted result is that this well-intentioned feature often ends up making code<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">less</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>reliable. A large amount of production Java code swallows and hides runtime exceptions, and the reason it does so is to satisfy the compiler.</P>
<P>Sometimes when interfacing to Java, however, you may need to write Scala code that has Java-friendly annotations describing which exceptions your methods may throw. For example, each method in an RMI remote interface is required to mention<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.io.RemoteException</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>throws</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause. Thus, if you wish to write an RMI remote interface as a Scala trait with abstract methods, you would need to list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RemoteException</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>throws</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clauses for those methods. To accomplish this, all you have to do is mark your methods with<SPAN class=code>@throws</SPAN><A id=i-1229583646-1></A><A id=i1626806115-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>annotations. For example, the Scala class shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combining-scala-and-java.html#lst:throws-clause">Listing 29.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>has a method marked as throwing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>IOException</SPAN>.</P>
<P><A name=lst:throws-clause></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;java.io._
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Reader</SPAN>(fname:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;in&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BufferedReader</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">FileReader</SPAN>(fname))
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;@throws(classOf[<SPAN class=typename style="COLOR: rgb(103,0,154)">IOException</SPAN>])
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;read()&nbsp;=&nbsp;in.read()
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 29.1 - A Scala method that declares a Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>throws</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause.</H5>
<P>Here is how it looks from Java:<A id=i1433885554-2></A><A id=i385195690-2></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;javap&nbsp;Reader
  <SPAN class=output style="COLOR: rgb(90,0,0)">Compiled&nbsp;from&nbsp;"Reader.scala"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">public&nbsp;class&nbsp;Reader&nbsp;extends&nbsp;java.lang.Object&nbsp;implements</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">scala.ScalaObject{</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Reader(java.lang.String);</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;read()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;java.io.IOException;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;$tag();</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">}</SPAN>
  $
</PRE>Note that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>read</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method indicates with a Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>throws</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause that it may throw an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>IOException</SPAN>. 
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Java annotations</H4>
<P>Existing annotations from Java frameworks can be used directly in Scala code. Any Java framework will see the annotations you write just as if you were writing in Java.</P>
<P>A wide variety of Java packages use annotations. As an example, consider JUnit 4.<A id=i70981870-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>JUnit is a framework for writing automated tests and for running those tests. The latest version, JUnit 4, uses annotations to indicate which parts of your code are tests. The idea is that you write a lot of tests for your code, and then you run those tests whenever you change the source code. That way, if your changes add a new bug, one of the tests will fail and you will find out immediately.</P>
<P>Writing a test is easy. You simply write a method in a top-level class that exercises your code, and you use an annotation to mark the method as a test. It looks like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;org.junit.Test
  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;org.junit.Assert.assertEquals
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SetTest</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;@<SPAN class=typename style="COLOR: rgb(103,0,154)">Test</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;testMultiAdd&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;set&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>()&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;assertEquals(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;set.size)
  &nbsp;&nbsp;}
  }
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>testMultiAdd</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is a test. This test adds multiple items to a set and makes sure that each is added only once. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>assertEquals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which comes as part of the JUnit API, checks that its two arguments are equal. If they are different, then the test fails. In this case, the test verifies that repeatedly adding the same numbers does not increase the size of a set. 
<P></P>
<P>The test is marked using the annotation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>org.junit.Test</SPAN>. Note that this annotation has been imported, so it can be referred to as simply<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@Test</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of the more cumbersome<SPAN class=code>@org.junit.Test</SPAN>.<A id=i-1737029383-1></A><A id=i-380372540-1></A></P>
<P>That's all there is to it. The test can be run using any JUnit test runner. Here it is being run with the command-line test runner:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;-cp&nbsp;junit-4.3.<SPAN class=literal style="COLOR: rgb(205,123,0)">1.</SPAN>jar:.&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">org.junit.runner.JUnitCore</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SetTest</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">JUnit&nbsp;version&nbsp;4.3.1</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Time:&nbsp;0.023</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)"></SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">OK&nbsp;(1&nbsp;test)</SPAN>
</PRE>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Writing your own annotations</H4>
<P>To make an annotation that is visible to Java reflection,<A id=i-244877014-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>you must use<A id=i-1366299605-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Java notation and compile it with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>javac</SPAN><A id=i-1137870217-1></A>. For this use case, writing the annotation in Scala does not seem helpful, so the standard compiler does not support it. The reasoning is that the Scala support would inevitably fall short of the full possibilities of Java annotations, and further, Scala will probably one day have its own reflection, in which case you would want to access Scala annotations with Scala reflection.</P>
<P>Here is an example annotation:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;java.lang.annotation.*;
  @<SPAN class=typename style="COLOR: rgb(103,0,154)">Retention</SPAN>(RetentionPolicy.RUNTIME)
  @<SPAN class=typename style="COLOR: rgb(103,0,154)">Target</SPAN>(ElementType.METHOD)
  public&nbsp;@interface&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ignore</SPAN>&nbsp;{&nbsp;}
</PRE>After compiling the above with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>javac</SPAN>, you can use the annotation as follows:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tests</SPAN>&nbsp;{
  &nbsp;&nbsp;@<SPAN class=typename style="COLOR: rgb(103,0,154)">Ignore</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;testData&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;test1&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;assert(testData&nbsp;==&nbsp;(testData.head&nbsp;::&nbsp;testData.tail))
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;test2&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;assert(testData.contains(testData.head))
  &nbsp;&nbsp;}
  }
</PRE>In this example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>test1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>test2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are supposed to be test methods, but<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>testData</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should be ignored even though its name starts with "test". 
<P></P>
<P>To see when these annotations are present, you can use the Java reflection APIs. Here is sample code to show how it works:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;{
  &nbsp;&nbsp;method&nbsp;&lt;-&nbsp;Tests.getClass.getMethods
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;method.getName.startsWith(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"test"</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;method.getAnnotation(classOf[<SPAN class=typename style="COLOR: rgb(103,0,154)">Ignore</SPAN>])&nbsp;==&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">null</SPAN>
  }&nbsp;{
  &nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"found&nbsp;a&nbsp;test&nbsp;method:&nbsp;"</SPAN>&nbsp;+&nbsp;method)
  }
</PRE>Here, the reflective methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getClass</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getMethods</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are used to inspect all the fields of the input object's class. These are normal reflection methods. The annotation-specific part is the use of method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getAnnotation</SPAN>. As of Java 1.5, many reflection objects have a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getAnnotation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method for searching for annotations of a specific type. In this case, the code looks for an annotation of our new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ignore</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type. Since this is a Java API, success is indicated by whether the result is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or is an actual annotation object. 
<P></P>
<P>Here is the code in action:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;javac&nbsp;Ignore.java
  $&nbsp;scalac&nbsp;Tests.scala
  $&nbsp;scalac&nbsp;FindTests.scala
  $&nbsp;scala&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">FindTests</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">found&nbsp;a&nbsp;test&nbsp;method:&nbsp;public&nbsp;void&nbsp;Tests$.test2()</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">found&nbsp;a&nbsp;test&nbsp;method:&nbsp;public&nbsp;void&nbsp;Tests$.test1()</SPAN>
</PRE>As an aside, notice that the methods are in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tests$</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tests</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>when viewed with Java reflection. As described at the beginning of the chapter, the implementation of a Scala singleton object is placed in a Java class with a dollar sign added to the end of its name. In this case, the implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tests</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in the Java class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tests$</SPAN>. 
<P>Be aware that when you use Java annotations you have to work within their limitations. For example, you can only use constants, not expressions, in the arguments to annotations. You can support<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@serial(1234)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>but not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@serial(x * 2)</SPAN>, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not a constant.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=29.3></A>29.3 Existential types<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combining-scala-and-java.html#29.3">link</A>]</SPAN></H3>
<P><A name=sec:existentials></A></P>
<P>All Java types have a Scala equivalent.<A id=i-531244609-2></A><A id=i1673589657-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This is necessary so that Scala code can access any legal Java class. Most of the time the translation is straightforward.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Pattern</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java is<SPAN class=code>Pattern</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator&lt;Component&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator[Component]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala. For some cases, though, the Scala types you have seen so far are not enough. What can be done with Java wildcard types such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator&lt;?&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator&lt;?</SPAN>&nbsp;<SPAN class=code>extends</SPAN>&nbsp;<SPAN class=code>Component&gt;</SPAN>? What can be done about raw types like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN>, where the type parameter is omitted? For wildcard types and raw types, Scala uses an extra kind of type<A id=i414933374-2></A><A id=i1163979645-2></A><A id=i-119763145-1></A><A id=i-315542260-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>called an<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-1470033894"><EM style="FONT-STYLE: italic">existential type</EM></A>.</P>
<P>Existential types are a fully supported part of the language, but in practice they are mainly used when accessing Java types from Scala. This section gives a brief overview of how existential types work, but mostly this is only useful so that you can understand compiler error messages when your Scala code accesses Java code.</P>
<P>The general form of an existential type is as follows:<A id=i1318155814-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <I>type</I>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">forSome</SPAN>&nbsp;{&nbsp;<I>declarations</I>&nbsp;}
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">type</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>part is an arbitrary Scala type, and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">declarations</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>part is a list of abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>type</SPAN>s. The interpretation is that the declared variables and types exist but are unknown, just like abstract members of a class. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">type</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is then allowed to refer to the declared variables and types even though it is unknown what they refer to. 
<P></P>
<P>Take a look at some concrete examples. A Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator&lt;?&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be written in Scala as:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">Iterator[T]</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">forSome</SPAN>&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;T&nbsp;}
</PRE>Read this from left to right. This is an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>'s for some type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. The type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is unknown, and could be anything, but it is known to be fixed for this particular<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN>. Similarly, a Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator&lt;?</SPAN>&nbsp;<SPAN class=code>extends</SPAN>&nbsp;<SPAN class=code>Component&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be viewed in Scala as:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">Iterator[T]</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">forSome</SPAN>&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;T&nbsp;&lt;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Component</SPAN>&nbsp;}
</PRE>This is an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>, for some type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Component</SPAN>. In this case<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is still unknown, but now it is sure to be a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Component</SPAN>. 
<P></P>
<P>By the way, there is a shorter way to write these examples. If you write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator[_]</SPAN>, it means the same thing as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterator[T]</SPAN>&nbsp;<SPAN class=code>forSome</SPAN>&nbsp;<SPAN class=code>{</SPAN>&nbsp;<SPAN class=code>type</SPAN>&nbsp;<SPAN class=code>T</SPAN>&nbsp;<SPAN class=code>}</SPAN>. This is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">placeholder syntax</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>for existential types, and is similar in spirit to the placeholder syntax for function literals that was described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#sec:placeholder-syntax">Section 8.5</A>.<A id=i394425348-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>If you use an underscore (<SPAN class=code>_</SPAN>) in place of an expression, then Scala treats this as a placeholder and makes a function literal for you. For types it works similarly. If you use an underscore in place of a type, Scala makes an existential type for you. Each underscore becomes one type parameter in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>forSome</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause, so if you use two underscores in the same type, you will get the effect of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>forSome</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause with two types in it.</P>
<P>You can also insert upper and lower bounds when using this placeholder syntax. Simply add them to the underscore instead of in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>forSome</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause. The type<SPAN class=code>Iterator[_</SPAN>&nbsp;<SPAN class=code>&lt;:</SPAN>&nbsp;<SPAN class=code>Component]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the same as this one, which you just saw:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">Iterator[T]</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">forSome</SPAN>&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;T&nbsp;&lt;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Component</SPAN>&nbsp;}
</PRE>
<P></P>
<P>Enough about the existential types themselves. How do you actually use them? Well, in simple cases, you use an existential type just as if the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>forSome</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>were not there. Scala will check that the program is sound even though the types and values in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>forSome</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause are unknown. For example, suppose you had the following Java class:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  //&nbsp;This&nbsp;is&nbsp;a&nbsp;Java&nbsp;class&nbsp;with&nbsp;wildcards
  public&nbsp;class&nbsp;Wild&nbsp;{
  &nbsp;&nbsp;Collection&lt;?&gt;&nbsp;contents()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;Collection&lt;String&gt;&nbsp;stuff&nbsp;=&nbsp;new&nbsp;Vector&lt;String&gt;();
  &nbsp;&nbsp;&nbsp;&nbsp;stuff.add("a");
  &nbsp;&nbsp;&nbsp;&nbsp;stuff.add("b");
  &nbsp;&nbsp;&nbsp;&nbsp;stuff.add("see");
  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stuff;
  &nbsp;&nbsp;}
  }
</PRE>If you access this in Scala code you will see that it has an existential type: 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;contents&nbsp;=&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wild</SPAN>).contents
  <SPAN class=output style="COLOR: rgb(90,0,0)">contents:&nbsp;java.util.Collection[?0]&nbsp;forSome&nbsp;{&nbsp;type&nbsp;?0&nbsp;}&nbsp;=</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;[a,&nbsp;b,&nbsp;see]</SPAN>
</PRE>If you want to find out how many elements are in this collection, you can simply ignore the existential part and call the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>size</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method as normal:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;contents.size()
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
</PRE>In more complicated cases, existential types can be more awkward, because there is no way to name the existential type. For example, suppose you wanted to create a mutable Scala set and initialize it with the elements of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable.Set
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;iter&nbsp;=&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wild</SPAN>).contents.iterator
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;set&nbsp;=&nbsp;Set.empty[???]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;what&nbsp;type&nbsp;goes&nbsp;here?</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">while</SPAN>&nbsp;(iter.hasMore)
  &nbsp;&nbsp;set&nbsp;+=&nbsp;iter.next()
</PRE>A problem strikes on the third line. There is no way to name the type of elements in the Java collection, so you cannot write down a satisfactory type for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>set</SPAN>. To work around this kind of problem, here are two tricks you should consider: 
<OL>
<LI>When passing an existential type into a method, move type parameters from the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>forSome</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause to type parameters of the method. Inside the body of the method, you can use the type parameters to refer to the types that were in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>forSome</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause. 
<LI>Instead of returning an existential type from a method, return an object that has abstract members for each of the types in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>forSome</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause. (See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html">Chapter 20</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>for information on abstract members.)</LI></OL>Using these two tricks together, the previous code can be written as follows:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable.Set
  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;java.util.Collection
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SetAndType</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Elem</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;set:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set[Elem]</SPAN>
  }
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;javaSet2ScalaSet[T](jset:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Collection[T]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SetAndType</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;sset&nbsp;=&nbsp;Set.empty[T]&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;now&nbsp;T&nbsp;can&nbsp;be&nbsp;named!</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;iter&nbsp;=&nbsp;jset.iterator
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">while</SPAN>&nbsp;(iter.hasNext)
  &nbsp;&nbsp;&nbsp;&nbsp;sset&nbsp;+=&nbsp;iter.next()
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">return</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SetAndType</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Elem</SPAN>&nbsp;=&nbsp;T
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;set&nbsp;=&nbsp;sset
  &nbsp;&nbsp;}
  }
</PRE>You can see why Scala code normally does not use existential types. To do anything sophisticated with them, you tend to convert them to use abstract members. So you may as well use abstract members to begin with. 
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=29.4></A>29.4 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combining-scala-and-java.html#29.4">link</A>]</SPAN></H3>
<P>Most of the time, you can ignore how Scala is implemented and simply write and run your code. Sometimes it is nice to "look under the hood," however, so this chapter has gone into three aspects of Scala's implementation on the Java platform: what the translation looks like, how Scala and Java annotations work together, and how Scala's existential types let you access Java wildcard types. These topics are important whenever you use Scala and Java together.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 29:</H4>
<P><A name=footnote29-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The implementation of value types was discussed in detail in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scalas-hierarchy.html#sec:impl-primitives">Section 11.2</A>.</P>
<P><A name=footnote29-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The reason it all works is that the Java bytecode verifier does not check the declarations, anyway! The Java compiler checks, but not the verifier.</P></DIV>