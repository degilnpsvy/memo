<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 33 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">The SCells Spreadsheet</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>In the previous chapters you saw many different constructs of the Scala programming language. In this chapter you'll see how these constructs play together in the implementation of a sizable application. The task is to write a spreadsheet application, which will be named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SCells</SPAN>.<A id=i-1325982169-1></A></P>
<P>There are several reasons why this task is interesting. First, everybody knows spreadsheets, so it is easy to understand what the application should do. Second, spreadsheets are programs that exercise a large range of different computing tasks. There's the visual aspect, where a spreadsheet is seen as a rich GUI application.<A id=i1275390415-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>There's the symbolic aspect, having to do with formulas and how to parse and interpret them. There's the calculational aspect, dealing with how to update possibly large tables incrementally. There's the reactive aspect, where spreadsheets are seen as programs that react in intricate ways to events. Finally, there's the component aspect where the application is constructed as a set of reusable components.<A id=i-421431555-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>All these aspects will be treated in depth in this chapter.</P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:scells1></A>
<P><IMG alt="image images/scells1Gray60.jpg" src="http://www.artima.com/pins1ed/images/scells1Gray60.jpg"></P></DIV>
<H5>Figure 33.1 - A simple spreadsheet table.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=33.1></A>33.1 The visual framework<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#33.1">link</A>]</SPAN></H3>
<P>We'll start by writing the basic visual framework of the application.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#fig:scells1">Figure 33.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows the first iteration of the user interface. You can see that a spreadsheet is a scrollable table. It has rows going from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>99</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and columns going from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Z</SPAN>. You express this in Swing by defining a spreadsheet as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ScrollPane</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>containing a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Table</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Spreadsheet1">Listing 33.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows the code.<A id=i870227341-1></A><A id=i455478918-1></A></P>
<P><A name=lst:scells-Spreadsheet1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;swing._
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Spreadsheet</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ScrollPane</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;table&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Table</SPAN>(height,&nbsp;width)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rowHeight&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">25</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autoResizeMode&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Table.AutoResizeMode.Off</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showGrid&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gridColor&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">java.awt.Color</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">150</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">150</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">150</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;rowHeader&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ListView</SPAN>((<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;until&nbsp;height)&nbsp;map&nbsp;(_.toString))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedCellWidth&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">30</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedCellHeight&nbsp;=&nbsp;table.rowHeight
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;viewportView&nbsp;=&nbsp;table
  &nbsp;&nbsp;&nbsp;&nbsp;rowHeaderView&nbsp;=&nbsp;rowHeader
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 33.1 - Code for spreadsheet in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#fig:scells1">Figure 33.1</A>.</H5>
<P>The spreadsheet component shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Spreadsheet1">Listing 33.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>org.stairwaybook.scells</SPAN>, which will contain all classes, traits, and objects needed for the application. It imports from package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.swing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>essential elements of Scala's Swing wrapper.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Spreadsheet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>itself is a class that takes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>height</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(in numbers of cells) as parameters. The class extends<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ScrollPane</SPAN>, which gives it the scroll-bars at the bottom and right in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#fig:scells1">Figure 33.1</A>. It contains two sub-components named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>table</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rowHeader</SPAN>.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>table</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>component is an instance of an anonymous subclass of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.swing.Table</SPAN>. The four lines in its body set some of its attributes:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rowHeight</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for the height of a table row in points,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>autoResizeMode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to turn auto-sizing the table off,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>showGrid</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to show a grid of lines between cells, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>gridColor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to set the color of the grid to a dark gray.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rowHeader</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>component, which contains the row-number headers at the left of the spreadsheet in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#fig:scells1">Figure 33.1</A>, is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ListView</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that displays in its elements the strings<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>through<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>99</SPAN>.<A id=i1410352259-1></A>The two lines in its body fix the width of a cell to be 30 points and the height to be the same as the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>table</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rowHeight</SPAN>.</P>
<P>The whole spreadsheet is assembled by setting two fields in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ScrollPane</SPAN>. The field<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>viewportView</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is set to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>table</SPAN>, and the field<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rowHeaderView</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is set to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rowHeader</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list.<A id=i-184785362-1></A><A id=i-1248398867-1></A><A id=i870227341-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The difference between the two views is that a view port of a scroll pane is the area that scrolls with the two bars, whereas the row header on the left stays fixed when you move the horizontal scroll bar. By some quirk, Swing already supplies by default a column header at the top of the table, so there's no need to define one explicitly.</P>
<P><A name=lst:scells-Main></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;swing._
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Main</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SimpleGUIApplication</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;top&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">MainFrame</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"ScalaSheet"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Spreadsheet</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">100</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">26</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 33.2 - The main program for the spreadsheet application.</H5>
<P>To try out the rudimentary spreadsheet shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Spreadsheet1">Listing 33.1</A>, you just need to define a main program that creates<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Spreadsheet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>component. Such a program is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Main">Listing 33.2</A>.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Main</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>program inherits from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SimpleGUIApplication</SPAN>, which takes care of all the low-level details that need to be set up before a Swing application can be run.<A id=i1631071135-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You only need to define the top-level window of the application in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>top</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. In our example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>top</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MainFrame</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that has two elements defined: its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>title</SPAN>, set to "ScalaSheet," and its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN>, set to an instance of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Spreadsheet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>100</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>rows and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>26</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>columns. That's all. If you launch this application with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN>&nbsp;<SPAN class=code>org.stairwaybook.scells.Main</SPAN>, you should see the spreadsheet in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#fig:scells1">Figure 33.1</A>.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=33.2></A>33.2 Disconnecting data entry and display<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#33.2">link</A>]</SPAN></H3>
<P>If you play a bit with the spreadsheet written so far, you'll quickly notice that the output that's displayed in a cell is always exactly what you entered in the cell. A real spreadsheet does not behave like that. In a real spreadsheet, you would enter a formula and you'd see its value. So what is entered into a cell is different from what is displayed.</P>
<P><A name=lst:scells-Spreadsheet2></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.scells
  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;swing._
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Spreadsheet</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ScrollPane</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;cellModel&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Model</SPAN>(height,&nbsp;width)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;cellModel._
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;table&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Table</SPAN>(height,&nbsp;width)&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;settings&nbsp;as&nbsp;before...&nbsp;</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;rendererComponent(isSelected:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasFocus:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>,&nbsp;row:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;column:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Component</SPAN>&nbsp;=
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(hasFocus)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">TextField</SPAN>(userData(row,&nbsp;column))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Label</SPAN>(cells(row)(column).toString)&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xAlignment&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Alignment.Right</SPAN>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;userData(row:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;column:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;v&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>(row,&nbsp;column)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(v&nbsp;==&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">null</SPAN>)&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">""</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;v.toString
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;rest&nbsp;as&nbsp;before...&nbsp;</SPAN>
  }&nbsp;
</PRE>
<H5>Listing 33.3 - A spreadsheet with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rendererComponent</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.</H5>
<P>As a first step to a real spreadsheet application, you should concentrate on disentangling data entry and display. The basic mechanism for display is contained in the<SPAN class=code>rendererComponent</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Table</SPAN>.<A id=i455478918-2></A><A id=i-1871849869-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>By default,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rendererComponent</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>always displays what's entered. If you want to change that, you need to override<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rendererComponent</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to do something different.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Spreadsheet2">Listing 33.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a new version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Spreadsheet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rendererComponent</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rendererComponent</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method overrides a default method in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Table</SPAN>. It takes four parameters. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isSelected</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hasFocus</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameters are<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN>s that indicate whether the cell has been selected and whether it has focus, meaning that keyboard events will go into into the cell. The remaining two parameters,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>row</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>column</SPAN>, give the cell's coordinates.</P>
<P>The new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rendererComponent</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method checks whether the cell has input focus. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hasFocus</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is true, the cell is used for editing. In this case you want to display an editable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TextField</SPAN>that contains the data the user has entered so far.<A id=i942981037-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This data is returned by the helper method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>userData</SPAN>, which displays the contents of the table at a given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>row</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>column</SPAN>. The contents are retrieved by the call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this(row,</SPAN>&nbsp;<SPAN class=code>column)</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#footnote33-1">[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>userData</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method also takes care to display a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>element as the empty string instead of "<SPAN class=code>null</SPAN>".</P>
<P>So far so good. But what should be displayed if the cell does not have focus? In a real spreadsheet this would be the value of a cell. Thus, there are really two tables at work. The first table, named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>table</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains what the user entered. A second "shadow" table contains the internal representation of cells and what should be displayed. In the spreadsheet example, this table is a two-dimensional array called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cells</SPAN>. If a cell at a given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>row</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>column</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not have editing focus, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rendererComponent</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method will display the element<SPAN class=code>cells(row)(column)</SPAN>. The element cannot be edited, so it should be displayed in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Label</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of in an editable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TextField</SPAN>.<A id=i73174740-1></A></P>
<P>It remains to define the internal array of cells. You could do this directly in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Spreadsheet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class, but it's generally preferable to separate the view of a GUI component from its internal model. That's why in the example above the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cells</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>array is defined in a separate class named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN>. The model is integrated into the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Spreadsheet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by defining a value<SPAN class=code>cellModel</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>import</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause that follows this<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition makes the members of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cellModel</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>available inside<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Spreadsheet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>without having to prefix them.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Model1">Listing 33.4</A>shows a first simplified version of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. The class defines an inner class,<A id=i178325035-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN>, and a two-dimensional array,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cells</SPAN>, of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>elements. Each element is initialized to be a fresh<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN>.</P>
<P><A name=lst:scells-Model1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.scells
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Model</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{&nbsp;
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cell</SPAN>(row:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;column:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;cells&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[Array[Cell]]</SPAN>(height,&nbsp;width)&nbsp;
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(i&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;until&nbsp;height;&nbsp;j&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;until&nbsp;width)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells(i)(j)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cell</SPAN>(i,&nbsp;j)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 33.4 - First version of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class.</H5>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:scells2></A>
<P><IMG alt="image images/scells2Gray60.jpg" src="http://www.artima.com/pins1ed/images/scells2Gray60.jpg"></P></DIV>
<H5>Figure 33.2 - Cells displaying themselves.</H5>
<P>That's it. If you compile the modified<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Spreadsheet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait and run the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Main</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>application you should see a window as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#fig:scells2">Figure 33.2</A>.</P>
<P>The objective of this section was to arrive at a design where the displayed value of a cell is different from the string that was entered into it. This objective has clearly been met, albeit in a very crude way. In the new spreadsheet you can enter anything you want into a cell, but it will always display just its coordinates once it loses focus. Clearly, we are not done yet.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=33.3></A>33.3 Formulas<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#33.3">link</A>]</SPAN></H3>
<P>In reality, a spreadsheet cell holds two things: An actual<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">formula</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to compute this value. There are three types of formulas in a spreadsheet:</P>
<OL>
<LI>Numeric values such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1.22</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-3</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN>. 
<LI>Textual labels such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Annual</SPAN>&nbsp;<SPAN class=code>sales</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Deprecation</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>total</SPAN>. 
<LI>Formulas that compute a new value from the contents of cells, such as "<SPAN class=code>=add(A1,B2)</SPAN>", or "<SPAN class=code>=sum(mul(2,</SPAN>&nbsp;<SPAN class=code>A2),</SPAN>&nbsp;<SPAN class=code>C1:D16)</SPAN>"</LI></OL>A formula that computes a value always starts with an equals sign and is followed by an arithmetic expression. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SCells</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>spreadsheet has a particularly simple and uniform convention for arithmetic expressions: every expression is an application of some function to a list of arguments. The function name is an identifier such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>add</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for binary addition, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for summation of an arbitrary number of operands. A function argument can be a number, a reference to a cell, a reference to a range of cells such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C1:D16</SPAN>, or another function application. You'll see later that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SCells</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has an open architecture that makes it easy to install your own functions via mixin composition. 
<P>The first step to handling formulas is writing down the types that represent them. As you might expect, the different kinds of formulas are represented by case classes.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Formulas">Listing 33.5</A>shows the contents of a file named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Formulas.scala</SPAN>, where these case classes are defined:<A id=i1927236622-1></A></P>
<P><A name=lst:scells-Formulas></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.scells
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>&nbsp;&nbsp;
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Coord</SPAN>(row:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;column:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'A'</SPAN>&nbsp;+&nbsp;column).toChar.toString&nbsp;+&nbsp;row
  }
  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Range</SPAN>(c1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Coord</SPAN>,&nbsp;c2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Coord</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;c1.toString&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">":"</SPAN>+&nbsp;c2.toString
  }
  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(value:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;value.toString&nbsp;
  }
  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Textual</SPAN>(value:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;value
  }
  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Application</SPAN>(function:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;arguments:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Formula]</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>&nbsp;{&nbsp;
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;+&nbsp;arguments.mkString(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"("</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">","</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">")"</SPAN>)
  }
  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Empty</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Textual</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">""</SPAN>)
</PRE>
<H5>Listing 33.5 - Classes representing formulas.</H5>
<P>The root of the class hierarchy shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Formulas">Listing 33.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Formula</SPAN>. This trait has five case classes as children:</P>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="">
<TD><SPAN class=code>Coord</SPAN></TD>
<TD>for cell coordinates such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A3</SPAN>,</TD></TR>
<TR class="">
<TD><SPAN class=code>Range</SPAN></TD>
<TD>for cell ranges such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A3:B17</SPAN>,</TD></TR>
<TR class="">
<TD><SPAN class=code>Number</SPAN></TD>
<TD>for floating-point numbers such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>3.1415</SPAN>,</TD></TR>
<TR class="">
<TD><SPAN class=code>Textual</SPAN></TD>
<TD>for textual labels such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Deprecation</SPAN>,</TD></TR>
<TR class="">
<TD><SPAN class=code>Application</SPAN></TD>
<TD>for function applications such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum(A1,A2)</SPAN>.</TD></TR></TBODY></TABLE>
<P>Each case class overrides the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method so that it displays its kind of formula in the standard way shown above. For convenience there's also an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Empty</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object that represents the contents of an empty cell. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Empty</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object is an instance of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Textual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class with an empty string argument.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=33.4></A>33.4 Parsing formulas<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#33.4">link</A>]</SPAN></H3>
<P>In the previous section you saw the different kinds of formulas and how they display as strings.<A id=i-2095840458-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In this section you'll see how to reverse the process: that is, how to transform a user input string into a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Formula</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>tree. The rest of this section explains one by one the different elements of a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>FormulaParsers</SPAN>, which contains the parsers that do the transformation. The class builds on the combinator framework given in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html">Chapter 31</A>. Specifically, formula parsers are an instance of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RegexParsers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class explained in that chapter:<A id=i519257659-3></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.scells
  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.util.parsing.combinator._
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">FormulaParsers</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RegexParsers</SPAN>&nbsp;{&nbsp;
</PRE>
<P></P>
<P>The first two elements of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>FormulaParser</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class are auxiliary parsers for identifiers and decimal numbers:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;ident:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[String]</SPAN>&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"""[a-zA-Z_]\w*"""</SPAN>.r
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;decimal:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[String]</SPAN>&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"""-?\d+(\.\d*)?"""</SPAN>.r
</PRE>As you can see from the first regular expression above, an identifier starts with a letter or underscore.<A id=i-2139156663-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This is followed by an arbitrary number of "word" characters represented by the regular expression code<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\w</SPAN>, which recognizes letters, digits or underscores. The second regular expression describes decimal numbers, which consist of an optional minus sign, one or more digits that are represented by regular expression code<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>\d</SPAN>, and an optional decimal part consisting of a period followed by zero or more digits. 
<P></P>
<P>The next element of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>FormulaParsers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser, which recognizes the coordinates of a cell, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C11</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>B2</SPAN>. It first calls a regular expression parser that determines the form of a coordinate: a single letter followed by one or more digits. The string returned from that parser is then converted to a cell coordinate by separating the letter from the numerical part and converting the two parts to indices for the cell's column and row:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;cell:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Coord]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"""[A-Za-z]\d+"""</SPAN>.r&nbsp;^^&nbsp;{&nbsp;s&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;column&nbsp;=&nbsp;s.charAt(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;-&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'A'</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;row&nbsp;=&nbsp;s.substring(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>).toInt
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Coord</SPAN>(row,&nbsp;column)
  &nbsp;&nbsp;}
</PRE>Note that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser is a bit restrictive in that it allows only column coordinates consisting of a single letter. Hence the number of spreadsheet columns is in effect restricted to be at most 26, because further columns cannot be parsed. It's a good idea to generalize the parser so that it accepts cells with several leading letters. This is left as an exercise to you. 
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>range</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser recognizes a range of cells. Such a range is composed of two cell coordinates with a colon between them:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;range:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Range]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;cell<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">":"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>cell&nbsp;^^&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;c1<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">":"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>c2&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Range</SPAN>(c1,&nbsp;c2)&nbsp;
  &nbsp;&nbsp;}
</PRE>
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>number</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser recognizes a decimal number, which is converted to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and wrapped in an instance of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Number</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;number:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Number]</SPAN>&nbsp;=
  &nbsp;&nbsp;decimal&nbsp;^^&nbsp;(d&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(d.toDouble))
</PRE>
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>application</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser recognizes a function application. Such an application is composed of an identifier followed by a list of argument expressions in parentheses:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;application:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Application]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;ident<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"("</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>repsep(expr,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">","</SPAN>)<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">")"</SPAN>&nbsp;^^&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;f<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"("</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>ps<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">")"</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Application</SPAN>(f,&nbsp;ps)&nbsp;
  &nbsp;&nbsp;}
</PRE>
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser recognizes a formula expression&#8212;either a top-level formula following an `<SPAN class=code>=</SPAN>', or an argument to a function. Such a formula expression is defined to be a cell, a range of cells, a number, or an application:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;expr:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Formula]</SPAN>&nbsp;=
  &nbsp;&nbsp;range&nbsp;|&nbsp;cell&nbsp;|&nbsp;number&nbsp;|&nbsp;application
</PRE>This definition of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser contains a slight oversimplification because ranges of cells should only appear as function arguments; they should not be allowed as top-level formulas. You could change the formula grammar so that the two uses of expressions are separated, and ranges are excluded syntactically from top-level formulas. In the spreadsheet presented here such an error is instead detected once an expression is evaluated. 
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>textual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser recognizes an arbitrary input string, as long as it does not start with an equals sign (recall that strings that start with `<SPAN class=code>=</SPAN>' are considered to be formulas):</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;textual:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Textual]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"""[^=].*"""</SPAN>.r&nbsp;^^&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Textual</SPAN>
</PRE>
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formula</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser recognizes all kinds of legal inputs into a cell. A formula is either a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>number</SPAN>, or a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>textual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>entry, or a formula starting with an equals sign:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;formula:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Formula]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;number&nbsp;|&nbsp;textual&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"="</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>&gt;expr
</PRE>
<P></P>
<P>This concludes the grammar for spreadsheet cells. The final method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>parse</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>uses this grammar in a method that converts an input string into a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Formula</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>tree:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;parse(input:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;parseAll(formula,&nbsp;input)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Success</SPAN>(e,&nbsp;_)&nbsp;=&gt;&nbsp;e
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;f:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">NoSuccess</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Textual</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"["</SPAN>+&nbsp;f.msg&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"]"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  }&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//end&nbsp;FormulaParsers</SPAN>
</PRE>
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>parse</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method parses all of the input with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formula</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser. If that succeeds, the resulting formula is returned. If it fails, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Textual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object with an error message is returned instead.</P>
<P><A name=lst:spreadsheet-parses-formulas></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;swing._
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;event._
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Spreadsheet</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;...&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;table&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Table</SPAN>(height,&nbsp;width)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reactions&nbsp;+=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">TableUpdated</SPAN>(table,&nbsp;rows,&nbsp;column)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(row&nbsp;&lt;-&nbsp;rows)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells(row)(column).formula&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FormulaParsers.parse(userData(row,&nbsp;column))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 33.6 - A spreadsheet that parses formulas.</H5>
<P>That's everything there is to parsing formulas. The only thing that remains is to integrate the parser into the spreadsheet. To do this, you can enrich the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formula</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cell</SPAN>(row:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;column:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;formula:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Empty</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;formula.toString
  }
</PRE>In the new version of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is defined to display the cell's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formula</SPAN>. That way you can check whether formulas have been correctly parsed. 
<P></P>
<P>The last step in this section is to integrate the parser into the spreadsheet. Parsing a formula happens as a reaction to the user's input into a cell. A completed cell input is modeled in the Swing library by a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TableUpdated</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>event.<A id=i1392790829-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TableUpdated</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class is contained in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.swing.event</SPAN>. The event is of the form:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">TableUpdated</SPAN>(table,&nbsp;rows,&nbsp;column)
</PRE>It contains the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>table</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that was changed, as well as a set of coordinates of affected cells given by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rows</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>column</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rows</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter is a range value of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Range[Int]</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#footnote33-2">[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=code>column</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter is an integer. So in general a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TableUpdated</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>event can refer to several affected cells, but they would be on a consecutive range of rows and share the same column. 
<P></P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:scells3></A>
<P><IMG alt="image images/scells3Gray60.jpg" src="http://www.artima.com/pins1ed/images/scells3Gray60.jpg"></P></DIV>
<H5>Figure 33.3 - Cells displaying their formulas.</H5>
<P>Once a table is changed, the affected cells need to be re-parsed. To react to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>TableUpdated</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>event, you add a case to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reactions</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>value of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>table</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>component, as is shown in<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:spreadsheet-parses-formulas">Listing 33.6</A>.<A id=i-1242645043-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Now, whenever the table is edited the formulas of all affected cells will be updated by parsing the corresponding user data. When compiling the classes discussed so far and launching the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scells.Main</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>application you should see a spreadsheet application like the one shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#fig:scells3">Figure 33.3</A>. You can edit cells by typing into them. After editing is done, a cell displays the formula it contains. You can also try to type some illegal input such as the one reading<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=add(1,</SPAN>&nbsp;<SPAN class=code>X)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the field that has the editing focus in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#fig:scells3">Figure 33.3</A>. Illegal input will show up as an error message. For instance, once you'd leave the edited field in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#fig:scells3">Figure 33.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>you should see the error message<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>[`('</SPAN>&nbsp;<SPAN class=code>expected]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the cell (to see all of the error message you might need to widen the column by dragging the separation between the column headers to the right).</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=33.5></A>33.5 Evaluation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#33.5">link</A>]</SPAN></H3>
<P>Of course, in the end a spreadsheet should evaluate formulas, not just display them. In this section, we'll add the necessary components to achieve this.</P>
<P>What's needed is a method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>evaluate</SPAN>, which takes a formula and returns the value of that formula in the current spreadsheet, represented as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>. We'll place this method in a new trait,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Evaluator</SPAN>. The method needs to access the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cells</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to find out about the current values of cells that are referenced in a formula. On the other hand, the<SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class needs to call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>evaluate</SPAN>. Hence, there's a mutual dependency between the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Evaluator</SPAN>. A good way to express such mutual dependencies between classes was shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/modular-programming-using-objects.html">Chapter 27</A>: you use inheritance in one direction and self types in the other.<A id=i1009253694-1></A><A id=i1609470629-1></A><A id=i-560124499-2></A></P>
<P>In the spreadsheet example, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>inherits from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Evaluator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and thus gains access to its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>evaluation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. To go the other way, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Evaluator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defines its self type to be<SPAN class=code>Model</SPAN>, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.scells
  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Evaluator</SPAN>&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Model</SPAN>&nbsp;=&gt;&nbsp;...
</PRE>That way, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>value inside class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Evaluator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is assumed to be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cells</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>array is accessible by writing either<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cells</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this.cells</SPAN>. 
<P></P>
<P>Now that the wiring is done, we'll concentrate on defining the contents of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Evaluator</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:evaluate-method">Listing 33.7</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows the implementation of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>evaluate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. As you might expect, the method contains a pattern match over the different types of formulas.<A id=i1154860961-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For a coordinate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Coord(row,</SPAN>&nbsp;<SPAN class=code>column)</SPAN>, it returns the value of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cells</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>array at that coordinate. For a number<SPAN class=code>Number(v)</SPAN>, it returns the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>v</SPAN>. For a textual label<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Textual(s)</SPAN>, it returns zero. Finally, for an application<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Application(function,</SPAN>&nbsp;<SPAN class=code>arguments)</SPAN>, it computes the values of all arguments, retrieves a function object corresponding to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>function</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>name from an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>operations</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>table and applies that function to all argument values.<A name=lst:evaluate-method></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;evaluate(e:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">try</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;e&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Coord</SPAN>(row,&nbsp;column)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells(row)(column).value
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(v)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Textual</SPAN>(_)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Application</SPAN>(function,&nbsp;arguments)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;argvals&nbsp;=&nbsp;arguments&nbsp;flatMap&nbsp;evalList
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operations(function)(argvals)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">catch</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;ex:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Exception</SPAN>&nbsp;=&gt;&nbsp;Math.NaN_DOUBLE
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 33.7 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>evaluate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method of trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Evaluator</SPAN>.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>operations</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>table maps function names to function objects. It is defined as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Op</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Double]</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;operations&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">collection.mutable.HashMap[String, Op]</SPAN>
</PRE>As you can see from this definition, operations are modeled as functions from lists of values to values. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Op</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type introduces a convenient alias for the type of an operation. 
<P></P>
<P>The computation in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>evaluate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is wrapped in a try-catch to guard against input errors. There are actually quite a few things that can go wrong when evaluating a cell formula: coordinates might be out of range; function names might be undefined; functions might have the wrong number of arguments; arithmetic operations might be illegal or overflow. The reaction to any of these errors is the same: a "not-a-number" value is returned. The returned value,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Math.NaN_DOUBLE</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the IEEE representation for a computation that does not have a representable floating-point value.<A id=i995050225-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This might happen because of an overflow or a division by zero, for example. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>evaluate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:evaluate-method">Listing 33.7</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>chooses to return the same value also for all other kinds of errors. The advantage of this scheme is that it's simple to understand and doesn't require much code to implement. Its disadvantage is that all kinds of errors are lumped together, so a spreadsheet user does not get any detailed feedback on what went wrong. If you wish you can experiment with more refined ways of representing errors in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SCells</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>application.</P>
<P>The evaluation of arguments is different from the evaluation of top-level formulas. Arguments may be lists whereas top-level functions may not. For instance, the argument expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A1:A3</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum(A1:A3)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns the values of cells<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A1</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A2</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A3</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in a list. This list is then passed to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation. It's also possible to mix lists and single values in argument expressions, for instance the operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum(A1:A3,</SPAN>&nbsp;<SPAN class=code>1.0,</SPAN>&nbsp;<SPAN class=code>C7)</SPAN>, which would sum up five values. To handle arguments that might evaluate to lists, there's another evaluation function, called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>evalList</SPAN>. This function takes a formula and returns a list of values. Here is its definition:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;evalList(e:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Double]</SPAN>&nbsp;=&nbsp;e&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Range</SPAN>(_,&nbsp;_)&nbsp;=&gt;&nbsp;references(e)&nbsp;map&nbsp;(_.value)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(evaluate(e))
  }
</PRE>If the formula argument passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>evalList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Range</SPAN>, the returned value is a list consisting of the values of all cells referenced by the range. For every other formula the result is a list consisting of the single result value of that formula. The cells referenced by a formula are computed by a third function,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>references</SPAN>. Here is its definition:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;references(e:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Cell]</SPAN>&nbsp;=&nbsp;e&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Coord</SPAN>(row,&nbsp;column)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(cells(row)(column))
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Range</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Coord</SPAN>(r1,&nbsp;c1),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Coord</SPAN>(r2,&nbsp;c2))&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(row&nbsp;&lt;-&nbsp;(r1&nbsp;to&nbsp;r2).toList;&nbsp;column&nbsp;&lt;-&nbsp;c1&nbsp;to&nbsp;c2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;cells(row)(column)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Application</SPAN>(function,&nbsp;arguments)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments&nbsp;flatMap&nbsp;references
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
  &nbsp;&nbsp;}
  }&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;end&nbsp;Evaluator</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>references</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is actually more general than needed right now in that it computes the list of cells referenced by any sort of formula, not just a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Range</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>formula. It will turn out later that the added functionality is needed to compute the sets of cells that need updating. The body of the method is a straightforward pattern match on kinds of formulas. For a coordinate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Coord(row,</SPAN>&nbsp;<SPAN class=code>column)</SPAN>, it returns a single-element list containing the cell at that coordinate. For a range expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Range(coord1,</SPAN>&nbsp;<SPAN class=code>coord2)</SPAN>, it returns all cells between the two coordinates, computed by a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. For a function application<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Application(function,</SPAN>&nbsp;<SPAN class=code>arguments)</SPAN>, it returns the cells referenced by each argument expression, concatenated via<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into a single list. For the other two types of formulas,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Textual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Number</SPAN>, it returns an empty list. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=33.6></A>33.6 Operation libraries<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#33.6">link</A>]</SPAN></H3>
<P>The class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Evaluator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>itself defines no operations that can be performed on cells: its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>operations</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>table is initially empty. The idea is to define such operations in other traits, which are then mixed into the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class.<A id=i464307868-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Arithmetic">Listing 33.8</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an example trait that implements common arithmetic operations:</P>
<P><A name=lst:scells-Arithmetic></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Arithmetic</SPAN>&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Evaluator</SPAN>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;operations&nbsp;+=&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"add"</SPAN>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"sub"</SPAN>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;-&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"div"</SPAN>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;/&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"mul"</SPAN>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;*&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"mod"</SPAN>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;%&nbsp;y&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"sum"</SPAN>&nbsp;&nbsp;-&gt;&nbsp;{&nbsp;xs&nbsp;=&gt;&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">0.0</SPAN>&nbsp;/:&nbsp;xs)(_&nbsp;+&nbsp;_)&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"prod"</SPAN>&nbsp;-&gt;&nbsp;{&nbsp;xs&nbsp;=&gt;&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">1.0</SPAN>&nbsp;/:&nbsp;xs)(_&nbsp;*&nbsp;_)&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 33.8 - A library for arithmetic operations.</H5>
<P>Interestingly, this trait has no exported members. The only thing it does is populate the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>operations</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>table during its initialization. It gets access to that table by using a self type<SPAN class=code>Evaluator</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, by the same technique the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Arithmetic</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class uses to get access to the model.<A id=i1609470629-2></A><A id=i-560124499-3></A></P>
<P>Of the seven operations that are defined by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Arithmetic</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait, five are binary operations and two take an arbitrary number of arguments. The binary operations all follow the same schema. For instance, the addition operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>add</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined by the expression:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  {&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x,&nbsp;y)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;y&nbsp;}
</PRE>That is, it expects an argument list consisting of two elements<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and returns the sum of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN>. If the argument list contains a number of elements different from two, a<SPAN class=code>MatchError</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is thrown. This corresponds to the general "let it crash" philosophy of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SCell</SPAN>'s evaluation model, where incorrect input is expected to lead to a runtime exception that then gets caught by the try-catch inside the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>evaluation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. 
<P></P>
<P>The last two operations,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>prod</SPAN>, take a list of arguments of arbitrary length and insert a binary operation between successive elements. So they are instances of the "fold left" schema that's expressed in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>/:</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation. For instance, to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>a list of numbers<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(x,</SPAN>&nbsp;<SPAN class=code>y,</SPAN>&nbsp;<SPAN class=code>z)</SPAN>, the operation computes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>z</SPAN>. The first operand,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN>, is the result if the list is empty.</P>
<P>You can integrate this operation library into the spreadsheet application by mixing the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Arithmetic</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait into the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.scells
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Model</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Evaluator</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Arithmetic</SPAN>&nbsp;{&nbsp;
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cell</SPAN>(row:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;column:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;formula:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Empty</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;value&nbsp;=&nbsp;evaluate(formula)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;formula&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Textual</SPAN>(s)&nbsp;=&gt;&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;value.toString
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;...&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;rest&nbsp;as&nbsp;before</SPAN>
  }
</PRE>Another change in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class concerns the way cells display themselves. In the new version, the displayed value of a cell depends on its formula. If the formula is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Textual</SPAN>field, the contents of the field are displayed literally. In all other cases, the formula is evaluated and the result<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of that evaluation is displayed. 
<P></P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:scells4></A>
<P><IMG alt="image images/scells4Gray60.jpg" src="http://www.artima.com/pins1ed/images/scells4Gray60.jpg"></P></DIV>
<H5>Figure 33.4 - Cells that evaluate.</H5>
<P>If you compile the changed traits and classes and relaunch the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Main</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>program you get something that starts to resemble a real spreadsheet.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#fig:scells4">Figure 33.4</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an example. You can enter formulas into cells and get them to evaluate themselves. For instance, once you close the editing focus on cell<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C5</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#fig:scells4">Figure 33.4</A>, you should see<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>86.0</SPAN>, the result of evaluating the formula<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum(C1:C4)</SPAN>.</P>
<P>However, there's a crucial element still missing. If you change the value of cell<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#fig:scells4">Figure 33.4</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>from 20 to 100, the sum in cell<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C5</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will not be automatically updated to 166. You'll have to click on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C5</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>manually to see a change in its value. What's still missing is a way to have cells recompute their values automatically after a change.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=33.7></A>33.7 Change propagation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#33.7">link</A>]</SPAN></H3>
<P>If a cell's value has changed, all cells that depend on that value should have their results recomputed and redisplayed. The simplest way to achieve this would be to recompute the value of every of cell in the spreadsheet after each change. However such an approach does not scale well as the spreadsheet grows in size.</P>
<P>A better approach is to recompute the values of only those cells that refer to a changed cell in their formula. The idea is to use an event-based publish/subscribe framework for change propagation: once a cell gets assigned a formula, it will subscribe to be notified of all value changes in cells to which the formula refers. A value change in one of these cells will trigger a re-evaluation of the subscriber cell. If such a re-evaluation causes a change in the value of the cell, it will in turn notify all cells that depend on it. The process continues until all cell values have stabilized,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, there are no more changes in the values of any cell.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#footnote33-3">[3]</A></P>
<P>The publish/subscribe framework is implemented in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>using the standard event mechanism of Scala's Swing framework. Here's a new (and final) version of this class:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.scells
  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;swing._
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Model</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;
  <SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Evaluator</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Arithmetic</SPAN>&nbsp;{&nbsp;
</PRE>Compared to the previous version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN>, this version adds a new import of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>swing._</SPAN>, which makes Swing's event abstractions directly available.<A id=i1245010859-2></A> 
<P></P>
<P>The main modifications of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>concern the nested class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN>. Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>now inherits from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Publisher</SPAN>, so that it can publish events.<A id=i-843595300-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The event-handling logic is completely contained in the setters of two properties:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formula</SPAN>. Here is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN>'s new version:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cell</SPAN>(row:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;column:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Publisher</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;formula&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Textual</SPAN>(s)&nbsp;=&gt;&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;value.toString
  &nbsp;&nbsp;}
</PRE>To the outside, it looks like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formula</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are two variables in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN>. Their actual implementation is in terms of two private fields that are equipped with public getters,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formula</SPAN>, and setters,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value_=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formula_=</SPAN>. Here are the definitions implementing the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>property:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;v:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;value:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>&nbsp;=&nbsp;v
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;value_=(w:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(!(v&nbsp;==&nbsp;w&nbsp;||&nbsp;v.isNaN&nbsp;&amp;&amp;&nbsp;w.isNaN))&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;w
  &nbsp;&nbsp;&nbsp;&nbsp;publish(<SPAN class=typename style="COLOR: rgb(103,0,154)">ValueChanged</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>))
  &nbsp;&nbsp;}
  }
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value_=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>setter assigns a new value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>w</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the private field<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>v</SPAN>. If the new value is different from the old one, it also publishes a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ValueChanged</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>event with the cell itself as argument.<A id=i1571974179-1></A>Note that the test whether the value has changed is a bit tricky because it involves the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>NaN</SPAN>.<A id=i995050225-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The Java spec says that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>NaN</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is different from every other value, including itself! Therefore, a test whether two values are the same has to treat<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>NaN</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>specially: two values<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>v</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>w</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are the same if they are equal with respect to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN>, or they are both the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>NaN</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>,<SPAN class=code>v.isNaN</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>w.isNaN</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>both yield<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>. 
<P></P>
<P>Whereas the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value_=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>setter does the publishing in the publish/subscribe framework, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formula_=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>setter does the subscribing:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;f:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Empty</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;formula:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>&nbsp;=&nbsp;f
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;formula_=(f:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Formula</SPAN>)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(c&nbsp;&lt;-&nbsp;references(formula))&nbsp;deafTo(c)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.f&nbsp;=&nbsp;f
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(c&nbsp;&lt;-&nbsp;references(formula))&nbsp;listenTo(c)
  &nbsp;&nbsp;value&nbsp;=&nbsp;evaluate(f)
  }
</PRE>If a cell is assigned a new formula, it first unsubscribes with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>deafTo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from all cells referenced by the previous<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>formula</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>value. It then stores the new formula in the private variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and subscribes with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>listenTo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to all cells referenced by it.<A id=i-2118281873-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Finally, it recomputes its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>using the new formula. 
<P></P>
<P>The last piece of code in the revised class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>specifies how to react to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ValueChanged</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>event:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;reactions&nbsp;+=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ValueChanged</SPAN>(_)&nbsp;=&gt;&nbsp;value&nbsp;=&nbsp;evaluate(formula)
  &nbsp;&nbsp;}
  }&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;end&nbsp;class&nbsp;Cell</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ValueChanged</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class is also contained in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ValueChanged</SPAN>(cell:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cell</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">event.Event</SPAN>
</PRE>The rest of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Model</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is as before:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;cells&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[Array[Cell]]</SPAN>(height,&nbsp;width)&nbsp;
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(i&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;until&nbsp;height;&nbsp;j&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;until&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;cells(i)(j)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cell</SPAN>(i,&nbsp;j)
  }&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;end&nbsp;class&nbsp;Model</SPAN>
</PRE><A name=lst:scells-Spreadsheet3></A>
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.scells
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;swing._,&nbsp;event._
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Spreadsheet</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ScrollPane</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;cellModel&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Model</SPAN>(height,&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;cellModel._
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;table&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Table</SPAN>(height,&nbsp;width)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;settings&nbsp;as&nbsp;in&nbsp;<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Spreadsheet1">Listing 33.1</A></SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;rendererComponent(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isSelected:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>,&nbsp;hasFocus:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;column:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;as&nbsp;in&nbsp;<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Spreadsheet2">Listing 33.3</A></SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;userData(row:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;column:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;as&nbsp;in&nbsp;<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Spreadsheet2">Listing 33.3</A></SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reactions&nbsp;+=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">TableUpdated</SPAN>(table,&nbsp;rows,&nbsp;column)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(row&nbsp;&lt;-&nbsp;rows)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells(row)(column).formula&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FormulaParsers.parse(userData(row,&nbsp;column))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ValueChanged</SPAN>(cell)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateCell(cell.row,&nbsp;cell.column)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(row&nbsp;&lt;-&nbsp;cells;&nbsp;cell&nbsp;&lt;-&nbsp;row)&nbsp;listenTo(cell)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;rowHeader&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ListView</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;until&nbsp;height)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedCellWidth&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">30</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixedCellHeight&nbsp;=&nbsp;table.rowHeight
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;viewportView&nbsp;=&nbsp;table
  &nbsp;&nbsp;&nbsp;&nbsp;rowHeaderView&nbsp;=&nbsp;rowHeader
  &nbsp;&nbsp;}</PRE>
<H5>Listing 33.9 - The finished spreadsheet component.</H5>
<P>The spreadsheet code is now almost complete. The final piece missing is the re-display of modified cells. So far, all value propagation concerned the internal<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cell</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>values only; the visible table was not affected. One way to change this would be to add a redraw command to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value_=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>setter. However, this would undermine the strict separation between model and view that you have seen so far. A more modular solution is to notify the table of all<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ValueChanged</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>events and let it do the redrawing itself.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Spreadsheet3">Listing 33.9</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows the final spreadsheet component, which implements this scheme.</P>
<P>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Spreadsheet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#lst:scells-Spreadsheet3">Listing 33.9</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>has only two new revisions. First, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>table</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>component now subscribes with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>listenTo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to all cells in the model. Second, there's a new case in the table's reactions: if it is notified of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ValueChanged(cell)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>event, it demands a redraw of the corresponding cell with a call of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>updateCell(cell.row,</SPAN>&nbsp;<SPAN class=code>cell.column)</SPAN>.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=33.8></A>33.8 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/the-scells-spreadsheet.html#33.8">link</A>]</SPAN></H3>
<P>The spreadsheet developed in this chapter is fully functional, even though at some points it adopts the simplest solution to implement rather than the most convenient one for the user. That way, it could be written in just under 200 lines of code. Nevertheless, the architecture of the spreadsheet makes modifications and extensions easy. In case you would like to experiment with the code a bit further, here are some suggestions of what you could change or add:</P>
<OL>
<LI>You could make the spreadsheet resizable, so that the number of rows and columns can be changed interactively. 
<LI>You could add new kinds of formulas, for instance binary operations, or other functions. 
<LI>You might think about what to do when cells refer recursively to themselves. For instance, if cell<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>holds the formula<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>add(B1,</SPAN>&nbsp;<SPAN class=code>1)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and cell<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>B1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>holds the formula<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mul(A1,</SPAN>&nbsp;<SPAN class=code>2)</SPAN>, a re-evaluation of either cell will trigger a stack-overflow. Clearly, that's not a very good solution. As alternatives, you could either disallow such a situation, or just compute one iteration each time one of the cells is touched. 
<LI>You could enhance error handling, giving more detailed messages describing what went wrong. 
<LI>You could add a formula entry field at the top of the spreadsheet, so that long formulas could be entered more conveniently.</LI></OL>At the beginning of this book we stressed the scalability aspect of Scala.<A id=i-885663216-3></A><A id=i-2079231610-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>We claimed that the combination of Scala's object-oriented and functional constructs makes it suitable for programs ranging from small scripts to very large systems. The spreadsheet presented here is clearly still a small system, even though it would probably take up much more than 200 lines in most other languages. Nevertheless, you can see many of the details that make Scala scalable at play in this application. 
<P>The spreadsheet uses Scala's classes and traits with their mixin composition to combine its components in flexible ways.<A id=i1953973959-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Recursive dependencies between components are expressed using self types. The need for static state is completely eliminated&#8212;the only top-level components that are not classes are formula trees and formula parsers, and both of these are purely functional. The application also uses higher-order functions and pattern matching extensively, both for accessing formulas and for event handling. So it is a good showcase of how functional and object-oriented programming can be combined smoothly.</P>
<P>One important reason why the spreadsheet application is so concise is that it can base itself on powerful libraries. The parser combinator library provides in effect an internal domain-specific language for writing parsers.<A id=i-218658218-1></A><A id=i-640692980-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Without it, parsing formulas would have been much more difficult. The event handling in Scala's Swing libraries is a good example of the power of control abstractions. If you know Java's Swing libraries, you probably appreciate the conciseness of Scala's reactions concept, particularly when compared to the tedium of writing notify methods and implementing listener interfaces in the classical publish/subscribe design pattern.<A id=i851179987-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>So the spreadsheet demonstrates the benefits of extensibility, where high-level libraries can be made to look just like language extensions.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 33:</H4>
<P><A name=footnote33-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Although "<SPAN class=code>this(row,</SPAN>&nbsp;<SPAN class=code>column)</SPAN>" may look similar to a constructor invocation, it is in this case an invocation of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method on the current<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Table</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instance.</P>
<P><A name=footnote33-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Range[Int]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is also the type of a Scala expression such as "<SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code>N</SPAN>".</P>
<P><A name=footnote33-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This assumes that there are no cyclic dependencies between cells. We discuss dropping this assumption at the end of this chapter.</P></DIV>