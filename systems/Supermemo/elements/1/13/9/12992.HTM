<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 28 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Object Equality</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>Comparing two values for equality is ubiquitous in programming. It is also more tricky than it looks at first glance. This chapter looks at object equality in detail and gives some recommendations to consider when you design your own equality tests.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=28.1></A>28.1 Equality in Scala<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#28.1">link</A>]</SPAN></H3>
<P>As mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scalas-hierarchy.html#sec:impl-primitives">Section 11.2</A>, the definition of equality is different in Scala and Java. Java has two equality comparisons: the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator,<A id=i-2046772853-1></A><A id=i-1785676493-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which is the natural equality for value types and object identity for reference types, and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which is (user-defined) canonical equality for reference types.<A id=i-342464093-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This convention is problematic, because the more natural symbol,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN>, does not always correspond to the natural notion of equality. When programming in Java, a common pitfall for beginners is to compare objects with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN>when they should have been compared with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>. For instance, comparing two strings<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>using "<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>y</SPAN>" might well yield<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java, even if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>have exactly the same characters in the same order.</P>
<P>Scala also has an equality method signifying object identity, but it is not used much. That kind of equality, written "<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>eq</SPAN>&nbsp;<SPAN class=code>y</SPAN>", is true if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>reference the same object.<A id=i-795280463-3></A><A id=i2030434891-3></A><A id=i1544052809-3></A><A id=i-644344128-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN>equality<A id=i-1583721442-3></A><A id=i1095465388-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is reserved in Scala for the "natural" equality of each type. For value types,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is value comparison, just like in Java. For reference types,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala. You can redefine the behavior of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for new types by overriding the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which is always inherited from class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>. The inherited<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>, which takes effect unless overridden, is object identity, as is the case in Java. So<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(and with it,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN>) is by default the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eq</SPAN>, but you can change its behavior by overriding the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in the classes you define. It is not possible to override<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>directly, as it is defined as a final method in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>. That is, Scala treats<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as if it were defined as follows in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">final</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;==&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">null</SPAN>&nbsp;eq&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)&nbsp;{<SPAN class=vem style="COLOR: rgb(0,0,230)">null</SPAN>&nbsp;eq&nbsp;that}&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;{<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>&nbsp;equals&nbsp;that}
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=28.2></A>28.2 Writing an equality method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#28.2">link</A>]</SPAN></H3>
<P><A name=sec:writing-an-equality-method></A></P>
<P>How should the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method be defined? It turns out that writing a correct equality method is surprisingly difficult in object-oriented languages. In fact, after studying a large body of Java code, the authors of a 2007 paper concluded that almost all implementations of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods are faulty.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#footnote28-1">[1]</A></P>
<P>This is problematic, because equality is at the basis of many other things. For one, a faulty equality method for a type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>might mean that you cannot reliably put an object of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN>in a collection. You might have two elements<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elem1</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elem2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>which are equal,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, "<SPAN class=code>elem1</SPAN>&nbsp;<SPAN class=code>equals</SPAN>&nbsp;<SPAN class=code>elem2</SPAN>" yields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>. Nevertheless, with commonly occurring faulty implementations of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, you could still see behavior like the following:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;hashSet:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set[C]</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">collection.immutable.HashSet</SPAN>
  hashSet&nbsp;+=&nbsp;elem1
  hashSet&nbsp;contains&nbsp;elem2&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;returns&nbsp;false!</SPAN>
</PRE>Here are four common pitfalls<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#footnote28-2">[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that can cause inconsistent behavior when overriding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>: 
<P></P>
<OL>
<LI>Defining<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the wrong signature. 
<LI>Changing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>without also changing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>. 
<LI>Defining<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in terms of mutable fields. 
<LI>Failing to define<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an equivalence relation.</LI></OL>These four pitfalls are discussed in the remainder of this section. 
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Pitfall #1: Defining<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the wrong signature.</H4>
<P>Consider adding an equality method to the following class of simple points:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{&nbsp;...&nbsp;}
</PRE>A seemingly obvious, but wrong way would be to define it like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;An&nbsp;utterly&nbsp;wrong&nbsp;definition&nbsp;of&nbsp;equals</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.x&nbsp;==&nbsp;other.x&nbsp;&amp;&amp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.y&nbsp;==&nbsp;other.y
</PRE>What's wrong with this method? At first glance, it seems to work OK:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;p1,&nbsp;p2&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">p1:&nbsp;Point&nbsp;=&nbsp;Point@62d74e</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">p2:&nbsp;Point&nbsp;=&nbsp;Point@254de0</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;q&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">q:&nbsp;Point&nbsp;=&nbsp;Point@349f8a</SPAN>
  <BR>  scala&gt;&nbsp;p1&nbsp;equals&nbsp;p2
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;p1&nbsp;equals&nbsp;q
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>However, trouble starts once you start putting points into a collection:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable._
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.collection.mutable._</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;coll&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HashSet</SPAN>(p1)
  <SPAN class=output style="COLOR: rgb(90,0,0)">coll:&nbsp;scala.collection.mutable.Set[Point]&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Set(Point@62d74e)</SPAN>
  <BR>  scala&gt;&nbsp;coll&nbsp;contains&nbsp;p2
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>How to explain that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>coll</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not contain<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p2</SPAN>, even though<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was added to it, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are equal objects? The reason becomes clear in the following interaction, where the precise type of one of the compared points is masked. Define<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p2a</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an alias of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p2</SPAN>, but with type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;p2a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>&nbsp;=&nbsp;p2
  <SPAN class=output style="COLOR: rgb(90,0,0)">p2a:&nbsp;Any&nbsp;=&nbsp;Point@254de0</SPAN>
</PRE>Now, were you to repeat the first comparison, but with the alias<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p2a</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p2</SPAN>, you would get:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;p1&nbsp;equals&nbsp;p2a
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>What went wrong? In fact, the version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>given previously does not override the standard method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>, because its type is different. Here is the type of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method as it is defined in the root class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>:<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#footnote28-3">[3]</A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>
</PRE>Because the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an argument, it does not override<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>.<A id=i1623576437-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Instead, it is just an overloaded alternative. Now, overloading in Scala and in Java is resolved by the static type of the argument, not the run-time type. So as long as the static type of the argument is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN>, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in<SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is called. However, once the static argument is of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is called instead.<SPAN class=Apple-converted-space>&nbsp;</SPAN>This method has not been overridden, so it is still implemented by comparing object identity. That's why the comparison "<SPAN class=code>p1</SPAN>&nbsp;<SPAN class=code>equals</SPAN>&nbsp;<SPAN class=code>p2a</SPAN>" yields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>even though points<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p2a</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>have the same<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>values. That's also why the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contains</SPAN>method in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashSet</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returned<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>. Since that method operates on generic sets, it calls the generic<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Object</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of the overloaded variant in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN>. 
<P></P>
<P>A better<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is the following:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;A&nbsp;better&nbsp;definition,&nbsp;but&nbsp;still&nbsp;not&nbsp;perfect</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.x&nbsp;==&nbsp;that.x&nbsp;&amp;&amp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.y&nbsp;==&nbsp;that.y
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  }
</PRE>Now<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has the correct type. It takes a value of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as parameter and it yields a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>result. The implementation of this method uses a pattern match.<A id=i-1742228676-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It first tests whether the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>other</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object is also of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN>. If it is, it compares the coordinates of the two points and returns the result. Otherwise the result is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>. 
<P></P>
<P>A related pitfall is to define<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a wrong signature. Normally, if you try to redefine<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the correct signature, which takes an argument of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>, the compiler will give you an error because you try to override a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>final</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>. However, newcomers to Scala sometimes make two errors at once: They try to override<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">and</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>they give it the wrong signature. For instance:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;==(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Don't&nbsp;do&nbsp;this!</SPAN>
</PRE>In that case, the user-defined<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is treated as an overloaded variant of the same-named method class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>, and the program compiles. However, the behavior of the program would be just as dubious as if you had defined<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the wrong signature. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Pitfall #2: Changing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>without also changing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN></H4>
<P>If you repeat the comparison of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p2a</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the latest definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defined previously, you will get<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>, as expected.<A id=i-579193195-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>However, if you repeat the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashSet.contains</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>test, you will probably still get<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>.</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;p1,&nbsp;p2&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">p1:&nbsp;Point&nbsp;=&nbsp;Point@670f2b</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">p2:&nbsp;Point&nbsp;=&nbsp;Point@14f7c0</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HashSet</SPAN>(p1)&nbsp;contains&nbsp;p2
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>In fact, this outcome is not 100% certain. You might also get<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from the experiment. If you do, you can try with some other points with coordinates 1 and 2. Eventually, you'll get one which is not contained in the set. What goes wrong here is that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>redefined<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>without also redefining<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>. 
<P></P>
<P>Note that the collection in the example above is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashSet</SPAN>. This means elements of the collection are put in "hash buckets" determined by their hash code. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contains</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>test first determines a hash bucket to look in and then compares the given elements with all elements in that bucket. Now, the last version of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>did redefine<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>, but it did not at the same time redefine<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>. So<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is still what it was in its version in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>: some transformation of the address of the allocated object. The hash codes of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p1</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are almost certainly different, even though the fields of both points are the same. Different hash codes mean with high probability different hash buckets in the set. The<SPAN class=code>contains</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>test will look for a matching element in the bucket which corresponds to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p2</SPAN>'s hash code. In most cases, point<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be in another bucket, so it will never be found.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=code>p2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>might also end up by chance in the same hash bucket. In that case the test would return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>.</P>
<P>The problem was that the last implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><A id=i668953714-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>violated the contract on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as defined for class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>:<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#footnote28-4">[4]</A></P>
<P><SPAN style="FONT-STYLE: italic">If two objects are equal according to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, then calling the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method on each of the two objects must produce the same integer result.</SPAN></P>
<P>In fact, it's well known in Java that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should always be redefined together. Furthermore,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>may only depend on fields that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>depends on. For the<SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class, the following would be a suitable definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hashCode&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;+&nbsp;x)&nbsp;+&nbsp;y
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.x&nbsp;==&nbsp;that.x&nbsp;&amp;&amp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.y&nbsp;==&nbsp;that.y&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>&nbsp;
  &nbsp;&nbsp;}
  }
</PRE>This is just one of many possible implementations of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>. Adding the constant<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>41</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to one integer field<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>, multiplying the result with the prime number<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>41</SPAN>, and adding to that result the other integer field<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>gives a reasonable distribution of hash codes at a low cost in running time and code size. We'll provide more guidance on writing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>later in this chapter. 
<P></P>
<P>Adding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fixes the problems of equality when defining classes like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN>. However, there are still other trouble spots to watch out for.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Pitfall #3: Defining<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in terms of mutable fields</H4>
<P>Consider the following slight variation of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Problematic</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hashCode&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;+&nbsp;x)&nbsp;+&nbsp;y
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.x&nbsp;==&nbsp;that.x&nbsp;&amp;&amp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.y&nbsp;==&nbsp;that.y&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>&nbsp;
  &nbsp;&nbsp;}
  }
</PRE>The only difference is that the fields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are now<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s.<A id=i-1325523688-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods are now defined in terms of these mutable fields, so their results change when the fields change. This can have strange effects once you put points in collections:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;p&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">p:&nbsp;Point&nbsp;=&nbsp;Point@2b</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;coll&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HashSet</SPAN>(p)
  <SPAN class=output style="COLOR: rgb(90,0,0)">coll:&nbsp;scala.collection.mutable.Set[Point]&nbsp;=&nbsp;Set(Point@2b)</SPAN>
  <BR>  scala&gt;&nbsp;coll&nbsp;contains&nbsp;p
  <SPAN class=output style="COLOR: rgb(90,0,0)">res5:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>Now, if you change a field in point<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>, does the collection still contain the point? We'll try it:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;p.x&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  <BR>  scala&gt;&nbsp;coll&nbsp;contains&nbsp;p
  <SPAN class=output style="COLOR: rgb(90,0,0)">res7:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>This looks strange. Where did<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>go? More strangeness results if you check whether the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elements</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>iterator of the set contains<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;coll.elements&nbsp;contains&nbsp;p
  <SPAN class=output style="COLOR: rgb(90,0,0)">res8:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>So here's a set that does not contain<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>, yet<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is among the elements of the set! What happened, of course, is that after the change to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field, the point<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>ended up in the wrong hash bucket of the set<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>coll</SPAN>. That is, its original hash bucket no longer corresponded to the new value of its hash code. In a manner of speaking, the point<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>"dropped out of sight" in the set<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>coll</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>even though it still belonged to its elements. 
<P></P>
<P>The lesson to be drawn from this example is that when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>depend on mutable state, it causes problems for potential users. If they put such objects into collections, they have to be careful never to modify the depended-on state, and this is tricky. If you need a comparison that takes the current state of an object into account, you should usually name it something else, not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>. Considering the last definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN>, it would have been preferable to omit a redefinition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and to name the comparison method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equalContents</SPAN>, or some other name different from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would then have inherited the default implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>. So<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would have stayed locatable in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>coll</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>even after the modification to its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Pitfall #4: Failing to define<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an equivalence relation</H4>
<P>The contract of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Any</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>specifies that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>must<A id=i358320206-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>implement an equivalence relation on non-<SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>objects:<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#footnote28-5">[5]</A></P>
<DIV style="FONT-STYLE: italic">
<UL>
<LI>It is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">reflexive</SPAN>: for any non-null value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>, the expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x.equals(x)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>. 
<LI>It is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">symmetric</SPAN>: for any non-null values<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x.equals(y)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if and only if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y.equals(x)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>. 
<LI>It is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">transitive</SPAN>: for any non-null values<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>z</SPAN>, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x.equals(y)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y.equals(z)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>, then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x.equals(z)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>. 
<LI>It is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">consistent</SPAN>: for any non-null values<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN>, multiple invocations of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x.equals(y)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should consistently return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or consistently return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>, provided no information used in equals comparisons on the objects is modified. 
<LI>For any non-null value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x.equals(null)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>.<A id=i-677123658-1></A></LI></UL></DIV><BR>
<P>The definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>developed so far for class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>satisfies the contract for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>. However, things become more complicated once subclasses are considered. Say there is a subclass<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that adds a field<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>color</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Color</SPAN>. Assume<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Color</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined as an enumeration, as presented in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#sec:enums">Section 20.8</A>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Color</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Enumeration</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Red</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Orange</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Yellow</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Green</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Blue</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Indigo</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Violet</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Value</SPAN>
  }
</PRE><SPAN class=code>ColoredPoint</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>overrides<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to take the new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>color</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field into account:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ColoredPoint</SPAN>(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;color:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Color.Value</SPAN>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(x,&nbsp;y)&nbsp;{&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Problem:&nbsp;equals&nbsp;not&nbsp;symmetric</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ColoredPoint</SPAN>&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.color&nbsp;==&nbsp;that.color&nbsp;&amp;&amp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">super</SPAN>.equals(that)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;}
  }
</PRE>This is what many programmers would likely write.<A id=i-591223748-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Note that in this case, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>need not override<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>. Because the new definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is stricter than the overridden definition in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(meaning it equates fewer pairs of objects), the contract for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>stays valid. If two colored points are equal, they must have the same coordinates, so their hash codes are guaranteed to be equal as well. 
<P></P>
<P>Taking the class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by itself, its definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>looks OK. However, the contract for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is broken once points and colored points are mixed. Consider:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;p&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">p:&nbsp;Point&nbsp;=&nbsp;Point@2b</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;cp&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ColoredPoint</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Color.Red</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">cp:&nbsp;ColoredPoint&nbsp;=&nbsp;ColoredPoint@2b</SPAN>
  <BR>  scala&gt;&nbsp;p&nbsp;equals&nbsp;cp
  <SPAN class=output style="COLOR: rgb(90,0,0)">res8:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;cp&nbsp;equals&nbsp;p
  <SPAN class=output style="COLOR: rgb(90,0,0)">res9:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>The comparison "<SPAN class=code>p</SPAN>&nbsp;<SPAN class=code>equals</SPAN>&nbsp;<SPAN class=code>cp</SPAN>" invokes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which is defined in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN>. This method only takes into account the coordinates of the two points. Consequently, the comparison yields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>. On the other hand, the comparison "<SPAN class=code>cp</SPAN>&nbsp;<SPAN class=code>equals</SPAN>&nbsp;<SPAN class=code>p</SPAN>" invokes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cp</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which is defined in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN>. This method returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>is not a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN>. So the relation defined by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not symmetric. 
<P></P>
<P>The loss in symmetry can have unexpected consequences for collections. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HashSet[Point]</SPAN>(p)&nbsp;contains&nbsp;cp
  <SPAN class=output style="COLOR: rgb(90,0,0)">res10:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HashSet[Point]</SPAN>(cp)&nbsp;contains&nbsp;p
  <SPAN class=output style="COLOR: rgb(90,0,0)">res11:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>So even though<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cp</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are equal, one<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contains</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>test succeeds whereas the other one fails. 
<P></P>
<P>How can you change the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>so that it becomes symmetric? Essentially there are two ways. You can either make the relation more general or more strict. Making it more general means that a pair of two objects,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN>, is taken to be equal if either comparing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or comparing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>yields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>. Here's code that does this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ColoredPoint</SPAN>(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;color:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Color.Value</SPAN>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(x,&nbsp;y)&nbsp;{&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Problem:&nbsp;equals&nbsp;not&nbsp;transitive</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ColoredPoint</SPAN>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.color&nbsp;==&nbsp;that.color)&nbsp;&amp;&amp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">super</SPAN>.equals(that)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;equals&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;}
  }
</PRE>The new definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has one more case than the old one: If the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>other</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>but not a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN>, the method forwards to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method of<SPAN class=code>Point</SPAN>. This has the desired effect of making<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>symmetric. Now, both "<SPAN class=code>cp</SPAN>&nbsp;<SPAN class=code>equals</SPAN>&nbsp;<SPAN class=code>p</SPAN>" and "<SPAN class=code>p</SPAN>&nbsp;<SPAN class=code>equals</SPAN>&nbsp;<SPAN class=code>cp</SPAN>" result in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>. However, the contract for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is still broken. Now the problem is that the new relation is no longer transitive! Here's a sequence of statements that demonstrates this. Define a point and two colored points of different colors, all at the same position:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;redp&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ColoredPoint</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Color.Red</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">redp:&nbsp;ColoredPoint&nbsp;=&nbsp;ColoredPoint@2b</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bluep&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ColoredPoint</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Color.Blue</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">bluep:&nbsp;ColoredPoint&nbsp;=&nbsp;ColoredPoint@2b</SPAN>
</PRE>Taken individually,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>redp</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is equal to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is equal to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bluep</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;redp&nbsp;==&nbsp;p
  <SPAN class=output style="COLOR: rgb(90,0,0)">res12:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;p&nbsp;==&nbsp;bluep
  <SPAN class=output style="COLOR: rgb(90,0,0)">res13:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>However, comparing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>redp</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bluep</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>yields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;redp&nbsp;==&nbsp;bluep
  <SPAN class=output style="COLOR: rgb(90,0,0)">res14:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>Hence, the transitivity clause of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>'s contract is violated. Making the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>relation more general seems to lead to a dead end. We'll try to make it stricter instead. One way to make<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>stricter is to always treat objects of different classes as different. That could be achieved by modifying the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods in classes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN>. In class<SPAN class=code>Point</SPAN>, you could add an extra comparison that checks whether the run-time class of the other<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is exactly the same as this<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN>'s class, as follows:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;A&nbsp;technically&nbsp;valid,&nbsp;but&nbsp;unsatisfying,&nbsp;equals&nbsp;method</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hashCode&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;+&nbsp;x)&nbsp;+&nbsp;y
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.x&nbsp;==&nbsp;that.x&nbsp;&amp;&amp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.y&nbsp;==&nbsp;that.y&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.getClass&nbsp;==&nbsp;that.getClass
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;}
  }
</PRE>You can then revert class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN>'s implementation back to the version that previously had violated the symmetry requirement:<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#footnote28-6">[6]</A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ColoredPoint</SPAN>(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;color:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Color.Value</SPAN>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(x,&nbsp;y)&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ColoredPoint</SPAN>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.color&nbsp;==&nbsp;that.color)&nbsp;&amp;&amp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">super</SPAN>.equals(that)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;}
  }
</PRE>Here, an instance of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is considered to be equal to some other instance of the same class only if the objects have the same coordinates and they have the same run-time class, meaning<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>.getClass</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on either object returns the same value. The new definitions satisfy symmetry and transitivity because now every comparison between objects of different classes yields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>. So a colored point can never be equal to a point. This convention looks reasonable, but one could argue that the new definition is too strict. 
<P></P>
<P>Consider the following slightly roundabout way to define a point at coordinates<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(1,</SPAN>&nbsp;<SPAN class=code>2)</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;pAnon&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;y&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">pAnon:&nbsp;Point&nbsp;=&nbsp;$anon$1@2b</SPAN>
</PRE>Is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pAnon</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>equal to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>? The answer is no because the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Class</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>objects associated with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pAnon</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are different. For<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>it is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN>, whereas for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pAnon</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>it is an anonymous class of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN>.<A id=i-8484895-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>But clearly,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pAnon</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is just another point at coordinates<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(1,</SPAN>&nbsp;<SPAN class=code>2)</SPAN>. It does not seem reasonable to treat it as being different from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>. 
<P></P>
<P>So it seems we are stuck. Is there a sane way to redefine equality on several levels of the class hierarchy while keeping its contract? In fact, there is such a way, but it requires one more method to redefine together with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>. The idea is that as soon as a class redefines<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>), it should also explicitly state that objects of this class are never equal to objects of some superclass that implement a different equality method. This is achieved by adding a method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to every class that redefines<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>. Here's the method's signature:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;canEqual(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>
</PRE>The method should return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>other</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object is an instance of the class in which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is (re)defined,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>otherwise. It is called from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to make sure that the objects are comparable both ways.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#lst:satisfying-equals">Listing 28.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a new (and final) implementation of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>along these lines:<A name=lst:satisfying-equals></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hashCode&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;+&nbsp;x)&nbsp;+&nbsp;y
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(that&nbsp;canEqual&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.x&nbsp;==&nbsp;that.x)&nbsp;&amp;&amp;&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.y&nbsp;==&nbsp;that.y)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;canEqual(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other.isInstanceOf[<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>]
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 28.1 - A superclass<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that calls<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN>.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in this version of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains the additional requirement that the other object<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">can equal</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>this one, as determined by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. The implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>states that all instances of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be equal.</P>
<P><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#lst:subclass-can-equal">Listing 28.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows the corresponding implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN>.<A name=lst:subclass-can-equal></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ColoredPoint</SPAN>(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;color:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Color.Value</SPAN>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(x,&nbsp;y)&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hashCode&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">super</SPAN>.hashCode&nbsp;+&nbsp;color.hashCode
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ColoredPoint</SPAN>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(that&nbsp;canEqual&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">super</SPAN>.equals(that)&nbsp;&amp;&amp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.color&nbsp;==&nbsp;that.color
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;canEqual(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;other.isInstanceOf[<SPAN class=typename style="COLOR: rgb(103,0,154)">ColoredPoint</SPAN>]
  }
</PRE>
<H5>Listing 28.2 - A subclass<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that calls<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN>.</H5>
<P>It can be shown that the new definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keeps the contract of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>. Equality is symmetric and transitive. Comparing a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>always yields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>. Indeed, for any point<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and colored point<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cp</SPAN>, "<SPAN class=code>p</SPAN>&nbsp;<SPAN class=code>equals</SPAN>&nbsp;<SPAN class=code>cp</SPAN>" will return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>because "<SPAN class=code>cp</SPAN>&nbsp;<SPAN class=code>canEqual</SPAN>&nbsp;<SPAN class=code>p</SPAN>" will return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>. The reverse comparison, "<SPAN class=code>cp</SPAN>&nbsp;<SPAN class=code>equals</SPAN>&nbsp;<SPAN class=code>p</SPAN>", will also return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN>, so the first pattern match in the body of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will fail.</P>
<P>On the other hand, instances of different subclasses of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be equal, as long as none of the classes redefines the equality method. For instance, with the new class definitions, the comparison of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pAnon</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would yield true. Here are some examples:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;p&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">p:&nbsp;Point&nbsp;=&nbsp;Point@6bc</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;cp&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ColoredPoint</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Color.Indigo</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">cp:&nbsp;ColoredPoint&nbsp;=&nbsp;ColoredPoint@11421</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;pAnon&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;y&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">pAnon:&nbsp;Point&nbsp;=&nbsp;$anon$1@6bc</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;coll&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(p)
  <SPAN class=output style="COLOR: rgb(90,0,0)">coll:&nbsp;List[Point]&nbsp;=&nbsp;List(Point@6bc)</SPAN>
  <BR>  scala&gt;&nbsp;coll&nbsp;contains&nbsp;p&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;coll&nbsp;contains&nbsp;cp
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;coll&nbsp;contains&nbsp;pAnon
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>These examples demonstrate that if a superclass<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>implementation defines and calls<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN>, then programmers who implement subclasses can decide whether or not their subclasses may be equal to instances of the superclass. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>overrides<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN>, for example, a colored point may never be equal to a plain-old point. But because the anonymous subclass referenced from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pAnon</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not override<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN>, its instance can be equal to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instance. 
<P></P>
<P>One potential criticism of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>approach is that it violates the Liskov Substitution Principle (LSP)<A id=i1527452340-1></A>. For example, the technique of implementing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by comparing run-time classes, which led to the inability to define a subclass whose instances can equal instances of the superclass, has been described as a violation of the LSP.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#footnote28-7">[7]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The reasoning is that the LSP states you should be able to use (substitute) a subclass instance where a superclass instance is required. In the previous example, however, "coll contains cp" returned<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>even though<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cp</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>values matched those of the point in the collection. Thus it may seem like a violation of the LSP, because you can't use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>here where a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is expected. We believe this is the wrong interpretation, though, because the LSP doesn't require that a subclass behaves identically to its superclass, just that it behaves in a way that fulfills the contract of its superclass.</P>
<P>The problem with writing an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that compares run-time classes is not that it violates the LSP, but that it doesn't give you a way to create a subclass whose instances can equal superclass instances. For example, had we used the run-time class technique in the previous example, "<SPAN class=code>coll</SPAN>&nbsp;<SPAN class=code>contains</SPAN>&nbsp;<SPAN class=code>pAnon</SPAN>" would have returned<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>, and that's not what we wanted. By contrast, we really did want "<SPAN class=code>coll</SPAN>&nbsp;<SPAN class=code>contains</SPAN>&nbsp;<SPAN class=code>cp</SPAN>" to return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>, because by overriding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN>, we were basically saying that an indigo-colored point at coordinates (1, 2) is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">not the same thing</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an uncolored point at (1, 2). Thus, in the previous example we were able to pass two different<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>subclass instances to the collection's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contains</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, and we got back two different answers, both correct.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=28.3></A>28.3 Defining equality for parameterized types<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#28.3">link</A>]</SPAN></H3>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods in the previous examples all started with a pattern match that tested whether the type of the operand conformed to the type of the class containing the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>method.<A id=i511396682-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>When classes are parameterized, this scheme needs to be adapted a little bit. As an example, consider binary trees. The class hierarchy shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#lst:binary-tree">Listing 28.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>defines an abstract class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tree</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for a binary tree, with two alternative implementations: an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EmptyTree</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object and a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class representing non-empty trees. A non-empty tree is made up of some element<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>left</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>right</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>child tree. The type of its element is given by a type parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>.<A name=lst:binary-tree></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tree[+T]</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;elem:&nbsp;T
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;left:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tree[T]</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;right:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tree[T]</SPAN>
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EmptyTree</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tree[Nothing]</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;elem&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">NoSuchElementException</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"EmptyTree.elem"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;left&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">NoSuchElementException</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"EmptyTree.left"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;right&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">NoSuchElementException</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"EmptyTree.right"</SPAN>)
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Branch[+T]</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;elem:&nbsp;T,
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;left:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tree[T]</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;right:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tree[T]</SPAN>
  &nbsp;&nbsp;)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tree[T]</SPAN>
</PRE>
<H5>Listing 28.3 - Hierarchy for binary trees.</H5>
<P>We'll<SPAN class=Apple-converted-space>&nbsp;</SPAN>now add<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods to these classes. For class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tree</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>itself there's nothing to do, because we assume that these methods are implemented separately for each implementation of the abstract class. For object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EmptyTree</SPAN>, there's still nothing to do because the default implementations of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EmptyTree</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>inherits from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>work just fine. After all, an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>EmptyTree</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is only equal to itself, so equality should be reference equality, which is what's inherited from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>.</P>
<P>But adding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>requires some work. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>value should only be equal to other<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>values, and only if the two values have equal<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elem</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>left</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=code>right</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fields. It's natural to apply the schema for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that was developed in the previous sections of this chapter. This would give:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Branch[T]</SPAN>(
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;elem:&nbsp;T,
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;left:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tree[T]</SPAN>,
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;right:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tree[T]</SPAN>
  )&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tree[T]</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Branch[T]</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.elem&nbsp;==&nbsp;that.elem&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.left&nbsp;==&nbsp;that.left&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.right&nbsp;==&nbsp;that.right
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;}
  }
</PRE>Compiling this example, however, gives an indication that "<SPAN class=code>unchecked</SPAN>" warnings occurred. Compiling again with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-unchecked</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>option reveals the following problem:<A id=i-1285804133-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;$&nbsp;fsc&nbsp;-unchecked&nbsp;Tree.scala
  <SPAN class=output style="COLOR: rgb(90,0,0)">Tree.scala:14:&nbsp;warning:&nbsp;non&nbsp;variable&nbsp;type-argument&nbsp;T&nbsp;in&nbsp;type&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">pattern&nbsp;is&nbsp;unchecked&nbsp;since&nbsp;it&nbsp;is&nbsp;eliminated&nbsp;by&nbsp;erasure</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;that:&nbsp;Branch[T]&nbsp;=&gt;&nbsp;this.elem&nbsp;==&nbsp;that.elem&nbsp;&amp;&amp;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>As the warning says, there is a pattern match against a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type, yet the system can only check that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>other</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>reference is (some kind of)<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN>; it cannot check that the element type of the tree is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. You encountered in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html">Chapter 19</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>the reason for this: element types of parameterized types are eliminated by the compiler's erasure phase; they are not available to be inspected at run-time.<A id=i-237149939-1></A><A id=i101369192-1></A><A id=i-735891161-1></A></P>
<P>So what can you do? Fortunately, it turns out that you need not necessarily check that two<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN>es have the same element types when comparing them. It's quite possible that two<SPAN class=code>Branch</SPAN>es with different element types are equal, as long as their fields are the same. A simple example of this would be the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that consists of a single<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>element and two empty subtrees. It's plausible to consider any two such<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN>es to be equal, no matter what static types they have:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;b1&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Branch[List[String]]</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EmptyTree</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EmptyTree</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">b1:&nbsp;Branch[List[String]]&nbsp;=&nbsp;Branch@2f1eb9</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;b2&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Branch[List[Int]]</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EmptyTree</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">EmptyTree</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">b2:&nbsp;Branch[List[Int]]&nbsp;=&nbsp;Branch@be55d1</SPAN>
  <BR>  scala&gt;&nbsp;b1&nbsp;==&nbsp;b2
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>
<P></P>
<P>The positive result of the comparison above was obtained with the implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown previously. This demonstrates that the element type of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN>was not checked&#8212;if it had been checked, the result would have been<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>.</P>
<P>Note that one can disagree which of the two possible outcomes of the comparison would be more natural. In the end, this depends on the mental model of how classes are represented. In a model where type-parameters are present only at compile-time, it's natural to consider the two<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>values<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be equal. In an alternative model where a type parameter forms part of an object's value, it's equally natural to consider them different. Since Scala adopts the type erasure model, type parameters are not preserved at run time, so that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are naturally considered to be equal.</P>
<P>There's only a tiny change needed to formulate an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that does not produce an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unchecked</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>warning: instead of an element type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>, use a lower case letter, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>t</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Branch[t]</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.elem&nbsp;==&nbsp;that.elem&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.left&nbsp;==&nbsp;that.left&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.right&nbsp;==&nbsp;that.right
</PRE>Recall from<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#sec:kinds-of-patterns">Section 15.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that a type parameter in a pattern starting with a lower-case letter represents an unknown type. Hence, the pattern match:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Branch[t]</SPAN>&nbsp;=&gt;&nbsp;
</PRE>will succeed for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>values of any type. The type parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>t</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>represents the unknown element type of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN>. It can also be replaced by an underscore, as in the following case, which is equivalent to the previous one:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Branch[_]</SPAN>&nbsp;=&gt;
</PRE>
<P></P>
<P>The only thing that remains is to define for class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the other two methods,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN>, which go with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>. Here's a possible implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hashCode:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;+&nbsp;elem.hashCode
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;+&nbsp;left.hashCode
  &nbsp;&nbsp;)&nbsp;+&nbsp;right.hashCode
</PRE>This is only one of many possible implementations. As shown previously, the principle is to take<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>values of all fields, and to combine them using additions and multiplications by some prime number. Here's an implementation of method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;canEqual(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Branch[_]</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  }
</PRE>The implementation of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method used a typed pattern match. It would also be possible to formulate it with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isInstanceOf</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;canEqual(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other.isInstanceOf[<SPAN class=typename style="COLOR: rgb(103,0,154)">Branch[_]</SPAN>]
</PRE>If you feel like nit-picking (and we encourage you to do so!), you might wonder what the occurrence of the underscore in the type above signifies. After all,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch[_]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a technically a type parameter of a method, not a type pattern, so how is it possible to leave some parts of it undefined?<A id=i-961603339-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The answer to that question is found in the next chapter:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch[_]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a shorthand for a so-called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">existential type</SPAN>,<A id=i-531244609-1></A><A id=i1673589657-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which is roughly speaking a type with some unknown parts in it. So even though technically the underscore stands for two different things in a pattern match and in a type parameter of a method call, in essence the meaning is the same: it lets you label something that is unknown. The final version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Branch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is shown in<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#lst:a-good-branch">Listing 28.4</A>. 
<P></P>
<P><A name=lst:a-good-branch></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Branch[T]</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;elem:&nbsp;T,
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;left:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tree[T]</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;right:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tree[T]</SPAN>
  &nbsp;&nbsp;)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tree[T]</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Branch[_]</SPAN>&nbsp;=&gt;&nbsp;(that&nbsp;canEqual&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.elem&nbsp;==&nbsp;that.elem&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.left&nbsp;==&nbsp;that.left&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.right&nbsp;==&nbsp;that.right
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;canEqual(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;other.isInstanceOf[<SPAN class=typename style="COLOR: rgb(103,0,154)">Branch[_]</SPAN>]
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hashCode:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;+&nbsp;elem.hashCode
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;+&nbsp;left.hashCode
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;+&nbsp;right.hashCode
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 28.4 - A parameterized type with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=28.4></A>28.4 Recipes for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#28.4">link</A>]</SPAN></H3>
<P>In this section, we'll provide step-by-step recipes for creating<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods that should suffice for most situations. As an illustration, we'll use the methods of class<SPAN class=code>Rational</SPAN>, shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#lst:rational-equals-hashcode">Listing 28.5</A>. To create this class, we removed the mathematical operator methods from the version of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html#lst:overloaded-methods">Listing 6.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html#lst:overloaded-methods">here</A>. We also made a minor enhancement to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and modified the initializers of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denom</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to normalize all fractions to have a positive denominator (<I>i.e.</I>, to transform<SPAN class=Apple-converted-space>&nbsp;</SPAN><SUP>1</SUP>/<SUB>-2</SUB><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SUP>-1</SUP>/<SUB>2</SUB>). Here's the recipe for overriding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>:<A id=i-145701109-1></A></P>
<P><A name=lst:rational-equals-hashcode></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>(n:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;d:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;g&nbsp;=&nbsp;gcd(n.abs,&nbsp;d.abs)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;numer&nbsp;=&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(d&nbsp;&lt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;-n&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;n)&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;denom&nbsp;=&nbsp;d.abs&nbsp;/&nbsp;g
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;gcd(a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;b:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(b&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;a&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;gcd(b,&nbsp;a&nbsp;%&nbsp;b)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(that&nbsp;canEqual&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;==&nbsp;that.numer&nbsp;&amp;&amp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;==&nbsp;that.denom
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;canEqual(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other.isInstanceOf[<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>]
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hashCode:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;+&nbsp;numer
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;+&nbsp;denom
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(denom&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)&nbsp;numer.toString&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;numer&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"/"</SPAN>+&nbsp;denom
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 28.5 - Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>.</H5>
<OL>
<LI>If you're going to override<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in a non-final class, you should create a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. If the inherited definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(that is,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was not redefined higher up in the class hierarchy), the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be new, otherwise it will override a previous definition of a method with the same name. The only exception to this requirement is for final classes that redefine the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method inherited from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>. For them the subclass anomalies described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#sec:writing-an-equality-method">Section 28.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>cannot arise; consequently they need not define<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN>. The type of the object passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;canEqual(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=
</PRE>
<LI>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method should yield<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the argument object is an instance of the current class (<I>i.e.</I>, the class in which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined),<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>otherwise:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  other.isInstanceOf[<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>]
</PRE>
<LI>In the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, make sure you declare the type of the object passed as an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(other:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=
</PRE>
<LI>Write the body of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method as a single<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. The selector of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should be the object passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  other&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;...</SPAN>
  }
</PRE>
<LI>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression should have two cases. The first case should declare a typed pattern for the type of the class on which you're defining the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>&nbsp;=&gt;
</PRE>
<LI>In the body of this case, write an expression that logical-ands together the individual expressions that must be true for the objects to be equal. If the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method you are overriding is not that of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>, you will most likely want to include an invocation of the superclass's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">super</SPAN>.equals(that)&nbsp;&amp;&amp;
</PRE>If you are defining<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for a class that first introduced<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN>, you should invoke<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the argument to the equality method, passing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as the argument:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  (that&nbsp;canEqual&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)&nbsp;&amp;&amp;
</PRE>Overriding redefinitions of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should also include the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>invocation, unless they contain a call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super.equals</SPAN>. In the latter case, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>test will already be done by the superclass call. Lastly, for each field relevant to equality, verify that the field in this object is equal to the corresponding field in the passed object:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  numer&nbsp;==&nbsp;that.numer&nbsp;&amp;&amp;
  denom&nbsp;==&nbsp;that.denom
</PRE>
<LI>For the second case, use a wildcard pattern that yields false:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
</PRE></LI></OL>
<P>If you adhere to the preceding recipe, equality is guaranteed to be an equivalence relation, as is required by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contract.</P>
<P>For<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>, you can usually achieve satisfactory results if you use the following recipe, which<A id=i-1457981337-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is similar to a recipe recommended for Java classes in<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Effective Java</EM>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#footnote28-8">[8]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Include in the calculation each field in your object that is used to determine equality in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method (the "relevant" fields). For each relevant field, no matter its type, you can calculate a hash code by invoking<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on it. To calculate a hash code for the entire object, add 41 to the first field's hash code, multiply that by 41, add the second field's hash code, multiply that by 41, add the third field's hash code, multiply that by 41, and so on, until you've done this for all relevant fields.</P>
<P>For example, to implement the hash code for an object that has five relevant fields named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>c</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>d</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN>, you would write:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hashCode:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;+&nbsp;a.hashCode
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;+&nbsp;b.hashCode
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;+&nbsp;c.hashCode
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;+&nbsp;d.hashCode
  &nbsp;&nbsp;)&nbsp;+&nbsp;e.hashCode
</PRE>If you wish, you can leave off the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>invocation on fields of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Short</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Byte</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Char</SPAN>.<A id=i517506535-2></A><A id=i1149344948-2></A><A id=i1013322880-2></A><A id=i1377752142-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The hash code for an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the value of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>, as are the hash codes of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Short</SPAN>s,<SPAN class=code>Byte</SPAN>s, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Char</SPAN>s when automatically widened to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>. Given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>numer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>denom</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>s, therefore, we implemented<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hashCode:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;+&nbsp;numer
  &nbsp;&nbsp;)&nbsp;+&nbsp;denom
</PRE>The number 41 was selected for the multiplications because it is an odd prime. You could use another number, but it should be an odd prime to minimize the potential for information loss on overflow. The reason we added 41 to the innermost value is to reduce the likelihood that the first multiplication will result in zero, under the assumption that it is more likely the first field used will be zero than -41. The number 41 was chosen for the addition only for looks. You could use any non-zero integer. 
<P></P>
<P>If the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method invokes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super.equals(that)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as part of its calculation, you should start your<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>calculation with an invocation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super.hashCode</SPAN>. For example, had<SPAN class=code>Rational</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method invoked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super.equals(that)</SPAN>, its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would have been:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hashCode:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">super</SPAN>.hashCode
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;+&nbsp;numer
  &nbsp;&nbsp;)&nbsp;+&nbsp;denom
</PRE>
<P></P>
<P>One thing to keep in mind as you write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods using this approach is that your hash code will only be as good as the hash codes you build it out of, namely the hash codes you obtain by calling<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the relevant fields of your object. Sometimes you may need to do something extra besides just calling<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the field to get a useful hash code for that field. For example, if one of your fields is a collection, you probably want a hash code for that field that is based on all the elements contained in the collection. If the field is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>, or tuple, you can simply call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the field, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are overridden in those classes to take into account the contained elements. However the same is not true for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN>s, which do not take elements into account when calculating a hash code. Thus for an array, you should treat each element of the array like an individual field of your object, calling<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on each element explicitly, or passing the array to one of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods in singleton object<SPAN class=code>java.util.Arrays</SPAN>.</P>
<P>Lastly, if you find that a particular hash code calculation is harming the performance of your program, you can consider caching the hash code. If the object is immutable, you can calculate the hash code when the object is created and store it in a field. You can do this by simply overriding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN>, like this:<A id=i1757872331-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;hashCode:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;*&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">41</SPAN>&nbsp;+&nbsp;numer
  &nbsp;&nbsp;)&nbsp;+&nbsp;denom
</PRE>This approach trades off memory for computation time, because each instance of the immutable class will have one more field to hold the cached hash code value. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=28.5></A>28.5 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html#28.5">link</A>]</SPAN></H3>
<P>In retrospect, defining a correct implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has been surprisingly subtle. You must be careful about the type signature; you must override<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>; you should avoid dependencies on mutable state; and you should implement and use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>canEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method if your class is non-final. Given how difficult it is to implement a correct equality method, you might prefer to define your classes of comparable objects as case classes. That way, the Scala compiler will add<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods with the right properties automatically.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 28:</H4>
<P><A name=footnote28-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Vaziri, et al., "Declarative Object Identity Using Relation Types"<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#vaziri-tip-2007">vaziri-tip-2007</A></P>
<P><A name=footnote28-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>All but the third of these pitfalls are described in the context of Java in the book,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Effective Java Second Edition</EM>, by Joshua Bloch.<A id=i-64318620-1></A><A id=i186753339-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#bloch:effective-java">bloch:effective-java</A></P>
<P><A name=footnote28-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>If you write a lot of Java, you might expect the argument to this method to be type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Object</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>. Don't worry about it. It is the same<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. The compiler simply makes it appear to have type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>.</P>
<P><A name=footnote28-4>[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The text of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contract is inspired by the Javadoc documentation of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Object</SPAN>.</P>
<P><A name=footnote28-5>[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>As with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contract is based on the contract of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Object</SPAN>.</P>
<P><A name=footnote28-6>[6]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Given the new implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN>, this version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ColoredPoint</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>no longer violates the symmetry requirement.</P>
<P><A name=footnote28-7>[7]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Bloch,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Effective Java Second Edition</EM>, p. 39<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#bloch:effective-java">bloch:effective-java</A><A id=i-64318620-2></A><A id=i166435877-1></A></P>
<P><A name=footnote28-8>[8]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Bloch,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Effective Java Second Edition</EM>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#bloch:effective-java">bloch:effective-java</A><A id=i-64318620-3></A><A id=i166435877-2></A></P></DIV>