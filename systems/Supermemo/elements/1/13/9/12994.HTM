<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 30 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Actors and Concurrency</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>Sometimes it helps in designing a program to specify that things happen independently, in parallel,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">concurrently</EM>. Java includes support for concurrency, and although this support is sufficient, it turns out to be quite difficult to get right in practice as programs get larger and more complex.<A id=i-1261817322-1></A><A id=i-1422944994-3></A><A id=i1338746414-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Scala augments Java's native support by adding<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">actors</EM>. Actors provide a concurrency model that is easier to work with and can, therefore, help you avoid many of the difficulties of using Java's native concurrency model. This chapter will show you the basics of how to use Scala's actors library and provide an extended example that transforms the single-threaded circuit simulation code of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html">Chapter 18</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>into a multi-threaded version.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=30.1></A>30.1 Trouble in paradise<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#30.1">link</A>]</SPAN></H3>
<P>The Java platform comes with a built-in threading model based on shared data and locks. Each object is associated with a logical<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">monitor</EM>,<A id=i-328798631-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which can be used to control multi-threaded access to data. To use this model, you decide what data will be shared by multiple threads and mark as "synchronized" sections of the code that access, or control access to, the shared data. The Java runtime employs a locking mechanism to ensure that only one thread at a time enters synchronized sections guarded by the same lock, thereby enabling you to orchestrate multi-threaded access to the shared data.<A id=i2035919517-1></A></P>
<P>Unfortunately, programmers have found it very difficult to reliably build robust multi-threaded applications using the shared data and locks model, especially as applications grow in size and complexity. The problem is that at each point in the program, you must reason about what data you are modifying or accessing that might be modified or accessed by other threads, and what locks are being held. At each method call, you must reason about what locks it will try to hold, and convince yourself that it will not deadlock while<A id=i503639951-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>trying to obtain them. Compounding the problem, the locks you reason about are not fixed at compile time, because the program is free to create new locks at run time as it progresses.</P>
<P>Making things worse, testing is not reliable with multi-threaded code.<A id=i-670497952-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Since threads are non-deterministic, you might successfully test a program one thousand times, yet still the program could go wrong the first time it runs on a customer's machine. With shared data and locks, you must get the program correct through reason alone.</P>
<P>Moreover, you can't solve the problem by over-synchronizing either. It can be just as problematic to synchronize everything as it is to synchronize nothing. The problem is that new lock operations remove possibilities for race conditions, but simultaneously add possibilities for deadlocks. A correct lock-using program must have neither race conditions nor deadlocks, so you cannot play it safe by overdoing it in either direction.</P>
<P>Java 5 introduced<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.util.concurrent</SPAN>, a library of concurrency utilities that provides higher level abstractions for concurrent programming.<A id=i-1522908125-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Using the concurrency utilities makes multi-threaded programming far less error prone than rolling your own abstractions with Java's low-level synchronization primitives. Nevertheless, the concurrent utilities are also based on the shared data and locks model, and as a result do not solve the fundamental difficulties of using that model.<A id=i1837693870-1></A><A id=i1225979037-1></A><A id=i1954917920-1></A></P>
<P>Scala's actors library does address the fundamental problem by providing an alternative,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">share-nothing</EM>, message-passing model that programmers tend to find much easier to reason about.<A id=i-93411491-1></A><A id=i-1499722452-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Actors are a good first tool of choice when designing concurrent software, because they can help you avoid the deadlocks and race conditions that are easy to fall into when using the shared data and locks model.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=30.2></A>30.2 Actors and message passing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#30.2">link</A>]</SPAN></H3>
<P>An actor is a thread-like entity that has a mailbox for receiving messages.<A id=i-122023144-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>To implement an actor, you subclass<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.actors.Actor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and implement the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.<A id=i63093205-1></A><A id=i1229358457-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>An example is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#lst:silly-actor">Listing 30.1</A>. This actor doesn't do anything with its mailbox. It just prints a message five times and quits.<A name=lst:silly-actor></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.actors._
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SillyActor</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;act()&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(i&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;to&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"I'm&nbsp;acting!"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(<SPAN class=literal style="COLOR: rgb(205,123,0)">1000</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 30.1 - A simple actor.</H5>
<P>You start an actor by invoking its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>start</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, similar to the way you start a Java thread:<A id=i827922473-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;SillyActor.start()
  <SPAN class=output style="COLOR: rgb(90,0,0)">I'm&nbsp;acting!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;scala.actors.Actor&nbsp;=&nbsp;SillyActor$@1945696</SPAN>
  <BR>  <SPAN class=output style="COLOR: rgb(90,0,0)">scala&gt;&nbsp;I'm&nbsp;acting!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">I'm&nbsp;acting!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">I'm&nbsp;acting!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">I'm&nbsp;acting!</SPAN>
</PRE>Notice that the "I'm acting!" output is interleaved with the Scala shell's output. This interleaving is due to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SillyActor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>actor running independently from the thread running the shell. Actors run independently from each other, too. For example, given this second actor:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.actors._
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SeriousActor</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;act()&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(i&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;to&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"To&nbsp;be&nbsp;or&nbsp;not&nbsp;to&nbsp;be."</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(<SPAN class=literal style="COLOR: rgb(205,123,0)">1000</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  }
</PRE>
<P></P>
<P>You could run two actors at the same time, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;SillyActor.start();&nbsp;SeriousActor.start()
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;scala.actors.Actor&nbsp;=&nbsp;seriousActor$@1689405</SPAN>
  <BR>  <SPAN class=output style="COLOR: rgb(90,0,0)">scala&gt;&nbsp;To&nbsp;be&nbsp;or&nbsp;not&nbsp;to&nbsp;be.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">I'm&nbsp;acting!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">To&nbsp;be&nbsp;or&nbsp;not&nbsp;to&nbsp;be.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">I'm&nbsp;acting!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">To&nbsp;be&nbsp;or&nbsp;not&nbsp;to&nbsp;be.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">I'm&nbsp;acting!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">To&nbsp;be&nbsp;or&nbsp;not&nbsp;to&nbsp;be.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">I'm&nbsp;acting!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">To&nbsp;be&nbsp;or&nbsp;not&nbsp;to&nbsp;be.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">I'm&nbsp;acting!</SPAN>
</PRE>You can also create an actor using a utility method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>actor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.actors.Actor</SPAN>:<A id=i297460982-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.actors.Actor._
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;seriousActor2&nbsp;=&nbsp;actor&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(i&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;to&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"That&nbsp;is&nbsp;the&nbsp;question."</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(<SPAN class=literal style="COLOR: rgb(205,123,0)">1000</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  <SPAN class=output style="COLOR: rgb(90,0,0)">scala&gt;&nbsp;That&nbsp;is&nbsp;the&nbsp;question.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">That&nbsp;is&nbsp;the&nbsp;question.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">That&nbsp;is&nbsp;the&nbsp;question.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">That&nbsp;is&nbsp;the&nbsp;question.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">That&nbsp;is&nbsp;the&nbsp;question.</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition above creates an actor that executes the actions defined in the block following the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>actor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. The actor starts immediately when it is defined. There is no need to call a separate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>start</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. 
<P></P>
<P>All well and good. You can create actors and they run independently. How do they work together, though? How do they communicate without using shared memory and locks? Actors communicate by sending each other<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g954925063"><EM style="FONT-STYLE: italic">messages</EM></A>. You send a message by using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>!</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, like this:<A id=i1171485367-1></A><A id=i155878042-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SillyActor</SPAN>&nbsp;!&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hi&nbsp;there"</SPAN>
</PRE>Nothing happens in this case, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SillyActor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is too busy acting to process its messages, and so the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"hi</SPAN>&nbsp;<SPAN class=code>there"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>message sits in its mailbox unread.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#lst:receive-clause">Listing 30.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a new, more sociable, actor that waits for a message in its mailbox and prints out whatever it receives. It receives a message by calling<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN>, passing in a partial function.<A id=i-1060995512-1></A><A id=i-854473105-1></A><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#footnote30-1">[1]</A><A name=lst:receive-clause></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;echoActor&nbsp;=&nbsp;actor&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">while</SPAN>&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;receive&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;msg&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"received&nbsp;message:&nbsp;"</SPAN>+&nbsp;msg)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 30.2 - An actor that calls<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN>.</H5>
<P>When an actor sends a message, it does not block, and when an actor receives a message, it is not interrupted. The sent message waits in the receiving actor's mailbox until the actor calls<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN>. You can see this behavior illustrated here:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;echoActor&nbsp;!&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hi&nbsp;there"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">received&nbsp;message:&nbsp;hi&nbsp;there</SPAN>
  <BR>  scala&gt;&nbsp;echoActor&nbsp;!&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">15</SPAN>
  <BR>  scala&gt;&nbsp;received&nbsp;message:&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">15</SPAN>
</PRE>
<P>As discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#sec:partial-functions">Section 15.7</A>, a partial function (an instance of trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PartialFunction</SPAN>) is not a full function&#8212;<I>i.e.</I>, it might not be defined over all input values.<A id=i-33298553-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In addition to an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN>method that takes one argument, a partial function offers an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isDefinedAt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which also takes one argument.<A id=i1604479281-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isDefinedAt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method will return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the partial function can "handle" the passed value. Such values are safe to pass to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN>. If you pass a value to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isDefinedAt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would return false, however,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will throw an exception.</P>
<P>An actor will only process messages matching one of the cases in the partial function passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN>. For each message in the mailbox,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will first invoke<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isDefinedAt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the passed partial function to determine whether it has a case that will match and handle the message. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method will choose the first message in the mailbox for which<SPAN class=code>isDefinedAt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns true, and pass that message to the partial function's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. The partial function's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method will handle the message. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>echoActor</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN>method will print<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"received</SPAN>&nbsp;<SPAN class=code>message:</SPAN>&nbsp;<SPAN class=code>"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>followed by the message object's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>result. If the mailbox contains no message for which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isDefinedAt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns true, the actor on which<SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was invoked will block until a matching message arrives.</P>
<P>For example, here is an actor that handles only messages of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;intActor&nbsp;=&nbsp;actor&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;receive&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;I&nbsp;only&nbsp;want&nbsp;Ints</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Got&nbsp;an&nbsp;Int:&nbsp;"</SPAN>+&nbsp;x)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">intActor:&nbsp;scala.actors.Actor&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;scala.actors.Actor$$anon$1@34ba6b</SPAN>
</PRE>If you send a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>, for example, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>intActor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will silently ignore the message:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;intActor&nbsp;!&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>
  scala&gt;&nbsp;intActor&nbsp;!&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Math.Pi</SPAN>
</PRE>But if you pass an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>, you'll get a response printed out:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;intActor&nbsp;!&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">12</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Got&nbsp;an&nbsp;Int:&nbsp;12</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=30.3></A>30.3 Treating native threads as actors<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#30.3">link</A>]</SPAN></H3>
<P>The actor subsystem manages one or more native threads for its own use.<A id=i1922192932-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>So long as you work with an explicit actor that you define, you do not need to think much about how they map to threads.</P>
<P>The other direction is also supported by the subsystem: every native thread is also usable as an actor. However, you cannot use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Thread.current</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>directly, because it does not have the necessary methods.<A id=i-1922502654-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Instead, you should use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Actor.self</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if you want to view the current thread as an actor.</P>
<P>This facility is especially useful for debugging actors from the interactive shell. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.actors.Actor._
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;scala.actors.Actor._</SPAN>
  <BR>  scala&gt;&nbsp;self&nbsp;!&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>
  <BR>  scala&gt;&nbsp;self.receive&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;=&gt;&nbsp;x&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">res6:&nbsp;Any&nbsp;=&nbsp;hello</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method returns the value computed by the partial function passed to it. In this case, the partial function returns the message itself, and so the received message ends up being printed out by the interpreter shell. 
<P></P>
<P>If you use this technique, it is better to use a variant of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receiveWithin</SPAN>.<A id=i-1195361571-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You can then specify a timeout in milliseconds. If you use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the interpreter shell, then the<SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will block the shell until a message arrives. In the case of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>self.receive</SPAN>, this could mean waiting forever! Instead, use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receiveWithin</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with some timeout value:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;self.receiveWithin(<SPAN class=literal style="COLOR: rgb(205,123,0)">1000</SPAN>)&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;=&gt;&nbsp;x&nbsp;}&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;wait&nbsp;a&nbsp;sec!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res7:&nbsp;Any&nbsp;=&nbsp;TIMEOUT</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=30.4></A>30.4 Better performance through thread reuse<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#30.4">link</A>]</SPAN></H3>
<P>Actors are implemented on top of normal Java threads. As described so far, in fact, every actor must be given its own thread, so that all the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods get their turn.</P>
<P>Unfortunately, despite their light-sounding name, threads are not all that cheap in Java. Threads consume enough memory that typical Java virtual machines, which can host millions of objects, can have only thousands of threads. Worse, switching threads often takes hundreds if not thousands of processor cycles. If you want your program be as efficient as possible, then it is important to be sparing with thread creation and switching.<A id=i1159262946-1></A></P>
<P>To help you conserve threads, Scala provides an alternative to the usual<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN>.<A id=i785426092-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes a partial function. Unlike<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN>, however,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN>does not return after it finds and processes a message. Its result type is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nothing</SPAN>. It evaluates the message handler and that's it.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#footnote30-2">[2]</A></P>
<P>Because the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method does not need to return, the implementation does not need to preserve the call stack of the current<A id=i-1862604258-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>thread. Instead, the library can reuse the current thread for the next actor that wakes up. This approach is so effective that if every actor in a program uses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN>, only a single thread is necessary in principle to host all of the program's actors (to be sure, if your computer has several processor cores, the actors subsystem will use enough threads to utilize all cores when it can).<A id=i-1206501288-2></A></P>
<DIV class=callout style="BORDER-RIGHT: rgb(153,153,153) groove; PADDING-RIGHT: 49px; BORDER-TOP: rgb(153,153,153) groove; PADDING-LEFT: 49px; PADDING-BOTTOM: 0.5em; MARGIN-LEFT: 49px; BORDER-LEFT: rgb(153,153,153) groove; MARGIN-RIGHT: 49px; PADDING-TOP: 0.5em; BORDER-BOTTOM: rgb(153,153,153) groove; BACKGROUND-COLOR: rgb(248,248,248)">
<P><BR>In practice, programs will need at least a few<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN>'s, but you should try to use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>whenever possible so as to conserve threads.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DIV>
<P>Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not return, the message handler you pass it must now both process that message and arrange to do all of the actor's remaining work. A common way to do this is to have a top-level work method&#8212;such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>itself&#8212;that the message handler calls when it finishes.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#lst:reactive-actor">Listing 30.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an example that uses this approach.</P>
<P><A name=lst:reactive-actor></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">NameResolver</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;java.net.{<SPAN class=typename style="COLOR: rgb(103,0,154)">InetAddress</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnknownHostException</SPAN>}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;act()&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;react&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;actor:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actor&nbsp;!&nbsp;getIp(name)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;act()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"EXIT"</SPAN>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Name&nbsp;resolver&nbsp;exiting."</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;quit</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;msg&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Unhandled&nbsp;message:&nbsp;"</SPAN>+&nbsp;msg)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;act()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;getIp(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Option[InetAddress]</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">try</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(InetAddress.getByName(name))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">catch</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_:<SPAN class=typename style="COLOR: rgb(103,0,154)">UnknownHostException</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">None</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 30.3 - An actor that calls<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN>.</H5>
<P>The actor shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#lst:reactive-actor">Listing 30.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>waits for strings that are host names, and if there is one, returns an IP address for that host name. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;NameResolver.start()
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;scala.actors.Actor&nbsp;=&nbsp;NameResolver$@90d6c5</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">NameResolver</SPAN>&nbsp;!&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"www.scala-lang.org"</SPAN>,&nbsp;self)
  <BR>  scala&gt;&nbsp;self.receiveWithin(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;=&gt;&nbsp;x&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;Any&nbsp;=&nbsp;Some(www.scala-lang.org/128.178.154.102)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">NameResolver</SPAN>&nbsp;!&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"wwwwww.scala-lang.org"</SPAN>,&nbsp;self)
  <BR>  scala&gt;&nbsp;self.receiveWithin(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;=&gt;&nbsp;x&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;Any&nbsp;=&nbsp;None</SPAN>
</PRE>Writing an actor to use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is challenging, but pays off in performance. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not return, the calling actor's call stack can be discarded, freeing up the thread's resources for a different actor. At the extreme, if all of the actors of a program use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN>, then they can be implemented on a single thread. 
<P>This coding pattern is so common with event-based actors, there is special support in the library for it. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Actor.loop</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function executes a block of code repeatedly, even if the code calls<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN>.<A id=i-534082357-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>NameResolver</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method can be rewritten to use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>loop</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#lst:act-with-loop">Listing 30.4</A>. The one difference in behavior between this<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method and that of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#lst:reactive-actor">Listing 30.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is that this one does not handle<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"EXIT"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by quitting. Instead, this actor will loop and react to messages forever.<A name=lst:act-with-loop></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;act()&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;react&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;actor:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actor&nbsp;!&nbsp;getIp(name)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;msg&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Unhandled&nbsp;message:&nbsp;"</SPAN>&nbsp;+&nbsp;msg)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 30.4 - An actor's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that uses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>loop</SPAN>.</H5>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">How<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>works</H3>
<P>A return type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nothing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>indicates a function will never return normally, but instead will always complete abruptly with an exception. And indeed, this is true of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN>. The actual implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not as simple as the following description, and subject to change, but conceptually you can think of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as working like this:</P>
<P>When you call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>start</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on an actor, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>start</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method will in some way arrange things such that some thread will eventually call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on that actor. If that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method invokes<SPAN class=code>react</SPAN>, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method will look in the actor's mailbox for a message the passed partial function can handle. (It does this the same way as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN>, by passing candidate messages to the partial function's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isDefinedAt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.) If it finds a message that can be handled,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will schedule the handling of that message for later execution and throw an exception. If it doesn't find one, it will place the actor in "cold storage," to be resurrected if and when it gets more messages in its mailbox, and throw an exception. In either case,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will complete abruptly with this exception, and so will<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN>. The thread that invoked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will catch the exception, forget about the actor, and move on to other duties.</P>
<P>This is why if you want<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to handle more than the first message, you'll need to call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>again from inside your partial function, or use some other means to get<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN>invoked again.</P></DIV>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=30.5></A>30.5 Good actors style<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#30.5">link</A>]</SPAN></H3>
<P>At this point you have seen everything you need to write your own actors. Simply using these methods takes you only so far, however. The point of them is that they support an actors<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">style</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of concurrent programming. To the extent you can write in this style, your code will be easier to debug and will have fewer deadlocks and race conditions. This section provides some guidelines for programming in an actors style.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Actors should not block</H4>
<P>A well written actor does not block while processing a message. The problem is that while the actor blocks, some other actor might make a request on it that it could handle. If the actor is blocked on the first request, it will not even notice the second request. In the worst case, a deadlock can even result, with multiple actors blocked as they each wait for some other blocked actor to respond.</P>
<P>Instead of blocking, the actor should arrange for some message to arrive designating that action is ready to be taken. Often this rearrangement will require the help of other actors. For example, instead of calling<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Thread.sleep</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>directly and blocking the current actor, you could create a helper actor that sleeps and then sends a message back when enough time has elapsed:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  actor&nbsp;{
  &nbsp;&nbsp;Thread.sleep(time)
  &nbsp;&nbsp;mainActor&nbsp;!&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"WAKEUP"</SPAN>
  }&nbsp;
</PRE>This helper actor does indeed block, but since it will never receive a message, it is OK in this case. The main actor remains available to answer new requests. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>emoteLater</SPAN>method, shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#lst:timer-helper">Listing 30.5</A>, demonstrates the use of this idiom. It creates a new actor that will do the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sleep</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>so that the main actor does not block. To ensure that it sends the<SPAN class=code>"Emote"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>message to the correct actor, it is careful to evaluate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>self</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the scope of the main actor instead of the scope of the helper actor.<A name=lst:timer-helper></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;sillyActor2&nbsp;=&nbsp;actor&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;emoteLater()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;mainActor&nbsp;=&nbsp;self
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actor&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(<SPAN class=literal style="COLOR: rgb(205,123,0)">1000</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainActor&nbsp;!&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Emote"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;emoted&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;emoteLater()
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;react&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Emote"</SPAN>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"I'm&nbsp;acting!"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emoted&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(emoted&nbsp;&lt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emoteLater()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;msg&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Received:&nbsp;"</SPAN>+&nbsp;msg)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 30.5 - An actor that uses a helper actor to avoid blocking itself.</H5>
<P>Because this actor does not block in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sleep</SPAN>&#8212;its helper actor does&#8212;it can continue to do other work while waiting for its next time to emote. Unlike the earlier silly actor, this one will continue to print out messages while it waits for its next input:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;sillyActor2&nbsp;!&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hi&nbsp;there"</SPAN>
  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Received</SPAN>:&nbsp;hi&nbsp;there
  <SPAN class=output style="COLOR: rgb(90,0,0)">I'm&nbsp;acting!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">I'm&nbsp;acting!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">I'm&nbsp;acting!</SPAN>
</PRE>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Communicate with actors only via messages</H4>
<P>The key way the actors model addresses the difficulties of the shared data and locks model is by providing a safe space&#8212;the actor's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method&#8212;where you can think sequentially. Put another way, actors allow you to write a multi-threaded program as a bunch of independent single-threaded programs that communicate with each other via asynchronous messaging.<A id=i1351372324-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This simplification works, however, only so long as messages are the only way you let your actors communicate.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#footnote30-3">[3]</A><A id=i855957185-1></A></P>
<P>For example, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>GoodActor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>could include a reference to itself in a message to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BadActor</SPAN>, to identify itself as the source of that message. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BadActor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>invokes some arbitrary method on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>GoodActor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of sending it a message with `<SPAN class=code>!</SPAN>', however, problems may ensue. The invoked method might read private instance data in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>GoodActor</SPAN>, which may have been written by a different thread. As a result, you would need to ensure that both the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BadActor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>thread's reading of the instance data and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>GoodActor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>thread's writing of it are synchronized on the same lock. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>GoodActor</SPAN>'s private instance data has become<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">shared data</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>that must be guarded by a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">lock</EM>. As soon as you go around the message passing scheme between actors, therefore, you drop back down into the shared data and locks model, with all the difficulties you were trying to avoid in the first place by using the actors model.<A id=i-122023144-3></A></P>
<P>On the other hand, this does not mean that you should never go around message passing. Although shared data and locks is very difficult to get right, it is not impossible. One difference between Scala's approach to actors and that of Erlang, in fact, is that Scala gives you the option to combine the actors and shared data and locks models in the same program.<A id=i-894319228-1></A></P>
<P>As an example, imagine you wanted multiple actors to share a common mutable map. Since the map is mutable, the pure actors approach would be to create an actor that "owns" the mutable map and define a set of messages that allows other actors to access it. You could define a message for putting a key-value pair into the shared map, getting a value given a key, and so on, for all the operations you need to do on the map. In addition, you'd need to define messages for sending asynchronous responses to actors that made queries of the map. Another option, however, is to pass a thread-safe map, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ConcurrentHashMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from the<A id=i181041576-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Java Concurrency Utilities, in a message to multiple actors, and let those actors use that map directly.<A id=i557834191-1></A><A id=i1928053007-1></A><A id=i510829358-1></A></P>
<P>Although it would be far easier and safer to implement a shared map via actors than to implement something like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ConcurrentHashMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>yourself, since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ConcurrentHashMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>already exists, you may judge it easier and as low risk to use that than to implement your own shared map with an actor. This would also mean that your responses from the shared map could be synchronous, whereas with actors they would need to be asynchronous. Scala's actors library gives you the choice.</P>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">If you're considering shared data and locks</H3>
<P>When considering whether to combine the actors model with the shared data and locks model, it is helpful to recall the words of Harry Callahan,<A id=i-1020432582-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>played by Clint Eastwood<A id=i-1067398584-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the 1971 movie Dirty Harry:<A id=i317859986-1></A></P>
<P><EM style="FONT-STYLE: italic">I know what you're thinking. "Did he fire six shots or only five?" Well, to tell you the truth, in all this excitement I kind of lost track myself. But being as this is a .44 Magnum, the most powerful handgun in the world, and would blow your head clean off, you've got to ask yourself one question: Do I feel lucky? Well, do ya, punk?</EM></P></DIV>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Prefer immutable messages</H4>
<P>Because Scala's actors model provides what amounts to a single-threaded environment inside each actor's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, you need not worry about whether the objects you use in the implementation of this method are thread-safe.<A id=i181041576-4></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You can use unsynchronized, mutable objects to your hearts content in an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, for example, because each<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is effectively confined to one thread.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#footnote30-4">[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This is why the actors model is called a share-nothing model&#8212;the data is confined to one thread rather than being shared by many.</P>
<P>There is one exception to the share-nothing rule, however: the data inside objects used to send messages between actors is "shared" by multiple actors. As a result, you<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">do</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>have to worry about whether message objects are thread-safe. And in general, they should be.</P>
<P>The best way to ensure that message objects are thread-safe is to only use immutable objects for messages. Instances of any class that has only<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fields, which themselves refer only to immutable objects, are immutable. An easy way to define such message classes, of course, is as case classes.<A id=i783873611-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>So long as you don't explicitly add<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fields to a case class and ensure the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fields are all immutable types, your case class will by definition be immutable. It will also be convenient for pattern matching in the partial functions passed to<SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>receive</SPAN>. You can also use as messages instances of regular (non-case) immutable classes that you define. Or you can use instances of the many immutable classes provided in the Scala API, such as tuples, strings, lists, immutable sets and maps, and so on.</P>
<P>Now, if an actor sends a mutable, unsynchronized object as a message, and never reads or writes that object thereafter, it would work, but it's just asking for trouble. A future maintainer may not realize the object is shared and write to it, thereby creating a hard to find concurrency bug.</P>
<P>In general, it is best to arrange your data such that every unsynchronized, mutable object is "owned," and therefore accessed by, only one actor. You can arrange for objects to be transferred from one actor to another if you like, but you need to make sure that at any given time, it is clear which actor owns the object and is allowed to access it. In other words, when you design an actors-based system, you need to decide which parts of<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">mutable</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>memory are assigned to which actor. All other actors that access a mutable data structure must send messages to the data structure's owner and wait for a message to come back with a reply.</P>
<P>If you do find you have a mutable object you want to continue using as well as send in a message to another actor, you should make and send a copy of it instead. While you're at it, you may want to make it immutable. For example, because arrays are mutable and unsynchronized, any array you use should be accessed by one actor at a time. If you want to continue using an array as well as send it to another actor, you should send a copy. For example, if the array itself holds only immutable objects, you can make a copy with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arr.clone</SPAN>.<A id=i1900167322-1></A>But you should also consider using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arr.toList</SPAN>, and send the resulting immutable list instead.</P>
<P>Immutable objects are convenient in many cases, but they really shine for parallel systems, because they are the easiest, lowest risk way to design thread-safe objects. When you design a program that might involve parallelism in the future, whether using actors or not, you should try especially hard to make data structures immutable.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Make messages self-contained</H4>
<P>When you return a value from a method, the caller is in a good position to remember what it was doing before it called the method. It can take the response value and then continue whatever it was doing.</P>
<P>With actors, things are trickier. When one actor makes a request of another, the response might not come for a long time. The calling actor should not block, but should continue to do any other work it can while it waits for the response. A difficulty, then, is interpreting the response when it finally does come back. Can the actor remember what it was doing when it made the request?</P>
<P>One way to simplify the logic of an actors program is to include redundant information in the messages. If the request is an immutable object, you can even cheaply include a reference to the request in the return value! For example, the IP-lookup actor would be better if it returned the host name in addition to the IP address found for it. It would make this actor slightly longer, but it should simplify the logic of any actor making requests on it:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;act()&nbsp;{&nbsp;
  &nbsp;&nbsp;loop&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;react&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;actor:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actor&nbsp;!&nbsp;(name,&nbsp;getIp(name))
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  }
</PRE>Another way to increase redundancy in the messages is to make a case class for each kind of message. While such a wrapper is not strictly necessary in many cases, it makes an actors program much easier to understand. Imagine a programmer looking at a send of a string, for example:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  lookerUpper&nbsp;!&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"www.scala-lang.org"</SPAN>,&nbsp;self)
</PRE>It can be difficult to figure out which actors in the code might respond. It is much easier if the code looks like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LookupIP</SPAN>(hostname:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;requester:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>)
  <BR>  lookerUpper&nbsp;!&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LookupIP</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"www.scala-lang.org"</SPAN>,&nbsp;self)
</PRE>Now, the programmer can search for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LookupIP</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the source code, probably finding very few possible responders.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#lst:NameResolver2">Listing 30.6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an updated name-resolving actor that uses case classes instead of tuples for its messages.<A name=lst:NameResolver2></A> 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.actors.Actor._
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;java.net.{<SPAN class=typename style="COLOR: rgb(103,0,154)">InetAddress</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnknownHostException</SPAN>}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LookupIP</SPAN>(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;respondTo:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LookupResult</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;address:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Option[InetAddress]</SPAN>
  &nbsp;&nbsp;)
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">NameResolver2</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;act()&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;react&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LookupIP</SPAN>(name,&nbsp;actor)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actor&nbsp;!&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LookupResult</SPAN>(name,&nbsp;getIp(name))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;getIp(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Option[InetAddress]</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;As&nbsp;before&nbsp;(in&nbsp;Listing&nbsp;30.3)</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 30.6 - An actor that uses case classes for messages.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=30.6></A>30.6 A longer example: Parallel discrete event simulation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#30.6">link</A>]</SPAN></H3>
<P>As a longer example, suppose you wanted to parallelize the discrete event simulation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html">Chapter 18</A>. Each participant in the simulation could run as its own actor, thus allowing you to speed up a simulation by using more processors. This section will walk you through the process, using code based on a parallel circuit simulator developed by Philipp Haller.<A id=i-952102166-1></A></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Overall Design</H4>
<P>Most of the design from<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html">Chapter 18</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>works fine for both sequential and parallel discrete event simulation. There are events, and they happen at designated times, processing an event can cause new events to be scheduled, and so forth. Likewise, a circuit simulation can be implemented as a discrete event simulation by making gates and wires participants in the simulation, and changes in the wires the events of the simulation. The one thing that would be nice to change would be to run the events in parallel. How can the design be rearranged to make this happen?</P>
<P>The key idea is to make each simulated object an actor. Each event can then be processed by the actor where most of that event's state lies. For circuit simulation, the update of a gate's output can be processed by the actor corresponding to that gate. With this arrangement, events will naturally be handled in parallel.</P>
<P>In code, it is likely that there will be some common behavior between different simulated objects. It makes sense, then, to define a trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulant</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that can be mixed into to any class to make it a simulated object. Wires, gates, and other simulated objects can mix in this trait.</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Simulant</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Simulant</SPAN>
</PRE>
<P></P>
<P>So far so good, but there are a few design issues to work out, several of which do not have a single, obviously best answer. For this chapter, we present a reasonable choice for each design issue that keeps the code concise. There are other solutions possible, though, and trying them out would make for good practice for anyone wanting experience programming with actors.</P>
<P>The first design issue is to figure out how to make the simulation participants stay synchronized with the simulated time. That is, participant A should not race ahead and process an event at time tick 100 until all other actors have finished with time tick 99. To see why this is essential, imagine for a moment that simulant A is working at time 90 while simulant B is working at time 100. It might be that participant A is about to send a message that changes B's state at time 91. B will not learn this until too late, because it has already processed times 92 to 99. To avoid this problem, the design approach used in this chapter is that no simulant should process events for time<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>until all other simulants are finished with time<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I>-1.</P>
<P>That decision raises a new question,<SPAN class=Apple-converted-space>&nbsp;</SPAN>though: how do simulants know when it's safe to move forward? A straightforward approach is to have a "clock" actor that keeps track of the current time and tells the simulation participants when it is time to move forward. To keep the clock from moving forward before all simulants are ready, the clock can ping actors at carefully chosen times to make sure they have received and processed all messages for the current time tick. There will be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ping</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>messages that the clock sends the simulants, and<SPAN class=code>Pong</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>messages that the simulants send back when they are ready for the clock to move forward.</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ping</SPAN>(time:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Pong</SPAN>(time:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;from:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>)
</PRE>
<P></P>
<P>Note that these messages could be defined as having no fields. However, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>time</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>from</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fields add a little bit of redundancy to the system. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>time</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field holds the time of a ping, and it can be used to connect a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Pong</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with its associated<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ping</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>from</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field is the sender of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Pong</SPAN>. The sender of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ping</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is always the clock, so it does not have a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>from</SPAN>field. All of this information is unnecessary if the program is behaving perfectly, but it can simplify the logic in some places, and it can greatly help in debugging if the program has any errors.</P>
<P>One question that arises is how a simulant knows it has finished with the current time tick. Simulants should not respond to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ping</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>until they have finished all the work for that tick, but how do they know? Maybe another actor has made a request to it that has not yet arrived. Maybe a message one actor has sent another has not been processed yet.</P>
<P>It simplifies the answer to this question to add two constraints. First, assume that simulants never send each other messages directly, but instead only schedule events on each other. Second, they never post events for the current time tick, but only for times at least one tick into the future. These two constraints are significant, but they appear tolerable for a typical simulation. After all, there is normally some non-zero propagation delay whenever two components of a system interact with each other. Further, at worst, time ticks can be made to correspond to shorter time intervals, and information that will be needed in the future can be sent ahead of time.</P>
<P>Other arrangements are possible. Simulants could be allowed to send messages directly to each other. However, if they do so, then there would need to be a more sophisticated mechanism for deciding when it is safe for an actor to send back a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Pong</SPAN>. Each simulant should delay responding to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ping</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>until any other simulants it has made requests to are finished processing those requests. To ensure this property, you would need the simulants to pass each other some extra information. For now, assume that simulants don't communicate with each other except via the simulation's agenda.</P>
<P>Given that decision, there may as well be a single agenda of work items, and that agenda may as well be held by the clock actor. That way, the clock can wait to send out pings until it has sent out requests for all work items at the current time. Actors then know that whenever they receive a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ping</SPAN>, they have already received from the clock all work items that need to happen at the current time tick. It is thus safe when an actor receives a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ping</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to immediately send back a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Pong</SPAN>, because no more work will be arriving during the current time tick. Taking this approach, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Clock</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has the following state:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Clock</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;running&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;currentTime&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;agenda:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[WorkItem]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
  }
</PRE>
<P></P>
<P>The final design issue to work out is how a simulation is set up to begin with. A natural approach is to create the simulation with the clock stopped, add all the simulants, connect them all together, and then start the clock. The subtlety is that you need to be absolutely sure that everything is connected before you start the clock running! Otherwise, some parts of the simulation will start running before they are fully formed.</P>
<P>How do you know when the simulation is fully assembled and ready to start? There are again multiple ways to approach this problem. The simple way adopted in this chapter is to avoid sending message to actors while setting the simulation up. That way, once the last method call returns, you know that the simulation is entirely constructed. The resulting coding pattern is that you use regular method calls to set the simulation up, and you use actor message sends while the simulation is running.</P>
<P>Given the preceding decisions, the rest of the design is straightforward. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>WorkItem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be defined much like in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html">Chapter 18</A>, in that it holds a time and an action. For the parallel simulation, however, the action itself has a different encoding. In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html">Chapter 18</A>, actions are represented as zero-argument functions. For parallel simulation, it is more natural to use a target actor and a message to be sent to that actor:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">WorkItem</SPAN>(time:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;msg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>,&nbsp;target:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>)
</PRE>Likewise, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>afterDelay</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method for scheduling a new work item becomes an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AfterDelay</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>message that can be sent to the clock. Just as with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>WorkItem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class, the zero-argument action function is replaced by a message and a target actor:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AfterDelay</SPAN>(delay:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;msg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>,&nbsp;target:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>)
</PRE>Finally, it will prove useful to have messages requesting the simulation to start and stop:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Start</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Stop</SPAN>
</PRE>
<P></P>
<P>That's it for the overall design. There is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Clock</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class holding a current time and an agenda, and a clock only advances the clock after it has pinged all of its simulants to be sure they are ready. There is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulant</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait for simulation participants, and these communicate with their fellow simulants by sending work items to the clock to add to its agenda. The next section will take a look now at how to implement these core classes.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Implementing the simulation framework</H4>
<P>There are two things that need implementing for the core framework: the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Clock</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulant</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait. Consider the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Clock</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class, first. The necessary state of a clock is as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Clock</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;running&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;currentTime&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;agenda:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[WorkItem]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;allSimulants:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Actor]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;busySimulants:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set[Actor]</SPAN>&nbsp;=&nbsp;Set.empty
</PRE>A clock starts out with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>running</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>set to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>. Once the simulation is fully initialized, the clock will be sent the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Start</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>message and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>running</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will become true. This way, the simulation stays frozen until all of its pieces have been connected together as desired. It also means that, since all of the simulants are also frozen, it is safe to use regular method calls to set things up instead of needing to use actor message sends. 
<P></P>
<P>A clock may as well go ahead and start running as an actor once it is created. This is safe, because it will not actually do anything until it receives a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Start</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>message:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  start()
</PRE>
<P></P>
<P>A clock also keeps track of the current time (<SPAN class=code>currentTime</SPAN>), the list of participants managed by this clock (<SPAN class=code>allSimulants</SPAN>), and the list of participants that are still working on the current time tick (<SPAN class=code>busySimulants</SPAN>). A list is used to hold<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>allSimulants</SPAN>, because it is only iterated through, but a set is used for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>busySimulants</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>because items will be removed from it in an unpredictable order. Once the simulator starts running, it will only advance to a new time when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>busySimulants</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is empty, and whenever it advances the clock, it will set<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>busySimulants</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>allSimulants</SPAN>.</P>
<P>To set up a simulation, there is going to be a need for a method to add new simulants to a clock. It may as well be added right now:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;add(sim:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Simulant</SPAN>)&nbsp;{
  &nbsp;&nbsp;allSimulants&nbsp;=&nbsp;sim&nbsp;::&nbsp;allSimulants
  }
</PRE>
<P></P>
<P>That's the state of a clock. Now look at its activity. Its main loop alternates between two responsibilities: advancing the clock, and responding to messages. Once the clock advances, it can only advance again when at least one message has been received, so it is safe to define the main loop as an alternation between these two activities:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;act()&nbsp;{
  &nbsp;&nbsp;loop&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(running&nbsp;&amp;&amp;&nbsp;busySimulants.isEmpty)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;advance()
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;reactToOneMessage()
  &nbsp;&nbsp;}
  }
</PRE>The advancement of time has a few parts beyond simply incrementing the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>currentTime</SPAN>. First, if the agenda is empty, and the simulation is not just starting, then the simulation should exit. Second, assuming the agenda is non-empty, all work items for time<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>currentTime</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should now take place. Third, all simulants should be put on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>busySimulants</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list and sent<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ping</SPAN>s. The clock will not advance again until all<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ping</SPAN>s have been responded to:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;advance()&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(agenda.isEmpty&nbsp;&amp;&amp;&nbsp;currentTime&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"**&nbsp;Agenda&nbsp;empty.&nbsp;&nbsp;Clock&nbsp;exiting&nbsp;at&nbsp;time&nbsp;"</SPAN>+
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentTime+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"."</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;self&nbsp;!&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Stop</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">return</SPAN>
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;currentTime&nbsp;+=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  &nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Advancing&nbsp;to&nbsp;time&nbsp;"</SPAN>+currentTime)
  <BR>  &nbsp;&nbsp;processCurrentEvents()
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(sim&nbsp;&lt;-&nbsp;allSimulants)
  &nbsp;&nbsp;&nbsp;&nbsp;sim&nbsp;!&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ping</SPAN>(currentTime)
  <BR>  &nbsp;&nbsp;busySimulants&nbsp;=&nbsp;Set.empty&nbsp;++&nbsp;allSimulants
  }
</PRE>Processing the current events is simply a matter of processing all events at the top of the agenda whose time is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>currentTime</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;processCurrentEvents()&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;todoNow&nbsp;=&nbsp;agenda.takeWhile(_.time&nbsp;&lt;=&nbsp;currentTime)
  <BR>  &nbsp;&nbsp;agenda&nbsp;=&nbsp;agenda.drop(todoNow.length)
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">WorkItem</SPAN>(time,&nbsp;msg,&nbsp;target)&nbsp;&lt;-&nbsp;todoNow)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;assert(time&nbsp;==&nbsp;currentTime)
  &nbsp;&nbsp;&nbsp;&nbsp;target&nbsp;!&nbsp;msg
  &nbsp;&nbsp;}
  }
</PRE>There are three steps in this method. First, the items that need to occur at the current time are selected using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>takeWhile</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and saved into the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>todoNow</SPAN>. Second, those items are dropped from the agenda by using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drop</SPAN>. Finally, the items to do now are looped through and sent the target message. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>assert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is included just to guarantee that the scheduler's logic is sound. 
<P></P>
<P>Given this ground work, handling the messages that a clock can receive is straightforward. An<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AfterDelay</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>message causes a new item to be added to the work queue. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Pong</SPAN>causes a simulant to be removed from the list of busy simulants.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Start</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>causes the simulation to begin, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Stop</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>causes the clock to stop:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;reactToOneMessage()&nbsp;{
  &nbsp;&nbsp;react&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AfterDelay</SPAN>(delay,&nbsp;msg,&nbsp;target)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;item&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">WorkItem</SPAN>(currentTime&nbsp;+&nbsp;delay,&nbsp;msg,&nbsp;target)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;agenda&nbsp;=&nbsp;insert(agenda,&nbsp;item)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Pong</SPAN>(time,&nbsp;sim)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(time&nbsp;==&nbsp;currentTime)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(busySimulants&nbsp;contains&nbsp;sim)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;busySimulants&nbsp;-=&nbsp;sim
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Start</SPAN>&nbsp;=&gt;&nbsp;running&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Stop</SPAN>&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(sim&nbsp;&lt;-&nbsp;allSimulants)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sim&nbsp;!&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Stop</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit()
  &nbsp;&nbsp;}
  }
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>insert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, not shown, is exactly like that of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html#lst:simulation">Listing 18.8</A>. It inserts its argument into the agenda while being careful to keep the agenda sorted. 
<P></P>
<P>That's the complete implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Clock</SPAN>. Now consider how to implement<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulant</SPAN>. Boiled down to its essence, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulant</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is any actor that understands and cooperates with the simulation messages<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Stop</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ping</SPAN>. Its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method can therefore be as simple as this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;act()&nbsp;{
  &nbsp;&nbsp;loop&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;react&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Stop</SPAN>&nbsp;=&gt;&nbsp;exit()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ping</SPAN>(time)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(time&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)&nbsp;simStarting()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clock&nbsp;!&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Pong</SPAN>(time,&nbsp;self)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;msg&nbsp;=&gt;&nbsp;handleSimMessage(msg)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  }
</PRE>Whenever a simulant receives<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Stop</SPAN>, it exits. If it receives a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ping</SPAN>, it responds with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Pong</SPAN>. If the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ping</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is for time 1, then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>simStarting</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is called before the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Pong</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is sent back, allowing subclasses to define behavior that should happen when the simulation starts running. Any other message must be interpreted by subclasses, so it defers to an abstract<SPAN class=code>handleSimMessage</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. 
<P></P>
<P>There are two abstract members of a simulant:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>handleSimMessage</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>clock</SPAN>. A simulant must know its clock so that it can reply to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ping</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>messages and schedule new work items. Putting it all together, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulant</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait is as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#lst:simulant-trait">Listing 30.7</A>.<A name=lst:simulant-trait></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Simulant</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;clock:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Clock</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;handleSimMessage(msg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;simStarting()&nbsp;{&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;act()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;react&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Stop</SPAN>&nbsp;=&gt;&nbsp;exit()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ping</SPAN>(time)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(time&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)&nbsp;simStarting()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clock&nbsp;!&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Pong</SPAN>(time,&nbsp;self)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;msg&nbsp;=&gt;&nbsp;handleSimMessage(msg)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;start()
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 30.7 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulant</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait.</H5>
<P>Note that a simulant goes ahead and starts running the moment it is created. This is safe and convenient, because it will not actually do anything until its clock sends it a message, and that should not happen until the simulation starts and the clock receives a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Start</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>message.</P>
<P>That completes the framework for parallel event simulation. Like its sequential cousin in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html">Chapter 18</A>, it takes surprisingly little code.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Implementing a circuit simulation</H4>
<P>Now that the simulation framework is complete, it's time to work on the implementation of circuits. A circuit has a number of wires and gates, which will be simulants, and a clock for managing the simulation. A wire holds a boolean signal&#8212;either high (<SPAN class=code>true</SPAN>) or low (<SPAN class=code>false</SPAN>). Gates are connected to a number of wires, some of which are inputs and others outputs. Gates compute a signal for their output wires based on the state of their input wires.</P>
<P>Since the wire, gates,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>etc.</I>, of a circuit are only used for that particular circuit, their classes can be defined as members of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Circuit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class, just as with the currency objects of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#sec:currencies">Section 20.9</A>. The overall<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Circuit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class will therefore have a number of members:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Circuit</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;clock&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Clock</SPAN>
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;simulation&nbsp;messages</SPAN>
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;delay&nbsp;constants</SPAN>
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Wire&nbsp;and&nbsp;Gate&nbsp;classes&nbsp;and&nbsp;methods</SPAN>
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;misc.&nbsp;utility&nbsp;methods</SPAN>
  }
</PRE>Now look at each of these members, one group at a time. First, there are the simulation messages. Once the simulation starts running, wires and gates can only communicate via message sends, so they will need a message type for each kind of information they want to send each other. There are only two such kinds of information. Gates need to tell their output wires to change state, and wires need to inform the gates they are inputs to whenever their state changes:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SetSignal</SPAN>(sig:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SignalChanged</SPAN>(wire:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;sig:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)
</PRE>Next, there are several delays that must be chosen. Any work item scheduled with the simulation framework&#8212;including propagation of a signal to or from a wire&#8212;must be scheduled at some time in the future. It is unclear what the precise delays should be, so those delays are worth putting into<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s. This way, they can be easily adjusted in the future:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">WireDelay</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">InverterDelay</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">OrGateDelay</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AndGateDelay</SPAN>&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>
</PRE>At this point it is time to look at the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Wire</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Gate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>classes. Consider wires, first. A wire is a simulant that has a current signal state (high or low) and a list of gates that are observing that state. It mixes in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulant</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait, so it also needs to specify a clock to use:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;init:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Simulant</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>(name,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>)&nbsp;}
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>()&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"unnamed"</SPAN>)&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;clock&nbsp;=&nbsp;Circuit.this.clock
  &nbsp;&nbsp;clock.add(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;sigVal&nbsp;=&nbsp;init
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;observers:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Actor]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
</PRE>The class also needs a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>handleSimMessage</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method to specify how it should respond to simulation messages. The only message a wire should receive is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SetSignal</SPAN>, the message for changing a wire's signal. The response should be that if the signal is different from the current signal, the current state changes, and the new signal is propagated:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;handleSimMessage(msg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;{
  &nbsp;&nbsp;msg&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SetSignal</SPAN>(s)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(s&nbsp;!=&nbsp;sigVal)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigVal&nbsp;=&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signalObservers()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  }
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;signalObservers()&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(obs&nbsp;&lt;-&nbsp;observers)
  &nbsp;&nbsp;&nbsp;&nbsp;clock&nbsp;!&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AfterDelay</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">WireDelay</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SignalChanged</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>,&nbsp;sigVal),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obs)
  }
</PRE>The above code shows how<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">changes</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>in a wire's signal are propagated to any gates watching it. It's also important to pass the initial state of a wire to any observing gates. This only needs to be done once, when the simulation starts up. After that, gates can simply store the result of the most recent<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SignalChanged</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>they have received. Sending out the initial signal when the simulation starts is as simple as providing a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>simStarting()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;simStarting()&nbsp;{&nbsp;signalObservers()&nbsp;}
</PRE>There are now just a few more odds and ends about wires. Wires need a method for connecting new gates, and they could use a nice<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;addObserver(obs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>)&nbsp;{
  &nbsp;&nbsp;observers&nbsp;=&nbsp;obs&nbsp;::&nbsp;observers
  }
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Wire("</SPAN>+&nbsp;name&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">")"</SPAN>
</PRE>That is everything you need for wires. Now consider gates, the other major class of objects in a circuit. There are three fundamental gates that would be nice to define:<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">And</EM>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Or</EM>, and<EM style="FONT-STYLE: italic">Not</EM>.<SPAN class=Apple-converted-space>&nbsp;</SPAN>All of these share a lot of behavior, so it is worth defining an abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Gate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class to hold the commonality. 
<P></P>
<P>A difficulty in defining this<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Gate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class is that some gates have two input wires (<EM style="FONT-STYLE: italic">And</EM>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Or</EM>) while others have just one (<EM style="FONT-STYLE: italic">Not</EM>). It would be possible to model this difference explicitly. However, it simplifies the code to think of all gates as having two inputs, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Not</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>gates simply ignore their second input. The ignored second input can be set to some dummy wire that never changes state from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">DummyWire</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"dummy"</SPAN>)
</PRE>Given this trick, the gate class will come together straightforwardly. It mixes in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulant</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait, and its one constructor accepts two input wires and one output wire:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Gate</SPAN>(in1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;in2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;out:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Simulant</SPAN>&nbsp;{
</PRE>There are two abstract members of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Gate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that specific subclasses will have to fill in. The most obvious is that different kinds of gates compute a different function of their inputs. Thus, there should be an abstract method for computing an output based on inputs:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;computeOutput(s1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>,&nbsp;s2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>
</PRE>Second, different kinds of gates have different propagation delays. Thus, the delay of the gate should be an abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;delay:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
</PRE>The delay could be a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN>, but making it a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>encodes the fact that a particular gate's delay should never change. 
<P></P>
<P>Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Gate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>mixes in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Simulant</SPAN>, it is required to specify which clock it is using. As with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Wire</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Gate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should specify the clock of the enclosing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Circuit</SPAN>. For convenience, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Gate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can go ahead and add itself to the clock when it is constructed:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;clock&nbsp;=&nbsp;Circuit.this.clock
  clock.add(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)
</PRE>Similarly, it makes sense to go ahead and connect the gate to the two input wires, using regular method calls:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  in1.addObserver(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)
  in2.addObserver(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)
</PRE>The only local state of a gate is the most recent signal on each of its input wires. This state needs to be stored, because wires only send a signal when the state changes. If one input wire changes, only that one wire's state will be sent to the gate, but the new output will need to be computed from both wires' states:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;s1,&nbsp;s2&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
</PRE>Now look at how gates respond to simulation messages. There is only one message they need to handle, and that's the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SignalChanged</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>message indicating that one of the input wires has changed. When a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SignalChanged</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>arrives, two things need to be done. First, the local notion of the wire states need to be updated according to the change. Second, the new output needs to be computed and then sent out to the output wire with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SetSignal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>message: 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;handleSimMessage(msg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;{
  &nbsp;&nbsp;msg&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SignalChanged</SPAN>(w,&nbsp;sig)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(w&nbsp;==&nbsp;in1)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s1&nbsp;=&nbsp;sig
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(w&nbsp;==&nbsp;in2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s2&nbsp;=&nbsp;sig
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clock&nbsp;!&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AfterDelay</SPAN>(delay,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SetSignal</SPAN>(computeOutput(s1,&nbsp;s2)),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out)
  &nbsp;&nbsp;}
  }
</PRE>Given this abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Gate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class, it is now easy to define specific kinds of gates. As with the sequential simulation in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html">Chapter 18</A>, the gates can be created as side effects of calling some utility methods. All the methods need to do is create a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Gate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and fill in the appropriate delay and output computation. Everything else is common to all gates and is handled in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Gate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;orGate(in1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;in2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;output:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Gate</SPAN>(in1,&nbsp;in2,&nbsp;output)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;delay&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">OrGateDelay</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;computeOutput(s1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>,&nbsp;s2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)&nbsp;=&nbsp;s1&nbsp;||&nbsp;s2&nbsp;
  &nbsp;&nbsp;}
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;andGate(in1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;in2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;output:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Gate</SPAN>(in1,&nbsp;in2,&nbsp;output)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;delay&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AndGateDelay</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;computeOutput(s1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>,&nbsp;s2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)&nbsp;=&nbsp;s1&nbsp;&amp;&amp;&nbsp;s2&nbsp;
  &nbsp;&nbsp;}
</PRE>In the case of<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Not</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>gates, a dummy wire will be specified as the second input. This is an implementation detail from the point of view of a caller creating a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Not</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>gate, so the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>inverter</SPAN>method only takes one input wire instead of two:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;inverter(input:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;output:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Gate</SPAN>(input,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">DummyWire</SPAN>,&nbsp;output)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;delay&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">InverterDelay</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;computeOutput(s1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>,&nbsp;ignored:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)&nbsp;=&nbsp;!s1
  &nbsp;&nbsp;}
</PRE>At this point the library can simulate circuits, but, as described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html">Chapter 18</A>, it is useful to add a wire-probing utility so that you can watch the circuit evolve. Without such a utility, the simulation would have no way to know which wires are worth logging and which are more like implementation details. 
<P>Define a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>probe</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that takes a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Wire</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an argument and then prints out a line of text whenever that wire's signal changes. The method can be implemented by simply making a new simulant that connects itself to a specified wire. This simulant can respond to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SignalChanged</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>messages by printing out the new signal:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;probe(wire:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Simulant</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;clock&nbsp;=&nbsp;Circuit.this.clock
  &nbsp;&nbsp;clock.add(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)
  &nbsp;&nbsp;wire.addObserver(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;handleSimMessage(msg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;msg&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">SignalChanged</SPAN>(w,&nbsp;s)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"signal&nbsp;"</SPAN>+&nbsp;w&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;changed&nbsp;to&nbsp;"</SPAN>+&nbsp;s)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  }
</PRE>
<P></P>
<P>That is the bulk of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Circuit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. Callers should create an instance of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Circuit</SPAN>, create a bunch of wires and gates, call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>probe</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on a few wires of interest, and then start the simulation running. The one piece missing is how the simulation is started, and that can be as simple as sending the clock a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Start</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>message:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;start()&nbsp;{&nbsp;clock&nbsp;!&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Start</SPAN>&nbsp;}
</PRE>
<P></P>
<P><A name=lst:adders></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Adders</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Circuit</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;halfAdder(a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;b:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;c:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;d,&nbsp;e&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orGate(a,&nbsp;b,&nbsp;d)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;andGate(a,&nbsp;b,&nbsp;c)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inverter(c,&nbsp;e)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;andGate(d,&nbsp;e,&nbsp;s)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;fullAdder(a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;b:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;cin:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>,&nbsp;cout:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>)&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;s,&nbsp;c1,&nbsp;c2&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;halfAdder(a,&nbsp;cin,&nbsp;s,&nbsp;c1)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;halfAdder(b,&nbsp;s,&nbsp;sum,&nbsp;c2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orGate(c1,&nbsp;c2,&nbsp;cout)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 30.8 - Adder components.</H5>
<P>More complicated circuit components can be built from methods just as it was explained previously in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html">Chapter 18</A>. For instance<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#lst:adders">Listing 30.8</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows again the half adder and full adder components that were already introduced then. Their implementation stays is the same, but as a small variation they are now packaged in a trait, named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Adders</SPAN>, whereas in<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/stateful-objects.html">Chapter 18</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>they were contained in an abstract class. Because the trait is marked as extending<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Circuit</SPAN>, it can directly access members of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Circuit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Wire</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orGate</SPAN>. Using the trait then looks like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;circuit&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Circuit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Adders</SPAN>
</PRE>This<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>circuit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable holds a circuit that has all of the methods of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Circuit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and all of the methods of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Adders</SPAN>. Note that with this coding pattern, based on a trait instead of a class, you set the stage to provide multiple component sets. Users mix in whichever component sets they plan to use, like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;circuit&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Circuit</SPAN>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Adders</SPAN>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Multiplexers</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">FlipFlops</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">MultiCoreProcessors</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Trying it all out</H4>
<P>That's the whole framework. It includes a simulation framework, a circuit simulation class, and a small library of standard adder components. Here is a simple demo object that uses it:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Demo</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;main(args:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;circuit&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Circuit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Adders</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;circuit._
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;ain&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"ain"</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bin&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"bin"</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;cin&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"cin"</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;sout&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"sout"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;cout&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Wire</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"cout"</SPAN>)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;probe(ain)
  &nbsp;&nbsp;&nbsp;&nbsp;probe(bin)
  &nbsp;&nbsp;&nbsp;&nbsp;probe(cin)
  &nbsp;&nbsp;&nbsp;&nbsp;probe(sout)
  &nbsp;&nbsp;&nbsp;&nbsp;probe(cout)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;fullAdder(ain,&nbsp;bin,&nbsp;cin,&nbsp;sout,&nbsp;cout)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;circuit.start()
  &nbsp;&nbsp;}
  }
</PRE>This example creates a circuit that includes the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Adders</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait. It immediately imports all of the circuit's members, thus allowing easy accesses to methods like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>probe</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>fullAdder</SPAN>. Without the import, it would be necessary to write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>circuit.probe(ain)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of just<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>probe(ain)</SPAN>. 
<P></P>
<P>The example then creates five wires. Three will be used as inputs (<SPAN class=code>ain</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bin</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cin</SPAN>), and two will be used as outputs (<SPAN class=code>sout</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>cout</SPAN>). The three input wires are given arbitrary initial signals of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>. These inputs correspond to adding 1 to 0, with a carry in of 1.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>probe</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method gets applied to all five externally visible wires, so any changes in their state can be observed as the simulation runs. Finally the wires are plugged into a full adder, and the simulation is started. The output of the simulation is as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;1</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;2</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">signal&nbsp;Wire(cout)&nbsp;changed&nbsp;to&nbsp;false</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">signal&nbsp;Wire(cin)&nbsp;changed&nbsp;to&nbsp;true</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">signal&nbsp;Wire(ain)&nbsp;changed&nbsp;to&nbsp;true</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">signal&nbsp;Wire(sout)&nbsp;changed&nbsp;to&nbsp;false</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">signal&nbsp;Wire(bin)&nbsp;changed&nbsp;to&nbsp;false</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;3</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;4</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;5</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;6</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;7</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;8</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;9</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;10</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">signal&nbsp;Wire(cout)&nbsp;changed&nbsp;to&nbsp;true</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;11</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;12</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;13</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;14</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;15</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;16</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;17</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;18</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">signal&nbsp;Wire(sout)&nbsp;changed&nbsp;to&nbsp;true</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;19</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;20</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">Advancing&nbsp;to&nbsp;time&nbsp;21</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">signal&nbsp;Wire(sout)&nbsp;changed&nbsp;to&nbsp;false</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">**&nbsp;Agenda&nbsp;empty.&nbsp;&nbsp;Clock&nbsp;exiting&nbsp;at&nbsp;time&nbsp;21.</SPAN>
</PRE>As expected, with inputs of 1, 0, and 1 (<SPAN class=code>true</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>), the outputs are a carry of 1 and sum of 0 (<SPAN class=code>cout</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sout</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>). 
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=30.7></A>30.7 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html#30.7">link</A>]</SPAN></H3>
<P>Concurrent programming gives you great power. It lets you simplify your code, and it lets you take advantage of multiple processors. It is therefore unfortunate that the most widely used concurrency primitives, threads, locks, and monitors, are such a minefield of deadlocks and race conditions.</P>
<P>The actors style provides a way out of the minefield, letting you write concurrent programs without having such a great risk of deadlocks and race conditions. This chapter has introduced several fundamental constructs for working with actors in Scala, including how to create actors, how to send and receive messages, and how to conserve threads with<SPAN class=code>react</SPAN>, among other nuts and bolts. It then showed you how to use these constructs as part of a general actors style.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 30:</H4>
<P><A name=footnote30-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>As described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#sec:partial-functions">Section 15.7</A>, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">partial function</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>literal is expressed as a series of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>alternatives or "cases." It looks like a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression without the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword.</P>
<P><A name=footnote30-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Behind the scenes,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will throw an exception after its done.</P>
<P><A name=footnote30-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Another benefit is that a message send ensures the message object is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">safely published</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>to other threads, as described in Goetz,<A id=i348023279-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><I>et. al.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Java Concurrency in Practice</EM>, p. 49.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#goetz:java-con-in-prac">goetz:java-con-in-prac</A><A id=i-374110760-1></A></P>
<P><A name=footnote30-4>[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>When using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN>, different messages could potentially be handled by different threads, but if so they will be handled sequentially and with sufficient synchronization to allow you to program under the simplifying assumption that each<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>act</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is confined to a single thread.</P></DIV>