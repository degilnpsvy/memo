<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 31 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Combinator Parsing</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>Occasionally, you may need to process a small, special-purpose language.<A id=i1395246279-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, you may need to read configuration files for your software, and you want to make them easier to modify by hand than XML. Alternatively, maybe you want to support an input language in your program, such as search terms with boolean operators (computer, find me a movie "with `space ships' and without `love stories"'). Whatever the reason, you are going to need a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">parser</EM>.<A id=i-792967116-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You need a way to convert the input language into some data structure your software can process.</P>
<P>Essentially, you have only a few choices. One choice is to roll your own parser (and lexical analyzer). If you are not an expert, this is hard. If you are an expert, it is still time consuming.</P>
<P>An alternative choice is to use a parser generator.<A id=i-1495136757-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>There exist quite a few of these generators. Some of the better known are Yacc and Bison for parsers written in C and ANTLR for parsers written in Java.<A id=i-606539021-1></A><A id=i2747784-1></A><A id=i64194507-1></A><A id=i62435725-1></A><A id=i-679763866-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You'll probably also need a scanner generator such as Lex, Flex, or JFlex to go with it.<A id=i76287-1></A><A id=i2192409-1></A><A id=i70532963-1></A><A id=i-693168286-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This might be the best solution, except for a couple of inconveniences. You need to learn new tools, including their&#8212;sometimes obscure&#8212;error messages. You also need to figure out how to connect the output of these tools to your program. This might limit the choice of your programming language, and complicate your tool chain.</P>
<P>This chapter presents a third alternative. Instead of using the standalone domain specific language of a parser generator, you will use an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">internal domain specific language</SPAN>, or internal DSL for short.<A id=i-1137790491-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The internal DSL will consist of a library of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">parser combinators</SPAN>&#8212;functions and operators defined in Scala that will serve as building blocks for parsers.<A id=i-2095840458-1></A>These building blocks will map one to one to the constructions of a context-free grammar, to make them easy to understand.<A id=i-581215934-1></A></P>
<P>This chapter introduces only one language feature that was not explained before:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>aliasing, in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#sec:this-aliasing">Section 31.6</A>. The chapter does, however, heavily use several other features that were explained in previous chapters. Among others, parameterized types, abstract types, functions as objects, operator overloading, by-name parameters, and implicit conversions all play important roles. The chapter shows how these language elements can be combined in the design of a very high-level library.</P>
<P>The concepts explained in this chapter tend to be a bit more advanced than previous chapters. If you have a good grounding in compiler construction, you'll profit from it reading this chapter, because it will help you put things better in perspective. However, the only prerequisite for understanding this chapter is that you know about regular and context-free grammars. If you don't, the material in this chapter can also safely be skipped.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=31.1></A>31.1 Example: Arithmetic expressions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#31.1">link</A>]</SPAN></H3>
<P><A name=sec:arith></A></P>
<P>We'll start with an example. Say you want to construct a parser for arithmetic expressions consisting of floating-point<SPAN class=Apple-converted-space>&nbsp;</SPAN>numbers, parentheses, and the binary operators<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>/</SPAN>. The first step is always to write down a grammar for the language to be parsed. Here's the grammar for arithmetic expressions:</P>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="">
<TD><SPAN style="FONT-STYLE: italic">expr</SPAN></TD>
<TD>::=</TD>
<TD><SPAN style="FONT-STYLE: italic">term</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;\{<SPAN class=code>"+"</SPAN>&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">term</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;|&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"-"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">term</SPAN>\}.</TD></TR>
<TR class="">
<TD><SPAN style="FONT-STYLE: italic">term</SPAN></TD>
<TD>::=</TD>
<TD><SPAN style="FONT-STYLE: italic">factor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;\{<SPAN class=code>"*"</SPAN>&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">factor</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;|&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"/"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;<SPAN style="FONT-STYLE: italic">factor</SPAN>\}.</TD></TR>
<TR class="">
<TD><SPAN style="FONT-STYLE: italic">factor</SPAN></TD>
<TD>::=</TD>
<TD><SPAN style="FONT-STYLE: italic">floatingPointNumber</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;|&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"("</SPAN>&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;<SPAN class=code>")"</SPAN>.</TD></TR></TBODY></TABLE></DIV>
<P>Here, | denotes alternative productions, and \{ ... \<I>hspace</I>{-1.5<I>pt</I>}\} denotes repetition (zero or more times). And although there's no use of it in this example, [ ...<SPAN class=Apple-converted-space>&nbsp;</SPAN>] denotes an optional occurrence.</P>
<P>This context-free grammar defines formally a language of arithmetic expressions. Every expression (represented by<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">expr</EM>) is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">term</EM>, which can be followed by a sequence of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN>operators and further<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">term</EM>s. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">term</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">factor</EM>, possibly followed by a sequence of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>/</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operators and further<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">factor</EM>s. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">factor</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is either a numeric literal or an expression in parentheses. Note that the grammar already encodes the relative precedence of operators. For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>binds more tightly than<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>, because a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation gives a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">term</EM>, whereas a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation gives an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">expr</EM>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">expr</EM>s can contain<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">term</EM>s but a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">term</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>can contain an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">expr</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>only when the latter is enclosed in parentheses.</P>
<P>Now that you have defined the grammar, what's next? If you use Scala's combinator parsers, you are basically done! You only need to perform some systematic text replacements and wrap the parser in a class, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:expression-parser">Listing 31.1</A>:<A name=lst:expression-parser></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.util.parsing.combinator._
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Arith</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">JavaTokenParsers</SPAN>&nbsp;{&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;expr:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=&nbsp;term<SPAN style="FONT-SIZE: large">~</SPAN>rep(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>term&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>term)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;term:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=&nbsp;factor<SPAN style="FONT-SIZE: large">~</SPAN>rep(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"*"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>factor&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"/"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>factor)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;factor:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=&nbsp;floatingPointNumber&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"("</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>expr<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">")"</SPAN>
  }
</PRE>
<H5>Listing 31.1 - An arithmetic expression parser.</H5>
<P>The parsers for arithmetic expressions are contained in a class that inherits from the trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>JavaTokenParsers</SPAN>.<A id=i-585361525-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This trait provides the basic machinery for writing a parser and also provides some primitive parsers that recognize some word classes: identifiers, string literals and numbers. In the example in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:expression-parser">Listing 31.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>you need only the primitive<SPAN class=code>floatingPointNumber</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser, which is inherited from this trait.<A id=i1891349662-1></A><A id=i-63210921-1></A></P>
<P>The three definitions in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Arith</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>represent the productions for arithmetic expressions. As you can see, they follow very closely the productions of the context-free grammar. In fact, you could generate this part automatically from the context-free grammar, by performing a number of simple text replacements:</P>
<OL>
<LI>Every production becomes a method, so you need to prefix it with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN>. 
<LI>The result type of each method is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser[Any]</SPAN>, so you need to change the ::= symbol to "<SPAN class=code>:</SPAN>&nbsp;<SPAN class=code>Parser[Any]</SPAN>&nbsp;<SPAN class=code>=</SPAN>". You'll find out later in this chapter what the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser[Any]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>signifies, and also how to make it more precise. 
<LI>In the grammar, sequential composition was implicit, but in the program it is expressed by an explicit operator:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>. So you need to insert a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>between every two consecutive symbols of a production. In the example in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:expression-parser">Listing 31.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>we chose not to write any spaces around the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator. That way, the parser code keeps closely to the visual appearance of the grammar&#8212;it just replaces spaces by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>characters. 
<LI>Repetition is expressed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rep(</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>...<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of \{ ...<SPAN class=Apple-converted-space>&nbsp;</SPAN>\}. Analogously (though not shown in the example), option is expressed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>opt(</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>...<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of [ ...<SPAN class=Apple-converted-space>&nbsp;</SPAN>]. 
<LI>The period (.) at the end of each production is omitted&#8212;you can, however, write a semicolon (<SPAN class=code>;</SPAN>) if you prefer.</LI></OL>
<P>That's all there is to it. The resulting class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Arith</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defines three parsers,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>term</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>factor</SPAN>, which can be used to parse arithmetic expressions and their parts.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=31.2></A>31.2 Running your parser<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#31.2">link</A>]</SPAN></H3>
<P>You can exercise your parser with the following small program:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ParseExpr</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Arith</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;main(args:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"input&nbsp;:&nbsp;"</SPAN>+&nbsp;args(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>))
  &nbsp;&nbsp;&nbsp;&nbsp;println(parseAll(expr,&nbsp;args(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)))
  &nbsp;&nbsp;}
  }
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ParseExpr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object defines a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>main</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that parses the first command-line argument passed to it. It prints the original input argument, and then prints its parsed version. Parsing is done by the expression:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  parseAll(expr,&nbsp;input)
</PRE>This expression applies the parser,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr</SPAN>, to the given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>input</SPAN>. It expects that all of the input matches,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, that there are no characters trailing a parsed expression. There's also a method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>parse</SPAN>, which allows you to parse an input prefix, leaving some remainder unread. 
<P></P>
<P>You can run the arithmetic parser with the following command:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;ParseExpr&nbsp;"2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7)"
  <SPAN class=output style="COLOR: rgb(90,0,0)">input:&nbsp;2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">[1.12]&nbsp;parsed:&nbsp;((2<SPAN style="FONT-SIZE: large">~</SPAN>List((*<SPAN style="FONT-SIZE: large">~</SPAN>(((<SPAN style="FONT-SIZE: large">~</SPAN>((3<SPAN style="FONT-SIZE: large">~</SPAN>List())<SPAN style="FONT-SIZE: large">~</SPAN>List((+</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)"><SPAN style="FONT-SIZE: large">~</SPAN>(7<SPAN style="FONT-SIZE: large">~</SPAN>List())))))<SPAN style="FONT-SIZE: large">~</SPAN>)))))<SPAN style="FONT-SIZE: large">~</SPAN>List())</SPAN>
</PRE>The output tells you that the parser successfully analyzed the input string up to position [1.12]. That means the first line and the twelfth column&#8212;in other words, the whole input string&#8212;was parsed. Disregard for the moment the result after "<SPAN class=code>parsed:</SPAN>". It is not very useful, and you will find out later how to get more specific parser results. 
<P></P>
<P>You can also try to introduce some input string that is not a legal expression. For instance, you could write one closing parenthesis too many:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;ParseExpr&nbsp;"2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7))"
  <SPAN class=output style="COLOR: rgb(90,0,0)">input:&nbsp;2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7))</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">[1.12]&nbsp;failure:&nbsp;`-'&nbsp;expected&nbsp;but&nbsp;`)'&nbsp;found</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)"></SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">2&nbsp;*&nbsp;(3&nbsp;+&nbsp;7))</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>Here, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser parsed everything until the final closing parenthesis, which does not form part of the arithmetic expression. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>parseAll</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method then issued an error message, which said that it expected a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator at the point of the closing parenthesis. You'll find out later in this chapter why it produced this particular error message, and how you can improve it.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=31.3></A>31.3 Basic regular expression parsers<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#31.3">link</A>]</SPAN></H3>
<P>The parser for arithmetic expressions made use of another parser, named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>floatingPointNumber</SPAN>. This parser, which was inherited from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Arith</SPAN>'s supertrait,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>JavaTokenParsers</SPAN>, recognizes a floating point number in the format of Java. But what do you do if you need to parse numbers in a format that's a bit different from Java's? In this situation, you can use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">regular expression parser</EM>.</P>
<P>The idea is that you can use any regular expression as a parser.<A id=i-2139156663-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The regular expression parses all strings that it can match. Its result is the parsed string. For instance, the regular expression parser shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:regular-expression-parser">Listing 31.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>describes Java's identifiers:<A name=lst:regular-expression-parser></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">MyParsers</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RegexParsers</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;ident:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[String]</SPAN>&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"""[a-zA-Z_]\w*"""</SPAN>.r
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 31.2 - A regular expression parser for Java identifiers.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MyParsers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:regular-expression-parser">Listing 31.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>inherits from trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RegexParsers</SPAN>, whereas<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Arith</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>inherited from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>JavaTokenParsers</SPAN>.<A id=i519257659-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Scala's parsing combinators are arranged in a hierarchy of traits, which are all contained in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.util.parsing.combinator</SPAN>. The top-level trait is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parsers</SPAN>, which defines a very general parsing framework for all sorts of input. One level below is trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RegexParsers</SPAN>, which requires that the input is a sequence of characters and provides for regular expression parsing. Even more specialized is trait<SPAN class=code>JavaTokenParsers</SPAN>, which implements parsers for basic classes of words (or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">tokens</SPAN>) as they are defined in Java.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=31.4></A>31.4 Another example: JSON<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#31.4">link</A>]</SPAN></H3>
<P>JSON, the JavaScript Object Notation, is a popular data interchange format.<A id=i2286824-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In this section, we'll show you how to write a parser for it. Here's a grammar that describes the syntax of JSON:</P>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="">
<TD><SPAN style="FONT-STYLE: italic">value</SPAN></TD>
<TD>::=</TD>
<TD><SPAN style="FONT-STYLE: italic">obj</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;|&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">arr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;|&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">stringLiteral</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;|</TD></TR>
<TR class="">
<TD></TD>
<TD></TD>
<TD><SPAN style="FONT-STYLE: italic">floatingPointNumber</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;|</TD></TR>
<TR class="">
<TD></TD>
<TD></TD>
<TD><SPAN class=code>"null"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;|&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"true"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;|&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"false"</SPAN>.</TD></TR>
<TR class="">
<TD><SPAN style="FONT-STYLE: italic">obj</SPAN></TD>
<TD>::=</TD>
<TD><SPAN class=code>"{"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;[<SPAN style="FONT-STYLE: italic">members</SPAN>]&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"}"</SPAN>.</TD></TR>
<TR class="">
<TD><SPAN style="FONT-STYLE: italic">arr</SPAN></TD>
<TD>::=</TD>
<TD><SPAN class=code>"["</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;[<SPAN style="FONT-STYLE: italic">values</SPAN>]&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"]"</SPAN>.</TD></TR>
<TR class="">
<TD><SPAN style="FONT-STYLE: italic">members</SPAN></TD>
<TD>::=</TD>
<TD><SPAN style="FONT-STYLE: italic">member</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;\{<SPAN class=code>","</SPAN>&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">member</SPAN>\}.</TD></TR>
<TR class="">
<TD><SPAN style="FONT-STYLE: italic">member</SPAN></TD>
<TD>::=</TD>
<TD><SPAN style="FONT-STYLE: italic">stringLiteral</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;<SPAN class=code>":"</SPAN>&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">value</SPAN>.</TD></TR>
<TR class="">
<TD><SPAN style="FONT-STYLE: italic">values</SPAN></TD>
<TD>::=</TD>
<TD><SPAN style="FONT-STYLE: italic">value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;\{<SPAN class=code>","</SPAN>&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">value</SPAN>\}.</TD></TR></TBODY></TABLE></DIV>
<P>A JSON value is an object, array, string, number, or one of the three reserved words<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>. A JSON object is a (possibly empty) sequence of members separated by commas and enclosed in braces. Each member is a string/value pair where the string and the value are separated by a colon. Finally, a JSON array is a sequence of values separated by commas and enclosed in square brackets. As an example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:JSON-data">Listing 31.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains an address-book formatted as a JSON object.<A name=lst:JSON-data></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"address&nbsp;book"</SPAN>:&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"name"</SPAN>:&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"John&nbsp;Smith"</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"address"</SPAN>:&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"street"</SPAN>:&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"10&nbsp;Market&nbsp;Street"</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"city"</SPAN>&nbsp;&nbsp;:&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"San&nbsp;Francisco,&nbsp;CA"</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"zip"</SPAN>&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">94111</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"phone&nbsp;numbers"</SPAN>:&nbsp;[
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"408&nbsp;338-4238"</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"408&nbsp;111-6892"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 31.3 - Data in JSON format.</H5>
<P>Parsing such data is straightforward when using Scala's parser combinators. The complete parser is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:JSON-parser">Listing 31.4</A>. This parser follows the same structure as the arithmetic expression parser. It is again a straightforward mapping of the productions of the JSON grammar. The productions use one shortcut that simplifies the grammar: The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>repsep</SPAN>combinator parses a (possibly empty) sequence of terms that are separated by a given separator string. For instance, in the example in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:JSON-parser">Listing 31.4</A>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>repsep(member,</SPAN>&nbsp;<SPAN class=code>",")</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parses a comma-separated sequence of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>member</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>terms. Otherwise, the productions in the parser correspond exactly to the productions in the grammar, as was the case for the arithmetic expression parsers.<A name=lst:JSON-parser></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.util.parsing.combinator._
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;JSON&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">JavaTokenParsers</SPAN>&nbsp;{&nbsp;&nbsp;&nbsp;
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;value&nbsp;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=&nbsp;obj&nbsp;|&nbsp;arr&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringLiteral&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;floatingPointNumber&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"null"</SPAN>&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"true"</SPAN>&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"false"</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;obj&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"{"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>repsep(member,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">","</SPAN>)<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"}"</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;arr&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"["</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>repsep(value,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">","</SPAN>)<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"]"</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;member:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=&nbsp;stringLiteral<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">":"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>value
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 31.4 - A simple JSON parser.</H5>
<P>To try out the JSON parsers, we'll change the framework a bit, so that the parser operates on a file instead of on the command line:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;java.io.FileReader
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ParseJSON</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;JSON&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;main(args:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;reader&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">FileReader</SPAN>(args(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>))
  &nbsp;&nbsp;&nbsp;&nbsp;println(parseAll(value,&nbsp;reader))
  &nbsp;&nbsp;}
  }
</PRE>
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>main</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in this program first creates a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>FileReader</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object.<A id=i1651665815-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It then parses the characters returned by that reader according to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>production of the JSON grammar. Note that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>parseAll</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>parse</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>exist in overloaded variants: both can take a character sequence or alternatively an input reader as second argument.</P>
<P>If you store the "address book" object shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:JSON-data">Listing 31.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>into a file named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>address-book.json</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and run the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ParseJSON</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>program on it, you should get:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;ParseJSON&nbsp;address-book.json
  <SPAN class=output style="COLOR: rgb(90,0,0)">[13.4]&nbsp;parsed:&nbsp;(({<SPAN style="FONT-SIZE: large">~</SPAN>List((("address&nbsp;book"<SPAN style="FONT-SIZE: large">~</SPAN>:)<SPAN style="FONT-SIZE: large">~</SPAN>(({<SPAN style="FONT-SIZE: large">~</SPAN>List(((</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">"name"<SPAN style="FONT-SIZE: large">~</SPAN>:)<SPAN style="FONT-SIZE: large">~</SPAN>"John&nbsp;Smith"),&nbsp;(("address"<SPAN style="FONT-SIZE: large">~</SPAN>:)<SPAN style="FONT-SIZE: large">~</SPAN>(({<SPAN style="FONT-SIZE: large">~</SPAN>List(((</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">"street"<SPAN style="FONT-SIZE: large">~</SPAN>:)<SPAN style="FONT-SIZE: large">~</SPAN>"10&nbsp;Market&nbsp;Street"),&nbsp;(("city"<SPAN style="FONT-SIZE: large">~</SPAN>:)<SPAN style="FONT-SIZE: large">~</SPAN>"San&nbsp;Francisco</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">,CA"),&nbsp;(("zip"<SPAN style="FONT-SIZE: large">~</SPAN>:)<SPAN style="FONT-SIZE: large">~</SPAN>94111)))<SPAN style="FONT-SIZE: large">~</SPAN>})),&nbsp;(("phone&nbsp;numbers"<SPAN style="FONT-SIZE: large">~</SPAN>:)<SPAN style="FONT-SIZE: large">~</SPAN>(([<SPAN style="FONT-SIZE: large">~</SPAN></SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">List("408&nbsp;338-4238",&nbsp;"408&nbsp;111-6892"))<SPAN style="FONT-SIZE: large">~</SPAN>]))))<SPAN style="FONT-SIZE: large">~</SPAN>}))))<SPAN style="FONT-SIZE: large">~</SPAN>})</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=31.5></A>31.5 Parser output<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#31.5">link</A>]</SPAN></H3>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ParseJSON</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>program successfully parsed the JSON address book. However, the parser output looks strange. It seems to be a sequence composed of bits and pieces of the input glued together with lists and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>combinations. This output is not very useful. It is less readable for humans than the input, but it is also too disorganized to be easily analyzable by a computer. It's time to do something about this.</P>
<P>To figure out what to do, you need to know first what the individual parsers in the combinator frameworks return as a result (provided they succeed in parsing the input). Here are the rules:</P>
<OL>
<LI>Each parser written as a string (such as:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"{"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>":"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"null"</SPAN>) returns the parsed string itself. 
<LI>Regular expression parsers such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"""[a-zA-Z_]\w*""".r</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>also return the parsed string itself. The same holds for regular expression parsers such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stringLiteral</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=code>floatingPointNumber</SPAN>, which are inherited from trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>JavaTokenParsers</SPAN>.<A id=i-826062925-1></A><A id=i1891349662-2></A> 
<LI>A sequential composition<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P<SPAN style="FONT-SIZE: large">~</SPAN>Q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns the results of both<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Q</SPAN>. These results are returned in an instance of a case class that is also written<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>. So if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"true"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=code>Q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"?"</SPAN>, then the sequential composition<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P<SPAN style="FONT-SIZE: large">~</SPAN>Q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN>("true",</SPAN>&nbsp;<SPAN class=code>"?")</SPAN>, which prints as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(true<SPAN style="FONT-SIZE: large">~</SPAN>?)</SPAN>. 
<LI>An alternative composition<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>&nbsp;<SPAN class=code>|</SPAN>&nbsp;<SPAN class=code>Q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns the result of either<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Q</SPAN>, whichever one succeeds. 
<LI>A repetition<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rep(P)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>repsep(P,</SPAN>&nbsp;<SPAN class=code>separator)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns a list of the results of all runs of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>. 
<LI>An option<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>opt(P)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns an instance of Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Option</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type. It returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some(R)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>succeeds with result<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>R</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>None</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fails.</LI></OL>With these rules you can now deduce<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">why</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the parser output appeared as it did in the previous examples. However, the output is still not very convenient. It would be much better to map a JSON object into an internal Scala representation that represents the meaning of the JSON value. A more natural representation would be as follows: 
<UL>
<LI>A JSON object is represented as a Scala map of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map[String,</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any]</SPAN>. Every member is represented as a key/value binding in the map. 
<LI>A JSON array is represented as a Scala list of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Any]</SPAN>. 
<LI>A JSON string is represented as a Scala<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>. 
<LI>A JSON numeric literal is represented as a Scala<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>. 
<LI>The values<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are represented in as the Scala values with the same names.</LI></UL>To produce to this representation, you need to make use of one more combination form for parsers:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>^^</SPAN>.<A id=i1109178044-1></A> 
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>^^</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">transforms</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the result of a parser. Expressions using this operator have the form<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>&nbsp;<SPAN class=code>^^</SPAN>&nbsp;<SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a parser and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a function.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>&nbsp;<SPAN class=code>^^</SPAN>&nbsp;<SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parses the same sentences as just<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>. Whenever<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns with some result<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>R</SPAN>, the result of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>&nbsp;<SPAN class=code>^^</SPAN>&nbsp;<SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f(R)</SPAN>.</P>
<P>As an example, here is a parser that parses a floating point number and converts it to a Scala value of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  floatingPointNumber&nbsp;^^&nbsp;(_.toDouble)
</PRE>And here is a parser that parses the string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"true"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and returns Scala's boolean<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>value:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"true"</SPAN>&nbsp;^^&nbsp;(x&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>)
</PRE>Now for more advanced transformations. Here's a new version of a parser for JSON objects that returns a Scala<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;obj:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Map[String, Any]]</SPAN>&nbsp;=&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Can&nbsp;be&nbsp;improved</SPAN>
  &nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"{"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>repsep(member,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">","</SPAN>)<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"}"</SPAN>&nbsp;^^&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"{"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>ms<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"}"</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>()&nbsp;++&nbsp;ms&nbsp;}
</PRE>Remember that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator produces as its result an instance of a case class with the same name:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>. Here's a definition of that class&#8212;it's an inner class of trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parsers</SPAN>:<A id=i-1259402311-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN>[+A,&nbsp;+B](x:&nbsp;A,&nbsp;y:&nbsp;B)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"("</SPAN>+&nbsp;x&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"<SPAN style="FONT-SIZE: large">~</SPAN>"</SPAN>+&nbsp;y&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">")"</SPAN>
  }
</PRE>The name of the class is intentionally the same as the name of the sequence combinator method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>. That way, you can match parser results with patterns that follow the same structure as the parsers themselves. For instance, the pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"{"<SPAN style="FONT-SIZE: large">~</SPAN>ms<SPAN style="FONT-SIZE: large">~</SPAN>"}"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>matches a result string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"{"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>followed by a result variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ms</SPAN>, which is followed in turn by a result string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"}"</SPAN>. This pattern corresponds exactly to what is returned by the parser on the left of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>^^</SPAN>. In its desugared versions where the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator comes first, the same pattern reads<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN>(<SPAN style="FONT-SIZE: large">~</SPAN>("{",</SPAN>&nbsp;<SPAN class=code>ms),</SPAN>&nbsp;<SPAN class=code>"}")</SPAN>, but this is much less legible. 
<P></P>
<P>The purpose of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"{"<SPAN style="FONT-SIZE: large">~</SPAN>ms<SPAN style="FONT-SIZE: large">~</SPAN>"}"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>pattern is to strip off the braces so that you can get at the list of members resulting from the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>repsep(member,</SPAN>&nbsp;<SPAN class=code>",")</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser. In cases like these there is also an alternative that avoids producing unnecessary parser results that are immediately discarded by the pattern match. The alternative makes use of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN>&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;<SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser combinators.<A id=i1302279396-1></A><A id=i1234233109-1></A><A id=i-1674511423-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Both express sequential composition like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>, but<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN>&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keeps only the result of its right operand, whereas<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;<SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keeps only the result of its left operand. Using these combinators, the JSON object parser can be expressed more succinctly:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;obj:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Map[String, Any]]</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"{"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>&gt;&nbsp;repsep(member,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">","</SPAN>)&nbsp;&lt;<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"}"</SPAN>&nbsp;^^&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>()&nbsp;++&nbsp;_)
</PRE>
<P></P>
<P><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:JSON1">Listing 31.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a full JSON parser that returns meaningful results. If you run this parser on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>address-book.json</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>file, you will get the following result (after adding some newlines and indentation):</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;JSON1Test&nbsp;address-book.json
  [14.1]&nbsp;parsed:&nbsp;Map(
  &nbsp;&nbsp;address&nbsp;book&nbsp;-&gt;&nbsp;Map(
  &nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;-&gt;&nbsp;John&nbsp;Smith,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;address&nbsp;-&gt;&nbsp;Map(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;street&nbsp;-&gt;&nbsp;10&nbsp;Market&nbsp;Street,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;city&nbsp;-&gt;&nbsp;San&nbsp;Francisco,&nbsp;CA,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zip&nbsp;-&gt;&nbsp;94111),&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;phone&nbsp;numbers&nbsp;-&gt;&nbsp;List(408&nbsp;338-4238,&nbsp;408&nbsp;111-6892)
  &nbsp;&nbsp;)
  )
</PRE>
<P></P>
<P>This is all you need to know in order to get started writing your own parsers. As an aide to memory,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#table:parser-combinators">Table 31.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>lists the parser combinators that were discussed so far.</P>
<P><A name=lst:JSON1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.util.parsing.combinator._
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;JSON1&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">JavaTokenParsers</SPAN>&nbsp;{&nbsp;&nbsp;&nbsp;
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;obj:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Map[String, Any]]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"{"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>&gt;&nbsp;repsep(member,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">","</SPAN>)&nbsp;&lt;<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"}"</SPAN>&nbsp;^^&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>()&nbsp;++&nbsp;_)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;arr:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[List[Any]]</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"["</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>&gt;&nbsp;repsep(value,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">","</SPAN>)&nbsp;&lt;<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"]"</SPAN>&nbsp;
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;member:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[(String, Any)]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringLiteral<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">":"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>value&nbsp;^^&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;name<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">":"</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>value&nbsp;=&gt;&nbsp;(name,&nbsp;value)&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;value:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;arr&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;stringLiteral
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;floatingPointNumber&nbsp;^^&nbsp;(_.toDouble)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"null"</SPAN>&nbsp;&nbsp;^^&nbsp;(x&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">null</SPAN>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"true"</SPAN>&nbsp;&nbsp;^^&nbsp;(x&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"false"</SPAN>&nbsp;^^&nbsp;(x&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 31.5 - A full JSON parser that returns meaningful results.</H5>
<P><A name=table:parser-combinators></A></P>
<H5>Table 31.1 - Summary of parser combinators</H5>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN class=code><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"..."</SPAN></SPAN></TD>
<TD style="BORDER-TOP: black thin solid">literal</TD></TR>
<TR class="">
<TD><SPAN class=code><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"..."</SPAN>.r</SPAN></TD>
<TD>regular expression</TD></TR>
<TR class="">
<TD><SPAN class=code>P<SPAN style="FONT-SIZE: large">~</SPAN>Q</SPAN></TD>
<TD>sequential composition</TD></TR>
<TR class="">
<TD><SPAN class=code>P</SPAN>&nbsp;<SPAN class=code>&lt;<SPAN style="FONT-SIZE: large">~</SPAN></SPAN>&nbsp;<SPAN class=code>Q,</SPAN>&nbsp;<SPAN class=code>P</SPAN>&nbsp;<SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN>&gt;</SPAN>&nbsp;<SPAN class=code>Q</SPAN></TD>
<TD>sequential composition; keep left/right only</TD></TR>
<TR class="">
<TD><SPAN class=code>P</SPAN>&nbsp;<SPAN class=code>|</SPAN>&nbsp;<SPAN class=code>Q</SPAN></TD>
<TD>alternative</TD></TR>
<TR class="">
<TD><SPAN class=code>opt(P)</SPAN></TD>
<TD>option</TD></TR>
<TR class="">
<TD><SPAN class=code>rep(P)</SPAN></TD>
<TD>repetition</TD></TR>
<TR class="">
<TD><SPAN class=code>repsep(P,</SPAN>&nbsp;<SPAN class=code>Q)</SPAN></TD>
<TD>interleaved repetition</TD></TR>
<TR class=bottomline style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TD style="BORDER-BOTTOM: black thin solid"><SPAN class=code>P</SPAN>&nbsp;<SPAN class=code>^^</SPAN>&nbsp;<SPAN class=code>f</SPAN></TD>
<TD style="BORDER-BOTTOM: black thin solid">result conversion</TD></TR></TBODY></TABLE></DIV>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Turning off semicolon inference</H3>
<P>Note that the body of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:JSON1">Listing 31.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is enclosed in parentheses. This is a little trick to disable semicolon inference in parser expressions. You saw in<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/classes-and-objects.html#sec:semicolon-inf">Section 4.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that Scala assumes there's a semicolon between any two lines that can be separate statements<A id=i-615670524-1></A><A id=i561868586-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>syntactically, unless the first line ends in an infix operator, or the two lines are enclosed in parentheses or square brackets. Now, you could have written the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>|</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator at the end of the each alternative instead of at the beginning of the following one, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;value:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;obj&nbsp;|
  &nbsp;&nbsp;arr&nbsp;|
  &nbsp;&nbsp;stringLiteral&nbsp;|
  &nbsp;&nbsp;...
</PRE>In that case, no parentheses around the body of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser would have been required. However, some people prefer to see the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>|</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator at the beginning of the second alternative rather than at the end of the first. Normally, this would lead to an unwanted semicolon between the two lines, like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;obj;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;semicolon&nbsp;implicitly&nbsp;inserted</SPAN>
  |&nbsp;arr
</PRE>The semicolon changes the structure of the code, causing it to fail compilation. Putting the whole expression in parentheses avoids the semicolon and makes the code compile correctly. 
<P></P></DIV>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Symbolic versus alphanumeric names</H4>
<P>Many of the parser combinators in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#table:parser-combinators">Table 31.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>use symbolic names. This has both advantages and disadvantages. On the minus side, symbolic names take time to learn. Users who are unfamiliar with Scala's combinator parsing libraries are probably mystified what<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN>&gt;</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>^^</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>mean. On the plus side, symbolic names are short, and can be chosen to have the "right" precedences and associativities. For instance, the parser combinators<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>^^</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>|</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are chosen intentionally in decreasing order of precedence. A typical grammar production is composed of alternatives that have a parsing part and a transformation part. The parsing part usually contains several sequential items separated by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operators. With the chosen precedences of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>^^</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>|</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>you can write such a grammar production without needing any parentheses.</P>
<P>Furthermore, symbolic operators take less visual real estate than alphabetic ones. That's important for a parser because it lets you concentrate on the grammar at hand, instead of the combinators themselves. To see the difference, imagine for a moment that sequential composition (<SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>) was called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>andThen</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and alternative (<SPAN class=code>|</SPAN>) was called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>orElse</SPAN>. The arithmetic expression parsers in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:expression-parser">Listing 31.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:expression-parser">here</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>would look as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArithHypothetical</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">JavaTokenParsers</SPAN>&nbsp;{&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;expr:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;&nbsp;&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;term&nbsp;andThen&nbsp;rep((<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>&nbsp;andThen&nbsp;term)&nbsp;orElse&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>&nbsp;andThen&nbsp;term))
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;term:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;&nbsp;&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;factor&nbsp;andThen&nbsp;rep((<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"*"</SPAN>&nbsp;andThen&nbsp;factor)&nbsp;orElse&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"/"</SPAN>&nbsp;andthen&nbsp;factor))
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;factor:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;floatingPointNumber&nbsp;orElse&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"("</SPAN>&nbsp;andThen&nbsp;expr&nbsp;andThen&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">")"</SPAN>)
  }
</PRE>You notice that the code becomes much longer, and that it's hard to "see" the grammar among all those operators and parentheses. On the other hand, somebody new to combinator parsing could probably figure out better what the code is supposed to do. 
<P></P>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Choosing between symbolic and alphabetic names</H3>
<P>As guidelines for choosing between symbolic and alphabetic names we recommend the following:<A id=i-252867623-1></A><A id=i760884015-1></A><A id=i27050837-1></A><A id=i-1245815134-1></A></P>
<UL>
<LI>Use symbolic names in cases where they already have a universally established meaning. For instance, nobody would recommend writing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>add</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for numeric addition. 
<LI>Otherwise, give preference to alphabetic names if you want your code to be understandable to casual readers. 
<LI>You can still choose symbolic names for domain-specific libraries, if this gives clear advantages in legibility and you do not expect anyway that a casual reader without a firm grounding in the domain would be able to understand the code immediately.</LI></UL>In the case of parser combinators we are looking at a highly domain-specific language, which casual readers may have trouble understanding even with alphabetic names. Furthermore, symbolic names give clear advantages in legibility for the expert. So we believe their use is warranted in this application.</DIV>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=31.6></A>31.6 Implementing combinator parsers<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#31.6">link</A>]</SPAN></H3>
<P>The previous sections have shown that Scala's combinator parsers provide a convenient means for constructing your own parsers. Since they are nothing more than a Scala library, they fit seamlessly into your Scala programs. So it's very easy to combine a parser with some code that processes the results it delivers, or to rig a parser so that it takes its input from some specific source (say, a file, a string, or a character array).</P>
<P>How is this achieved? In the rest of this chapter you'll take a look "under the hood" of the combinator parser library. You'll see what a parser is, and how the primitive parsers and parser combinators encountered in previous sections are implemented. You can safely skip these parts if all you want to do is write some simple combinator parsers. On the other hand, reading the rest of this chapter should give you a deeper understanding of combinator parsers in particular, and of the design principles of a combinator domain-specific language in general.</P>
<P>The core of Scala's combinator parsing framework is contained in the trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.util.parsing.combinator.Parsers</SPAN>.<A id=i1073514242-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This trait defines the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type as well as all fundamental combinators. Except where stated explicitly otherwise, the definitions explained in the following two subsections all reside in this trait. That is, they are assumed to be contained in a trait definition that starts as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;scala.util.parsing.combinator
  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parsers</SPAN>&nbsp;{
  &nbsp;&nbsp;...&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;code&nbsp;goes&nbsp;here&nbsp;unless&nbsp;otherwise&nbsp;stated</SPAN>
  }
</PRE>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in essence just a function from some input type to a parse result. As a first approximation, the type could be written as follows:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[T]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ParseResult[T]</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Parser input</H4>
<P>Sometimes, a parser reads a stream of tokens instead of a raw sequence of characters. A separate lexical analyzer is then used to convert a stream of raw characters into a stream of tokens.<A id=i262352408-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The type of parser inputs is defined as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Reader[Elem]</SPAN>&nbsp;&nbsp;&nbsp;
</PRE>The class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Reader</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>comes from the package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.util.parsing.input</SPAN>.<A id=i1984859131-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It is similar to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Stream</SPAN>, but also keeps track of the positions of all the elements it reads. The type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Elem</SPAN>represents individual input elements.<A id=i-2008629102-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It is an abstract type member of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parsers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Elem</SPAN>
</PRE>This means that subclasses and subtraits of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parsers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>need to instantiate class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the type of input elements that are being parsed. For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RegexParsers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=code>JavaTokenParsers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fix<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be equal to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Char</SPAN>. But it would also be possible to set<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to some other type, such as the type of tokens returned from a separate lexer. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Parser results</H4>
<P>A parser might either succeed or fail on some given input. Consequently class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ParseResult</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has two subclasses for representing success and failure:<A id=i-27560472-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">sealed</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ParseResult[+T]</SPAN>&nbsp;
  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Success[T]</SPAN>(result:&nbsp;T,&nbsp;in:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>)&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ParseResult[T]</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Failure</SPAN>(msg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;in:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>)&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ParseResult[Nothing]</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Success</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>case carries the result returned from the parser in its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>result</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter.<A id=i240639739-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The type of parser results is arbitrary; that's why<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ParseResult</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Success</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are all parameterized with a type parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. The type parameter represents the kinds of results returned by a given parser.<A id=i-370701594-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Success</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>also takes a second parameter,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>in</SPAN>, which refers to the input immediately following the part that the parser consumed. This field is needed for chaining parsers, so that one parser can operate after another. Note that this is a purely functional approach to parsing.<A id=i-1568373391-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Input is not read as a side effect, but it is kept in a stream. A parser analyzes some part of the input stream, and then returns the remaining part in its result. 
<P></P>
<P>The other subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ParseResult</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Failure</SPAN>.<A id=i1670336322-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This class takes as a parameter a message that describes why the parser<SPAN class=Apple-converted-space>&nbsp;</SPAN>failed. Like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Success</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Failure</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>also takes the remaining input stream as a second parameter. This is needed not for chaining (the parser won't continue after a failure), but to position the error message at the correct place in the input stream.</P>
<P>Note that parse results are defined to be covariant in the type parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. That is, a parser returning<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>s as result, say, is compatible with a parser returning<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>s.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class</H4>
<P>The previous characterization of parsers as functions from inputs to parse results was a bit oversimplified. The previous examples showed that parsers also implement<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">methods</SPAN>such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for sequential composition of two parsers and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>|</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for their alternative composition. So<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in reality a class that inherits from the function type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Input</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>ParseResult[T]</SPAN>and additionally defines these methods:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[+T]</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ParseResult[T]</SPAN>)&nbsp;
  {&nbsp;p&nbsp;=&gt;
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;An&nbsp;unspecified&nbsp;method&nbsp;that&nbsp;defines&nbsp;</SPAN>
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;the&nbsp;behavior&nbsp;of&nbsp;this&nbsp;parser.</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(in:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ParseResult[T]</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN>&nbsp;...
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;|&nbsp;...
  &nbsp;&nbsp;...
  }
</PRE>Since parsers are (<I>i.e.</I>, inherit from) functions, they need to define an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. You see an abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN>, but this is just for documentation, as the same method is in any case inherited from the parent type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Input</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>ParseResult[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(recall that this type is an abbreviation for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Function1[Input,</SPAN>&nbsp;<SPAN class=code>ParseResult[T]]</SPAN>). The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN>method still needs to be implemented in the individual parsers that inherit from the abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. These parsers will be discussed after the following section on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN>aliasing. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Aliasing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN></H4>
<P><A name=sec:this-aliasing></A></P>
<P>The body of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class starts with a curious expression:<A id=i-1148380995-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[+T]</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;...&nbsp;{&nbsp;p&nbsp;=&gt;
</PRE>A clause such as "<SPAN class=code>id</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>" immediately after the opening brace of a class template defines the identifier<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>id</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an alias<A id=i427194646-1></A><A id=i198894-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the class. It's as if you had written:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;id&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>
</PRE>in the class body, except that the Scala compiler knows that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>id</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an alias for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN>. For instance, you could access an object-private member<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>m</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the class using either<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>id.m</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=code>this.m</SPAN>; the two are completely equivalent. The first expression would not compile if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>id</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>were just defined as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as its right hand side, because in that case the Scala compiler would treat<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>id</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a normal identifier. 
<P></P>
<P>You saw syntax like this in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/modular-programming-using-objects.html#sec:modules-traits">Section 27.4</A>, where it was used to give a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-1749196914">self type</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>to a trait. Aliasing can also be a good abbreviation when you need to access the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of an outer class. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Outer</SPAN>&nbsp;{&nbsp;outer&nbsp;=&gt;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Inner</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(Outer.this&nbsp;eq&nbsp;outer)&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;prints:&nbsp;true</SPAN>
  &nbsp;&nbsp;}
  }
</PRE>The example defines two nested classes,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Outer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Inner</SPAN>. Inside<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Inner</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>value of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Outer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class is referred to twice, using different expressions. The first expression shows the Java way of doing things: You can prefix the reserved word<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the name of an outer class and a period; such an expression then refers to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the outer class. The second expression shows the alternative that Scala gives you. By introducing an alias named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>outer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Outer</SPAN>, you can refer to this alias directly also in inner classes.<A id=i1909060649-1></A>The Scala way is more concise, and can also improve clarity, if you choose the name of the alias well. You'll see examples of this<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#sec:parsers-seq">here</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#sec:parsers-alt">here</A>. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Single-token parsers</H4>
<P>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parsers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defines a generic parser<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that can be used to parse any single token:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;elem(kind:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;p:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Elem</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Elem]</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(in:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(p(in.first))&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Success</SPAN>(in.first,&nbsp;in.rest)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Failure</SPAN>(kind&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;expected"</SPAN>,&nbsp;in)
  &nbsp;&nbsp;}
</PRE>This parser takes two parameters: a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>kind</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>string describing what kind of token should be parsed and a predicate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Elem</SPAN>s, which indicates whether an element fits the class of tokens to be parsed. 
<P></P>
<P>When applying the parser<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elem(kind,</SPAN>&nbsp;<SPAN class=code>p)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to some input<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>in</SPAN>, the first element of the input stream is tested with predicate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>, the parser succeeds. Its result is the element itself, and its remaining input is the input stream starting just after the element that was parsed. On the other hand, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>, the parser fails with an error message that indicates what kind of token was expected.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Sequential composition</H4>
<P><A name=sec:parsers-seq></A></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser only consumes a single element. To parse more interesting phrases, you can string parsers together with the sequential composition operator<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>.<A id=i-1259402311-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>As you have seen before,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P<SPAN style="FONT-SIZE: large">~</SPAN>Q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a parser that applies first the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser to a given input string. Then, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>succeeds, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser is applied to the input that's left after<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has done its job.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>combinator is implemented as a method in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN>. Its definition is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#lst:tilde-combinator">Listing 31.6</A>. The method is a member of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. Inside this class,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is specified by the "<SPAN class=code>p</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>" part as an alias of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN>, so<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>designates the left operand (or: receiver) of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>. Its right operand is represented by parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN>. Now, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p<SPAN style="FONT-SIZE: large">~</SPAN>q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is run on some input<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>in</SPAN>, first<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>is run on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>in</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the result is analyzed in a pattern match. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>succeeds,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is run on the remaining input<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>in1</SPAN>. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>also succeeds, the parser as a whole succeeds. Its result is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>object containing both the result of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<I>i.e.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>) and the result of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<I>i.e.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN>). On the other hand, if either<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fails the result of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p<SPAN style="FONT-SIZE: large">~</SPAN>q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Failure</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object returned by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN>.<A name=lst:tilde-combinator></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[+T]</SPAN>&nbsp;...&nbsp;{&nbsp;p&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;...
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN>&nbsp;[U](q:&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[U]</SPAN>)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[T<SPAN style="FONT-SIZE: large">~</SPAN>U]</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(in:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>)&nbsp;=&nbsp;p(in)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Success</SPAN>(x,&nbsp;in1)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q(in1)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Success</SPAN>(y,&nbsp;in2)&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Success</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN>(x,&nbsp;y),&nbsp;in2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;failure&nbsp;=&gt;&nbsp;failure
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;failure&nbsp;=&gt;&nbsp;failure
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
</PRE>
<H5>Listing 31.6 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>combinator method.</H5>
<P>The result type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a parser that returns an instance of the case class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with elements of types<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>U</SPAN>. The type expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T<SPAN style="FONT-SIZE: large">~</SPAN>U</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is just a more legible shorthand for the parameterized type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN>[T,</SPAN>&nbsp;<SPAN class=code>U]</SPAN>. Generally, Scala always interprets a binary type operation such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A</SPAN>&nbsp;<SPAN class=code>op</SPAN>&nbsp;<SPAN class=code>B</SPAN>, as the parameterized type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op[A,</SPAN>&nbsp;<SPAN class=code>B]</SPAN>. This is analogous to the situation for patterns, where a binary pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>&nbsp;<SPAN class=code>op</SPAN>&nbsp;<SPAN class=code>Q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is also interpreted as an application,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op(P,</SPAN>&nbsp;<SPAN class=code>Q)</SPAN>.</P>
<P>The other two sequential composition operators,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;<SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN>&gt;</SPAN>, could be defined just like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>, only with some small adjustment in how the result is computed.<A id=i1302279396-2></A><A id=i1234233109-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>A more elegant technique, though, is to define them in terms of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;&lt;<SPAN style="FONT-SIZE: large">~</SPAN>&nbsp;[U](q:&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[U]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[T]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;(p<SPAN style="FONT-SIZE: large">~</SPAN>q)&nbsp;^^&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x<SPAN style="FONT-SIZE: large">~</SPAN>y&nbsp;=&gt;&nbsp;x&nbsp;}
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN>&gt;&nbsp;[U](q:&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[U]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[U]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;(p<SPAN style="FONT-SIZE: large">~</SPAN>q)&nbsp;^^&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x<SPAN style="FONT-SIZE: large">~</SPAN>y&nbsp;=&gt;&nbsp;y&nbsp;}
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Alternative composition</H4>
<P><A name=sec:parsers-alt></A></P>
<P>An alternative composition<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>&nbsp;<SPAN class=code>|</SPAN>&nbsp;<SPAN class=code>Q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>applies either<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to a given input.<A id=i1105339901-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It first tries<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>succeeds, the whole parser succeeds with the result of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>. Otherwise, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fails, then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is tried<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">on the same input</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>. The result of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is then the result of the whole parser.</P>
<P>Here is a definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>|</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a method of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;|&nbsp;(q:&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[T]</SPAN>)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[T]</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(in:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>)&nbsp;=&nbsp;p(in)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;s1&nbsp;@&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Success</SPAN>(_,&nbsp;_)&nbsp;=&gt;&nbsp;s1
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;failure&nbsp;=&gt;&nbsp;q(in)&nbsp;
  &nbsp;&nbsp;}
  }
</PRE>Note that if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>both fail, then the failure message is determined by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Q</SPAN>. This subtle choice is discussed later, in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#sec:combinator-errors">Section 31.9</A>. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Dealing with recursion</H4>
<P>Note that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter in methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>|</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is by-name&#8212;its type is preceded by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=&gt;</SPAN>.<A id=i999036029-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This means that the actual parser argument will be evaluated only when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is needed, which should only be the case after<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has run. This makes it possible to write recursive parsers like the following one which parses a number enclosed by arbitrarily many parentheses:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;parens&nbsp;=&nbsp;floatingPointNumber&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"("</SPAN><SPAN style="FONT-SIZE: large">~</SPAN>parens<SPAN style="FONT-SIZE: large">~</SPAN><SPAN class=quotedstring style="COLOR: rgb(205,123,0)">")"</SPAN>&nbsp;
</PRE>If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>|</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>took<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-430862780"><EM style="FONT-STYLE: italic">by-value parameters</EM></A>, this definition would<A id=i267370507-1></A><A id=i-471844177-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>immediately cause a stack overflow without reading anything, because the value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>parens</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>occurs in the middle of its right-hand side. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Result conversion</H4>
<P>The last method of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>converts a parser's result. The parser<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>&nbsp;<SPAN class=code>^^</SPAN>&nbsp;<SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>succeeds exactly when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>succeeds. In that case it returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>'s result converted using the function<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN>. Here is the implementation of this method:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;^^&nbsp;[U](f:&nbsp;T&nbsp;=&gt;&nbsp;U):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[U]</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[U]</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(in:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>)&nbsp;=&nbsp;p(in)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Success</SPAN>(x,&nbsp;in1)&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Success</SPAN>(f(x),&nbsp;in1)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;failure&nbsp;=&gt;&nbsp;failure
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  }&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;end&nbsp;Parser</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Parsers that don't read any input</H4>
<P>There are also two parsers that do not consume any input:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>success</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>failure</SPAN>. The parser<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>success(result)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>always succeeds with the given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>result</SPAN>. The parser<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>failure(msg)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>always fails with error message<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msg</SPAN>. Both are implemented as methods in trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parsers</SPAN>, the outer trait that also contains class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;success[T](v:&nbsp;T)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[T]</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(in:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>)&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Success</SPAN>(v,&nbsp;in)
  }
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;failure(msg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Nothing]</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(in:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>)&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Failure</SPAN>(msg,&nbsp;in)
  }
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Option and repetition</H4>
<P>Also defined in trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parsers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are the option and repetition combinators<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>opt</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rep</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>repsep</SPAN>.<A id=i1073514242-2></A><A id=i1251140526-1></A><A id=i476382634-1></A><A id=i1315224406-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>They are all implemented in terms of sequential composition, alternative, and result conversion:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;opt[T](p:&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[T]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Option[T]]</SPAN>&nbsp;=&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;^^&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(_)&nbsp;&nbsp;
  &nbsp;&nbsp;|&nbsp;success(<SPAN class=typename style="COLOR: rgb(103,0,154)">None</SPAN>)
  &nbsp;&nbsp;)
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;rep[T](p:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[T]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[List[T]]</SPAN>&nbsp;=&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;p<SPAN style="FONT-SIZE: large">~</SPAN>rep(p)&nbsp;^^&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x<SPAN style="FONT-SIZE: large">~</SPAN>xs&nbsp;=&gt;&nbsp;x&nbsp;::&nbsp;xs&nbsp;}&nbsp;&nbsp;
  &nbsp;&nbsp;|&nbsp;success(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>())
  &nbsp;&nbsp;)
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;repsep[T,&nbsp;U](p:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[T]</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[U]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[List[T]]</SPAN>&nbsp;=&nbsp;(
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;p<SPAN style="FONT-SIZE: large">~</SPAN>rep(q<SPAN style="FONT-SIZE: large">~</SPAN>&gt;&nbsp;p)&nbsp;^^&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;r<SPAN style="FONT-SIZE: large">~</SPAN>rs&nbsp;=&gt;&nbsp;r&nbsp;::&nbsp;rs&nbsp;}&nbsp;&nbsp;
  &nbsp;&nbsp;|&nbsp;success(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>())
  &nbsp;&nbsp;)
  <BR>  }&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;end&nbsp;Parsers</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=31.7></A>31.7 String literals and regular expressions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#31.7">link</A>]</SPAN></H3>
<P>The parsers you saw so far made use of string literals and regular expressions to parse single words. The support for these comes from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RegexParsers</SPAN>, a subtrait of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parsers</SPAN>:<A id=i519257659-2></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RegexParsers</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parsers</SPAN>&nbsp;{&nbsp;
</PRE>This trait is more specialized than trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parsers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in that it only works for inputs that are sequences of characters:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">type</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Elem</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Char</SPAN>
</PRE>It defines two methods,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>literal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>regex</SPAN>, with the following signatures:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;literal(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[String]</SPAN>&nbsp;=&nbsp;...
  <SPAN class=vem style="COLOR: rgb(0,0,230)">implicit</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;regex(r:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Regex</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[String]</SPAN>&nbsp;=&nbsp;...
</PRE>Note that both methods have an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>implicit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier, so they are automatically applied whenever a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Regex</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is given but a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parser</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is expected.<A id=i1803313949-1></A><A id=i961731205-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>That's why you can write string literals and regular expressions directly in a grammar, without having to wrap them with one of these methods. For instance, the parser<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"("<SPAN style="FONT-SIZE: large">~</SPAN>expr<SPAN style="FONT-SIZE: large">~</SPAN>")"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be automatically expanded to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>literal("(")<SPAN style="FONT-SIZE: large">~</SPAN>expr<SPAN style="FONT-SIZE: large">~</SPAN>literal(")")</SPAN>. 
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RegexParsers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait also takes care of handling white space between symbols. To do this, it calls a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>handleWhiteSpace</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>before running a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>literal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>regex</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>handleWhiteSpace</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method skips the longest input sequence that conforms to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>whiteSpace</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>regular expression, which is defined by default as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">protected</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;whiteSpace&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"""\s+"""</SPAN>.r
  }&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;end&nbsp;RegexParsers</SPAN>
</PRE>If you prefer a different treatment of white space, you can override the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>whiteSpace</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>. For instance, if you want white space not to be skipped at all, you can override<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>whiteSpace</SPAN>with the empty regular expression:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">MyParsers</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RegexParsers</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;whiteSpace&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">""</SPAN>.r
  &nbsp;&nbsp;...
  }
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=31.8></A>31.8 Lexing and parsing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#31.8">link</A>]</SPAN></H3>
<P>The task of syntax analysis is often split into two phases. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">lexer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>phase recognizes individual words in the input and classifies them into some<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">token</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>classes. This phase is also called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">lexical analysis</SPAN>. This is followed by a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">syntactical analysis</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>phase that analyzes sequences of tokens.<A id=i1371644930-1></A><A id=i1779690801-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Syntactical analysis is also sometimes just called parsing, even though this is slightly imprecise, as lexical analysis can also be regarded as a parsing problem.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parsers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait as described in the previous section can be used for either phase, because its input elements are of the abstract type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Elem</SPAN>. For lexical analysis,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be instantiated to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Char</SPAN>, meaning the individual characters that make up a word are being parsed. The syntactical analyzer would in turn instantiate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the type of token returned by the lexer.</P>
<P>Scala's parsing combinators provide several utility classes for lexical and syntactic analysis. These are contained in two sub-packages, one for each kind of analysis:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala.util.parsing.combinator.lexical&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  scala.util.parsing.combinator.syntactical&nbsp;&nbsp;&nbsp;
</PRE>If you want to split your parser into a separate lexer and syntactical analyzer, you should consult the Scaladoc documentation<SPAN class=Apple-converted-space>&nbsp;</SPAN>for these packages. But for simple parsers, the regular expression based approach shown previously in this chapter is usually sufficient. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=31.9></A>31.9 Error reporting<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#31.9">link</A>]</SPAN></H3>
<P><A name=sec:combinator-errors></A></P>
<P>There's one final topic that was not covered yet: how does the parser issue an error message? Error reporting for parsers is somewhat of a black art. One problem is that when a parser rejects some input, it generally has encountered many different failures.<A id=i1725890298-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Each alternative parse must have failed, and recursively so at each choice point. Which of the usually numerous failures should be emitted as error message to the user?</P>
<P>Scala's parsing library implements a simple heuristic: among all failures, the one that occurred at the latest position in the input is chosen. In other words, the parser picks the longest prefix that is still valid and issues an error message that describes why parsing the prefix could not be continued further. If there are several failure points at that latest position, the one that was visited last is chosen.</P>
<P>For instance, consider running the JSON parser on a faulty address book which starts with the line:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  {&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"name"</SPAN>:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">John</SPAN>,
</PRE>The longest legal prefix of this phrase is "<SPAN class=code>{</SPAN>&nbsp;<SPAN class=code>"name":</SPAN>&nbsp;<SPAN class=code></SPAN>". So the JSON parser will flag the word<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>John</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an error. The JSON parser expects a value at this point, but<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>John</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an identifier, which does not count as a value (presumably, the author of the document had forgotten to enclose the name in quotation marks). The error message issued by the parser for this document is:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  [<SPAN class=literal style="COLOR: rgb(205,123,0)">1.13</SPAN>]&nbsp;failure:&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"false"</SPAN>&nbsp;expected&nbsp;but&nbsp;identifier&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">John</SPAN>&nbsp;found
  <BR>  &nbsp;&nbsp;{&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"name"</SPAN>:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">John</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
</PRE>
<P></P>
<P>The part that "false" was expected comes from the fact that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"false"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the last alternative of the production for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the JSON grammar. So this was the last failure at this point. Users who know the JSON grammar in detail can reconstruct the error message, but for non-experts this error message is probably surprising and can also be quite misleading.</P>
<P>A better error message can be engineered by adding a "catch-all" failure point as last alternative of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>production:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;value:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=
  &nbsp;&nbsp;obj&nbsp;|&nbsp;arr&nbsp;|&nbsp;stringLit&nbsp;|&nbsp;floatingPointNumber&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"null"</SPAN>&nbsp;|
  &nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"true"</SPAN>&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"false"</SPAN>&nbsp;|&nbsp;failure(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"illegal&nbsp;start&nbsp;of&nbsp;value"</SPAN>)
</PRE>This addition does not change the set of inputs that are accepted as valid documents. What it does is improve the error messages, because now it will be the explicitly added<SPAN class=code>failure</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that comes as last alternative and therefore gets reported:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  [<SPAN class=literal style="COLOR: rgb(205,123,0)">1.13</SPAN>]&nbsp;failure:&nbsp;illegal&nbsp;start&nbsp;of&nbsp;value
  <BR>  &nbsp;&nbsp;{&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"name"</SPAN>:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">John</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
</PRE>
<P></P>
<P>The implementation of the "latest possible" scheme of error reporting uses a field named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>lastFailure</SPAN>: in trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parsers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to mark the failure that occurred at the latest position in the input:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;lastFailure:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Option[Failure]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">None</SPAN>
</PRE>The field is initialized to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>None</SPAN>. It is updated in the constructor of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Failure</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Failure</SPAN>(msg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;in:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ParseResult[Nothing]</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(lastFailure.isDefined&nbsp;&amp;&amp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastFailure.get.in.pos&nbsp;&lt;=&nbsp;in.pos)
  &nbsp;&nbsp;&nbsp;&nbsp;lastFailure&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>)
  }
</PRE>The field is read by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>phrase</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which emits the final error message if the parser failed. Here is the implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>phrase</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parsers</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;phrase[T](p:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[T]</SPAN>)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[T]</SPAN>&nbsp;{
  &nbsp;&nbsp;lastFailure&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">None</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(in:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Input</SPAN>)&nbsp;=&nbsp;p(in)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;s&nbsp;@&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Success</SPAN>(out,&nbsp;in1)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(in1.atEnd)&nbsp;s&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Failure</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"end&nbsp;of&nbsp;input&nbsp;expected"</SPAN>,&nbsp;in1)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;f&nbsp;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Failure</SPAN>&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastFailure
  &nbsp;&nbsp;}
  }
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>phrase</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method runs its argument parser<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>succeeds with a completely consumed input, the success result of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is returned. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>succeeds but the input is not read completely, a failure with message "end of input expected" is returned. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fails, the failure or error stored in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>lastFailure</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is returned. Note that the treatment of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>lastFailure</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is non-functional; it is updated as a side effect by the constructor of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Failure</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>phrase</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method itself. A functional version of the same scheme would be possible, but it would require threading the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>lastFailure</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>value though every parser result, no matter whether this result is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Success</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Failure</SPAN>. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=31.10></A>31.10 Backtracking versus LL(1)<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#31.10">link</A>]</SPAN></H3>
<P>The parser combinators employ<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">backtracking</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to choose between different parsers in an alternative.<A id=i426003614-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In an expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>&nbsp;<SPAN class=code>|</SPAN>&nbsp;<SPAN class=code>Q</SPAN>, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>fails, then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is run on the same input as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN>.<A id=i-2138187530-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This happens even if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>P</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has parsed some tokens before failing. In this case the same tokens will be parsed again by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Q</SPAN>.</P>
<P>Backtracking imposes only a few restrictions on how to formulate a grammar so that it can be parsed. Essentially, you just need to avoid left-recursive productions. A production such as:</P>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="">
<TD><SPAN style="FONT-STYLE: italic">expr</SPAN></TD>
<TD>::=</TD>
<TD><SPAN style="FONT-STYLE: italic">expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;<SPAN class=code>"+"</SPAN>&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">term</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;|&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">term</SPAN>.</TD></TR></TBODY></TABLE></DIV>
<P>will always fail because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>immediately calls itself and thus never progresses any further.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#footnote31-1">[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>On the other hand, backtracking is potentially costly because the same input can be parsed several times. Consider for instance the production:</P>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="">
<TD><SPAN style="FONT-STYLE: italic">expr</SPAN></TD>
<TD>::=</TD>
<TD><SPAN style="FONT-STYLE: italic">term</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;<SPAN class=code>"+"</SPAN>&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;|&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">term</SPAN>.</TD></TR></TBODY></TABLE></DIV>
<P>What happens if the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parser is applied to an input such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(1</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>2)</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>3</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>which constitutes a legal term? The first alternative would be tried, and would fail when matching the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN>sign. Then the second alternative would be tried on the same term and this would succeed. In the end the term ended up being parsed twice.</P>
<P>It is often possible to modify the grammar so that backtracking can be avoided. For instance, in the case of arithmetic expressions, either one of the following productions would work:</P>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="">
<TD><SPAN style="FONT-STYLE: italic">expr</SPAN></TD>
<TD>::=</TD>
<TD><SPAN style="FONT-STYLE: italic">term</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;[<SPAN class=code>"+"</SPAN>&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">expr</SPAN>].</TD></TR>
<TR class="">
<TD><SPAN style="FONT-STYLE: italic">expr</SPAN></TD>
<TD>::=</TD>
<TD><SPAN style="FONT-STYLE: italic">term</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp;\{<SPAN class=code>"+"</SPAN>&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">term</SPAN>\}.</TD></TR></TBODY></TABLE></DIV>
<P>Many languages admit so-called "LL(1)" grammars.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#footnote31-2">[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>When a combinator parser is formed from such a grammar, it will never backtrack,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, the input position will never be reset to an earlier value. For instance, the grammars for arithmetic expressions and JSON terms earlier in this chapter are both LL(1), so the backtracking capabilities of the parser combinator framework are never exercised for inputs from these languages.</P>
<P>The combinator parsing framework allows you to express the expectation that a grammar is LL(1) explicitly, using a new operator<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN>!</SPAN>.<A id=i1119621308-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This operator is like sequential composition<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>but it will never backtrack to "un-read" input elements that have already been parsed. Using this operator, the productions in the arithmetic expression parser could alternatively be written as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;expr&nbsp;&nbsp;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;term&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN>!&nbsp;rep(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN>!&nbsp;term&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN>!&nbsp;term)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;term&nbsp;&nbsp;:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;factor&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN>!&nbsp;rep(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"*"</SPAN>&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN>!&nbsp;factor&nbsp;|&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"/"</SPAN>&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN>!&nbsp;factor)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;factor:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Parser[Any]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"("</SPAN>&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN>!&nbsp;expr&nbsp;<SPAN style="FONT-SIZE: large">~</SPAN>!&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">")"</SPAN>&nbsp;|&nbsp;floatingPointNumber
</PRE>One advantage of an LL(1) parser is that it can use a simpler input technique. Input can be read sequentially, and input elements can be discarded once they are read. That's another reason why LL(1) parsers are usually more efficient than backtracking parsers.<A id=i-1119687476-1></A> 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=31.11></A>31.11 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#31.11">link</A>]</SPAN></H3>
<P>You have now seen all the essential elements of Scala's combinator parsing framework. It's surprisingly little code for something that's genuinely useful. With the framework you can construct parsers for a large class of context-free grammars. The framework lets you get started quickly, but it is also customizable to new kinds of grammars and input methods. Being a Scala library, it integrates seamlessly with the rest of the language. So it's easy to integrate a combinator parser in a larger Scala program.</P>
<P>One downside of combinator parsers is that they are not very efficient, at least not when compared with parsers generated from special purpose tools such as Yacc or Bison. There are two reasons for this. First, the backtracking method used by combinator parsing is itself not very efficient. Depending on the grammar and the parse input, it might yield an exponential slow-down due to repeated backtracking. This can be fixed by making the grammar LL(1) and by using the committed sequential composition operator,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN>!</SPAN>.</P>
<P>The second problem affecting the performance of combinator parsers is that they mix parser construction and input analysis in the same set of operations. In effect, a parser is generated anew for each input that's parsed.</P>
<P>This problem can be overcome, but it requires a different implementation of the parser combinator framework. In an optimizing framework, a parser would no longer be represented as a function from inputs to parse results. Instead, it would be represented as a tree, where every construction step was represented as a case class. For instance, sequential composition could be represented by a case class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Seq</SPAN>, alternative by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Alt</SPAN>, and so on. The "outermost" parser method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>phrase</SPAN>, could then take this symbolic representation of a parser and convert it to highly efficient parsing tables, using standard parser generator algorithms.</P>
<P>What's nice about all this is that from a user perspective nothing changes compared to plain combinator parsers. Users still write parsers in terms of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ident</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>floatingPointNumber</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code><SPAN style="FONT-SIZE: large">~</SPAN></SPAN>,<SPAN class=code>|</SPAN>, and so on. They need not be aware that these methods generate a symbolic representation of a parser instead of a parser function. Since the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>phrase</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>combinator converts these representations into real parsers, everything works as before.</P>
<P>The advantage of this scheme with respect to performance is two-fold. First, you can now factor out parser construction from input analysis. If you were to write:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;jsonParser&nbsp;=&nbsp;phrase(value)
</PRE>and then apply<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>jsonParser</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to several different inputs, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>jsonParser</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be constructed only once, not every time an input is read. 
<P></P>
<P>Second, the parser generation can use efficient parsing algorithms such as LALR(1).<A id=i-572333127-1></A><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combinator-parsing.html#footnote31-3">[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>These algorithms usually lead to much faster parsers than parsers that operate with backtracking.</P>
<P>At present, such an optimizing parser generator has not yet been written for Scala. But it would be perfectly possible to do so. If someone contributes such a generator, it will be easy to integrate into the standard Scala library. Even postulating that such a generator will exist at some point in the future, however, there are reasons for keeping the current parser combinator framework around. It is much easier to understand and to adapt than a parser generator, and the difference in speed would often not matter in practice, unless you want to parse very large inputs.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 31:</H4>
<P><A name=footnote31-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>There are ways to avoid stack overflows even in the presence of left-recursion, but this requires a more refined parsing combinator framework, which to date has not been implemented.</P>
<P><A name=footnote31-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Aho,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>et. al.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Compilers: Principles, Techniques, and Tools</EM>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#aho-sethi-ullman">aho-sethi-ullman</A><A id=i1109104818-2></A></P>
<P><A name=footnote31-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Aho,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>et. al.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Compilers: Principles, Techniques, and Tools</EM>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#aho-sethi-ullman">aho-sethi-ullman</A><A id=i-1383802058-1></A></P></DIV>