<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Glossary</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<DIV id=glossary>
<P><A id=g-725411438></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">algebraic data type</SPAN>&nbsp;&nbsp; A type defined by providing<SPAN class=Apple-converted-space>&nbsp;</SPAN>several alternatives, each of which<SPAN class=Apple-converted-space>&nbsp;</SPAN>comes with its own constructor. It usually comes with a way to decompose the type through pattern matching. The concept is found in specification languages and functional programming languages.<SPAN class=Apple-converted-space>&nbsp;</SPAN>Algebraic data types can be emulated in Scala with case classes.</P>
<P><A id=g-196794451></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">alternative</SPAN>&nbsp;&nbsp; A branch of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. It has the form "<SPAN class=code>case</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">pattern</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">expression</EM>." Another name for alternative is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">case</EM>.<A id=i1197489584-1></A></P>
<P><A id=g-1555043537></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">annotation</SPAN>&nbsp;&nbsp; An<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">annotation</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>appears in source code and is attached to some part of the syntax. Annotations are computer processable, so you can use them to effectively add an extension to Scala.</P>
<P><A id=g-113939451></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">anonymous class</SPAN>&nbsp;&nbsp;An anonymous<SPAN class=Apple-converted-space>&nbsp;</SPAN>class is a synthetic subclass generated by the Scala compiler from a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression in which the class or trait name is followed by curly braces. The curly braces contains the body of the anonymous subclass, which may be empty. However, if the name following<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>refers to a trait or class that contains abstract members, these must be made concrete inside the curly braces that define the body of the anonymous subclass.</P>
<P><A id=g-657421781></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">anonymous function</SPAN>&nbsp;&nbsp;Another name for function literal.</P>
<P><A id=g93029230></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">apply</SPAN>&nbsp;&nbsp; You can<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">apply</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>a method, function, or closure<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">to</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments, which means you invoke it on those arguments.</P>
<P><A id=g-1589682499></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">argument</SPAN>&nbsp;&nbsp; When a function is invoked, an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">argument</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is passed for each parameter of that function. The parameter is the variable that refers to the argument. The argument is the object passed at invocation time. In addition, applications can take (command line) arguments that show up in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>main</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods of singleton objects.</P>
<P><A id=g-1408204561></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">assign</SPAN>&nbsp;&nbsp; You can<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">assign</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>an object<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">to</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>a variable. Afterwards, the variable will refer to the object.</P>
<P><A id=g729406368></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">auxiliary constructor</SPAN>&nbsp;&nbsp;Extra constructors defined inside the curly braces of the class definition, which look like method definitions named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN>, but with no result type.</P>
<P><A id=g93832333></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">block</SPAN>&nbsp;&nbsp; One or more expressions and declarations<A id=i824842378-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>surrounded by curly braces. When the block evaluates, all of its expressions and declarations are processed in order, and then the block returns the value of the last expression as its own value. Blocks are commonly used as the bodies of functions,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops, and any other place where you want to group a number of statements together. More formally, a block is an encapsulation construct for which you can only see side effects and a result value. The curly braces in which you define a class or object do not, therefore, form a block, because fields and methods (which are defined inside those curly braces) are visible from the outside. Such curly braces form a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">template</EM>.</P>
<P><A id=g183453406></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">bound variable</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">bound variable</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of an expression is a variable that's both used and defined inside the expression. For instance, in the function literal expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>(x,</SPAN>&nbsp;<SPAN class=code>y)</SPAN>, both variables<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are used, but only<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is bound, because it is defined in the expression as an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the sole argument to the function described by the expression.</P>
<P><A id=g-1173919606></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">by-name parameter</SPAN>&nbsp;&nbsp; A parameter that is marked with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in front of the parameter type,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>e.g.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>. The argument corresponding to a by-name parameter is evaluated not before the method is invoked, but each time the parameter is referenced<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">by name</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>inside the method. If a parameter is not by-name, it is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">by-value</EM>.</P>
<P><A id=g-430862780></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">by-value parameter</SPAN>&nbsp;&nbsp; A parameter that is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">not</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>marked with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in front of the parameter type,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>e.g.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>. The argument corresponding to a by-value parameter is evaluated before the method is invoked. By-value parameters contrast with<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">by-name</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameters.</P>
<P><A id=g94742904></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">class</SPAN>&nbsp;&nbsp; Defined with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>class</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">class</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>may either be abstract or concrete, and may be parameterized with types and values when instantiated. In "<SPAN class=code>new</SPAN>&nbsp;<SPAN class=code>Array[String](2)</SPAN>", the class being instantiated is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the type of the value that results is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN>. A class that takes type parameters is called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">type constructor</EM>. A type can be said to have a class as well, as in: the class of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN>.</P>
<P><A id=g866552379></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">closure</SPAN>&nbsp;&nbsp; A function object that captures free variables, and is said to be "closed" over the variables visible at the time it is created.</P>
<P><A id=g-828430492></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">companion class</SPAN>&nbsp;&nbsp;A class that shares the same name with a singleton object defined in the same source file. The class is the singleton object's companion class.</P>
<P><A id=g423027411></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">companion object</SPAN>&nbsp;&nbsp;A singleton object that shares the same name with a class defined in the same source file. Companion objects and classes have access to each other's private members. In addition, any implicit conversions defined in the companion object will be in scope anywhere the class is used.</P>
<P><A id=g-1356412796></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">contravariant</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">contravariant</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>annotation can be applied to a type parameter of a class or trait by putting a minus sign (<SPAN class=code>-</SPAN>) before the type parameter. The class or trait then subtypes contravariantly with&#8212;in the opposite direction as&#8212;the type annotated parameter. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is contravariant in its first type parameter, and so<SPAN class=code>Function1[Any,</SPAN>&nbsp;<SPAN class=code>Any]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function1[String,</SPAN>&nbsp;<SPAN class=code>Any]</SPAN>.</P>
<P><A id=g1865839257></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">covariant</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">covariant</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>annotation can be applied to a type parameter of a class or trait by putting a plus sign (<SPAN class=code>+</SPAN>) before the type parameter. The class or trait then subtypes covariantly with&#8212;in the same direction as&#8212;the type annotated parameter. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is covariant in its type parameter, so<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Any]</SPAN>.</P>
<P><A id=g575993339></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">currying</SPAN>&nbsp;&nbsp; A way to write functions with multiple parameter lists. For instance<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN>&nbsp;<SPAN class=code>f(x:</SPAN>&nbsp;<SPAN class=code>Int)(y:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a curried function with two parameter lists. A curried function is applied by passing several arguments lists, as in:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f(3)(4)</SPAN>. However, it is also possible to write a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">partial application</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of a curried function, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f(3)</SPAN>.</P>
<P><A id=g1542341994></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">declare</SPAN>&nbsp;&nbsp;You can<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">declare</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>an abstract field, method, or type, which gives an entity a name but not an implementation. The key difference between declarations<A id=i1190494299-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and definitions is that definitions establish an implementation for the named entity, declarations do not.</P>
<P><A id=g-1335633477></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">define</SPAN>&nbsp;&nbsp; To<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">define</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>something in a Scala program is to give it a name and an implementation. You can define classes, traits, singleton objects,<A id=i-1265372713-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>fields, methods, local functions, local variables,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>etc.</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>Because definitions always involve some kind of implementation, abstract members are<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">declared</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>not defined.</P>
<P><A id=g1336110479></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">direct subclass</SPAN>&nbsp;&nbsp; A class is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">direct subclass</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of its direct superclass.</P>
<P><A id=g384896884></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">direct superclass</SPAN>&nbsp;&nbsp; The class from which a class or trait it is immediately derived, the nearest class above it in its inheritance hierarchy. If a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parent</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is mentioned in a class<SPAN class=code>Child</SPAN>'s optional extends clause, then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parent</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the direct superclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Child</SPAN>. If a trait is mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Child</SPAN>'s extends clause, the trait's direct superclass is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Child</SPAN>'s direct superclass. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Child</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has no extends clause, then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the direct superclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Child</SPAN>. If a class's direct superclass takes type parameters, for example<SPAN class=code>class</SPAN>&nbsp;<SPAN class=code>Child</SPAN>&nbsp;<SPAN class=code>extends</SPAN>&nbsp;<SPAN class=code>Parent[String]</SPAN>, the direct superclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Child</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is still<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parent</SPAN>, not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parent[String]</SPAN>. On the other hand,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Parent[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be the direct<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">supertype</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Child</SPAN>. See<EM style="FONT-STYLE: italic">supertype</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>for more discussion of the distinction between class and type.</P>
<P><A id=g581399802></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">equality</SPAN>&nbsp;&nbsp; When used without qualification,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">equality</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the relation between values expressed by `<SPAN class=code>==</SPAN>'. See also<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">reference equality</EM>.</P>
<P><A id=g-1470033894></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">existential type</SPAN>&nbsp;&nbsp; An existential type includes references to type variables that are unknown. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[T]</SPAN>&nbsp;<SPAN class=code>forSome</SPAN>&nbsp;<SPAN class=code>{</SPAN>&nbsp;<SPAN class=code>type</SPAN>&nbsp;<SPAN class=code>T</SPAN>&nbsp;<SPAN class=code>}</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an existential type. It is an array of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>, where<SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is some completely unknown type. All that is assumed about<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is that it exists at all. This assumption is weak, but it means at least that an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[T]</SPAN>&nbsp;<SPAN class=code>forSome</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>{</SPAN>&nbsp;<SPAN class=code>type</SPAN>&nbsp;<SPAN class=code>T</SPAN>&nbsp;<SPAN class=code>}</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is indeed an array and not a banana.</P>
<P><A id=g-1795452264></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">expression</SPAN>&nbsp;&nbsp; Any bit of Scala code that yields a result. You can also say that an expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">evaluates to</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>a result or<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">results in</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>a value.</P>
<P><A id=g-1274492040></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">filter</SPAN>&nbsp;&nbsp; An<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>followed by a boolean expression in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. In<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for(i</SPAN>&nbsp;<SPAN class=code>&lt;-</SPAN>&nbsp;<SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code>10;</SPAN>&nbsp;<SPAN class=code>if</SPAN>&nbsp;<SPAN class=code>i</SPAN>&nbsp;<SPAN class=code>%</SPAN>&nbsp;<SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>0)</SPAN>, the filter is "<SPAN class=code>if</SPAN>&nbsp;<SPAN class=code>i</SPAN>&nbsp;<SPAN class=code>%</SPAN>&nbsp;<SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>0</SPAN>". The value to the right of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">filter expression</EM>.</P>
<P><A id=g-1577991104></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">filter expression</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">filter expression</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the boolean expression following an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. In<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for(i</SPAN>&nbsp;<SPAN class=code>&lt;-</SPAN>&nbsp;<SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code>10;</SPAN>&nbsp;<SPAN class=code>if</SPAN>&nbsp;<SPAN class=code>i</SPAN>&nbsp;<SPAN class=code>%</SPAN>&nbsp;<SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>0)</SPAN>, the filter expression is "<SPAN class=code>i</SPAN>&nbsp;<SPAN class=code>%</SPAN>&nbsp;<SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>0</SPAN>".</P>
<P><A id=g1589563862></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">first-class function</SPAN>&nbsp;&nbsp; Scala supports<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">first-class functions</EM>, which means you can express functions in<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">function literal</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>syntax,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>1</SPAN>, and that functions can be represented by objects, which are called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">function values</EM>.</P>
<P><A id=g1007002221></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">for comprehension</SPAN>&nbsp;&nbsp; Another name for<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic"><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression</EM>.</P>
<P><A id=g-761850448></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">free variable</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">free variable</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of an expression is a variable that's used inside the expression but not defined inside the expression. For instance, in the function literal expression<SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>(x,</SPAN>&nbsp;<SPAN class=code>y)</SPAN>, both variables<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are used, but only<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a free variable, because it is not defined inside the expression.</P>
<P><A id=g1380938712></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">function</SPAN>&nbsp;&nbsp;A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">function</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">invoked</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a list of arguments to produce a result. A function has a parameter list, a body, and a result type. Functions that are members of a class, trait, or singleton object are called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">methods</EM>. Functions defined inside other functions are called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">local functions</EM>. Functions with the result type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">procedures</EM>. Anonymous functions in source code are called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">function literals</EM>. At run time, function literals are instantiated into objects called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">function values</EM>.</P>
<P><A id=g1911543911></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">function literal</SPAN>&nbsp;&nbsp;A function with no name in Scala source code, specified with function literal syntax. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int,</SPAN>&nbsp;<SPAN class=code>y:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN>.</P>
<P><A id=g1731647273></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">function value</SPAN>&nbsp;&nbsp; A function object that can be invoked just like any other function. A function value's class extends one of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>FunctionN</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>traits (<I>e.g.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function0</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function1</SPAN>) from package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN>, and is usually expressed in source code via<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">function literal</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>syntax. A function value is "invoked" when its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is called. A function value that captures free variables is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">closure</EM>.</P>
<P><A id=g1434668372></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">functional style</SPAN>&nbsp;&nbsp; The<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">functional style</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of programming emphasizes functions and evaluation results and deemphasizes the order in which operations occur. The style is characterized by passing function values into looping methods, immutable data, methods with no side effects. It is the dominant paradigm of languages such as Haskell and Erlang, and contrasts with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">imperative style</EM>.</P>
<P><A id=g286956243></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">generator</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">generator</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>defines a named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and assigns to it a series of values in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. For example, in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for(i</SPAN>&nbsp;<SPAN class=code>&lt;-</SPAN>&nbsp;<SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code>10)</SPAN>, the generator is "<SPAN class=code>i</SPAN>&nbsp;<SPAN class=code>&lt;-</SPAN>&nbsp;<SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code>10</SPAN>". The value to the right of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;-</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">generator expression</EM>.</P>
<P><A id=g-2128716283></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">generator expression</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">generator expression</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>generates a series of values in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. For example, in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for(i</SPAN>&nbsp;<SPAN class=code>&lt;-</SPAN>&nbsp;<SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code>10)</SPAN>, the generator expression is "<SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>to</SPAN>&nbsp;<SPAN class=code>10</SPAN>".</P>
<P><A id=g-1372927505></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">generic class</SPAN>&nbsp;&nbsp; A class that takes type parameters. For example, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes a type parameter,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a generic class.</P>
<P><A id=g-1357049211></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">generic trait</SPAN>&nbsp;&nbsp; A trait that takes type parameters. For example, because trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.collection.Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes a type parameter, it is a generic trait.</P>
<P><A id=g-59832310></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">helper function</SPAN>&nbsp;&nbsp; A function whose purpose is to provide a service to one or more other functions nearby. Helper functions are often implemented as local functions.</P>
<P><A id=g-1128216173></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">helper method</SPAN>&nbsp;&nbsp; A helper function that's a member of a class. Helper methods are often private.</P>
<P><A id=g1596987778></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">immutable</SPAN>&nbsp;&nbsp; An object is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">immutable</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>if its value cannot be changed after it is created in any way visible to clients. Objects may or may not be immutable.</P>
<P><A id=g148663933></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">imperative style</SPAN>&nbsp;&nbsp; The<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">imperative style</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of programming emphasizes careful sequencing of operations so that their effects happen in the right order. The style is characterized by iteration with loops, mutating data in place, and methods with side effects. It is the dominant paradigm of languages such as C, C++, C# and Java, and contrasts with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">functional style</EM>.</P>
<P><A id=g871091088></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">initialize</SPAN>&nbsp;&nbsp; When a variable is defined in Scala source code, you must<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">initialize</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>it with an object.</P>
<P><A id=g555127957></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">instance</SPAN>&nbsp;&nbsp; An<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">instance</EM>, or class instance, is an object, a concept that exists only at run time.</P>
<P><A id=g-2086173974></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">instantiate</SPAN>&nbsp;&nbsp; To<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">instantiate</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>a class is to make a new object from the class,<SPAN class=Apple-converted-space>&nbsp;</SPAN>an action that happens only at run time.</P>
<P><A id=g-2131763264></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">invariant</SPAN>&nbsp;&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Invariant</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used in two ways. It can mean a property that always holds true when a data structure is well-formed. For example, it is an invariant of a sorted binary tree that each node is ordered before its right subnode, if it has a right subnode.<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Invariant</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is also sometimes used as a synonym for nonvariant: "class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is invariant in its type parameter."</P>
<P><A id=g-1183693704></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">invoke</SPAN>&nbsp;&nbsp; You can<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">invoke</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>a method, function, or closure<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">on</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments, meaning its body will be executed with the specified arguments.</P>
<P><A id=g73857></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">JVM</SPAN>&nbsp;&nbsp; The<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">JVM</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the Java Virtual Machine, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">runtime</EM>, that hosts a running Scala program.</P>
<P><A id=g182460591></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">literal</SPAN>&nbsp;&nbsp;<SPAN class=code>1</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"One"</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are examples of<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">literals</EM>. A literal is a shorthand way to describe an object, where the shorthand exactly mirrors the structure of the created object.</P>
<P><A id=g43293933></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">local function</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">local function</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defined inside a block. To contrast, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defined as a member of<SPAN class=Apple-converted-space>&nbsp;</SPAN>a class, trait, or singleton object is called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">method</EM>.</P>
<P><A id=g1707735953></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">local variable</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">local variable</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defined inside a block. Although similar to local variables, parameters to functions are not referred to as local variables, but simply as parameters or "variables" without the "local."</P>
<P><A id=g-1077769574></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">member</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">member</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is any named element of the template of a class, trait, or singleton object. A member may be accessed with the name of its owner, a dot, and its simple name.<SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, top-level fields and methods defined in a class are members of that class. A trait defined inside a class is a member of its enclosing class. A type defined with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>type</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword in a class is a member of that class. A class is a member of the package in which is it defined. By contrast, a local variable or local function is not a member of its surrounding block.</P>
<P><A id=g954925063></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">message</SPAN>&nbsp;&nbsp; Actors communicate with each other by sending each other<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">messages</EM>. Sending a message does not interrupt what the receiver is doing. The receiver can wait until it has finished its current activity and its invariants have been reestablished.</P>
<P><A id=g-850220783></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">meta-programming</SPAN>&nbsp;&nbsp; Meta-programming software is software whose input is itself software. Compilers are meta-programs, as are tools like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scaladoc</SPAN>. Meta-programming software is required in order to do anything with an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">annotation</EM>.</P>
<P><A id=g-1077554975></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">method</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">method</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a function that is a member of some class, trait, or singleton object.</P>
<P><A id=g103910529></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">mixin</SPAN>&nbsp;&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Mixin</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is what a trait is called when it is being used in a mixin composition. In other words, in "<SPAN class=code>trait</SPAN>&nbsp;<SPAN class=code>Hat</SPAN>,"<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Hat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is just a trait, but in "<SPAN class=code>new</SPAN>&nbsp;<SPAN class=code>Cat</SPAN>&nbsp;<SPAN class=code>extends</SPAN>&nbsp;<SPAN class=code>AnyRef</SPAN>&nbsp;<SPAN class=code>with</SPAN>&nbsp;<SPAN class=code>Hat</SPAN>,"<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Hat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be called a mixin. When used as a verb, "mix in" is two words. For example, you can<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">mix</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>traits<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">in</EM>to classes or other traits.</P>
<P><A id=g-528906101></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">mixin composition</SPAN>&nbsp;&nbsp; The process of mixing traits into classes or other traits.<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Mixin composition</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>differs from traditional<SPAN class=Apple-converted-space>&nbsp;</SPAN>multiple inheritance in that the type of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>reference is not known at the point the trait is defined, but rather is determined anew each time the trait is mixed into a class or other trait.</P>
<P><A id=g-615513385></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">modifier</SPAN>&nbsp;&nbsp; A keyword that qualifies a class, trait, field, or method definition in some way. For example, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier indicates that a class, trait, field, or method being defined is private.</P>
<P><A id=g-181260432></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">multiple definitions</SPAN>&nbsp;&nbsp; The same expression can be assigned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">multiple definitions</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>if you use the syntax<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>&nbsp;<SPAN class=code><I>v1</I>,</SPAN>&nbsp;<SPAN class=code><I>v2</I>,</SPAN>&nbsp;<SPAN class=code><I>v3</I></SPAN>&nbsp;<SPAN class=code>=</SPAN>&nbsp;<SPAN class=code><I>exp</I></SPAN>.</P>
<P><A id=g-233237224></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">nonvariant</SPAN>&nbsp;&nbsp; A type parameter of a class or trait is by default<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">nonvariant</EM>. The class or trait then does not subtype when that parameter changes. For example, because class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN>is nonvariant in its type parameter,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is neither a subtype nor a supertype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[Any]</SPAN>.</P>
<P><A id=g1662702951></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">operation</SPAN>&nbsp;&nbsp; In Scala, every<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">operation</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a method call. Methods may be invoked in<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">operator notation</EM>, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>2</SPAN>, and when in that notation,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">operator</EM>.</P>
<P><A id=g1954460585></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">parameter</SPAN>&nbsp;&nbsp; Functions may take zero to many<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">parameters</EM>. Each parameter has a name and a type. The<A id=i-1413740950-1></A><A id=i-1309185960-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>distinction<SPAN class=Apple-converted-space>&nbsp;</SPAN>between parameters and arguments is that arguments refer to the actual objects passed when a function is invoked. Parameters are the variables that refer to those passed arguments.</P>
<P><A id=g-1701137034></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">parameterless function</SPAN>&nbsp;&nbsp; A function that takes no parameters, which is defined without any empty parentheses. Invocations of parameterless functions may not supply parentheses. This supports the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">uniform access principle</EM>, which enables the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be changed into a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>without requiring a change to client code.</P>
<P><A id=g-1903107585></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">parameterless method</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">parameterless method</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a parameterless function that is a member of a class, trait, or singleton object.</P>
<P><A id=g-1177929110></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">parametric field</SPAN>&nbsp;&nbsp; A field defined as a class parameter.</P>
<P><A id=g-1880499411></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">partially applied function</SPAN>&nbsp;&nbsp; A function that's used in an expression and that misses some of its arguments. For instance, if function<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Int</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Int</SPAN>, then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f(1)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are<EM style="FONT-STYLE: italic">partially applied functions</EM>.</P>
<P><A id=g1121900131></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">path-dependent type</SPAN>&nbsp;&nbsp; A type like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>swiss.cow.Food</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>swiss.cow</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>part is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">path</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>that forms a reference to an object.<SPAN class=Apple-converted-space>&nbsp;</SPAN>The meaning of the type is sensitive to the path you use to access it. The types<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>swiss.cow.Food</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>fish.Food</SPAN>, for example,<SPAN class=Apple-converted-space>&nbsp;</SPAN>are different types.</P>
<P><A id=g-791090288></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">pattern</SPAN>&nbsp;&nbsp; In a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression alternative, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">pattern</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>follows each<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>case</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword and precedes either a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">pattern guard</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>or the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>symbol.</P>
<P><A id=g624636437></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">pattern guard</SPAN>&nbsp;&nbsp; In a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression alternative, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">pattern guard</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>can follow a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">pattern</EM>. For example, in "<SPAN class=code>case</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>if</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>%</SPAN>&nbsp;<SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>0</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>1</SPAN>", the pattern guard is "<SPAN class=code>if</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>%</SPAN>&nbsp;<SPAN class=code>2</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>0</SPAN>". A case with a pattern guard will only be selected if the pattern matches and the pattern guard yields true.</P>
<P><A id=g-1348032073></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">predicate</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">predicate</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a function with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>result type.</P>
<P><A id=g-1733976356></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">primary constructor</SPAN>&nbsp;&nbsp; The main constructor of a class, which invokes a superclass constructor, if necessary, initializes fields to passed values, and executes any top-level code defined between the curly braces of the class. Fields are initialized only for value parameters not passed to the superclass constructor, except for any that are not used in the body of the class and can therefore by optimized away.</P>
<P><A id=g-1095204141></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">procedure</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">procedure</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a function with result type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN>, which is therefore executed solely<SPAN class=Apple-converted-space>&nbsp;</SPAN>for its side effects.</P>
<P><A id=g1752969532></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">reassignable</SPAN>&nbsp;&nbsp; A variable may or may not be<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">reassignable</EM>. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is reassignable while a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not.</P>
<P><A id=g1165780018></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">recursive</SPAN>&nbsp;&nbsp; A function is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">recursive</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>if it calls itself. If the only place the function calls itself is the last expression of the function, then the function is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">tail recursive</EM>.</P>
<P><A id=g-925155509></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">reference</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">reference</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the Java abstraction of a pointer, which uniquely identifies an object that resides on the JVM's heap. Reference type variables hold references to objects, because reference types (instances of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>) are implemented as Java objects that reside on the JVM's heap.<A id=i-396510763-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Value type variables, by contrast, may sometimes hold a reference (to a boxed wrapper type) and sometimes not (when the object is being represented as a primitive value). Speaking generally, a Scala variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">refers</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>to an object. The term "refers" is more abstract than "holds a reference." If a variable of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is currently represented as a primitive Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, then that variable still refers to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>object, but no reference is involved.</P>
<P><A id=g1293228591></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">reference equality</SPAN>&nbsp;&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Reference equality</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>means that two references identify the very same Java object. Reference equality can be determined, for reference types only, by calling<SPAN class=code>eq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>. (In Java programs, reference equality can be determined using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on Java reference types.)</P>
<P><A id=g-1958144273></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">reference type</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">reference type</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>. Instances of reference types always reside on the JVM's heap at run time.</P>
<P><A id=g-1825668081></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">referential transparency</SPAN>&nbsp;&nbsp; A property of functions that are independent of temporal context and have no side effects. For a particular input, an invocation of a referentially transparent function can be replaced by its result without changing the program semantics.</P>
<P><A id=g-934829069></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">refers</SPAN>&nbsp;&nbsp; A variable in a running Scala program always<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">refers</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>to some object. Even if that variable is assigned to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN>, it conceptually refers to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object. At runtime, an object may be implemented by a Java object or a value of a primitive type, but Scala allows programmers to think at a higher level of abstraction about their code as they imagine it running. See also<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">reference</EM>.</P>
<P><A id=g-934426595></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">result</SPAN>&nbsp;&nbsp; An expression in a Scala program yields a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">result</EM>. The result of every expression in Scala is an object.</P>
<P><A id=g-595246755></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">result type</SPAN>&nbsp;&nbsp; A method's<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">result type</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the type of the value that results from calling the method. (In Java, this concept is called the return type.)</P>
<P><A id=g-934396624></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">return</SPAN>&nbsp;&nbsp; A function in a Scala program<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">returns</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>a value. You can call this value the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">result</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the function. You can also say the function<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">results in</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>the value. The result of every function in Scala is an object.</P>
<P><A id=g1550962648></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">runtime</SPAN>&nbsp;&nbsp; The Java Virtual Machine, or JVM, that hosts a running Scala program.<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Runtime</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>encompasses both the virtual machine, as defined by the Java Virtual Machine Specification, and the runtime libraries of the Java API and the standard Scala API. The phrase<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">at run time</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>(with a space between<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">run</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">time</EM>)<SPAN class=Apple-converted-space>&nbsp;</SPAN>means when the program is running, and contrasts with compile time.</P>
<P><A id=g1877464706></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">runtime type</SPAN>&nbsp;&nbsp; The type of an object at run time. To contrast, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">static type</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the type of an expression at compile time. Most runtime types are simply bare classes with no type parameters. For example, the runtime type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"Hi"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>, and the runtime type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function1</SPAN>. Runtime types can be tested with<A id=i-901220338-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isInstanceOf</SPAN>.</P>
<P><A id=g-907685685></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">script</SPAN>&nbsp;&nbsp; A file containing top level definitions and statements, which can be run directly with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>without explicitly compiling. A script must end in an expression, not a definition.</P>
<P><A id=g1191572447></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">selector</SPAN>&nbsp;&nbsp; The value being matched on in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. For example, in "<SPAN class=code>s</SPAN>&nbsp;<SPAN class=code>match</SPAN>&nbsp;<SPAN class=code>{</SPAN>&nbsp;<SPAN class=code>case</SPAN>&nbsp;<SPAN class=code>_</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>}</SPAN>", the selector is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s</SPAN>.</P>
<P><A id=g-1749196914></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">self type</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">self type</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of a trait is the assumed type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN>, the receiver, to be used within the trait. Any concrete class that mixes in the trait must ensure that its type conforms to the trait's self type. The most common use of self types is for dividing a large class into several traits as described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/modular-programming-using-objects.html">Chapter 27</A>.</P>
<P><A id=g-408699718></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">semi-structured data</SPAN>&nbsp;&nbsp; XML data is semi-structured. It is more structured than a flat binary file or text file, but it does not have the full structure of a programming language's data structures.</P>
<P><A id=g922807280></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">serialization</SPAN>&nbsp;&nbsp; You can<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">serialize</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>an object into a byte stream which can then be saved to files or transmitted over the network. You can later<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">deserialize</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>the byte stream, even on different computer, and obtain an object that is the same as the original serialized object.</P>
<P><A id=g-903579360></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">shadow</SPAN>&nbsp;&nbsp; A new declaration of a local variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">shadows</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>one of the same name in an enclosing scope.</P>
<P><A id=g1073584312></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">signature</SPAN>&nbsp;&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Signature</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is short for<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">type signature</EM>.</P>
<P><A id=g775061748></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">singleton object</SPAN>&nbsp;&nbsp; An object defined with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>object</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword. Each<SPAN class=Apple-converted-space>&nbsp;</SPAN>singleton object has one and only one instance. A singleton object that shares its name with a class, and is defined in the same source file as that class, is that class's<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">companion object</EM>. The class is its<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">companion class</EM>. A singleton object that doesn't have a companion class is a<EM style="FONT-STYLE: italic">standalone object</EM>.</P>
<P><A id=g1856979834></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">standalone object</SPAN>&nbsp;&nbsp;A singleton object that has no companion class.</P>
<P><A id=g-2085148305></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">statement</SPAN>&nbsp;&nbsp; An expression, definition, or import,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, things that can go into a template or a block in Scala source code.</P>
<P><A id=g827426220></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">static type</SPAN>&nbsp;&nbsp;See<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">type</EM>.</P>
<P><A id=g-2076126408></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">subclass</SPAN>&nbsp;&nbsp; A class is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">subclass</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of all of its superclasses and supertraits.</P>
<P><A id=g-2060248114></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">subtrait</SPAN>&nbsp;&nbsp; A trait is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">subtrait</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of all of its supertraits.</P>
<P><A id=g-1867567750></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">subtype</SPAN>&nbsp;&nbsp; The Scala compiler will allow any of a type's<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">subtypes</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be used as a substitute wherever that type is required. For classes and traits that take no type<A id=i-155377413-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameters, the subtype relationship mirrors the subclass relationship. For example, if class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subclass of abstract class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN>, and neither takes type parameters, type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN>. Likewise, if trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtrait of trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruit</SPAN>, and neither takes type parameters, type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruit</SPAN>. For classes and traits that take type parameters, however, variance comes into play. For example, because abstract class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is declared to be covariant in its lone type parameter (<I>i.e.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is declared<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[+A]</SPAN>),<SPAN class=code>List[Cat]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Animal]</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Apple]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Fruit]</SPAN>. These subtype relationships exist even though the class of each of these types is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. By contrast, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not declared to be covariant in its type parameter (<I>i.e.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is declared<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set[A]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with no plus sign),<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set[Cat]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">not</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set[Animal]</SPAN>. A subtype should correctly implement the contracts of its supertypes, so that the Liskov Substitution Principle applies, but the compiler only verifies this property at the level of type checking.</P>
<P><A id=g-1714704675></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">superclass</SPAN>&nbsp;&nbsp; A class's<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">superclasses</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>include its direct superclass, its direct superclass's direct superclass, and so on, all the way up to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>.</P>
<P><A id=g-1698826381></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">supertrait</SPAN>&nbsp;&nbsp; A class's or trait's<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">supertraits</EM>, if any, include all traits directly mixed into the class or trait or any of its superclasses, plus any supertraits of those traits.</P>
<P><A id=g-331888331></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">supertype</SPAN>&nbsp;&nbsp; A type is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">supertype</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of all of its subtypes.</P>
<P><A id=g1908038877></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">synthetic class</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">synthetic class</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is generated automatically by the compiler rather than being written by hand by the programmer.</P>
<P><A id=g2133301346></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">tail recursive</SPAN>&nbsp;&nbsp; A function is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">tail recursive</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the only place the function calls itself is the last operation of the function.</P>
<P><A id=g-1884158234></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">target typing</SPAN>&nbsp;&nbsp;<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Target typing</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a form of type inference that takes into account the type that's expected. In<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>nums.filter((x)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>0)</SPAN>, for example, the Scala compiler infers type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>to be the element type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>nums</SPAN>, because the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method invokes the function on each element of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>nums</SPAN>.</P>
<P><A id=g-1321546630></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">template</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">template</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the body of a class, trait, or singleton object definition.<A id=i-1722035434-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It defines the type signature, behavior and initial state of the class, trait, or object.</P>
<P><A id=g110621198></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">trait</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">trait</EM>, which is defined with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>trait</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword, is like an abstract class that cannot take any value parameters and can be "mixed into" classes or other traits via the process known as<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">mixin composition</EM>. When a trait is being mixed into a class or trait, it is called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">mixin</EM>. A trait may be parameterized with one or more types. When parameterized with types, the trait constructs a type. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a trait that takes a single type parameter, whereas<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set[Int]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a type. Also,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is said to be "the trait of" type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set[Int]</SPAN>.</P>
<P><A id=g3575610></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">type</SPAN>&nbsp;&nbsp; Every variable and expression in a Scala program has a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">type</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>that is known at compile time. A type restricts the possible values to which a variable can refer, or an expression can produce, at run time. A variable or expression's type can also<A id=i-1395189617-1></A><A id=i-1148073513-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>be referred to as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">static type</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>if necessary to differentiate it from an object's<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">runtime type</EM>. In other words, "type" by itself means static type. Type is distinct from class because a class that takes type parameters can construct many types. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a class, but not a type.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a type with a free type parameter.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Int]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are also types (called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">ground types</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>because they have no free type parameters).<A id=i-1740168280-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>A type can have a "class" or "trait." For example, the class of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Int]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. The trait of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN>.</P>
<P><A id=g1827075715></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">type constraint</SPAN>&nbsp;&nbsp; Some annotations are<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">type constraints</EM>, meaning that they add additional limits, or constraints, on what values the type includes. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@positive</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>could be a type constraint on the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>, limiting the type of 32-bit integers down to those that are positive. Type constraints are not checked by the standard Scala compiler, but must instead be checked by an extra tool or by a compiler plugin.</P>
<P><A id=g823069716></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">type constructor</SPAN>&nbsp;&nbsp; A class or trait that takes type parameters.</P>
<P><A id=g772613699></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">type parameter</SPAN>&nbsp;&nbsp; A parameter to a generic class or generic method that must be filled in by a type. For example, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined as "<SPAN class=code>class</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>{ ...", and method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>identity</SPAN>, a member of object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Predef</SPAN>, is defined as "<SPAN class=code>def</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>identity[T](x:T)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>". The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in both cases is a type parameter.</P>
<P><A id=g-108262574></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">type signature</SPAN>&nbsp;&nbsp; A method's<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">type signature</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>comprises its name, the number, order, and types of its parameters, if any, and its result type. The type signature of a class, trait, or singleton object comprises its name, the type signatures of all of its members and constructors, and its declared inheritance and mixin relations.</P>
<P><A id=g729932460></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">uniform access principle</SPAN>&nbsp;&nbsp; The<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">uniform access principle</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>states that variables and parameterless functions should be accessed using the same syntax. Scala supports this principle by not allowing parentheses to be placed at call sites of parameterless functions. As a result, a parameterless function definition can be changed to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>vice versa</I>, without affecting client code.</P>
<P><A id=g-1065891116></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">unreachable</SPAN>&nbsp;&nbsp; At the Scala level, objects can become<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">unreachable</EM>, at which point<SPAN class=Apple-converted-space>&nbsp;</SPAN>the memory they occupy may be reclaimed by the runtime. Unreachable does not necessarily mean unreferenced. Reference types (instances of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>) are implemented as objects that reside on the JVM's heap. When an instance of a reference type becomes unreachable, it indeed becomes unreferenced, and is available for garbage collection. Value types (instances of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyVal</SPAN>) are implemented as both primitive type values and as instances of<SPAN class=Apple-converted-space>&nbsp;</SPAN>Java wrapper types (such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Integer</SPAN>), which reside on the heap. Value type instances can be boxed (converted from a primitive value to a wrapper object) and unboxed (converted from a wrapper object to a primitive value) throughout the lifetime of the variables that refer to them. If a value type instance currently represented as a wrapper object on the JVM's heap becomes unreachable, it indeed becomes unreferenced, and is available for garbage collection. But if a value type currently represented as a primitive value becomes unreachable, then it does not become unreferenced, because it does not exist as an object on the JVM's heap at that point in time. The runtime may reclaim memory occupied by unreachable objects, but if an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>, for example, is implemented at run time by a primitive Java<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that occupies some memory in the stack frame of an executing method, then the memory for that object is "reclaimed" when the stack frame is popped as<SPAN class=Apple-converted-space>&nbsp;</SPAN>the method completes. Memory for reference types, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>s, may be reclaimed by the JVM's garbage collector after they become unreachable.</P>
<P><A id=g-788394542></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">unreferenced</SPAN>&nbsp;&nbsp; See<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">unreachable</EM>.</P>
<P><A id=g111972721></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">value</SPAN>&nbsp;&nbsp; The result of any computation or expression in Scala is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">value</EM>, and in Scala, every value is an object. The term value essentially means the image of an object in memory (on the JVM's heap or stack).</P>
<P><A id=g1985162377></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">value type</SPAN>&nbsp;&nbsp; A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">value type</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is any subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyVal</SPAN>, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN>. This term has meaning at the level of Scala source code. At runtime, instances of value types that correspond to Java primitive types may be implemented in terms of primitive type values or instances of wrapper types, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Integer</SPAN>. Over the lifetime of a value type instance, the runtime may transform it back and forth between primitive and wrapper types (<I>i.e.</I>, to box and unbox it).</P>
<P><A id=g-1249586564></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">variable</SPAN>&nbsp;&nbsp; A named entity that refers to an object. A variable is either a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>. Both<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s must be initialized when defined, but only<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s can be later reassigned to refer to a different object.</P>
<P><A id=g-1249575311></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">variance</SPAN>&nbsp;&nbsp; A type parameter of a class or trait can be marked with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">variance</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>annotation, either<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">covariant</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<SPAN class=code>+</SPAN>) or<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">contravariant</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<SPAN class=code>-</SPAN>). Such variance annotations indicate how subtyping works for a generic class or trait. For example, the generic class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is covariant in its type parameter, and thus<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Any]</SPAN>. By default,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, absent a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>annotation, type parameters are<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">nonvariant</EM>.</P>
<P><A id=g114974605></A><SPAN class=glossaryname style="FONT-WEIGHT: bold">yield</SPAN>&nbsp;&nbsp; An expression can<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">yield</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>a result. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>yield</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword designates the result of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression.</P></DIV></DIV>