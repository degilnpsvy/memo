<DIV class=navheader style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<TABLE width="100%" summary="Navigation header">
<TBODY>
<TR>
<TH align=middle colSpan=3>5.5.&nbsp;Architecture Classifications</TH></TR>
<TR>
<TD align=left width="20%"><A accessKey=p href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch05s04.html">Prev</A>&nbsp;</TD>
<TH align=middle width="60%">Chapter&nbsp;5.&nbsp;The MIPS Architecture</TH>
<TD align=right width="20%">&nbsp;<A accessKey=n href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch05s06.html">Next</A></TD></TR></TBODY></TABLE>
<HR>
</DIV>
<DIV class=section title="5.5.&nbsp;Architecture Classifications" style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=id286959674></A>5.5.&nbsp;Architecture Classifications</H2></DIV></DIV></DIV>
<DIV class=section title="5.5.1.&nbsp;Classification by Instruction Operands">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286959677></A>5.5.1.&nbsp;Classification by Instruction Operands</H3></DIV></DIV></DIV>
<P>Memory-to-memory (VAX, PDP series) architectures allow more than one operand of most instructions to access memory. They often allow up to three operands per instruction, all of which can be either data registers or memory addresses.</P><PRE class=programlisting>	    addl3   a, b, sum
	    </PRE>
<P>Register-memory (x86, 68k) architectures allow only one operand of most instructions to access memory. The other operand must be a CPU register. Most register-memory CPUs allow no more than two operands per instruction.</P>
<P>Compared with memory-to-memory, these processors cost less. Individual instructions execute faster due to fewer memory accesses, but it takes more instructions to accomplish the same task.</P><PRE class=programlisting>	    movl    eax, a
	    addl    eax, b
	    movl    sum, eax
	    </PRE>
<P>Load-store (MIPS, Sun Sparc, ARM) architectures do not allow most instructions to access memory. Only load and store instructions, which simply move data between registers and memory, can access memory. All other instructions get their operands from, and store their results in registers.</P>
<P>Most instructions in load-store CPUs execute very fast (often in a single clock cycle) since they operate entirely within the CPU. However, load-store architectures require the longest sequences of instructions to accomplish a given task, since it takes separate instructions to load operands from memory, perform operations such as addition, subtraction, etc., and store the results in memory.</P>
<P>Note, however, that intermediate results do not have to be stored in memory at all, so the situation is not as dire as it may seem at first. Most load-store architectures have a large number of CPU registers so that memory access can be minimized.</P><PRE class=programlisting>	    lw      $t0, a
	    lw      $t1, b
	    add     $t2, $t0, $t1
	    sw      $t2, sum
	    </PRE>
<P>Accumulator-based, A.K.A. one-operand (8051, 68HC12) architectures allow only one operand per instruction. The other operand, where two operands are required, is a special register called the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>accumulator</EM>, and is implicit.</P>
<P>Most early processors were accumulator-based, and many low-cost embedded processors today use this architecture.</P><PRE class=programlisting>	    ld      a
	    add     b
	    st      sum
	    </PRE></DIV>
<DIV class=section title="5.5.2.&nbsp;Classification by Memory Structure">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286959710></A>5.5.2.&nbsp;Classification by Memory Structure</H3></DIV></DIV></DIV>
<P>In a Von-Neumann architecture, a single<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>memory address space</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains the machine instructions of running programs as well as data. In such a system, there is only one memory address 0, 1, 2, and so on. This style of architecture is named after John Von Neumann, a Hungarian-American mathematician. Most general-purpose computers use this architecture.</P>
<P><IMG src="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/Images/VonNeumann.jpg"></P>
<P>In a Harvard architecture, machine code and data are stored in separate memory units connected by different busses. Since there are two (or more) memory address spaces, there are two memory cells with address 0 (one in the code memory and one in the data memory), two with address 1, and so on. The Harvard architecture is often used for microcontrollers, where the program (called firmware) is stored in a non-volatile EEPROM such as Flash memory so that it remains when the power is off. The tradition volatile RAM is used only for data.</P></DIV>
<DIV class=section title="5.5.3.&nbsp;Classification by Complexity">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286959728></A>5.5.3.&nbsp;Classification by Complexity</H3></DIV></DIV></DIV>
<P>Complex Instruction Set Computers (CISC) tend to have a large number of instructions (often hundreds), and either memory-to-memory or register-memory organization. Examples include the VAX, x86 series, and Motorola 68000 series. Many instructions require multiple clock cycles to complete, due in part to the ability to access memory.</P>
<P>Reduced Instruction Set Computers (RISC) have far fewer instructions (typically a few dozen), and are usually load-store architectures. They tend to have a large number of registers. Most instructions execute in one or a few clock cycles.</P></DIV></DIV>
<DIV class=navfooter style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<HR>

<TABLE width="100%" summary="Navigation footer">
<TBODY>
<TR>
<TD align=left width="40%"><A accessKey=p href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch05s04.html">Prev</A>&nbsp;</TD>
<TD align=middle width="20%"><A accessKey=u href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch05.html">Up</A></TD>
<TD align=right width="40%">&nbsp;<A accessKey=n href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch05s06.html">Next</A></TD></TR>
<TR>
<TD vAlign=top align=left width="40%">5.4.&nbsp;MAL: MIPS Assembly Language&nbsp;</TD>
<TD align=middle width="20%"><A accessKey=h href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/index.html">Home</A></TD>
<TD vAlign=top align=right width="40%">&nbsp;5.6.&nbsp;The Instruction Cycle</TD></TR></TBODY></TABLE></DIV>