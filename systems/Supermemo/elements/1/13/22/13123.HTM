<DIV class=navheader style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<TABLE width="100%" summary="Navigation header">
<TBODY>
<TR>
<TH align=middle colSpan=3>15.4.&nbsp;Interrupts</TH></TR>
<TR>
<TD align=left width="20%"><A accessKey=p href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch15s03.html">Prev</A>&nbsp;</TD>
<TH align=middle width="60%">Chapter&nbsp;15.&nbsp;Exceptions</TH>
<TD align=right width="20%">&nbsp;<A accessKey=n href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch15s05.html">Next</A></TD></TR></TBODY></TABLE>
<HR>
</DIV>
<DIV class=section title=15.4.&nbsp;Interrupts style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=id286966416></A>15.4.&nbsp;Interrupts</H2></DIV></DIV></DIV>
<DIV class=section title="15.4.1.&nbsp;The Solution to Polling">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286966419></A>15.4.1.&nbsp;The Solution to Polling</H3></DIV></DIV></DIV>
<P></P>
<P>As discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=xref title=Chapter&nbsp;14.&nbsp;Input/Output href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch14.html">Chapter&nbsp;14,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>Input/Output</I></A>, there are problems with spin waiting and periodic polling for which there is no software solution. In spin waiting, software maniacally asks a device if it is ready until the device says yes. In periodic polling, software has a hard time polling at the correct frequency and times to ensure catching all I/O events without wasting too much time on polling.</P>
<P>Interrupts are a hardware-based solution to the problems with software polling. Whether software polling or interrupts are used, each I/O device must have a way to indicate that it requires service or is ready to serve. This is generally done by changing the status of a single wire connected to the CPU. This wire is often called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>flag</EM>.</P>
<P>Interrupts are essentially a form of<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>hardware polling</EM>. The interrupt mechanism removes the burden of polling devices from software, but adding hardware to the CPU to check I/O device flags during every instruction cycle. Generally, the only role played by the interrupt hardware is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>detecting</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>when I/O devices are ready. Once an event is detected, it is up to software to actually perform the I/O transaction.</P>
<P>Note that there is no extra time cost involved in the interrupt detection, since added hardware checks the flags at the same time other parts of the CPU are executing the current instruction.</P></DIV>
<DIV class=section title="15.4.2.&nbsp;Interfacing with Interrupt Handlers">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286966446></A>15.4.2.&nbsp;Interfacing with Interrupt Handlers</H3></DIV></DIV></DIV>
<P>Input ISR places incoming data in a queue (ring buffer)</P>
<P>User programs call a subprogram such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE class=code>getc</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to Differences between software-polled and interrupt-driven I/O are isolated within getc. Program should work the same whether getc uses software polling or reads from a queue</P>
<P>Blocking: getc does not return until something appears in the queue due to an interrupt</P>
<P>Non-blocking: If queue is empty, getc returns immediately.</P></DIV></DIV>
<DIV class=navfooter style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<HR>

<TABLE width="100%" summary="Navigation footer">
<TBODY>
<TR>
<TD align=left width="40%"><A accessKey=p href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch15s03.html">Prev</A>&nbsp;</TD>
<TD align=middle width="20%"><A accessKey=u href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch15.html">Up</A></TD>
<TD align=right width="40%">&nbsp;<A accessKey=n href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch15s05.html">Next</A></TD></TR>
<TR>
<TD vAlign=top align=left width="40%">15.3.&nbsp;Traps&nbsp;</TD>
<TD align=middle width="20%"><A accessKey=h href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/index.html">Home</A></TD>
<TD vAlign=top align=right width="40%">&nbsp;15.5.&nbsp;MIPS Exception Handling</TD></TR></TBODY></TABLE></DIV>