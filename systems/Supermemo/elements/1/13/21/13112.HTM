<DIV class=navheader style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<TABLE width="100%" summary="Navigation header">
<TBODY>
<TR>
<TH align=middle colSpan=3>13.2.&nbsp;Logic Operations</TH></TR>
<TR>
<TD align=left width="20%"><A accessKey=p href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch13.html">Prev</A>&nbsp;</TD>
<TH align=middle width="60%">Chapter&nbsp;13.&nbsp;Logic and Shift Operations</TH>
<TD align=right width="20%">&nbsp;<A accessKey=n href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch13s03.html">Next</A></TD></TR></TBODY></TABLE>
<HR>
</DIV>
<DIV class=section title="13.2.&nbsp;Logic Operations" style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=id286964942></A>13.2.&nbsp;Logic Operations</H2></DIV></DIV></DIV>
<DIV class=section title="13.2.1.&nbsp;Logic Basics">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286964948></A>13.2.1.&nbsp;Logic Basics</H3></DIV></DIV></DIV>
<P>Logic operations include any operations that manipulate<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>Boolean</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>values.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=indexterm name=id286964958></A>Boolean values are either true or false. They are named after English mathematician George Boole, who invented Boolean algebra, and is widely considered the founder of computer science theory. They can also be represented as 1 and 0. Normally, 1 represents true, and 0 represents false, but it could be the other way around.</P>
<P>The basic Boolean operators are<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>and</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>(^),<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>or</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>(v), and<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>not</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>('). In settings where Boolean operators are not mixed with mathematical operators, or is sometimes written as + and and as *. We will avoid this notation to prevent confusion with addition and multiplication. All Boolean functions can be built from these three basic operators.</P>
<P>Given two Boolean variables A and B, the Boolean expression A ^ B is true only if both A and B are true. The truth table below illustrates all possible combinations with the AND operator.</P>
<DIV class=table><A name=and></A>
<P class=title><B>Table&nbsp;13.1.&nbsp;The AND Operator</B></P>
<DIV class=table-contents>
<TABLE summary="The AND Operator" border=1>
<COLGROUP>
<COL>
<COL>
<COL></COLGROUP>
<THEAD>
<TR>
<TH align=middle>A</TH>
<TH align=middle>B</TH>
<TH align=middle>A ^ B</TH></TR></THEAD>
<TBODY>
<TR>
<TD align=middle>0</TD>
<TD align=middle>0</TD>
<TD align=middle>0</TD></TR>
<TR>
<TD align=middle>0</TD>
<TD align=middle>1</TD>
<TD align=middle>0</TD></TR>
<TR>
<TD align=middle>1</TD>
<TD align=middle>0</TD>
<TD align=middle>0</TD></TR>
<TR>
<TD align=middle>1</TD>
<TD align=middle>1</TD>
<TD align=middle>1</TD></TR></TBODY></TABLE></DIV></DIV><BR class=table-break>
<P>A v B is true if either A or B is true, including the case when both are true.</P>
<DIV class=table><A name=or></A>
<P class=title><B>Table&nbsp;13.2.&nbsp;The OR Operator</B></P>
<DIV class=table-contents>
<TABLE summary="The OR Operator" border=1>
<COLGROUP>
<COL>
<COL>
<COL></COLGROUP>
<THEAD>
<TR>
<TH align=middle>A</TH>
<TH align=middle>B</TH>
<TH align=middle>A v B</TH></TR></THEAD>
<TBODY>
<TR>
<TD align=middle>0</TD>
<TD align=middle>0</TD>
<TD align=middle>0</TD></TR>
<TR>
<TD align=middle>0</TD>
<TD align=middle>1</TD>
<TD align=middle>1</TD></TR>
<TR>
<TD align=middle>1</TD>
<TD align=middle>0</TD>
<TD align=middle>1</TD></TR>
<TR>
<TD align=middle>1</TD>
<TD align=middle>1</TD>
<TD align=middle>1</TD></TR></TBODY></TABLE></DIV></DIV><BR class=table-break>
<P>Not A is true when A is false, and vice-versa.</P>
<DIV class=table><A name=not></A>
<P class=title><B>Table&nbsp;13.3.&nbsp;The NOT Operator</B></P>
<DIV class=table-contents>
<TABLE summary="The NOT Operator" border=1>
<COLGROUP>
<COL>
<COL></COLGROUP>
<THEAD>
<TR>
<TH align=middle>A</TH>
<TH align=middle>A'</TH></TR></THEAD>
<TBODY>
<TR>
<TD align=middle>0</TD>
<TD align=middle>1</TD></TR>
<TR>
<TD align=middle>1</TD>
<TD align=middle>0</TD></TR></TBODY></TABLE></DIV></DIV><BR class=table-break>
<P>Another common operator is the exclusive or (xor) operator. A xor B is defined as A or B, but not both. In other words, A xor B is true if A and B are different. This turns out to be frequently useful, so most computer architectures include an xor instruction.</P>
<P>A xor B = (A ^ B') or (A' ^ B)</P>
<P>All functions in digital computers, including arithmetic operations, are built on these basic logic functions. The full details are covered in a course on digital logic. As a simple example, suppose we add two 1-bit binary numbers A and B. This will result in a 1-bit sum, and a 1-bit carry.</P>
<DIV class=table><A name=adder_truth></A>
<P class=title><B>Table&nbsp;13.4.&nbsp;Adder Truth Table</B></P>
<DIV class=table-contents>
<TABLE summary="Adder Truth Table" border=1>
<COLGROUP>
<COL>
<COL>
<COL>
<COL></COLGROUP>
<THEAD>
<TR>
<TH align=left>A</TH>
<TH align=left>B</TH>
<TH align=left>C</TH>
<TH align=left>S</TH></TR></THEAD>
<TBODY>
<TR>
<TD align=left>0</TD>
<TD align=left>0</TD>
<TD align=left>0</TD>
<TD align=left>0</TD></TR>
<TR>
<TD align=left>0</TD>
<TD align=left>1</TD>
<TD align=left>0</TD>
<TD align=left>1</TD></TR>
<TR>
<TD align=left>1</TD>
<TD align=left>0</TD>
<TD align=left>0</TD>
<TD align=left>1</TD></TR>
<TR>
<TD align=left>1</TD>
<TD align=left>1</TD>
<TD align=left>1</TD>
<TD align=left>0</TD></TR></TBODY></TABLE></DIV></DIV><BR class=table-break>
<P>From the truth table, we can see that S = A xor B, and C = A ^ B. From this basic logic, we can develop a circuit to add N-bit numbers. From these adders, we can develop subtracters, multipliers, and dividers, and eventually an entire arithmetic/logic unit (ALU).</P></DIV>
<DIV class=section title="13.2.2.&nbsp;Logic Instructions">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286965333></A>13.2.2.&nbsp;Logic Instructions</H3></DIV></DIV></DIV>
<P>In machine language, logic instructions perform the same logic operation on all corresponding bits in a word. Suppose X and Y are two 8-bit words with values of 0x23 and 0x4f. We can line up the values as we would when performing an arithmetic operation, and perform a logic operation on corresponding bits instead:</P><PRE class=screen>		00100011        00100011    00100011'       00100011
	    ^   01001111    v   01001111                xor 01001111
	    ----------------------------------------------------------------
		00000011        01101111    11011100        01101100
	    </PRE>
<P>Some architectures have instructions to perform logic operations on various data sizes. For example, the VAX has<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE class=code>andb</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(byte),<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE class=code>andw</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(word) and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE class=code>andl</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(long word) instructions. The MIPS, being a RISC architecture, has a more limited instruction set, and hence all logic operations act on 32-bit words. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE class=code>not</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation is not supported by hardware, but is implemented as a pseudo-instruction. The not operation can be easily achieved by a variety of means.</P><PRE class=screen>	    # and
	    and     $t0, $t2, $t1
	    andi    $t0, $t2, 0xffff0000
	    
	    # or
	    or      $t0, $t2, $t1
	    ori     $t0, $t2, 0xffff0000
	    
	    # not
	    not     $t0, $t1
	    
	    # xor
	    xor     $t0, $t2, $t1
	    xori    $t0, $t2, 0xffff0000
	    
	    # nor
	    nor     $t0, $t2, $t1
	    
	    # not   $t1, $t0
	    xori    $t1, $t0, 0xffffffff
	    nor     $t1, $t0, $t0
	    
	    # slow not
	    sub     $t0, $0, $t0
	    addi    $t0, $t0, -1
	    
	    # Incredibly slow not
	    mul     $t0, $t0, -1
	    addi    $t0, $t0, -1
	    </PRE>
<P>and vs div for detecting odd numbers Can be used in C</P></DIV>
<DIV class=section title="13.2.3.&nbsp;Using Masks">
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id286965368></A>13.2.3.&nbsp;Using Masks</H3></DIV></DIV></DIV>
<P>Logic instructions are commonly used to set (turn on) or clear (reset, turn off) individual bits within a word without affecting other bits.</P>
<P>By ANDing a value with a deliberately designed constant, called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM class=glossterm>bit mask</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>we can clear specific bits. Any bits that are 0 in the mask will be cleared in the result, and bits that are 1 in the mask with be preserved in the result.</P><PRE class=screen>	    value   10010100
	    mask    00001111
	    ----------------
		    00000100
	    </PRE>
<P>Likewise, we can use an OR operation to set bits. A 1 in the mask causes the bit to be set, and a 0 causes it be be preserved.</P><PRE class=screen>	    value   10010100
	    mask    00001111
	    ----------------
		    10011111
	    </PRE>
<P>An XOR can be used to invert (toggle) specific bits. A 1 in the mask causes a bit to be inverted, while a 0 causes it be preserved:</P><PRE class=screen>	    value   10010100
	    mask    00001111
	    ----------------
		    10011011
	    </PRE>
<P>What MAL instruction would we use to set the two rightmost bits in $t0 while leaving the rest alone?</P><PRE class=screen>	    # OR with 0000 0000 0000 0000 0000 0000 0000 0011
	    ori     $t0, $t0, 3
	    </PRE>
<P>What MAL instruction would we use to clear bits 3 and 5 in $t0 while leaving the rest alone?</P><PRE class=screen>	    # AND with 1111 1111 1111 1111 1111 1111 1101 0111
	    andi    $t0, $t0, 0xffffffd7
	    </PRE>
<P>What MAL instruction would be use to toggle the leftmost bit in $t0? ( Sign-magnitude negation )</P><PRE class=screen>	    # XOR with 1000 0000 0000 0000 0000 0000 0000 0000
	    xori    $t0, $t0, 0x80000000
	    </PRE></DIV></DIV>
<DIV class=navfooter style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<HR>

<TABLE width="100%" summary="Navigation footer">
<TBODY>
<TR>
<TD align=left width="40%"><A accessKey=p href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch13.html">Prev</A>&nbsp;</TD>
<TD align=middle width="20%"><A accessKey=u href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch13.html">Up</A></TD>
<TD align=right width="40%">&nbsp;<A accessKey=n href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch13s03.html">Next</A></TD></TR>
<TR>
<TD vAlign=top align=left width="40%">Chapter&nbsp;13.&nbsp;Logic and Shift Operations&nbsp;</TD>
<TD align=middle width="20%"><A accessKey=h href="http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/index.html">Home</A></TD>
<TD vAlign=top align=right width="40%">&nbsp;13.3.&nbsp;Shift Operations</TD></TR></TBODY></TABLE></DIV>