<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 9 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Control Abstraction</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/builtin-control-structures.html">Chapter 7</A>, we pointed out that Scala doesn't have many built-in control abstractions, because it gives you the ability to create your own. In the previous chapter, you learned about function values. In this chapter, we'll show you how to apply function values to create new control abstractions. Along the way, you'll also learn about currying and by-name parameters.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=9.1></A>9.1 Reducing code duplication<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#9.1">link</A>]</SPAN></H3>
<P><A name=sec:reducing-code-dup></A></P>
<P>All functions are separated into common parts, which are the same<A id=i14092899-2></A><A id=i-1950695486-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in every invocation of the function, and non-common parts, which may vary from one function invocation to the next. The common parts are in the body of the function, while the non-common parts must be supplied via arguments. When you use a function value as an argument, the non-common part of the algorithm is itself some other algorithm! At each invocation of such a function, you can pass in a different function value as an argument, and the invoked function will, at times of its choosing, invoke the passed function value. These<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">higher-order functions</EM>&#8212;functions that take functions as parameters&#8212;give you extra opportunities to condense and simplify code<A id=i1069366433-1></A><A id=i319271759-1></A>.</P>
<P>One benefit of higher-order functions is they enable you to create control abstractions that allow you to reduce code duplication. For example, suppose you are writing a file browser, and you want to provide an API that allows users to search for files matching some criterion. First, you add a facility to search for files whose names end in a particular string. This would enable your users to find, for example, all files with a "<SPAN class=texttt>.scala</SPAN>" extension. You could provide such an API by defining a public<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesEnding</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method inside a singleton object like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">FileMatcher</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesHere&nbsp;=&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">java.io.File</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"."</SPAN>)).listFiles
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesEnding(query:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;file.getName.endsWith(query))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;file
  }
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesEnding</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method obtains the list of all files in the current directory<SPAN class=Apple-converted-space>&nbsp;</SPAN>using the private helper method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesHere</SPAN>, then filters them based on whether each file name ends with the user-specified query. Given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesHere</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is private, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesEnding</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is the only accessible method defined in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>FilesMatcher</SPAN>, the API you provide to your users. 
<P></P>
<P>So far so good, and there is no repeated code yet. Later on, though, you decide to let people search based on any part of the file name. This is good for when your users cannot remember if they named a file<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=texttt>phb-important.doc</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=texttt>stupid-phb-report.doc</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=texttt>may2003salesdoc.phb</SPAN>, or something entirely different, but they think that "phb" appears in the name somewhere. You go back to work and add this function to your<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>FileMatcher</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>API:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesContaining(query:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;file.getName.contains(query))
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;file
</PRE>This function works just like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesEnding</SPAN>. It searches<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesHere</SPAN>, checks the name, and returns the file if the name matches. The only difference is that this function uses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contains</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>endsWith</SPAN>. 
<P></P>
<P>The months go by, and the program becomes more successful. Eventually, you give in to the requests of a few power users who want to search based on regular expressions. These sloppy guys have immense directories with thousands of files, and they would like to do things like find all "pdf" files that have "oopsla" in the title somewhere. To support them, you write this function:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesRegex(query:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;file.getName.matches(query))
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;file
</PRE>Experienced programmers will notice all of this repetition and wonder if it can be factored into a common helper function. Doing it the obvious way does not work, however. You would like to be able to do the following:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesMatching(query:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;<I>method</I>)&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;file.getName.<I>method</I>(query))
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;file
</PRE>This approach would work in some dynamic languages, but Scala does not allow pasting together code at runtime like this. So what do you do? 
<P></P>
<P>Function values provide an answer.<A id=i2141458026-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>While you cannot pass around a method name as a value, you can get the same effect by passing around a function value that calls the method for you. In this case, you could add a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>matcher</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter to the method whose sole purpose is to check a file name against a query:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesMatching(query:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;matcher:&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)&nbsp;=&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;matcher(file.getName,&nbsp;query))
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;file
  }
</PRE>In this version of the method, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause now uses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>matcher</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to check the file name against the query. Precisely what this check does depends on what is specified as the matcher. Take a look, now, at the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>matcher</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>itself. It is a function, and thus has a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the type. This function takes two string arguments&#8212;the file name and the query&#8212;and returns a boolean, so the type of this function is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(String,</SPAN>&nbsp;<SPAN class=code>String)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Boolean</SPAN>. 
<P></P>
<P>Given this new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesMatching</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>helper method, you can simplify the three searching methods by having them call the helper method, passing in an appropriate function:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesEnding(query:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=
  &nbsp;&nbsp;filesMatching(query,&nbsp;_.endsWith(_))
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesContaining(query:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=
  &nbsp;&nbsp;filesMatching(query,&nbsp;_.contains(_))
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesRegex(query:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=
  &nbsp;&nbsp;filesMatching(query,&nbsp;_.matches(_))
</PRE>The function literals shown in this example use the placeholder syntax, introduced in the previous chapter, which may not as yet feel very natural to you.<A id=i1101169360-1></A><A id=i788093512-2></A><A id=i-383997826-2></A><A id=i603770043-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Thus, here's a clarification of how placeholders are used in this example. The function literal<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_.endsWith(_)</SPAN>, used in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesEnding</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, means the same thing as:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  (fileName:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;query:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&gt;&nbsp;fileName.endsWith(query)
</PRE>Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesMatching</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes a function that requires two<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments, however, you need not specify the types of the arguments. Thus you could also write<SPAN class=code>(fileName,</SPAN>&nbsp;<SPAN class=code>query)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>fileName.endsWith(query)</SPAN>. Since the parameters are each used only once in the body of the function, and since the first parameter,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>fileName</SPAN>, is used first in the body, and the second parameter,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>query</SPAN>, is used second, you can use the placeholder syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_.endsWith(_)</SPAN>. The first underscore is a placeholder for the first parameter, the file name, and the second underscore a placeholder for the second parameter, the query string. 
<P></P>
<P>This code is already simplified, but it can actually be even shorter. Notice that the query gets passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesMatching</SPAN>, but<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesMatching</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does nothing with the query except to pass it back to the passed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>matcher</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function. This passing back and forth is unnecessary, because the caller already knew the query to begin with! You might as well simply remove the query parameter from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesMatching</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>matcher</SPAN>, thus simplifying the code as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#lst:closures-reduce">Listing 9.1</A>.</P>
<P><A name=lst:closures-reduce></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">FileMatcher</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesHere&nbsp;=&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">java.io.File</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"."</SPAN>)).listFiles
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesMatching(matcher:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(file&nbsp;&lt;-&nbsp;filesHere;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;matcher(file.getName))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;file
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesEnding(query:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filesMatching(_.endsWith(query))
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesContaining(query:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filesMatching(_.contains(query))
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;filesRegex(query:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filesMatching(_.matches(query))
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 9.1 - Using closures to reduce code duplication.</H5>
<P>This example demonstrates the way in which first-class functions can help you eliminate code duplication<A id=i532436688-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>where it would be very difficult to do so without them. In Java, for example, you could create an interface containing a method that takes one<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and returns a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN>, then create and pass anonymous inner class instances that implement this interface to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesMatching</SPAN>. Although this approach would remove the code duplication you are trying to eliminate, it would at the same time add as much or more new code. Thus the benefit is not worth the cost, and you may as well live with the duplication.</P>
<P>Moreover, this example demonstrates how closures can help you reduce code duplication<A id=i1093320088-2></A>. The function literals used in the previous example, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_.endsWith(_)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=code>_.contains(_)</SPAN>, are instantiated at runtime into function values that are<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">not</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>closures, because they don't capture any free variables. Both variables used in the expression,<SPAN class=code>_.endsWith(_)</SPAN>, for example, are represented by underscores, which means they are taken from arguments to the function. Thus,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_.endsWith(_)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>uses two bound variables, and no free variables. By contrast, the function literal<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_.endsWith(query)</SPAN>, used in the most recent example, contains one bound variable, the argument represented by the underscore, and one free variable named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>query</SPAN>. It is only because Scala supports closures that you were able to remove the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>query</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesMatching</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the most recent example, thereby simplifying the code even further.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=9.2></A>9.2 Simplifying client code<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#9.2">link</A>]</SPAN></H3>
<P>The previous example demonstrated that higher-order functions can help reduce code duplication as you implement an API. Another important use of higher-order functions is to put them in an API itself to make client code more concise. A good example is provided by the special-purpose looping methods of Scala's collection types.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#footnote9-1">[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Many of these are listed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#tab:listmethods">Table 3.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html">Chapter 3</A>, but take a look at just one example for now to see why these methods are so useful.</P>
<P>Consider<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN>, a method that determines whether a passed value is contained in a collection<A id=i1794232640-1></A>. You could of course search for an element by having a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>initialized to false, looping through the collection checking each item, and setting the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to true if you find what you are looking for. Here's a method that uses this approach to determine whether a passed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains a negative number:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;containsNeg(nums:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;exists&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(num&nbsp;&lt;-&nbsp;nums)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(num&nbsp;&lt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  &nbsp;&nbsp;exists
  }
</PRE>If you define this method in the interpreter, you can call it like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;containsNeg(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;containsNeg(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>A more concise way to define the method, though, is by calling the higher-order function<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the passed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>, like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;containsNeg(nums:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>)&nbsp;=&nbsp;nums.exists(_&nbsp;&lt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
</PRE>This version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>containsNeg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>yields the same results as the previous:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;containsNeg(<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;containsNeg(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method represents a control abstraction. It is a special-purpose looping construct provided by the Scala library rather than being built into the Scala language like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN>. In the previous section, the higher-order function,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filesMatching</SPAN>, reduces code duplication in the implementation of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>object</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>FileMatcher</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method provides a similar benefit, but because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is public in Scala's collections API, the code duplication it reduces is client code of that API. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>didn't exist, and you wanted to write a<SPAN class=code>containsOdd</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, to test whether a list contains odd numbers, you might write it like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;containsOdd(nums:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;exists&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(num&nbsp;&lt;-&nbsp;nums)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(num&nbsp;%&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  &nbsp;&nbsp;exists
  }
</PRE>If you compare the body of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>containsNeg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with that of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>containsOdd</SPAN>, you'll find that everything is repeated except the test condition of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. Using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN>, you could write this instead:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;containsOdd(nums:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>)&nbsp;=&nbsp;nums.exists(_&nbsp;%&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
</PRE>The body of the code in this version is again identical to the body of the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>containsNeg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method (the version that uses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN>), except the condition for which to searchis different. Yet the amount of code duplication is much smaller because all of the looping infrastructure is factored out into the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method itself. 
<P></P>
<P>There are many other looping methods in Scala's standard library. As with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN>, they can often shorten your code if you recognize opportunities to use them.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=9.3></A>9.3 Currying<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#9.3">link</A>]</SPAN></H3>
<P><A name=sec:currying></A></P>
<P>In Chapter 1, we said that Scala allows you to create new control abstractions that "feel like native language support." Although the examples you've seen so far are indeed control abstractions, it is unlikely anyone would mistake them for native language support. To understand how to make control abstractions that feel more like language extensions, you first need to understand the functional programming technique called<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g575993339"><EM style="FONT-STYLE: italic">currying</EM></A>.<A id=i575993339-1></A></P>
<P>A curried function is applied to multiple argument lists, instead of just one.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#lst:plain-old-function">Listing 9.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a regular, non-curried function, which adds two<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameters,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN>.</P>
<P><A name=lst:plain-old-function></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;plainOldSum(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&nbsp;x&nbsp;+&nbsp;y
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;plainOldSum:&nbsp;(Int,Int)Int</SPAN>
  <BR>  &nbsp;&nbsp;scala&gt;&nbsp;plainOldSum(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;res4:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
</PRE>
<H5>Listing 9.2 - Defining and invoking a "plain old" function.</H5>
<P>By contrast,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#lst:curried-function">Listing 9.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a similar function that's curried. Instead of one list of two<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameters, you apply this function to two lists of one<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter each.</P>
<P><A name=lst:curried-function></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;curriedSum(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)(y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&nbsp;x&nbsp;+&nbsp;y
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;curriedSum:&nbsp;(Int)(Int)Int</SPAN>
  <BR>  &nbsp;&nbsp;scala&gt;&nbsp;curriedSum(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;res5:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
</PRE>
<H5>Listing 9.3 - Defining and invoking a curried function.</H5>
<P>What's happening here is that when you invoke<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>curriedSum</SPAN>, you actually get two traditional function invocations back to back. The first function invocation takes a single<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>parameter named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>, and returns a function value for the second function. This second function takes the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN>. Here's a function named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>first</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that does in spirit what the first traditional function invocation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>curriedSum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would do:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;first(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&nbsp;(y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;y
  <SPAN class=output style="COLOR: rgb(90,0,0)">first:&nbsp;(Int)(Int)&nbsp;=&gt;&nbsp;Int</SPAN>
</PRE>Applying<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the first function&#8212;in other words, invoking the first function and passing in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>&#8212;yields the second function:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;second&nbsp;=&nbsp;first(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">second:&nbsp;(Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function&gt;</SPAN>
</PRE>Applying<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the second function yields the result:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;second(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res6:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
</PRE>These<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>first</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>second</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>functions are just an illustration of the currying process. They are not directly connected to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>curriedSum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function. Nevertheless, there is a way to get an actual reference to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>curriedSum</SPAN>'s "second" function. You can use the placeholder notation to use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>curriedSum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in a partially applied function expression, like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;onePlus&nbsp;=&nbsp;curriedSum(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)_
  <SPAN class=output style="COLOR: rgb(90,0,0)">onePlus:&nbsp;(Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function&gt;</SPAN>
</PRE>The underscore in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>curriedSum(1)_</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a placeholder for the second parameter list.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#footnote9-2">[2]</A><A id=i-877041491-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The result is a reference to a function that, when invoked, adds one to its sole<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument and returns the result:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;onePlus(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res7:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
</PRE>And here's how you'd get a function that adds two to its sole<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;twoPlus&nbsp;=&nbsp;curriedSum(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)_
  <SPAN class=output style="COLOR: rgb(90,0,0)">twoPlus:&nbsp;(Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function&gt;</SPAN>
  <BR>  scala&gt;&nbsp;twoPlus(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res8:&nbsp;Int&nbsp;=&nbsp;4</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=9.4></A>9.4 Writing new control structures<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#9.4">link</A>]</SPAN></H3>
<P><A name=sec:control-structures></A></P>
<P>In languages with first-class functions, you can effectively make new control structures even though the syntax of the language is fixed. All you need to do is create methods that take functions as arguments.</P>
<P>For example, here is the "twice" control structure, which repeats an operation two times and returns the result:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;twice(op:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>,&nbsp;x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>)&nbsp;=&nbsp;op(op(x))
  <SPAN class=output style="COLOR: rgb(90,0,0)">twice:&nbsp;((Double)&nbsp;=&gt;&nbsp;Double,Double)Double</SPAN>
  <BR>  scala&gt;&nbsp;twice(_&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res9:&nbsp;Double&nbsp;=&nbsp;7.0</SPAN>
</PRE>The type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in this example is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Double</SPAN>, which means it is a function that takes one<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an argument and returns another<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>. 
<P></P>
<P>Any time you find a control pattern repeated in multiple parts of your code, you should think about implementing it as a new control structure. Earlier in the chapter you saw<SPAN class=code>filesMatching</SPAN>, a very specialized control pattern. Consider now a more widely used coding pattern: open a resource, operate on it, and then close the resource. You can capture this in a control abstraction using a method like the following:<A name=exa:first-with-print-writer></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;withPrintWriter(file:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">File</SPAN>,&nbsp;op:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PrintWriter</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Unit</SPAN>)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;writer&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PrintWriter</SPAN>(file)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">try</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;op(writer)
  &nbsp;&nbsp;}&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">finally</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;writer.close()
  &nbsp;&nbsp;}
  }
</PRE>Given such a method, you can use it like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  withPrintWriter(
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">File</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"date.txt"</SPAN>),
  &nbsp;&nbsp;writer&nbsp;=&gt;&nbsp;writer.println(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">java.util.Date</SPAN>)
  )
</PRE>The advantage of using this method is that it's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>withPrintWriter</SPAN>, not user code, that assures the file is closed at the end. So it's impossible to forget to close the file. This technique is called the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">loan pattern</EM>, because a control-abstraction function, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>withPrintWriter</SPAN>, opens a resource and "loans" it to a function.<A id=i-531276704-1></A><A id=i850457101-1></A><A id=i193663324-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>withPrintWriter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the previous example loans a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PrintWriter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the function,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN>. When the function completes, it signals that it no longer needs the "borrowed" resource. The resource is then closed in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>finally</SPAN>block, to ensure it is indeed closed, regardless of whether the function completes by returning normally or throwing an exception. 
<P></P>
<P>One way in which you can make the client code look a bit more like a built-in control structure is to use curly braces instead of parentheses to surround the argument list. In any method invocation in Scala in which you're passing in exactly one argument, you can opt to use curly braces to surround the argument instead of parentheses.<A id=i-2010619769-1></A><A id=i798707221-1></A><A id=i-1201222106-1></A></P>
<P>For example, instead of:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello,&nbsp;world!"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">Hello,&nbsp;world!</SPAN>
</PRE>You could write:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;println&nbsp;{&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello,&nbsp;world!"</SPAN>&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">Hello,&nbsp;world!</SPAN>
</PRE>In the second example, you used curly braces instead of parentheses to surround the arguments to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println</SPAN>. This curly braces technique will work, however, only if you're passing in one argument. Here's an attempt at violating that rule:<A id=i724160184-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;g&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Hello,&nbsp;world!"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">g:&nbsp;java.lang.String&nbsp;=&nbsp;Hello,&nbsp;world!</SPAN>
  <BR>  scala&gt;&nbsp;g.substring&nbsp;{&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">7</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">9</SPAN>&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:1:&nbsp;error:&nbsp;';'&nbsp;expected&nbsp;but&nbsp;','&nbsp;found.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.substring&nbsp;{&nbsp;7,&nbsp;9&nbsp;}</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>Because you are attempting to pass in two arguments to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>substring</SPAN>, you get an error when you try to surround those arguments with curly braces. Instead, you'll need to use parentheses:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;g.substring(<SPAN class=literal style="COLOR: rgb(205,123,0)">7</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">9</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res12:&nbsp;java.lang.String&nbsp;=&nbsp;wo</SPAN>
</PRE>
<P></P>
<P>The purpose of this ability to substitute curly braces for parentheses for passing in one argument is to enable client programmers to write function literals between curly braces. This can make a method call feel more like a control abstraction. Take the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>withPrintWriter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method defined previously as an example. In its most recent form,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>withPrintWriter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes two arguments, so you can't use curly braces. Nevertheless, because the function passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>withPrintWriter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the last argument in the list, you can use currying to pull the first argument, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>File</SPAN>, into a separate argument list. This will leave the function as the lone parameter of the second argument list.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#lst:loan-pattern">Listing 9.4</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows how you'd need to redefine<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>withPrintWriter</SPAN>.</P>
<P><A name=lst:loan-pattern></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;withPrintWriter(file:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">File</SPAN>)(op:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PrintWriter</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Unit</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;writer&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PrintWriter</SPAN>(file)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">try</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op(writer)
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">finally</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.close()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 9.4 - Using the loan pattern to write to a file.</H5>
<P>The new version differs from the old one only in that there are now two parameter lists with one parameter each instead of one parameter list with two parameters. Look between the two parameters. In the previous version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>withPrintWriter</SPAN>, shown<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#exa:first-with-print-writer">here</A>, you see ...<SPAN class=code>File,</SPAN>&nbsp;<SPAN class=code>op</SPAN>.... But in this version, you see ...<SPAN class=code>File)(op</SPAN>.... Given the above definition, you can call the method with a more pleasing syntax:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;file&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">File</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"date.txt"</SPAN>)
  <BR>  withPrintWriter(file)&nbsp;{
  &nbsp;&nbsp;writer&nbsp;=&gt;&nbsp;writer.println(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">java.util.Date</SPAN>)
  }
</PRE>In this example, the first argument list, which contains one<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>File</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument, is written surrounded by parentheses. The second argument list, which contains one function argument, is surrounded by curly braces. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=9.5></A>9.5 By-name parameters<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#9.5">link</A>]</SPAN></H3>
<P><A name=sec:by-name-parameters></A></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>withPrintWriter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method shown in the previous section differs<SPAN class=Apple-converted-space>&nbsp;</SPAN>from built-in control structures of the language, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN>, in that the code between the curly braces takes an argument. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>withPrintWriter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method requires one argument of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PrintWriter</SPAN>. This argument shows up as the "<SPAN class=code>writer</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>" in:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  withPrintWriter(file)&nbsp;{
  &nbsp;&nbsp;writer&nbsp;=&gt;&nbsp;writer.println(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">java.util.Date</SPAN>)
  }
</PRE>What if you want to implement something more like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN>, however, where there is no value to pass into the code between the curly braces? To help with such situations, Scala provides by-name parameters.<A id=i-1931276111-1></A><A id=i-2031769303-1></A> 
<P></P>
<P>As a concrete example, suppose you want to implement an assertion construct called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>myAssert</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#footnote9-3">[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>myAssert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function will take a function value as input and consult a flag to decide what to do. If the flag is set,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>myAssert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will invoke the passed function and verify that it returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>. If the flag is turned off,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>myAssert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will quietly do nothing at all.</P>
<P>Without using by-name parameters, you could write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>myAssert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;assertionsEnabled&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;myAssert(predicate:&nbsp;()&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(assertionsEnabled&nbsp;&amp;&amp;&nbsp;!predicate())
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AssertionError</SPAN>
</PRE>The definition is fine, but using it is a little bit awkward:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  myAssert(()&nbsp;=&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
</PRE>You would really prefer to leave out the empty parameter list and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>symbol in the function literal and write the code like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  myAssert(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Won't&nbsp;work,&nbsp;because&nbsp;missing&nbsp;()&nbsp;=&gt;&nbsp;</SPAN>
</PRE>By-name parameters exist precisely so that you can do this. To make a by-name parameter, you give the parameter a type starting with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>()</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>. For example, you could change<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>myAssert</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>predicate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter into a by-name parameter by changing its type, "<SPAN class=code>()</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Boolean</SPAN>", into "<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Boolean</SPAN>".<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#lst:by-name-parameter">Listing 9.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows how that would look: 
<P></P>
<P><A name=lst:by-name-parameter></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;byNameAssert(predicate:&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(assertionsEnabled&nbsp;&amp;&amp;&nbsp;!predicate)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AssertionError</SPAN>
</PRE>
<H5>Listing 9.5 - Using a by-name parameter.</H5>
<P>Now you can leave out the empty parameter in the property you want to assert. The result is that using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>byNameAssert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>looks exactly like using a built-in control structure:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  byNameAssert(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
</PRE>A by-name type, in which the empty parameter list,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>()</SPAN>, is left out, is only allowed for parameters. There is no such thing as a by-name variable or a by-name field. 
<P></P>
<P>Now, you may be wondering why you couldn't simply write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>myAssert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>using a plain old<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for the type of its parameter, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;boolAssert(predicate:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(assertionsEnabled&nbsp;&amp;&amp;&nbsp;!predicate)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AssertionError</SPAN>
</PRE>This formulation is also legal, of course, and the code using this version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>boolAssert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would still look exactly as before:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  boolAssert(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
</PRE>Nevertheless, one difference exists between these two approaches that is important to note. Because the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>boolAssert</SPAN>'s parameter is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN>, the expression inside the parentheses in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>boolAssert(5</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>3)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is evaluated<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">before</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>the call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>boolAssert</SPAN>. The expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>5</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>3</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>yields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>, which is passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>boolAssert</SPAN>. By contrast, because the type of<SPAN class=code>byNameAssert</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>predicate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Boolean</SPAN>, the expression inside the parentheses in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>byNameAssert(5</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>3)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">not</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>evaluated before the call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>byNameAssert</SPAN>. Instead a function value will be created whose<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method will evaluate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>5</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>3</SPAN>, and this function value will be passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>byNameAssert</SPAN>. 
<P></P>
<P>The difference between the two approaches, therefore, is that if assertions are disabled, you'll see any side effects that the expression inside the parentheses may have in<SPAN class=code>boolAssert</SPAN>, but not in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>byNameAssert</SPAN>. For example, if assertions are disabled, attempting to assert on "<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>0</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>0</SPAN>" will yield an exception in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>boolAssert</SPAN>'s case:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;assertionsEnabled&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">assertionsEnabled:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;boolAssert(x&nbsp;/&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">java.lang.ArithmeticException:&nbsp;/&nbsp;by&nbsp;zero</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.&lt;init&gt;(&lt;console&gt;:8)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.&lt;clinit&gt;(&lt;console&gt;)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;RequestResult$.&lt;init&gt;(&lt;console&gt;:3)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;RequestResult$.&lt;clinit&gt;(&lt;console&gt;)...</SPAN>
</PRE>But attempting to assert on the same code in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>byNameAssert</SPAN>'s case will<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">not</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>yield an exception:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;byNameAssert(x&nbsp;/&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=9.6></A>9.6 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#9.6">link</A>]</SPAN></H3>
<P>This chapter has shown you how to build on Scala's rich function support to build control abstractions. You can use functions within your code to factor out common control patterns, and you can take advantage of higher-order functions in the Scala library to reuse control patterns that are common across all programmers' code. This chapter has also shown how to use currying and by-name parameters so that your own higher-order functions can be used with a concise syntax.</P>
<P>In the previous chapter and this one, you have seen quite a lot of information about functions. The next few chapters will go back to discussing more object-oriented features of the language.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 9:</H4>
<P><A name=footnote9-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>These special-purpose looping methods are defined in trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable</SPAN>, which is extended by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html">Chapter 17</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>for a discussion.</P>
<P><A name=footnote9-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In the previous chapter, when the placeholder notation was used on traditional methods, like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println</SPAN>&nbsp;<SPAN class=code>_</SPAN>, you had to leave a space between the name and the underscore. In this case you don't, because whereas<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println_</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a legal identifier in Scala,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>curriedSum(1)_</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not.</P>
<P><A name=footnote9-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You'll call this<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>myAssert</SPAN>, not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>assert</SPAN>, because Scala provides an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>assert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of its own, which will be described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/assertions-and-unit-testing.html#sec:assert">Section 14.1</A>.</P></DIV>