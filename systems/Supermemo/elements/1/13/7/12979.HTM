<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 15 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Case Classes and Pattern Matching</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>This chapter introduces<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">case classes</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">pattern matching</EM>, twin constructs that support you when writing regular, non-encapsulated data structures. These two constructs are particularly helpful for tree-like recursive data.</P>
<P>If you have programmed in a functional language before, then you will probably recognize pattern matching. Case classes will be new to you, though. Case classes are Scala's way to allow pattern matching on objects without requiring a large amount of boilerplate. In the common case, all you need to do is add a single<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>case</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword to each class that you want to be pattern matchable.</P>
<P>This chapter starts with a simple example of case classes and pattern matching. It then goes through all of the kinds of patterns that are supported, talks about the role of<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">sealed</EM>classes, discusses the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Option</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type, and shows some non-obvious places in the language where pattern matching is used. Finally, a larger, more realistic example of pattern matching is shown.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=15.1></A>15.1 A simple example<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#15.1">link</A>]</SPAN></H3>
<P>Before delving into all the rules and nuances of pattern matching, it is worth looking at a simple example to get the general idea. Let's say you need to write a library that manipulates arithmetic expressions, perhaps as part of a domain-specific language you are designing.</P>
<P>A first step to tackle this problem is the definition of the input data. To keep things simple, we'll concentrate on arithmetic expressions consisting of variables, numbers, and unary and binary operations. This is expressed by the hierarchy of Scala classes shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:case-classes">Listing 15.1</A>.</P>
<P><A name=lst:case-classes></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(num:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(operator:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;arg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(operator:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>,&nbsp;right:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
</PRE>
<H5>Listing 15.1 - Defining case classes.</H5>
<P>The hierarchy includes an abstract base class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with four subclasses, one for each kind of expression being considered.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#footnote15-1">[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The bodies of all five classes are empty. As mentioned previously, in Scala you can leave out the braces around an empty class body if you wish, so<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>class</SPAN>&nbsp;<SPAN class=code>C</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>class</SPAN>&nbsp;<SPAN class=code>C</SPAN>&nbsp;<SPAN class=code>{}</SPAN>.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Case classes</H4>
<P>The other noteworthy thing about the declarations of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:case-classes">Listing 15.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is that each subclass has<A id=i-502971380-1></A><A id=i1163509252-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>case</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier. Classes with such a modifier are called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">case classes</SPAN>. Using the modifier makes the Scala compiler add some syntactic conveniences to your class.</P>
<P>First, it adds a factory method with the name of the class. This means you can write say,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Var("x")</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to construct a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object instead of the slightly longer<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN>&nbsp;<SPAN class=code>Var("x")</SPAN>:<A id=i-1645439037-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;v&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"x"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">v:&nbsp;Var&nbsp;=&nbsp;Var(x)</SPAN>
</PRE>The factory methods are particularly nice when you nest them. Because there are no noisy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keywords sprinkled throughout the code, you can take in the expression's structure at a glance:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;op&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>),&nbsp;v)
  <SPAN class=output style="COLOR: rgb(90,0,0)">op:&nbsp;BinOp&nbsp;=&nbsp;BinOp(+,Number(1.0),Var(x))</SPAN>
</PRE>The second syntactic convenience is that all arguments in the parameter list of a case class implicitly get a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>prefix, so they are maintained as fields:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;v.name
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;String&nbsp;=&nbsp;x</SPAN>
  <BR>  scala&gt;&nbsp;op.left
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;Expr&nbsp;=&nbsp;Number(1.0)</SPAN>
</PRE>Third, the compiler adds "natural" implementations of methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to your class. They will<A id=i311333302-1></A><A id=i-567433454-1></A><A id=i811694371-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>print, hash, and compare a whole tree consisting of the class and (recursively) all its arguments. Since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala always forwards to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>, this means in particular that elements of case classes are always compared structurally:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;println(op)
  <SPAN class=output style="COLOR: rgb(90,0,0)">BinOp(+,Number(1.0),Var(x))</SPAN>
  <BR>  scala&gt;&nbsp;op.right&nbsp;==&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"x"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>All these conventions add a lot of convenience, at a small price. The price is that you have to write the case modifier and that your classes and objects become a bit larger. They are larger because additional methods are generated and an implicit field is added for each constructor parameter. However, the biggest advantage of case classes is that they support pattern matching. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Pattern matching</H4>
<P>Say you want to simplify arithmetic expressions of the kinds<A id=i-1124185517-1></A><A id=i-174768992-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>just presented. There is a multitude of possible simplification rules. The following three rules just serve as an illustration:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;<I>e</I>))&nbsp;&nbsp;=&gt;&nbsp;<I>e</I>&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Double&nbsp;negation</SPAN>
  <SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>,&nbsp;<I>e</I>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>))&nbsp;=&gt;&nbsp;<I>e</I>&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Adding&nbsp;zero</SPAN>
  <SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"*"</SPAN>,&nbsp;<I>e</I>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>))&nbsp;=&gt;&nbsp;<I>e</I>&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Multiplying&nbsp;by&nbsp;one</SPAN>
</PRE>Using pattern matching, these rules can be taken almost as they are to form the core of a simplification function in Scala, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:simplify-top">Listing 15.2</A>. The function,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>simplifyTop</SPAN>, can be used like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;simplifyTop(<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"x"</SPAN>))))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;Expr&nbsp;=&nbsp;Var(x)</SPAN>
</PRE>
<P></P>
<P><A name=lst:simplify-top></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;simplifyTop(expr:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>&nbsp;=&nbsp;expr&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;e))&nbsp;&nbsp;=&gt;&nbsp;e&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Double&nbsp;negation</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>,&nbsp;e,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>))&nbsp;=&gt;&nbsp;e&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Adding&nbsp;zero</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"*"</SPAN>,&nbsp;e,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>))&nbsp;=&gt;&nbsp;e&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Multiplying&nbsp;by&nbsp;one</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;expr
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 15.2 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>simplifyTop</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function, which does a pattern match.</H5>
<P>The right-hand side of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>simplifyTop</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>consists of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>corresponds to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>switch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java, but it's written after the selector expression.<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>I.e.</I>, it's:<A id=i-451801752-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN style="FONT-STYLE: italic">selector</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{&nbsp;<SPAN style="FONT-STYLE: italic">alternatives</SPAN>&nbsp;}
</PRE>instead of:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  switch&nbsp;(<SPAN style="FONT-STYLE: italic">selector</SPAN>)&nbsp;{&nbsp;<SPAN style="FONT-STYLE: italic">alternatives</SPAN>&nbsp;}
</PRE>A pattern match includes a sequence of<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">alternatives</EM>,<A id=i1524854239-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>each starting with the keyword<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>case</SPAN>. Each alternative includes a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">pattern</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>and one or more expressions, which will be evaluated if the pattern matches. An arrow symbol<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>separates the pattern from the expressions. 
<P></P>
<P>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression is evaluated by trying each of the patterns in the order they are written. The first pattern that matches is selected, and the part following the arrow is selected and executed.</P>
<P>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">constant pattern</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"+"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>matches values that are equal<A id=i-1897505825-1></A><A id=i-612986830-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the constant with respect to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN>. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">variable pattern</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>matches every value. The variable then refers to that value in the right hand side of the case clause. In this example, note that the first three examples evaluate to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN>, a variable that is bound within the associated pattern. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">wildcard pattern</EM>(<SPAN class=code>_</SPAN>) also matches every value, but it does not introduce a variable name to refer to that value. In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:simplify-top">Listing 15.2</A>, notice how the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>ends with a default case that does nothing to the expression. Instead,<SPAN class=Apple-converted-space>&nbsp;</SPAN>it just results in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr</SPAN>, the expression matched upon.</P>
<P>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">constructor pattern</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>looks like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UnOp("-",</SPAN>&nbsp;<SPAN class=code>e)</SPAN>. This pattern<A id=i-881203127-1></A><A id=i-1934430442-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>matches all values of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UnOp</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>whose first argument matches<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"-"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and whose second argument matches<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN>. Note that the arguments to the constructor are themselves patterns. This allows you to write deep patterns using a concise notation. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;e))
</PRE>Imagine trying to implement this same functionality using the visitor design pattern!<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#footnote15-2">[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Almost as awkward, imagine implementing it as a long sequence of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>statements, type tests, and type casts. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic"><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>compared to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>switch</SPAN></H4>
<P>Match expressions can be seen as a generalization of Java-style<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>switch</SPAN>es. A Java-style<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>switch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be naturally expressed as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression where each pattern is a constant and the last pattern may be a wildcard (which represents the default case of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>switch</SPAN>). There are three differences to keep in mind, however. First,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">expression</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, it always results in a value. Second, Scala's alternative expressions never "fall through" into the next case. Third, if none of the patterns match, an exception named<SPAN class=code>MatchError</SPAN><A id=i1620352635-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is thrown. This means you always have to make sure that all cases are covered, even if it means adding a default case where there's nothing to do.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:default-case">Listing 15.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an example:</P>
<P><A name=lst:default-case></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;expr&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(op,&nbsp;left,&nbsp;right)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(expr&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;is&nbsp;a&nbsp;binary&nbsp;operation"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 15.3 - A pattern match with an empty "default" case.</H5>
<P>The second case is necessary in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:default-case">Listing 15.3</A>, because otherwise the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression would throw a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MatchError</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for every<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument that is not a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BinOp</SPAN>. In this example, no code is specified for that second case, so if that case runs it does nothing. The result of either case is the unit value `<SPAN class=code>()</SPAN>', which is also, therefore, the result of the entire<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN>expression.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=15.2></A>15.2 Kinds of patterns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#15.2">link</A>]</SPAN></H3>
<P><A name=sec:kinds-of-patterns></A></P>
<P>The previous example showed several kinds of patterns in quick succession. Now take a minute to look at each.</P>
<P>The syntax of patterns is easy, so do not worry about that too much. All patterns look exactly like the corresponding expression. For instance, given the hierarchy of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:case-classes">Listing 15.1</A>, the pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Var(x)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>matches any variable expression, binding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the name of the variable. Used as an expression,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Var(x)</SPAN>&#8212;exactly the same syntax&#8212;recreates an equivalent object, assuming<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is already bound to the variable's name. Since the syntax of patterns is so transparent, the main thing to pay attention to is just what kinds of patterns are possible.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Wildcard patterns</H4>
<P>The wildcard pattern (<SPAN class=code>_</SPAN>) matches any object whatsoever. You have<A id=i669211324-1></A><A id=i-615307671-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>already seen it used as a default, catch-all alternative,<A id=i-149672069-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  expr&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(op,&nbsp;left,&nbsp;right)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;println(expr&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"is&nbsp;a&nbsp;binary&nbsp;operation"</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;
  }
</PRE>Wildcards can also be used to ignore parts of an object that you do not care about. For example, the previous example does not actually care what the elements of a binary operation are. It just checks whether it is a binary operation at all. Thus the code can just as well use the wildcard pattern for the elements of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BinOp</SPAN>, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:wildcard-patterns">Listing 15.4</A>: 
<P></P>
<P><A name=lst:wildcard-patterns></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  expr&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(_,&nbsp;_,&nbsp;_)&nbsp;=&gt;&nbsp;println(expr&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"is&nbsp;a&nbsp;binary&nbsp;operation"</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"It's&nbsp;something&nbsp;else"</SPAN>)
  }
</PRE>
<H5>Listing 15.4 - A pattern match with wildcard patterns.</H5>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Constant patterns</H4>
<P>A constant pattern matches only itself. Any literal may be used as a<A id=i-1897505825-2></A><A id=i-612986830-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>constant. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>5</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"hello"</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are all constant patterns. Also, any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or singleton object can be used as a constant. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN>, a singleton object, is a pattern that matches only the empty list.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:constant-patterns">Listing 15.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows some examples of constant patterns:</P>
<P><A name=lst:constant-patterns></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;describe(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;x&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"five"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"truth"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hi!"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"the&nbsp;empty&nbsp;list"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"something&nbsp;else"</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 15.5 - A pattern match with constant patterns.</H5>
<P>Here is how the pattern match shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:constant-patterns">Listing 15.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>looks in action:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;describe(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res5:&nbsp;java.lang.String&nbsp;=&nbsp;five</SPAN>
  <BR>  scala&gt;&nbsp;describe(<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res6:&nbsp;java.lang.String&nbsp;=&nbsp;truth</SPAN>
  <BR>  scala&gt;&nbsp;describe(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res7:&nbsp;java.lang.String&nbsp;=&nbsp;hi!</SPAN>
  <BR>  scala&gt;&nbsp;describe(<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res8:&nbsp;java.lang.String&nbsp;=&nbsp;the&nbsp;empty&nbsp;list</SPAN>
  <BR>  scala&gt;&nbsp;describe(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res9:&nbsp;java.lang.String&nbsp;=&nbsp;something&nbsp;else</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Variable patterns</H4>
<P><A name=subsec:kinds-of-patterns-variables></A></P>
<P>A variable pattern matches any object, just like a wildcard. Unlike a<A id=i-1540579321-1></A><A id=i-256060326-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>wildcard, Scala binds the variable to whatever the object is. You can then use this variable to act on the object further. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:variable-pattern">Listing 15.6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a pattern match that has a special case for zero, and a default case for all other values. The default cases uses a variable pattern so that it has a name for the value, no matter what it is.</P>
<P><A name=lst:variable-pattern></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;expr&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"zero"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;somethingElse&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"not&nbsp;zero:&nbsp;"</SPAN>+&nbsp;somethingElse
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 15.6 - A pattern match with a variable pattern.</H5>
<H5>Variable or constant?</H5>
<P>Constant patterns can have symbolic names. You saw this already when we used<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a pattern. Here is a related example, where a pattern match involves the constants<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>E</SPAN>(2.71828...) and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Pi</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(3.14159...):</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;Math.{E,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Pi</SPAN>}
  <SPAN class=output style="COLOR: rgb(90,0,0)">import&nbsp;Math.{E,&nbsp;Pi}</SPAN>
  <BR>  scala&gt;&nbsp;E&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Pi</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"strange&nbsp;math?&nbsp;Pi&nbsp;=&nbsp;"</SPAN>+&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Pi</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"OK"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">res10:&nbsp;java.lang.String&nbsp;=&nbsp;OK</SPAN>
</PRE>As expected,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>E</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not match<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Pi</SPAN>, so the "strange math" case is not used. 
<P></P>
<P>How does the Scala compiler know that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Pi</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a constant imported from the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Math</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object, and not a variable that stands for the selector value itself? Scala uses a simple lexical rule for disambiguation: a simple name starting with a lowercase letter is taken to be a pattern variable; all other references are taken to be constants. To see the difference, create a lowercase alias for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pi</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and try with that:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;pi&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Math.Pi</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">pi:&nbsp;Double&nbsp;=&nbsp;3.141592653589793</SPAN>
  <BR>  scala&gt;&nbsp;E&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;pi&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"strange&nbsp;math?&nbsp;Pi&nbsp;=&nbsp;"</SPAN>+&nbsp;pi
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">res11:&nbsp;java.lang.String&nbsp;=&nbsp;strange&nbsp;math?&nbsp;Pi&nbsp;=&nbsp;2.7182818...</SPAN>
</PRE>
<P></P>
<P>Here<SPAN class=Apple-converted-space>&nbsp;</SPAN>the compiler will not even let you add a default case at all. Since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pi</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a variable pattern, it will match all inputs, and so no cases following it can be reached:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;E&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;pi&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"strange&nbsp;math?&nbsp;Pi&nbsp;=&nbsp;"</SPAN>+&nbsp;pi
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"OK"</SPAN>&nbsp;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:9:&nbsp;error:&nbsp;unreachable&nbsp;code</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;_&nbsp;=&gt;&nbsp;"OK"&nbsp;&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>If you need to, you can still use a lowercase name for a pattern constant, using one of two tricks. First, if the constant is a field of some object, you can prefix it with a qualifier. For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pi</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a variable pattern, but<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this.pi</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>obj.pi</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are constants even though they start with lowercase letters. If that does not work (because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>pi</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a local variable, say), you can alternatively enclose the variable name in back ticks. For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>`pi`</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would again be interpreted as a constant, not as a variable:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;E&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;`pi`&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"strange&nbsp;math?&nbsp;Pi&nbsp;=&nbsp;"</SPAN>+&nbsp;pi
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"OK"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">res13:&nbsp;java.lang.String&nbsp;=&nbsp;OK</SPAN>
</PRE>As you can see, the back-tick syntax for identifiers is used for two different purposes in Scala to help you code your way out of unusual circumstances. Here you see that it can be used to treat a lowercase identifier as a constant in a pattern match. Earlier on, in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html#sec:literal-identifier">Section 6.10</A>, you saw that it can also be used to treat a keyword as an ordinary identifier,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>e.g.</I>, writing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Thread.`yield`()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>treats<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>yield</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an identifier rather than a keyword. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Constructor patterns</H4>
<P>Constructors are where pattern matching becomes really powerful. A<A id=i-881203127-2></A><A id=i-1934430442-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>constructor pattern looks like "<SPAN class=code>BinOp("+",</SPAN>&nbsp;<SPAN class=code>e,</SPAN>&nbsp;<SPAN class=code>Number(0))</SPAN>". It consists of a name (<SPAN class=code>BinOp</SPAN>) and then a number of patterns within parentheses:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"+"</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Number(0)</SPAN>. Assuming the name designates a case class, such a pattern means to first check that the object is a member of the named case class, and then to check that the constructor parameters of the object match the extra patterns supplied.</P>
<P>These extra patterns mean that Scala patterns support<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">deep matches</EM>. Such patterns not only check the top-level object supplied, but also check the contents of the object against further patterns. Since the extra patterns can themselves be constructor patterns, you can use them to check arbitrarily deep into an object. For example, the pattern shown in<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:constructor-patterns">Listing 15.7</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>checks that the top-level object is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BinOp</SPAN>, that its third constructor parameter is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Number</SPAN>, and that the value field of that number is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN>. This pattern is one line long yet checks three levels deep.</P>
<P><A name=lst:constructor-patterns></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;expr&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>,&nbsp;e,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>))&nbsp;=&gt;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a&nbsp;deep&nbsp;match"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 15.7 - A pattern match with a constructor pattern.</H5>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Sequence patterns</H4>
<P><A name=sec:pat-sequences></A></P>
<P>You can match against sequence types like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>just<A id=i1331042402-1></A><A id=i-1679405899-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>like you match against case classes. Use the same syntax, but now you can specify any number of elements within the pattern. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:fixed-sequence">Listing 15.8</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a pattern that checks for a three-element list starting with zero:</P>
<P><A name=lst:fixed-sequence></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;expr&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;_,&nbsp;_)&nbsp;=&gt;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"found&nbsp;it"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 15.8 - A sequence pattern with a fixed length.</H5>
<P>If you want to match against a sequence without specifying how long it can be, you can specify<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as the last element of the pattern. This funny-looking pattern matches any number of elements within a sequence, including zero elements.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:arbitrary-sequence">Listing 15.9</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an example that matches any list that starts with zero, regardless of how long the list is.</P>
<P><A name=lst:arbitrary-sequence></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;expr&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;_*)&nbsp;=&gt;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"found&nbsp;it"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 15.9 - A sequence pattern with an arbitrary length.</H5>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Tuple patterns</H4>
<P>You can match against tuples, too. A pattern like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(a,</SPAN>&nbsp;<SPAN class=code>b,</SPAN>&nbsp;<SPAN class=code>c)</SPAN><A id=i-1134485445-1></A><A id=i-2090433336-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>matches an arbitrary 3-tuple. An example is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:tuple-pattern">Listing 15.10</A>:</P>
<P><A name=lst:tuple-pattern></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;tupleDemo(expr:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;expr&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;(a,&nbsp;b,&nbsp;c)&nbsp;&nbsp;=&gt;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"matched&nbsp;"</SPAN>+&nbsp;a&nbsp;+&nbsp;b&nbsp;+&nbsp;c)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;}
</PRE>
<H5>Listing 15.10 - A pattern match with a tuple pattern.</H5>
<P>If you load the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tupleDemo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:tuple-pattern">Listing 15.10</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>into the interpreter, and pass to it a tuple with three elements, you'll see:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;tupleDemo((<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a&nbsp;"</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-tuple"</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">matched&nbsp;a&nbsp;3-tuple</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Typed patterns</H4>
<P>You can use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">typed pattern</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a convenient replacement for type tests and type casts.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:typed-patterns">Listing 15.11</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an<A id=i1877140953-1></A><A id=i921193062-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>example:<A id=i-378444118-1></A><A id=i1534392557-1></A><A name=lst:typed-patterns></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;generalSize(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;x&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=&gt;&nbsp;s.length
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;m:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map[_, _]</SPAN>&nbsp;=&gt;&nbsp;m.size
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 15.11 - A pattern match with typed patterns.</H5>
<P>Here are a few examples of using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>generalSize</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in the interpreter:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;generalSize(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res14:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
  <BR>  scala&gt;&nbsp;generalSize(<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'a'</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'b'</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res15:&nbsp;Int&nbsp;=&nbsp;2</SPAN>
  <BR>  scala&gt;&nbsp;generalSize(<SPAN class=typename style="COLOR: rgb(103,0,154)">Math.Pi</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res16:&nbsp;Int&nbsp;=&nbsp;-1</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>generalSize</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method returns the size or length of objects of various types. Its argument is of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>, so it could be any value. If the argument is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>, the method returns the string's length. The pattern "<SPAN class=code>s:</SPAN>&nbsp;<SPAN class=code>String</SPAN>" is a typed pattern; it matches every (non-null) instance of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>. The pattern variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>then refers to that string. 
<P>Note that, even though<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>refer to the same value, the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>, but the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>. So you can write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>s.length</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the alternative expression that corresponds to the pattern, but you could not write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x.length</SPAN>, because the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not have a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>length</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>member.</P>
<P>An equivalent but more long-winded way that achieves the effect of a match against a typed pattern employs a type test followed by a type cast. Scala uses a different syntax than Java for these. To test whether an expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>, say, you write:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  expr.isInstanceOf[<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>]
</PRE>To cast the same expression to type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>, you use:<A id=i-1504091967-1></A><A id=i1385408228-1></A><A id=i-1701093140-1></A><A id=i-316974287-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  expr.asInstanceOf[<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>]
</PRE>Using a type test and cast, you could rewrite the first case of the previous<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:is-as-instanceof">Listing 15.12</A>. 
<P></P>
<P><A name=lst:is-as-instanceof></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x.isInstanceOf[<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>])&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;s&nbsp;=&nbsp;x.asInstanceOf[<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>]
  &nbsp;&nbsp;&nbsp;&nbsp;s.length
  &nbsp;&nbsp;}&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;...
</PRE>
<H5>Listing 15.12 - Using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isInstanceOf</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>asInstanceOf</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(poor style).</H5>
<P>The operators<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isInstanceOf</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>asInstanceOf</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are treated as<SPAN class=Apple-converted-space>&nbsp;</SPAN>predefined methods of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>which take a type parameter in square brackets. In fact,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x.asInstanceOf[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a special case of a method invocation with an explicit type parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>.</P>
<P>As you will have noted by now, writing type tests and casts is rather verbose in Scala. That's intentional, because it is not encouraged practice. You are usually better off using a pattern match with a typed pattern. That's particularly true if you need to do both a type test and a type cast, because both operations are then rolled into a single pattern match.</P>
<P>The second case of the previous<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression contains the type pattern "<SPAN class=code>m:</SPAN>&nbsp;<SPAN class=code>Map[_,</SPAN>&nbsp;<SPAN class=code>_]</SPAN>". This pattern matches any value that is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of some arbitrary key and value types and lets<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>m</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>refer to that value. Therefore,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>m.size</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is well typed and returns the size of the map. The underscores in the type pattern are like wildcards in other patterns. You could have also used (lowercase) type variables instead.</P>
<H5>Type erasure</H5>
<P>Can you also test for a map with specific element types? This would be handy, say for testing whether a given value is a map from type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>. Let's try:<A id=i-513765188-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isIntIntMap(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;x&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;m:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map[Int, Int]</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">warning:&nbsp;there&nbsp;were&nbsp;unchecked&nbsp;warnings;&nbsp;re-run&nbsp;with&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;-unchecked&nbsp;for&nbsp;details</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">isIntIntMap:&nbsp;(Any)Boolean</SPAN>
</PRE>The interpreter emitted an "unchecked warning." You can find out details by starting the interpreter again with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-unchecked</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>command-line option:<A id=i1857155057-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;scala&gt;&nbsp;:quit
  &nbsp;&nbsp;$&nbsp;scala&nbsp;-unchecked
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Welcome&nbsp;to&nbsp;Scala&nbsp;version&nbsp;2.7.2</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;(Java&nbsp;HotSpot(TM)&nbsp;Client&nbsp;VM,&nbsp;Java&nbsp;1.5.0_13).</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Type&nbsp;in&nbsp;expressions&nbsp;to&nbsp;have&nbsp;them&nbsp;evaluated.</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;Type&nbsp;:help&nbsp;for&nbsp;more&nbsp;information.</SPAN>
  <BR>  scala&gt;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isIntIntMap(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;x&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;m:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map[Int, Int]</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&lt;console&gt;:5:&nbsp;warning:&nbsp;non&nbsp;variable&nbsp;type-argument&nbsp;Int&nbsp;in</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;type&nbsp;pattern&nbsp;is&nbsp;unchecked&nbsp;since&nbsp;it&nbsp;is&nbsp;eliminated&nbsp;by&nbsp;erasure</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;m:&nbsp;Map[Int,&nbsp;Int]&nbsp;=&gt;&nbsp;true</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>Scala uses the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">erasure</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>model of generics,<A id=i-1494561943-1></A><A id=i-557245309-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>just like Java does. This means that no information about type arguments is maintained at runtime. Consequently, there is no way to determine at runtime whether a given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object has been created with two<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments, rather than with arguments of different types. All the system can do is determine that a value is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of some arbitrary type parameters. You can verify this behavior by applying<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isIntIntMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to arguments of different instances of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;isIntIntMap(<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res17:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;isIntIntMap(<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc"</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res18:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>The first application returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>, which looks correct, but the second application also returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>, which might be a surprise. To alert you to the possibly non-intuitive runtime behavior, the compiler emits unchecked warnings like the one shown above. 
<P></P>
<P>The only exception to the erasure rule is arrays, because they are handled specially in Java as well as in Scala. The element type of an array is stored with the array value, so you can pattern match on it. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isStringArray(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;x&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"yes"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"no"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">isStringArray:&nbsp;(Any)java.lang.String</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;as&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">as:&nbsp;Array[java.lang.String]&nbsp;=&nbsp;Array(abc)</SPAN>
  <BR>  scala&gt;&nbsp;isStringArray(as)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res19:&nbsp;java.lang.String&nbsp;=&nbsp;yes</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;ai&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">ai:&nbsp;Array[Int]&nbsp;=&nbsp;Array(1,&nbsp;2,&nbsp;3)</SPAN>
  <BR>  scala&gt;&nbsp;isStringArray(ai)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res20:&nbsp;java.lang.String&nbsp;=&nbsp;no</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Variable binding</H4>
<P><A name=sec:var-binding></A></P>
<P>In addition to the standalone variable patterns, you can also add a<A id=i-199464286-1></A><A id=i1053833551-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable to any other pattern. You simply write the variable name, an at sign (<SPAN class=code>@</SPAN>), and then the pattern. This gives you a variable-binding pattern. The meaning of such a pattern is to perform the pattern match as normal, and if the pattern succeeds, set the variable to the matched object just as with a simple variable pattern.</P>
<P>As an example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:variable-binding">Listing 15.13</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a pattern match that looks for the absolute value operation being applied twice in a row. Such an expression can be simplified to only take the absolute value one time.</P>
<P><A name=lst:variable-binding></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;expr&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abs"</SPAN>,&nbsp;e&nbsp;@&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abs"</SPAN>,&nbsp;_))&nbsp;=&gt;&nbsp;e
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 15.13 - A pattern with a variable binding (via the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>sign).</H5>
<P>In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:variable-binding">Listing 15.13</A>, there is a variable-binding pattern with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as the variable and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UnOp("abs",</SPAN>&nbsp;<SPAN class=code>_)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as the pattern. If the entire pattern match succeeds, then the portion that matched the<SPAN class=code>UnOp("abs",</SPAN>&nbsp;<SPAN class=code>_)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>part is made available as variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN>. As the code is written,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>then gets returned as is.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=15.3></A>15.3 Pattern guards<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#15.3">link</A>]</SPAN></H3>
<P>Sometimes, syntactic pattern matching is not precise enough. For instance, say you are given the task of formulating a simplification rule that replaces sum expressions with two identical operands such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>e</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by multiplications of two,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>e.g.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>2</SPAN>. In the language of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trees, an expression like:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"x"</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"x"</SPAN>))
</PRE>would be transformed by this rule to:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"*"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"x"</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>))
</PRE>You might try to define this rule as follows:<A id=i1430878475-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;simplifyAdd(e:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>)&nbsp;=&nbsp;e&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>,&nbsp;x,&nbsp;x)&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"*"</SPAN>,&nbsp;x,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;e
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:10:&nbsp;error:&nbsp;x&nbsp;is&nbsp;already&nbsp;defined&nbsp;as&nbsp;value&nbsp;x</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;BinOp("+",&nbsp;x,&nbsp;x)&nbsp;=&gt;&nbsp;BinOp("*",&nbsp;x,&nbsp;Number(2))</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>This fails, because Scala restricts patterns to be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">linear</SPAN>: a pattern variable may only appear once in a pattern. However, you can re-formulate<A id=i-2111106818-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>the match with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g624636437"><EM style="FONT-STYLE: italic">pattern guard</EM></A>, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:pattern-guard">Listing 15.14</A>:</P>
<P><A name=lst:pattern-guard></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;simplifyAdd(e:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>)&nbsp;=&nbsp;e&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>,&nbsp;x,&nbsp;y)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;x&nbsp;==&nbsp;y&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"*"</SPAN>,&nbsp;x,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;e
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;simplifyAdd:&nbsp;(Expr)Expr</SPAN>
</PRE>
<H5>Listing 15.14 - A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression with a pattern guard.</H5>
<P>A pattern guard comes after a pattern and starts with an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>if</SPAN>. The guard can be an arbitrary boolean expression, which typically refers to variables in the pattern. If a pattern guard is present, the match succeeds only if the guard evaluates to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>. Hence, the first case above would only match binary operations with two equal operands.</P>
<P>Some other examples of guarded patterns are:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;match&nbsp;only&nbsp;positive&nbsp;integers</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;n:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;&lt;&nbsp;n&nbsp;=&gt;&nbsp;...&nbsp;&nbsp;
  <BR>  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;match&nbsp;only&nbsp;strings&nbsp;starting&nbsp;with&nbsp;the&nbsp;letter&nbsp;`a'</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;s(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;==&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'a'</SPAN>&nbsp;=&gt;&nbsp;...&nbsp;
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=15.4></A>15.4 Pattern overlaps<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#15.4">link</A>]</SPAN></H3>
<P>Patterns are tried in the order in which they are written. The version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>simplify</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:case-order-matters">Listing 15.15</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>presents an example where the order of the cases matters:</P>
<P><A name=lst:case-order-matters></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;simplifyAll(expr:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>&nbsp;=&nbsp;expr&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;e))&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simplifyAll(e)&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;`-'&nbsp;is&nbsp;its&nbsp;own&nbsp;inverse</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>,&nbsp;e,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>))&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simplifyAll(e)&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;`0'&nbsp;is&nbsp;a&nbsp;neutral&nbsp;element&nbsp;for&nbsp;`+'</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"*"</SPAN>,&nbsp;e,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>))&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simplifyAll(e)&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;`1'&nbsp;is&nbsp;a&nbsp;neutral&nbsp;element&nbsp;for&nbsp;`*'</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(op,&nbsp;e)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(op,&nbsp;simplifyAll(e))
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(op,&nbsp;l,&nbsp;r)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(op,&nbsp;simplifyAll(l),&nbsp;simplifyAll(r))
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;expr
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 15.15 - Match expression in which case order matters.</H5>
<P>The version of simplify shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:case-order-matters">Listing 15.15</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>will apply simplification rules everywhere in an expression, not just at the top, as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>simplifyTop</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>did. It can be derived from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>simplifyTop</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by adding two more cases for general unary and binary expressions (cases four and five in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:case-order-matters">Listing 15.15</A>).</P>
<P>The fourth case has the pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UnOp(op,</SPAN>&nbsp;<SPAN class=code>e)</SPAN>;<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, it matches every unary operation. The operator and operand of the unary operation can be arbitrary. They are bound to the pattern variables<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN>, respectively. The alternative in this case applies<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>simplifyAll</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>recursively to the operand<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and then rebuilds the same unary operation with the (possibly) simplified operand. The fifth case for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BinOp</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is analogous: it is a "catch-all" case for arbitrary binary operations, which recursively applies the simplification method to its two operands.</P>
<P>In this example, it is important that the catch-all cases come<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">after</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the more specific simplification rules. If you wrote them in the other order, then the catch-all case would be run in favor of the more specific rules. In many cases, the compiler will even complain if you try.</P>
<P>For example, here's a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression that won't compile because the first case will match anything that would be matched by the second case:<A id=i-1756802201-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;simplifyBad(expr:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>&nbsp;=&nbsp;expr&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(op,&nbsp;e)&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(op,&nbsp;simplifyBad(e))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;e))&nbsp;=&gt;&nbsp;e
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:17:&nbsp;error:&nbsp;unreachable&nbsp;code</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;UnOp("-",&nbsp;UnOp("-",&nbsp;e))&nbsp;=&gt;&nbsp;e</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=15.5></A>15.5 Sealed classes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#15.5">link</A>]</SPAN></H3>
<P><A name=sec:sealed-classes></A></P>
<P>Whenever you write a pattern match, you need to make sure you have<A id=i1902128432-1></A><A id=i-975567006-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>covered all of the possible cases. Sometimes you can do this by adding a default case at the end of the match, but that only applies if there is a sensible default behavior. What do you do if there is no default? How can you ever feel safe that you covered all the cases?</P>
<P>In fact, you can enlist the help of the Scala compiler in detecting missing combinations of patterns in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. To be able to do this, the compiler needs to be able to tell which are the possible cases. In general, this is impossible in Scala, because new case classes can be defined at any time and in arbitrary compilation units. For instance, nothing would prevent you from adding a fifth case class to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class hierarchy in a different compilation unit from the one where the other four cases are defined.</P>
<P>The alternative is to make the superclass of your case classes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">sealed</SPAN>. A sealed class cannot have any new subclasses added except the ones in the same file. This is very useful for pattern matching, because it means you only need to worry about the subclasses you already know about. What's more, you get better compiler support as well. If you match against case classes that inherit from a sealed class, the compiler will flag missing combinations of patterns with a warning message.</P>
<P>Therefore, if you write a hierarchy of classes intended to be pattern matched, you should consider sealing them. Simply put the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sealed</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword in front of the class at the top of the hierarchy. Programmers using your class hierarchy will then feel confident in pattern matching against it. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sealed</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword, therefore, is often a license to pattern match.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:sealed-hierarchy">Listing 15.16</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an example in which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is turned into a sealed class.<A id=i-1485759717-1></A></P>
<P><A name=lst:sealed-hierarchy></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">sealed</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(num:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(operator:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;arg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(operator:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>,&nbsp;right:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
</PRE>
<H5>Listing 15.16 - A sealed hierarchy of case classes.</H5>
<P>Now define a pattern match where some of the possible cases are left out:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;describe(e:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=&nbsp;e&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(_)&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a&nbsp;number"</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(_)&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a&nbsp;variable"</SPAN>
  }
</PRE>You will get a compiler warning like the following:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">warning:&nbsp;match&nbsp;is&nbsp;not&nbsp;exhaustive!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">missing&nbsp;combination&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UnOp</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">missing&nbsp;combination&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BinOp</SPAN>
</PRE>Such a warning tells you that there's a risk your code might produce a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MatchError</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>exception because some possible patterns (<SPAN class=code>UnOp</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BinOp</SPAN>) are not handled. The warning points to a potential source of runtime faults, so it is usually a welcome help in getting your program right.<A id=i738442815-1></A> 
<P></P>
<P>However, at times you might encounter a situation where the compiler is too picky in emitting the warning. For instance, you might know from the context that you will only ever apply the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>describe</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method above to expressions that are either<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Number</SPAN>s or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Var</SPAN>s. So you know that in fact no<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MatchError</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be produced. To make the warning go away, you could add a third catch-all case to the method, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;describe(e:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=&nbsp;e&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(_)&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a&nbsp;number"</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(_)&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a&nbsp;variable"</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RuntimeException</SPAN>&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Should&nbsp;not&nbsp;happen</SPAN>
  }
</PRE>That works, but it is not ideal. You will probably not be very happy that you were forced to add code that will never be executed (or so you think), just to make the compiler shut up. 
<P></P>
<P>A more lightweight alternative is to add an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@unchecked</SPAN><A id=i-1840852242-1></A><A id=i-815574504-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>annotation to the selector expression of the match. This is done as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;describe(e:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>&nbsp;=&nbsp;(e:&nbsp;@unchecked)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(_)&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a&nbsp;number"</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(_)&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a&nbsp;variable"</SPAN>
  }
</PRE>Annotations are described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/annotations.html">Chapter 25</A>. In general, you can add an annotation to an expression in the same way you add a type: follow the expression with a colon and the name of the annotation (preceded by an at sign).<SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, in this case you add an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@unchecked</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>annotation to the variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN>, with "<SPAN class=code>e:</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@unchecked</SPAN>". The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@unchecked</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>annotation has a special meaning for pattern matching. If a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN>'s selector expression carries this annotation, exhaustivity checking for the patterns that follow will be suppressed. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=15.6></A>15.6 The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Option</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#15.6">link</A>]</SPAN></H3>
<P>Scala has a standard type named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Option</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for optional values. Such a value can be of two forms. It can be of the form<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some(x)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the actual value. Or it can be the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>None</SPAN>object, which represents a missing value.<A id=i118074925-1></A><A id=i-747501716-1></A><A id=i1519187207-1></A></P>
<P>Optional values are produced by some of the standard operations on Scala's collections. For instance, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>get</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method of Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>produces<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some(value)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>value</SPAN>corresponding to a given key has been found, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>None</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the given key is not defined in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;capitals&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"France"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Paris"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Japan"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Tokyo"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">capitals:&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;scala.collection.immutable.Map[java.lang.String,</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;java.lang.String]&nbsp;=&nbsp;Map(France&nbsp;-&gt;&nbsp;Paris,&nbsp;Japan&nbsp;-&gt;&nbsp;Tokyo)</SPAN>
  <BR>  scala&gt;&nbsp;capitals&nbsp;get&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"France"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res21:&nbsp;Option[java.lang.String]&nbsp;=&nbsp;Some(Paris)</SPAN>
  <BR>  scala&gt;&nbsp;capitals&nbsp;get&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"North&nbsp;Pole"</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res22:&nbsp;Option[java.lang.String]&nbsp;=&nbsp;None</SPAN>
</PRE>The most common way to take optional values apart is through a pattern match. For instance:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;show(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Option[String]</SPAN>)&nbsp;=&nbsp;x&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(s)&nbsp;=&gt;&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">None</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"?"</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">show:&nbsp;(Option[String])String</SPAN>
  <BR>  scala&gt;&nbsp;show(capitals&nbsp;get&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Japan"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res23:&nbsp;String&nbsp;=&nbsp;Tokyo</SPAN>
  <BR>  scala&gt;&nbsp;show(capitals&nbsp;get&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"France"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res24:&nbsp;String&nbsp;=&nbsp;Paris</SPAN>
  <BR>  scala&gt;&nbsp;show(capitals&nbsp;get&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"North&nbsp;Pole"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res25:&nbsp;String&nbsp;=&nbsp;?</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Option</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type is used frequently in Scala programs. Compare this to the dominant idiom in Java of using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to indicate no value.<A id=i-906570700-1></A><A id=i508928486-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>get</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method of<SPAN class=code>java.util.HashMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns either a value stored in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashMap</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if no value was found. This approach works for Java, but is error prone, because it is difficult in practice to keep track of which variables in a program are allowed to be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN>. If a variable is allowed to be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN>, then you must remember to check it for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>every time you use it. When you forget to check, you open the possibility that a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>NullPointerException</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>may result at runtime. Because such exceptions<A id=i-2004250537-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>may not happen very often, it can be difficult to discover the bug during testing. For Scala, the approach would not work at all, because it is possible to store value types in hash maps, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not a legal element for a value type. For instance, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HashMap[Int,</SPAN>&nbsp;<SPAN class=code>Int]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>cannot return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to signify "no element". 
<P></P>
<P>By contrast, Scala encourages the use of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Option</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to indicate an optional value. This approach to optional values has several advantages over Java's. First, it is far more obvious to readers of code that a variable whose type is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Option[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an optional<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>than a variable of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>, which may sometimes be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN>. But most importantly, that programming error described earlier of using a variable that may be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>without first checking it for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>becomes in Scala a type error. If a variable is of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Option[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and you try to use it as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN>, your Scala program will not compile.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=15.7></A>15.7 Patterns everywhere<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#15.7">link</A>]</SPAN></H3>
<P><A name=sec:patterns-everywhere></A></P>
<P>Patterns are allowed in many parts of Scala, not just in standalone<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions. Take a look at some other places you can use patterns.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Patterns in variable definitions</H4>
<P>Any time you define a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>, you can use a pattern instead of a simple identifier. For example, you can use this to take apart a tuple and assign each of its parts to its own variable, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:multiple-variables">Listing 15.17</A>:<A id=i-1873919990-1></A><A id=i-467993090-1></A></P>
<P><A name=lst:multiple-variables></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;myTuple&nbsp;=&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">123</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;myTuple:&nbsp;(Int,&nbsp;java.lang.String)&nbsp;=&nbsp;(123,abc)</SPAN>
  <BR>  &nbsp;&nbsp;scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;(number,&nbsp;string)&nbsp;=&nbsp;myTuple
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;number:&nbsp;Int&nbsp;=&nbsp;123</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;string:&nbsp;java.lang.String&nbsp;=&nbsp;abc</SPAN>
</PRE>
<H5>Listing 15.17 - Defining multiple variables with one assignment.</H5>
<P>This construct is quite useful when working with case classes. If you know the precise case class you are working with, then you can deconstruct it with a pattern. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;exp&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"*"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">exp:&nbsp;BinOp&nbsp;=&nbsp;BinOp(*,Number(5.0),Number(1.0))</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(op,&nbsp;left,&nbsp;right)&nbsp;=&nbsp;exp
  <SPAN class=output style="COLOR: rgb(90,0,0)">op:&nbsp;String&nbsp;=&nbsp;*</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">left:&nbsp;Expr&nbsp;=&nbsp;Number(5.0)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">right:&nbsp;Expr&nbsp;=&nbsp;Number(1.0)</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Case sequences as partial functions</H4>
<P><A name=sec:partial-functions></A></P>
<P>A sequence of cases (<I>i.e.</I>, alternatives) in curly braces can be used anywhere a function literal can be used.<A id=i773900220-1></A><A id=i-422039390-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Essentially, a case sequence<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">is</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>a function literal,<A id=i525081623-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>only more general. Instead of having a single entry point and list of parameters, a case sequence has multiple entry points, each with their own list of parameters. Each case is an entry point to the function, and the parameters are specified with the pattern. The body of each entry point is the right-hand side of the case.</P>
<P>Here is a simple example:<A id=i844888422-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;withDefault:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Option[Int]</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(x)&nbsp;=&gt;&nbsp;x
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">None</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  }
</PRE>The body of this function<SPAN class=Apple-converted-space>&nbsp;</SPAN>has two cases. The first case matches a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some</SPAN>, and returns the number inside the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some</SPAN>. The second case matches a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>None</SPAN>, and returns a default value of zero. Here is this function in use:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;withDefault(<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res25:&nbsp;Int&nbsp;=&nbsp;10</SPAN>
  <BR>  scala&gt;&nbsp;withDefault(<SPAN class=typename style="COLOR: rgb(103,0,154)">None</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res26:&nbsp;Int&nbsp;=&nbsp;0</SPAN>
</PRE>
<P></P>
<P>This facility is quite useful for the actors library, described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/actors-and-concurrency.html">Chapter 30</A>. Here is some typical actors code. It passes a pattern match directly to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  react&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;actor:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Actor</SPAN>)&nbsp;=&gt;&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;actor&nbsp;!&nbsp;getip(name)
  &nbsp;&nbsp;&nbsp;&nbsp;act()
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;msg&nbsp;=&gt;&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Unhandled&nbsp;message:&nbsp;"</SPAN>+&nbsp;msg)
  &nbsp;&nbsp;&nbsp;&nbsp;act()
  &nbsp;&nbsp;}
  }
</PRE>
<P></P>
<P>One other generalization is worth noting: a sequence of cases<SPAN class=Apple-converted-space>&nbsp;</SPAN>gives you a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">partial</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>function. If you apply such a function on a value it does not support, it will generate a run-time exception. For example, here is a partial function that returns the second element of a list of integers:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;second:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;::&nbsp;y&nbsp;::&nbsp;_&nbsp;=&gt;&nbsp;y
  }
</PRE>When you compile this, the compiler will correctly complain that the match is not exhaustive:<A id=i-160448460-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:17:&nbsp;warning:&nbsp;match&nbsp;is&nbsp;not&nbsp;exhaustive!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">missing&nbsp;combination&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nil</SPAN>
</PRE>This function will succeed if you pass it a three-element list, but not if you pass it an empty list: 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;second(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,<SPAN class=literal style="COLOR: rgb(205,123,0)">6</SPAN>,<SPAN class=literal style="COLOR: rgb(205,123,0)">7</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res24:&nbsp;Int&nbsp;=&nbsp;6</SPAN>
  <BR>  scala&gt;&nbsp;second(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>())
  <SPAN class=output style="COLOR: rgb(90,0,0)">scala.MatchError:&nbsp;List()</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;$anonfun$1.apply(&lt;console&gt;:17)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;$anonfun$1.apply(&lt;console&gt;:17)</SPAN>
</PRE>
<P>If you want to check whether a partial function is defined, you must first tell the compiler that you know you are working with partial functions. The type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Int]</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>includes all functions from lists of integers to integers, whether or not the functions are partial. The type that only includes<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">partial</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>functions from lists of integers to integers is written<SPAN class=code>PartialFunction[List[Int],Int]</SPAN>. Here is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>second</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function again, this time written with a partial function type:<A id=i-33298553-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;second:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PartialFunction[List[Int],Int]</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;::&nbsp;y&nbsp;::&nbsp;_&nbsp;=&gt;&nbsp;y
  }
</PRE>Partial functions have a method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isDefinedAt</SPAN>, which can be<A id=i1604479281-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>used to test whether the function is defined at a particular value.<SPAN class=Apple-converted-space>&nbsp;</SPAN>In this case, the function is defined for any list that has at least two elements:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;second.isDefinedAt(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,<SPAN class=literal style="COLOR: rgb(205,123,0)">6</SPAN>,<SPAN class=literal style="COLOR: rgb(205,123,0)">7</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res27:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;second.isDefinedAt(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>())
  <SPAN class=output style="COLOR: rgb(90,0,0)">res28:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>The typical example of a partial function is a pattern matching function literal like the one in the previous example. In fact, such an expression gets translated by the Scala compiler to a partial function by translating the patterns twice&#8212;once for the implementation of the real function, and once to test whether the function is defined or not. For instance, the function literal<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>{</SPAN>&nbsp;<SPAN class=code>case</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>y</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>_</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>y</SPAN>&nbsp;<SPAN class=code>}</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>above gets translated to the following partial function value:<A id=i-711183731-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">PartialFunction[List[Int], Int]</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;apply(xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>)&nbsp;=&nbsp;xs&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;::&nbsp;y&nbsp;::&nbsp;_&nbsp;=&gt;&nbsp;y&nbsp;
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isDefinedAt(xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>)&nbsp;=&nbsp;xs&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;::&nbsp;y&nbsp;::&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;_&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  &nbsp;&nbsp;}
  }
</PRE>This translation takes effect whenever the declared type of a function literal is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>PartialFunction</SPAN>. If the declared type is just<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function1</SPAN>, or is missing, the function literal is instead translated to a complete function. 
<P></P>
<P>In general, you should try to work with complete functions whenever possible, because using partial functions allows for runtime errors that the compiler cannot help you with. Sometimes partial functions are really helpful, though. You might be sure that an unhandled value will never be supplied. Alternatively, you might be using a framework that expects partial functions and so will always check<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isDefinedAt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>before calling the function. An example of the latter is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>react</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>example given above, where the argument is a partially defined function, defined precisely for those messages that the caller wants to handle.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Patterns in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions</H4>
<P>You can also use a pattern in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:pattern-in-for">Listing 15.18</A>. This<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression retrieves all key/value pairs from the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>capitals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>map. Each pair is matched against the pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(country,</SPAN>&nbsp;<SPAN class=code>city)</SPAN>, which defines the two variables<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>country</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>city</SPAN>.<A id=i-1272952554-1></A><A id=i371386352-1></A></P>
<P><A name=lst:pattern-in-for></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;((country,&nbsp;city)&nbsp;&lt;-&nbsp;capitals)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"The&nbsp;capital&nbsp;of&nbsp;"</SPAN>+&nbsp;country&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;is&nbsp;"</SPAN>+&nbsp;city)
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;The&nbsp;capital&nbsp;of&nbsp;France&nbsp;is&nbsp;Paris</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;The&nbsp;capital&nbsp;of&nbsp;Japan&nbsp;is&nbsp;Tokyo</SPAN>
</PRE>
<H5>Listing 15.18 - A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression with a tuple pattern.</H5>
<P>The pair pattern shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:pattern-in-for">Listing 15.18</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>was special because the match against it can never fail. Indeed,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>capitals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>yields a sequence of pairs, so you can be sure that every generated pair can be matched against a pair pattern. But it is equally possible that a pattern might not match a generated value.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:options-to-somes">Listing 15.19</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an example where that is the case:</P>
<P><A name=lst:options-to-somes></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;results&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"apple"</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">None</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"orange"</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;results:&nbsp;List[Option[java.lang.String]]&nbsp;=&nbsp;List(Some(apple),&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;None,&nbsp;Some(orange))</SPAN>
  <BR>  &nbsp;&nbsp;scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">Some</SPAN>(fruit)&nbsp;&lt;-&nbsp;results)&nbsp;println(fruit)
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;apple</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;orange</SPAN>
</PRE>
<H5>Listing 15.19 - Picking elements of a list that match a pattern.</H5>
<P>As you can see from this example, generated values that do not match the pattern are discarded. For instance, the second element<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>None</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>results</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>list does not match the pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some(fruit)</SPAN>; therefore it does not show up in the output.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=15.8></A>15.8 A larger example<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#15.8">link</A>]</SPAN></H3>
<P>After having learned the different forms of patterns, you might be interested in seeing them applied in a larger example. The proposed task is to write an expression formatter class that displays an arithmetic expression in a two-dimensional layout. Divisions such as "<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>1</SPAN>" should be printed vertically, by placing the numerator on top of the denominator, like this:</P>
<DIV align=center><SPAN class=code>&nbsp;&nbsp;x&nbsp;&nbsp;</SPAN><BR><SPAN class=code>-----&nbsp;</SPAN><BR><SPAN class=code>x&nbsp;+&nbsp;1</SPAN><BR></DIV>
<P>As another example, here's the expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>((a</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>(b</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>c)</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>n)</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>3)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in two dimensional layout:</P>
<DIV align=center><SPAN class=code>&nbsp;&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;</SPAN><BR><SPAN class=code>-----&nbsp;+&nbsp;-&nbsp;</SPAN><BR><SPAN class=code>b&nbsp;*&nbsp;c&nbsp;&nbsp;&nbsp;n&nbsp;</SPAN><BR><SPAN class=code>---------&nbsp;</SPAN><BR><SPAN class=code>&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><BR></DIV>
<P>From these examples it looks like the class (we'll call it<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ExprFormatter</SPAN>) will have to do a fair bit of layout juggling, so it makes sense to use the layout library developed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html">Chapter 10</A>. We'll also use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Expr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>family of case classes you saw previously in this chapter, and place both<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html">Chapter 10</A>'s layout library and this chapter's expression formatter into named packages. The full code for the example will be shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:expr-form-top-half">Listings 15.20</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:expr-form-bottom-half">15.21</A>.</P>
<P>A useful first step is to concentrate on horizontal layout. A structured expression like:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"*"</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"x"</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"y"</SPAN>)),&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"z"</SPAN>)),&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>))
</PRE>should print<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y)</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>z</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>1</SPAN>. Note that parentheses are mandatory around<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y</SPAN>, but would be optional around<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>y)</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>z</SPAN>. To keep the layout as legible as possible, your goal should be to omit parentheses wherever they are redundant, while ensuring that all necessary parentheses are present. 
<P></P>
<P>To know where to put parentheses, the code needs to know about the relative precedence of each operator, so it's a good idea to tackle this first. You could express the relative precedence directly as a map literal of the following form:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>(
  &nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"|"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"||"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,
  &nbsp;&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&amp;"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&amp;&amp;"</SPAN>&nbsp;-&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;...
  )
</PRE>However, this would involve some amount of pre-computation of precedences on your part. A more convenient approach is to just define groups of operators of increasing precedence and then calculate the precedence of each operator from that.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:expr-form-top-half">Listing 15.20</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows the code. 
<P></P>
<P><A name=lst:expr-form-top-half></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;org.stairwaybook.expr
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;layout.Element.elem
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">sealed</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(num:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(operator:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;arg:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(operator:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>,&nbsp;right:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ExprFormatter</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Contains&nbsp;operators&nbsp;in&nbsp;groups&nbsp;of&nbsp;increasing&nbsp;precedence</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;opGroups&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"|"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"||"</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&amp;"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&amp;&amp;"</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"^"</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"=="</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"!="</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&lt;"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&lt;="</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&gt;"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&gt;="</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Set</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"*"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"%"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;A&nbsp;mapping&nbsp;from&nbsp;operators&nbsp;to&nbsp;their&nbsp;precedence</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;precedence&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;assocs&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;until&nbsp;opGroups.length
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op&nbsp;&lt;-&nbsp;opGroups(i)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;op&nbsp;-&gt;&nbsp;i
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Map</SPAN>()&nbsp;++&nbsp;assocs
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;unaryPrecedence&nbsp;=&nbsp;opGroups.length
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;fractionPrecedence&nbsp;=&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;continued&nbsp;in&nbsp;Listing&nbsp;15.21...</SPAN>
</PRE>
<H5>Listing 15.20 - The top half of the expression formatter.</H5>
<P><A name=lst:expr-form-bottom-half></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;...continued&nbsp;from&nbsp;Listing&nbsp;15.20</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;format(e:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>,&nbsp;enclPrec:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;e&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(name)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(name)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(num)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;stripDot(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(s&nbsp;endsWith&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">".0"</SPAN>)&nbsp;s.substring(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;s.length&nbsp;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;s
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(stripDot(num.toString))
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(op,&nbsp;arg)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(op)&nbsp;beside&nbsp;format(arg,&nbsp;unaryPrecedence)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"/"</SPAN>,&nbsp;left,&nbsp;right)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;top&nbsp;=&nbsp;format(left,&nbsp;fractionPrecedence)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bot&nbsp;=&nbsp;format(right,&nbsp;fractionPrecedence)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;line&nbsp;=&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'-'</SPAN>,&nbsp;top.width&nbsp;max&nbsp;bot.width,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;frac&nbsp;=&nbsp;top&nbsp;above&nbsp;line&nbsp;above&nbsp;bot
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(enclPrec&nbsp;!=&nbsp;fractionPrecedence)&nbsp;frac
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>)&nbsp;beside&nbsp;frac&nbsp;beside&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(op,&nbsp;left,&nbsp;right)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;opPrec&nbsp;=&nbsp;precedence(op)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;l&nbsp;=&nbsp;format(left,&nbsp;opPrec)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;r&nbsp;=&nbsp;format(right,&nbsp;opPrec&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;oper&nbsp;=&nbsp;l&nbsp;beside&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>+&nbsp;op&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>)&nbsp;beside&nbsp;r&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(enclPrec&nbsp;&lt;=&nbsp;opPrec)&nbsp;oper
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"("</SPAN>)&nbsp;beside&nbsp;oper&nbsp;beside&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">")"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;format(e:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;format(e,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 15.21 - The bottom half of the expression formatter.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>precedence</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable is a map from operators to their precedences, which are integers starting with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>0</SPAN>. It is calculated using a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression with two generators. The first generator produces every index<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>i</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>opGroups</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>array. The second generator produces every operator<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>opGroups(i)</SPAN>. For each such operator the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression yields an association from the operator<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to its index<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>i</SPAN>. Hence, the relative position of an operator in the array is taken to be its precedence. Associations are written with an infix arrow,<I>e.g.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>i</SPAN>. So far you have seen associations only as part of map constructions, but they are also values in their own right. In fact, the association<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN>&nbsp;<SPAN class=code>-&gt;</SPAN>&nbsp;<SPAN class=code>i</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is nothing else but the pair<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(op,</SPAN>&nbsp;<SPAN class=code>i)</SPAN>.</P>
<P>Now that you have fixed the precedence of all binary operators except<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>/</SPAN>, it makes sense to generalize this concept to also cover unary operators. The precedence of a unary operator is higher than the precedence of every binary operator. Thus we can set<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unaryPrecedence</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:expr-form-top-half">Listing 15.20</A>) to the length of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>opGroups</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>array, which is one more than the precedence of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>%</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operators.</P>
<P>The precedence of a fraction is treated differently from the other operators because fractions use vertical layout. However, it will prove convenient to assign to the division operator the special precedence value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-1</SPAN>, so we'll initialize<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>fractionPrecedence</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to -1 (shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:expr-form-top-half">Listing 15.20</A>).</P>
<P>After these preparations, you are ready to write the main<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>format</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. This method takes two arguments: an expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN>, of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Expr</SPAN>, and the precedence<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>enclPrec</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the operator directly enclosing the expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(if there's no enclosing operator,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>enclPrec</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should be zero). The method yields a layout element that represents a two-dimensional array of characters.</P>
<P><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:expr-form-bottom-half">Listing 15.21</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows the remainder of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ExprFormatter</SPAN>, which includes three methods. The first method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stripDot</SPAN>, is a helper method.The next method, the private<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>format</SPAN>method, does most of the work to format expressions. The last method, also named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>format</SPAN>, is the lone public method in the library, which takes an expression to format.</P>
<P>The private<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>format</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method does its work by performing a pattern match on the kind of expression. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>match</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression has five cases. We'll discuss each case individually. The first case is:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(name)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;elem(name)
</PRE>
<P></P>
<P>If the expression is a variable, the result is an element formed from the variable's name.</P>
<P>The second case is:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(num)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;stripDot(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(s&nbsp;endsWith&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">".0"</SPAN>)&nbsp;s.substring(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;s.length&nbsp;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;s
  &nbsp;&nbsp;elem(stripDot(num.toString))
</PRE>If the expression is a number, the result is an element formed from the number's value. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>stripDot</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function cleans up the display of a floating-point number by stripping any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>".0"</SPAN>suffix from a string. 
<P></P>
<P>The third case is:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UnOp</SPAN>(op,&nbsp;arg)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;elem(op)&nbsp;beside&nbsp;format(arg,&nbsp;unaryPrecedence)
</PRE>If the expression is a unary operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UnOp(op,</SPAN>&nbsp;<SPAN class=code>arg)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the result is formed from the operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the result of formatting the argument<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the highest-possible environment precedence.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#footnote15-3">[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This means that if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arg</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a binary operation (but not a fraction) it will always be displayed in parentheses. 
<P></P>
<P>The fourth case is:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"/"</SPAN>,&nbsp;left,&nbsp;right)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;top&nbsp;=&nbsp;format(left,&nbsp;fractionPrecedence)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bot&nbsp;=&nbsp;format(right,&nbsp;fractionPrecedence)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;line&nbsp;=&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'-'</SPAN>,&nbsp;top.width&nbsp;max&nbsp;bot.width,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;frac&nbsp;=&nbsp;top&nbsp;above&nbsp;line&nbsp;above&nbsp;bot
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(enclPrec&nbsp;!=&nbsp;fractionPrecedence)&nbsp;frac
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>)&nbsp;beside&nbsp;frac&nbsp;beside&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>)
</PRE>If the expression is a fraction, an intermediate result<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>frac</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is formed by placing the formatted operands<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>left</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>right</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on top of each other, separated by an horizontal line element. The width of the horizontal line is the maximum of the widths of the formatted operands. This intermediate result is also the final result unless the fraction appears itself as an argument of another fraction. In the latter case, a space is added on each side of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>frac</SPAN>. To see the reason why, consider the expression "<SPAN class=code>(a</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>b)</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>c</SPAN>". Without the widening correction, formatting this expression would give: 
<P></P>
<DIV align=center><SPAN class=code>a</SPAN><BR><SPAN class=code>-</SPAN><BR><SPAN class=code>b</SPAN><BR><SPAN class=code>-</SPAN><BR><SPAN class=code>c</SPAN></DIV>
<P>The problem with this layout is evident&#8212;it's not clear where the top-level fractional bar is. The expression above could mean either "<SPAN class=code>(a</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>b)</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>c</SPAN>" or "<SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>(b</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>c)</SPAN>". To disambiguate, a space should be added on each side to the layout of the nested fraction "<SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>b</SPAN>". Then the layout becomes unambiguous:</P>
<DIV align=center><SPAN class=code>&nbsp;a&nbsp;</SPAN><BR><SPAN class=code>&nbsp;-&nbsp;</SPAN><BR><SPAN class=code>&nbsp;b&nbsp;</SPAN><BR><SPAN class=code>---</SPAN><BR><SPAN class=code>&nbsp;c&nbsp;</SPAN></DIV>
<P>The fifth and last case is:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(op,&nbsp;left,&nbsp;right)&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;opPrec&nbsp;=&nbsp;precedence(op)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;l&nbsp;=&nbsp;format(left,&nbsp;opPrec)&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;r&nbsp;=&nbsp;format(right,&nbsp;opPrec&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;oper&nbsp;=&nbsp;l&nbsp;beside&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>+&nbsp;op&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>)&nbsp;beside&nbsp;r&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(enclPrec&nbsp;&lt;=&nbsp;opPrec)&nbsp;oper
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"("</SPAN>)&nbsp;beside&nbsp;oper&nbsp;beside&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">")"</SPAN>)
</PRE>This case applies for all other binary operations. Since it comes after the case starting with:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"/"</SPAN>,&nbsp;left,&nbsp;right)&nbsp;=&gt;&nbsp;...
</PRE>you know that the operator<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BinOp(op,</SPAN>&nbsp;<SPAN class=code>left,</SPAN>&nbsp;<SPAN class=code>right)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>cannot be a division. To format such a binary operation, one needs to format first its operands<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>left</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>right</SPAN>. The precedence parameter for formatting the left operand is the precedence<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>opPrec</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the operator<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN>, while for the right operand it is one more than that. This scheme ensures that parentheses also reflect the correct associativity. For instance, the operation:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a"</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"-"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"b"</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"c"</SPAN>)))
</PRE>would be correctly parenthesized as "<SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>-</SPAN>&nbsp;<SPAN class=code>(b</SPAN>&nbsp;<SPAN class=code>-</SPAN>&nbsp;<SPAN class=code>c)</SPAN>". The intermediate result<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>oper</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is then formed by placing the formatted left and right operands side-by-side, separated by the operator. If the precedence of the current operator is smaller than the precedence of the enclosing operator,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>r</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is placed between parentheses, otherwise it is returned as is. 
<P></P>
<P>This finishes the design of the private<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>format</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function. The only remaining method is the public<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>format</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which allows client programmers to format a top-level expression without passing a precedence argument.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#lst:express-app">Listing 15.22</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a demo program that exercises<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ExprFormatter</SPAN>:</P>
<P><A name=lst:express-app></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;org.stairwaybook.expr._
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Express</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Application</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;f&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ExprFormatter</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;e1&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"*"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"/"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)),&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"x"</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)))
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;e2&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"/"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"x"</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)),&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"/"</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Number</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1.5</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Var</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"x"</SPAN>)))
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;e3&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BinOp</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"/"</SPAN>,&nbsp;e1,&nbsp;e2)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;show(e:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Expr</SPAN>)&nbsp;=&nbsp;println(f.format(e)+&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"\n\n"</SPAN>)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;e&nbsp;&lt;-&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(e1,&nbsp;e2,&nbsp;e3))&nbsp;show(e)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 15.22 - An application that prints formatted expressions.</H5>
<P>Note that, even though this program does not define a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>main</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, it is still a runnable application because it inherits from the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Application</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait. As mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/classes-and-objects.html#sec:application-trait">Section 4.5</A>, trait<SPAN class=code>Application</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>simply defines an empty<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>main</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that gets inherited by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Express</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object. The actual work in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Express</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object gets done as part of the object's initialization, before the main method is run. That's why you can apply this trick only if your program does not take any command-line arguments. Once there are arguments, you need to write the<SPAN class=code>main</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method explicitly. You can run the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Express</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>program with the command:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&nbsp;Express
</PRE>This will give the following output: 
<P></P>
<P><SPAN class=code>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>-&nbsp;*&nbsp;(x&nbsp;+&nbsp;1)<BR>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR><BR><BR>x&nbsp;&nbsp;&nbsp;1.5<BR>-&nbsp;+&nbsp;---<BR>2&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<BR><BR><BR>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>-&nbsp;*&nbsp;(x&nbsp;+&nbsp;1)<BR>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>-----------<BR>&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;1.5&nbsp;&nbsp;<BR>&nbsp;&nbsp;-&nbsp;+&nbsp;---&nbsp;&nbsp;<BR>&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;</SPAN></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=15.9></A>15.9 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html#15.9">link</A>]</SPAN></H3>
<P>In this chapter, you learned about Scala's case classes and pattern matching in detail. Using them, you can take advantage of several concise idioms not normally available in object-oriented languages. Scala's pattern matching goes further than this chapter describes, however. If you want to use pattern matching on one of your classes, but you do not want to open access to your classes the way case classes do, then you can use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">extractors</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html">Chapter 24</A>. In the next chapter, however, we'll turn our attention to lists.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 15:</H4>
<P><A name=footnote15-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Instead of an abstract class, we could have equally well chosen to model the root of that class hierarchy as a trait. Modeling it as an abstract class may be slightly more efficient.<A id=i991539031-2></A></P>
<P><A name=footnote15-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Gamma,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>et. al.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Design Patterns</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#gang-of-four">gang-of-four</A><A id=i978021020-1></A><A id=i-37693691-1></A></P>
<P><A name=footnote15-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unaryPrecedence</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the highest possible precedence, because it was initialized to one more than the precedence of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>%</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operators.</P></DIV>