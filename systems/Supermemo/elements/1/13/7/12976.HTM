<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 12 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Traits</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P><A id=i-865710043-1></A></P>
<P>Traits are a fundamental unit of code reuse in Scala. A trait encapsulates method and field definitions, which can then be reused by mixing them into classes. Unlike class inheritance, in which each class must inherit from just one superclass, a class can mix in any number of traits. This chapter shows you how traits work and shows two of the most common ways they are useful: widening thin interfaces to rich ones, and defining stackable modifications. It also shows how to use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait and compares traits to the multiple inheritance of other languages.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=12.1></A>12.1 How traits work<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#12.1">link</A>]</SPAN></H3>
<P>A trait definition looks just like a class definition except that it uses the keyword<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>trait</SPAN>. An example is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#lst:defining-a-trait">Listing 12.1</A>:</P>
<P><A name=lst:defining-a-trait></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Philosophical</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;philosophize()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"I&nbsp;consume&nbsp;memory,&nbsp;therefore&nbsp;I&nbsp;am!"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 12.1 - The definition of trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Philosophical</SPAN>.</H5>
<P>This trait is named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Philosophical</SPAN>. It does not declare a superclass, so like a class, it has the default superclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>. It defines one method, named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>philosophize</SPAN>, which is concrete. It's a simple trait, just enough to show how traits work.</P>
<P>Once a trait is defined, it can be<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">mixed in</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>to a class using either the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>extends</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>with</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keywords.<A id=i-1415422629-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Scala programmers "mix in" traits rather than inherit from them, because mixing in a trait has important differences from the multiple inheritance found in many other languages.<A id=i-917586794-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This issue is discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#sec:traits-vs-multi">Section 12.6</A>. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#lst:extending-a-trait">Listing 12.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a class that mixes in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Philosophical</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>extends</SPAN>:</P>
<P><A name=lst:extending-a-trait></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Frog</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Philosophical</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"green"</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 12.2 - Mixing in a trait using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>extends</SPAN>.</H5>
<P>You can use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>extends</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword to mix in a trait; in that case you implicitly inherit the trait's superclass. For instance, in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#lst:extending-a-trait">Listing 12.2</A>, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Frog</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>subclasses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(the superclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Philosophical</SPAN>) and mixes in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Philosophical</SPAN>. Methods inherited from a trait can be used just like methods inherited from a superclass. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;frog&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Frog</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">frog:&nbsp;Frog&nbsp;=&nbsp;green</SPAN>
  <BR>  scala&gt;&nbsp;frog.philosophize()
  <SPAN class=output style="COLOR: rgb(90,0,0)">I&nbsp;consume&nbsp;memory,&nbsp;therefore&nbsp;I&nbsp;am!</SPAN>
</PRE>A trait also defines a type. Here's an example in which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Philosophical</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used as a type:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;phil:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Philosophical</SPAN>&nbsp;=&nbsp;frog&nbsp;&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">phil:&nbsp;Philosophical&nbsp;=&nbsp;green</SPAN>
  <BR>  scala&gt;&nbsp;phil.philosophize()
  <SPAN class=output style="COLOR: rgb(90,0,0)">I&nbsp;consume&nbsp;memory,&nbsp;therefore&nbsp;I&nbsp;am!</SPAN>
</PRE>The type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>phil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Philosophical</SPAN>, a trait. Thus, variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>phil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>could have been initialized with any object whose class mixes in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Philosophical</SPAN>. 
<P></P>
<P>If you wish to mix a trait into a class that explicitly extends a superclass, you use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>extends</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to indicate the superclass and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>with</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to mix in the trait.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#lst:mixing-in-using-with">Listing 12.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an example. If you want to mix in multiple traits, you add more<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>with</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clauses. For example, given a trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HasLegs</SPAN>, you could mix both<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Philosophical</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HasLegs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Frog</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#lst:multiple-withs">Listing 12.4</A>.</P>
<P><A name=lst:mixing-in-using-with></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Frog</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Philosophical</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"green"</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 12.3 - Mixing in a trait using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>with</SPAN>.<A id=i1578124431-1></A></H5>
<P><A name=lst:multiple-withs></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HasLegs</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Frog</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Philosophical</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HasLegs</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"green"</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 12.4 - Mixing in multiple traits.</H5>
<P>In the examples you've seen so far, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Frog</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has inherited an implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>philosophize</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Philosophical</SPAN>. Alternatively,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Frog</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>could override<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>philosophize</SPAN>. The syntax looks the same as overriding a method declared in a superclass. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Frog</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Philosophical</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"green"</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;philosophize()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"It&nbsp;ain't&nbsp;easy&nbsp;being&nbsp;"</SPAN>+&nbsp;toString&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"!"</SPAN>)
  &nbsp;&nbsp;}
  }
</PRE>Because this new definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Frog</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>still mixes in trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Philosophical</SPAN>, you can still use it from a variable of that type. But because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Frog</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>overrides<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Philosophical</SPAN>'s implementation of<SPAN class=code>philosophize</SPAN>, you'll get a new behavior when you call it:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;phrog:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Philosophical</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Frog</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">phrog:&nbsp;Philosophical&nbsp;=&nbsp;green</SPAN>
  <BR>  scala&gt;&nbsp;phrog.philosophize()
  <SPAN class=output style="COLOR: rgb(90,0,0)">It&nbsp;ain't&nbsp;easy&nbsp;being&nbsp;green!</SPAN>
</PRE>At this point you might philosophize that traits are like Java interfaces with concrete methods, but they can actually do much more. Traits can, for example, declare fields and maintain state. In fact, you can do anything in a trait definition that you can do in a class definition, and the syntax looks exactly the same, with only two exceptions. First, a trait cannot have any "class" parameters,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, parameters passed to the primary constructor of a class. In other words, although you could define a class like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)
</PRE>The following attempt to define a trait would not compile:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">NoPoint</SPAN>(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Does&nbsp;not&nbsp;compile</SPAN>
</PRE>You'll find out in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/abstract-members.html#sec:val-init">Section 20.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>how to work around this restriction. 
<P></P>
<P>The other difference between classes and traits is that whereas in classes,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>calls are statically bound, in traits,<A id=i-718179772-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>they are dynamically bound.<A id=i-1297249718-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>If you write "<SPAN class=code>super.toString</SPAN>" in a class, you know exactly which method implementation will be invoked. When you write the same thing in a trait, however, the method implementation to invoke for the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>call is undefined when you define the trait. Rather, the implementation to invoke will be determined anew each time the trait is mixed into a concrete class. This curious behavior of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN>is key to allowing traits to work as<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">stackable modifications</EM>, which will be described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#sec:stackable-modifications">Section 12.5</A>. The rules for resolving<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>calls will be given in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#sec:traits-vs-multi">Section 12.6</A>.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=12.2></A>12.2 Thin versus rich interfaces<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#12.2">link</A>]</SPAN></H3>
<P>One major use of traits is to automatically add methods to a class in terms of methods the class already has. That is, traits can enrich a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">thin</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>interface, making it into a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">rich</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>interface.</P>
<P>Thin versus rich interfaces represents a commonly faced trade-off in object-oriented design. The trade-off is between the implementers and the clients of an interface. A rich interface has many methods, which make it convenient for the caller. Clients can pick a method that exactly matches the functionality they need. A thin interface, on the other hand, has fewer methods, and thus is easier on the implementers. Clients calling into a thin interface, however, have to write more code. Given the smaller selection of methods to call, they may have to choose a less than perfect match for their needs and write extra code to use it.</P>
<P>Java's interfaces are more often thin than rich. For example, interface<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CharSequence</SPAN>, which was introduced in Java 1.4, is a thin interface common to all string-like classes that hold a sequence of characters. Here's its definition when seen as a Scala trait:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CharSequence</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;charAt(index:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Char</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;length:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;subSequence(start:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;end:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">CharSequence</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString():&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>
  }
</PRE>Although most of the dozens of methods in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would apply to any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CharSequence</SPAN>, Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CharSequence</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>interface declares only four methods. Had<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CharSequence</SPAN>instead included the full<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>interface, it would have placed a large burden on implementers of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CharSequence</SPAN>. Every programmer that implemented<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>CharSequence</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java would have had to define dozens more methods. Because Scala traits can contain concrete methods, they make rich interfaces far more convenient. 
<P></P>
<P>Adding a concrete method to a trait tilts the thin-rich trade-off heavily towards rich interfaces. Unlike in Java, adding a concrete method to a Scala trait is a one-time effort. You only need to implement the method once, in the trait itself, instead of needing to reimplement it for every class that mixes in the trait. Thus, rich interfaces are less work to provide in Scala than in a language without traits.</P>
<P>To enrich an interface using traits, simply define a trait with a small number of abstract methods&#8212;the thin part of the trait's interface&#8212;and a potentially large number of concrete methods, all implemented in terms of the abstract methods. Then you can mix the enrichment trait into a class, implement the thin portion of the interface, and end up with a class that has all of the rich interface available.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=12.3></A>12.3 Example: Rectangular objects<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#12.3">link</A>]</SPAN></H3>
<P>Graphics libraries often have many different classes that represent something rectangular. Some examples are windows, bitmap images, and regions selected with a mouse. To make these rectangular objects convenient to use, it is nice if the library provides geometric queries such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>height</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>left</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>right</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>topLeft</SPAN>, and so on. However, many such methods exist that would be nice to have, so it can be a large burden on library writers to provide all of them for all rectangular objects in a Java library. If such a library were written in Scala, by contrast, the library writer could use traits to easily supply all of these convenience methods on all the classes they'd like.</P>
<P>To see how, first imagine what the code would look like without traits. There would be some basic geometric classes like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Point</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rectangle</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rectangle</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;topLeft:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bottomRight:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;left&nbsp;=&nbsp;topLeft.x
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;right&nbsp;=&nbsp;bottomRight.x
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;width&nbsp;=&nbsp;right&nbsp;-&nbsp;left
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;and&nbsp;many&nbsp;more&nbsp;geometric&nbsp;methods...</SPAN>
  }
</PRE>This<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rectangle</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class takes two points in its primary constructor: the coordinates of the top-left and bottom-right corners. It then implements many convenience methods such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>left</SPAN>,<SPAN class=code>right</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by performing simple calculations on these two points. 
<P></P>
<P>Another class a graphics library might have is a 2-D graphical widget:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Component</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;topLeft:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;bottomRight:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;left&nbsp;=&nbsp;topLeft.x
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;right&nbsp;=&nbsp;bottomRight.x
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;width&nbsp;=&nbsp;right&nbsp;-&nbsp;left
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;and&nbsp;many&nbsp;more&nbsp;geometric&nbsp;methods...</SPAN>
  }
</PRE>Notice that the definitions of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>left</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>right</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are exactly the same in the two classes. They will also be the same, aside from minor variations, in any other classes for rectangular objects. 
<P></P>
<P>This repetition can be eliminated with an enrichment trait. The trait will have two abstract methods: one that returns the top-left coordinate of the object, and another that returns the bottom-right coordinate. It can then supply concrete implementations of all the other geometric queries.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#lst:enrichment-trait">Listing 12.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows what it will look like:</P>
<P><A name=lst:enrichment-trait></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rectangular</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;topLeft:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;bottomRight:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;left&nbsp;=&nbsp;topLeft.x
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;right&nbsp;=&nbsp;bottomRight.x
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;width&nbsp;=&nbsp;right&nbsp;-&nbsp;left
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;and&nbsp;many&nbsp;more&nbsp;geometric&nbsp;methods...</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 12.5 - Defining an enrichment trait.</H5>
<P>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Component</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can mix in this trait to get all the geometric methods provided by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rectangular</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Component</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rectangular</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;other&nbsp;methods...</SPAN>
  }
</PRE>Similarly,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rectangle</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>itself can mix in the trait:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rectangle</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;topLeft:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>,&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;bottomRight:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rectangular</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;other&nbsp;methods...</SPAN>
  }
</PRE>Given these definitions, you can create a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rectangle</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and call geometric methods such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>left</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on it:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;rect&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rectangle</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Point</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">rect:&nbsp;Rectangle&nbsp;=&nbsp;Rectangle@3536fd</SPAN>
  <BR>  scala&gt;&nbsp;rect.left
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;Int&nbsp;=&nbsp;1</SPAN>
  <BR>  scala&gt;&nbsp;rect.right
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;Int&nbsp;=&nbsp;10</SPAN>
  <BR>  scala&gt;&nbsp;rect.width
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;Int&nbsp;=&nbsp;9</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=12.4></A>12.4 The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#12.4">link</A>]</SPAN></H3>
<P><A name=sec:the-ordered-trait></A></P>
<P>Comparison is another domain where a rich interface is convenient.<A id=i2068605051-1></A><A id=i795809807-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Whenever you compare two objects that are ordered, it is convenient if you use a single method call to ask about the precise comparison you want. If you want "is less than," you would like to call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;</SPAN>, and if you want "is less than or equal," you would like to call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;=</SPAN>. With a thin comparison interface, you might just have the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, and you would sometimes have to write things like "<SPAN class=code>(x</SPAN>&nbsp;<SPAN class=code>&lt;</SPAN>&nbsp;<SPAN class=code>y)</SPAN>&nbsp;<SPAN class=code>||</SPAN>&nbsp;<SPAN class=code>(x</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>y)</SPAN>". A rich interface would provide you with all of the usual comparison operators, thus allowing you to directly write things like "<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>&lt;=</SPAN>&nbsp;<SPAN class=code>y</SPAN>".</P>
<P>Before looking at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN>, imagine what you might do without it. Suppose you took the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class from<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html">Chapter 6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and added comparison operations to it. You would end up with something like this:<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#footnote12-1">[1]</A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>(n:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;d:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;...</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;&lt;&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.numer&nbsp;*&nbsp;that.denom&nbsp;&gt;&nbsp;that.numer&nbsp;*&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.denom
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;&gt;&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>)&nbsp;=&nbsp;that&nbsp;&lt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;&lt;=&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>)&nbsp;=&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>&nbsp;&lt;&nbsp;that)&nbsp;||&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>&nbsp;==&nbsp;that)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;&gt;=&nbsp;(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>)&nbsp;=&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>&nbsp;&gt;&nbsp;that)&nbsp;||&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>&nbsp;==&nbsp;that)
  }
</PRE>This class defines four comparison operators (<SPAN class=code>&lt;</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;=</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;=</SPAN>), and it's a classic demonstration of the costs of defining a rich interface. First, notice that three of the comparison operators are defined in terms of the first one. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined as the reverse of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined as literally "less than or equal." Additionally, notice that all three of these methods would be the same for any other class that is comparable. There is nothing special about rational numbers regarding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;=</SPAN>. In a comparison context,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">always</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>used to mean "less than or equals." Overall, there is quite a lot of boilerplate code in this class which would be the same in any other class that implements comparison operations. 
<P></P>
<P>This problem is so common that Scala provides a trait to help with it. The trait is called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN>. To use it, you replace all of the individual comparison methods with a single<SPAN class=code>compare</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.<A id=i1970675952-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait then defines<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;=</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for you in terms of this one method. Thus, trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>allows you to enrich a class with comparison methods by implementing only one method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>compare</SPAN>.</P>
<P>Here is how it looks if you define comparison operations on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>(n:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;d:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ordered[Rational]</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;...</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;compare(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.numer&nbsp;*&nbsp;that.denom)&nbsp;-&nbsp;(that.numer&nbsp;*&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.denom)
  }
</PRE>There are just two things to do. First, this version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>mixes in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait. Unlike the traits you have seen so far,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>requires you to specify a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g772613699"><EM style="FONT-STYLE: italic">type parameter</EM></A>when you mix it in. Type parameters are not discussed in detail until<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html">Chapter 19</A>, but for now all you need to know is that when you mix in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN>, you must actually mix in<SPAN class=code>Ordered[</SPAN><EM style="FONT-STYLE: italic">C</EM><SPAN class=code>]</SPAN>, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">C</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the class whose elements you compare. In this case,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>mixes in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered[Rational]</SPAN>. 
<P></P>
<P>The second thing you need to do is define a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>compare</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method for comparing two objects. This method should compare the receiver,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this</SPAN>, with the object passed as an argument to the method. It should return an integer that is zero if the objects are the same, negative if receiver is less than the argument, and positive if the receiver is greater than the argument. In this case, the comparison method of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>uses a formula based on converting the fractions to a common denominator and then subtracting the resulting numerators. Given this mixin and the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>compare</SPAN>, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>now has all four comparison methods:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;half&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">half:&nbsp;Rational&nbsp;=&nbsp;1/2</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;third&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rational</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">third:&nbsp;Rational&nbsp;=&nbsp;1/3</SPAN>
  <BR>  scala&gt;&nbsp;half&nbsp;&lt;&nbsp;third
  <SPAN class=output style="COLOR: rgb(90,0,0)">res5:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;half&nbsp;&gt;&nbsp;third
  <SPAN class=output style="COLOR: rgb(90,0,0)">res6:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>
<P></P>
<P>Any time you implement a class that is ordered by some comparison, you should consider mixing in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait. If you do, you will provide the class's users with a rich set of comparison methods.</P>
<P>Beware that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait does not define<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for you, because it is unable to do so. The problem is that implementing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in terms of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>compare</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>requires checking the type of the passed object, and because of type erasure,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>itself cannot do this test. Thus, you need to define<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>yourself, even if you inherit<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN>. You'll find out how to go about this in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html">Chapter 28</A>.</P>
<P>The complete<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait, minus comments and compatibility cruft, is as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Ordered[T]</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;compare(that:&nbsp;T):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;&lt;(that:&nbsp;T):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>&nbsp;compare&nbsp;that)&nbsp;&lt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;&gt;(that:&nbsp;T):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>&nbsp;compare&nbsp;that)&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;&lt;=(that:&nbsp;T):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>&nbsp;compare&nbsp;that)&nbsp;&lt;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;&gt;=(that:&nbsp;T):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>&nbsp;compare&nbsp;that)&nbsp;&gt;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  }
</PRE>Do not worry much about the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>'s and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>[T]</SPAN>'s.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>here is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g772613699">type parameter</A>, as described in detail in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html">Chapter 19</A>. For understanding the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait, just think of it as "the same type as the receiver". You can then see that this trait defines one abstract method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>compare</SPAN>, which is expected to compare the receiver (<SPAN class=code>this</SPAN>) against another object of the same type as the receiver (<SPAN class=code>that</SPAN>). Given this one method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can then provide concrete definitions for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;=</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&gt;=</SPAN>. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=12.5></A>12.5 Traits as stackable modifications<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#12.5">link</A>]</SPAN></H3>
<P><A name=sec:stackable-modifications></A></P>
<P>You have now seen one major use of traits: turning a thin interface<A id=i-590612839-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>into a rich one. Now we'll turn to a second major use: providing stackable modifications to classes. Traits let you<EM style="FONT-STYLE: italic">modify</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>the methods of a class, and they do so in a way that allows you to<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">stack</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>those modifications with each other.</P>
<P>As an example, consider stacking modifications to a queue of integers. The queue will have two operations:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>put</SPAN>, which places integers in the queue, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>get</SPAN>, which takes them back out. Queues are first-in, first-out, so<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>get</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should return the integers in the same order they were put in the queue.</P>
<P>Given a class that implements such a queue, you could define traits to perform modifications such as these:</P>
<UL>
<LI><SPAN class=code>Doubling</SPAN>: double all integers that are put in the queue 
<LI><SPAN class=code>Incrementing</SPAN>: increment all integers that are put in the queue 
<LI><SPAN class=code>Filtering</SPAN>: filter out negative integers from a queue</LI></UL>
<P>These three traits represent<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">modifications</EM>, because they modify the behavior of an underlying queue class rather than defining a full queue class themselves. The three are also<EM style="FONT-STYLE: italic">stackable</EM>. You can select any of the three you like, mix them into a class, and obtain a new class that has all of the modifications you chose.</P>
<P>An abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>IntQueue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#lst:class-intqueue">Listing 12.6</A>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>IntQueue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>put</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that adds new integers to the queue and a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>get</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that removes and returns them. A basic implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>IntQueue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that uses an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayBuffer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#lst:basic-intqueue">Listing 12.7</A>.</P>
<P><A name=lst:class-intqueue></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">IntQueue</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;get():&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;put(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 12.6 - Abstract class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>IntQueue</SPAN>.</H5>
<P><A name=lst:basic-intqueue></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.collection.mutable.ArrayBuffer
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BasicIntQueue</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">IntQueue</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;buf&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayBuffer[Int]</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;get()&nbsp;=&nbsp;buf.remove(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;put(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{&nbsp;buf&nbsp;+=&nbsp;x&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 12.7 - A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BasicIntQueue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>implemented with an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayBuffer</SPAN>.</H5>
<P>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BasicIntQueue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has a private field holding an array buffer. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>get</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method removes an entry from one end of the buffer, while the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>put</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method adds elements to the other end. Here's how this implementation looks when you use it:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;queue&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BasicIntQueue</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">queue:&nbsp;BasicIntQueue&nbsp;=&nbsp;BasicIntQueue@24655f</SPAN>
  <BR>  scala&gt;&nbsp;queue.put(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <BR>  scala&gt;&nbsp;queue.put(<SPAN class=literal style="COLOR: rgb(205,123,0)">20</SPAN>)
  <BR>  scala&gt;&nbsp;queue.get()
  <SPAN class=output style="COLOR: rgb(90,0,0)">res9:&nbsp;Int&nbsp;=&nbsp;10</SPAN>
  <BR>  scala&gt;&nbsp;queue.get()
  <SPAN class=output style="COLOR: rgb(90,0,0)">res10:&nbsp;Int&nbsp;=&nbsp;20</SPAN>
</PRE>
<P></P>
<P>So far so good. Now take a look at using traits to modify this behavior.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#lst:doubling-trait">Listing 12.8</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a trait that doubles integers as they are put in the queue. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Doubling</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait has two funny things going on. The first is that it declares a superclass,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>IntQueue</SPAN>. This declaration means that the trait can only be mixed into a class that also extends<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>IntQueue</SPAN>. Thus, you can mix<SPAN class=code>Doubling</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BasicIntQueue</SPAN>, but not into<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN>.</P>
<P><A name=lst:doubling-trait></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Doubling</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">IntQueue</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;put(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">super</SPAN>.put(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;*&nbsp;x)&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 12.8 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Doubling</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>stackable modification trait.</H5>
<P>The second funny thing is that the trait has a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>call on a method declared abstract. Such calls are illegal for normal classes, because they will certainly fail at run time. For a trait, however, such a call can actually succeed. Since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>calls in a trait are dynamically bound, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>call in trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Doubling</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will work so long as the trait is mixed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">after</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>another trait or class that gives a concrete definition to the method.</P>
<P>This arrangement is frequently needed with traits that implement stackable modifications. To tell the compiler you are doing this on purpose, you must mark such methods as<SPAN class=code>abstract</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>override</SPAN>.<A id=i-1048822646-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This combination of modifiers is only allowed for members of traits, not classes, and it means that the trait must be mixed into some class that has a concrete definition of the method in question.</P>
<P>There is a lot going on with such a simple trait, isn't there! Here's how it looks to use the trait:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">MyQueue</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BasicIntQueue</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Doubling</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">defined&nbsp;class&nbsp;MyQueue</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;queue&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">MyQueue</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">queue:&nbsp;MyQueue&nbsp;=&nbsp;MyQueue@91f017</SPAN>
  <BR>  scala&gt;&nbsp;queue.put(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <BR>  scala&gt;&nbsp;queue.get()
  <SPAN class=output style="COLOR: rgb(90,0,0)">res12:&nbsp;Int&nbsp;=&nbsp;20</SPAN>
</PRE>
<P></P>
<P>In the first line in this interpreter session, we define class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MyQueue</SPAN>, which extends<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>BasicIntQueue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and mixes in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Doubling</SPAN>. We then put a 10 in the queue, but because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Doubling</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has been mixed in, the 10 is doubled. When we get an integer from the queue, it is a 20.</P>
<P>Note that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MyQueue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defines no new code. It simply identifies a class and mixes in a trait. In this situation, you could supply "<SPAN class=code>BasicIntQueue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>with</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Doubling</SPAN>" directly to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of defining a named class. It would look as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#lst:new-with">Listing 12.9</A>:</P>
<P><A name=lst:new-with></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;queue&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BasicIntQueue</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Doubling</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;queue:&nbsp;BasicIntQueue&nbsp;with&nbsp;Doubling&nbsp;=&nbsp;$anon$1@5fa12d</SPAN>
  <BR>  &nbsp;&nbsp;scala&gt;&nbsp;queue.put(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <BR>  &nbsp;&nbsp;scala&gt;&nbsp;queue.get()
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;res14:&nbsp;Int&nbsp;=&nbsp;20</SPAN>
</PRE>
<H5>Listing 12.9 - Mixing in a trait when instantiating with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN>.</H5>
<P>To see how to stack modifications, we need to define the other two modification traits,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Incrementing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Filtering</SPAN>. Implementations of these traits are shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#lst:incrementing-filtering">Listing 12.10</A>:</P>
<P><A name=lst:incrementing-filtering></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Incrementing</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">IntQueue</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;put(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">super</SPAN>.put(x&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)&nbsp;}
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Filtering</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">IntQueue</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;put(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;&gt;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">super</SPAN>.put(x)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 12.10 - Stackable modification traits<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Incrementing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Filtering</SPAN>.</H5>
<P>Given these modifications, you can now pick and choose which ones you want for a particular queue. For example, here is a queue that both filters negative numbers and adds one to all numbers that it keeps:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;queue&nbsp;=&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BasicIntQueue</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Incrementing</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Filtering</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">queue:&nbsp;BasicIntQueue&nbsp;with&nbsp;Incrementing&nbsp;with&nbsp;Filtering...</SPAN>
  <BR>  scala&gt;&nbsp;queue.put(-<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>);&nbsp;queue.put(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>);&nbsp;queue.put(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  <BR>  scala&gt;&nbsp;queue.get()
  <SPAN class=output style="COLOR: rgb(90,0,0)">res15:&nbsp;Int&nbsp;=&nbsp;1</SPAN>
  <BR>  scala&gt;&nbsp;queue.get()
  <SPAN class=output style="COLOR: rgb(90,0,0)">res16:&nbsp;Int&nbsp;=&nbsp;2</SPAN>
</PRE>
<P></P>
<P>The order of mixins is significant.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#footnote12-2">[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The precise rules are given in the following section, but, roughly speaking, traits further to the right take effect first. When you call a method on a class with mixins, the method in the trait furthest to the right is called first. If that method calls<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN>, it invokes the method in the next trait to its left, and so on. In the previous example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Filtering</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>put</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is invoked first, so it removes integers that were negative to begin with.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Incrementing</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>put</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is invoked second, so it adds one to those integers that remain.</P>
<P>If you reverse the order, first integers will be incremented, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">then</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>the integers that are still negative will be discarded:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;queue&nbsp;=&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BasicIntQueue</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Filtering</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Incrementing</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">queue:&nbsp;BasicIntQueue&nbsp;with&nbsp;Filtering&nbsp;with&nbsp;Incrementing...</SPAN>
  <BR>  scala&gt;&nbsp;queue.put(-<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>);&nbsp;queue.put(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>);&nbsp;queue.put(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  <BR>  scala&gt;&nbsp;queue.get()
  <SPAN class=output style="COLOR: rgb(90,0,0)">res17:&nbsp;Int&nbsp;=&nbsp;0</SPAN>
  <BR>  scala&gt;&nbsp;queue.get()
  <SPAN class=output style="COLOR: rgb(90,0,0)">res18:&nbsp;Int&nbsp;=&nbsp;1</SPAN>
  <BR>  scala&gt;&nbsp;queue.get()
  <SPAN class=output style="COLOR: rgb(90,0,0)">res19:&nbsp;Int&nbsp;=&nbsp;2</SPAN>
</PRE>
<P></P>
<P>Overall, code written in this style gives you a great deal of flexibility. You can define sixteen different classes by mixing in these three traits in different combinations and orders. That's a lot of flexibility for a small amount of code, so you should keep your eyes open for opportunities to arrange code as stackable modifications.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=12.6></A>12.6 Why not multiple inheritance?<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#12.6">link</A>]</SPAN></H3>
<P><A name=sec:traits-vs-multi></A></P>
<P><A name=sec:linearization></A><A id=i-1280910181-1></A><A id=i1595934381-1></A><A id=i-1992074038-1></A></P>
<P>Traits are a way to inherit from multiple class-like constructs, but they differ in important ways from the multiple inheritance present in many languages. One difference is especially important: the interpretation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN>. With multiple inheritance, the method called by a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>call can be determined right where the call appears. With traits, the method called is determined by a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">linearization</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the classes and traits that are mixed into a class. This is the difference that enables the stacking of modifications described in the previous section.</P>
<P>Before looking at linearization, take a moment to consider how to stack modifications in a language with traditional multiple inheritance. Imagine the following code, but this time interpreted as multiple inheritance instead of trait mixin:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Multiple&nbsp;inheritance&nbsp;thought&nbsp;experiment</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;q&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BasicIntQueue</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Incrementing</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Doubling</SPAN>
  q.put(<SPAN class=literal style="COLOR: rgb(205,123,0)">42</SPAN>)&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;which&nbsp;put&nbsp;would&nbsp;be&nbsp;called?</SPAN>
</PRE>The first question is, which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>put</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method would get invoked by this call? Perhaps the rule would be that the last superclass wins, in which case<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Doubling</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would get called.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Doubling</SPAN>would double its argument and call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super.put</SPAN>, and that would be it. No incrementing would happen! Likewise, if the rule were that the first superclass wins, the resulting queue would increment integers but not double them. Thus neither ordering would work. 
<P></P>
<P>You might also entertain the possibility of allowing programmers to identify exactly which superclass method they want when they say<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN>. For example, imagine the following Scala-like code, in which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>appears to be explicitly invoked on both<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Incrementing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Doubling</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Multiple&nbsp;inheritance&nbsp;thought&nbsp;experiment</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">MyQueue</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">BasicIntQueue</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Incrementing</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Doubling</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;put(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;Incrementing.super.put(x)&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;(Not&nbsp;real&nbsp;Scala)</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;Doubling.super.put(x)
  &nbsp;&nbsp;}
  }
</PRE>
<P></P>
<P>This approach would give us new problems. The verbosity of this attempt is the least of its problems. What would happen is that the base class's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>put</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method would get called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">twice</EM>&#8212;once with an incremented value and once with a doubled value, but neither time with an incremented, doubled value.</P>
<P>There is simply no good solution to this problem using multiple inheritance. You would have to back up in your design and factor the code differently. By contrast, the traits solution in Scala is straightforward. You simply mix in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Incrementing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Doubling</SPAN>, and Scala's special treatment of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in traits makes it all work out. Something is clearly different here from traditional multiple inheritance, but what? As hinted previously, the answer is linearization. When you instantiate a class with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN>, Scala takes the class and all of its inherited classes and traits and puts them in a single,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">linear</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>order. Then, whenever you call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>inside one of those classes, the invoked method is the next one up the chain. If all of the methods but the last call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN>, the net result is stackable behavior.</P>
<P>The precise order of the linearization is described in the language specification. It is a little bit complicated, but the main thing you need to know is that, in any linearization, a class is always linearized before<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">all</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of its superclasses and mixed in traits. Thus, when you write a method that calls<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN>, that method is definitely modifying the behavior of the superclasses and mixed in traits, not the other way around.</P>
<DIV class=note style="PADDING-RIGHT: 20px; PADDING-LEFT: 20px; PADDING-BOTTOM: 5px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px">
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Note</H4>
<P>The remainder of this section describes the details of linearization. You can safely skip the rest of this section if you are not interested in understanding those details right now.</P></DIV>
<P>The main properties of Scala's linearization are illustrated by the following example: Say you have a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat</SPAN>, which inherits from a superclass<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and two traits<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Furry</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=code>FourLegged</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>FourLegged</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>extends in turn another trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>HasLegs</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;
  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Furry</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HasLegs</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">trait</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">FourLegged</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">HasLegs</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cat</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Animal</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Furry</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">with</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">FourLegged</SPAN>
</PRE>
<P></P>
<P>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat</SPAN>'s inheritance hierarchy and linearization are shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#fig:linearization">Figure 12.1</A>. Inheritance is indicated using traditional UML notation:<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#footnote12-3">[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>arrows with white, triangular arrowheads indicate inheritance, with the arrowhead pointing to the supertype. The arrows with darkened, non-triangular arrowheads depict linearization. The darkened arrowheads point in the direction in which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>calls will be resolved.</P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:linearization></A>
<P><IMG alt="image images/linearization.jpg" src="http://www.artima.com/pins1ed/images/linearization.jpg"></P></DIV>
<H5>Figure 12.1 - Inheritance hierarchy and linearization of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat</SPAN>.</H5>
<P>The linearization of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is computed from back to front as follows. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">last</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>part of the linearization of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the linearization of its superclass,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN>. This linearization is copied over without any changes. (The linearization of each of these types is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#tab:linearization-several">Table 12.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#tab:linearization-several">here</A>.) Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>doesn't explicitly extend a superclass or mix in any supertraits, it by default extends<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>, which extends<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN>'s linearization, therefore, looks like:</P>
<DIV align=center><IMG alt="image images/AnimalLine.jpg" src="http://www.artima.com/pins1ed/images/AnimalLine.jpg"></DIV>
<P>The second to last part is the linearization of the first mixin, trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Furry</SPAN>, but all classes that are already in the linearization of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Animal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are left out now, so that each class appears only once in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat</SPAN>'s linearization. The result is:</P>
<DIV align=center><IMG alt="image images/FurryLine.jpg" src="http://www.artima.com/pins1ed/images/FurryLine.jpg"></DIV>
<P>This is preceded by the linearization of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>FourLegged</SPAN>, where again any classes that have already been copied in the linearizations of the superclass or the first mixin are left out:</P>
<DIV align=center><IMG alt="image images/FourLeggedLine.jpg" src="http://www.artima.com/pins1ed/images/FourLeggedLine.jpg"></DIV>
<P>Finally, the first class in the linearization of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>itself:</P>
<DIV align=center><IMG alt="image images/CatLine.jpg" src="http://www.artima.com/pins1ed/images/CatLine.jpg"></DIV>
<P>When any of these classes and traits invokes a method via<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN>, the implementation invoked will be the first implementation to its right in the linearization.</P>
<P><A name=tab:linearization-several></A></P>
<H5>Table 12.1 - Linearization of types in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Cat</SPAN>'s hierarchy</H5>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Type</SPAN></SPAN></TD>
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">Linearization</SPAN></SPAN></TD></TR>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN class=code>Animal</SPAN></TD>
<TD style="BORDER-TOP: black thin solid">Animal, AnyRef, Any</TD></TR>
<TR class="">
<TD><SPAN class=code>Furry</SPAN></TD>
<TD>Furry, Animal, AnyRef, Any</TD></TR>
<TR class="">
<TD><SPAN class=code>FourLegged</SPAN></TD>
<TD>FourLegged, HasLegs, Animal, AnyRef, Any</TD></TR>
<TR class="">
<TD><SPAN class=code>HasLegs</SPAN></TD>
<TD>HasLegs, Animal, AnyRef, Any</TD></TR>
<TR class=bottomline style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TD style="BORDER-BOTTOM: black thin solid"><SPAN class=code>Cat</SPAN></TD>
<TD style="BORDER-BOTTOM: black thin solid">Cat, FourLegged, HasLegs, Furry, Animal, AnyRef, Any</TD></TR></TBODY></TABLE></DIV>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=12.7></A>12.7 To trait, or not to trait?<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#12.7">link</A>]</SPAN></H3>
<P>Whenever you implement a reusable collection of behavior, you will have to decide whether you want to use a trait or an abstract class. There is no firm rule, but this section contains a few guidelines to consider.</P>
<P><EM style="FONT-STYLE: italic">If the behavior will not be reused</EM>, then make it a concrete class. It is not reusable behavior after all.</P>
<P><EM style="FONT-STYLE: italic">If it might be reused in multiple, unrelated classes</EM>, make it a trait. Only traits can be mixed into different parts of the class hierarchy.</P>
<P><EM style="FONT-STYLE: italic">If you want to inherit from it in Java code</EM>, use an abstract class. Since traits with code do not have a close Java analog, it tends to be awkward to inherit from a trait in a Java class. Inheriting from a Scala class, meanwhile, is exactly like inheriting from a Java class. As one exception, a Scala trait with only abstract members translates directly to a Java interface, so you should feel free to define such traits even if you expect Java code to inherit from it. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/combining-scala-and-java.html">Chapter 29</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>for more information on working with Java and Scala together.</P>
<P><EM style="FONT-STYLE: italic">If you plan to distribute it in compiled form</EM>, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class. The issue is that when a trait gains or loses a member, any classes that inherit from it must be recompiled, even if they have not changed. If outside clients will only call into the behavior, instead of inheriting from it, then using a trait is fine.</P>
<P><EM style="FONT-STYLE: italic">If efficiency is very important</EM>, lean towards using a class. Most<A id=i991539031-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Java runtimes make a virtual method invocation of a class member a faster operation than an interface method invocation. Traits get compiled to interfaces and therefore may pay a slight performance overhead. However, you should make this choice only if you know that the trait in question constitutes a performance bottleneck and have evidence that using a class instead actually solves the problem.</P>
<P><EM style="FONT-STYLE: italic">If you still do not know</EM>, after considering the above, then start by making it as a trait. You can always change it later, and in general using a trait keeps more options open.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=12.8></A>12.8 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/traits.html#12.8">link</A>]</SPAN></H3>
<P>This chapter has shown you how traits work and how to use them in several common idioms. You saw that traits are similar to multiple inheritance, but because they interpret<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>super</SPAN>using linearization, they both avoid some of the difficulties of traditional multiple inheritance, and allow you to stack behaviors. You also saw the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Ordered</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait and learned how to write your own enrichment traits.</P>
<P>Now that you have seen all of these facets, it is worth stepping back and taking another look at traits as a whole. Traits do not merely support the idioms described in this chapter. They are a fundamental unit of code that is reusable through inheritance. Because of this nature, many experienced Scala programmers start with traits when they are at the early stages of implementation. Each trait can hold less than an entire concept, a mere fragment of a concept. As the design solidifies, the fragments can be combined into more complete concepts through trait mixin.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 12:</H4>
<P><A name=footnote12-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The full code for the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rational</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class on which this example is based is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html#lst:overloaded-methods">Listing 6.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html#lst:overloaded-methods">here</A>.</P>
<P><A name=footnote12-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Once a trait is mixed into a class, you can alternatively call it a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">mixin</EM>.</P>
<P><A name=footnote12-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Rumbaugh,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>et. al.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">The Unified Modeling Language Reference Manual</EM>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#rumbaugh:uml">rumbaugh:uml</A><A id=i-1488083405-1></A><A id=i-1072078781-1></A></P></DIV>