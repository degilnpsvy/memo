<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 10 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Composition and Inheritance</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html">Chapter 6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>introduced some basic object-oriented aspects of Scala. This chapter will pick up where<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html">Chapter 6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>left off and dive with much greater detail into Scala's support for object-oriented programming. We'll compare two fundamental relationships between classes: composition and inheritance. Composition means one class holds a reference to another, using the referenced class to help it fulfill its mission. Inheritance is the superclass/subclass relationship. In addition to these topics, we'll discuss abstract classes, parameterless methods, extending classes, overriding methods and fields, parametric fields, invoking superclass constructors, polymorphism and dynamic binding, final members and classes, and factory objects and methods.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.1></A>10.1 A two-dimensional layout library<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.1">link</A>]</SPAN></H3>
<P>As a running example in this chapter, we'll create a library for building and rendering two-dimensional layout elements. Each element will represent a rectangle filled with text. For convenience, the library will provide factory methods named "<SPAN class=code>elem</SPAN>" that construct new elements from passed data. For example, you'll be able to create a layout element containing a string using a factory method with the following signature:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  elem(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>
</PRE>As you can see, elements will be modeled with a type named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>. You'll be able to call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>above</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>beside</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on an element, passing in a second element, to get a new element that combines the two. For example, the following expression would construct a larger element consisting of two columns, each with a height of two:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;column1&nbsp;=&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>)&nbsp;above&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"***"</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;column2&nbsp;=&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"***"</SPAN>)&nbsp;above&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"world"</SPAN>)
  column1&nbsp;beside&nbsp;column2
</PRE>Printing the result of this expression would give:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  hello&nbsp;***&nbsp;&nbsp;
  &nbsp;***&nbsp;world
</PRE>Layout elements are a good example of a system in which objects can be constructed from simple parts with the aid of composing operators. In this chapter, we'll define classes that enable element objects to be constructed from arrays, lines, and rectangles&#8212;the simple parts. We'll also define composing operators<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>above</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>beside</SPAN>. Such composing operators are also often called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">combinators</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>because they combine elements of some domain into new elements<A id=i-649047625-1></A>. 
<P></P>
<P>Thinking in terms of combinators is generally a good way to approach library design: it pays to think about the fundamental ways to construct objects in an application domain. What are the simple objects? In what ways can more interesting objects be constructed out of simpler ones? How do combinators hang together? What are the most general combinations? Do they satisfy any interesting laws? If you have good answers to these questions, your library design is on track.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.2></A>10.2 Abstract classes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.2">link</A>]</SPAN></H3>
<P><A name=sec:abstract-classes></A></P>
<P>Our first task is to define type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>, which represents layout elements. Since elements are two dimensional rectangles of characters, it makes sense to include a member,<SPAN class=code>contents</SPAN>, that refers to the contents of a layout element<A id=i-860903178-1></A>. The contents can be represented as an array of strings, where each string represents a line. Hence, the type of the result returned by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:abstract-method-class">Listing 10.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows what it will look like.</P>
<P><A name=lst:abstract-method-class></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;contents:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 10.1 - Defining an abstract method and class.</H5>
<P>In this class,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is declared as a method that has no implementation. In other words, the method is an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">abstract</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>member of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>. A class with abstract members must itself be declared abstract, which is done by writing an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>abstract</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier in front of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>class</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword<A id=i1203833450-1></A><A id=i-860903178-2></A>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;...
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>abstract</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier signifies that the class may have abstract members that do not have an implementation. As a result, you cannot instantiate an abstract class. If you try to do so, you'll get a compiler error:<A id=i-983091129-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:5:&nbsp;error:&nbsp;class&nbsp;Element&nbsp;is&nbsp;abstract;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;cannot&nbsp;be&nbsp;instantiated</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Element</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>Later in this chapter you'll see how to create subclasses of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>, which you'll be able to instantiate because they fill in the missing definition for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN>.</P>
<P>Note that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not carry an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>abstract</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier. A method is abstract if it does not have an implementation (<I>i.e.</I>, no equals sign or body). Unlike Java, no abstract modifier is necessary (or allowed) on method declarations. Methods that do have an implementation are called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">concrete</SPAN><A id=i-141831446-1></A>.<A id=i-1171687261-1></A></P>
<P>Another bit of terminology distinguishes between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">declarations</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">definitions</SPAN>. Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g1542341994"><EM style="FONT-STYLE: italic">declares</EM></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>the abstract method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN>, but currently<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-1335633477"><EM style="FONT-STYLE: italic">defines</EM></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>no concrete methods. In the next section, however, we'll enhance<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by defining some concrete methods.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.3></A>10.3 Defining parameterless methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.3">link</A>]</SPAN></H3>
<P><A name=sec:uniform-access-principle></A></P>
<P>As a next step, we'll add methods to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that reveal its width and height, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:parameterless-methods">Listing 10.2</A>.<A id=i1448211194-1></A><A id=i1133207124-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>height</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method returns the number of lines in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method returns the length of the first line, or, if there are no lines in the element, zero. (This means you cannot define an element with a height of zero and a non-zero width.)</P>
<P><A name=lst:parameterless-methods></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;contents:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;contents.length
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(height&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;contents(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>).length
  }
</PRE>
<H5>Listing 10.2 - Defining parameterless methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>height</SPAN>.</H5>
<P>Note that none of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>'s three methods has a parameter list, not even an empty one. For example, instead of:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;width():&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
</PRE>the method is defined without parentheses:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
</PRE>Such<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-1903107585"><EM style="FONT-STYLE: italic">parameterless methods</EM></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>are quite common in Scala.<A id=i-1718164274-2></A><A id=i1976561855-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>By contrast, methods defined with empty parentheses, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN>&nbsp;<SPAN class=code>height():</SPAN>&nbsp;<SPAN class=code>Int</SPAN>, are called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">empty-paren methods</EM>.<A id=i1343251059-1></A><A id=i1617330716-1></A><A id=i1755483330-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The recommended convention is to use a parameterless method whenever there are no parameters<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">and</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>the method accesses mutable state only by reading fields of the containing object (in particular, it does not change mutable state). 
<P></P>
<P>This convention supports the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">uniform access principle</SPAN>,<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#footnote10-1">[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which says that client code should not be affected by a decision to implement an attribute as a field or method<A id=i758262274-1></A>. For instance, we could have chosen to implement<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>height</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as fields instead of methods, simply by changing the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in each definition to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;contents:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;height&nbsp;=&nbsp;contents.length
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;width&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(height&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;contents(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>).length
  }
</PRE>The two pairs of definitions are completely equivalent from a client's point of view. The only difference is that field accesses might be slightly faster than method invocations, because the field values are pre-computed when the class is initialized, instead of being computed on each method call. On the other hand, the fields require extra memory space in each<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object. So it depends on the usage profile of a class whether an attribute is better represented as a field or method, and that usage profile might change over time. The point is that clients of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class should not be affected when its internal implementation changes. 
<P></P>
<P>In particular, a client of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should not need to be rewritten if a field of that class gets changed into an access function so long as the access function is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">pure</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, it does not have any side effects and does not depend on mutable state<A id=i-242056329-1></A>. The client should not need to care either way.</P>
<P>So far so good. But there's still a slight complication that has to do with the way Java handles things. The problem is that Java does not implement the uniform access principle. So it's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>string.length()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java, not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>string.length</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(even though it's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>array.length</SPAN>, not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>array.length()</SPAN>). Needless to say, this is very confusing.</P>
<P>To bridge that gap, Scala is very liberal when it comes to mixing parameterless and empty-paren methods. In particular, you can override a parameterless method with an empty-paren method, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>vice versa</I>. You can also leave off the empty parentheses on an invocation of any function that takes no arguments. For instance, the following two lines are both legal in Scala:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>).toString
  <SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc"</SPAN>.length
</PRE>
<P></P>
<P>In principle it's possible to leave out all empty parentheses in Scala function calls. However, it is recommended to still write the empty parentheses when the invoked method represents more than a property of its receiver object. For instance, empty parentheses are appropriate if the method performs I/O, or writes reassignable variables (<SPAN class=code>var</SPAN>s), or reads<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s other than the receiver's fields, either directly or indirectly by using mutable objects. That way, the parameter list acts as a visual clue that some interesting computation is triggered by the call. For instance:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>.length&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;no&nbsp;()&nbsp;because&nbsp;no&nbsp;side-effect</SPAN>
  println()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;better&nbsp;to&nbsp;not&nbsp;drop&nbsp;the&nbsp;()</SPAN>
</PRE>To summarize, it is encouraged style in Scala to define methods that take no parameters and have no side effects as parameterless methods,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, leaving off the empty parentheses. On the other hand, you should never define a method that has side-effects without parentheses, because then invocations of that method would look like a field selection. So your clients might be surprised to see the side effects. Similarly, whenever you invoke a function that has side effects, be sure to include the empty parentheses when you write the invocation. Another way to think about this is if the function you're calling performs an operation, use the parentheses, but if it merely provides access to a property, leave the parentheses off. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.4></A>10.4 Extending classes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.4">link</A>]</SPAN></H3>
<P><A name=sec:extending-classes></A></P>
<P>We still need to be able to create new element objects. You have already seen that "<SPAN class=code>new</SPAN>&nbsp;<SPAN class=code>Element</SPAN>" cannot be used for this because class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is abstract. To instantiate an element, therefore, we will need to create a subclass that extends<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and implements the abstract<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:defining-subclass">Listing 10.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows one possible way to do that:<A id=i-1408184354-1></A><A id=i-1305664359-1></A></P>
<P><A name=lst:defining-subclass></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(conts:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;contents:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>&nbsp;=&nbsp;conts
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 10.3 - Defining<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>.</H5>
<P>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">extend</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>. Just like in Java, you use an extends clause after the class name to express this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  ...&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;...
</PRE>Such an extends clause has two effects: it makes class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">inherit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>all non-private members from class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>, and it makes the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">subtype</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>. Given<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>extends<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">subclass</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>.<A id=i-1485346100-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Conversely,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">superclass</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>.<A id=i1436252235-1></A> 
<P></P>
<P>If you leave out an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>extends</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause, the Scala compiler implicitly assumes your class extends from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.AnyRef</SPAN>, which on the Java platform is the same as class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Object</SPAN>. Thus, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>implicitly extends class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>. You can see these inheritance relationships in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#fig:element-family">Figure 10.1</A>.</P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:element-family></A>
<P><IMG alt="image images/ArrayElement.jpg" src="http://www.artima.com/pins1ed/images/ArrayElement.jpg"></P></DIV>
<H5>Figure 10.1 - Class diagram for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>.</H5>
<P><SPAN style="FONT-STYLE: italic">Inheritance</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>means that all members of the superclass are also members of the subclass, with two exceptions. First, private members of the superclass are not inherited in a subclass. Second, a member of a superclass is not inherited if a member with the same name and parameters is already implemented in the subclass. In that case we say the member of the subclass<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">overrides</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the member of the superclass. If the member in the subclass is concrete and the member of the superclass is abstract, we also say that the concrete member<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">implements</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>the abstract one.</P>
<P>For example, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>overrides (or,<SPAN class=Apple-converted-space>&nbsp;</SPAN>alternatively: implements) abstract method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#footnote10-2">[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>By contrast, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>inherits the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>height</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods from class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>. For example, given an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ae</SPAN>, you can query its width using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ae.width</SPAN>, as if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>were defined in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;ae&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"world"</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">ae:&nbsp;ArrayElement&nbsp;=&nbsp;ArrayElement@d94e60</SPAN>
  <BR>  scala&gt;&nbsp;ae.width
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;Int&nbsp;=&nbsp;5</SPAN>
</PRE>
<P></P>
<P><SPAN style="FONT-STYLE: italic">Subtyping</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>means that a value of the subclass can be used wherever a value of the superclass is required. For example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;e:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>))
</PRE>Variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined to be of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>, so its initializing value should also be an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>. In fact, the initializing value's type is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>. This is OK, because class<SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>extends class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>, and as a result, the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is compatible with the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#footnote10-3">[3]</A> 
<P></P>
<P><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#fig:element-family">Figure 10.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>also shows the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">composition</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>relationship that exists between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN><A id=i-838923862-1></A>. This relationship is called composition because class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is "composed" out of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN>, in that the Scala compiler will place into the binary class it generates for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>a field that holds a reference to the passed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>conts</SPAN>array. We'll discuss some design considerations concerning composition and inheritance later in this chapter, in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#sec:using-compo-inherit">Section 10.11</A>.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.5></A>10.5 Overriding methods and fields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.5">link</A>]</SPAN></H3>
<P><A name=sec:two-name-spaces></A></P>
<P>The uniform access principle is just one aspect where Scala treats<A id=i-1224666293-1></A><A id=i496223825-1></A><A id=i1471166698-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>fields and methods more uniformly than Java. Another difference is that in Scala, fields and methods belong to the same namespace. This makes it possible for a field to override a parameterless method. For instance, you could change the implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>from a method to a field without having to modify the abstract method definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:overriding-with-field">Listing 10.4</A>:</P>
<P><A name=lst:overriding-with-field></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(conts:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;contents:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>&nbsp;=&nbsp;conts
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 10.4 - Overriding a parameterless method with a field.</H5>
<P>Field<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(defined with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>) in this version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a perfectly good implementation of the parameterless method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(declared with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN>) in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>.</P>
<P>On the other hand, in Scala it is forbidden to define a field and method with the same name in the same class, whereas it is allowed in Java. For example, this Java class would compile just fine:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  //&nbsp;This&nbsp;is&nbsp;Java
  class&nbsp;CompilesFine&nbsp;{
  &nbsp;&nbsp;private&nbsp;int&nbsp;f&nbsp;=&nbsp;0;
  &nbsp;&nbsp;public&nbsp;int&nbsp;f()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
  &nbsp;&nbsp;}
  }
</PRE>But the corresponding Scala class would not compile:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">WontCompile</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;f&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Won't&nbsp;compile,&nbsp;because&nbsp;a&nbsp;field&nbsp;</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;f&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;and&nbsp;method&nbsp;have&nbsp;the&nbsp;same&nbsp;name</SPAN>
  }
</PRE>Generally, Scala has just two namespaces for definitions in place of Java's four.<A id=i765341585-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Java's four namespaces are fields, methods, types, and packages. By contrast, Scala's two namespaces are: 
<P></P>
<UL>
<LI>values (fields, methods, packages, and singleton objects) 
<LI>types (class and trait names)</LI></UL>The reason Scala places fields and methods into the same namespace is precisely so you can override a parameterless method with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>, something you can't do with Java.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#footnote10-4">[4]</A> 
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.6></A>10.6 Defining parametric fields<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.6">link</A>]</SPAN></H3>
<P><A name=sec:parametric-fields></A></P>
<P>Consider again the definition of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in the previous section. It has a<A id=i-590826255-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>conts</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>whose sole purpose is to be copied into the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field. The name<SPAN class=code>conts</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the parameter was chosen just so that it would look similar to the field name<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>without actually clashing with it. This is a "code smell," a sign that there may be some unnecessary redundancy and repetition in your code.</P>
<P>You can avoid the code smell by combining the parameter and the field in a single<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-1177929110"><EM style="FONT-STYLE: italic">parametric field</EM></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition,<A id=i763174956-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:parametric-field">Listing 10.5</A><A id=i2138903369-2></A>:</P>
<P><A name=lst:parametric-field></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;contents:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>
  &nbsp;&nbsp;)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>
</PRE>
<H5>Listing 10.5 - Defining<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a parametric field.</H5>
<P>Note that now the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter is prefixed by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>. This is a shorthand that defines at the same time a parameter and field with the same name. Specifically, class<SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>now has an (unreassignable) field<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN>, which can be accessed from outside the class. The field is initialized with the value of the parameter. It's as if the class had been written as follows, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x123</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an arbitrary fresh name for the parameter:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(x123:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;contents:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>&nbsp;=&nbsp;x123
  }
</PRE>You can also prefix a class parameter with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>, in which case the corresponding field would be reassignable.<A id=i332825445-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Finally, it is possible to add modifiers such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN>,<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#footnote10-5">[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=code>override</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to these parametric fields, just as you can do for any other class member.<A id=i-23781736-1></A><A id=i1026131843-1></A><A id=i1623377591-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Consider, for instance, the following class definitions:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cat</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;dangerous&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>
  }
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tiger</SPAN>(
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;dangerous:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>,
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;age:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
  )&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cat</SPAN>
</PRE><SPAN class=code>Tiger</SPAN>'s definition is a shorthand for the following alternate class definition with an overriding member<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>dangerous</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>member<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>age</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Tiger</SPAN>(param1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>,&nbsp;param2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Cat</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;dangerous&nbsp;=&nbsp;param1
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;age&nbsp;=&nbsp;param2
  }
</PRE>Both members are initialized from the corresponding parameters. We chose the names of those parameters,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>param1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>param2</SPAN>, arbitrarily. The important thing was that they not clash with any other name in scope. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.7></A>10.7 Invoking superclass constructors<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.7">link</A>]</SPAN></H3>
<P>You now have a complete system consisting of two classes: an abstract class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>, which is extended by a concrete class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>. You might also envision other ways to express an element.<A id=i1670701927-1></A><A id=i-1862849439-1></A><A id=i685242324-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, clients might want to create a layout element consisting of a single line given by a string. Object-oriented programming makes it easy to extend a system with new data-variants. You can simply add subclasses. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:invoking-superclass-constructor">Listing 10.6</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class that extends<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>:</P>
<P><A name=lst:invoking-superclass-constructor></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LineElement</SPAN>(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(s))&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;width&nbsp;=&nbsp;s.length
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;height&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  }
</PRE>
<H5>Listing 10.6 - Invoking a superclass constructor.</H5>
<P>Since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>extends<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>'s constructor takes a parameter (an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN>),<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>needs to pass an argument to the primary constructor of its superclass. To invoke a superclass constructor, you simply place the argument or arguments you want to pass in parentheses following the name of the superclass.<A id=i-2005725727-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>passes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array(s)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>'s primary constructor by placing it in parentheses after the superclass<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>'s name:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  ...&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(s))&nbsp;...
</PRE>With the new subclass, the inheritance hierarchy for layout elements now looks as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#fig:line-element">Figure 10.2</A>. 
<P></P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:line-element></A>
<P><IMG alt="image images/LineElement.jpg" src="http://www.artima.com/pins1ed/images/LineElement.jpg"></P></DIV>
<H5>Figure 10.2 - Class diagram for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN>.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.8></A>10.8 Using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>override</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifiers<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.8">link</A>]</SPAN></H3>
<P><A name=sec:using-override-modifiers></A></P>
<P>Note that the definitions of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>height</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>carry an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>override</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier. In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functional-objects.html#sec:reimp-tostring">Section 6.3</A>, you saw this modifier in the definition of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.<A id=i1201360043-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Scala requires such a modifier for all members that override a concrete member in a parent class. The modifier is optional if a member implements an abstract member with the same name. The modifier is forbidden if a member does not override or implement some other member in a base class. Since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>height</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>override concrete definitions in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>override</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is required.</P>
<P>This rule provides useful information for the compiler that helps avoid some hard-to-catch errors and makes system evolution safer. For instance, if you happen to misspell the method or accidentally give it a different parameter list, the compiler will respond with an error message:<A id=i934798591-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scalac&nbsp;LineElement.scala&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">.../LineElement.scala:50:</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">error:&nbsp;method&nbsp;hight&nbsp;overrides&nbsp;nothing</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;override&nbsp;def&nbsp;hight&nbsp;=&nbsp;1</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^&nbsp;</SPAN>
</PRE>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>override</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>convention is even more important when it comes to system evolution. Say you defined a library of 2D drawing methods. You made it publicly available, and it is widely used. In the next version of the library you want to add to your base class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Shape</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>a new method with this signature:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hidden():&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>
</PRE>Your new method will be used by various drawing methods to determine whether a shape needs to be drawn. This could lead to a significant speedup, but you cannot do this without the risk of breaking client code. After all, a client could have defined a subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Shape</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a different implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hidden</SPAN>. Perhaps the client's method actually makes the receiver object disappear instead of testing whether the object is hidden. Because the two versions of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hidden</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>override each other, your drawing methods would end up making objects disappear, which is certainly not what you want! These "accidental overrides" are the most common manifestation of what is called the "fragile base class" problem. The problem is that if you add new members to base classes (which we usually call superclasses) in a class hierarchy, you risk breaking client code. 
<P></P>
<P>Scala cannot completely solve the fragile base class problem, but it improves on the situation compared to Java.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#footnote10-6">[6]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>If the drawing library and its clients were written in Scala, then the client's original implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hidden</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>could not have had an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>override</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier, because at the time there was no other method with that name. Once you add the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hidden</SPAN>method to the second version of your shape class, a recompile of the client would give an error like the following:<A id=i-2133711083-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">.../Shapes.scala:6:&nbsp;error:&nbsp;error&nbsp;overriding&nbsp;method</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;hidden&nbsp;in&nbsp;class&nbsp;Shape&nbsp;of&nbsp;type&nbsp;()Boolean;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">method&nbsp;hidden&nbsp;needs&nbsp;`override'&nbsp;modifier</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">def&nbsp;hidden():&nbsp;Boolean&nbsp;=&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">^</SPAN>
</PRE>
<P></P>
<P>That is, instead of wrong behavior your client would get a compile-time error, which is usually much preferable.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.9></A>10.9 Polymorphism and dynamic binding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.9">link</A>]</SPAN></H3>
<P>You saw in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#sec:extending-classes">Section 10.4</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that a variable of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>could refer to an object of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>. The name for this phenomenon is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">polymorphism</EM>, which means "many shapes" or "many forms." In this case,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>objects can have many forms.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#footnote10-7">[7]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>So far, you've seen two such forms:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN>. You can create more forms of<SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by defining new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>subclasses. For example, here's how you could define a new form of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that has a given width and height and is filled everywhere with a given character:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UniformElement</SPAN>(
  &nbsp;&nbsp;ch:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Char</SPAN>,&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;
  )&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;line&nbsp;=&nbsp;ch.toString&nbsp;*&nbsp;width
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;contents&nbsp;=&nbsp;Array.make(height,&nbsp;line)
  }
</PRE>
<P></P>
<P>The inheritance hierarchy for class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>now looks as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#fig:layout-elements">Figure 10.3</A>. As a result, Scala will accept all of the following assignments, because the assigning expression's type conforms to the type of the defined variable:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;e1:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"world"</SPAN>))
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;ae:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LineElement</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;e2:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;ae
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;e3:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UniformElement</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'x'</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
</PRE>If you check the inheritance hierarchy, you'll find that in each of these four<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>definitions, the type of the expression to the right of the equals sign is below the type of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>being initialized to the left of the equals sign. 
<P></P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:layout-elements></A>
<P><IMG alt="image images/elementFamily.jpg" src="http://www.artima.com/pins1ed/images/elementFamily.jpg"></P></DIV>
<H5>Figure 10.3 - Class hierarchy of layout elements</H5>
<P>The other half of the story, however, is that method invocations on variables and expressions are<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">dynamically bound</EM>.<A id=i-1297249718-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This means that the actual method implementation invoked is determined at run time based on the class of the object, not the type of the variable or expression. To demonstrate this behavior, we'll temporarily remove all existing members from our<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>classes and add a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>demo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>. We'll override<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>demo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN>, but not in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UniformElement</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;demo()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"Element's&nbsp;implementation&nbsp;invoked"</SPAN>)
  &nbsp;&nbsp;}
  }
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;demo()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"ArrayElement's&nbsp;implementation&nbsp;invoked"</SPAN>)
  &nbsp;&nbsp;}
  }
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LineElement</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;demo()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"LineElement's&nbsp;implementation&nbsp;invoked"</SPAN>)
  &nbsp;&nbsp;}
  }
  <BR>  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;UniformElement&nbsp;inherits&nbsp;Element's&nbsp;demo</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UniformElement</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;
</PRE>
<P></P>
<P>If you enter this code into the interpreter, you can then define this method that takes an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and invokes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>demo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on it:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;invokeDemo(e:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>)&nbsp;{
  &nbsp;&nbsp;e.demo()
  }
</PRE>If you pass an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>invokeDemo</SPAN>, you'll see a message indicating<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>'s implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>demo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was invoked, even though the type of the variable,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>e</SPAN>, on which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>demo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was invoked is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;invokeDemo(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">ArrayElement's&nbsp;implementation&nbsp;invoked</SPAN>
</PRE>Similarly, if you pass a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>invokeDemo</SPAN>, you'll see a message that indicates<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN>'s<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>demo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>implementation was invoked:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;invokeDemo(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LineElement</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">LineElement's&nbsp;implementation&nbsp;invoked</SPAN>
</PRE>The behavior when passing a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UniformElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>may at first glance look suspicious, but it is correct:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;invokeDemo(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UniformElement</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">Element's&nbsp;implementation&nbsp;invoked</SPAN>
</PRE>Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UniformElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not override<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>demo</SPAN>, it inherits the implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>demo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from its superclass,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>. Thus,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>'s implementation is the correct implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>demo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to invoke when the class of the object is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UniformElement</SPAN>. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.10></A>10.10 Declaring final members<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.10">link</A>]</SPAN></H3>
<P>Sometimes when designing an inheritance hierarchy, you want to ensure that a member cannot be overridden by subclasses. In Scala, as in Java, you do this by adding a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>final</SPAN>modifier to the member.<A id=i-34445759-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, you could place a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>final</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>'s demo method, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:final-method">Listing 10.7</A>.</P>
<P><A name=lst:final-method></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">final</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;demo()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"ArrayElement's&nbsp;implementation&nbsp;invoked"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 10.7 - Declaring a final method.</H5>
<P>Given this version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>, an attempt to override demo in its subclass,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN>, would not compile:<A id=i-44166214-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">elem.scala:18:&nbsp;error:&nbsp;error&nbsp;overriding&nbsp;method&nbsp;demo</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;in&nbsp;class&nbsp;ArrayElement&nbsp;of&nbsp;type&nbsp;()Unit;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">method&nbsp;demo&nbsp;cannot&nbsp;override&nbsp;final&nbsp;member</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;def&nbsp;demo()&nbsp;{</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>You may also at times want to ensure that an entire class not be subclassed. To do this you simply declare the entire class final by adding a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>final</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier to the class declaration. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:final-class">Listing 10.8</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows how you would declare<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>final:</P>
<P><A name=lst:final-class></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">final</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;demo()&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"ArrayElement's&nbsp;implementation&nbsp;invoked"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 10.8 - Declaring a final class.</H5>
<P>With this version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>, any attempt at defining a subclass would fail to compile:<A id=i-1180851066-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">elem.scala:&nbsp;18:&nbsp;error:&nbsp;illegal&nbsp;inheritance&nbsp;from&nbsp;final&nbsp;class</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;ArrayElement</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;class&nbsp;LineElement&nbsp;extends&nbsp;ArrayElement&nbsp;{</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>We'll now remove the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>final</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifiers and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>demo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods, and go back to the earlier implementation of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>family. We'll focus our attention in the remainder of this chapter to completing a working version of the layout library.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.11></A>10.11 Using composition and inheritance<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.11">link</A>]</SPAN></H3>
<P><A name=sec:using-compo-inherit></A></P>
<P>Composition and inheritance are two ways to define a new class in terms of another existing class.<A id=i-838923862-2></A><A id=i-613838584-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>If what you're after is primarily code reuse, you should in general prefer composition to inheritance. Only inheritance suffers from the fragile base class problem, in which you can inadvertently break subclasses by changing a superclass.</P>
<P>One question you can ask yourself about an inheritance relationship is whether it models an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">is-a</EM><A id=i-422624999-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>relationship.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#footnote10-8">[8]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, it would be reasonable to say that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">is-an</EM><SPAN class=code>Element</SPAN>. Another question you can ask is whether clients will want to use the subclass type as a superclass type.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#footnote10-9">[9]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In the case of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>, we do indeed expect clients will want to use an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>.</P>
<P>If you ask these questions about the inheritance relationships shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#fig:layout-elements">Figure 10.3</A>, do any of the relationships seem suspicious? In particular, does it seem obvious to you that a<SPAN class=code>LineElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">is-an</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>? Do you think clients would ever need to use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>? In fact, we defined<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>primarily to reuse<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>'s definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN>. Perhaps it would be better, therefore, to define<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a direct subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LineElement</SPAN>(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;contents&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(s)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;width&nbsp;=&nbsp;s.length
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;height&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  }
</PRE>In the previous version,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>had an inheritance relationship with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>, from which it inherited<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN>. It now has a composition relationship with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN>: it holds a reference to an array of strings from its own<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#footnote10-10">[10]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Given this implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN>, the inheritance hierarchy for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>now looks as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#fig:new-line-element">Figure 10.4</A>. 
<P></P>
<DIV class=figure style="MARGIN-TOP: 0.75em; TEXT-ALIGN: center"><A name=fig:new-line-element></A>
<P><IMG alt="image images/elementFamily2.jpg" src="http://www.artima.com/pins1ed/images/elementFamily2.jpg"></P></DIV>
<H5>Figure 10.4 - Class hierarchy with revised<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN>.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.12></A>10.12 Implementing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>above</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>beside</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.12">link</A>]</SPAN></H3>
<P><A name=sec:impl-above-beside-tostring></A></P>
<P>As a next step, we'll implement method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>above</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>. Putting one element above another means concatenating the two<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>values of the elements. So a first draft of method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>above</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>could look like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;above(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.contents&nbsp;++&nbsp;that.contents)
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>++</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation concatenates two arrays. Arrays in Scala are represented as Java arrays, but support many more methods<A id=i-1409164998-1></A>. Specifically, arrays in Scala inherit from a class<SPAN class=code>scala.Seq</SPAN>, which represents sequence-like structures and contains a number of methods for accessing and transforming sequences.<A id=i-1529225491-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Some other array methods will be explained in this chapter, and a comprehensive discussion will be given in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html">Chapter 17</A>. 
<P></P>
<P>In fact, the code shown previously is not quite sufficient, because it does not permit you to put elements of different widths on top of each other. To keep things simple in this section, however, we'll leave this as is and only pass elements of the same length to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>above</SPAN>. In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#sec:heighten-and-widen">Section 10.14</A>, we'll make an enhancement to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>above</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>so that clients can use it to combine elements of different widths.</P>
<P>The next method to implement is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>beside</SPAN>. To put two elements beside each other, we'll create a new element in which every line results from concatenating corresponding lines of the two elements. As before, to keep things simple we'll start by assuming the two elements have the same height. This leads to the following design of method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>beside</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;beside(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;contents&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.contents.length)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(i&nbsp;&lt;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;until&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.contents.length)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;contents(i)&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.contents(i)&nbsp;+&nbsp;that.contents(i)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(contents)
  }
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>beside</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method first allocates a new array,<A id=i-1690228669-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN>and fills it with the concatenation of the corresponding array elements in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this.contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>that.contents</SPAN>. It finally produces a new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>containing the new<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN>. 
<P></P>
<P>Although this implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>beside</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>works, it is in an imperative style, the telltale sign of which is the loop in which we index through arrays. The method could alternatively be abbreviated to one expression:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;(line1,&nbsp;line2)&nbsp;&lt;-&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.contents&nbsp;zip&nbsp;that.contents
  &nbsp;&nbsp;)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;line1&nbsp;+&nbsp;line2
  )
</PRE>Here, the two arrays<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>this.contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>that.contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are transformed into an array of pairs (as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tuple2</SPAN>s are called)<A id=i1832062192-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>zip</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>zip</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method picks corresponding elements in its two arguments and forms an array of pairs. For instance, this expression:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)&nbsp;zip&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"b"</SPAN>)
</PRE>will evaluate to:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>((<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a"</SPAN>),&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"b"</SPAN>))
</PRE>If one of the two operand arrays is longer than the other,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>zip</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will drop the remaining elements. In the expression above, the third element of the left operand,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>3</SPAN>, does not form part of the result, because it does not have a corresponding element in the right operand. 
<P></P>
<P>The zipped array is then iterated over by a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. Here, the syntax "<SPAN class=code>for</SPAN>&nbsp;<SPAN class=code>((line1,</SPAN>&nbsp;<SPAN class=code>line2)</SPAN>&nbsp;<SPAN class=code>&lt;-</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>...<SPAN class=code>)</SPAN>" allows you to name both elements of a pair in one<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">pattern</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>line1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>stands now for the first element of the pair, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>line2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>stands for the second. Scala's pattern-matching system will be described in detail in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html">Chapter 15</A>. For now, you can just think of this as a way to define two<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>line1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>line2</SPAN>, for each step of the iteration.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression has a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>yield</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>part and therefore yields a result. The result is of the same kind as the expression iterated over,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>, it is an array. Each element of the array is the result of concatenating the corresponding lines,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>line1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>line2</SPAN>. So the end result of this code is the same as in the first version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>beside</SPAN>, but because it avoids explicit array indexing, the result is obtained in a less error-prone way.</P>
<P>You still need a way to display elements. As usual, this is done by defining a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that returns an element formatted as a string. Here is its definition:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;contents&nbsp;mkString&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"\n"</SPAN>
</PRE>The implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>makes use of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mkString</SPAN>, which is defined for all sequences, including arrays. As you saw in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/builtin-control-structures.html#sec:refactoring-imperative-code">Section 7.8</A>, an expression like "<SPAN class=code>arr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mkString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sep</SPAN>" returns a string consisting of all elements of the array<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arr</SPAN>. Each element is mapped to a string by calling its<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. A separator string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sep</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is inserted between consecutive element strings. So the expression "<SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mkString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"\n"</SPAN>" formats the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>array as a string, where each array element appears on a line by itself. 
<P></P>
<P>Note that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not carry an empty parameter list. This follows the recommendations for the uniform access principle, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a pure method that does not take any parameters.</P>
<P>With the addition of these three methods, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>now looks as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:element-with-three-methods">Listing 10.9</A>.</P>
<P><A name=lst:element-with-three-methods></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;contents:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(height&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;contents(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>).length
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;contents.length
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;above(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.contents&nbsp;++&nbsp;that.contents)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;beside(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(line1,&nbsp;line2)&nbsp;&lt;-&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.contents&nbsp;zip&nbsp;that.contents
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;line1&nbsp;+&nbsp;line2
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;contents&nbsp;mkString&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"\n"</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 10.9 - Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>above</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>beside</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN>.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.13></A>10.13 Defining a factory object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.13">link</A>]</SPAN></H3>
<P>You now have a hierarchy of classes for layout elements. This<A id=i-640194953-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>hierarchy could be presented to your clients "as is." But you might also choose to hide the hierarchy behind a factory object.<A id=i867568852-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>A factory object contains methods that construct other objects. Clients would then use these factory methods for object construction rather than constructing the objects directly with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN>. An advantage of this approach is that object creation can be centralized and the details of how objects are represented with classes can be hidden. This hiding will both<A id=i593484137-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>make your library simpler for clients to understand, because less detail is exposed, and provide you with more opportunities to change your library's implementation later without breaking client code.</P>
<P>The first task in constructing a factory for layout elements is to choose where the factory methods should be located. Should they be members of a singleton object or of a class? What should the containing object or class be called? There are many possibilities. A straightforward solution is to create a companion object of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and make this be the factory object for layout elements. That way, you need to expose only the class/object combo of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to your clients, and you can hide the three implementation classes<SPAN class=code>ArrayElement</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UniformElement</SPAN>.</P>
<P><A name=lst:factory-object-and-methods></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;elem(contents:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(contents)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;elem(chr:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Char</SPAN>,&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UniformElement</SPAN>(chr,&nbsp;width,&nbsp;height)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;elem(line:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LineElement</SPAN>(line)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 10.10 - A factory object with factory methods.</H5>
<P><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:factory-object-and-methods">Listing 10.10</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a design of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object that follows this scheme. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>companion object contains three overloaded variants of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. Each variant constructs a different kind of layout object.</P>
<P>With the advent of these factory methods, it makes sense to change the implementation of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>so that it goes through the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>factory methods rather than creating new<SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instances explicitly. To call the factory methods without qualifying them with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>, the name of the singleton object, we will import<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element.elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>at the top of the source file. In other words, instead of invoking the factory methods with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element.elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>inside class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>, we'll import<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element.elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>so we can just call the factory methods by their simple name,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elem</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:element-using-factory-methods">Listing 10.11</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows what class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will look like after these changes.</P>
<P><A name=lst:element-using-factory-methods></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;Element.elem
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;contents:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(height&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;contents(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>).length
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;contents.length
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;above(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.contents&nbsp;++&nbsp;that.contents)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;beside(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(line1,&nbsp;line2)&nbsp;&lt;-&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.contents&nbsp;zip&nbsp;that.contents
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;line1&nbsp;+&nbsp;line2
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;contents&nbsp;mkString&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"\n"</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 10.11 - Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>refactored to use factory methods.</H5>
<P>In addition, given the factory methods, the subclasses<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LineElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>UniformElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>could now be private, because they need no longer be accessed directly by clients. In Scala, you can define classes and singleton objects inside other classes and singleton objects.<A id=i1315254152-1></A><A id=i1968015105-1></A><A id=i-1545427464-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>One way to make the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>subclasses private, therefore, is to place them inside the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>singleton object and declare them private there. The classes will still be accessible to the three<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elem</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>factory methods, where they are needed.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:hiding-implementation">Listing 10.12</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows how that will look.</P>
<P><A name=lst:hiding-implementation></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;contents:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LineElement</SPAN>(s:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;contents&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(s)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;width&nbsp;=&nbsp;s.length
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;height&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UniformElement</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Char</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;line&nbsp;=&nbsp;ch.toString&nbsp;*&nbsp;width
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;contents&nbsp;=&nbsp;Array.make(height,&nbsp;line)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;elem(contents:&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(contents)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;elem(chr:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Char</SPAN>,&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">UniformElement</SPAN>(chr,&nbsp;width,&nbsp;height)
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;elem(line:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LineElement</SPAN>(line)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 10.12 - Hiding implementation with private classes.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.14></A>10.14 Heighten and widen<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.14">link</A>]</SPAN></H3>
<P><A name=sec:heighten-and-widen></A></P>
<P>We need one last enhancement. The version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:element-using-factory-methods">Listing 10.11</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not quite sufficient, because it does not allow clients to place elements of different widths on top of each other, or place elements of different heights beside each other. For example, evaluating the following expression would not work correctly, because the second line in the combined element is longer than the first:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>))&nbsp;above&nbsp;
  <SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"world!"</SPAN>))
</PRE>Similarly, evaluating the following expression would not work properly, because the first<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has a height of two, and the second a height of only one:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"one"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"two"</SPAN>))&nbsp;beside&nbsp;
  <SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">ArrayElement</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"one"</SPAN>))
</PRE>
<P></P>
<P><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:widen-heighten-methods">Listing 10.13</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows a private helper method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>widen</SPAN>, which takes a width and returns an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of that width. The result contains the contents of this<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>, centered, padded to the left and right by any spaces needed to achieve the required width.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:widen-heighten-methods">Listing 10.13</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>also shows a similar method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>heighten</SPAN>, which performs the same function in the vertical direction. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>widen</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is invoked by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>above</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to ensure that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN>s placed above each other have the same width. Similarly, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>heighten</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is invoked by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>beside</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to ensure that elements placed beside each other have the same height. With these changes, the layout library is ready for use.</P>
<P><A name=lst:widen-heighten-methods></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;Element.elem
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;contents:&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;contents(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>).length
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;height:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;contents.length
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;above(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;this1&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>&nbsp;widen&nbsp;that.width
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;that1&nbsp;=&nbsp;that&nbsp;widen&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.width
  &nbsp;&nbsp;&nbsp;&nbsp;elem(this1.contents&nbsp;++&nbsp;that1.contents)
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;beside(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;this1&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>&nbsp;heighten&nbsp;that.height
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;that1&nbsp;=&nbsp;that&nbsp;heighten&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>.height
  &nbsp;&nbsp;&nbsp;&nbsp;elem(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;((line1,&nbsp;line2)&nbsp;&lt;-&nbsp;this1.contents&nbsp;zip&nbsp;that1.contents)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;line1&nbsp;+&nbsp;line2)
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;widen(w:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(w&nbsp;&lt;=&nbsp;width)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;left&nbsp;=&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'&nbsp;'</SPAN>,&nbsp;(w&nbsp;-&nbsp;width)&nbsp;/&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;height)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;right&nbsp;=&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'&nbsp;'</SPAN>,&nbsp;w&nbsp;-&nbsp;width&nbsp;-&nbsp;left.width,&nbsp;height)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;beside&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>&nbsp;beside&nbsp;right
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;heighten(h:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(h&nbsp;&lt;=&nbsp;height)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;top&nbsp;=&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'&nbsp;'</SPAN>,&nbsp;width,&nbsp;(h&nbsp;-&nbsp;height)&nbsp;/&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;bot&nbsp;=&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'&nbsp;'</SPAN>,&nbsp;width,&nbsp;h&nbsp;-&nbsp;height&nbsp;-&nbsp;top.height)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top&nbsp;above&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>&nbsp;above&nbsp;bot
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">override</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString&nbsp;=&nbsp;contents&nbsp;mkString&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"\n"</SPAN>
  }
</PRE>
<H5>Listing 10.13 -<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Element</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>widen</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>heighten</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods.</H5>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.15></A>10.15 Putting it all together<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.15">link</A>]</SPAN></H3>
<P><A name=sec:putting-it-together></A></P>
<P>A fun way to exercise almost all elements of the layout library is to write a program that draws a spiral with a given number of edges. This<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Spiral</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>program, shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:spiral-app">Listing 10.14</A>, will do just that:</P>
<P><A name=lst:spiral-app></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;Element.elem
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Spiral</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;space&nbsp;=&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;corner&nbsp;=&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>)
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;spiral(nEdges:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;direction:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Element</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(nEdges&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"+"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;sp&nbsp;=&nbsp;spiral(nEdges&nbsp;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;(direction&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)&nbsp;%&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;verticalBar&nbsp;=&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'|'</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;sp.height)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;horizontalBar&nbsp;=&nbsp;elem(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'-'</SPAN>,&nbsp;sp.width,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(direction&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(corner&nbsp;beside&nbsp;horizontalBar)&nbsp;above&nbsp;(sp&nbsp;beside&nbsp;space)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(direction&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sp&nbsp;above&nbsp;space)&nbsp;beside&nbsp;(corner&nbsp;above&nbsp;verticalBar)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(direction&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(space&nbsp;beside&nbsp;sp)&nbsp;above&nbsp;(horizontalBar&nbsp;beside&nbsp;corner)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(verticalBar&nbsp;above&nbsp;corner)&nbsp;beside&nbsp;(space&nbsp;above&nbsp;sp)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;main(args:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;nSides&nbsp;=&nbsp;args(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>).toInt
  &nbsp;&nbsp;&nbsp;&nbsp;println(spiral(nSides,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>))
  &nbsp;&nbsp;}
  }
</PRE>
<H5>Listing 10.14 - The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Spiral</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>application.</H5>
<P>Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Spiral</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a standalone object with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>main</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method with the proper signature, it is a Scala application.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Spiral</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes one command-line argument, an integer, and draws a spiral with the specified number of edges. For example, you could draw a six-edge spiral as shown below on the left, and larger spirals as shown to the right:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;Spiral&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;scala&nbsp;Spiral&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;scala&nbsp;Spiral&nbsp;17
  +-----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+----------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+----------------
  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  |&nbsp;+-+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;+------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;+------------+&nbsp;
  |&nbsp;+&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;
  |&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;+--+&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;+--------+&nbsp;|&nbsp;
  +---+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;++&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;+----+&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;+----+&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;++&nbsp;|&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+--------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;+--+&nbsp;|&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;+------+&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;+----------+&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+--------------+&nbsp;
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=10.16></A>10.16 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#10.16">link</A>]</SPAN></H3>
<P>In this section, you saw more concepts related to object-oriented programming in Scala. Among others, you encountered abstract classes, inheritance and subtyping, class hierarchies, parametric fields, and method overriding. You should have developed a feel for constructing a non-trivial class hierarchy in Scala. We'll work with the layout library again in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/assertions-and-unit-testing.html">Chapter 14</A>.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 10:</H4>
<P><A name=footnote10-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Meyer,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Object-Oriented Software Construction</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#meyer:oo-soft-con">meyer:oo-soft-con</A><A id=i1013925756-1></A><A id=i730601900-1></A></P>
<P><A name=footnote10-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>One flaw with this design is that because the returned array is mutable, clients could change it. For the book we'll keep things simple, but were<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>part of a real project, you might consider returning a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">defensive copy</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the array instead. Another problem is we aren't currently ensuring that every<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>element of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>array has the same length. This could be solved by checking the precondition in the primary constructor, and throwing an exception if it is violated.</P>
<P><A name=footnote10-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For more perspective on the difference between subclass and subtype, see the glossary entry for<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-1867567750"><EM style="FONT-STYLE: italic">subtype</EM></A>.</P>
<P><A name=footnote10-4>[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The reason that packages share the same namespace as fields and methods in Scala is to enable you to import packages in addition to just importing the names of types, and the fields and methods of singleton objects. This is also something you can't do in Java. It will be described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#sec:imports">Section 13.2</A>.</P>
<P><A name=footnote10-5>[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier, which grants access to subclasses, will be covered in detail in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html">Chapter 13</A>.</P>
<P><A name=footnote10-6>[6]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In Java 1.5, an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>@Override</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>annotation was introduced that works similarly to Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>override</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier, but unlike Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>override</SPAN>, is not required.</P>
<P><A name=footnote10-7>[7]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This kind of polymorphism is called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">subtyping polymorphism</EM><A id=i63796807-1></A><A id=i367948816-1></A>. Another kind of polymorphism in Scala, called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">universal polymorphism</EM>, is discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html">Chapter 19</A>.</P>
<P><A name=footnote10-8>[8]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Meyers,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Effective C++</EM><A id=i-1960871386-1></A><A id=i-1839614926-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#meyers:effective-cpp">meyers:effective-cpp</A></P>
<P><A name=footnote10-9>[9]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Eckel,<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">Thinking in Java</EM><A id=i1711840479-1></A><A id=i-107465203-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/bibliography.html#eckel:thinking-in-java">eckel:thinking-in-java</A></P>
<P><A name=footnote10-10>[10]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>also has a composition relationship with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN>, because its parametric<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>contents</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>field holds a reference to an array of strings. The code for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ArrayElement</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:parametric-field">Listing 10.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#lst:parametric-field">here</A>. Its composition relationship is represented in class diagrams by a diamond, as shown, for example, in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#fig:element-family">Figure 10.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#fig:element-family">here</A>.</P></DIV>