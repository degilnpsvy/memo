<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 16 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Working with Lists</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>Lists are probably the most commonly used data structure in Scala programs<A id=i102982549-2></A>. This chapter explains lists in detail. It presents many common operations that can be performed on lists. It also teaches some important design principles for programs working on lists.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=16.1></A>16.1 List literals<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#16.1">link</A>]</SPAN></H3>
<P>You saw lists already in the preceding chapters, so you know that a list containing the elements<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>'a'</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>'b'</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>'c'</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is written<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List('a',</SPAN>&nbsp;<SPAN class=code>'b',</SPAN>&nbsp;<SPAN class=code>'c')</SPAN>.<A id=i-2038506824-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Here are some other examples:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;fruit&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"apples"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"oranges"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"pears"</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;nums&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;diag3&nbsp;=
  &nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;empty&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
</PRE>Lists are quite similar to arrays, but there are two important differences. First, lists are immutable. That is, elements of a list cannot be changed by assignment. Second, lists have a recursive structure (<I>i.e.</I>, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">linked list</EM><A id=i594306766-1></A>),<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#footnote16-1">[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>whereas arrays are flat. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=16.2></A>16.2 The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#16.2">link</A>]</SPAN></H3>
<P>Like arrays, lists are<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">homogeneous</SPAN>: the elements of a list all have the same type. The type of a list that has elements of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is written<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]</SPAN>. For instance, here are the same four lists with explicit types added:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;fruit:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[String]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"apples"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"oranges"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"pears"</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;nums:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;diag3:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[List[Int]]</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  &nbsp;&nbsp;)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;empty:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Nothing]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
</PRE>
<P></P>
<P>The list type in Scala is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">covariant</SPAN><A id=i-1469695991-1></A>. This means that for each pair of types<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>S</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>S</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>, then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[S]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]</SPAN>. For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[String]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of<SPAN class=code>List[Object]</SPAN>. This is natural because every list of strings can also be seen as a list of objects.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#footnote16-2">[2]</A></P>
<P>Note that the empty list has type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Nothing]</SPAN>.<A id=i-727376847-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You saw in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scalas-hierarchy.html#sec:bottom-types">Section 11.3</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nothing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the bottom type in Scala's class hierarchy. It is a subtype of every other Scala type. Because lists are covariant, it follows that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Nothing]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]</SPAN>, for any type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>. So the empty list object, which has type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Nothing]</SPAN>, can also be seen as an object of every other list type of the form<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]</SPAN>. That's why it is permissible to write code like:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;List()&nbsp;is&nbsp;also&nbsp;of&nbsp;type&nbsp;List[String]!</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[String]</SPAN>&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;&nbsp;
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=16.3></A>16.3 Constructing lists<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#16.3">link</A>]</SPAN></H3>
<P>All lists are built from two fundamental building blocks,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><A id=i1899558990-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN>(pronounced "cons").<A id=i1411857630-2></A><A id=i1674095775-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>represents the empty list. The infix operator,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN>, expresses list extension at the front. That is,<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>represents a list whose first element is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>, followed by (the elements of) list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>. Hence, the previous list values could also have been defined as follows:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;fruit&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"apples"</SPAN>&nbsp;::&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"oranges"</SPAN>&nbsp;::&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"pears"</SPAN>&nbsp;::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>))
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;nums&nbsp;&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;::&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;::&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>&nbsp;::&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>&nbsp;::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)))
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;diag3&nbsp;=&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;::&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;::&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)))&nbsp;::
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;::&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;::&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)))&nbsp;::
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;::&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;::&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)))&nbsp;::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;empty&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>
</PRE>In fact the previous definitions of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>fruit</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>nums</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>diag3</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>empty</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in terms of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(...)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are just wrappers that expand to these definitions. For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>creates the list<SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>(2</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>(3</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>Nil))</SPAN>. 
<P></P>
<P>Because it ends in a colon, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN>operation associates to the right:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>B</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>C</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is interpreted as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>(B</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>C)</SPAN>.<A id=i-1491182453-2></A><A id=i620923488-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Therefore, you can drop the parentheses in the previous definitions. For instance:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;nums&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;::&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;::&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>&nbsp;::&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>&nbsp;::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>
</PRE>is equivalent to the previous definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>nums</SPAN>. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=16.4></A>16.4 Basic operations on lists<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#16.4">link</A>]</SPAN></H3>
<P>All operations on lists can be expressed in terms of the following three:<A id=i-735890706-2></A><A id=i849842526-2></A><A id=i1657074897-2></A><A id=i-1093268841-2></A><A id=i1464399372-2></A><A id=i1464753276-2></A></P>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="">
<TD><SPAN class=code>head</SPAN></TD>
<TD>returns the first element of a list</TD></TR>
<TR class="">
<TD><SPAN class=code>tail</SPAN></TD>
<TD>returns a list consisting of all elements except the first</TD></TR>
<TR class="">
<TD><SPAN class=code>isEmpty</SPAN></TD>
<TD>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the list is empty</TD></TR></TBODY></TABLE>
<P>These operations are defined as methods of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. Some examples are shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#tab:lists:basics">Table 16.1</A>.</P>
<P><A name=tab:lists:basics></A></P>
<H5>Table 16.1 - Basic list operations</H5>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">What it is</SPAN></SPAN></TD>
<TD style="BORDER-TOP: black thin solid"><SPAN style="FONT-SIZE: medium"><SPAN style="FONT-WEIGHT: bold">What it does</SPAN></SPAN></TD></TR>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><SPAN class=code>empty.isEmpty</SPAN></TD>
<TD style="BORDER-TOP: black thin solid">returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>fruit.isEmpty</SPAN></TD>
<TD>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>fruit.head</SPAN></TD>
<TD>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"apples"</SPAN></TD></TR>
<TR class="">
<TD><SPAN class=code>fruit.tail.head</SPAN></TD>
<TD>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>"oranges"</SPAN></TD></TR>
<TR class=bottomline style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TD style="BORDER-BOTTOM: black thin solid"><SPAN class=code>diag3.head</SPAN></TD>
<TD style="BORDER-BOTTOM: black thin solid">returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(1,</SPAN>&nbsp;<SPAN class=code>0,</SPAN>&nbsp;<SPAN class=code>0)</SPAN></TD></TR></TBODY></TABLE></DIV>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods are defined only for non-empty lists. When selected from an empty list, they throw an exception. For instance:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;Nil.head
  <SPAN class=output style="COLOR: rgb(90,0,0)">java.util.NoSuchElementException:&nbsp;head&nbsp;of&nbsp;empty&nbsp;list</SPAN>
</PRE>As an example of how lists can be processed, consider sorting the elements of a list of numbers into ascending order. One simple way to do so is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">insertion sort</SPAN>,<A id=i132601811-1></A><A id=i-1814033297-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which works as follows: To sort a non-empty list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>xs</SPAN>, sort the remainder<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and insert the first element<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>at the right position in the result. Sorting an empty list yields the empty list. Expressed as Scala code, the insertion sort algorithm looks like:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isort(xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(xs.isEmpty)&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;insert(xs.head,&nbsp;isort(xs.tail))
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;insert(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(xs.isEmpty&nbsp;||&nbsp;x&nbsp;&lt;=&nbsp;xs.head)&nbsp;x&nbsp;::&nbsp;xs
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;xs.head&nbsp;::&nbsp;insert(x,&nbsp;xs.tail)
</PRE>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=16.5></A>16.5 List patterns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#16.5">link</A>]</SPAN></H3>
<P><A name=sec:list-patterns></A></P>
<P>Lists can also be taken apart using pattern matching<A id=i1817770109-1></A>. List patterns correspond one-by-one to list expressions. You can either match on all elements of a list using a pattern of the form<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(...)</SPAN>, or you take lists apart bit by bit using patterns composed from the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nil</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>constant.</P>
<P>Here's an example of the first kind of pattern:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(a,&nbsp;b,&nbsp;c)&nbsp;=&nbsp;fruit
  <SPAN class=output style="COLOR: rgb(90,0,0)">a:&nbsp;String&nbsp;=&nbsp;apples</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">b:&nbsp;String&nbsp;=&nbsp;oranges</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">c:&nbsp;String&nbsp;=&nbsp;pears</SPAN>
</PRE>The pattern List(a, b, c) matches lists of length 3, and binds the three elements to the pattern variables<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>c</SPAN>. If you don't know the number of list elements beforehand, it's better to match with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead. For instance, the pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>b</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>rest</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>matches lists of length 2 or greater: 
<P></P>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">About pattern matching on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>s</H3>
<P>If you review the possible forms of patterns explained in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html">Chapter 15</A>, you might find that neither<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(...)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>nor<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>looks like it fits one of the kinds of patterns defined there. In fact,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(...)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an instance of a library-defined<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">extractor</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>pattern<A id=i-1414877783-1></A>. Such patterns will be treated in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/extractors.html">Chapter 24</A>. The "cons" pattern<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a special case of an infix operation pattern. You know already that, when seen as an expression, an infix operation is equivalent to a method call. For patterns, the rules are different: When seen as a pattern, an infix operation such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>&nbsp;<SPAN class=code>op</SPAN>&nbsp;<SPAN class=code>q</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is equivalent to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op(p,</SPAN>&nbsp;<SPAN class=code>q)</SPAN>. That is, the infix operator<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is treated as a constructor pattern. In particular, a cons pattern such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is treated as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::(x,</SPAN>&nbsp;<SPAN class=code>xs)</SPAN>. This hints that there should be a class named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that corresponds to the pattern constructor. Indeed there is such as class. It is named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and is exactly the class that builds non-empty lists. So<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>exists twice in Scala, once as a name of a class in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN>, and again as a method in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. The effect of the method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is to produce an instance of the class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.::</SPAN>. You'll find out more details about how the List class is implemented in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html">Chapter 22</A>.</P></DIV><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;a&nbsp;::&nbsp;b&nbsp;::&nbsp;rest&nbsp;=&nbsp;fruit
  <SPAN class=output style="COLOR: rgb(90,0,0)">a:&nbsp;String&nbsp;=&nbsp;apples</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">b:&nbsp;String&nbsp;=&nbsp;oranges</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">rest:&nbsp;List[String]&nbsp;=&nbsp;List(pears)</SPAN>
</PRE>Taking<A id=i-986649610-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>lists apart with patterns is an alternative to taking them apart with the basic methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isEmpty</SPAN>. For instance, here's insertion sort<A id=i132601811-2></A><A id=i-1814033297-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>again, this time written with pattern matching:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isort(xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>&nbsp;=&nbsp;xs&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;&nbsp;&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;insert(x,&nbsp;isort(xs1))
  }
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;insert(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>&nbsp;=&nbsp;xs&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;y&nbsp;::&nbsp;ys&nbsp;=&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;&lt;=&nbsp;y)&nbsp;x&nbsp;::&nbsp;xs&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;y&nbsp;::&nbsp;insert(x,&nbsp;ys)
  }
</PRE>
<P>Often, pattern matching over lists is clearer than decomposing them with methods, so pattern matching should be a part of your list processing toolbox.</P>
<P>This is all you need to know about lists in Scala to be able to use them correctly. However, there are also a large number of methods that capture common patterns of operations over lists. These methods make list processing programs more concise and often clearer. The next two sections present the most important methods defined in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=16.6></A>16.6 First-order methods on class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#16.6">link</A>]</SPAN></H3>
<P>This section explains most first-order methods defined in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><A id=i-570225502-1></A><A id=i254621440-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. A method is<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">first-order</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>if it does not take any functions as arguments<A id=i-461147607-1></A>. The section also introduces by means of two examples some recommended techniques to structure programs that operate on lists.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Concatenating lists</H4>
<P>An operation similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is list concatenation, written<A id=i-1839436249-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>`<SPAN class=code>:::</SPAN>'. Unlike<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes two lists as operands<A id=i55390901-2></A><A id=i-1436258358-1></A>. The result of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>:::</SPAN>&nbsp;<SPAN class=code>ys</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a new list that contains all the elements of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>, followed by all the elements of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ys</SPAN>. Here are some examples:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)&nbsp;:::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;:::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)&nbsp;:::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4)</SPAN>
</PRE>Like cons, list concatenation associates to the right. An expression like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  xs&nbsp;:::&nbsp;ys&nbsp;:::&nbsp;zs
</PRE>is interpreted like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  xs&nbsp;:::&nbsp;(ys&nbsp;:::&nbsp;zs)
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">The Divide and Conquer principle</H4>
<P>Concatenation (<SPAN class=code>:::</SPAN>) is implemented as a method in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. It<A id=i673902975-1></A><A id=i1224006146-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>would also be possible to implement concatenation "by hand," using pattern matching on lists. It's instructive to try to do that yourself, because it shows a common way to implement algorithms using lists. First, we'll settle on a signature for the concatenation method, which we'll call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN>. In order not to mix things up too much, assume that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined outside the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. So it will take the two lists to be concatenated as parameters. These two lists must agree on their element type, but that element type can be arbitrary. This can be expressed by giving<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>a type parameter<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#footnote16-3">[3]</A><A id=i-940554758-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that represents the element type of the two input lists:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;append[T](xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>,&nbsp;ys:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>
</PRE>To design the implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN>, it pays to remember the "divide and conquer" design principle for programs over recursive data structures such as lists. Many algorithms over lists first split an input list into simpler cases using a pattern match. That's the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">divide</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>part of the principle. They then construct a result for each case. If the result is a non-empty list, some of its parts may be constructed by recursive invocations of the same algorithm. That's the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">conquer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>part of the principle. 
<P></P>
<P>To apply this principle to the implementation of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method,<SPAN class=Apple-converted-space>&nbsp;</SPAN>the first question to ask is on which list to match. This is less trivial in the case of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>than for many other methods because there are two choices. However, the subsequent "conquer" phase tells you that you need to construct a list consisting of all elements of both input lists. Since lists are constructed from the back towards the front,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ys</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can remain intact whereas<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will need to be taken apart and prepended to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ys</SPAN>. Thus, it makes sense to concentrate on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a source for a pattern match. The most common pattern match over lists simply distinguishes an empty from a non-empty list. So this gives the following outline of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>append</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;append[T](xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>,&nbsp;ys:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;=
  &nbsp;&nbsp;xs&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;=&gt;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;??</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;??</SPAN>
  &nbsp;&nbsp;}
</PRE>All that remains is to fill in the two places marked with "<SPAN class=code>??</SPAN>". The first such place is the alternative where the input list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is empty. In this case concatenation yields the second list:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;=&gt;&nbsp;ys
</PRE>The second place left open is the alternative where the input list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>consists of some head<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>followed by a tail<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs1</SPAN>. In this case the result is also a non-empty list. To construct a non-empty list you need to know what the head and the tail of that list should be. You know that the first element of the result list is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>. As for the remaining elements, these can be computed by appending the rest of the first list,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs1</SPAN>, to the second list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ys</SPAN>. This completes the design and gives:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;append[T](xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>,&nbsp;ys:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;=
  &nbsp;&nbsp;xs&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;=&gt;&nbsp;ys
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;x&nbsp;::&nbsp;append(xs1,&nbsp;ys)
  &nbsp;&nbsp;}
</PRE>The computation of the second alternative illustrated the "conquer" part of the divide and conquer principle: Think first what the shape of the desired output should be, then compute the individual parts of that shape, using recursive invocations of the algorithm where appropriate. Finally, construct the output from these parts. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Taking the length of a list:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>length</SPAN></H4>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>length</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method computes the length of a list.<A id=i1353349876-2></A><A id=i-1852559773-2></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>).length
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
</PRE>On lists, unlike arrays,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>length</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a relatively expensive operation. It needs to traverse the whole list to find its end and therefore takes time proportional to the number of elements in the list. That's why it's not a good idea to replace a test such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs.isEmpty</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs.length</SPAN>&nbsp;<SPAN class=code>==</SPAN>&nbsp;<SPAN class=code>0</SPAN>. The result of the two tests are equivalent, but the second one is slower, in particular if the list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is long. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Accessing the end of a list:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>init</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>last</SPAN></H4>
<P>You know already the basic operations<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN>, which respectively take the first element of a list, and the rest of the list except the first element. They each have a dual operation:<A id=i-1293540834-2></A><A id=i1464438076-2></A><A id=i1113811620-2></A><A id=i1464515266-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>last</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns the last element of a (non-empty) list, whereas<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>init</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns a list consisting of all elements except the last one:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;abcde&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'a'</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'b'</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'c'</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'d'</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'e'</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">abcde:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</SPAN>
  <BR>  scala&gt;&nbsp;abcde.last
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;Char&nbsp;=&nbsp;e</SPAN>
  <BR>  scala&gt;&nbsp;abcde.init
  <SPAN class=output style="COLOR: rgb(90,0,0)">res5:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d)</SPAN>
</PRE>Like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN>, these methods throw an exception when applied to an empty list:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>().init
  <SPAN class=output style="COLOR: rgb(90,0,0)">java.lang.UnsupportedOperationException:&nbsp;Nil.init</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;scala.List.init(List.scala:544)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;...</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>().last
  <SPAN class=output style="COLOR: rgb(90,0,0)">java.util.NoSuchElementException:&nbsp;Nil.last</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;scala.List.last(List.scala:563)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;...</SPAN>
</PRE>Unlike<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN>, which both run in constant time,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>init</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>last</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>need to traverse the whole list to compute their result. They therefore take time proportional to the length of the list. 
<P></P>
<DIV class=callout style="BORDER-RIGHT: rgb(153,153,153) groove; PADDING-RIGHT: 49px; BORDER-TOP: rgb(153,153,153) groove; PADDING-LEFT: 49px; PADDING-BOTTOM: 0.5em; MARGIN-LEFT: 49px; BORDER-LEFT: rgb(153,153,153) groove; MARGIN-RIGHT: 49px; PADDING-TOP: 0.5em; BORDER-BOTTOM: rgb(153,153,153) groove; BACKGROUND-COLOR: rgb(248,248,248)">
<P><BR>It's a good idea to organize your data so that most accesses are at the head of a list, rather than the last element.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DIV>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Reversing lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverse</SPAN></H4>
<P>If at some point in the computation an algorithm demands frequent accesses to the end of a list, it's sometimes better to reverse the list first and work with the result instead. Here's how to do the reversal:<A id=i1817641200-2></A><A id=i-2051462346-2></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;abcde.reverse&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">res6:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</SPAN>
</PRE>Note that, like all other list operations,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverse</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>creates a new list rather than changing the one it operates on. Since lists are immutable, such a change would not be possible, anyway. To verify this, check that the original value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>abcde</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is unchanged after the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverse</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;abcde
  <SPAN class=output style="COLOR: rgb(90,0,0)">res7:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverse</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>init</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>last</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operations satisfy some laws which can be used for reasoning about computations and for simplifying programs. 
<P></P>
<OL>
<LI><SPAN class=code>reverse</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is its own inverse:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  xs.reverse.reverse&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;xs
</PRE>
<LI><SPAN class=code>reverse</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>turns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>init</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>last</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN>, except that the elements are reversed:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  xs.reverse.init&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;xs.tail.reverse
  xs.reverse.tail&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;xs.init.reverse
  xs.reverse.head&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;xs.last
  xs.reverse.last&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;xs.head
</PRE></LI></OL>Reverse could be implemented using concatenation (<SPAN class=code>:::</SPAN>), like in the following method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rev</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;rev[T](xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;=&nbsp;xs&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;=&gt;&nbsp;xs
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;rev(xs1)&nbsp;:::&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x)
  }
</PRE>However, this method is less efficient than one would hope for. To study the complexity of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rev</SPAN>, assume that the list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has length<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>n</SPAN>. Notice that there are<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>n</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>recursive calls to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rev</SPAN>. Each call except the last involves a list concatenation. List concatenation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>:::</SPAN>&nbsp;<SPAN class=code>ys</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes time proportional to the length of its first argument<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>. Hence, the total complexity of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rev</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is: 
<DIV align=center><I>n</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>+ (<I>n</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>- 1) + ... + 1 = (1 +<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I>) *<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>/ 2</DIV>
<P>In other words,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rev</SPAN>'s complexity is quadratic in the length of its input argument. This is disappointing when compared to the standard reversal of a mutable, linked list, which has linear complexity. However, the current implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rev</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not the best implementation possible. You will see in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#sec:fastrev">Section 16.7</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>how to speed it up.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Prefixes and suffixes:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drop</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>take</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>splitAt</SPAN></H4>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drop</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>take</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operations<A id=i-1134266499-1></A><A id=i1464293147-2></A><A id=i425822536-1></A><A id=i-1852559773-3></A><A id=i1464753331-1></A><A id=i-567585630-1></A><A id=i-858153663-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>generalize<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>init</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in that they return arbitrary prefixes or suffixes of a list. The expression "<SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>take</SPAN>&nbsp;<SPAN class=code>n</SPAN>" returns the first<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>n</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>elements of the list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>n</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is greater than<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs.length</SPAN>, the whole list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is returned. The operation "<SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>drop</SPAN>&nbsp;<SPAN class=code>n</SPAN>" returns all elements of the list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>except the first<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>n</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>ones. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>n</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is greater than<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs.length</SPAN>, the empty list is returned.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>splitAt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation splits the list at a given index, returning a pair of two lists.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#footnote16-4">[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It is defined by the equality:</P>
<DIV align=center><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>splitAt</SPAN>&nbsp;<SPAN class=code>n</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=code>(xs</SPAN>&nbsp;<SPAN class=code>take</SPAN>&nbsp;<SPAN class=code>n,</SPAN>&nbsp;<SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>drop</SPAN>&nbsp;<SPAN class=code>n)</SPAN></DIV>
<P>However,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>splitAt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>avoids traversing the list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>twice. Here are some examples of these three methods:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;abcde&nbsp;take&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res8:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b)</SPAN>
  <BR>  scala&gt;&nbsp;abcde&nbsp;drop&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res9:&nbsp;List[Char]&nbsp;=&nbsp;List(c,&nbsp;d,&nbsp;e)</SPAN>
  <BR>  scala&gt;&nbsp;abcde&nbsp;splitAt&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res10:&nbsp;(List[Char],&nbsp;List[Char])&nbsp;=&nbsp;(List(a,&nbsp;b),List(c,&nbsp;d,&nbsp;e))</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Element selection:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>indices</SPAN></H4>
<P>Random element selection is supported through the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method;<A id=i-1534184650-1></A><A id=i-1854381886-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>however it is a less common operation for lists than it is for arrays.</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;abcde&nbsp;apply&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;rare&nbsp;in&nbsp;Scala</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res11:&nbsp;Char&nbsp;=&nbsp;c</SPAN>
</PRE>As for all other types,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is implicitly inserted when an object appears in the function position in a method call, so the line above can be shortened to:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;abcde(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;rare&nbsp;in&nbsp;Scala</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res12:&nbsp;Char&nbsp;=&nbsp;c</SPAN>
</PRE>One reason why random element selection is less popular for lists than for arrays is that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs(n)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes time proportional to the index<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>n</SPAN>. In fact,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is simply defined by a combination of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drop</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN>: 
<P></P>
<DIV align=center><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>apply</SPAN>&nbsp;<SPAN class=code>n</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=code>(xs</SPAN>&nbsp;<SPAN class=code>drop</SPAN>&nbsp;<SPAN class=code>n).head</SPAN></DIV>
<P>This definition also makes clear that list indices range from 0 up to the length of the list minus one, the same as for arrays. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>indices</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method<A id=i552445480-1></A><A id=i-1207917573-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns a list consisting of all valid indices of a given list:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;abcde.indices
  <SPAN class=output style="COLOR: rgb(90,0,0)">res13:&nbsp;List[Int]&nbsp;=&nbsp;List(0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4)</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Zipping lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>zip</SPAN></H4>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>zip</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation takes two lists and forms a list of pairs:<A id=i50424558-1></A><A id=i1986918773-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;abcde.indices&nbsp;zip&nbsp;abcde
  <SPAN class=output style="COLOR: rgb(90,0,0)">res14:&nbsp;List[(Int,&nbsp;Char)]&nbsp;=&nbsp;List((0,a),&nbsp;(1,b),&nbsp;(2,c),&nbsp;(3,d),&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">(4,e))</SPAN>
</PRE>If the two lists are of different length, any unmatched elements are dropped:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;zipped&nbsp;=&nbsp;abcde&nbsp;zip&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">zipped:&nbsp;List[(Char,&nbsp;Int)]&nbsp;=&nbsp;List((a,1),&nbsp;(b,2),&nbsp;(c,3))</SPAN>
</PRE>A useful special case is to zip a list with its index. This is done most efficiently with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>zipWithIndex</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which pairs every element of a list with the position where it appears in the list<A id=i1217066692-1></A>.<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;abcde.zipWithIndex
  <SPAN class=output style="COLOR: rgb(90,0,0)">res15:&nbsp;List[(Char,&nbsp;Int)]&nbsp;=&nbsp;List((a,0),&nbsp;(b,1),&nbsp;(c,2),&nbsp;(d,3),&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;(e,4))</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Displaying lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mkString</SPAN></H4>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation returns the canonical string representation of a list:<A id=i-683244392-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;abcde.toString
  <SPAN class=output style="COLOR: rgb(90,0,0)">res16:&nbsp;String&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</SPAN>
</PRE>If you want a different representation you can use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mkString</SPAN><A id=i1357784029-2></A><A id=i746937723-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. The operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>mkString</SPAN>&nbsp;<SPAN class=code>(pre,</SPAN>&nbsp;<SPAN class=code>sep,</SPAN>&nbsp;<SPAN class=code>post)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>involves four<A id=i-205371607-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>operands:<SPAN class=Apple-converted-space>&nbsp;</SPAN>the list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be displayed, a prefix string<SPAN class=code>pre</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be displayed in front of all elements, a separator string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sep</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be displayed between successive elements, and a postfix string<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>post</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be displayed at the end. The result of the operation is the string: 
<P></P>
<DIV align=center><SPAN class=code>pre</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>xs(0)</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>sep</SPAN>&nbsp;<SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>...<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>sep</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>xs(xs.length</SPAN>&nbsp;<SPAN class=code>-</SPAN>&nbsp;<SPAN class=code>1)</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>post</SPAN></DIV>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mkString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method has two overloaded variants that let you drop some or all of its arguments. The first variant only takes a separator string:</P>
<DIV align=center><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>mkString</SPAN>&nbsp;<SPAN class=code>sep</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>mkString</SPAN>&nbsp;<SPAN class=code>("",</SPAN>&nbsp;<SPAN class=code>sep,</SPAN>&nbsp;<SPAN class=code>"")</SPAN></DIV>
<P>The second variant lets you omit all arguments:</P>
<DIV align=center><SPAN class=code>xs.mkString</SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>mkString</SPAN>&nbsp;<SPAN class=code>""</SPAN></DIV>
<P>Here are some examples:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;abcde&nbsp;mkString&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"["</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">","</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"]"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res17:&nbsp;String&nbsp;=&nbsp;[a,b,c,d,e]</SPAN>
  <BR>  scala&gt;&nbsp;abcde&nbsp;mkString&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">""</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res18:&nbsp;String&nbsp;=&nbsp;abcde</SPAN>
  <BR>  scala&gt;&nbsp;abcde.mkString
  <SPAN class=output style="COLOR: rgb(90,0,0)">res19:&nbsp;String&nbsp;=&nbsp;abcde</SPAN>
  <BR>  scala&gt;&nbsp;abcde&nbsp;mkString&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"List("</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">",&nbsp;"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">")"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res20:&nbsp;String&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</SPAN>
</PRE>There are also variants of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mkString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>addString</SPAN><A id=i-1095177571-1></A><A id=i-454878362-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which append the constructed string to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>StringBuilder</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object,<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#footnote16-5">[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>rather than returning them as a result:<A id=i-2123413502-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;buf&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">StringBuilder</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">buf:&nbsp;StringBuilder&nbsp;=&nbsp;</SPAN>
  <BR>  scala&gt;&nbsp;abcde&nbsp;addString&nbsp;(buf,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"("</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">";"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">")"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res21:&nbsp;StringBuilder&nbsp;=&nbsp;(a;b;c;d;e)</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>mkString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>addString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods are inherited from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>'s super trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable</SPAN>, so they are applicable to all sorts of iterable collections. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Converting lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elements</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toArray</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>copyToArray</SPAN></H4>
<P>To convert data between the flat world of arrays and the recursive world of lists, you can use method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toArray</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toList</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN>:<A id=i-1473690452-1></A><A id=i-1723195748-1></A><A id=i-38723342-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;arr&nbsp;=&nbsp;abcde.toArray
  <SPAN class=output style="COLOR: rgb(90,0,0)">arr:&nbsp;Array[Char]&nbsp;=&nbsp;Array(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</SPAN>
  <BR>  scala&gt;&nbsp;arr.toString
  <SPAN class=output style="COLOR: rgb(90,0,0)">res22:&nbsp;String&nbsp;=&nbsp;Array(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</SPAN>
  <BR>  scala&gt;&nbsp;arr.toList
  <SPAN class=output style="COLOR: rgb(90,0,0)">res23:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</SPAN>
</PRE>There's also a method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>copyToArray</SPAN>,<A id=i1315859366-1></A><A id=i-1677368899-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which copies list elements to successive array positions within some destination array. The operation:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  xs&nbsp;copyToArray&nbsp;(arr,&nbsp;start)
</PRE>copies all elements of the list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the array<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arr</SPAN>, beginning with position<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>start</SPAN>. You must ensure that the destination array<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is large enough to hold the list in full. Here's an example:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;arr2&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[Int]</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">arr2:&nbsp;Array[Int]&nbsp;=&nbsp;Array(0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)&nbsp;copyToArray&nbsp;(arr2,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <BR>  scala&gt;&nbsp;arr2.toString
  <SPAN class=output style="COLOR: rgb(90,0,0)">res25:&nbsp;String&nbsp;=&nbsp;Array(0,&nbsp;0,&nbsp;0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0)</SPAN>
</PRE>Finally, if you need to access list elements via an iterator, you can use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>elements</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method:<A id=i1760043736-1></A><A id=i1085338403-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;it&nbsp;=&nbsp;abcde.elements
  <SPAN class=output style="COLOR: rgb(90,0,0)">it:&nbsp;Iterator[Char]&nbsp;=&nbsp;non-empty&nbsp;iterator</SPAN>
  <BR>  scala&gt;&nbsp;it.next
  <SPAN class=output style="COLOR: rgb(90,0,0)">res26:&nbsp;Char&nbsp;=&nbsp;a</SPAN>
  <BR>  scala&gt;&nbsp;it.next
  <SPAN class=output style="COLOR: rgb(90,0,0)">res27:&nbsp;Char&nbsp;=&nbsp;b</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Example: Merge sort</H4>
<P>The insertion sort presented earlier is concise to write, but it is not very efficient. Its average complexity is proportional to the<A id=i-2095646335-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>square of the length of the input list. A more efficient algorithm is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">merge sort</SPAN>.<A id=i-1435795620-1></A><A id=i-1149295482-1></A></P>
<DIV class=pointofinterest>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">The fast track</H3>
<P>This example provides another illustration of the divide and conquer principle and currying, as well as a useful discussion of algorithmic complexity. If you prefer to move a bit faster on your first pass through this book, however, you can safely skip to<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#sec:higher-order-methods">Section 16.7</A>.</P></DIV>
<P>Merge sort works as follows: First, if the list has zero or one elements, it is already sorted, so the list can be returned unchanged. Longer lists are split into two sub-lists, each containing about half the elements of the original list. Each sub-list is sorted by a recursive call to the sort function, and the resulting two sorted lists are then combined in a merge operation.</P>
<P>For a general implementation of merge sort, you want to leave open the type of list elements to be sorted, and also want to leave open the function to be used for the comparison of elements. You obtain a function of maximal generality by passing these two items as parameters. This leads to the implementation shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#lst:merge-sort-function">Listing 16.1</A>.</P>
<P><A name=lst:merge-sort-function></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;msort[T](less:&nbsp;(T,&nbsp;T)&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;=&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;merge(xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>,&nbsp;ys:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xs,&nbsp;ys)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">match</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>,&nbsp;_)&nbsp;=&gt;&nbsp;ys
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;(_,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nil</SPAN>)&nbsp;=&gt;&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">case</SPAN>&nbsp;(x&nbsp;::&nbsp;xs1,&nbsp;y&nbsp;::&nbsp;ys1)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(less(x,&nbsp;y))&nbsp;x&nbsp;::&nbsp;merge(xs1,&nbsp;ys)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;y&nbsp;::&nbsp;merge(xs,&nbsp;ys1)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;n&nbsp;=&nbsp;xs.length&nbsp;/&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(n&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;(ys,&nbsp;zs)&nbsp;=&nbsp;xs&nbsp;splitAt&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;merge(msort(less)(ys),&nbsp;msort(less)(zs))
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 16.1 - A merge sort function for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>s.</H5>
<P>The complexity of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is order (<I>n</I>\;<I>log</I>(<I>n</I>)), where<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the length of the input list. To see why, note that splitting a list in two and merging two sorted lists each take time proportional to the length of the argument list(s). Each recursive call of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>halves the number of elements in its input, so there are about<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>log</I>(<I>n</I>) consecutive recursive calls until the base case of lists of length 1 is reached. However, for longer lists each call spawns off two further calls. Adding everything up we obtain that at each of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>log</I>(<I>n</I>) call levels, every element of the original lists takes part in one split operation and in one merge operation. Hence, every call level has a total cost proportional to<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I>. Since there are<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>log</I>(<I>n</I>) call levels, we obtain an overall cost proportional to<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I>\;<I>log</I>(<I>n</I>). That cost does not depend on the initial distribution of elements in the list, so the worst case cost is the same as the average case cost. This property makes merge sort an attractive algorithm for sorting lists.</P>
<P>Here is an example of how<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;msort((x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;x&nbsp;&lt;&nbsp;y)(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">7</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res28:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;3,&nbsp;5,&nbsp;7)</SPAN>
</PRE>
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function is a classical example of the currying concept discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#sec:currying">Section 9.3</A>. Currying<A id=i575993339-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>makes it easy to specialize the function for particular comparison functions. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;intSort&nbsp;=&nbsp;msort((x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;x&nbsp;&lt;&nbsp;y)&nbsp;_
  <SPAN class=output style="COLOR: rgb(90,0,0)">intSort:&nbsp;(List[Int])&nbsp;=&gt;&nbsp;List[Int]&nbsp;=&nbsp;&lt;function&gt;</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>intSort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable refers to a function that takes a list of integers and sorts them in numerical order.<A id=i1128745740-2></A><A id=i1834060518-2></A><A id=i1842232449-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>As described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#sec:partially-applied-functions">Section 8.6</A>, an underscore stands for a missing argument list. In this case, the missing argument is the list that should be sorted. As another example, here's how you could define a function that sorts a list of integers in reverse numerical order:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;reverseIntSort&nbsp;=&nbsp;msort((x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;y)&nbsp;_
  <SPAN class=output style="COLOR: rgb(90,0,0)">reverseIntSort:&nbsp;(List[Int])&nbsp;=&gt;&nbsp;List[Int]&nbsp;=&nbsp;&lt;function&gt;</SPAN>
</PRE>
<P>Because you provided the comparison function already via currying, you now need only provide the list to sort when you invoke the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>intSort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverseIntSort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>functions. Here are some examples:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;mixedInts&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">9</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">8</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">6</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">7</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">mixedInts:&nbsp;List[Int]&nbsp;=&nbsp;List(4,&nbsp;1,&nbsp;9,&nbsp;0,&nbsp;5,&nbsp;8,&nbsp;3,&nbsp;6,&nbsp;2,&nbsp;7)</SPAN>
  <BR>  scala&gt;&nbsp;intSort(mixedInts)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;List[Int]&nbsp;=&nbsp;List(0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9)</SPAN>
  <BR>  scala&gt;&nbsp;reverseIntSort(mixedInts)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;List[Int]&nbsp;=&nbsp;List(9,&nbsp;8,&nbsp;7,&nbsp;6,&nbsp;5,&nbsp;4,&nbsp;3,&nbsp;2,&nbsp;1,&nbsp;0)</SPAN>
</PRE>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=16.7></A>16.7 Higher-order methods on class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#16.7">link</A>]</SPAN></H3>
<P><A name=sec:higher-order-methods></A></P>
<P>Many operations over lists have a similar structure. Several patterns appear time and time again.<A id=i-1450817245-1></A><A id=i1952802169-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Some examples are: transforming every element of a list in some way, verifying whether a property holds for all elements of a list, extracting from a list elements satisfying a certain criterion, or combining the elements of a list using some operator. In Java, such patterns would usually be expressed by idiomatic combinations of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops. In Scala, they can be expressed more concisely and directly using higher-order operators,<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#footnote16-6">[6]</A>which are implemented as methods in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. These higher-order operators are discussed in this section.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Mapping over lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN></H4>
<P>The operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>map</SPAN>&nbsp;<SPAN class=code>f</SPAN><A id=i395196522-2></A><A id=i1986906032-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes as operands a list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and a function<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>U</SPAN>. It returns the list resulting from applying the function<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to each list element in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>. For instance:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)&nbsp;map&nbsp;(_&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res29:&nbsp;List[Int]&nbsp;=&nbsp;List(2,&nbsp;3,&nbsp;4)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;words&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"the"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"quick"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"brown"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"fox"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">words:&nbsp;List[java.lang.String]&nbsp;=&nbsp;List(the,&nbsp;quick,&nbsp;brown,&nbsp;fox)</SPAN>
  <BR>  scala&gt;&nbsp;words&nbsp;map&nbsp;(_.length)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res30:&nbsp;List[Int]&nbsp;=&nbsp;List(3,&nbsp;5,&nbsp;5,&nbsp;3)</SPAN>
  <BR>  scala&gt;&nbsp;words&nbsp;map&nbsp;(_.toList.reverse.mkString)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res31:&nbsp;List[String]&nbsp;=&nbsp;List(eht,&nbsp;kciuq,&nbsp;nworb,&nbsp;xof)</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><A id=i535160876-1></A><A id=i364816247-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator is similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>, but it takes a function returning a list of elements as its right operand. It applies the function to each list element and returns the concatenation of all function results. The difference between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is illustrated in the following example:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;words&nbsp;map&nbsp;(_.toList)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res32:&nbsp;List[List[Char]]&nbsp;=&nbsp;List(List(t,&nbsp;h,&nbsp;e),&nbsp;List(q,&nbsp;u,&nbsp;i,&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;c,&nbsp;k),&nbsp;List(b,&nbsp;r,&nbsp;o,&nbsp;w,&nbsp;n),&nbsp;List(f,&nbsp;o,&nbsp;x))</SPAN>
  <BR>  scala&gt;&nbsp;words&nbsp;flatMap&nbsp;(_.toList)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res33:&nbsp;List[Char]&nbsp;=&nbsp;List(t,&nbsp;h,&nbsp;e,&nbsp;q,&nbsp;u,&nbsp;i,&nbsp;c,&nbsp;k,&nbsp;b,&nbsp;r,&nbsp;o,&nbsp;w,&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;n,&nbsp;f,&nbsp;o,&nbsp;x)</SPAN>
</PRE>You see that where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns a list of lists,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns a single list in which all element lists are concatenated. 
<P>The differences and interplay between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are also demonstrated by the following expression, which constructs a list of all pairs (<I>i</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>j</I>) such that 1 &#8804;<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>j</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>&lt;<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>&lt; 5:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;List.range(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)&nbsp;flatMap&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&gt;&nbsp;List.range(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;i)&nbsp;map&nbsp;(j&nbsp;=&gt;&nbsp;(i,&nbsp;j))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res34:&nbsp;List[(Int,&nbsp;Int)]&nbsp;=&nbsp;List((2,1),&nbsp;(3,1),&nbsp;(3,2),&nbsp;(4,1),&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;(4,2),&nbsp;(4,3))</SPAN>
</PRE><SPAN class=code>List.range</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a utility method that creates a list of all integers in some range.<A id=i2103556958-1></A><A id=i1320308892-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It is used twice in this example: once to generate a list of integers from 1 (including) until 5 (excluding), and in a second time to generate a list of integers from 1 until<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i</I>, for each value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>taken from the first list. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in this expression generates a list of tuples (<I>i</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>j</I>) where<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>j</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>&lt;<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i</I>. The outer<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in this example generates this list for each<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>i</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>between 1 and 5, and then concatenates all the results. 
<P></P>
<P>Note that the same list can alternatively be constructed with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(i&nbsp;&lt;-&nbsp;List.range(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>);&nbsp;j&nbsp;&lt;-&nbsp;List.range(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;i))&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">yield</SPAN>&nbsp;(i,&nbsp;j)
</PRE>You'll learn more about the interplay of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions and list operations in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/for-expressions-revisited.html">Chapter 23</A>. 
<P></P>
<P>The third map-like operation is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN>.<A id=i331113560-2></A><A id=i465975966-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Unlike<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatMap</SPAN>, however,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes a procedure (a function with result type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN>) as right operand. It simply applies the procedure to each list element. The result of the operation itself is again<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN>; no list of results is assembled. As an example, here is a concise way of summing up all numbers in a list:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;sum&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">sum:&nbsp;Int&nbsp;=&nbsp;0</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)&nbsp;foreach&nbsp;(sum&nbsp;+=&nbsp;_)
  <BR>  scala&gt;&nbsp;sum
  <SPAN class=output style="COLOR: rgb(90,0,0)">res36:&nbsp;Int&nbsp;=&nbsp;15</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Filtering lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>partition</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>find</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>takeWhile</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>dropWhile</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>span</SPAN></H4>
<P>The operation "<SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>filter</SPAN>&nbsp;<SPAN class=code>p</SPAN>" takes as operands a list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]</SPAN><A id=i1807572102-2></A><A id=i-1514694492-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and a predicate function<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Boolean</SPAN>. It yields the list of all elements<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p(x)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>. For instance:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)&nbsp;filter&nbsp;(_&nbsp;%&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res37:&nbsp;List[Int]&nbsp;=&nbsp;List(2,&nbsp;4)</SPAN>
  <BR>  scala&gt;&nbsp;words&nbsp;filter&nbsp;(_.length&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res38:&nbsp;List[java.lang.String]&nbsp;=&nbsp;List(the,&nbsp;fox)</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>partition</SPAN><A id=i-944990523-1></A><A id=i2039424574-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is like filter, but it returns a pair of lists. One list contains all elements for which the predicate is true, while the other list contains all elements for which the predicate is false. It is defined by the equality: 
<P></P>
<DIV align=center><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>partition</SPAN>&nbsp;<SPAN class=code>p</SPAN>&nbsp;<SPAN class=code></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=code>(xs</SPAN>&nbsp;<SPAN class=code>filter</SPAN>&nbsp;<SPAN class=code>p,</SPAN>&nbsp;<SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>filter</SPAN>&nbsp;<SPAN class=code>(!p(_)))</SPAN></DIV>
<P>Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)&nbsp;partition&nbsp;(_&nbsp;%&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res39:&nbsp;(List[Int],&nbsp;List[Int])&nbsp;=&nbsp;(List(2,&nbsp;4),List(1,&nbsp;3,&nbsp;5))</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>find</SPAN><A id=i383310678-1></A><A id=i1464344037-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is also similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>but it returns the first element satisfying a given predicate, rather than all such elements. The operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>find</SPAN>&nbsp;<SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes a list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and a predicate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as operands. It returns an optional value. If there is an element<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p(x)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is true,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Some(x)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is returned. Otherwise,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is false for all elements, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>None</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is returned. Here are some examples:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)&nbsp;find&nbsp;(_&nbsp;%&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res40:&nbsp;Option[Int]&nbsp;=&nbsp;Some(2)</SPAN>
  <BR>  scala&gt;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)&nbsp;find&nbsp;(_&nbsp;&lt;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res41:&nbsp;Option[Int]&nbsp;=&nbsp;None</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>takeWhile</SPAN><A id=i-334215483-1></A><A id=i1035564606-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>dropWhile</SPAN><A id=i-648573139-1></A><A id=i-976962346-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>operators also take a predicate as their right operand. The operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>takeWhile</SPAN>&nbsp;<SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes the longest prefix of list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>such that every element in the prefix satisfies<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>. Analogously, the operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>dropWhile</SPAN>&nbsp;<SPAN class=code>p</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>removes the longest prefix from list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>such that every element in the prefix satisfies<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>. Here are some examples:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)&nbsp;takeWhile&nbsp;(_&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res42:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</SPAN>
  <BR>  scala&gt;&nbsp;words&nbsp;dropWhile&nbsp;(_&nbsp;startsWith&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"t"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res43:&nbsp;List[java.lang.String]&nbsp;=&nbsp;List(quick,&nbsp;brown,&nbsp;fox)</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>span</SPAN><A id=i772550245-1></A><A id=i1464737654-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>method combines<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>takeWhile</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>dropWhile</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in one operation, just like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>splitAt</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>combines<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>take</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drop</SPAN>. It returns a pair of two lists, defined by the equality: 
<P></P>
<DIV align=center><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>span</SPAN>&nbsp;<SPAN class=code>p</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=code>(xs</SPAN>&nbsp;<SPAN class=code>takeWhile</SPAN>&nbsp;<SPAN class=code>p,</SPAN>&nbsp;<SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>dropWhile</SPAN>&nbsp;<SPAN class=code>p)</SPAN></DIV>
<P>Like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>splitAt</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>span</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>avoids traversing the list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>twice:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)&nbsp;span&nbsp;(_&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res44:&nbsp;(List[Int],&nbsp;List[Int])&nbsp;=&nbsp;(List(1,&nbsp;2,&nbsp;3),List(-4,&nbsp;5))</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Predicates over lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>forall</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN></H4>
<P>The operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>forall</SPAN>&nbsp;<SPAN class=code>p</SPAN><A id=i260029766-2></A><A id=i-1508992668-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes as arguments a list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and a predicate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>. Its result is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if all elements in the list satisfy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>. Conversely, the operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>exists</SPAN>&nbsp;<SPAN class=code>p</SPAN><A id=i339085162-2></A><A id=i-1529560696-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if there is an element in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that satisfies the predicate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>p</SPAN>. For instance, to find out whether a matrix represented as a list of lists has a row with only zeroes as elements:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hasZeroRow(m:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[List[Int]]</SPAN>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;exists&nbsp;(row&nbsp;=&gt;&nbsp;row&nbsp;forall&nbsp;(_&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">hasZeroRow:&nbsp;(List[List[Int]])Boolean</SPAN>
  <BR>  scala&gt;&nbsp;hasZeroRow(diag3)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res45:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Folding lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>/:</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:\</SPAN></H4>
<P>Another common kind of operation combines the elements of a list with some operator. For instance:</P>
<DIV align=center><SPAN class=code>sum(List(a,</SPAN>&nbsp;<SPAN class=code>b,</SPAN>&nbsp;<SPAN class=code>c))</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=code>0</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>b</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>c</SPAN></DIV>
<P>This is a special instance of a fold operation:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;sum(xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>&nbsp;/:&nbsp;xs)&nbsp;(_&nbsp;+&nbsp;_)&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">sum:&nbsp;(List[Int])Int</SPAN>
</PRE>Similarly: 
<P></P>
<DIV align=center><SPAN class=code>product(List(a,</SPAN>&nbsp;<SPAN class=code>b,</SPAN>&nbsp;<SPAN class=code>c))</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=code>1</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>a</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>b</SPAN>&nbsp;<SPAN class=code>*</SPAN>&nbsp;<SPAN class=code>c</SPAN></DIV>
<P>is a special instance of this fold operation:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;product(xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Int]</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;/:&nbsp;xs)&nbsp;(_&nbsp;*&nbsp;_)&nbsp;
  <SPAN class=output style="COLOR: rgb(90,0,0)">product:&nbsp;(List[Int])Int</SPAN>
</PRE>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">fold left</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation "<SPAN class=code>(z</SPAN>&nbsp;<SPAN class=code>/:</SPAN>&nbsp;<SPAN class=code>xs)</SPAN>&nbsp;<SPAN class=code>(op)</SPAN>" involves<A id=i-1160692124-1></A><A id=i-1069108030-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>three objects: a start value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>z</SPAN>, a list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>, and a binary operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN>. The result of the fold<A id=i487604192-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>applied between successive elements of the list prefixed by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>z</SPAN>. For instance: 
<P></P>
<DIV align=center><SPAN class=code>(z</SPAN>&nbsp;<SPAN class=code>/:</SPAN>&nbsp;<SPAN class=code>List(a,</SPAN>&nbsp;<SPAN class=code>b,</SPAN>&nbsp;<SPAN class=code>c))</SPAN>&nbsp;<SPAN class=code>(op)</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=code>op(op(op(z,</SPAN>&nbsp;<SPAN class=code>a),</SPAN>&nbsp;<SPAN class=code>b),</SPAN>&nbsp;<SPAN class=code>c)</SPAN></DIV>
<P>Or, graphically:</P>
<DIV align=center><IMG alt="image images/optree1.jpg" src="http://www.artima.com/pins1ed/images/optree1.jpg"></DIV>
<P>Here's another example that illustrates how<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>/:</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used. To concatenate all words in a list of strings with spaces between them and in front, you can write this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;&nbsp;(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">""</SPAN>&nbsp;/:&nbsp;words)&nbsp;(_&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>+&nbsp;_)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res46:&nbsp;java.lang.String&nbsp;=&nbsp;&nbsp;the&nbsp;quick&nbsp;brown&nbsp;fox</SPAN>
</PRE>This gives an extra space at the beginning. To remove the space, you can use this slight variation:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;(words.head&nbsp;/:&nbsp;words.tail)&nbsp;&nbsp;(_&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"&nbsp;"</SPAN>+&nbsp;_)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res47:&nbsp;java.lang.String&nbsp;=&nbsp;the&nbsp;quick&nbsp;brown&nbsp;fox</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>/:</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator produces left-leaning operation trees (its syntax with the slash rising forward is intended to be a reflection of that). The operator has<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:\</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an analog that produces right-leaning trees. For instance: 
<P></P>
<DIV align=center><SPAN class=code>(List(a,</SPAN>&nbsp;<SPAN class=code>b,</SPAN>&nbsp;<SPAN class=code>c)</SPAN>&nbsp;<SPAN class=code>:\</SPAN>&nbsp;<SPAN class=code>z)</SPAN>&nbsp;<SPAN class=code>(op)</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=code>op(a,</SPAN>&nbsp;<SPAN class=code>op(b,</SPAN>&nbsp;<SPAN class=code>op(c,</SPAN>&nbsp;<SPAN class=code>z)))</SPAN></DIV>
<P>Or, graphically:</P>
<DIV align=center><IMG alt="image images/optree2.jpg" src="http://www.artima.com/pins1ed/images/optree2.jpg"></DIV>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:\</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator is pronounced<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">fold right</SPAN>.<A id=i-1517880440-1></A><A id=i-2058478237-1></A><A id=i1039328969-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It involves the same three operands as fold left, but the first two appear in reversed order: The first operand is the list to fold, the second is the start value.</P>
<P>For associative operations, fold left and fold right are equivalent, but there might be a difference in efficiency.<A id=i-1099454431-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Consider for instance an operation corresponding to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List.flatten</SPAN>method, which concatenates all elements in a list of lists.<A id=i434218046-1></A><A id=i44703139-1></A><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#footnote16-7">[7]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This could be implemented with either fold left or fold right:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;flattenLeft[T](xss:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[List[T]]</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>()&nbsp;/:&nbsp;xss)&nbsp;(_&nbsp;:::&nbsp;_)
  <BR>  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;flattenRight[T](xss:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[List[T]]</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(xss&nbsp;:~<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>())&nbsp;(_&nbsp;:::&nbsp;_)
</PRE>Because list concatenation,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>:::</SPAN>&nbsp;<SPAN class=code>ys</SPAN>, takes time proportional to its first argument<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>, the implementation in terms of fold right in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flattenRight</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is more efficient than the fold left implementation in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flattenLeft</SPAN>. The problem is that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flattenLeft(xss)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>copies the first element list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xss.head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I>-1 times, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the length of the list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xss</SPAN>. 
<P></P>
<P>Note that both versions of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatten</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>require a type annotation on the empty list that is the start value of the fold. This is due to a limitation in Scala's type inferencer, which fails to infer the correct type of the list automatically. If you try to leave out the annotation, you get the following:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;flattenRight[T](xss:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[List[T]]</SPAN>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xss&nbsp;:~<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>())&nbsp;(_&nbsp;:::&nbsp;_)
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:15:&nbsp;error:&nbsp;type&nbsp;mismatch;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;List[T]</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;required:&nbsp;List[Nothing]</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xss&nbsp;:~List())&nbsp;(_&nbsp;:::&nbsp;_)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>To find out why the type inferencer goes wrong, you'll need to know about the types of the fold methods and how they are implemented. More on this in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html">Chapter 22</A>. Lastly, although the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>/:</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>:\</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operators have the advantage that the direction of the slash resembles the graphical depiction of their respective left or right-leaning trees, and the associativity of the colon character places the start value in the same position in the expression as it is in the tree, some may find the resulting code less than intuitive. If you prefer, you can alternatively use the methods named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foldLeft</SPAN><A id=i-1740081977-1></A><A id=i1387030996-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foldRight</SPAN><A id=i411005876-1></A>, which are also defined on class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>.<A id=i53948911-1></A></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Example: List reversal using fold</H4>
<P><A name=sec:fastrev></A></P>
<P>Earlier in the chapter you saw an implementation of method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverse</SPAN>, named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>rev</SPAN>, whose running time was quadratic in the length of the list to be reversed. Here is now a different implementation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverse</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that has linear cost. The idea is to use a fold left operation based on the following scheme:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;reverseLeft[T](xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>)&nbsp;=&nbsp;(<I>startvalue</I>&nbsp;/:&nbsp;xs)(<I>operation</I>)
</PRE>It only remains to fill in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>startvalue</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>operation</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>parts. In fact, you can try to deduce these parts from some simple examples. To deduce the correct value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>startvalue</I>, you can start with the smallest possible list,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List()</SPAN>, and calculate as follows:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;<SPAN class=rm style="FONT-FAMILY: serif">(by the properties of <SPAN class=code>reverseLeft</SPAN>)</SPAN>
  <BR>  reverseLeft(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;<SPAN class=rm style="FONT-FAMILY: serif">(by the template for <SPAN class=code>reverseLeft</SPAN>)</SPAN>
  <BR>  (<I>startvalue</I>&nbsp;/:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>())(<I>operation</I>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;<SPAN class=rm style="FONT-FAMILY: serif">(by the definition of <SPAN class=code>/:</SPAN>)</SPAN>
  <BR>  <I>startvalue</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</PRE>Hence,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>startvalue</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>must be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List()</SPAN>. To deduce the second operand, you can pick the next smallest list as an example case. You know already that<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>startvalue</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List()</SPAN>, so you can calculate as follows:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x)
  &nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;<SPAN class=rm style="FONT-FAMILY: serif">(by the properties of <SPAN class=code>reverseLeft</SPAN>)</SPAN>
  <BR>  reverseLeft(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x))
  &nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;<SPAN class=rm style="FONT-FAMILY: serif">(by the template for <SPAN class=code>reverseLeft</SPAN>, with</SPAN> <SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">startvalue</EM></SPAN> <SPAN class=rm style="FONT-FAMILY: serif"><SPAN class=code>= List()</SPAN>)</SPAN>
  <BR>  (<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>()&nbsp;/:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(x))&nbsp;(<I>operation</I>)&nbsp;
  &nbsp;&nbsp;<SPAN class=rm style="FONT-FAMILY: serif"><EM style="FONT-STYLE: italic">equals</EM></SPAN>&nbsp;<SPAN class=rm style="FONT-FAMILY: serif">(by the definition of <SPAN class=code>/:</SPAN>)</SPAN>
  <BR>  <I>operation</I>(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(),&nbsp;x)
</PRE>Hence,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>operation</I><SPAN class=code>(List(),</SPAN>&nbsp;<SPAN class=code>x)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>equals<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(x)</SPAN>, which can also be written as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>::</SPAN>&nbsp;<SPAN class=code>List()</SPAN>. This suggests taking as<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>operation</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator with its operands exchanged. (This operation is sometimes called "snoc," in reference<A id=i3535215-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>::</SPAN>, which is called cons.) We arrive then at the following implementation for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverseLeft</SPAN>:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;reverseLeft[T](xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>)&nbsp;=
  &nbsp;&nbsp;(<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>()&nbsp;/:&nbsp;xs)&nbsp;{(ys,&nbsp;y)&nbsp;=&gt;&nbsp;y&nbsp;::&nbsp;ys}
</PRE>(Again, the type annotation in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is necessary to make the type inferencer work.) If you analyze the complexity of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverseLeft</SPAN>, you'll find that it applies a constant-time operation ("snoc")<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>times, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>n</I><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the length of the argument list. Hence, the complexity of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverseLeft</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is linear, as hoped for. 
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Sorting lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sort</SPAN></H4>
<P>The operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>&nbsp;<SPAN class=code>sort</SPAN>&nbsp;<SPAN class=code>before</SPAN>, where "xs" is a list and "<SPAN class=code>before</SPAN>" is a function that can be used to compare two elements, sorts the elements of list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>.<A id=i1988049794-1></A><A id=i1464737226-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>before</SPAN>&nbsp;<SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should return<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should come before<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the intended ordering for the sort. For instance:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">6</SPAN>)&nbsp;sort&nbsp;(_&nbsp;&lt;&nbsp;_)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res48:&nbsp;List[Int]&nbsp;=&nbsp;List(-3,&nbsp;1,&nbsp;2,&nbsp;4,&nbsp;6)</SPAN>
  <BR>  scala&gt;&nbsp;words&nbsp;sort&nbsp;(_.length&nbsp;&gt;&nbsp;_.length)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res49:&nbsp;List[java.lang.String]&nbsp;=&nbsp;List(quick,&nbsp;brown,&nbsp;fox,&nbsp;the)</SPAN>
</PRE>Note that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>performs a merge sort similar to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>algorithm shown in the last section, but it is a method of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>whereas<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was defined outside lists. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=16.8></A>16.8 Methods of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#16.8">link</A>]</SPAN></H3>
<P>So far, all operations you have seen in this chapter are implemented as methods of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>, so you invoke them on individual list objects. There are also a number of methods in the globally accessible object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.List</SPAN>, which is the companion object of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. Some of these operations are factory methods that create lists. Others are operations that work on lists of some specific shape. Both kinds of methods will be presented in this section.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Creating lists from their elements:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List.apply</SPAN></H4>
<P>You've already seen on several occasions list literals such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3)</SPAN>. There's nothing special about their syntax. A literal like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3)</SPAN><A id=i19484993-2></A><A id=i1305057997-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is simply the application of the object<SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the elements<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>3</SPAN>. That is, it is equivalent to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List.apply(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3)</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;List.apply(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res50:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Creating a range of numbers:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List.range</SPAN></H4>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>range</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which you saw briefly earlier in the chapter in the discussion of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatmap</SPAN>, creates a list consisting of a range of numbers. Its simplest form is<SPAN class=code>List.range(from,</SPAN>&nbsp;<SPAN class=code>until)</SPAN>,<A id=i648409480-1></A><A id=i1320308892-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which creates a list of all numbers starting at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>from</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and going up to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>until</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>minus one. So the end value,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>until</SPAN>, does not form part of the range.</P>
<P>There's also a version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>range</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that takes a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>step</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>value as third parameter. This operation will yield list elements that are<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>step</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>values apart, starting at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>from</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>step</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be positive or negative:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;List.range(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res51:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4)</SPAN>
  <BR>  scala&gt;&nbsp;List.range(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">9</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res52:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;3,&nbsp;5,&nbsp;7)</SPAN>
  <BR>  scala&gt;&nbsp;List.range(<SPAN class=literal style="COLOR: rgb(205,123,0)">9</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res53:&nbsp;List[Int]&nbsp;=&nbsp;List(9,&nbsp;6,&nbsp;3)</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Creating uniform lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List.make</SPAN></H4>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>make</SPAN><A id=i1831752402-1></A><A id=i-1204484433-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>method creates a list consisting of zero or more copies of the same element. It takes two parameters: the length of the list to be created, and the element to be repeated:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;List.make(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'a'</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res54:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;a,&nbsp;a,&nbsp;a,&nbsp;a)</SPAN>
  <BR>  scala&gt;&nbsp;List.make(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res55:&nbsp;List[java.lang.String]&nbsp;=&nbsp;List(hello,&nbsp;hello,&nbsp;hello)</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Unzipping lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List.unzip</SPAN></H4>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unzip</SPAN><A id=i-1041609908-1></A><A id=i1323478343-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation is the inverse of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>zip</SPAN>. Where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>zip</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes two lists and forms a list of pairs,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unzip</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes a list of pairs and returns two lists, one consisting of the first element of each pair, the other consisting of the second element:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;zipped&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abcde"</SPAN>.toList&nbsp;zip&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">zipped:&nbsp;List[(Char,&nbsp;Int)]&nbsp;=&nbsp;List((a,1),&nbsp;(b,2),&nbsp;(c,3))</SPAN>
  <BR>  scala&gt;&nbsp;List.unzip(zipped)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res56:&nbsp;(List[Char],&nbsp;List[Int])&nbsp;=&nbsp;(List(a,&nbsp;b,&nbsp;c),</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;List(1,&nbsp;2,&nbsp;3))</SPAN>
</PRE><BR>
<P></P>
<DIV class=note style="PADDING-RIGHT: 20px; PADDING-LEFT: 20px; PADDING-BOTTOM: 5px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px">
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Note</H4>
<P>You might wonder why<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unzip</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a method of the global<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object, instead of being a method of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. The problem is that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unzip</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not work on any list but only on a list of pairs, whereas Scala's type system requires every method of a class to be available on every instance of that class. Thus,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unzip</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>cannot go in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class. It might be possible to extend Scala's type system in the future so that it accepts methods that only apply to some instances of a class, but so far this has not been done.</P></DIV>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Concatenating lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List.flatten</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List.concat</SPAN></H4>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatten</SPAN><A id=i-1020929432-1></A><A id=i44703139-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>method takes a list of lists and concatenates all element lists of the main list. For example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;xss&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'a'</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'b'</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'c'</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'d'</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'e'</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">xss:&nbsp;List[List[Char]]&nbsp;=&nbsp;List(List(a,&nbsp;b),&nbsp;List(c),&nbsp;List(d,&nbsp;e))</SPAN>
  <BR>  scala&gt;&nbsp;List.flatten(xss)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res57:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</SPAN>
</PRE>
<P></P>
<P><BR></P>
<DIV class=note style="PADDING-RIGHT: 20px; PADDING-LEFT: 20px; PADDING-BOTTOM: 5px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px">
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Note</H4>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatten</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is packaged in the global<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object for the same reason as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>unzip</SPAN>: it does not operate on any list, but only on lists with lists as elements, so it can't be a method of the generic<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class.</P></DIV>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>concat</SPAN><A id=i-214121608-1></A><A id=i1858358165-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flatten</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in that it concatenates a number of element lists. The element lists are given directly as repeated parameters. The number of lists to be passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>concat</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is arbitrary:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;List.concat(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'a'</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'b'</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'c'</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res58:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c)</SPAN>
  <BR>  scala&gt;&nbsp;List.concat(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'b'</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">'c'</SPAN>))
  <SPAN class=output style="COLOR: rgb(90,0,0)">res59:&nbsp;List[Char]&nbsp;=&nbsp;List(b,&nbsp;c)</SPAN>
  <BR>  scala&gt;&nbsp;List.concat()
  <SPAN class=output style="COLOR: rgb(90,0,0)">res60:&nbsp;List[Nothing]&nbsp;=&nbsp;List()</SPAN>
</PRE>
<P></P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Mapping and testing pairs of lists:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List.map2</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List.forall2</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List.exists2</SPAN></H4>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map2</SPAN><A id=i-1856727750-1></A><A id=i-1204484329-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>map</SPAN>, but it takes two lists as arguments together with a function that maps two element values to a result. The function gets applied to corresponding elements of the two lists, and a list is formed from the results:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;List.map2(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">20</SPAN>),&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">4</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>))&nbsp;(_&nbsp;*&nbsp;_)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res61:&nbsp;List[Int]&nbsp;=&nbsp;List(30,&nbsp;80)</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists2</SPAN><A id=i281503290-1></A><A id=i-491891979-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>forall2</SPAN><A id=i-1614645538-1></A><A id=i145716889-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>methods are similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>exists</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>forall</SPAN>, respectively, but they also take two lists and a boolean predicate that takes two arguments. The predicate is applied to corresponding arguments:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;List.forall2(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"de"</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>))&nbsp;(_.length&nbsp;==&nbsp;_)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res62:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;List.exists2(<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"de"</SPAN>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>))&nbsp;(_.length&nbsp;!=&nbsp;_)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res63:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
</PRE>
<P></P>
<DIV class=pointofinterest>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">The fast track</H3>
<P>In the next (and final) section of this chapter, we provide insight into Scala's type inference algorithm. You can safely skip the entire section if you're not interested in such details right now, and instead go straight to the conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#sec:list-conclusion">here</A>.</P></DIV>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=16.9></A>16.9 Understanding Scala's type inference algorithm<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#16.9">link</A>]</SPAN></H3>
<P>One difference<A id=i2062825537-1></A><A id=i2147374841-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>between the previous uses of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>concerns the admissible syntactic forms of the comparison function. Compare:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;msort((x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Char</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Char</SPAN>)&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;y)(abcde)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res64:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</SPAN>
</PRE>with:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;abcde&nbsp;sort&nbsp;(_&nbsp;&gt;&nbsp;_)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res65:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</SPAN>
</PRE>The two expressions are equivalent, but the first uses a longer form of comparison function with named parameters and explicit types whereas the second uses the concise form,<SPAN class=code>(_</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>_)</SPAN>, where named parameters are replaced by underscores. Of course, you could also use the first, longer form of comparison with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sort</SPAN>. However, the short form cannot be used with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN>: 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;msort(_&nbsp;&gt;&nbsp;_)(abcde)
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:12:&nbsp;error:&nbsp;missing&nbsp;parameter&nbsp;type&nbsp;for&nbsp;expanded&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">function&nbsp;((x$1,&nbsp;x$2)&nbsp;=&gt;&nbsp;x$1.$greater(x$2))</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msort(_&nbsp;&gt;&nbsp;_)(abcde)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P>To understand why, you need to know some details of Scala's type inference algorithm. Type inference in Scala is flow based. In a method application<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>m(args)</SPAN>, the inferencer first checks whether the method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>m</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has a known type. If it has, that type is used to infer the expected type of the arguments. For instance, in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>abcde.sort(_</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>_)</SPAN>, the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>abcde</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=code>List[Char]</SPAN>, hence<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is known to be a method that takes an argument of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(Char,</SPAN>&nbsp;<SPAN class=code>Char)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and produces a result of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Char]</SPAN>. Since the parameter types of the function arguments are thus known, they need not be written explicitly. With what it knows about<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sort</SPAN>, the inferencer can deduce that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(_</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>_)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>should expand to<SPAN class=code>((x:</SPAN>&nbsp;<SPAN class=code>Char,</SPAN>&nbsp;<SPAN class=code>y:</SPAN>&nbsp;<SPAN class=code>Char)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>y)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are some arbitrary fresh names.</P>
<P>Now consider the second case,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort(_</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>_)(abcde)</SPAN>. The type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a curried, polymorphic method type that takes an argument of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(T,</SPAN>&nbsp;<SPAN class=code>T)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to a function from<SPAN class=code>List[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[T]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>T</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is some as-yet unknown type</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method needs to be instantiated with a type parameter before it can be applied to its arguments. Because the precise instance type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the application is not yet known, it cannot be used to infer the type of its first argument. The type inferencer changes its strategy in this case; it first type checks method arguments to determine the proper instance type of the method. However, when tasked to type check the short-hand function literal,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(_</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>_)</SPAN>, it fails because it has no information about the types of the implicit function parameters that are indicated by underscores.</P>
<P>One way to resolve the problem is to pass an explicit type parameter to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN>, as in:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;msort[<SPAN class=typename style="COLOR: rgb(103,0,154)">Char</SPAN>](_&nbsp;&gt;&nbsp;_)(abcde)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res66:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</SPAN>
</PRE>Because the correct instance type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is now known, it can be used to infer the type of the arguments. 
<P></P>
<P>Another possible solution is to rewrite the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msort</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method so that its parameters are swapped:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;msortSwapped[T](xs:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>)(less:
  &nbsp;&nbsp;&nbsp;&nbsp;(T,&nbsp;T)&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>&nbsp;=&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;same&nbsp;implementation&nbsp;as&nbsp;msort,</SPAN>
  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;but&nbsp;with&nbsp;arguments&nbsp;swapped</SPAN>
  }
</PRE>Now type inference would succeed:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;msortSwapped(abcde)(_&nbsp;&gt;&nbsp;_)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res67:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</SPAN>
</PRE>What has happened is that the inferencer used the known type of the first parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>abcde</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to determine the type parameter of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msortSwapped</SPAN>. Once the precise type of<SPAN class=code>msortSwapped</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was known, it could be used in turn to infer the type of the second parameter,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(_</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>_)</SPAN>. 
<P></P>
<P>Generally, when tasked to infer the type parameters of a polymorphic method, the type inferencer consults the types of all value arguments in the first parameter list but no arguments beyond that. Since<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>msortSwapped</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a curried method with two parameter lists, the second argument (<I>i.e.</I>, the function value) did not need to be consulted to determine the type parameter of the method.</P>
<P>This inference scheme suggests the following library design principle: When designing a polymorphic method that takes some non-function arguments and a function argument, place the function argument last in a curried parameter list by its own<A id=i-1510488017-1></A>. That way, the method's correct instance type can be inferred from the non-function arguments, and that type can in turn be used to type check the function argument. The net effect is that users of the method will be able to give less type information and write function literals in more compact ways.</P>
<P>Now to the more complicated case of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">fold</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>operation. Why is there the need for an explicit type parameter in an expression like the body of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flattenRight</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method shown previously?</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  (xss&nbsp;:~<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>())&nbsp;(_&nbsp;:::&nbsp;_)
</PRE>The type of the fold-right operation is polymorphic in two type variables. Given an expression:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  (xs&nbsp;:~z)&nbsp;(op)
</PRE>The type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>must be a list of some arbitrary type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A</SPAN>, say<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs:</SPAN>&nbsp;<SPAN class=code>List[A]</SPAN>. The start value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>z</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be of some other type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>B</SPAN>. The operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>must then take two arguments of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>A</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>B</SPAN>and must return a result of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>B</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><I>i.e.</I>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op:</SPAN>&nbsp;<SPAN class=code>(A,</SPAN>&nbsp;<SPAN class=code>B)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>B</SPAN>. Because the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>z</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not related to the type of the list<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>xs</SPAN>, type inference has no context information for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>z</SPAN>. Now consider the erroneous expression in the method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>flattenRight</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>above:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  (xss&nbsp;:~<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>())&nbsp;(_&nbsp;:::&nbsp;_)&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;this&nbsp;won't&nbsp;compile</SPAN>
</PRE>The start value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>z</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in this fold is an empty list,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List()</SPAN>, so without additional type information its type is inferred to be a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Nothing]</SPAN>. Hence, the inferencer will infer that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>B</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type of the fold is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List[Nothing]</SPAN>. Therefore, the operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(_</SPAN>&nbsp;<SPAN class=code>:::</SPAN>&nbsp;<SPAN class=code>_)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the fold is expected to be of the following type:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  (<SPAN class=typename style="COLOR: rgb(103,0,154)">List[T]</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Nothing]</SPAN>)&nbsp;=&gt;&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List[Nothing]</SPAN>
</PRE>This is indeed a possible type for the operation in that fold but it is not a very useful one! It says that the operation always takes an empty list as second argument and always produces an empty list as result. In other words, the type inference settled too early on a type for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List()</SPAN>, it should have waited until it had seen the type of the operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN>. So the (otherwise very useful) rule to only consider the first argument section in a curried method application for determining the method's type is at the root of the problem here. On the other hand, even if that rule were relaxed, the inferencer still could not come up with a type for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>op</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>because its parameter types are not given. Hence, there is a Catch-22 situation which can only be resolved by an explicit type annotation from the programmer. 
<P></P>
<P>This example highlights some limitations of the local, flow-based type inference scheme of Scala. It is not present in the more global Hindley-Milner style of type inference used in functional languages such as ML or Haskell.<A id=i281902151-1></A><A id=i-402843137-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>However, Scala's local type inference deals much more gracefully with object-oriented subtyping than the Hindley-Milner style does. Fortunately, the limitations show up only in some corner cases, and are usually easily fixed by adding an explicit type annotation.</P>
<P>Adding type annotations<A id=i-250763219-1></A><A id=i-2128117477-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is also a useful debugging technique when you get confused by type error messages related to polymorphic methods. If you are unsure what caused a particular type error, just add some type arguments or other type annotations, which you think are correct. Then you should be able to quickly see where the real problem is.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=16.10></A>16.10 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html#16.10">link</A>]</SPAN></H3>
<P><A name=sec:list-conclusion></A></P>
<P>Now you have seen many ways to work with lists. You have seen the basic operations like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>head</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail</SPAN>, the first-order operations like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>reverse</SPAN>, the higher-order operations like<SPAN class=code>map</SPAN>, and the utility methods in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object. Along the way, you learned a bit about how Scala's type inference works.</P>
<P>Lists are a real work horse in Scala, so you will benefit from knowing how to use them. For that reason, this chapter has delved deeply into how to use lists. Lists are just one kind of collection that Scala supports, however. The next chapter is broad, rather than deep, and shows you how to use a variety of Scala's collection types.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 16:</H4>
<P><A name=footnote16-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For a graphical depiction of the structure of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>, see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#fig:more-fruit">Figure 22.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implementing-lists.html#fig:more-fruit">here</A>.</P>
<P><A name=footnote16-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html">Chapter 19</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>gives more details on covariance and other kinds of variance.</P>
<P><A name=footnote16-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Type parameters will be explained in more detail in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html">Chapter 19</A>.</P>
<P><A name=footnote16-4>[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>As mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/composition-and-inheritance.html#sec:impl-above-beside-tostring">Section 10.12</A>, the term<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">pair</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an informal name for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Tuple2</SPAN>.</P>
<P><A name=footnote16-5>[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>This is class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.StringBuilder</SPAN>, not<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.StringBuilder</SPAN>.</P>
<P><A name=footnote16-6>[6]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>By<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">higher-order operators</EM>, we mean higher-order functions used in operator notation. As mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/control-abstraction.html#sec:reducing-code-dup">Section 9.1</A>, higher-order functions are functions that take other functions as parameters.</P>
<P><A name=footnote16-7>[7]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List.flatten</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will be explained in the next section of this chapter.</P></DIV>