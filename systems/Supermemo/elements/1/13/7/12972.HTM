<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 8 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Functions and Closures</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>When programs get larger, you need some way to divide them into smaller, more manageable pieces. For dividing up control flow, Scala offers an approach familiar to all experienced programmers: divide the code into functions. In fact, Scala offers several ways to define functions that are not present in Java. Besides methods, which are functions that are members of some object, there are also functions nested within functions, function literals, and function values. This chapter takes you on a tour through all of these flavors of functions in Scala.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=8.1></A>8.1 Methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#8.1">link</A>]</SPAN></H3>
<P>The most common way to define a function is as a member of some object. Such a function is called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">method</SPAN><A id=i955534258-2></A>. As an example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#lst:longlines-methods">Listing 8.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows two methods that together read a file with a given name and print out all lines whose length exceeds a given width. Every printed line is prefixed with the name of the file it appears in.</P>
<P><A name=lst:longlines-methods></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.io.Source
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LongLines</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;processFile(filename:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;source&nbsp;=&nbsp;Source.fromFile(filename)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(line&nbsp;&lt;-&nbsp;source.getLines)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processLine(filename,&nbsp;width,&nbsp;line)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;processLine(filename:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;line:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(line.length&nbsp;&gt;&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(filename&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">":&nbsp;"</SPAN>+&nbsp;line.trim)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 8.1 -<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LongLines</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a private<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processLine</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.</H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processFile</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method takes a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filename</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as parameters. It creates a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Source</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object from the file name and, in the generator of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression, calls<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getLines</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>on the source. As mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html#step12">Step 12</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/next-steps-in-scala.html">Chapter 3</A>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>getLines</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns an iterator that provides one line from the file on each iteration, including the end-of-line character. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>for</SPAN>expression processes each of these lines by calling the helper method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processLine</SPAN>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processLine</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method takes three parameters: a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filename</SPAN>, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN>, and a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>line</SPAN>. It tests whether the length of the line is greater than the given width, and, if so, it prints the filename, a colon, and the line.</P>
<P>To use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LongLines</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from the command line, we'll create an application that expects the line width as the first command-line argument, and interprets subsequent arguments as filenames:<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#footnote8-1">[1]</A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">FindLongLines</SPAN>&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;main(args:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array[String]</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;width&nbsp;=&nbsp;args(<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>).toInt
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(arg&nbsp;&lt;-&nbsp;args.drop(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LongLines.processFile(arg,&nbsp;width)
  &nbsp;&nbsp;}&nbsp;
  }&nbsp;
</PRE>Here's how you'd use this application to find the lines in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LongLines.scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that are over 45 characters in length (there's just one):<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  $&nbsp;scala&nbsp;FindLongLines&nbsp;45&nbsp;LongLines.scala
  <SPAN class=output style="COLOR: rgb(90,0,0)">LongLines.scala:&nbsp;def&nbsp;processFile(filename:&nbsp;String,&nbsp;width:&nbsp;Int)&nbsp;{</SPAN>
</PRE>
<P>So far, this is very similar to what you would do in any object-oriented language. However, the concept of a function in Scala is more general than a method. Scala's other ways to express functions will be explained in the following sections.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=8.2></A>8.2 Local functions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#8.2">link</A>]</SPAN></H3>
<P>The construction of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processFile</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in the previous section demonstrated an important design principle of the functional programming style: programs should be decomposed into many small functions that each do a well-defined task. Individual functions are often quite small. The advantage of this style is that it gives a programmer many building blocks that can be flexibly composed to do more difficult things. Each building block should be simple enough to be understood individually.</P>
<P>One problem with this approach is that all the helper function names can pollute the program namespace. In the interpreter this is not so much of a problem, but once functions are packaged in reusable classes and objects, it's desirable to hide the helper functions from clients of a class. They often do not make sense individually, and you often want to keep enough flexibility to delete the helper functions if you later rewrite the class a different way.</P>
<P>In Java, your main tool for this purpose is the private method. This private-method approach works in Scala as well, as is demonstrated in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#lst:longlines-methods">Listing 8.1</A>, but Scala offers an additional approach: you can define functions inside other functions. Just like local variables, such<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g43293933"><EM style="FONT-STYLE: italic">local function</EM>s</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>are visible only in their enclosing block.<A id=i1082301132-1></A><A id=i1342112038-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Here's an example:<A id=i-1153551486-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;processFile(filename:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;processLine(filename:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;line:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(line.length&nbsp;&gt;&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(filename&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">":&nbsp;"</SPAN>+&nbsp;line)
  &nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;source&nbsp;=&nbsp;Source.fromFile(filename)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(line&nbsp;&lt;-&nbsp;source.getLines)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;processLine(filename,&nbsp;width,&nbsp;line)
  &nbsp;&nbsp;}
  }
</PRE>
<P>In this example, we refactored the original<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LongLines</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>version, shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#lst:longlines-methods">Listing 8.1</A>, by transforming private method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processLine</SPAN>, into a local function of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processFile</SPAN>. To do so we removed the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>modifier, which can only be applied (and is only needed) for methods, and placed the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processLine</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>inside the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processFile</SPAN>. As a local function,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processLine</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in scope inside<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processFile</SPAN>, but inaccessible outside.</P>
<P>Now that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processLine</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined inside<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processFile</SPAN>, however, another improvement becomes possible. Notice how<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filename</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>width</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are passed unchanged into the helper function? This is not necessary, because local functions can access the parameters of their enclosing function. You can just use the parameters of the outer<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processLine</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#lst:longlines-function">Listing 8.2</A>:<A name=lst:longlines-function></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala.io.Source
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LongLines</SPAN>&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;processFile(filename:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,&nbsp;width:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;processLine(line:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(line.length&nbsp;&gt;&nbsp;width)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(filename&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">":&nbsp;"</SPAN>+&nbsp;line)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;source&nbsp;=&nbsp;Source.fromFile(filename)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(line&nbsp;&lt;-&nbsp;source.getLines)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processLine(line)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 8.2 -<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LongLines</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a local<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>processLine</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function.</H5>
<P>Simpler, isn't it? This use of an enclosing function's parameters is a common and useful example of the general nesting Scala provides. The nesting and scoping described in<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/builtin-control-structures.html#sec:variable-scope">Section 7.7</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>applies to all Scala constructs, including functions. It's a simple principle, but very powerful, especially in a language with first-class functions.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=8.3></A>8.3 First-class functions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#8.3">link</A>]</SPAN></H3>
<P>Scala has<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g1589563862"><EM style="FONT-STYLE: italic">first-class functions</EM></A>.<A id=i-1098728772-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Not only can you define functions and call them, but you can write down functions as unnamed<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">literals</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>and then pass them around as<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">values</EM>. We introduced function literals in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html">Chapter 2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and showed the basic syntax in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#fig:function-literal">Figure 2.2</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/first-steps-in-scala.html#fig:function-literal">here</A>.</P>
<P>A function literal<A id=i-132187383-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is compiled into a class that<A id=i-1850091418-1></A><A id=i2141458026-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>when instantiated at runtime is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g1731647273"><EM style="FONT-STYLE: italic">function value</EM></A>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#footnote8-2">[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Thus the distinction between function literals and values is that function literals exist in the source code, whereas function values exist as objects at runtime. The distinction is much like that between classes (source code) and objects (runtime).</P>
<P>Here is a simple example of a function literal that adds one to a number:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  (x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>=&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>designates that this function converts the thing on the left (any integer<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>) to the thing on the right (<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>1</SPAN>). So, this is a function mapping any integer<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>1</SPAN>. 
<P></P>
<P>Function values are objects, so you can store them in variables if you like. They are functions, too, so you can invoke them using the usual parentheses function-call notation. Here is an example of both activities:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;increase&nbsp;=&nbsp;(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">increase:&nbsp;(Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function&gt;</SPAN>
  <BR>  scala&gt;&nbsp;increase(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res0:&nbsp;Int&nbsp;=&nbsp;11</SPAN>
</PRE>Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>increase</SPAN>, in this example, is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>, you can reassign it a different function value later on.<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;increase&nbsp;=&nbsp;(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">9999</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">increase:&nbsp;(Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function&gt;</SPAN>
  <BR>  scala&gt;&nbsp;increase(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;Int&nbsp;=&nbsp;10009</SPAN>
</PRE>If you want to have more than one statement in the function literal, surround its body by curly braces and put one statement per line, thus forming a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g93832333">block</A>. Just like a method, when the function value is invoked, all of the statements will be executed, and the value returned from the function is whatever the expression on the last line generates.<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;increase&nbsp;=&nbsp;(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"We"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"are"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"here!"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <SPAN class=output style="COLOR: rgb(90,0,0)">increase:&nbsp;(Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function&gt;</SPAN>
  <BR>  scala&gt;&nbsp;increase(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">We</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">are</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">here!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;Int&nbsp;=&nbsp;11</SPAN>
</PRE>So now you have seen the nuts and bolts of function literals and function values. Many Scala libraries give you opportunities to use them. For example, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is available for all collections.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#footnote8-3">[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>It takes a function as an argument and invokes that function on each of its elements. Here is how it can be used to print out all of the elements of a list:<A name=exa:someNumbers-def></A>-1<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;someNumbers&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(-<SPAN class=literal style="COLOR: rgb(205,123,0)">11</SPAN>,&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>,&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">someNumbers:&nbsp;List[Int]&nbsp;=&nbsp;List(-11,&nbsp;-10,&nbsp;-5,&nbsp;0,&nbsp;5,&nbsp;10)</SPAN>
  <BR>  scala&gt;&nbsp;someNumbers.foreach((x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;println(x))
  <SPAN class=output style="COLOR: rgb(90,0,0)">-11</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">-10</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">-5</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">0</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">5</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">10</SPAN>
</PRE>
<P></P>
<P>As another example, collection types also have a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. This method selects those elements of a collection that pass a test the user supplies. That test is supplied using a function. For example, the function<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>could be used for filtering. This function maps positive integers to true and all others to false. Here is how to use it with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;someNumbers.filter((x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res6:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</SPAN>
</PRE>Methods like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are described further later in the book.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/working-with-lists.html">Chapter 16</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>talks about their use in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html">Chapter 17</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>discusses their use with other collection types. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=8.4></A>8.4 Short forms of function literals<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#8.4">link</A>]</SPAN></H3>
<P>Scala provides a number of ways to leave out redundant information and write function literals more briefly. Keep your eyes open for these opportunities, because they allow you to remove clutter from your code.</P>
<P>One way to make a function literal more brief is to leave off the parameter types. Thus, the previous example with filter could be written like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;someNumbers.filter((x)&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res7:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</SPAN>
</PRE>The Scala compiler knows that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>must be an integer, because it sees that you are immediately using the function to filter a list of integers (referred to by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someNumbers</SPAN>). This is called<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-1884158234"><EM style="FONT-STYLE: italic">target typing</EM></A>, because the targeted usage of an expression&#8212;in this case an argument to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someNumbers.filter()</SPAN>&#8212;is allowed to influence the typing of that expression&#8212;in this case to determine the type of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter.<A id=i-1884158234-1></A><A id=i1428968692-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The precise details of target typing are not important to study. You can simply start by writing a function literal without the argument type, and, if the compiler gets confused, add in the type. Over time you'll get a feel for which situations the compiler can and cannot puzzle out. 
<P></P>
<P>A second way to remove useless characters is to leave out parentheses around a parameter whose type is inferred. In the previous example, the parentheses around<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are unnecessary:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;someNumbers.filter(x&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res8:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=8.5></A>8.5 Placeholder syntax<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#8.5">link</A>]</SPAN></H3>
<P><A name=sec:placeholder-syntax></A></P>
<P>To make a function literal even more concise, you can use underscores as<A id=i603770043-1></A><A id=i-383997826-1></A><A id=i-372979206-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>placeholders for one or more parameters, so long as each parameter appears only one time within the function literal<A id=i788093512-1></A>. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is very short notation for a function that checks whether a value is greater than zero:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;someNumbers.filter(_&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res9:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</SPAN>
</PRE>
<P></P>
<P>You can think of the underscore as a "blank" in the expression that needs to be "filled in." This blank will be filled in with an argument to the function each time the function is invoked. For example, given that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someNumbers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was initialized<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#exa:someNumbers-def">here</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List(-11,</SPAN>&nbsp;<SPAN class=code>-10,</SPAN>&nbsp;<SPAN class=code>-5,</SPAN>&nbsp;<SPAN class=code>0,</SPAN>&nbsp;<SPAN class=code>5,</SPAN>&nbsp;<SPAN class=code>10)</SPAN>, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>filter</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method will replace the blank in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>first with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-11</SPAN>, as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-11</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>0</SPAN>, then with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-10</SPAN>, as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-10</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>0</SPAN>, then with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-5</SPAN>, as in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-5</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>0</SPAN>, and so on to the end of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. The function literal<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>0</SPAN>, therefore, is equivalent to the slightly more verbose<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>0</SPAN>, as demonstrated here:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;someNumbers.filter(x&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res10:&nbsp;List[Int]&nbsp;=&nbsp;List(5,&nbsp;10)</SPAN>
</PRE>
<P></P>
<P>Sometimes when you use underscores as placeholders for parameters, the compiler might not have enough information to infer missing parameter types. For example, suppose you write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>_</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by itself:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;f&nbsp;=&nbsp;_&nbsp;+&nbsp;_
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:4:&nbsp;error:&nbsp;missing&nbsp;parameter&nbsp;type&nbsp;for&nbsp;expanded&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">function&nbsp;((x$1,&nbsp;x$2)&nbsp;=&gt;&nbsp;x$1.$plus(x$2))</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;f&nbsp;=&nbsp;_&nbsp;+&nbsp;_</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<P>In such cases, you can specify the types using a colon, like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;f&nbsp;=&nbsp;(_:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;+&nbsp;(_:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">f:&nbsp;(Int,&nbsp;Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function&gt;</SPAN>
  <BR>  scala&gt;&nbsp;f(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res11:&nbsp;Int&nbsp;=&nbsp;15</SPAN>
</PRE>Note that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>_</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expands into a literal for a function that takes two parameters. This is why you can use this short form only if each parameter appears in the function literal at most once. Multiple underscores mean multiple parameters, not reuse of a single parameter repeatedly. The first underscore represents the first parameter, the second underscore the second parameter, the third underscore the third parameter, and so on. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=8.6></A>8.6 Partially applied functions<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#8.6">link</A>]</SPAN></H3>
<P><A name=sec:partially-applied-functions></A></P>
<P>Although the previous examples substitute underscores in place of individual parameters, you can also replace an entire parameter list with an underscore.<A id=i1834060518-1></A><A id=i1842232449-1></A><A id=i1128745740-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, rather than writing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println(_)</SPAN>, you could write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println _</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN>Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  someNumbers.foreach(println&nbsp;_)
</PRE>Scala treats this short form exactly as if you had written the following:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  someNumbers.foreach(x&nbsp;=&gt;&nbsp;println(x))
</PRE>Thus, the underscore in this case is not a placeholder for a single parameter. It is a placeholder for an entire parameter list. Remember that you need to leave a space between the function name and the underscore, because otherwise the compiler will think you are referring to a different symbol, such as for example, a method named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println_</SPAN>, which likely does not exist. 
<P></P>
<P>When you use an underscore in this way, you are writing a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-1880499411"><EM style="FONT-STYLE: italic">partially applied function</EM></A>. In Scala, when you invoke a function, passing in any needed arguments, you<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">apply</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>that function<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">to</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>the arguments.<A id=i1914165903-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, given the following function:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;sum(a:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;b:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;c:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&nbsp;a&nbsp;+&nbsp;b&nbsp;+&nbsp;c
  <SPAN class=output style="COLOR: rgb(90,0,0)">sum:&nbsp;(Int,Int,Int)Int</SPAN>
</PRE>You could apply the function<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the arguments<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>3</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;sum(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res12:&nbsp;Int&nbsp;=&nbsp;6</SPAN>
</PRE>A partially applied function is an expression in which you don't supply all of the arguments needed by the function. Instead, you supply some, or none, of the needed arguments. For example, to create a partially applied function expression involving<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN>, in which you supply none of the three required arguments, you just place an underscore after "<SPAN class=code>sum</SPAN>". The resulting function can then be stored in a variable. Here's an example:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;a&nbsp;=&nbsp;sum&nbsp;_
  <SPAN class=output style="COLOR: rgb(90,0,0)">a:&nbsp;(Int,&nbsp;Int,&nbsp;Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function&gt;</SPAN>
</PRE>Given this code, the Scala compiler instantiates a function value that takes the three integer parameters missing from the partially applied function expression,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum _</SPAN>, and assigns a reference to that new function value to the variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN>. When you apply three arguments to this new function value, it will turn around and invoke<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN>, passing in those same three arguments:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;a(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res13:&nbsp;Int&nbsp;=&nbsp;6</SPAN>
</PRE>Here's what just happened: The variable named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>refers to a function value object. This function value is an instance of a class generated automatically by the Scala compiler from<SPAN class=code>sum _</SPAN>, the partially applied function expression. The class generated by the compiler has an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method that takes three arguments.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#footnote8-4">[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The generated class's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method takes three arguments because three is the number of arguments missing in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum _</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression. The Scala compiler translates the expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into an invocation of the function value's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, passing in the three arguments<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>2</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>3</SPAN>. Thus,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>a(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a short form for:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;a.apply(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res14:&nbsp;Int&nbsp;=&nbsp;6</SPAN>
</PRE>This<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, defined in the class generated automatically by the Scala compiler from the expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum _</SPAN>, simply forwards those three missing parameters to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN>, and returns the result. In this case<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>invokes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3)</SPAN>, and returns what<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns, which is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>6</SPAN>. 
<P></P>
<P>Another way to think about this kind of expression, in which an underscore is used to represent an entire parameter list, is as a way to transform a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>def</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into a function value. For example, if you have a local function, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum(a:</SPAN>&nbsp;<SPAN class=code>Int,</SPAN>&nbsp;<SPAN class=code>b:</SPAN>&nbsp;<SPAN class=code>Int,</SPAN>&nbsp;<SPAN class=code>c:</SPAN>&nbsp;<SPAN class=code>Int):</SPAN>&nbsp;<SPAN class=code>Int</SPAN>, you can "wrap" it in a function value whose<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method has the same parameter list and result types. When you apply this function value to some arguments, it in turn applies<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to those same arguments, and returns the result. Although you can't assign a method or nested function to a variable, or pass it as an argument to another function, you can do these things if you wrap the method or nested function in a function value by placing an underscore after its name.</P>
<P>Now, although<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum _</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is indeed a partially applied function, it may not be obvious to you why it is called this. It has this name because you are not applying that function to all of its arguments. In the case of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum _</SPAN>, you are applying it to<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">none</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of its arguments. But you can also express a partially applied function by supplying<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">some</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>but not all of the required arguments. Here's an example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;b&nbsp;=&nbsp;sum(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>,&nbsp;_:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">b:&nbsp;(Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function&gt;</SPAN>
</PRE>In this case, you've supplied the first and last argument to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN>, but the middle argument is missing. Since only one argument is missing, the Scala compiler generates a new function class whose<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method takes one argument. When invoked with that one argument, this generated function's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method invokes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN>, passing in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN>, the argument passed to the function, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>3</SPAN>. Here's an example:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;b(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res15:&nbsp;Int&nbsp;=&nbsp;6</SPAN>
</PRE>In this case,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b.apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>invoked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum(1,</SPAN>&nbsp;<SPAN class=code>2,</SPAN>&nbsp;<SPAN class=code>3)</SPAN>.<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;b(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res16:&nbsp;Int&nbsp;=&nbsp;9</SPAN>
</PRE>And in this case,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>b.apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>invoked<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum(1,</SPAN>&nbsp;<SPAN class=code>5,</SPAN>&nbsp;<SPAN class=code>3)</SPAN>. 
<P></P>
<P>If you are writing a partially applied function expression in which you leave off all parameters, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println _</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum _</SPAN>, you can express it more concisely by leaving off the underscore if a function is required at that point in the code. For example, instead of printing out each of the numbers in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>someNumbers</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(defined<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#exa:someNumbers-def">here</A>) like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  someNumbers.foreach(println&nbsp;_)
</PRE>You could just write:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  someNumbers.foreach(println)
</PRE>This last form is allowed only in places where a function is required, such as the invocation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in this example. The compiler knows a function is required in this case, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>requires that a function be passed as an argument. In situations where a function is not required, attempting to use this form will cause a compilation error. Here's an example:<A id=i732535273-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;c&nbsp;=&nbsp;sum
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:5:&nbsp;error:&nbsp;missing&nbsp;arguments&nbsp;for&nbsp;method&nbsp;sum...</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">follow&nbsp;this&nbsp;method&nbsp;with&nbsp;`_'&nbsp;if&nbsp;you&nbsp;want&nbsp;to&nbsp;treat&nbsp;it&nbsp;as</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;a&nbsp;partially&nbsp;applied&nbsp;function</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;c&nbsp;=&nbsp;sum</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;d&nbsp;=&nbsp;sum&nbsp;_
  <SPAN class=output style="COLOR: rgb(90,0,0)">d:&nbsp;(Int,&nbsp;Int,&nbsp;Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function&gt;</SPAN>
  <BR>  scala&gt;&nbsp;d(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">20</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">30</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res17:&nbsp;Int&nbsp;=&nbsp;60</SPAN>
</PRE>
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=8.7></A>8.7 Closures<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#8.7">link</A>]</SPAN></H3>
<P>So far in this chapter, all the examples of function literals have referred only to passed parameters.<A id=i1093320088-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example, in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>0</SPAN>, the only variable used in the function body,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>&gt;</SPAN>&nbsp;<SPAN class=code>0</SPAN>, is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>, which is defined as a parameter to the function. You can, however, refer to variables defined elsewhere:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  (x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;how&nbsp;much&nbsp;more?</SPAN>
</PRE>This function adds "<SPAN class=code>more</SPAN>" to its argument, but what is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>more</SPAN>? From the point of view of this function,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>more</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g-761850448"><EM style="FONT-STYLE: italic">free variable</EM></A>,<A id=i-2142527293-1></A><A id=i-968704369-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>because the function literal does not itself give a meaning to it. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable, by contrast, is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g183453406"><EM style="FONT-STYLE: italic">bound variable</EM></A>,<A id=i31167931-2></A><A id=i1392088405-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>because it does have a meaning in the context of the function: it is defined as the function's lone parameter, an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>. If you try using this function literal by itself, without any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>more</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defined in its scope, the compiler will complain:<A id=i138103638-2></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:5:&nbsp;error:&nbsp;not&nbsp;found:&nbsp;value&nbsp;more</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x:&nbsp;Int)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P></P>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Why the trailing underscore?</H3>
<P>Scala's syntax for partially applied functions highlights a difference in the design trade-offs of Scala and classical functional languages such as Haskell or ML. In these languages, partially applied functions are considered the normal case. Furthermore, these languages have a fairly strict static type system that will usually highlight every error with partial applications that you can make. Scala bears a much closer relation to imperative languages such as Java, where a method that's not applied to all its arguments is considered an error. Furthermore, the object-oriented tradition of subtyping and a universal root type accepts some programs that would be considered erroneous in classical functional languages.</P>
<P>For instance, say you mistook the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drop(n:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>tail()</SPAN>, and you therefore forgot you need to pass a number to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drop</SPAN>. You might write, "<SPAN class=code>println(drop)</SPAN>". Had Scala adopted the classical functional tradition that partially applied functions are OK everywhere, this code would type check. However, you might be surprised to find out that the output printed by this<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>statement would always be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;function&gt;</SPAN>! What would have happened is that the expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>drop</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would have been treated as a function object. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes objects of any type, this would have compiled OK, but it would have given an unexpected result.</P>
<P>To avoid situations like this, Scala normally requires you to specify function arguments that are left out explicitly, even if the indication is as simple as a `<SPAN class=code>_</SPAN>'. Scala allows you to leave off even the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>only when a function type is expected.</P></DIV>
<P>On the other hand, the same function literal will work fine so long as there is something available named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>more</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;more&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">more:&nbsp;Int&nbsp;=&nbsp;1</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;addMore&nbsp;=&nbsp;(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more
  <SPAN class=output style="COLOR: rgb(90,0,0)">addMore:&nbsp;(Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function&gt;</SPAN>
  <BR>  scala&gt;&nbsp;addMore(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res19:&nbsp;Int&nbsp;=&nbsp;11</SPAN>
</PRE>The function value (the object) that's created at runtime from this function literal is called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g866552379"><EM style="FONT-STYLE: italic">closure</EM></A>.<A id=i-940840561-1></A><A id=i-698028847-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The name arises from the act of "closing" the function literal by "capturing" the bindings of its free variables. A function literal with no free variables, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>1</SPAN>, is called a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">closed term</EM>, where a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">term</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a bit of source code<A id=i1045501329-1></A>. Thus a function value created at runtime from this function literal is not a closure in the strictest sense, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is already closed as written. But any function literal with free variables, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>more</SPAN>, is an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">open term</EM>. Therefore, any function value created at runtime from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>more</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will by definition require that a binding for its free variable,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>more</SPAN>, be captured. The resulting function value, which will contain a reference to the captured<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>more</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable, is called a closure, therefore, because the function value is the end product of the act of closing the open term,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>more</SPAN>. 
<P></P>
<P>This example brings up a question: what happens if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>more</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>changes after the closure is created? In Scala, the answer is that the closure sees the change. For example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;more&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">9999</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">more:&nbsp;Int&nbsp;=&nbsp;9999</SPAN>
  <BR>  scala&gt;&nbsp;addMore(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res21:&nbsp;Int&nbsp;=&nbsp;10009</SPAN>
</PRE>Intuitively, Scala's closures capture variables themselves, not the value to which variables refer.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#footnote8-5">[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>As the previous example demonstrates, the closure created for<SPAN class=code>(x:</SPAN>&nbsp;<SPAN class=code>Int)</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>+</SPAN>&nbsp;<SPAN class=code>more</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>sees the change to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>more</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>made outside the closure. The same is true in the opposite direction. Changes made by a closure to a captured variable are visible outside the closure. Here's an example:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;someNumbers&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(-<SPAN class=literal style="COLOR: rgb(205,123,0)">11</SPAN>,&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>,&nbsp;-<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">someNumbers:&nbsp;List[Int]&nbsp;=&nbsp;List(-11,&nbsp;-10,&nbsp;-5,&nbsp;0,&nbsp;5,&nbsp;10)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;sum&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">sum:&nbsp;Int&nbsp;=&nbsp;0</SPAN>
  <BR>  scala&gt;&nbsp;someNumbers.foreach(sum&nbsp;+=&nbsp;&nbsp;_)
  <BR>  scala&gt;&nbsp;sum
  <SPAN class=output style="COLOR: rgb(90,0,0)">res23:&nbsp;Int&nbsp;=&nbsp;-11</SPAN>
</PRE>This example uses a roundabout way to sum the numbers in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>. Variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in a surrounding scope from the function literal<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN>&nbsp;<SPAN class=code>+=</SPAN>&nbsp;<SPAN class=code>_</SPAN>, which adds numbers to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN>. Even though it is the closure modifying<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>sum</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>at runtime, the resulting total,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>-11</SPAN>, is still visible outside the closure. 
<P></P>
<P>What if a closure accesses some variable that has several different copies as the program runs? For example, what if a closure uses a local variable of some function, and the function is invoked many times? Which instance of that variable gets used at each access?</P>
<P>Only one answer is consistent with the rest of the language: the instance used is the one that was active at the time the closure was created. For example, here is a function that creates and returns "increase" closures:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;makeIncreaser(more:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&nbsp;(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&gt;&nbsp;x&nbsp;+&nbsp;more
</PRE>Each time this function is called it will create a new closure. Each closure will access the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>more</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable that was active when the closure was created.<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;inc1&nbsp;=&nbsp;makeIncreaser(<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">inc1:&nbsp;(Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function&gt;</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;inc9999&nbsp;=&nbsp;makeIncreaser(<SPAN class=literal style="COLOR: rgb(205,123,0)">9999</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">inc9999:&nbsp;(Int)&nbsp;=&gt;&nbsp;Int&nbsp;=&nbsp;&lt;function&gt;</SPAN>
</PRE>When you call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>makeIncreaser(1)</SPAN>, a closure is created and returned that captures the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>1</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as the binding for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>more</SPAN>. Similarly, when you call<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>makeIncreaser(9999)</SPAN>, a closure that captures the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>9999</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>more</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is returned. When you apply these closures to arguments (in this case, there's just one argument,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>, which must be passed in), the result that comes back depends on how<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>more</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>was defined when the closure was created:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;inc1(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res24:&nbsp;Int&nbsp;=&nbsp;11</SPAN>
  <BR>  scala&gt;&nbsp;inc9999(<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res25:&nbsp;Int&nbsp;=&nbsp;10009</SPAN>
</PRE>It makes no difference that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>more</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in this case is a parameter to a method call that has already returned. The Scala compiler rearranges things in cases like this so that the captured parameter lives out on the heap, instead of the stack, and thus can outlive the<A id=i-243919082-1></A><A id=i-1976863198-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>method call that created it. This rearrangement is all taken care of automatically, so you don't have to worry about it. Capture any variable you like:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>, or parameter. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=8.8></A>8.8 Repeated parameters<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#8.8">link</A>]</SPAN></H3>
<P><A name=sec:repeated-parameters></A></P>
<P>Scala<A id=i1567203046-1></A><A id=i-580179190-2></A><A id=i2051741460-1></A><A id=i-1544402352-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>allows you to indicate that the last parameter to a function may be repeated. This allows clients to pass variable length argument lists to the function. To denote a repeated parameter, place an asterisk after the type of the parameter. For example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;echo(args:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>*)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">for</SPAN>&nbsp;(arg&nbsp;&lt;-&nbsp;args)&nbsp;println(arg)
  <SPAN class=output style="COLOR: rgb(90,0,0)">echo:&nbsp;(String*)Unit</SPAN>
</PRE>Defined this way,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>echo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be called with zero to many<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>String</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;echo()
  <BR>  scala&gt;&nbsp;echo(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"one"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">one</SPAN>
  <BR>  scala&gt;&nbsp;echo(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"hello"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"world!"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">hello</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">world!</SPAN>
</PRE>
<P></P>
<P>Inside the function, the type of the repeated parameter is an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of the declared type of the parameter. Thus, the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>args</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>inside the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>echo</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function, which is declared as type "<SPAN class=code>String*</SPAN>" is actually<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array[String]</SPAN>. Nevertheless, if you have an array of the appropriate type, and attempt to pass it as a repeated parameter, you'll get a compiler error:<A id=i-677980410-1></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;arr&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Array</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"What's"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"up"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"doc?"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">arr:&nbsp;Array[java.lang.String]&nbsp;=&nbsp;Array(What's,&nbsp;up,&nbsp;doc?)</SPAN>
  <BR>  scala&gt;&nbsp;echo(arr)
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:7:&nbsp;error:&nbsp;type&nbsp;mismatch;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Array[java.lang.String]</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;required:&nbsp;String</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo(arr)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>To accomplish this, you'll need to append the array argument with a colon and an _* symbol,<A id=i-170392618-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>like this:<A id=i433377555-1></A><A id=i2101376046-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;echo(arr:&nbsp;_*)
  <SPAN class=output style="COLOR: rgb(90,0,0)">What's</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">up</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">doc?</SPAN>
</PRE>This notation tells the compiler to pass each element of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>arr</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as its own argument to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>echo</SPAN>, rather than all of it as a single argument. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=8.9></A>8.9 Tail recursion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#8.9">link</A>]</SPAN></H3>
<P><A name=sec:tail-recursion></A></P>
<P>In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/builtin-control-structures.html#sec:while-loops">Section 7.2</A>, we<A id=i1651241320-1></A><A id=i1113229075-1></A><A id=i2133301138-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>mentioned that to transform a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loop that updates<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN>s into a more functional style that uses only<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>val</SPAN>s, you may sometimes need to use recursion. Here's an example of a recursive function that approximates a value by repeatedly improving a guess until it is good enough:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;approximate(guess:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(isGoodEnough(guess))&nbsp;guess
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;approximate(improve(guess))
</PRE>A function like this is often used in search problems, with appropriate implementations for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isGoodEnough</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>improve</SPAN>. If you want the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>approximate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>function to run faster, you might be tempted to write it with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loop to try and speed it up, like this:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;approximateLoop(initialGuess:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Double</SPAN>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;guess&nbsp;=&nbsp;initialGuess
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">while</SPAN>&nbsp;(!isGoodEnough(guess))
  &nbsp;&nbsp;&nbsp;&nbsp;guess&nbsp;=&nbsp;improve(guess)
  &nbsp;&nbsp;guess
  }
</PRE>Which of the two versions of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>approximate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is preferable? In terms of brevity and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>var</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>avoidance, the first, functional one wins. But is the imperative approach perhaps more efficient? In fact, if we measure execution times it turns out that<A id=i1671917386-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>they are almost exactly the same! This might seem surprising, because a recursive call looks much more expensive than a simple jump from the end of a loop to its beginning. 
<P></P>
<P>However, in the case of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>approximate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>above, the Scala compiler is able to apply an important optimization. Note that the recursive call is the last thing that happens in the evaluation of function<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>approximate</SPAN>'s body. Functions like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>approximate</SPAN>, which call themselves as their last action, are called<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/glossary.html#g2133301346"><EM style="FONT-STYLE: italic">tail recursive</EM></A>.<A id=i-2133336344-1></A><A id=i1640045089-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The Scala compiler detects tail recursion and replaces it with a jump back to the beginning of the function, after updating the function parameters with the new values.</P>
<P>The moral is that you should not shy away from using recursive algorithms to solve your problem. Often, a recursive solution is more elegant and concise than a loop-based one. If the solution is tail recursive, there won't be any runtime overhead to be paid.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Tracing tail-recursive functions</H4>
<P>A tail-recursive function will not build a new stack frame for each call; all calls will execute in a single frame. This may surprise a programmer inspecting a stack trace of a program that failed. For example, this<A id=i10962622-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>function calls itself some number of times then throws an exception:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;boom(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Exception</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"boom!"</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;boom(x&nbsp;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)&nbsp;+&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>
</PRE>This function is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">not</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>tail recursive, because it performs an increment operation after the recursive call. You'll get what you expect when you run it: 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;&nbsp;boom(<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">java.lang.Exception:&nbsp;boom!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.boom(&lt;console&gt;:5)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.boom(&lt;console&gt;:6)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.boom(&lt;console&gt;:6)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.boom(&lt;console&gt;:6)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.&lt;init&gt;(&lt;console&gt;:6)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">...</SPAN>
</PRE>
<P>If you now modify<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>boom</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>so that it does become tail recursive:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;bang(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Exception</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"bang!"</SPAN>)
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;bang(x&nbsp;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
</PRE>
<P></P>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Tail call optimization</H3>
<P>The compiled code for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>approximate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is essentially the same as the compiled code for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>approximateLoop</SPAN>. Both functions compile down to the same thirteen instructions of Java bytecodes. If you look through the bytecodes generated by the Scala compiler for the tail recursive method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>approximate</SPAN>, you'll see that although both<SPAN class=code>isGoodEnough</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>improve</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are invoked in the body of the method,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>approximate</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not. The Scala compiler optimized away the recursive call<A id=i46846037-1></A>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  public&nbsp;double&nbsp;approximate(double);
  &nbsp;&nbsp;Code:
  &nbsp;&nbsp;&nbsp;0:&nbsp;&nbsp;&nbsp;aload_0
  &nbsp;&nbsp;&nbsp;1:&nbsp;&nbsp;&nbsp;astore_3
  &nbsp;&nbsp;&nbsp;2:&nbsp;&nbsp;&nbsp;aload_0
  &nbsp;&nbsp;&nbsp;3:&nbsp;&nbsp;&nbsp;dload_1
  &nbsp;&nbsp;&nbsp;4:&nbsp;&nbsp;&nbsp;invokevirtual&nbsp;&nbsp;&nbsp;#24;&nbsp;//Method&nbsp;isGoodEnough:(D)Z
  &nbsp;&nbsp;&nbsp;7:&nbsp;&nbsp;&nbsp;ifeq&nbsp;&nbsp;&nbsp;&nbsp;12
  &nbsp;&nbsp;&nbsp;10:&nbsp;&nbsp;dload_1
  &nbsp;&nbsp;&nbsp;11:&nbsp;&nbsp;dreturn
  &nbsp;&nbsp;&nbsp;12:&nbsp;&nbsp;aload_0
  &nbsp;&nbsp;&nbsp;13:&nbsp;&nbsp;dload_1
  &nbsp;&nbsp;&nbsp;14:&nbsp;&nbsp;invokevirtual&nbsp;&nbsp;&nbsp;#27;&nbsp;//Method&nbsp;improve:(D)D
  &nbsp;&nbsp;&nbsp;17:&nbsp;&nbsp;dstore_1
  &nbsp;&nbsp;&nbsp;18:&nbsp;&nbsp;goto&nbsp;&nbsp;&nbsp;&nbsp;2
</PRE>
<P></P></DIV>
<P>You'll get:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;bang(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">java.lang.Exception:&nbsp;bang!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.&lt;init&gt;(&lt;console&gt;:6)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">...</SPAN>
</PRE>This time, you see only a single stack frame for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bang</SPAN>. You might think that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bang</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>crashed before it called itself, but this is not the case. If you think you might be confused by tail-call optimizations when looking at a stack trace, you can turn them off by giving a:<A id=i-1882129636-1></A><A id=i2131054531-1></A><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  -g:notailcalls
</PRE>argument to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>shell or to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scalac</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>compiler. With that option specified, you will get a longer stack trace:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;bang(<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">java.lang.Exception:&nbsp;bang!</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.bang(&lt;console&gt;:5)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;.&lt;init&gt;(&lt;console&gt;:6)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">...</SPAN>
</PRE>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Limits of tail recursion</H4>
<P>The use of tail recursion in Scala is fairly limited, because the JVM<A id=i2022023743-1></A><A id=i1086960686-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction set makes implementing more advanced forms of tail recursion very difficult. Scala only optimizes directly recursive calls back to the same function making the call. If the recursion is indirect, as in the following example of two mutually recursive functions, no optimization is possible:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isEven(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">true</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;isOdd(x&nbsp;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isOdd(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;==&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">false</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;isEven(x&nbsp;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)
</PRE>You also won't get a tail-call optimization if the final call goes to a function value. Consider for instance the following recursive code:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;funValue&nbsp;=&nbsp;nestedFun&nbsp;_
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;nestedFun(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;{&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(x&nbsp;!=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;{&nbsp;println(x);&nbsp;funValue(x&nbsp;-&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>)&nbsp;}
  }
</PRE>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>funValue</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable refers to a function value that essentially wraps a call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>nestedFun</SPAN>. When you apply the function value to an argument, it turns around and applies<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>nestedFun</SPAN>to that same argument, and returns the result. You might hope, therefore, the Scala compiler would perform a tail-call optimization, but in this case it would not. Thus, tail-call optimization is limited to situations in which a method or nested function calls itself directly as its last operation, without going through a function value or some other intermediary. (If you don't fully understand tail recursion yet, see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#sec:tail-recursion">Section 8.9</A>). 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=8.10></A>8.10 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/functions-and-closures.html#8.10">link</A>]</SPAN></H3>
<P>This chapter has given you a grand tour of functions in Scala. In addition to methods, Scala provides local functions, function literals, and function values. In addition to normal function calls, Scala provides partially applied functions and functions with repeated parameters. When possible, function calls are implemented as optimized tail calls, and thus many nice-looking recursive functions run just as quickly as hand-optimized versions that use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>while</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>loops. The next chapter will build on these foundations and show how Scala's rich support for functions helps you abstract over control.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 8:</H4>
<P><A name=footnote8-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In this book, we usually won't check command-line arguments for validity in example applications, both to save trees and reduce boilerplate code that can obscure the example's important code. The trade-off is that instead of producing a helpful error message when given bad input, our example applications will throw an exception.</P>
<P><A name=footnote8-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Every function value is an instance of some class that extends one of several<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>FunctionN</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>traits in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN>, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function0</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>for functions with no parameters,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function1</SPAN>for functions with one parameter, and so on. Each<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>FunctionN</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>trait has an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method used to invoke the function.</P>
<P><A name=footnote8-3>[3]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>foreach</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method is defined in trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Iterable</SPAN>, a common supertrait of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Set</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Array</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Map</SPAN>. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/collections.html">Chapter 17</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>for the details.</P>
<P><A name=footnote8-4>[4]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The generated class extends trait<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Function3</SPAN>, which declares a three-arg<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>apply</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method.</P>
<P><A name=footnote8-5>[5]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>By contrast, Java's inner classes<A id=i706520282-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>do not allow you to access modifiable variables in surrounding scopes at all, so there is no difference between capturing a variable and capturing its currently held value.</P></DIV>