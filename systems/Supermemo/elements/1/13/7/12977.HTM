<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 13 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Packages and Imports</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>When working on a program, especially a large one, it is important to minimize<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">coupling</EM>&#8212;the extent to which the various parts of the program rely on the other parts. Low coupling reduces the risk that a small, seemingly innocuous change in one part of the program will have devastating consequences in another part. One way to minimize coupling is to write in a modular style. You divide the program into a number of smaller modules, each of which has an inside and an outside. When working on the inside of a module&#8212;its<EM style="FONT-STYLE: italic">implementation</EM>&#8212;you need only coordinate with other programmers working on that very same module. Only when you must change the outside of a module&#8212;its<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">interface</EM>&#8212;is it necessary to coordinate with developers working on other modules.<A id=i750867693-1></A></P>
<P>This chapter shows several constructs that help you program in a modular style. It shows how to place things in packages, make names visible through imports, and control the visibility of definitions through access modifiers. The constructs are similar in spirit to constructs in Java, but there are some differences&#8212;usually ways that are more consistent&#8212;so it's worth reading this chapter even if you already know Java.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=13.1></A>13.1 Packages<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#13.1">link</A>]</SPAN></H3>
<P>Scala code resides in the Java platform's global hierarchy of packages. The example code you've seen so far in this book has been in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">unnamed</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>package.<A id=i305704921-1></A><A id=i38834278-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You can place code into named packages in Scala in two ways. First, you can place the contents of an entire file into a package<SPAN class=Apple-converted-space>&nbsp;</SPAN>by putting a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>package</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause at the top of the file, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:entire-file-package">Listing 13.1</A>.</P>
<P><A name=lst:entire-file-package></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;bobsrockets.navigation
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Navigator</SPAN>
</PRE>
<H5>Listing 13.1 - Placing the contents of an entire file into a package.<A id=i-1154528502-1></A></H5>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>package</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:entire-file-package">Listing 13.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>places class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Navigator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>into the package named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bobsrockets.navigation</SPAN>. Presumably, this is the navigation software developed by Bob's Rockets, Inc.</P>
<DIV class=note style="PADDING-RIGHT: 20px; PADDING-LEFT: 20px; PADDING-BOTTOM: 5px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px">
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Note</H4>Because Scala code is part of the Java ecosystem, it is recommended to follow Java's reverse-domain-name convention for Scala packages that you release to the public. Thus, a better name for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Navigator</SPAN>'s package might be<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>com.bobsrockets.navigation</SPAN>. In this chapter, however, we'll leave off the "<SPAN class=code>com.</SPAN>" to make the examples easier to understand.</DIV>
<P>The other way you can place code into packages in Scala is more like C# namespaces.<A id=i-999496559-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You follow a package clause by a section in curly braces that contains the definitions that go into the package. Among other things, this syntax lets you put different parts of a file into different packages. For example, you might include a class's tests in the same file as the original code, but put the tests in a different package, as shown<A id=i-1775661018-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:nesting-packages">Listing 13.2</A>:<A name=lst:nesting-packages></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;navigation&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;In&nbsp;package&nbsp;bobsrockets.navigation</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Navigator</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;tests&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;In&nbsp;package&nbsp;bobsrockets.navigation.tests</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">NavigatorSuite</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 13.2 - Nesting multiple packages in the same file.</H5>
<P>The Java-like syntax shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:entire-file-package">Listing 13.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is actually just syntactic sugar for the more general nested syntax shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:nesting-packages">Listing 13.2</A>. In fact, if you do nothing with a package except nest another package inside it, you can save a level of indentation using the approach shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:dot-and-nested">Listing 13.3</A>:</P>
<P><A name=lst:dot-and-nested></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;bobsrockets.navigation&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;In&nbsp;package&nbsp;bobsrockets.navigation</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Navigator</SPAN>
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;tests&nbsp;{
  <BR>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;In&nbsp;package&nbsp;bobsrockets.navigation.tests</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">NavigatorSuite</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 13.3 - Nesting packages with minimal indentation.</H5>
<P>As this notation hints, Scala's packages truly nest. That is, package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>navigation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is semantically<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">inside</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bobsrockets</SPAN>. Java packages, despite being hierarchical, do not nest. In Java, whenever you name a package, you have to start at the root of the package hierarchy. Scala uses a more regular rule in order to simplify the language.</P>
<P>Take a look at<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:packages-truly-nest">Listing 13.4</A>. Inside the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Booster</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class, it's not necessary to reference<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Navigator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bobsrockets.navigation.Navigator</SPAN>, its fully qualified name. Since packages nest, it can be referred to as simply as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>navigation.Navigator</SPAN>. This shorter name is possible because class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Booster</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is contained in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bobsrockets</SPAN>, which has<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>navigation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a member. Therefore,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>navigation</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be referred to without a prefix, just like the code inside methods of a class can refer to other methods of that class without a prefix.<A name=lst:packages-truly-nest></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Navigator</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Booster</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;No&nbsp;need&nbsp;to&nbsp;say&nbsp;bobsrockets.navigation.Navigator</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;nav&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">navigation.Navigator</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 13.4 - Scala packages truly nest.</H5>
<P>Another consequence of Scala's scoping rules is that packages in an inner scope hide packages of the same name that are defined in an outer scope.<A id=i-370748244-1></A><A id=i498549358-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For instance, consider the code shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:hiding-packages">Listing 13.5</A>, which has three packages named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>launch</SPAN>. There's one<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>launch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bobsrockets.navigation</SPAN>, one in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bobsrockets</SPAN>, and one at the top level (in a different file from the other two). Such repeated names work fine&#8212;after all they are a major reason to use packages&#8212;but they do mean you must use some care to access precisely the one you mean.</P>
<P><A name=lst:hiding-packages></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;In&nbsp;file&nbsp;launch.scala</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Booster3</SPAN>
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;In&nbsp;file&nbsp;bobsrockets.scala</SPAN>
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Booster1</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">MissionControl</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;booster1&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">launch.Booster1</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;booster2&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">bobsrockets.launch.Booster2</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;booster3&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;_root_.launch.Booster3
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Booster2</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 13.5 - Accessing hidden package names.</H5>
<P>To see how to choose the one you mean, take a look at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>MissionControl</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:hiding-packages">Listing 13.5</A>. How would you reference each of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Booster1</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Booster2</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Booster3</SPAN>? Accessing the first one is easiest. A reference to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>launch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>by itself will get you to package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bobsrockets.navigation.launch</SPAN>, because that is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>launch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>package defined in the closest enclosing scope. Thus, you can refer to the first booster class as simply<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>launch.Booster1</SPAN>. Referring to the second one also is not tricky. You can write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bobrockets.launch.Booster2</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and be clear about which one you are referencing. That leaves the question of the third booster class, however. How can you access<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Booster3</SPAN>, considering that a nested<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>launch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>package shadows the top-level one?</P>
<P>To help in this situation, Scala provides a package named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_root_</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that is outside any package a user can write. Put another way, every top-level package you can write is treated as a member of package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_root_</SPAN>. For example, both<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>launch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bobsrockets</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:hiding-packages">Listing 13.5</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>are members of package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_root_</SPAN>. As a result,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_root_.launch</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>gives you the top-level<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>launch</SPAN>package, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>_root_.launch.Booster3</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>designates the outermost booster class.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=13.2></A>13.2 Imports<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#13.2">link</A>]</SPAN></H3>
<P><A name=sec:imports></A></P>
<P>In Scala, packages and their members can be imported using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>import</SPAN><A id=i1926037870-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>clauses. Imported items can then be accessed by a simple name like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>File</SPAN>, as opposed to requiring a qualified name like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.io.File</SPAN>. For example, consider the code shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:bobs-fruits">Listing 13.6</A>:</P>
<P><A name=lst:bobs-fruits></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;bobsdelights
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">abstract</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fruit</SPAN>(
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;name:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>,
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;color:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>
  &nbsp;&nbsp;)
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fruits</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Apple</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fruit</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"apple"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"red"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Orange</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fruit</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"orange"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"orange"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Pear</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fruit</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"pear"</SPAN>,&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"yellowish"</SPAN>)
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;menu&nbsp;=&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">List</SPAN>(<SPAN class=typename style="COLOR: rgb(103,0,154)">Apple</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Orange</SPAN>,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Pear</SPAN>)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 13.6 - Bob's delightful fruits, ready for import.</H5>
<P>An<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>import</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause makes members of a package or object available by their names alone without needing to prefix them by the package or object name. Here are some simple examples:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;easy&nbsp;access&nbsp;to&nbsp;Fruit</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;bobsdelights.Fruit
  <BR>  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;easy&nbsp;access&nbsp;to&nbsp;all&nbsp;members&nbsp;of&nbsp;bobsdelights</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;bobsdelights._
  <BR>  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;easy&nbsp;access&nbsp;to&nbsp;all&nbsp;members&nbsp;of&nbsp;Fruits</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;bobsdelights.Fruits._
</PRE>The first of these corresponds to Java's single type import, the second to Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">on-demand</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>import.<A id=i-410901588-1></A><A id=i-1858203568-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The only difference is that Scala's on-demand imports are written with a trailing underscore (<SPAN class=code>_</SPAN>) instead of an asterisk (<SPAN class=code>*</SPAN>) (after all,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a valid identifier in Scala!). The third import clause above corresponds to Java's import of static class fields. 
<P></P>
<P>These three imports give you a taste of what imports can do, but Scala imports are actually much more general. For one, imports in Scala can appear anywhere, not just at the beginning of a compilation unit. Also, they can refer to arbitrary values. For instance, the import shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:importing-object-members">Listing 13.7</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is possible:<A name=lst:importing-object-members></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;showFruit(fruit:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Fruit</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;fruit._
  &nbsp;&nbsp;&nbsp;&nbsp;println(name&nbsp;+<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"s&nbsp;are&nbsp;"</SPAN>+&nbsp;color)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 13.7 - Importing the members of a regular (not singleton) object.</H5>
<P>Method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>showFruit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>imports all members of its parameter<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>fruit</SPAN>, which is of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruit</SPAN>. The subsequent<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>println</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>statement can refer to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>name</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>color</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>directly. These two references are equivalent to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>fruit.name</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>fruit.color</SPAN>. This syntax is particularly useful when you use objects as modules, which will be described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/modular-programming-using-objects.html">Chapter 27</A>.</P>
<DIV class=aside style="BORDER-RIGHT: black thin solid; PADDING-RIGHT: 20px; BORDER-TOP: black thin solid; PADDING-LEFT: 20px; PADDING-BOTTOM: 10px; MARGIN: 25px; BORDER-LEFT: black thin solid; PADDING-TOP: 0px; BORDER-BOTTOM: black thin solid">
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Scala's flexible imports</H3>
<P>Scala's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>import</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>clauses are quite a bit more flexible than Java's. There are three principal differences. In Scala, imports:</P>
<UL>
<LI>may appear anywhere 
<LI>may refer to objects (singleton or regular) in addition to packages 
<LI>let you rename and hide some of the imported members</LI></UL></DIV>
<P>Another way Scala's imports are flexible is that they can import packages themselves, not just their non-package members. This is only natural if you think of nested packages being contained in their surrounding package. For example, in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:importing-package-name">Listing 13.8</A>, the package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.util.regex</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is imported. This makes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>regex</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>usable as a simple name. To access the<SPAN class=code>Pattern</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>singleton object from the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.util.regex</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>package, you can just say,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>regex.Pattern</SPAN>, as shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:importing-package-name">Listing 13.8</A>:</P>
<P><A name=lst:importing-package-name></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;java.util.regex
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">AStarB</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;Accesses&nbsp;java.util.regex.Pattern</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;pat&nbsp;=&nbsp;regex.Pattern.compile(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"a*b"</SPAN>)
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 13.8 - Importing a package name.</H5>
<P>Imports in Scala can also rename or hide members. This is done with an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">import selector clause</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>enclosed in braces, which follows the object from which members are imported. Here are some examples:<A id=i-1172048805-1></A><A id=i-303565265-1></A><A id=i1981623788-1></A><A id=i-1574838534-1></A></P>
<P><SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>Fruits.{Apple,</SPAN>&nbsp;<SPAN class=code>Orange}</SPAN></P>
<P><BR>This imports just members<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Orange</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruits</SPAN>.</P>
<P><SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>Fruits.{Apple</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>McIntosh,</SPAN>&nbsp;<SPAN class=code>Orange}</SPAN></P>
<P><BR>This imports the two members<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Orange</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from object<A id=i1446749334-1></A><A id=i-1444404533-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruits</SPAN>. However, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object is renamed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>McIntosh</SPAN>. So this object can be accessed with either<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruits.Apple</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=code>McIntosh</SPAN>. A renaming clause is always of the form "<SPAN class=code>&lt;original-name&gt;</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>&lt;new-name&gt;</SPAN>".</P>
<P><SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>java.sql.{Date</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>SDate}</SPAN></P>
<P><BR>This imports the SQL date class as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>SDate</SPAN>, so that you can simultaneously import the normal Java date class as simply<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Date</SPAN>.</P>
<P><SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>java.{sql</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>S}</SPAN></P>
<P><BR>This imports the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.sql</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>package as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>S</SPAN>, so that you can write things like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>S.Date</SPAN>.</P>
<P><SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>Fruits.{_}</SPAN></P>
<P><BR>This imports all members from object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruits</SPAN>. It means the same thing as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>Fruits._</SPAN>.<A id=i91932059-1></A></P>
<P><SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>Fruits.{Apple</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>McIntosh,</SPAN>&nbsp;<SPAN class=code>_}</SPAN></P>
<P><BR>This imports all members from object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruits</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>but renames<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>McIntosh</SPAN>.</P>
<P><SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>Fruits.{Pear</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>_,</SPAN>&nbsp;<SPAN class=code>_}</SPAN><A id=i1258079951-1></A></P>
<P><BR>This imports all members of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruits</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">except</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Pear</SPAN>. A clause of the form "<SPAN class=code>&lt;original-name&gt;</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>_</SPAN>" excludes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&lt;original-name&gt;</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from the names that are imported. In a sense, renaming something to `<SPAN class=code>_</SPAN>' means hiding it altogether. This is useful to avoid<A id=i-236944399-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>ambiguities. Say you have two packages,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruits</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Notebooks</SPAN>, which both define a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN>. If you want to get just the notebook named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN>, and not the fruit, you could still use two imports on demand like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;Notebooks._
  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;Fruits.{<SPAN class=typename style="COLOR: rgb(103,0,154)">Apple</SPAN>&nbsp;=&gt;&nbsp;_,&nbsp;_}
</PRE>This would import all<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Notebooks</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and all<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Fruits</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>except for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Apple</SPAN>. 
<P></P>
<P><BR>These examples demonstrate the great flexibility Scala offers when it comes to importing members selectively and possibly under different names. In summary, an import selector can consist of the following:</P>
<UL>
<LI>A simple name<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>. This includes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the set of imported names. 
<LI>A renaming clause<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>y</SPAN>. This makes the member named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>visible under the name<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN>. 
<LI>A hiding clause<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>=&gt;</SPAN>&nbsp;<SPAN class=code>_</SPAN>. This excludes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>from the set of imported names. 
<LI>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">catch-all</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>`<SPAN class=code>_</SPAN>'. This imports all members except those members mentioned in a preceding clause. If a catch-all is given, it must come last in the list of import selectors.</LI></UL>The simpler import clauses shown at the beginning of this section can be seen as special abbreviations of import clauses with a selector clause. For example, "<SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>p._</SPAN>" is equivalent to "<SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>p.{_}</SPAN>" and "<SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>p.n</SPAN>" is equivalent to "<SPAN class=code>import</SPAN>&nbsp;<SPAN class=code>p.{n}</SPAN>". 
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=13.3></A>13.3 Implicit imports<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#13.3">link</A>]</SPAN></H3>
<P>Scala adds some imports implicitly to every program. In essence, it is as if<A id=i-1027603681-1></A><A id=i586706545-2></A><A id=i1384274725-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>the following three import clauses had been added to the top of every source file with extension "<SPAN class=code>.scala</SPAN>":</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;java.lang._&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;everything&nbsp;in&nbsp;the&nbsp;java.lang&nbsp;package</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;scala._&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;everything&nbsp;in&nbsp;the&nbsp;scala&nbsp;package</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;Predef._&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;everything&nbsp;in&nbsp;the&nbsp;Predef&nbsp;object</SPAN>
</PRE>
<P></P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>package contains standard Java classes. It is always implicitly imported on the JVM implementation of Scala. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>.NET</SPAN><A id=i77181-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>implementation would import package<SPAN class=code>system</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead, which is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>.NET</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>analogue of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang</SPAN>. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is imported implicitly, you can write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Thread</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Thread</SPAN>, for instance.</P>
<P>As you have no doubt realized by now, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>package contains the standard Scala library, with many common classes and objects. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is imported implicitly, you can write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>List</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.List</SPAN>, for instance.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Predef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object contains many definitions of types, methods, and implicit conversions that are commonly used on Scala programs. For example, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Predef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is imported implicitly, you can write<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>assert</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Predef.assert</SPAN>.</P>
<P>The three import clauses above are treated a bit specially in that later imports overshadow earlier ones. For instance, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>StringBuilder</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class is defined both in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and, from Java version 1.5 on, also in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang</SPAN>. Because the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>import overshadows the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>import, the simple name<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>StringBuilder</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>will refer to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.StringBuilder</SPAN>, not<SPAN class=code>java.lang.StringBuilder</SPAN>.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=13.4></A>13.4 Access modifiers<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#13.4">link</A>]</SPAN></H3>
<P><A name=sec:access-modifiers></A></P>
<P>Members of packages, classes, or objects can be labeled with the<A id=i436061376-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>access modifiers<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN>. These modifiers restrict accesses to the members to certain regions of code. Scala's treatment of access modifiers roughly follows Java's but there are some important differences which are explained in this section.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Private members</H4>
<P>Private members are treated similarly to Java. A member labeled<A id=i-698337515-1></A><A id=i835454125-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is visible only inside the class or object that contains the member definition. In Scala, this rule applies also for inner classes. This treatment is more consistent, but differs from Java. Consider the example shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:private-access-differs">Listing 13.9</A>:</P>
<P><A name=lst:private-access-differs></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Outer</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Inner</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;f()&nbsp;{&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"f"</SPAN>)&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">InnerMost</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;OK</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Inner</SPAN>).f()&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;error:&nbsp;f&nbsp;is&nbsp;not&nbsp;accessible</SPAN>
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 13.9 - How private access differs in Scala and Java.</H5>
<P>In Scala, the access<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>(new</SPAN>&nbsp;<SPAN class=code>Inner).f()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is illegal because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is declared<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Inner</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the access is not from within class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Inner</SPAN>. By contrast, the first access to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>InnerMost</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is OK, because that access is contained in the body of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Inner</SPAN>. Java would permit both accesses because it lets an outer class access private members of its inner classes.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Protected members</H4>
<P>Access to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>members is also a bit more restrictive than in Java.<A id=i-711542007-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>In Scala, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>member is only accessible from subclasses of the class in which the member is defined. In Java such accesses are also possible from other classes in the same package. In Scala, there is another way to achieve this effect, as described below, so<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is free to be left as is. The example shown in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:protected-access-differs">Listing 13.10</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>illustrates protected accesses:<A name=lst:protected-access-differs></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;p&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Super</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">protected</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;f()&nbsp;{&nbsp;println(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"f"</SPAN>)&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Sub</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">extends</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Super</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Other</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Super</SPAN>).f()&nbsp;&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;error:&nbsp;f&nbsp;is&nbsp;not&nbsp;accessible</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 13.10 - How protected access differs in Scala and Java.</H5>
<P>In<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:protected-access-differs">Listing 13.10</A>, the access to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Sub</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is OK because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is declared<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Super</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Sub</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Super</SPAN>. By contrast the access to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>f</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Other</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not permitted, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Other</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not inherit from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Super</SPAN>. In Java, the latter access would be still permitted because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Other</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in the same package as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Sub</SPAN>.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Public members</H4>
<P>Every member not labeled<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is public. There is no explicit modifier for public members. Such members can be accessed from anywhere.</P>
<P><A name=lst:access-qualifiers></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>[bobsrockets]&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Navigator</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">protected</SPAN>[navigation]&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;useStarChart()&nbsp;{}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">LegOfJourney</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>[<SPAN class=typename style="COLOR: rgb(103,0,154)">Navigator</SPAN>]&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;distance&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">100</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>[<SPAN class=vem style="COLOR: rgb(0,0,230)">this</SPAN>]&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">var</SPAN>&nbsp;speed&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">200</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">package</SPAN>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;navigation._
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Vehicle</SPAN>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>[launch]&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;guide&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Navigator</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}</PRE>
<H5>Listing 13.11 - Flexible scope of protection with access qualifiers.</H5>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Scope of protection</H4>
<P>Access modifiers in Scala can be augmented with qualifiers. A modifier of the form<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private[X]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected[X]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>means that access is private or protected "up to"<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>X</SPAN>, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>X</SPAN>designates some enclosing package, class or singleton object.<A id=i488929967-1></A></P>
<P>Qualified access modifiers give you very fine-grained control over visibility. In particular they enable you to express Java's accessibility notions such as package private, package protected, or private up to outermost class, which are not directly expressible with simple modifiers in Scala. But they also let you express accessibility rules that cannot be expressed in Java.<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:access-qualifiers">Listing 13.11</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>presents an example with many access qualifiers being used. In this listing, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Navigator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is labeled<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private[bobsrockets]</SPAN>. This means that this class is visible in all classes and objects that are contained in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bobsrockets</SPAN>. In particular, the access to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Navigator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Vehicle</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is permitted, because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Vehicle</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is contained in package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>launch</SPAN>, which is contained in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bobsrockets</SPAN>. On the other hand, all code outside the package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>bobsrockets</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>cannot access class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Navigator</SPAN>.</P>
<P>This technique is quite useful in large projects that span several packages. It allows you to define things that are visible in several sub-packages of your project but that remain hidden from clients external to your project. The same technique is not possible in Java. There, once a definition escapes its immediate package boundary, it is visible to the world at large.</P>
<P>Of course, the qualifier of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>may also be the directly enclosing package. An example is the access modifier of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>guide</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Vehicle</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:access-qualifiers">Listing 13.11</A>. Such an access modifier is equivalent to Java's package-private access.<A id=i908525335-1></A></P>
<P><A name=tab:leg-of-journey-private></A></P>
<H5>Table 13.1 - Effects of private qualifiers on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LegOfJourney.distance</SPAN></H5>
<DIV align=center>
<TABLE style="BORDER-COLLAPSE: collapse">
<TBODY>
<TR class="topline ">
<TD style="BORDER-TOP: black thin solid"><EM style="FONT-STYLE: italic">no access modifier</EM></TD>
<TD style="BORDER-TOP: black thin solid">public access</TD></TR>
<TR class="">
<TD><SPAN class=code>private[bobsrockets]</SPAN></TD>
<TD>access within outer package</TD></TR>
<TR class="">
<TD><SPAN class=code>private[navigation]</SPAN></TD>
<TD>same as package visibility in Java</TD></TR>
<TR class="">
<TD><SPAN class=code>private[Navigator]</SPAN></TD>
<TD>same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java</TD></TR>
<TR class="">
<TD><SPAN class=code>private[LegOfJourney]</SPAN></TD>
<TD>same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala</TD></TR>
<TR class=bottomline style="BORDER-BOTTOM: rgb(222,222,222) 3px solid">
<TD style="BORDER-BOTTOM: black thin solid"><SPAN class=code>private[this]</SPAN></TD>
<TD style="BORDER-BOTTOM: black thin solid">access only from same object</TD></TR></TBODY></TABLE></DIV>
<P>All qualifiers can also be applied to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN>, with the same meaning as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN>. That is, a modifier<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected[X]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>allows access to the labeled definition in all subclasses of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and also within the enclosing package, class, or object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>X</SPAN>. For instance, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>useStarChart</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:access-qualifiers">Listing 13.11</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is accessible in all subclasses of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Navigator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and also in all code contained in the enclosing package<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>navigation</SPAN>. It thus corresponds exactly to the meaning of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java.</P>
<P>The qualifiers of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can also refer to an enclosing class or object. For instance the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>distance</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LegOfJourney</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:access-qualifiers">Listing 13.11</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is labeled<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private[Navigator]</SPAN>, so it is visible from everywhere in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Navigator</SPAN>. This gives the same access capabilities as for private members of inner classes in Java. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private[C]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>where<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the outermost enclosing class is the same as just<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java.<A id=i570723644-1></A><A id=i-1579182668-1></A></P>
<P>Finally, Scala also has an access modifier that is even more<A id=i-1909160422-1></A><A id=i623710400-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>restrictive than<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN>. A definition labeled<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private[this]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is accessible only from within the same object that contains the definition. Such a definition is called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">object-private</SPAN>. For instance, the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>speed</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Navigator</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:access-qualifiers">Listing 13.11</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is object-private. This means that any access must not only be within class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Navigator</SPAN>, but it must also be made from the very same instance of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Navigator</SPAN>. Thus the accesses "<SPAN class=code>speed</SPAN>" and "<SPAN class=code>this.speed</SPAN>" would be legal from within<SPAN class=code>Navigator</SPAN>. The following access, though, would not be allowed, even if it appeared inside class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Navigator</SPAN>:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;other&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Navigator</SPAN>
  other.speed&nbsp;<SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;this&nbsp;line&nbsp;would&nbsp;not&nbsp;compile</SPAN>
</PRE>Marking a member<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private[this]</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a guarantee that it will not be seen from other objects of the same class. This can be useful for documentation. It also sometimes lets you write more general variance annotations (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/type-parameterization.html#variance-object-local">Section 19.7</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>for details). 
<P></P>
<P>To summarize,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#tab:leg-of-journey-private">Table 13.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#tab:leg-of-journey-private">here</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>lists the effects of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>qualifiers. Each line shows a qualified private modifier and what it would mean if such a modifier were attached to the<SPAN class=code>distance</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable declared in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>LegOfJourney</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:access-qualifiers">Listing 13.11</A>.</P>
<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Visibility and companion objects</H4>
<P><A id=i-565810484-1></A></P>
<P>In Java, static members and instance members belong to the same class, so access modifiers apply uniformly to them. You have already seen that in Scala there are no static members; instead you can have a companion object that contains members that exist only once.<SPAN class=Apple-converted-space>&nbsp;</SPAN>For instance, in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#lst:companion-private">Listing 13.12</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rocket</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a companion of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rocket</SPAN>:<A name=lst:companion-private></A></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">class</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rocket</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">import</SPAN>&nbsp;Rocket.fuel
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;canGoHomeAgain&nbsp;=&nbsp;fuel&nbsp;&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">20</SPAN>
  &nbsp;&nbsp;}
  <BR>  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">object</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rocket</SPAN>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">private</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;fuel&nbsp;=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">10</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;chooseStrategy(rocket:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Rocket</SPAN>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(rocket.canGoHomeAgain)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goHome()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pickAStar()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;goHome()&nbsp;{}
  &nbsp;&nbsp;&nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;pickAStar()&nbsp;{}
  &nbsp;&nbsp;}
</PRE>
<H5>Listing 13.12 - Accessing private members of companion classes and objects.</H5>
<P>Scala's access rules privilege companion objects and classes when it comes to private or protected accesses. A class shares all its access rights with its companion object and<I>vice versa</I>. In particular, an object can access all private members of its companion class, just as a class can access all private members of its companion object.</P>
<P>For instance, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rocket</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>class above can access method<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>fuel</SPAN>, which is declared<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>private</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in object<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rocket</SPAN>. Analogously, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rocket</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object can access the private method<SPAN class=code>canGetHome</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Rocket</SPAN>.</P>
<P>One exception where the similarity between Scala and Java breaks down concerns<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>static</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>members. A protected static member of a Java class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be accessed in all subclasses of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>C</SPAN>. By contrast, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>protected</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>member in a companion object makes no sense, as singleton objects don't have any subclasses.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=13.5></A>13.5 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/packages-and-imports.html#13.5">link</A>]</SPAN></H3>
<P>In this chapter, you saw the basic constructs for dividing a program into packages. This gives you a simple and useful kind of modularity, so that you can work with very large bodies of code without different parts of the code trampling on each other. This system is the same in spirit as Java's packages, but there are some differences where Scala chooses to be more consistent or more general.</P>
<P>Looking ahead,<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/modular-programming-using-objects.html">Chapter 27</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>describes a more flexible module system than division into packages. In addition to letting you separate code into several namespaces, that approach allows modules to be parameterized and to inherit from each other. In the next chapter, we'll turn our attention to assertions and unit testing.</P></DIV>