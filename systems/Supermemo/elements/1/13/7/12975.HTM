<DIV class=vegies style="WORD-SPACING: 0px; FONT: medium Arial, Helvetica, sans-serif; MARGIN-LEFT: 27px; TEXT-TRANSFORM: none; COLOR: rgb(33,35,36); TEXT-INDENT: 0px; MARGIN-RIGHT: 139px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DIV class=tc><SPAN class=sts style="FONT-WEIGHT: normal; FONT-SIZE: 20px">Chapter 11 of Programming in Scala, First Edition</SPAN><BR><SPAN class=ts style="FONT-WEIGHT: normal; FONT-SIZE: 32px">Scala's Hierarchy</SPAN><BR><SPAN class=as style="FONT-SIZE: 18px">by Martin Odersky, Lex Spoon, and Bill Venners</SPAN><BR><SPAN class=pd style="FONT-SIZE: 15px">December 10, 2008</SPAN><BR></DIV>
<P>Now that you've seen the details of class inheritance in the previous chapter, it is a good time to take a step back and look at Scala's class hierarchy as a whole. In Scala, every class inherits from a common superclass named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>. Because every class is a subclass of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>, the methods defined in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are "universal" methods: they may be invoked on any object. Scala also defines some interesting classes at the bottom of the hierarchy,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nothing</SPAN>, which essentially act as common<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM style="FONT-STYLE: italic">sub</EM>classes. For example, just as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a superclass of every other class,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nothing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subclass of every other class. In this chapter, we'll give you a tour of Scala's class hierarchy.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=11.1></A>11.1 Scala's class hierarchy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scalas-hierarchy.html#11.1">link</A>]</SPAN></H3>
<P><A name=sec:scalas-class-hierarchy></A></P>
<P><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scalas-hierarchy.html#fig:class-hierarchy">Figure 11.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>shows an outline of Scala's class hierarchy. At the top of the hierarchy is class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>, which defines methods that include the following:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">final</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;==(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">final</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;!=(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;equals(that:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Boolean</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;hashCode:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;toString:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>
</PRE>Because every class inherits from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>, every object in a Scala program can be compared using<A id=i-1583721442-2></A><A id=i1095465388-2></A><A id=i15383763-2></A><A id=i-1108611945-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>!=</SPAN>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>; hashed using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>hashCode</SPAN>; and<A id=i1926521799-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>formatted using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN>.<A id=i-1787342122-1></A><A id=i-720005867-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The equality and inequality methods,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>!=</SPAN>, are declared<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>final</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>, so they cannot be overridden in subclasses. In fact,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is always the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>!=</SPAN><A id=i-342464093-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>is always the negation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN>. So individual classes can tailor what<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>!=</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>means by overriding the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method. We'll show an example later in this chapter. 
<P></P>
<P><A name=fig:class-hierarchy></A></P>
<DIV align=center><IMG alt="image images/scalaHierarchy.jpg" src="http://www.artima.com/pins1ed/images/scalaHierarchy.jpg"> 
<H5>Class hierarchy of Scala.<A id=i-395909855-1></A><A id=i1570311014-1></A><A id=i1398855960-1></A><A id=i1276473496-1></A><A id=i-1121985306-1></A><A id=i2002716718-1></A><A id=i695215832-1></A><A id=i-345413291-1></A></H5></DIV>
<P>The root class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has two subclasses:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyVal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyVal</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the parent class of every built-in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">value class</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala.<A id=i-20487049-1></A><A id=i499600205-1></A><A id=i785702719-1></A><A id=i-2060175836-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>There are nine such value classes:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Byte</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Short</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Char</SPAN>,<SPAN class=code>Int</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Long</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Float</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Double</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN>. The first eight of these correspond to Java's primitive types, and their values are<A id=i884498802-3></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>represented at run time as Java's primitive values. The instances of these classes are all written as literals in Scala. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>42</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an instance of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>'x'</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an instance of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Char</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>an instance of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN>. You cannot create instances of these classes using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>new</SPAN>. This is enforced by the "trick" that value classes are all defined to be both abstract and final. So if you were to write:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>
</PRE>you would get: 
<P></P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:5:&nbsp;error:&nbsp;class&nbsp;Int&nbsp;is&nbsp;abstract;&nbsp;cannot&nbsp;be&nbsp;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">instantiated</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Int</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</SPAN>
</PRE>
<P>The other value class,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN>, corresponds roughly to Java's<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>void</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>type; it is used as the result type of a method that does not otherwise return an interesting result.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Unit</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has a single instance value, which is written<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>()</SPAN>, as discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/builtin-control-structures.html#sec:while-loops">Section 7.2</A>.</P>
<P>As explained in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html">Chapter 5</A>, the value classes support the usual arithmetic and boolean operators as methods. For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has methods named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>+</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>*</SPAN>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Boolean</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>has methods named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>||</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>&amp;&amp;</SPAN>. Value classes also inherit all methods from class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN>. You can test this in the interpreter:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">42.</SPAN>toString
  <SPAN class=output style="COLOR: rgb(90,0,0)">res1:&nbsp;java.lang.String&nbsp;=&nbsp;42</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">42.</SPAN>hashCode
  <SPAN class=output style="COLOR: rgb(90,0,0)">res2:&nbsp;Int&nbsp;=&nbsp;42</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">42</SPAN>&nbsp;equals&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">42</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res3:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>Note that the value class space is flat; all value classes are subtypes of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.AnyVal</SPAN>, but they do not subclass each other. Instead there are implicit conversions between different value class types. For example, an instance of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is automatically widened (by an implicit conversion) to an instance of class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Long</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>when required. 
<P></P>
<P>As mentioned in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/basic-types-and-operations.html#sec:rich-wrappers">Section 5.9</A>, implicit conversions are also used to add more functionality to value types. For instance, the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>supports all of the operations below:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">42</SPAN>&nbsp;max&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">43</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res4:&nbsp;Int&nbsp;=&nbsp;43</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">42</SPAN>&nbsp;min&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">43</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res5:&nbsp;Int&nbsp;=&nbsp;42</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;until&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res6:&nbsp;Range&nbsp;=&nbsp;Range(1,&nbsp;2,&nbsp;3,&nbsp;4)</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">1</SPAN>&nbsp;to&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">5</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">res7:&nbsp;Range.Inclusive&nbsp;=&nbsp;Range(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5)</SPAN>
  <BR>  scala&gt;&nbsp;3.abs
  <SPAN class=output style="COLOR: rgb(90,0,0)">res8:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
  <BR>  scala&gt;&nbsp;(-<SPAN class=literal style="COLOR: rgb(205,123,0)">3</SPAN>).abs
  <SPAN class=output style="COLOR: rgb(90,0,0)">res9:&nbsp;Int&nbsp;=&nbsp;3</SPAN>
</PRE>Here's how this works: The methods<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>min</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>max</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>until</SPAN>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>to</SPAN>,<A id=i-256644535-3></A><A id=i-2103371977-2></A><A id=i-1690228669-2></A><A id=i574171488-3></A><A id=i-1171773097-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>abs</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are all defined in a class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.runtime.RichInt</SPAN>, and there is an implicit conversion from class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RichInt</SPAN>. The conversion is applied whenever a method is invoked on an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that is undefined in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>but defined in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>RichInt</SPAN>. Similar "booster classes" and implicit conversions exist for the other value classes. Implicit conversions will be discussed in detail in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/implicit-conversions-and-parameters.html">Chapter 21</A>. 
<P>The other subclass of the root class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Any</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>. This is the base class of all<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-STYLE: italic">reference classes</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala.<A id=i-1054988553-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>As mentioned previously, on the Java platform<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in fact just an alias for class<A id=i-786400333-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Object</SPAN>. So classes written in Java as well as classes written in Scala all inherit from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scalas-hierarchy.html#footnote11-1">[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>One way to think of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Object</SPAN>, therefore, is as the way<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is implemented on the Java platform. Thus, although you can use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Object</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>interchangeably in Scala programs on the Java platform, the recommended style is to use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>everywhere.<A id=i-1076915945-1></A></P>
<P>Scala classes are different from Java classes in that they also inherit from a special marker trait called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ScalaObject</SPAN>. The idea is<A id=i2117526067-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ScalaObject</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains methods that the Scala compiler defines and implements in order to make execution of Scala programs<A id=i-1203245927-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>more efficient. Right now, Scala object contains a single method, named<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>$tag</SPAN>,<A id=i-948457535-1></A><A id=i882006649-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>which is used internally to speed up pattern matching.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=11.2></A>11.2 How primitives are implemented<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scalas-hierarchy.html#11.2">link</A>]</SPAN></H3>
<P><A name=sec:impl-primitives></A></P>
<P>How is all this implemented? In fact, Scala stores integers in the<A id=i-911544850-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>same way as Java: as 32-bit words. This is important for efficiency on the JVM and also for interoperability with Java libraries. Standard operations like addition or multiplication are implemented as primitive operations. However, Scala uses the "backup" class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Integer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>whenever an integer needs to be seen as a (Java) object. This happens for instance when invoking the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>toString</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method on an integer number or when assigning an integer to a variable of type<SPAN class=code>Any</SPAN>. Integers of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are converted transparently to "boxed integers" of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Integer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>whenever necessary.<A id=i292516588-1></A><A id=i1431094886-1></A></P>
<P>All this sounds a lot like auto-boxing in Java 5 and it is indeed quite similar. There's one crucial difference, though, in that boxing in Scala is much less visible than boxing in Java. Try the following in Java:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;This&nbsp;is&nbsp;Java</SPAN>
  boolean&nbsp;isEqual(int&nbsp;x,&nbsp;int&nbsp;y)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">return</SPAN>&nbsp;x&nbsp;==&nbsp;y;
  }
  System.out.println(isEqual(<SPAN class=literal style="COLOR: rgb(205,123,0)">421</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">421</SPAN>));
</PRE>You will surely get<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>true</SPAN>. Now, change the argument types of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>isEqual</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Integer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>(or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Object</SPAN>, the result will be the same):<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=comment style="COLOR: rgb(76,76,76)">//&nbsp;This&nbsp;is&nbsp;Java</SPAN>
  boolean&nbsp;isEqual(<SPAN class=typename style="COLOR: rgb(103,0,154)">Integer</SPAN>&nbsp;x,&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Integer</SPAN>&nbsp;y)&nbsp;{
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">return</SPAN>&nbsp;x&nbsp;==&nbsp;y;
  }
  System.out.println(isEqual(<SPAN class=literal style="COLOR: rgb(205,123,0)">421</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">421</SPAN>));
</PRE>You will find that you get<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>! What happens is that the number<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>421</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>gets boxed twice, so that the arguments for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are two different objects. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>means reference equality on reference types,<A id=i1544052809-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Integer</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a reference type, the result is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>false</SPAN>. This is one aspect where it shows that Java is not a pure object-oriented language. There is a difference between primitive types and reference types that can be clearly observed. 
<P></P>
<P>Now try the same experiment in Scala:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isEqual(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>)&nbsp;=&nbsp;x&nbsp;==&nbsp;y
  <SPAN class=output style="COLOR: rgb(90,0,0)">isEqual:&nbsp;(Int,Int)Boolean</SPAN>
  <BR>  scala&gt;&nbsp;isEqual(<SPAN class=literal style="COLOR: rgb(205,123,0)">421</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">421</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res10:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;isEqual(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Any</SPAN>)&nbsp;=&nbsp;x&nbsp;==&nbsp;y
  <SPAN class=output style="COLOR: rgb(90,0,0)">isEqual:&nbsp;(Any,Any)Boolean</SPAN>
  <BR>  scala&gt;&nbsp;isEqual(<SPAN class=literal style="COLOR: rgb(205,123,0)">421</SPAN>,&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">421</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">res11:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>In fact, the equality operation<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Scala is<SPAN class=Apple-converted-space>&nbsp;</SPAN>designed to be transparent with respect to the type's representation. For value types, it is the natural (numeric or boolean) equality. For reference types,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is treated as an alias of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method inherited from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Object</SPAN>. That method is originally defined as reference equality, but is overridden by many subclasses to implement their natural notion of equality. This also means that in Scala you never fall into Java's well-known trap concerning string comparisons. In Scala, string comparison works as it should:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abcd"</SPAN>.substring(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">x:&nbsp;java.lang.String&nbsp;=&nbsp;cd</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;y&nbsp;=&nbsp;<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abcd"</SPAN>.substring(<SPAN class=literal style="COLOR: rgb(205,123,0)">2</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">y:&nbsp;java.lang.String&nbsp;=&nbsp;cd</SPAN>
  <BR>  scala&gt;&nbsp;x&nbsp;==&nbsp;y
  <SPAN class=output style="COLOR: rgb(90,0,0)">res12:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>In Java, the result of comparing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>y</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>would be false. The programmer should have used<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in this case, but it is easy to forget. 
<P></P>
<P>However, there are situations where you need reference equality instead of user-defined equality. For example, in some situations where efficiency is paramount, you would like to<EM style="FONT-STYLE: italic">hash cons</EM><A id=i1337872025-1></A><A id=i-1199948289-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>with some classes and compare their instances with reference equality.<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scalas-hierarchy.html#footnote11-2">[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For these cases, class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>defines an additional<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eq</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method, which cannot be<A id=i-795280463-2></A><A id=i2030434891-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>overridden and is implemented as reference equality (<I>i.e.</I>, it behaves like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>==</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in Java for reference types). There's also the negation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>eq</SPAN>, which is called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>ne</SPAN>.<A id=i-1620977796-2></A><A id=i1319501024-2></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>For example:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;x&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">x:&nbsp;java.lang.String&nbsp;=&nbsp;abc</SPAN>
  <BR>  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;y&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"abc"</SPAN>)
  <SPAN class=output style="COLOR: rgb(90,0,0)">y:&nbsp;java.lang.String&nbsp;=&nbsp;abc</SPAN>
  <BR>  scala&gt;&nbsp;x&nbsp;==&nbsp;y
  <SPAN class=output style="COLOR: rgb(90,0,0)">res13:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
  <BR>  scala&gt;&nbsp;x&nbsp;eq&nbsp;y
  <SPAN class=output style="COLOR: rgb(90,0,0)">res14:&nbsp;Boolean&nbsp;=&nbsp;false</SPAN>
  <BR>  scala&gt;&nbsp;x&nbsp;ne&nbsp;y
  <SPAN class=output style="COLOR: rgb(90,0,0)">res15:&nbsp;Boolean&nbsp;=&nbsp;true</SPAN>
</PRE>Equality in Scala is discussed further in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/object-equality.html">Chapter 28</A>. 
<P></P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=11.3></A>11.3 Bottom types<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scalas-hierarchy.html#11.3">link</A>]</SPAN></H3>
<P><A name=sec:bottom-types></A></P>
<P>At the bottom of the type hierarchy in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scalas-hierarchy.html#fig:class-hierarchy">Figure 11.1</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>you see the two classes<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>scala.Nothing</SPAN>. These are special types that handle some "corner cases" of Scala's object-oriented type system in a uniform way.<A id=i794065476-1></A><A id=i-1885936564-1></A></P>
<P>Class<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the type of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>reference; it is a subclass of every reference class (<I>i.e.</I>, every class that itself inherits from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN>).<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not compatible with value types.<A id=i-1844978241-1></A><A id=i-597441587-1></A><A id=i473754008-1></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You cannot, for example, assign a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>null</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>value to an integer variable:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  scala&gt;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">val</SPAN>&nbsp;i:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">null</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&lt;console&gt;:4:&nbsp;error:&nbsp;type&nbsp;mismatch;</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Null(null)</SPAN>
  <SPAN class=output style="COLOR: rgb(90,0,0)">&nbsp;required:&nbsp;Int</SPAN>
</PRE>
<P></P>
<P>Type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nothing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is at the very bottom of Scala's class hierarchy; it is a subtype of every other type. However, there exist no values of this type whatsoever. Why does it make sense to have a type without values? As discussed in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/builtin-control-structures.html#sec:try-expressions">Section 7.4</A>, one use of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nothing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is that it signals abnormal termination. For instance there's the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>error</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>method in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Predef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>object of Scala's standard library, which is defined like this:</P><PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;error(message:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">String</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Nothing</SPAN>&nbsp;=
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">throw</SPAN>&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">new</SPAN>&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">RuntimeException</SPAN>(message)
</PRE>The return type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>error</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nothing</SPAN>, which tells users that the method will not return normally (it throws an exception instead). Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nothing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of every other type, you can use methods like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>error</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>in very flexible ways. For instance:<PRE style="FONT-SIZE: 0.88em; FONT-FAMILY: 'Lucida Console', 'American Typewriter', 'Courier New', Courier, monospace">  <SPAN class=vem style="COLOR: rgb(0,0,230)">def</SPAN>&nbsp;divide(x:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>,&nbsp;y:&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>):&nbsp;<SPAN class=typename style="COLOR: rgb(103,0,154)">Int</SPAN>&nbsp;=&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">if</SPAN>&nbsp;(y&nbsp;!=&nbsp;<SPAN class=literal style="COLOR: rgb(205,123,0)">0</SPAN>)&nbsp;x&nbsp;/&nbsp;y&nbsp;
  &nbsp;&nbsp;<SPAN class=vem style="COLOR: rgb(0,0,230)">else</SPAN>&nbsp;error(<SPAN class=quotedstring style="COLOR: rgb(205,123,0)">"can't&nbsp;divide&nbsp;by&nbsp;zero"</SPAN>)
</PRE>
<P></P>
<P>The "then" branch of the conditional,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>x</SPAN>&nbsp;<SPAN class=code>/</SPAN>&nbsp;<SPAN class=code>y</SPAN>, has type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>, whereas the else branch, the call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>error</SPAN>, has type<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nothing</SPAN>. Because<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Nothing</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a subtype of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>, the type of the whole conditional is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>Int</SPAN>, as required.</P>
<H3 style="FONT-WEIGHT: normal; FONT-SIZE: 20px"><A name=11.4></A>11.4 Conclusion<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN style="FONT-SIZE: 0.5em">[<A style="COLOR: rgb(128,0,128); TEXT-DECORATION: none" href="http://www.artima.com/pins1ed/scalas-hierarchy.html#11.4">link</A>]</SPAN></H3>
<P>In this chapter we showed you the classes at the top and bottom of Scala's class hierarchy. Now that you've gotten a good foundation on class inheritance in Scala, you're ready to understand mixin composition. In the next chapter, you'll learn about traits.</P>
<HR>

<H4 style="FONT-WEIGHT: normal; FONT-SIZE: 18px; FONT-STYLE: italic">Footnotes for Chapter 11:</H4>
<P><A name=footnote11-1>[1]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>The reason the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>AnyRef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>alias exists, instead of just using the name<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>java.lang.Object</SPAN>, is because Scala was designed to work on both the Java and .NET platforms. On .NET,<SPAN class=code>AnyRef</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an alias for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>System.Object</SPAN>.<A id=i77181-2></A></P>
<P><A name=footnote11-2>[2]</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>You hash cons instances of a class by caching all instances you have created in a weak collection. Then, any time you want a new instance of the class, you first check the cache. If the cache already has an element equal to the one you are about to create, you can reuse the existing instance. As a result of this arrangement, any two instances that are equal with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=code>equals()</SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>are also equal with reference equality.</P></DIV>