Here is an example of defining a canned recipe: <PRE class=example>     define run-yacc =
     yacc $(firstword $^)
     mv y.tab.c $@
     endef
</PRE>
<P><A name=index-g_t_0040code_007byacc_007d-463></A>Here <CODE>run-yacc</CODE> is the name of the variable being defined; <CODE>endef</CODE> marks the end of the definition; the lines in between are the commands. <FONT class=extract>The <CODE>define</CODE> directive does not expand variable references and function calls in the canned sequence; the &#8216;<SAMP><SPAN class=samp>$</SPAN></SAMP>&#8217; characters, parentheses, variable names, and so on, all become part of the value of the variable you are defining. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Multi_002dLine"><FONT class=extract>Defining Multi-Line Variables</FONT></A><FONT class=extract>, for a complete explanation of <CODE>define</CODE>.</FONT> 
<P>The first command in this example runs Yacc on the first prerequisite of whichever rule uses the canned sequence. The output file from Yacc is always named <SAMP><SPAN class=file>y.tab.c</SPAN></SAMP>. The second command moves the output to the rule's target file name. 
<P>To use the canned sequence, substitute the variable into the recipe of a rule. You can substitute it like any other variable (see <A href="https://www.gnu.org/software/make/manual/make.html#Reference">Basics of Variable References</A>). Because variables defined by <CODE>define</CODE> are recursively expanded variables, all the variable references you wrote inside the <CODE>define</CODE> are expanded now. For example: <PRE class=example>     foo.c : foo.y
             $(run-yacc)
</PRE>
<P class=noindent>&#8216;<SAMP><SPAN class=samp>foo.y</SPAN></SAMP>&#8217; will be substituted for the variable &#8216;<SAMP><SPAN class=samp>$^</SPAN></SAMP>&#8217; when it occurs in <CODE>run-yacc</CODE>'s value, and &#8216;<SAMP><SPAN class=samp>foo.c</SPAN></SAMP>&#8217; for &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217;. 
<P>This is a realistic example, but this particular one is not needed in practice because <CODE>make</CODE> has an implicit rule to figure out these commands based on the file names involved (see <A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules">Using Implicit Rules</A>).