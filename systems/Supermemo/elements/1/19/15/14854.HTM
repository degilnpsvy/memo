This is marginally more exciting, but the true power of this feature only becomes apparent when you discover that secondary expansions always take place within the scope of the automatic variables for that target. This means that you can use variables such as <CODE>$@</CODE>, <CODE>$*</CODE>, etc. during the second expansion and they will have their expected values, just as in the recipe. All you have to do is defer the expansion by escaping the <CODE>$</CODE>. Also, secondary expansion occurs for both explicit and implicit (pattern) rules. Knowing this, the possible uses for this feature increase dramatically. For example: <PRE class=example>     .SECONDEXPANSION:
     main_OBJS := main.o try.o test.o
     lib_OBJS := lib.o api.o
     
     main lib: <FONT class=clozed>$$($$@_OBJS)
</FONT></PRE>
<P><FONT class=clozed>Here, after the initial expansion the prerequisites of both the <SAMP><SPAN class=file>main</SPAN></SAMP> and <SAMP><SPAN class=file>lib</SPAN></SAMP> targets will be <CODE>$($@_OBJS)</CODE>. During the secondary expansion, the <CODE>$@</CODE> variable is set to the name of the target and so the expansion for the <SAMP><SPAN class=file>main</SPAN></SAMP> target will yield <CODE>$(main_OBJS)</CODE>, or <CODE>main.o try.o test.o</CODE>, while the secondary expansion for the <SAMP><SPAN class=file>lib</SPAN></SAMP> target will yield <CODE>$(lib_OBJS)</CODE>, or <CODE>lib.o api.o</CODE>.</FONT>