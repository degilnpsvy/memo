<H3 class=section>6.6 Appending More Text to Variables</H3>
<P><A name=index-g_t_002b_003d-523></A><A name=index-appending-to-variables-524></A><A name=index-variables_002c-appending-to-525></A>Often it is useful to add more text to the value of a variable already defined. You do this with a line containing &#8216;<SAMP><SPAN class=samp>+=</SPAN></SAMP>&#8217;, like this: <PRE class=example>     objects += another.o
</PRE>
<P class=noindent>This takes the value of the variable <CODE>objects</CODE>, and adds the text &#8216;<SAMP><SPAN class=samp>another.o</SPAN></SAMP>&#8217; to it (preceded by a single space). Thus: <PRE class=example>     objects = main.o foo.o bar.o utils.o
     objects += another.o
</PRE>
<P class=noindent>sets <CODE>objects</CODE> to &#8216;<SAMP><SPAN class=samp>main.o foo.o bar.o utils.o another.o</SPAN></SAMP>&#8217;. 
<P>Using &#8216;<SAMP><SPAN class=samp>+=</SPAN></SAMP>&#8217; is similar to: <PRE class=example>     objects = main.o foo.o bar.o utils.o
     objects := $(objects) another.o
</PRE>
<P class=noindent>but differs in ways that become important when you use more complex values. 
<P><FONT class=extract>When the variable in question has not been defined before, &#8216;<SAMP><SPAN class=samp>+=</SPAN></SAMP>&#8217; acts just like normal &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217;: it defines a recursively-expanded variable. However, when there <EM>is</EM> a previous definition, exactly what &#8216;<SAMP><SPAN class=samp>+=</SPAN></SAMP>&#8217; does depends on what flavor of variable you defined originally. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Flavors"><FONT class=extract>The Two Flavors of Variables</FONT></A><FONT class=extract>, for an explanation of the two flavors of variables.</FONT> 
<P><FONT class=extract>When you add to a variable's value with &#8216;<SAMP><SPAN class=samp>+=</SPAN></SAMP>&#8217;, <CODE>make</CODE> acts essentially as if you had included the extra text in the initial definition of the variable. If you defined it first with &#8216;<SAMP><SPAN class=samp>:=</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>::=</SPAN></SAMP>&#8217;, making it a simply-expanded variable, &#8216;<SAMP><SPAN class=samp>+=</SPAN></SAMP>&#8217; adds to that simply-expanded definition, and expands the new text before appending it to the old value just as &#8216;<SAMP><SPAN class=samp>:=</SPAN></SAMP>&#8217; does (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Setting"><FONT class=extract>Setting Variables</FONT></A><FONT class=extract>, for a full explanation of &#8216;<SAMP><SPAN class=samp>:=</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>::=</SPAN></SAMP>&#8217;). In fact, </FONT><PRE class=example><FONT class=extract>     variable := value
     variable += more
</FONT></PRE>
<P class=noindent><FONT class=extract>is exactly equivalent to: </FONT>
<P class=noindent><FONT class=extract></FONT><PRE class=example><FONT class=extract>     variable := value
     variable := $(variable) more</FONT>
</PRE>
<P><FONT class=extract>On the other hand, when you use &#8216;<SAMP><SPAN class=samp>+=</SPAN></SAMP>&#8217; with a variable that you defined first to be recursively-expanded using plain &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217;, <CODE>make</CODE> does something a bit different. Recall that when you define a recursively-expanded variable, <CODE>make</CODE> does not expand the value you set for variable and function references immediately. Instead it stores the text verbatim, and saves these variable and function references to be expanded later, when you refer to the new variable (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Flavors"><FONT class=extract>The Two Flavors of Variables</FONT></A><FONT class=extract>). When you use &#8216;<SAMP><SPAN class=samp>+=</SPAN></SAMP>&#8217; on a recursively-expanded variable, it is this unexpanded text to which <CODE>make</CODE> appends the new text you specify. </FONT><PRE class=example><FONT class=extract>     variable = value
     variable += more
</FONT></PRE>
<P class=noindent><FONT class=extract>is roughly equivalent to: </FONT><PRE class=example><FONT class=extract>     temp = value
     variable = $(temp) more
</FONT></PRE>
<P class=noindent><FONT class=extract>except that of course it never defines a variable called <CODE>temp</CODE>.</FONT> <FONT class=extract>The importance of this comes when the variable's old value contains variable references. Take this common example: </FONT><PRE class=example><FONT class=extract>     CFLAGS = $(includes) -O
     ...
     CFLAGS += -pg # enable profiling
</FONT></PRE>
<P class=noindent><FONT class=extract>The first line defines the <CODE>CFLAGS</CODE> variable with a reference to another variable, <CODE>includes</CODE>. (<CODE>CFLAGS</CODE> is used by the rules for C compilation; see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Catalogue-of-Rules"><FONT class=extract>Catalogue of Implicit Rules</FONT></A><FONT class=extract>.) Using &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217; for the definition makes <CODE>CFLAGS</CODE> a recursively-expanded variable, meaning &#8216;<SAMP><SPAN class=samp>$(includes)&nbsp;-O</SPAN></SAMP>&#8217;<!-- /@w --> is <EM>not</EM> expanded when <CODE>make</CODE> processes the definition of <CODE>CFLAGS</CODE>. Thus, <CODE>includes</CODE> need not be defined yet for its value to take effect. It only has to be defined before any reference to <CODE>CFLAGS</CODE>. If we tried to append to the value of <CODE>CFLAGS</CODE> without using &#8216;<SAMP><SPAN class=samp>+=</SPAN></SAMP>&#8217;, we might do it like this: </FONT><PRE class=example><FONT class=extract>     CFLAGS := $(CFLAGS) -pg # enable profiling
</FONT></PRE>
<P class=noindent><FONT class=extract>This is pretty close, but not quite what we want. Using &#8216;<SAMP><SPAN class=samp>:=</SPAN></SAMP>&#8217; redefines <CODE>CFLAGS</CODE> as a simply-expanded variable; this means <CODE>make</CODE> expands the text &#8216;<SAMP><SPAN class=samp>$(CFLAGS)&nbsp;-pg</SPAN></SAMP>&#8217;<!-- /@w --> before setting the variable. If <CODE>includes</CODE> is not yet defined, we get &#8216;<SAMP><SPAN class=samp>&nbsp;-O&nbsp;-pg</SPAN></SAMP>&#8217;<!-- /@w -->, and a later definition of <CODE>includes</CODE> will have no effect. Conversely, by using &#8216;<SAMP><SPAN class=samp>+=</SPAN></SAMP>&#8217; we set <CODE>CFLAGS</CODE> to the <EM>unexpanded</EM> value &#8216;<SAMP><SPAN class=samp>$(includes)&nbsp;-O&nbsp;-pg</SPAN></SAMP>&#8217;<!-- /@w -->. Thus we preserve the reference to <CODE>includes</CODE>, so if that variable gets defined at any later point, a reference like &#8216;<SAMP><SPAN class=samp>$(CFLAGS)</SPAN></SAMP>&#8217; still uses its value.</FONT>