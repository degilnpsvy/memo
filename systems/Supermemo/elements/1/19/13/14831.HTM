<H3 class=section>6.5 Setting Variables</H3>
<P><A name=index-setting-variables-516></A><A name=index-variables_002c-setting-517></A><A name=index-g_t_003d-518></A><A name=index-g_t_003a_003d-519></A><A name=index-g_t_003a_003a_003d-520></A><A name=index-g_t_003f_003d-521></A><A name=index-g_t_0021_003d-522></A>To set a variable from the makefile, write a line starting with the variable name followed by &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217; &#8216;<SAMP><SPAN class=samp>:=</SPAN></SAMP>&#8217;, or &#8216;<SAMP><SPAN class=samp>::=</SPAN></SAMP>&#8217;. Whatever follows the &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>:=</SPAN></SAMP>&#8217;, or &#8216;<SAMP><SPAN class=samp>::=</SPAN></SAMP>&#8217; on the line becomes the value. <FONT class=extract>For example, </FONT><PRE class=example><FONT class=extract>     objects = main.o foo.o bar.o utils.o
</FONT></PRE>
<P class=noindent><FONT class=extract>defines a variable named <CODE>objects</CODE>. Whitespace around the variable name and immediately after the &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217; is ignored.</FONT> 
<P><FONT class=extract>Variables defined with &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217; are <DFN>recursively expanded</DFN> variables. Variables defined with &#8216;<SAMP><SPAN class=samp>:=</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>::=</SPAN></SAMP>&#8217; are <DFN>simply expanded</DFN> variables; these definitions can contain variable references which will be expanded before the definition is made. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Flavors"><FONT class=extract>The Two Flavors of Variables</FONT></A><FONT class=extract>. </FONT>
<P><FONT class=extract>The variable name may contain function and variable references, which are expanded when the line is read to find the actual variable name to use.</FONT> 
<P>There is no limit on the length of the value of a variable except the amount of memory on the computer. You can split the value of a variable into multiple physical lines for readability (see <A href="https://www.gnu.org/software/make/manual/make.html#Splitting-Lines">Splitting Long Lines</A>). 
<P>Most variable names are considered to have the empty string as a value if you have never set them. Several variables have built-in initial values that are not empty, but you can set them in the usual ways (see <A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Variables">Variables Used by Implicit Rules</A>). <FONT class=extract>Several special variables are set automatically to a new value for each rule; these are called the <DFN>automatic</DFN> variables (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables"><FONT class=extract>Automatic Variables</FONT></A><FONT class=extract>).</FONT> 
<P><FONT class=extract>If you'd like a variable to be set to a value only if it's not already set, then you can use the shorthand operator &#8216;<SAMP><SPAN class=samp>?=</SPAN></SAMP>&#8217; instead of &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217;. These two settings of the variable &#8216;<SAMP><SPAN class=samp>FOO</SPAN></SAMP>&#8217; are identical (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Origin-Function"><FONT class=extract>The <CODE>origin</CODE> Function</FONT></A><FONT class=extract>): </FONT><PRE class=example><FONT class=extract>     FOO ?= bar
</FONT></PRE>
<P class=noindent><FONT class=extract>and </FONT><PRE class=example><FONT class=extract>     ifeq ($(origin FOO), undefined)
     FOO = bar
     endif</FONT>
</PRE>
<P><FONT class=extract>The shell assignment operator &#8216;<SAMP><SPAN class=samp>!=</SPAN></SAMP>&#8217; can be used to execute a program and set a variable to its output. This operator first evaluates the right-hand side, then passes that result to the shell for execution. If the result of the execution ends in a newline, that one newline is removed; all other newlines are replaced by spaces. The resulting string is then placed into the named recursively-expanded variable. For example: </FONT><PRE class=example><FONT class=extract>     hash != printf '\043'
     file_list != find . -name '*.c'
</FONT></PRE>
<P><FONT class=extract>If the result of the execution could produce a <CODE>$</CODE>, and you don't intend what follows that to be interpreted as a make variable or function reference, then you must replace every <CODE>$</CODE> with <CODE>$$</CODE> as part of the execution. Alternatively, you can set a simply expanded variable to the result of running a program using the <CODE>shell</CODE> function call. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Shell-Function"><FONT class=extract>The <CODE>shell</CODE> Function</FONT></A><FONT class=extract>. For example: </FONT><PRE class=example><FONT class=extract>     hash := $(shell printf '\043')
     var := $(shell find . -name "*.c")
</FONT></PRE>