<H3 class=section>6.8 Defining Multi-Line Variables</H3>
<P><A name=index-define-529></A><A name=index-endef-530></A><A name=index-multi_002dline-variable-definition-531></A><A name=index-variables_002c-multi_002dline-532></A><A name=index-verbatim-variable-definition-533></A><A name=index-defining-variables-verbatim-534></A><A name=index-variables_002c-defining-verbatim-535></A><FONT class=extract>Another way to set the value of a variable is to use the <CODE>define</CODE> directive. This directive has an unusual syntax which allows newline characters to be included in the value, which is convenient for defining both canned sequences of commands (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Canned-Recipes"><FONT class=extract>Defining Canned Recipes</FONT></A><FONT class=extract>), and also sections of makefile syntax to use with <CODE>eval</CODE> (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Eval-Function"><FONT class=extract>Eval Function</FONT></A><FONT class=extract>).</FONT> 
<P>The <CODE>define</CODE> directive is followed on the same line by the name of the variable being defined and an (optional) assignment operator, and nothing more. The value to give the variable appears on the following lines. The end of the value is marked by a line containing just the word <CODE>endef</CODE>. Aside from this difference in syntax, <CODE>define</CODE> works just like any other variable definition. The variable name may contain function and variable references, which are expanded when the directive is read to find the actual variable name to use. 
<P>You may omit the variable assignment operator if you prefer. If omitted, <CODE>make</CODE> assumes it to be &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217; and creates a recursively-expanded variable (see <A href="https://www.gnu.org/software/make/manual/make.html#Flavors">The Two Flavors of Variables</A>). When using a &#8216;<SAMP><SPAN class=samp>+=</SPAN></SAMP>&#8217; operator, the value is appended to the previous value as with any other append operation: with a single space separating the old and new values. 
<P>You may nest <CODE>define</CODE> directives: <CODE>make</CODE> will keep track of nested directives and report an error if they are not all properly closed with <CODE>endef</CODE>. Note that lines beginning with the recipe prefix character are considered part of a recipe, so any <CODE>define</CODE> or <CODE>endef</CODE> strings appearing on such a line will not be considered <CODE>make</CODE> directives. <PRE class=example><FONT class=extract>     define two-lines =
     echo foo
     echo $(bar)
     endef
</FONT></PRE>
<P><FONT class=extract>The value in an ordinary assignment cannot contain a newline; but the newlines that separate the lines of the value in a <CODE>define</CODE> become part of the variable's value (except for the final newline which precedes the <CODE>endef</CODE> and is not considered part of the value). </FONT>
<P>When used in a recipe, the previous example is functionally equivalent to this: <PRE class=example>     two-lines = echo foo; echo $(bar)
</PRE>
<P class=noindent><FONT class=extract>since two commands separated by semicolon behave much like two separate shell commands. However, note that using two separate lines means <CODE>make</CODE> will invoke the shell twice, running an independent sub-shell for each line. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Execution"><FONT class=extract>Recipe Execution</FONT></A><FONT class=extract>.</FONT> 
<P><FONT class=extract>If you want variable definitions made with <CODE>define</CODE> to take precedence over command-line variable definitions, you can use the <CODE>override</CODE> directive together with <CODE>define</CODE>: </FONT><PRE class=example><FONT class=extract>     override define two-lines =
     foo
     $(bar)
     endef
</FONT></PRE>
<P class=noindent>See <A href="https://www.gnu.org/software/make/manual/make.html#Override-Directive">The <CODE>override</CODE> Directive</A>.