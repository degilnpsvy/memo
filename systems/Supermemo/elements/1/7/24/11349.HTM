<H2 style="MARGIN: 12pt 0cm 6pt 28.8pt"><SPAN lang=EN-US style="FONT-SIZE: 20pt; mso-bidi-font-size: 14.0pt"><EM><FONT face=&#23435;&#20307;>17.1 # Determinants in Simulation Performance </FONT></EM></SPAN></H2>
<p><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>We sometimes hear comments from folks such as, &#8220;We tried SystemC, but our simulations were slower than Verilog.&#8221; Such comments betray a common misconception. SystemC is not a faster simulator. The OSCI reference version of the SystemC simulator has several opportunities for optimization, and there are EDA vendors hoping to capitalize on that situation. More importantly, simulation performance is not so much about the simulator as it is the way the system is modeled. </FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>KEY POINT: SystemC simulation speed is linked directly to the use of higher levels of modeling using un-timed and transaction-level concepts. </FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>For all simulators (e.g., SPICE, Verilog, VHDL, or SystemC), there are a fundamental set of tasks that must be performed: moving data, updating event queues, keeping track of time, etc. Any simulator simulating detailed pin-level activity and timing information will provide a certain level of performance. Almost all simulators for a given class of detail will perform within a factor of two or so. </FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>No so long ago, cycle-based simulators were all the rage due to their advertised speed. Problems arose when designers discovered that these simulators didn&#8217;t provide the same level of accuracy as their event-driven counterparts. Indeed, that was exactly the reason they ran faster! </FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>That said, RTL simulates at RTL speeds. Certainly, there are simulators that do RTL better than others, but they still have the limitation of keeping track of all the same details. A good optimizer may improve performance by finding commonalities, but the improvement will be bounded.</FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>GUIDELINE: To improve simulation performance, reduce details and model at higher levels of abstraction whenever possible. </FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>It is possible to obtain dramatic speed improvements by keeping as much of the system as possible at very high levels of abstraction, and only using details where absolutely required. This approach has the effect of minimizing the number of simulation context switches, which will keep performance high. That said, even if you are at the right level of abstraction, it is necessary to limit the number of calls to wait(). </FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Part of the problem lies with understanding what a given simulation is supposed to accomplish. Ask yourself, &#8220;What question is this simulation model supposed to answer?&#8221; For example, early in the design process the architect may wish to know if a new algorithm even works. At this level, timing and pins are not really interesting. A simple executable that takes input data and produces output for analysis is all that is required. Timing should not be a part of this model. Sequential execution is probably sufficient. </FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Another set of questions might be, &#8220;Have all the parts been connected? Have we defined paths for all the information required to perform the system functions?&#8221;These questions may be answered by creating a module for every component and using a simple transaction-level model to interconnect the pieces. Cycle accuracy should not be a concern at this point in the design. </FONT></SPAN>