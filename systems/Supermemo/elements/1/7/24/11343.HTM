<HEAD></HEAD>
<BODY>
<H2 style="MARGIN: 12pt 0cm 6pt 28.8pt"><SPAN lang=EN-US style="FONT-SIZE: 20pt; mso-bidi-font-size: 14.0pt"><EM><FONT face=&#23435;&#20307;>16.6 # A TLM Example </FONT></EM></SPAN></H2>
<P><FONT face=&#23435;&#20307;><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt">In this section, we will discuss using the TLM methodology to design a realistic system. When creating a system-level design, it is important to ask yourself what the purpose of your model is. As we mentioned earlier in the chapter, a TLM model can be used to aid architectural exploration, verify system performance, assist in early software development, or aid in functional verification. </SPAN><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: &#23435;&#20307;"></SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>In some cases, your model may be used for multiple purposes, which means your system-level model architecture should also facilitate modeling at different levels of abstraction. The example in this section will focus on a high-level abstract system model that can be used for architectural exploration and software development. In addition, we will present some simulation performance statistics that show significant incentives for using TLM modeling. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>The figure below shows the system block diagram for a Voice-Over-IP (VoIP) design. This system uses many typical SoC components, including a processor, flash memory, RAM, and IO devices. All system components are connected using TLM.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><?xml:namespace prefix = v /><v:shapetype id=_x0000_t75 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"><v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"></v:path><?xml:namespace prefix = o /><o:lock v:ext="edit" aspectratio="t"></o:lock></v:shapetype><v:shape id=_x0000_i1025 style="WIDTH: 498pt; HEIGHT: 311.25pt; mso-wrap-distance-left: 0; mso-wrap-distance-right: 0; mso-position-horizontal: left; mso-position-vertical: top; mso-position-vertical-relative: line" filled="t" type="#_x0000_t75" o:allowoverlap="f"><FONT face=&#23435;&#20307;><v:fill color2="black"></v:fill><v:imagedata src="file:///C:\DOCUME~1\DONPOP~1\LOCALS~1\Temp\msohtml1\18\clip_image001.png" o:title=""></v:imagedata></FONT></v:shape></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Fig. 16.14<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>VoIP system </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>This system model simulates a home network with multiple PCs and a phone. The WAN model generates incoming Ethernet traffic, the LAN model generates output Ethernet traffic, and the phone model generates in/out phone traffic. Specifically, we would like to simulate a 20 second phone call during simultaneous network traffic. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Each IO device uses the same initiator class, configured to generate different types of traffic. In addition, each IO device also instantiates a target port to support programmer&#8217;s view, which allows bit accurate control and status register access. The target models are simple memories with storage capabilities and read/write timing delays. The router is an address decoder, and the arbiter uses a simple roundrobin algorithm. Our CPU model simulates random traffic to memory and also loads device drivers for each IO device. The device drivers manage transmit and receive queues on the IO devices, transfer received packets to destination NICs, and manage buffer allocation. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>The following figure shows how the target finally processes an initiator request using the tlm_transport_if&lt;Req,Rsp&gt; interface. First, a SystemC process (e.g., testbench, stimulus generator, etc.) calls the initiator to issue a memory write request. The initiator calls the transport() function via the TLM interface port, init_port. At this point, the request may travel through other components, including channels, routers, and arbiters, before finally arriving at the memory target. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>The target &#8220;receives&#8221; the write request in the form of a function call to its transport() function and processes the request accordingly. Note that this interface, tlm_transport_if&lt;Req,Rsp&gt;, is a blocking interface. This means that the originating SystemC thread will block until it receives a response from the slave.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><v:shape id=_x0000_i1026 style="WIDTH: 383.25pt; HEIGHT: 510.75pt; mso-wrap-distance-left: 0; mso-wrap-distance-right: 0; mso-position-horizontal: center; mso-position-vertical: top" filled="t" type="#_x0000_t75"><FONT face=&#23435;&#20307;><v:fill color2="black"></v:fill><v:imagedata src="file:///C:\DOCUME~1\DONPOP~1\LOCALS~1\Temp\msohtml1\18\clip_image003.png" o:title=""></v:imagedata></FONT></v:shape></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Fig. 16.15<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Transaction sequence via tlm_transport_if interface </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>By using this system model, we are able to validate and analyze several characteristics about our design, including: </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>&#8226;<SPAN style="mso-tab-count: 1"> </SPAN>Bus sizing </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>&#8226;<SPAN style="mso-tab-count: 1"> </SPAN>Single cycle vs. block transfer vs. bus widths </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>&#8226;<SPAN style="mso-tab-count: 1"> </SPAN>Block diagram&#8212;identify all required blocks and IO </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>&#8226;<SPAN style="mso-tab-count: 1"> </SPAN>HW/SW partitioning </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>&#8226;<SPAN style="mso-tab-count: 1"> </SPAN>Memory partitioning and performance&#8212;separating instruction and data memory. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>&#8226;<SPAN style="mso-tab-count: 1"> </SPAN>Memory access contention using the arbiter </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>&#8226;<SPAN style="mso-tab-count: 1"> </SPAN>Memory transmit/receive processing queue size </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>&#8226;<SPAN style="mso-tab-count: 1"> </SPAN>HW/SW interface </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>One advantage to designing a model at this level of abstraction is the simulation performance. We simulated our model for 20 seconds, which only required 8.43seconds of CPU time; 42% of simulated time. Of course, your simulation performance is heavily dependent on your designs and your host computer. We used timed approximations for all read/write transactions, used an event-driven vs. polling where possible, and used burst transactions for data transactions. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>To summarize, TLM modeling is great for system design feedback. Doing so requires a reasonable amount of effort, and the simulation performance lets you change your design and re-simulate very quickly. Some important thoughts to remember are to focus on what you are trying to achieve with your model, and leverage the existing IP where possible. </FONT></SPAN></P></BODY>