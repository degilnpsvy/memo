<H3 style="MARGIN: 12pt 0cm 6pt 36pt"><SPAN lang=EN-US style="FONT-SIZE: 20pt; mso-bidi-font-size: 14.0pt"><FONT face=&#23435;&#20307;>2.3.2 # SystemC Threads and Methods </FONT></SPAN></H3>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Before getting started, it is necessary to have a firm understanding of simulation processes in SystemC. As indicated earlier, the SystemC simulation kernel schedules the execution of all simulation processes. Simulation processes are simply member functions of sc_module classes that are &#8220;registered&#8221; with the simulation kernel. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Because the simulation kernel is the only caller of these member functions, they need no arguments and they return no value. They are simply C++ functions that are declared as returning a void and having an empty argument list. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>An sc_module class can also have processes that are not executed by the simulation kernel. These processes are invoked as function calls within the simulation processes of the sc_module class. These are normal C++ member functions or class methods. </FONT></SPAN></P>
<P><FONT face=&#23435;&#20307;><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt">From a software perspective, processes are simply threads of execution. From a hardware perspective, processes provide necessary modeling of independently timed circuits. Simulation processes are member functions of an sc_module that are registered with the simulation kernel. Generally, registration occurs during the elaboration phase (during the execution of the constructor for the</SPAN><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: &#23435;&#20307;"> </SPAN><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt">sc_module class) using an SC_METHOD, SC_THREAD, or SC_CTHREAD[<FONT class=extract>4SC_CTHREAD is a special case of SC_THREAD. This process type is a thread process that has the requirement of being sensitive to a clock. SC_CTHREAD is under consideration for deprecation; however, several synthesis tools depend on it at the time of writing.</FONT>]</SPAN><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: &#23435;&#20307;"> </SPAN><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt">SystemC macro. </SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT class=extract face=&#23435;&#20307;>The most basic type of simulation process is known as the SC_METHOD. An SC_METHOD is a member function of an sc_module class where time does not pass between the invocation and return of the function. In other words, an SC_METHOD is a normal C++ function that happens to have no arguments, returns no value, and is repeatedly and only called by the simulation kernel. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;><FONT class=extract>The other basic type of simulation process is known as the SC_THREAD. This process differs from the SC_METHOD in two ways. First, an SC_METHOD is invoked (or started) multiple times and the SC_THREAD is invoked only once. Second, an SC_THREAD has the option to suspend itself and potentially allow time to pass before continuing. In this sense, an SC_THREAD is similar to a traditional software thread of execution.</FONT> </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;><FONT class=extract>The SC_METHOD and SC_THREAD are the basic units of concurrent execution. The simulation kernel invokes each of these processes. Therefore, they are never invoked directly by the user. The user indirectly controls execution of the simulation processes by the kernel as a result of events, sensitivity, and notification.</FONT> </FONT></SPAN>