<H2 style="MARGIN: 12pt 0cm 6pt 28.8pt"><SPAN lang=EN-US style="FONT-SIZE: 20pt; mso-bidi-font-size: 14.0pt"><EM><FONT face=&#23435;&#20307;>6.9 # The SystemC Method Process </FONT></EM></SPAN></H2>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>As mentioned earlier, SystemC has more than one type of process. The SC_METHOD process is in some ways simpler than the SC_THREAD; however, this simplicity makes it more difficult to use for some modeling styles. To its credit, SC_METHOD may be slightly more efficient in some situations than SC_THREAD. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>What is different about an SC_METHOD? One major difference is invocation. SC_METHOD processes never suspend internally (i.e., they can never invoke wait(). Instead, SC_METHOD processes run completely and return. In some sense, SC_METHOD processes are similar to the Verilog always@ block or the VHDL process. By contrast, if an SC_THREAD terminates, it never runs again in the current simulation. </FONT></SPAN></P>
<P><FONT face=&#23435;&#20307;><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt">Because SC_METHOD processes are prohibited from suspending internally, they may not call the wait() method. Attempting to call wait() either directly or indirectly from an SC_METHOD will result in a run-time error.</SPAN><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: &#23435;&#20307;"></SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Implicit waits result from calling functions that are defined such that they may issue a wait(). These are known as blocking methods. As discussed later in this book, the read() and write() methods of the sc_fifo&lt;T&gt; data type are examples of blocking methods. Thus, SC_METHOD processes must avoid using calls to blocking methods. </FONT></SPAN></P>
<P><FONT face=&#23435;&#20307;><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt">The syntax for SC_METHOD processes follows (Fig. 6.29) and is identical to SC_THREAD except for the keyword SC_METHOD: </SPAN><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: &#23435;&#20307;"></SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: &#23435;&#20307;"><FONT face=&#23435;&#20307;>&nbsp;</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>SC_METHOD(process_name);//Located INSIDE constructor </FONT></SPAN></P>
<P><FONT face=&#23435;&#20307;><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt">Fig. 6.29<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Syntax of SC_METHOD </SPAN><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: &#23435;&#20307;"></SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: &#23435;&#20307;"><FONT face=&#23435;&#20307;>&nbsp;</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>A note on the choice of these keywords might be useful. The similarity of names between an SC_METHOD process and a regular object-oriented method betrays its name. An SC_METHOD executes without interruption and returns to the caller (the simulation kernel). By contrast, an SC_THREAD process is more akin to an operating system thread, which suspends (waits) returning control to the simulation kernel and later the kernel can resume that thread process. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Variables allocated in SC_THREAD processes are persistent. SC_METHOD processes must declare and initialize variables each time the method is invoked. For this reason, SC_METHOD processes typically rely on module local data members declared within the SC_MODULE. SC_THREAD processes tend to use locally declared variables. </FONT></SPAN></P>
<P><FONT face=&#23435;&#20307;><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt">GUIDELINE: To differentiate threads from methods, we strongly recommend adopting a naming style. One naming style appends _thread or _method as appropriate. Being able to differentiate processes based on names becomes useful during debug. </SPAN><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: &#23435;&#20307;"></SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: &#23435;&#20307;"><FONT face=&#23435;&#20307;>&nbsp;</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT class=extract face=&#23435;&#20307;>next_trigger(time); </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT class=extract face=&#23435;&#20307;>next_trigger(timeout,time_unit); //convenience </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT class=extract face=&#23435;&#20307;>next_trigger(event); </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT class=extract face=&#23435;&#20307;>next_trigger(event1 | eventi...); //any of these </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT class=extract face=&#23435;&#20307;>next_trigger(event1 &amp; eventi...); //all of these required </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT class=extract face=&#23435;&#20307;>next_trigger(timeout,event); //event with timeout </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT class=extract face=&#23435;&#20307;>next_trigger(timeout,event1 | eventi...);//any + timeout </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT class=extract face=&#23435;&#20307;>next_trigger(timeout,event1 &amp; eventi...);//all + timeout </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT class=extract face=&#23435;&#20307;>next_trigger(void); //re-establish static sensitivity </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT class=extract face=&#23435;&#20307;>Fig. 6.30<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Syntax of SC_METHOD next_trigger()</FONT></SPAN>