<H2 style="MARGIN: 12pt 0cm 6pt 28.8pt"><SPAN lang=EN-US style="FONT-SIZE: 20pt; mso-bidi-font-size: 14.0pt"><EM><FONT face=&#23435;&#20307;>6.10 # Catching Events for Method Processes </FONT></EM></SPAN></H2>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>SC_METHOD processes dynamically specify their sensitivity by means of the next_trigger() method as shown in Fig 6.30. This method has the same syntax as the wait() method but with a slightly different behavior. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>As with wait(), the multiple event syntaxes do not specify order. Thus, with next_trigger(evt1 &amp; evt2), it is not possible to know which occurred first. It is only possible to assert that both evt1 and evt2 happened. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>The wait() method suspends SC_THREAD processes; however, SC_METHOD processes are not allowed to suspend. The next_trigger() method has the effect of temporarily setting a sensitivity list that affects the SC_METHOD. The next_trigger() method may be called repeatedly, and each invocation encountered overrides the previous. The last next_trigger() executed before a return from the process determines the sensitivity for a recall or of the process. The initialization call is vital to making this work. See the next_trigger() code in the downloads section of the web site for an example. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>You should note that it is critical for every path through an SC_METHOD to specify at least one next_trigger() for the process to be called by the scheduler. <FONT class=extract>Without a next_trigger() or static sensitivity (discussed in the next section), an SC_METHOD will never be executed again.</FONT> </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>You might be tempted to place a default next_trigger() as the first statement of the SC_METHOD, since subsequent calls to next_trigger() will overwrite any previous calls. For fairly simple designs, this approach may work; however, there is a potential problem since it could mask problem where you intended a different trigger. It might be better to both allow the possibility of hanging and insert some code to determine if the process is active. An even better solution is to use a tool that can statically analyze your code for correctness. Having said that, the next section discusses a technique that guarantees a default next_trigger(). </FONT></SPAN>