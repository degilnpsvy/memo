<HEAD></HEAD>
<BODY>
<H1 style="PAGE-BREAK-BEFORE: always; MARGIN: 12pt 0cm 6pt 21.6pt"><SPAN lang=EN-US style="FONT-SIZE: 22pt; mso-bidi-font-size: 16.0pt"><FONT face=&#23435;&#20307;>Chapter 8 Basic Channels</FONT></SPAN></H1>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Thus far, we have communicated information between concurrent processes using events and using ordinary module member data. Within one instance of time (a delta cycle), the order of execution is not defined; therefore, we must be extremely careful when sharing data. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Events let us manage simulation concurrency, but they require careful coding. Because the code may miss capturing an event, it is important to update a handshake variable indicating when a request is made, and clear it when the request is acknowledged. This mechanism also allows safe data communication between concurrent simulation processes. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Let&#8217;s consider the gas station example again (Fig. 8.1). The customer notices an empty tank and arrives at the pump (1). The attendant has to be watching when the customer requests a fill-up (2), and has to make note of it if in the middle of filling up another customer (3). In the case of two arriving customers, if the attendant waits on either customer&#8217;s request (i.e., wait(e_request1|e_request2)), the sc_event semantics do not allow the attendant to know which customer made the request. In other words, the attendant does not know which request triggered the wait() to return. This is why the gas_station model uses the status of the gas tank as an indicator to choose whether to fill the tank. Similarly, the customer must watch to see if the tank was actually filled when the attendant yells done (4).</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><?xml:namespace prefix = v /><v:shapetype id=_x0000_t75 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"><v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"></v:path><?xml:namespace prefix = o /><o:lock v:ext="edit" aspectratio="t"></o:lock></v:shapetype><v:shape id=_x0000_i1025 style="WIDTH: 498.75pt; HEIGHT: 248.25pt; mso-wrap-distance-left: 0; mso-wrap-distance-right: 0; mso-position-horizontal: left; mso-position-vertical: top; mso-position-vertical-relative: line" filled="t" type="#_x0000_t75" o:allowoverlap="f"><FONT face=&#23435;&#20307;><v:fill color2="black"></v:fill><v:imagedata src="file:///C:\DOCUME~1\DONPOP~1\LOCALS~1\Temp\msohtml1\01\clip_image001.png" o:title=""></v:imagedata></FONT></v:shape></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Fig. 8.1<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>Gas station processes and events</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>SystemC has built-in mechanisms, known as channels, to reduce the tedium of these chores, to aid communications, and to encapsulate complex communications. SystemC has two types of channels: primitive and hierarchical. This chapter covers the topic of primitive channels. Hierarchical channels are the subject matter of the chapter on Custom Channels. </FONT></SPAN></P></BODY>