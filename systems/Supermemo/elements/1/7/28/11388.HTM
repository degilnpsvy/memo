<P class=Default style="MARGIN: 0cm 0cm 0pt"><FONT face=Arial><B><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.0pt">3.2 Transaction-level modeling, use cases and abstraction </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.0pt"></SPAN></FONT></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15pt; FONT-FAMILY: 'Times New Roman'; mso-bidi-font-size: 10.0pt">There has been a longstanding discussion in the ESL community concerning what is the most appropriate taxonomy of abstraction levels for transaction level modeling. Models have been categorized according to a range of criteria, including granularity of time, frequency of model evaluation, functional abstraction, communication abstraction, and use cases. The TLM-2.0 activity explicitly recognizes the existence of a variety of use cases for transaction-level modeling (see the Requirements Specification for TLM-2.0), but rather than defining an abstraction level around each use case, TLM-2.0 takes the approach of distinguishing between interfaces (APIs) on the one hand, and coding styles on the other. The TLM-2.0 standard defines a set of interfaces which should be thought of as low-level programming mechanisms for implementing transaction-level models, then describes a number of coding styles that are appropriate for, but not locked to, the various use cases. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15pt; FONT-FAMILY: 'Times New Roman'; mso-bidi-font-size: 10.0pt">The definitions of the standard TLM-2.0 interfaces stand apart from the descriptions of the coding styles. It is the TLM-2.0 interfaces which form the normative part of the standard and ensure interoperability. Each coding style can support a range of abstraction across functionality, timing and communication. In principle users can create their own coding styles. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">An untimed functional model consisting of a single software thread can be written as a C function or as a single SystemC process, and is sometimes termed an <I>algorithmic </I>model. Such a model is not <I>transaction-level </I>per se, because by definition a transaction is an abstraction of communication, and a single-threaded model has no inter-process communication. A transaction-level model requires multiple SystemC processes to simulate concurrent execution and communication.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">An abstract transaction-level model containing multiple processes (multiple software threads) requires some mechanism by which those threads can yield control to one another. This is because SystemC uses a co-operative multitasking model where an executing process cannot be pre-empted by any other process. SystemC processes yield control by calling <I>wait </I>in the case of a thread process, or returning to the kernel in the case of a method process. Calls to <I>wait </I>are usually hidden behind a programming interface (API), which may model a particular abstract or concrete protocol that may or may not rely on timing information. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Synchronization may be <I>strong </I>in the sense that the sequence of communication events is precisely determined in advance, or <I>weak </I>in the sense that the sequence of communication events is partially determined by the detailed timing of the individual processes. Strong sychronization is easily implemented in SystemC using FIFOs or semaphores, allowing a completely untimed modeling style where in principle simulation can run without advancing simulation time. Untimed modeling in this sense is outside the scope of TLM-2.0. On the other hand, a fast virtual platform model allowing multiple embedded software threads to run in parallel may use either strong or weak synchronization. In this standard, the appropriate coding style for such a model is termed <I>loosely-timed</I>. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A more detailed transaction-level model may need to associate multiple protocol-specific timing points with each transaction, such as timing points to mark the start and the end of each phase of the protocol. By choosing an appropriate number of timing points, it is possible to model communication to a high degree of timing accuracy without the need to execute the component models on every single clock cycle. In this standard, such a coding style is termed <I>approximately-timed</I>.</SPAN>