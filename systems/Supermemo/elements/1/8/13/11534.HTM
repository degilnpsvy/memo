<B><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 11.0pt; mso-font-kerning: 0pt">7.5 Generic payload memory management </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 11.0pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">a) The initiator shall be responsible for setting the data pointer and byte enable pointer attributes to existing storage, which could be static, automatic (stack) or dynamically allocated (new) storage. The initiator shall not delete this storage before the lifetime of the transaction is complete. The generic payload destructor does not delete these two arrays. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">b) This clause should be read in conjunction with the rules on generic payload extensions. See 7.20 Generic payload extensions. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">c) The generic payload supports two distinct approaches to memory management; reference counting with an explicit memory manager and ad hoc memory management by the initiator. The two approaches can be combined. Any memory management approach should manage both the transaction object itself and any extensions to the transaction object. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">d) The construction and destruction of objects of type <B>tlm_generic_payload </B>is expected to be expensive in terms of CPU time due to the implementation of the extension array. As a consequence, repeated construction and destruction of generic payload objects should be avoided. There are two recommended strategies; either use a memory manager that implements a pool of transaction objects, or if using ad hoc memory management, re-use the very same generic payload object across successive calls to <B>b_transport </B>(effectively a transaction pool with a size of one). In particular, having a generic payload object constructed and destructed once per call to <I>transport </I>would be prohibitively slow and should be avoided. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">e) A memory manager is a user-defined class that implements at least the <B>free </B>method of the abstract base class <B>tlm_mm_interface</B>. The intent is that a memory manager would provide a method to allocate a generic payload transaction object from a pool of transactions, would implement the <B>free </B>method to return a transaction object to that same pool, and would implement a destructor to delete the entire pool. The free method is called by the release method of class tlm_generic_payload when the reference count of a transaction object reaches 0. The free method of class tlm_mm_interface would typically call the reset method of class tlm_generic_payload in order to delete any extensions marked for automatic deletion. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">f) The methods set_mm, acquire, release, get_ref_count and reset of the generic payload shall only used in the presence of a memory manager. By default, a generic payload object does not have a memory manager set. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">g) Ad hoc memory management by the initiator without a memory manager requires the initiator to allocate memory for the transaction object before the TLM-2.0 core interface call, and delete or pool the transaction object and any extension objects after the call. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">h) When the generic payload is used with the blocking transport interface, the direct memory interface or the debug transport interface, either approach may be used. Ad hoc memory management by the initiator is sufficient. In the absence of a memory manager, the <B>b_transport</B>, <B>get_direct_mem_ptr</B>, or <B>transport_dbg </B>method should assume that the transaction object and any extensions will be invalidated or deleted on return. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">i) When the generic payload is used with the non-blocking transport interface, a memory manager shall be used. Any transaction object passed as an argument to <I>nb_transport </I>shall have a memory manager already set. This applies whether the caller is the initiator, an interconnect component, or a target. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">j) A blocking-to-non-blocking transport adapter shall set a memory manager for a given transaction if none existed already, in which case it shall remove that same memory manager from the transaction before returning control to the caller. A memory manager cannot be removed until the reference count has returned to 0, so the implementation will necessarily require that the method <B>free </B>of the memory manager does not delete the transaction object. The <B>simple_target_socket </B>provides an example of such an adapter. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">k) When using a memory manager, the transaction object and any extension objects shall be allocated from the heap (ultimately by calling <B>new </B>or <B>malloc</B>). </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">l) When using ad hoc memory management, the transaction object and any extensions may be allocated from the heap or from the stack. When using stack allocation, particular care needs to be taken with the memory management of extension objects in order to avoid memory leaks and segmentation faults. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">m) The method <B>set_mm </B>shall set the memory manager of the generic payload object to the object whose address is passed as an argument. The argument may be null, in which case any existing memory manager would be removed from the transaction object, but not itself deleted. <B>set_mm </B>shall not be called for a transaction object that already has a memory manager and a reference count greater than 0. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">n) The method <B>has_mm </B>shall return true if and only if a memory manager has been set. When called from the body of an <I>nb_transport </I>method, <B>has_mm </B>should return true. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">o) When called from the body of the <B>b_transport</B>, <B>get_direct_mem_ptr</B>, or <B>transport_dbg </B>methods, <B>has_mm </B>may return true or false. An interconnect component may call <B>has_mm </B>and take the appropriate action depending on whether or not a transaction has a memory manager. Otherwise, it shall assume all the obligations of a transaction with a memory manager (for example, heap allocation), but shall not call any of the methods that require the presence of a memory manager (for example, acquire). </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">p) Each generic payload object has a reference count. The default value of the reference count is 0. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">q) The method acquire shall increment the value of the reference count. If acquire is called in the absence of a memory manager, a run-time error will occur. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">r) The method release shall decrement the value of the reference count, and if this leaves the value equal to 0, shall call the method free of the memory manager object, passing the address of the transaction object as an argument. If <B>release </B>is called in the absence of a memory manager, a run-time error will occur. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">s) The method <B>get_ref_count </B>shall return the value of the reference count. In the absence of a memory manager, the value returned would be 0. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">t) In the presence of a memory manager, each initiator should call the <B>acquire </B>method of each transaction object before first passing that object as an argument to an interface method call, and should call the <B>release </B>method of that transaction object when the object is no longer required. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">u) In the presence of a memory manager, each interconnect component and target should call the <B>acquire </B>method whenever they need to extend the lifetime of a transaction object beyond the current interface method call, and call the <B>release </B>method when the object is no longer required. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">v) In the presence of a memory manager, a component may call the <B>release </B>method from any interface method call or process. Thus, a component cannot assume a transaction object is still valid after making an interface method call or after yielding control unless it has previously called the <B>acquire </B>method. For example, an initiator may call <B>release </B>from its implementation of <B>nb_transport_bw</B>, or a target from its implementation of <B>nb_transport_fw</B>. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">w) If an interconnect component or a target wishes to extend the lifetime of a transaction object indefinitely for analysis purposes, it should make a clone of the transaction object rather than using the reference counting mechanism. In other words, the reference count should not be used to extend the lifetime of a transaction object beyond the normal phases of the protocol. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">x) In the presence of a memory manager, a transaction object shall not be re-used to represent a new transaction or re-used with a different interface until the reference count indicates that no component other than the initiator itself still has a reference to the transaction object. That is, assuming the initiator has called <B>acquire </B>for the transaction object, until the reference count equals 1. This rule applies when re-using transactions with the same interface or across the transport, direct memory and debug transport interfaces. When reusing transaction objects to represent different transaction instances, it is best practice not to reuse the object until the reference count equals 0, that is, until the object has been freed. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">y) The method <B>reset </B>shall delete any extensions marked for automatic deletion, and shall set the corresponding extension pointers to null. Each extension shall be deleted by calling the method <B>free </B>of the extension object, which could conceivably be overloaded if a user wished to provide explicit memory management for extension objects. The method <B>reset </B>should typically be called from the method <B>free </B>of class <B>tlm_mm_interface </B>in order to delete extensions at the end of the lifetime of a transaction. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">z) An extension object added by calling <B>set_extension </B>may be deleted by calling <B>release_extension</B>. Calling <B>clear_extension </B>would only clear the extension pointer, not delete the extension object itself. This latter behavior would be required in the case that transaction objects are stack-allocated without a memory manager, and extension objects pooled. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">aa) In the absence of a memory manager, whichever component allocates or sets a given extension should also delete or clear that same extension before returning control from b_transport, get_direct_mem_ptr, or transport_dbg. For example, an interconnect component that implements b_transport and calls set_mm to add a memory manager to a transaction object shall not return from b_transport until it has removed from the transaction object all extensions added by itself (and assuming that any downstream components will already have removed any extensions added by themselves, by virtue of this very same rule). </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">bb) In the presence of a memory manager, extensions can be added by calling set_auto_extension, and thus deleted or pooled automatically by the memory manager. Alternatively, extensions added by calling set_ex<B>tension </B>and not explicitly cleared are so-called <I>sticky </I>extensions, meaning that they will not be automatically deleted when the transaction reference count reaches 0 but may remain associated with the transaction object even when it is pooled. Sticky extensions are a particularly efficient way to manage extension objects because the extension object need not be deleted and re-constructed between transport calls. Sticky extensions rely on transaction objects being pooled (or re-used singly). </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">cc) If it is unknown whether or not a memory manager is present, extensions should be added by calling <B>set_extension </B>and deleted by calling <B>release_extension</B>. This calling sequence is safe in the presence or absence of a memory manager. This circumstance can only occur within an interconnect component or target that chooses not to call <B>has_mm</B>. (Within an initiator, it is always known whether or not a memory manager is present, and a call to <B>has_mm </B>will always reveal whether or not a memory manager is present.) </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">dd) The method <B>free_all_extensions </B>shall delete all extensions, including but not limited to those marked for automatic deletion, and shall set the corresponding extension pointers to null. Each extension shall be deleted by calling the method <B>free </B>of the extension object. The <B>free </B>method could conceivably be overloaded if a user wished to provide explicit memory management for extension objects. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">ee) <B>free_all_extensions </B>would be useful when removing the extensions from a pooled transaction object that does not use a memory manager. With a memory manager, extensions marked for automatic deletion would indeed have been deleted automatically, while sticky extensions would not need to be deleted. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">ff) The method <B>deep_copy_from </B>shall modify the attributes and extensions of the current transaction object by copying those of another transaction object, which is passed as an argument to the method. The command, address, data length, byte enable length, streaming width, response status, and DMI allowed attributes shall be copied. The data and byte enable arrays shall be deep copied if and only if the corresponding pointers in both transactions are non-null. The application is responsible for ensuring that the arrays in the current transaction are sufficiently large. If an extension on the other transaction already exists on the current transaction, it shall be copied by calling the <B>copy_from </B>method of the extension class. Otherwise, a new extension object shall be created by calling the <B>clone </B>method of the extension class, and set on the current transaction. In the case of cloning, the new extension shall be marked for automatic deletion if and only if a memory manager is present for the current transaction. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">gg) In other words, in the presence of a memory manager <B>deep_copy_from </B>will mark for automatic deletion any new extensions that were not already on the current object. Without a memory manager, extensions cannot be marked for auto-deletion. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><FONT face=Arial><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">hh) The method <B>update_original_from </B>shall modify certain attributes and extensions of the current transaction object by copying those of another transaction object, which is passed as an argument to the method. The intent is that <B>update_original_from </B>should be called to pass back the response for a transaction created using <B>deep_copy_from</B>. The response status and DMI allowed attributes of the current transaction object shall be modified. The data array shall be deep copied if and only if the command attribute of the current transaction is TLM_READ_COMMAND and the data pointers in the two transactions are both non-null and are unequal. The byte enable array shall be used to mask the copy operation, as per the read command, if and only if the byte enable pointer is non-null and the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 17pt; FONT-FAMILY: 'Times New Roman'; mso-bidi-font-size: 12.0pt"></SPAN></FONT></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">use_byte_enable_on_read </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">argument is <B>true</B>. Otherwise, the entire data array shall be deep copied. The extensions of the current transaction object shall be updated as per the <B>update_extensions_from </B>method. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">ii) The method <B>update_extensions_from </B>shall modify the extensions of the current transaction object by copying from another transaction object only those extensions that were already present on the current object. The extensions shall be copied by calling the <B>copy_from </B>method of the extension class. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">jj) The typical use case for <B>deep_copy_from</B>, <B>update_original_from </B>and <B>update_extensions_from </B>is within a transaction bridge where they are used to deep copy an incoming request, send the copy out through an initiator socket, then on receiving back the response copy the appropriate attributes and extensions back to the original transaction object. The transaction bridge may choose to deep copy the arrays or merely to copy the pointers. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">kk) These obligations apply to the generic payload. In principle, similar obligations might apply to transaction types unrelated to the generic payload </SPAN>