<B><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 11.0pt; mso-font-kerning: 0pt">7.10 Data pointer attribute </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 11.0pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">a) The method <B>set_data_ptr </B>shall set the data pointer attribute to the value passed as an argument. The method <B>get_data_ptr </B>shall return the current value of the data pointer attribute. Note that the data pointer attribute is a pointer to the data array, and these methods set or get the value of the pointer, not the contents of the array. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">b) For a read command or a write command, the target shall copy data to or from the data array, respectively, honoring the semantics of the remaining attributes of the generic payload. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">c) The initiator is responsible for allocating storage for the data and byte enable arrays. The storage may represent the final source or destination of the data in the initiator, such as a register file or cache memory, or may represent a temporary buffer used to transfer data to and from the transaction level interface. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">d) In general, the organization of the generic payload data array is independent of the organization of local storage within the initiator and the target. However, the generic payload has been designed so that data can be copied to and from the target with a single call to memcpy in most circumstances. This assumes that the target uses the same storage organization as the generic payload. This assumption is made for simulation efficiency, but does not restrict the expressive power of the generic payload: the target is free to transform the data in any way it wishes as it copies the data to and from the data array. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">e) It is an error to call the transport interface with a transaction object having a null data pointer attribute. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">f) The length of the data array shall be greater than or equal to the value of the data length attribute, in bytes. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">g) The data pointer attribute shall be set by the initiator, and shall not be overwritten by any interconnect component or target. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">h) For a write command or TLM_IGNORE_COMMAND, the contents of the data array shall be set by the initiator, and shall not be overwritten by any interconnect component or target </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">i) For a read command, the contents of the data array may be overwritten by the target (honoring the semantics of the byte enable) but by no other component and only before the target sends a response. A target sends a response in this sense whenever it returns control from the <B>b_transport</B>, <B>get_direct_mem_ptr </B>or <B>transport_dbg </B>methods, whenever it passes the BEGIN_RESP phase as an argument to <I>nb_transport</I>, or whenever it returns the value TLM_COMPLETED from <I>nb_transport</I>. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">j) The default value of the data pointer attribute shall be 0, the null pointer. </SPAN>