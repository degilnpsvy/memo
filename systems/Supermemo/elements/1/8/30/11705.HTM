<HEAD></HEAD>
<BODY><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">8.2.3 Base protocol phase sequences </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN>
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">a) The base protocol permits the use of the blocking transport interface, the non-blocking transport interface, or both together. The blocking transport interface does not carry phase information. When used with the base protocol, the constraints governing the order of calls to <I>nb_transport </I>are stronger than those governing the order of calls to <B>b_transport</B>. Hence <I>nb_transport </I>is more for the approximately-timed coding style, and <B>b_transport </B>for the loosely-timed coding style </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">b) The full sequence of phase transitions for a given transaction through a given socket is: </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">BEGIN_REQ &#8594; END_REQ &#8594; BEGIN_RESP &#8594; END_RESP</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">c) BEGIN_REQ and END_RESP shall be sent through initiator sockets only, END_REQ and BEGIN_RESP through target sockets only. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">d) In the case of the blocking transport interface, a transaction instance is associated with a single call to and return from <B>b_transport</B>. The correspondence between the call to <B>b_transport </B>and BEGIN_REQ, and the return from <B>b_transport </B>and BEGIN_RESP, is purely notional; <B>b_transport </B>has no associated phases. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">e) For the base protocol, each call to <I>nb_transport </I>and each return from <I>nb_transport </I>with a value of TLM_UPDATED shall cause a phase transition. In other words, two consecutive calls to <I>nb_transport </I>for the same transaction shall have different values for the phase argument. Ignorable phase extensions are permitted, in which case the insertion of an extended phase shall count as a phase transition for the purposes of this rule, even if the phase is ignored. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">f) The phase sequence can be cut short by having <I>nb_transport </I>return a value of TLM_COMPLETED, but only in one of the following ways. An interconnect component or target may return TLM_COMPLETED when it receives BEGIN_REQ or END_RESP on the forward path. An interconnect component or initiator may return TLM_COMPLETED when it receives BEGIN_RESP on the backward path. A return value of TLM_COMPLETED indicates the end of the transaction with respect to a particular hop, in which case the phase argument should be ignored by the caller (see 4.1.2.7 The tlm_sync_enum return value). TLM_COMPLETED does not imply successful completion, so the initiator should check the response status of the transaction for success or failure. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"><?xml:namespace prefix = v /><v:shapetype id=_x0000_t75 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"><v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"></v:path><?xml:namespace prefix = o /><o:lock v:ext="edit" aspectratio="t"></o:lock></v:shapetype><v:shape id=_x0000_i1025 style="WIDTH: 578.25pt; HEIGHT: 400.5pt" type="#_x0000_t75"><v:imagedata src="file:///C:\DOCUME~1\DONPOP~1\LOCALS~1\Temp\msohtml1\01\clip_image001.emz" o:title=""></v:imagedata></v:shape></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">g) A transition to the phase END_RESP shall also indicate the end of the transaction with respect to a particular hop, in which case the callee is not obliged to return a value of TLM_COMPLETED. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">h) When TLM_COMPLETED is returned in an upstream direction after having received BEGIN_REQ, this carries with it an implicit END_REQ and an implicit BEGIN_RESP. Hence the initiator should check the response status of the generic payload, and may send BEGIN_REQ for the next transaction immediately. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">i) Since TLM_COMPLETED returned after having received BEGIN_REQ carries with it an implicit BEGIN_RESP, this situation is forbidden by the response exclusion rule if there is already a response in progress through a given socket. In this situation the callee should have returned TLM_ACCEPTED instead of TLM_COMPLETED and should wait for END_RESP before sending the next response upstream. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">j) Since TLM_COMPLETED returned after having received BEGIN_REQ indicates the end of the transaction, an interconnect component or initiator is forbidden from then sending END_RESP for that same transaction through that same socket. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">k) When TLM_COMPLETED is returned in a downstream direction by a component after having received BEGIN_RESP, this carries with it an implicit END_RESP. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">l) If a component receives a BEGIN_RESP from a downstream component without having first received an END_REQ for that same transaction, the initiator shall assume an implicit END_REQ immediately preceding the BEGIN_RESP. This is only the case for the same transaction; a BEGIN_RESP does not imply an END_REQ for any other transaction, and a target that receives a BEGIN_REQ cannot infer an END_RESP for the previous transaction. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">m) The above points hold regardless of the value of the timing annotation argument to <I>nb_transport</I>. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">n) A base protocol transaction is complete (with respect to a particular hop) when TLM_COMPLETED is returned on either path, or when END_RESP is sent on the forward path or the return path. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">o) In the case where END_RESP is sent on the forward path, the callee may return TLM_ACCEPTED or TLM_COMPLETED. The transaction is complete in either case. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">p) A given transaction may complete at different times on different hops. A transaction object passed to <I>nb_transport </I>is obliged to have a memory manager, and the lifetime of the transaction object ends when the reference count of the generic payload reaches zero. Any component that calls the <B>acquire </B>method of a generic payload transaction object should also call the <B>release </B>method at or before the completion of the transaction. See 7.5 Generic payload memory management </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">q) If a component receives an illegal or out-of-order phase transition, this is an error on the part of the sender. The behavior of the recipient is undefined, meaning that a run-time error may be caused. </SPAN></P></BODY>