<HEAD></HEAD>
<BODY><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">8.2.5 Ignorable phases </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN>
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Extended phases may be used with the base protocol provided that they are <I>ignorable phases</I>. An ignorable phase may be ignored by its recipient. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">a) In general, the recommended way to add extended phases to the four phases of the base protocol is to define a new protocol traits class. See 7.2.2 Define a new protocol traits class containing a typedef for tlm_generic_payload. Ignorable phases are a special and restricted case of extended phases. The main purpose of ignorable phases is to permit extra timing points to be added to the base protocol in order to increase the timing accuracy of the model. For example, an ignorable phase could mark the time of the start of the data transfer from initiator to target. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">b) In the case of a call to <I>nb_transport</I>, if it is the callee that is ignoring the phase it shall return a value of TLM_ACCEPTED. In the case that the callee returns TLM_UPDATED, the caller may ignore the phase being passed on the return path but is not obliged to take any specific action to indicate that the phase is being ignored. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">c) The <I>nb_transport </I>interface does not provide any way for the caller of <I>nb_transport </I>to distinguish between the case where the callee is ignoring the phase, and the case where the callee will respond later on the opposite path. The callee shall return TLM_ACCEPTED in either case. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">d) The presence of an ignorable phase shall not change the order or the semantics of the four phases BEGIN_REQ, END_REQ, BEGIN_RESP, and END_RESP of the base protocol, and is not permitted to result in any of the rules of the base protocol being broken. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">e) An ignorable phase shall not occur before BEGIN_REQ or after END_RESP for a given transaction through a given socket. The presence of an ignorable phase before BEGIN_REQ or after END_RESP would violate the base protocol, and is an error. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">f) The presence of an ignorable phase shall not change the rules concerning the validity of the generic payload attributes or the rules for modifying those attributes. For example, on receipt of an ignorable phase, an interconnect component is only permitted to modify the address attribute, DMI allowed attribute, and extensions. See 7.7 Default values and modifiability of attributes. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">g) With the exception of transparent components as defined below, if the recipient of an ignorable phase does not recognize that phase (that is, the phase is being ignored), the recipient shall not propagate that phase on the forward, the backward or the return path. In other words, a component is only permitted to pass a phase as an argument to an <I>nb_transport </I>call if it fully understands the semantics of that phase. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">h) If the recipient of an ignorable phase does recognize that phase, provided that the base protocol is not violated, the behavior of that component is otherwise outside the scope of the base protocol and is undefined by the base protocol</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; COLOR: black; mso-bidi-font-size: 9.0pt; mso-font-kerning: 0pt">. </SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The recipient should obey the semantics of the extended protocol to which the phase belongs. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">i) By definition, a component that sends an ignorable phase cannot require or demand any kind of response from the components to which that phase is sent other than the minimal response of <I>nb_transport </I>returning a value of TLM_ACCEPTED. A phase that demands a response is not ignorable, by definition, in which case the recommended approach is to define a new protocol traits class rather than using extensions to the base protocol. This prevents the binding of sockets that represent incompatible protocols. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">j) On the other hand, a base-protocol-compliant component that does recognize an incoming extended phase may respond by sending another extended phase on the opposite path according to the rules of some extended protocol agreed in advance. This possibility is permitted by the TLM-2.0 standard, provided that the rules of the base protocol are not broken. For example, such an extended protocol could make use of generic payload extensions. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">k) It is possible to create so-called <I>transparent </I>interconnect components, which immediately and directly pass through any TLM-2.0 interface method calls between a target socket and an initiator socket contained within the same component. The sole intent of recognizing transparent components in this standard is to allow for checkers and monitors, which typically have one target socket, one initiator socket, and pass through all transactions in both directions without modification. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">l) Within a transparent component, the implementation of any TLM-2.0 core interface method shall not consume any simulation time, insert any delay, or call <B>wait</B>, but shall immediately make the identical interface method call through the opposing socket (initiator socket to target socket or target socket to initiator socket), passing through all its arguments. Such an interface method shall not modify the value of any argument, including the transaction object, the phase and the delay, with the one exception of generic payload extensions. The routing through such transparent components shall be fixed, and not depend on transaction attributes or phases. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">m) As a consequence of the above rules, a transparent component would pass through any extended phase or ignorable phase in either direction. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"><?xml:namespace prefix = v /><v:shapetype id=_x0000_t75 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"><v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"></v:path><?xml:namespace prefix = o /><o:lock v:ext="edit" aspectratio="t"></o:lock></v:shapetype><v:shape id=_x0000_i1025 style="WIDTH: 575.25pt; HEIGHT: 408pt" type="#_x0000_t75"><v:imagedata src="file:///C:\DOCUME~1\DONPOP~1\LOCALS~1\Temp\msohtml1\01\clip_image001.emz" o:title=""></v:imagedata></v:shape></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt"><FONT face=Arial>An example of an ignorable phase generated by an initiator would be a phase to mark the first beat of the data transfer from the initiator in the case of a write command. An interconnect component or target that recognized this phase could distinguish between the time at which the command and address become </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; FONT-FAMILY: 'Times New Roman'; mso-bidi-font-size: 10.0pt">available and the start of the data transfer. A target that ignored this phase would have to use the BEGIN_REQ phase as its single timing reference for the availability of the command, address and data. An example of an ignorable phase generated by a target would be a phase to mark a split transaction. An initiator that recognized this phase could send the next request immediately upon receiving the split phase, knowing that the target would be ready to process it. An initiator that ignored the split phase might wait until it had received a response to the first request before sending the second request. </SPAN></P></BODY>