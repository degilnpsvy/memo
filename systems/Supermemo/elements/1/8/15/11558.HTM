<B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">7.19.3 Rules </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">a) The first argument to a function of the form <I>to_hostendian </I>should be a pointer to a generic payload transaction object that would be valid if it were sent through a transport interface. The function should only be called after constructing and initializing the transaction object and before passing it to an interface method call. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">b) The first argument to a function of the form <I>from_hostendian </I>shall be a pointer to a generic payload transaction object previously passed to <I>to_hostendian</I>. The function should only be called when the initiator receives a response for the given transaction or the transaction is complete. Since the function may modify the transaction and its arrays, it should only be called at the end of the lifetime of the transaction object. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">c) If a <I>to_hostendian </I>function is called for a given transaction, the corresponding from_hostendian function should also be called with the same template and function arguments. Alternatively, the function tlm_from_hostendian(tlm_generic_payload *) can be called for the given transaction. This function uses additional context information stored with the transaction object (as an ignorable extension) to recover the template and function argument values, but is marginally slower in execution. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">d) The second argument to a hostendian function should be the width of the local socket through which the transaction is passed, expressed in bytes. This is equivalent to the word length of the generic payload data array with respect to the local socket. This shall be a power of 2. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">e) The template argument to a hoste<I>ndian </I>function should be a type representing the internal initiator data word for the endianness conversion. The expression sizeof(DATAWORD) is used to determine the width of the data word in bytes, and the assignment operator of type DATAWORD is used during copying. sizeof(DATAWORD) shall be a power of 2. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">f) The implementation of <I>to_hostendian </I>adds an extension to the generic payload transaction object to store context information. This means that <I>to_hostendian </I>can only be called once before calling <I>from_hostendian</I>. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">g) The following constraints are common to every pair of <I>hostendian </I>functions. The term <I>integer multiple </I>means 1 </SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">x </SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">, 2 </SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">x </SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">, 3 </SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">x </SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">, ... and so forth: </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Socket width shall be a power of 2 </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Data word width shall be a power of 2 </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The streaming width attribute shall be an integer multiple of the data word width </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The data length attribute shall be an integer multiple of the streaming width attribute </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">h) The hostendi<I>an_generic </I>functions are not subject to any further specific constraints. In particular, they support byte enables, streaming, and non-aligned addresses and word widths. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">i) The remaining pairs of functions, namely <I>hostendian_word</I>, <I>hostendian_aligned</I>, and <I>hostendian_single</I>, all share the following additional constraints: </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Data word width shall be no greater than socket width, and as a consequence, socket width shall be a power-of-2 multiple of data word width. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The streaming width attribute shall equal the data length attribute. That is, streaming is not supported. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Byte enable granularity shall be no finer than data word width. That is, the bytes in a given data word shall be either all enabled or all disabled. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">If byte enables are present, the byte enable length attribute shall equal the data length attribute. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">j) The hostendian_aligned functions alone are subject to the following additional constraints: </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The address attribute shall be an integer multiple of the socket width. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The data length attribute shall be an integer multiple of the socket width. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">k) The hostendian_single functions alone are subject to the following additional constraints: </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The data length attribute shall equal the data word width. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The data array shall not cross a data word boundary, and as a consequence, shall not cross a socket boundary.</SPAN>