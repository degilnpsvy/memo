<B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">7.19.1 Introduction </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN>
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The rules governing the organization of the generic payload data array are well-defined, and in many simple cases, writing host-independent C++ code to create and interpret the data array is a straightforward task. However, the rules do depend on the relationship between the endianness of the modeled component and host endianness, so creating host-independent code can become quite complex in cases involving non-aligned addressing and data word widths that differ from the socket width. A set of helper functions is provided to assist with this task. With respect to endianness, interoperability depends only on the endianness rules being followed. Use of the helper functions is not necessary for interoperability. The motivation behind the endianness conversion functions is to permit the C++ code that creates a generic payload transaction for an initiator to be written once with little regard for host endianness, and then to have the transaction converted to match host endianness with a single function call. Each conversion function takes an existing generic payload transaction and modifies that transaction in-place. The conversion functions are organised in pairs, a <I>to_hostendian </I>function and a <I>from_hostendian </I>function, which should always be used together. The <I>to_hostendian </I>function should be called by an initiator before sending a transaction through a transport interface, and <I>from_hostendian </I>on receiving back the response. Four pairs of functions are provided, the <I>_generic </I>pair being the most general and powerful, and the <I>_word</I>, <I>_aligned </I>and <I>_single </I>functions being variants that can only handle restricted cases. The transformation performed by the <I>_generic </I>functions is relatively computationally expensive, so the other functions should be preferred for efficiency wherever possible. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The conversion functions provide sufficient flexibility to handle many common cases, including both <I>arithmetic mode </I>and <I>byte order mode</I>. <I>Arithmetic mode </I>is where a component stores data words in host-endian format for efficiency when performing arithmetic operations, regardless of the endianness of the component being modeled. <I>Byte order mode </I>is where a component stores bytes in an array in ascending address order, disregarding host endianness. The use of arithmetic mode is recommended for simulation speed. Byte order mode may necessitate byte swapping when copying data to and from the generic payload data array. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The conversion functions use the concept of a <I>data word</I>. The data word is independent of both the TLM-2.0 socket width and the word width of the generic payload data array. The data word is intended to represent a register that stores bytes in host-endian order within the component model (regardless of the endianness of the component being modeled). If the data word width is different to the socket width, the <I>hostendian </I>functions may have to perform an endianness conversion. If the data word is just one byte wide, the <I>hostendian </I>functions will effectively perform a conversion from and to <I>byte order mode</I>. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">In summary, the approach to be taken with the <I>hostendian </I>conversion functions is to write the initiator code <I>as if </I>the endianness of the host computer matched the endianness of the component being modeled, while keeping the bytes within each data word in actual host-endian order. For data words wider than the host machine word length, use an array in host-endian order. Then if host endianness differs from modeled endianness, simply call the <I>hostendian </I>conversion functions.</SPAN>