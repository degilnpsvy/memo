<HEAD></HEAD>
<BODY><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">7.17.2 Rules </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN>
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">a) In the following rules, the generic payload data array is denoted as <B>data </B>and the generic payload byte enable array as <B>be</B>. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">b) When using the standard socket classes of the interoperability layer (or classes derived from these), the contents of the data and byte enable arrays shall be interpreted using the BUSWIDTH template parameter of the socket through which the transaction is sent or received locally. The effective word length shall be calculated as (BUSWIDTH + 7)/8 bytes, and in the following rules is denoted as <B>W</B>. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><FONT face=Arial><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">c) This quantity <B>W </B>defines the length of a <I>word </I>within the data array, each word being the amount of data that could be transferred through the local socket on a single beat. The data array may contain a single word, a part-word, or several contiguous words or part-words. Only the first and last words in the data </SPAN><SPAN lang=EN-US style="FONT-SIZE: 17pt; FONT-FAMILY: 'Times New Roman'; mso-bidi-font-size: 12.0pt"></SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">array may be part-words. This description refers to the internal organization of the generic payload, not to the organization of the architecture being modeled. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">d) If a given generic payload transaction object is passed through sockets of different widths, the data array word length would appear different when calculated from the point of view of different sockets (see the description of width conversion below). </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">e) The order of the bytes within each word of the data array shall be host-endian. That is, on a little-endian host processor, within any given word <B>data[n] </B>shall be less significant than <B>data[n+1]</B>, and on a big-endian host processor, <B>data[n] </B>shall be the more significant than <B>data[n+1]</B>. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">f) The word boundaries in the data array shall be address-aligned, that is, they shall fall on addresses that are integer multiples of the word length <B>W</B>. However, neither the address attribute nor the data length attribute are required to be multiples of the word length. Hence the possibility that the first and last words in the data array could be part-words. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">g) The order of the words within the data array shall be determined by their addresses in the memory map of the modeled system. For array index values less than the value of the streaming width attribute, the local addresses of successive words shall be in increasing order, and (excluding any leading part-word) shall equal <B>address_attribute - (address_attribute % W) + NW</B>, where <B>N </B>is a non-negative integer, and <B>% </B>indicates remainder on division. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">h) In other words, using the notation {a,b,c,d} to list the elements of the data array in increasing order of array index, and using LSB</SPAN><SPAN lang=EN-US style="FONT-SIZE: 11.5pt; COLOR: black; mso-bidi-font-size: 6.5pt; mso-font-kerning: 0pt">N </SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">to denote the least significant byte of the Nth word, on a little-endian host bytes are stored in the order {..., MSB</SPAN><SPAN lang=EN-US style="FONT-SIZE: 11.5pt; COLOR: black; mso-bidi-font-size: 6.5pt; mso-font-kerning: 0pt">0</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">, LSB</SPAN><SPAN lang=EN-US style="FONT-SIZE: 11.5pt; COLOR: black; mso-bidi-font-size: 6.5pt; mso-font-kerning: 0pt">1</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">, ..., MSB</SPAN><SPAN lang=EN-US style="FONT-SIZE: 11.5pt; COLOR: black; mso-bidi-font-size: 6.5pt; mso-font-kerning: 0pt">1</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">, LSB</SPAN><SPAN lang=EN-US style="FONT-SIZE: 11.5pt; COLOR: black; mso-bidi-font-size: 6.5pt; mso-font-kerning: 0pt">2</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">, ...}, and on a big-endian host {... LSB</SPAN><SPAN lang=EN-US style="FONT-SIZE: 11.5pt; COLOR: black; mso-bidi-font-size: 6.5pt; mso-font-kerning: 0pt">0</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">, MSB</SPAN><SPAN lang=EN-US style="FONT-SIZE: 11.5pt; COLOR: black; mso-bidi-font-size: 6.5pt; mso-font-kerning: 0pt">1</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">, ... LSB</SPAN><SPAN lang=EN-US style="FONT-SIZE: 11.5pt; COLOR: black; mso-bidi-font-size: 6.5pt; mso-font-kerning: 0pt">1</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">, MSB</SPAN><SPAN lang=EN-US style="FONT-SIZE: 11.5pt; COLOR: black; mso-bidi-font-size: 6.5pt; mso-font-kerning: 0pt">2</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">, ...}, where the number of bytes in each full word is given by <B>W</B>, and the total number of bytes is given by the <B>data_length </B>attribute. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">i) The above rules effectively mean that initiators and targets are connected LSB-to-LSB, MSB-to-MSB. The rules have been chosen to give optimal simulation speed in the case where the majority of initiators and targets are modeled using host endianness whatever their native endianness, also known as &#8213;arithmetic mode</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: &#23435;&#20307;; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: &#23435;&#20307;">&#8214;</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">j) It is strongly recommended that applications should be independent of host endianness, that is, should model the same behavior when run on a host of either endianness. This may require the use of helper functions or conditional compilation. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">k) If an initiator or target is modeled using its native endianness and that is different from host endianness, it will be necessary to swap the order of bytes within a word when transferring data to or from the generic payload data array. Helper functions are provided for this purpose. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">l) For example, consider the following SystemC code fragment, which uses the literal value 0xAABBCCDD to initialize the generic payload data array: </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">int data = 0xAABBCCDD; </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">trans.set_data_ptr( reinterpret_cast&lt;unsigned char*&gt;( &amp;data ) ); </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">trans.set_data_length(4); </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">trans.set_address(0); </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">socket-&gt;b_transport(trans, delay);</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 17pt; COLOR: black; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt">&nbsp;</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">m) The C++ compiler will interpret the literal 0xAABBCCDD in host-endian form. In either case, the MSB has value 0xAA and the LSB has value 0xDD. Assuming this is the intent, the code fragment is valid and is independent of host endianness. However, the array index of the four bytes will differ depending on host endianness. On a little-endian host, data[0] = 0xDD, and on a big-endian host, data[0] = 0xAA. The correspondence between local addresses in the modeled system and array indexes will differ depending whether modeled endianess and host endianness are equal: </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Little-endian model and little-endian host: data[0] is 0xDD and local address 0 </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Big-endian model and little-endian host: data[0] is 0xDD and local address 3 </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Little-endian model and big-endian host: data[0] is 0xAA and local address 3 </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Big-endian model and big-endian host: data[0] is 0xAA and local address 0 </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">n) Code such as the fragment shown above would not be portable to a host computer that uses neither little nor big endianness. In such a case, the code would have to be re-written to access the generic payload data array using byte addressing only. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">o) When a little-endian and a big-endian model interpret a given generic payload transaction, then by definition they will agree on which is the MSB and LSB of a word, but they will each use different local addresses to access the bytes of the word. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">p) Neither the data length attribute nor the address attribute are required to be integer multiples of <B>W</B>. However, having address and data length aligned with word boundaries and having <B>W </B>be a power of 2 considerably simplifies access to the data array. Just to emphasize the point, it would be perfectly in order for a generic payload transaction to have an address and data length that indicated three bytes in the middle of a 48-bit socket. If a particular target is unable to support a given address attribute or data length, it should generate a standard error response. See 7.16 Response status attribute </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">q) For example, on a little-endian host and with <B>W = 4</B>, <B>address = 1</B>, and <B>data_length = </B>4, the first word would contain 3 bytes at addresses 1...3, and the second word 1 byte at address 4. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">r) Single byte and part-word transfers may be expressed using non-aligned addressing. For example, given <B>W </B>= 8, address = 5, and <B>data </B>= {1,2}, the two bytes with local addresses 5 and 6 are accessed in an order dependent on endianness. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">s) Part-word and non-aligned transfers can always be expressed using integer multiples of <B>W </B>together with byte enables. This implies that a given transaction may have several equally valid generic payload representations. For example, given a little-endian host and a little-endian initiator, </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">address = 2, W = 4, data = {1} is equivalent to </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">address = 0, W = 4, data = {x, x, 1, x}, and be = {0, 0, 0xff, 0} </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">address = 2, W = 4, data = {1,2,3,4} is equivalent to </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">address = 0, W = 4, data = {x, x, 1, 2, 3, 4, x, x}, and be = {0, 0, 0xff, 0xff, 0xff, 0xff, 0, 0}. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">t) For part-word access, the necessity to use byte enables is dependent on endianness. For example, given the intent to access the whole of the first word and the LSB of the second word, given a little-endian host this might be expressed as </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">address = 0, W = 4, data = {1,2,3,4,5} </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Given a big-endian host, the equivalent would be address = 0, W = 4, data = {4,3,2,1,x,x,x,5}, be = {0xff, 0xff, 0xff, 0xff, 0, 0, 0, 0xff }. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">u) When two sockets are bound together, they necessarily have the same BUSWIDTH. However, a transaction may be forwarded from a target socket to an initiator socket of a different bus width. In this case, width conversion of the generic payload transaction must be considered. Any width conversion has its own intrinsic endianness, depending on whether the least- or most significant byte of the wider socket is picked out first. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"><?xml:namespace prefix = v /><v:shapetype id=_x0000_t75 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"><v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"></v:path><?xml:namespace prefix = o /><o:lock v:ext="edit" aspectratio="t"></o:lock></v:shapetype><v:shape id=_x0000_i1025 style="WIDTH: 575.25pt; HEIGHT: 423pt" type="#_x0000_t75"><v:imagedata src="file:///C:\DOCUME~1\DONPOP~1\LOCALS~1\Temp\msohtml1\01\clip_image001.emz" o:title=""></v:imagedata></v:shape></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 17pt; COLOR: black; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt">&nbsp;</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">v) When the endianness chosen for a width conversion matches the host endianness, the width conversion is effectively free, meaning that a single transaction object can be forwarded from socket-to-socket without modification. Otherwise, two separate generic payload transaction objects would be required. In figure 12, the width conversion between the 4-byte socket and the 2-byte socket uses host-endianness, moving the less-significant bytes to lower addresses whilst retaining the host-endian byte order within each word. The initiator and target both access the same sequence of bytes in the data array, but their local addressing schemes are quite different. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">w) If a width conversion is performed from a narrower socket to a wider socket, the choice has to be made as to whether or not to perform address alignment on the outgoing transaction. Performing address alignment will always necessitate the construction of a new generic payload transaction object. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">x) Similar width conversion issues arise when the streaming width attribute is non-zero but different from <B>W</B>. A choice has to be made as to the order in which to read off the bytes down the data array depending on host endianness and the desired endianness of the width conversion. </SPAN></P></BODY>