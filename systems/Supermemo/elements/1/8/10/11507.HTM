<B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">4.3.1 Introduction </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The debug transport interface provides a means to read and write to storage in a target, over the same forward path from initiator to target as is used by the transport interface, but without any of the delays, waits, event notifications or side effects associated with a regular transaction. In other words, the debug transport interface is non-intrusive. Because the debug transport interface follows the same path as the transport interface, the implementation of the debug transport interface can perform the same address translation as for regular transactions. For example, the debug transport interface could permit a software debugger attached to an ISS to peek or poke an address in the memory of the simulated system from the point of view of the simulated CPU. The debug transport interface could also allow an initiator to take a snapshot of system memory contents during simulation for diagnostic purposes, or to initialize some area of system memory at the end of elaboration. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The default debug transaction type is <B>tlm_generic_payload</B>, where only the command, address, data length and data pointer attributes of the transaction object are used. Debug transactions follow the same approach to extension as the transport interface, that is, a debug transaction may contain ignorable extensions, but any non-ignorable or mandatory extension requires the definition of a new protocol traits class (see 7.2.2 Define a new protocol traits class containing a typedef for tlm_generic_payload). </SPAN>