<B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">4.2.5 tlm_dmi class </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">a) A DMI descriptor is an object of class <B>tlm_dmi</B>. DMI descriptors shall be constructed by initiators, but their members may be set by interconnect components or targets. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">b) A DMI descriptor shall have the following attributes: the DMI pointer attribute, the granted access type attribute, the start address attribute, the end address attribute, the read latency attribute, and the write latency attribute. The default values of these attributes shall be as follows: DMI pointer attribute = 0, access type = DMI_ACCESS_NONE, start address = 0, end address = the maximum value of type <B>sc_dt::uint64, </B>read latency = SC_ZERO_TIME, and write latency = SC_ZERO_TIME. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">c) Method <B>init </B>shall initialize the members of the DMI descriptor to their default values. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">d) A DMI descriptor shall be in its default state whenever it is passed as an argument to <B>get_direct_mem_ptr </B>by the initiator. If DMI descriptor objects are pooled, the initiator shall reset the DMI descriptor to its default state before passing it as an argument to <B>get_direct_mem_ptr</B>. Method <B>init </B>may be called for this purpose. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">e) Since an interconnect component is not permitted to modify the DMI descriptor as it is passed on towards the target, the DMI descriptor shall be in its initial state when it is received by the target. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">f) The method <B>set_dmi_ptr </B>shall set the DMI pointer attribute to the value passed as an argument. The method <B>get_dmi_ptr </B>shall return the current value of the DMI pointer attribute </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">g) The DMI pointer attribute shall be set by the target to point to the storage location corresponding to the value of the start address attribute. This shall be less than or equal to the address requested in the call to <B>get_direct_mem_ptr</B>. The initial value shall be 0. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">h) The storage in the DMI region is represented with type <B>unsigned char*</B>. The storage shall have the same organization as the data array of the generic payload. If a target is unable to return a pointer to a memory region with that organization, the target is unable to support DMI and <B>get_direct_mem_ptr </B>should return the value false. For a full description of how memory organization and endianness are handled in TLM-2.0, see 7.17 Endianness </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">i) An interconnect component is permitted to modify the DMI pointer attribute on the return path from the <B>get_direct_mem_ptr </B>function call in order to restrict the region to which DMI access is being granted. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">j) The method <B>set_granted_access </B>shall set the granted access type attribute to the value passed as an argument. The method <B>get_granted_access </B>shall return the current value of the granted access type attribute. The initial value shall be DMI_ACCESS_NONE. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">k) The methods <B>allow_none</B>, <B>allow_read</B>, <B>allow_write </B>and <B>allow_read_write </B>shall set the granted access type attribute to the value DMI_ACCESS_NONE, DMI_ACCESS_READ, DMI_ACCESS_WRITE or DMI_ACCESS_READ_WRITE respectively. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">l) The method is_none_allowed shall return true if and only if the granted access type attribute has the value DMI_ACCESS_NONE. The method is_read_allowed shall return true if and only if the granted access type attribute has the value DMI_ACCESS_READ or DMI_ACCESS_READ_WRITE. The method is_write_allowed shall return true if and only if the granted access type attribute has the value DMI_ACCESS_WRITE or DMI_ACCESS_READ_WRITE. The method is_read_write_allowed shall return true if and only if the granted access type attribute has the value DMI_ACCESS_READ_WRITE. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">m) The target shall set the granted access type attribute to the type of access being granted or being denied. A target is permitted to respond to a request for read access by granting (or denying) read or read/write access, and to a request for write access by granting (or denying) write or read/write access. An interconnect component is permitted to restrict the granted access type by overwriting a value of DMI_ACCESS_READ_WRITE with DMI_ACCESS_READ or DMI_ACCESS_WRITE on the return path from the get_direct_mem_ptr function call. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">n) A target wishing to deny read and write access to the DMI region should set the granted access type to DMI_ACCESS_READ_WRITE, not to DMI_ACCESS_NONE. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Example </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">bool get_direct_mem_ptr( TRANS&amp; trans, tlm::tlm_dmi&amp; dmi_data ) { <I>// Deny DMI access to entire memory region </I>dmi_data.allow_read_write(); dmi_data.set_start_address( 0x0 ); dmi_data.set_end_address( (sc_dt::uint64)-1 ); return false; } </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">o) The target should set the granted access type to DMI_ACCESS_NONE to indicate that it is not granting (or denying) read, write, or read/write access to the initiator, but is granting (or denying) some other kind of access as requested by an extension to the DMI transaction object. This value should only be used in cases where an extension to the DMI transaction object makes the pre-defined access types read, write and read/write unnecessary or meaningless. This value should not be used in the case of the base protocol. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">p) The initiator is responsible for using only those modes of DMI access which have been granted by the target (and possibly modified by the interconnect) using the granted access type attribute (or in cases other than the base protocol, granted using extensions to the generic payload or using other DMI transaction types). </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">q) The methods <B>set_start_address </B>and <B>set_end_address </B>shall set the start and end address attributes, respectively, to the values passed as arguments. The methods <B>get_start_address </B>and <B>get_end_address </B>shall return the current values of the start and end address attributes, respectively. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">r) The start and end address attributes shall be set by the target (or modified by the interconnect) to point to the addresses of the first and the last bytes in the DMI region. The DMI region is either being granted or being denied, as determined by the value returned from the <B>get_direct_mem_ptr </B>method (<B>true </B>or <B>false</B>). A target wishing to deny access to its entire memory region may set the start address to 0 and the end address to the maximum value of type sc_dt::uint64. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">s) A target can only grant or deny a single contiguous memory region for each get_direct_mem_ptr call. A target can set the DMI region to a single address by having the start and end address attributes be equal, or can set the DMI region to be arbitrarily large. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">t) Having been granted DMI access of a given type to a given region, an initiator may perform access of the given type anywhere in that region until it is invalidated. In other words, access is not restricted to the address given in the DMI request. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">u) Any interconnect components that pass on the <B>get_direct_mem_ptr </B>call are obliged to transform the start and end address attributes as they do the address argument. Any transformations on the addresses in the DMI descriptor shall occur as the descriptor is passed along the return path from the <B>get_direct_mem_ptr </B>function call. For example, the target may set the start address attribute to a relative address within the memory map known to that target, in which case the interconnect component is obliged to transform the relative address back to an absolute address in the system memory map. The initial values shall be 0 and the maximum value of type <B>sc_dt::uint64</B>, respectively. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">v) An interconnect component is permitted to modify the start and end address attributes in order to restrict the region to which DMI access is being granted, or expand the range to which DMI access is being denied. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">w) If <B>get_direct_mem_ptr </B>returns the value <B>true</B>, the DMI region indicated by the start and end address attributes is a region for which DMI access is allowed. On the other hand, if <B>get_direct_mem_ptr </B>return the value <B>false, </B>it is a region for which DMI access is disallowed. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">x) A target or interconnect component receiving two or more calls to <B>get_direct_mem_ptr </B>may return two or more overlapping allowed DMI regions or two or more overlapping disallowed DMI regions. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">y) A target or interconnect component shall not return overlapping DMI regions where one region is allowed and the other is disallowed for the same access type, for example both read or read/write or both write or read/write, without making an intervening call to <B>invalidate_direct_mem_ptr </B>to invalidate the first region. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">z) In other words, the definition of the DMI regions shall not be dependent upon the order in which they were created unless the first region is invalidated by an intervening call to <B>invalidate_direct_mem_ptr</B>. Specifically, the creation of a disallowed DMI region shall not be permitted to punch a hole in an existing allowed DMI region for the same access type, or vice versa. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">aa) A target may disallow DMI access to the entire address space (start address attribute = 0, end address attribute = maximum value), perhaps because the target does not support DMI access at all, in which case an interconnect component should clip this disallowed region down to the part of the memory map occupied by the target. Otherwise, if an interconnect component fails to clip the address range, then an initiator would be misled into thinking that DMI was disallowed across the entire system address space. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">bb) The methods <B>set_read_latency </B>and <B>set_write_latency </B>shall set the read and write latency attributes, respectively, to the values passed as arguments. The methods <B>get_read_latency </B>and <B>get_write_latency </B>shall return the current values of the read and write latency attributes, respectively. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">cc) The read and write latency attributes shall be set to the average latency per byte for read and write memory transactions, respectively. In other words, the initiator performing the direct memory operation shall calculate the actual latency by multiplying the read or write latency from the DMI descriptor by the number of bytes that would have been transferred by the equivalent transport transaction. The initial values shall be SC_ZERO_TIME. Both interconnect components and the target may increase the value of either latency such that the latency accumulates as the DMI descriptor is passed back from target to initiator on return from the get_direct_mem_ptr method. One or both latencies will be valid, depending on the value of the granted access type attribute. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">dd) The initiator is responsible for respecting the latencies whenever it accesses memory using the direct memory pointer. If the initiator chooses to ignore the latencies, this may result in timing inaccuracies. </SPAN>