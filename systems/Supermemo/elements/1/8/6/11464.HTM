<P class=Default style="MARGIN: 0cm 0cm 0pt"><FONT face=Arial><B><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.0pt">4.1 Transport interfaces </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.0pt"></SPAN></FONT></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15pt; FONT-FAMILY: 'Times New Roman'; mso-bidi-font-size: 10.0pt">The transport interfaces are the primary interfaces used to transport transactions between initiators, targets and interconnect components. Both the blocking and non-blocking transport interfaces support timing annotation and temporal decoupling, but only non-blocking transport supports multiple phases within the lifetime of a transaction. Blocking transport does not have an explicit phase argument, and any association between blocking transport and the phases of the non-blocking transport interface is purely notional. Only the non-blocking transport method returns a value indicating whether or not the return path was used. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15pt; FONT-FAMILY: 'Times New Roman'; mso-bidi-font-size: 10.0pt">The transport interfaces and the generic payload were designed to be used together for the fast, abstract modeling of memory-mapped buses. The transport interface templates are specialized with the transaction type allowing them to be used separately from the generic payload, although many of the interoperability benefits would be lost. The rules governing memory management of the transaction object, transaction ordering, and the permitted function calling sequence depend on the specific transaction type passed as a template argument to the transport interface, which in turn depends on the protocol traits class passed as a template argument to the socket (if a socket is used). </SPAN>