<HEAD></HEAD>
<BODY><B><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 11.0pt; mso-font-kerning: 0pt">3.4 Initiators, targets, sockets, and transaction bridges </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 11.0pt; mso-font-kerning: 0pt"></SPAN>
<P></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15pt; FONT-FAMILY: 'Times New Roman'; mso-bidi-font-size: 10.0pt">The TLM-2.0 core interfaces pass transactions between initiators and targets. An initiator is a module that can initiate transactions, that is, create new transaction objects and pass them on by calling a method of one of the core interfaces. A target is a module that acts as the final destination for a transaction. In the case of a write</SPAN><SPAN lang=EN-US style="FONT-SIZE: 20pt; mso-bidi-font-size: 10.0pt"></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt"><?xml:namespace prefix = v /><v:shapetype id=_x0000_t75 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"><v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"></v:path><?xml:namespace prefix = o /><o:lock v:ext="edit" aspectratio="t"></o:lock></v:shapetype><v:shape id=_x0000_i1025 style="WIDTH: 599.25pt; HEIGHT: 381pt" type="#_x0000_t75"><v:imagedata src="file:///C:\DOCUME~1\DONPOP~1\LOCALS~1\Temp\msohtml1\01\clip_image001.emz" o:title=""></v:imagedata></v:shape></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15pt; FONT-FAMILY: 'Times New Roman'; mso-bidi-font-size: 10.0pt">transaction, an initiator (such as a processor) writes data to a target (such as a memory). In the case of a read transaction, an initiator reads data from a target. An interconnect component is a module that accesses a transaction but does not act as an initiator or a target for that transaction, typical examples being arbiters and routers. The roles of initiator, interconnect and target can change dynamically. For example, a given component may act as an interconnect for some transactions but as a target for other transactions. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">In order to illustrate the idea, this paragraph will describe the lifetime of a typical transaction object. The transaction object is created by an initiator and passed as an argument of a method of the transport interface (blocking or non-blocking). That method is implemented by an interconnect component such as an arbiter, which may read attributes of the transaction object before passing it on to a further transport call. That second transport method is implemented by a second interconnect component, such as a router, which in turn passes on the transaction through a third transport call to a target such as a memory, the final destination for the transaction object. (The actual number of interconnect components will vary from transaction to transaction. There may be none.) This sequence of method calls is known as the <I>forward path</I>. The transaction is executed in the target, and the transaction object may be returned to the initiator in one of two ways, either carried with the return from the transport method calls as they unwind, known as the <I>return path</I>, or passed by making explicit transport method calls on the opposite path from target back to initiator, known as the <I>backward path</I>. This choice is determined by the return value from the non-blocking transport method. (Strictly speaking there are two return paths corresponding to the forward and backward paths, but the meaning is usually clear from the context.)</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt"><v:shape id=_x0000_i1026 style="WIDTH: 821.25pt; HEIGHT: 526.5pt" type="#_x0000_t75"><v:imagedata src="file:///C:\DOCUME~1\DONPOP~1\LOCALS~1\Temp\msohtml1\01\clip_image003.emz" o:title=""></v:imagedata></v:shape></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The forward path is the calling path by which an initiator or interconnect component makes interface method calls forward in the direction of another interconnect component or the target. The backward path is the calling path by which a target or interconnect component makes interface method calls back in the direction of another interconnect component or the initiator. The entire path between an initiator and a target consists of a number of <I>hops</I>, each hop connecting two adjacent components. The number of hops from initiator to target is one greater than the number of interconnect components on that path. When using the generic payload, the forward and backward paths should always pass through the same set of components and sockets, obviously in reverse order.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">In order to support both forward and backward paths, each connection between components requires a port and an export, both of which have to be bound. This is facilitated by the <I>initiator socket </I>and the <I>target socket</I>. An initiator socket provides a port for interface method calls on the forward path and an export for interface method calls on the backward path. A target socket provides the opposite. (More specifically, an initiator socket is derived from class <B>sc_port </B>and <I>has </I>an <B>sc_export</B>, and vice versa for a target socket.) The initiator and target socket classes overload the SystemC port binding operator to implicitly bind both forward and backward paths. As well as the transport interfaces, the sockets also encapsulate the DMI and debug transport interfaces (see below). When using sockets, an initiator component will have at least one initiator socket, a target component at least one target socket, and an interconnect component at least one of each. A component may have several sockets transporting different transaction types, in which case a single component may act as initiator or target for multiple independent transactions. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">In order to model a bus bridge there are two alternatives. Either model the bus bridge as an interconnect component, or model the bus bridge as a transaction bridge between two separate TLM-2.0 transactions. An interconnect component would pass on a pointer to a single transaction object, which is the best approach for simulation speed. A transaction bridge would require the transaction object to be copied, which gives much more flexibility because the two transactions could have different attributes. The use of TLM-2.0 sockets is recommended for maximal interoperability, convenience, and a consistent coding style. Whilst it is possible for components to use SystemC ports and exports directly with the TLM-2.0 core interfaces, this is not recommended. </SPAN></P></BODY>