<B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">6.2.4 Classes tlm_base_initiator_socket and tlm_base_target_socket </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">a) For class <B>tlm_base_initiator_socket</B>, the constructor with a name argument shall pass the character string argument to the constructor belonging to the base class <B>sc_port </B>to set the string name of the instance in the module hierarchy, and shall also pass the same character string to set the string name of the corresponding <B>sc_export </B>on the backward path, adding the suffix <B>&#8220;_export&#8221; </B>and calling <B>sc_gen_unique_name </B>to avoid name clashes. For example, the call <B>tlm_initiator_socket(&#8220;foo&#8221;) </B>would set the port name to <B>&#8220;foo&#8221; </B>and the export name to <B>&#8220;foo_export&#8221;</B>. In the case of the default constructor, the names shall be created by calling <B>sc_gen_unique_name("tlm_base_initiator_socket") </B>for the port, and <B>sc_gen_unique_name("tlm_base_initiator_socket_export") </B>for the export. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><FONT face=Arial><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">b) For class <B>tlm_base_target_socket</B>, the constructor with a name argument shall pass the character string argument to the constructor belonging to the base class <B>sc_export </B>to set the string name of the instance in the module hierarchy, and shall also pass the same character string to set the string name of the corresponding <B>sc_port </B>on the backward path, adding the suffix <B>&#8220;_port&#8221; </B>and calling <B>sc_gen_unique_name </B>to avoid name clashes. For example, the call <B>tlm_target_socket(&#8220;foo&#8221;) </B>would set the export name to <B>&#8220;foo&#8221; </B>and the port name to <B>&#8220;foo_port&#8221;</B>. In the case of the default constructor, the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 17pt; FONT-FAMILY: 'Times New Roman'; mso-bidi-font-size: 12.0pt"></SPAN></FONT></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">names shall be created by calling <B>sc_gen_unique_name("tlm_base_target_socket") </B>for the export, and <B>sc_gen_unique_name("tlm_base_target_socket_port") </B>for the port. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">c) The method <B>kind </B>shall return the class name as a C string, that is, &#8213;tlm_base_initiator_socket</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: &#23435;&#20307;; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: &#23435;&#20307;">&#8214;</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"> or &#8213;tlm_base_target_socket</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: &#23435;&#20307;; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: &#23435;&#20307;">&#8214;</SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"> respectively. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">d) The method <B>get_bus_width </B>shall return the value of the BUSWIDTH template argument. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">e) Template argument BUSWIDTH shall determine the word length for each individual data word transferred through the socket, expressed as the number of bits in each word. For a burst transfer, BUSWIDTH shall determine the number of bits in each beat of the burst. The precise interpretation of this attribute shall depend on the transaction type. For the meaning of BUSWIDTH with the generic payload, see 7.11 Data length attribute. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">f) When binding socket-to-socket, the two sockets shall have identical values for the BUSWIDTH template argument. Executable code in the initiator or target may get and act on the BUSWIDTH. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">g) Each of the methods <B>bind </B>and <B>operator() </B>that take a socket as an argument shall bind the socket instance to which the method belongs to the socket instance passed as an argument to the method. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">h) Each of the methods <B>bind </B>and <B>operator() </B>that take an interface as an argument shall bind the export of the socket instance to which the method belongs to the channel instance passed as an argument to the method. (A channel is the SystemC term for a class that implements an interface.) </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">i) When binding initiator socket to target socket, the <B>bind </B>method and <B>operator() </B>shall each bind the port of the initiator socket to the export of the target socket, and the port of the target socket to the export of the initiator socket. This is for use when binding socket-to-socket at the same level in the hierarchy. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">j) An initiator socket can be bound to a target socket by calling the <B>bind </B>method or <B>operator() </B>of either socket, with precisely the same effect. In either case, the forward path lies in the direction from the initiator socket to the target socket. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">k) When binding initiator socket to initiator socket or target socket to target socket, the <B>bind </B>method and <B>operator() </B>shall each bind the port of one socket to the port of the other socket, and the export of one socket to the export of the other socket. This is for use in hierarchical binding, that is, when binding a socket on a child module to a socket on a parent module, or a socket on a parent module to a socket on a child module, passing transactions up or down the module hierarchy. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">l) For hierarchical binding, it is necessary to bind sockets in the correct order. When binding initiator socket to initiator socket, the socket of the child must be bound to the socket of the parent. When binding target socket to target socket, the socket of the parent must be bound to the socket of the child. This rule is consistent with the fact the <B>tlm_base_initiator_socket </B>is derived from <B>sc_port</B>, and <B>tlm_base_target_socket </B>from <B>sc_export</B>. Port must be bound to port going up the hierarchy, port-to-export across the top, and export-to-export going down the hierarchy. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">m) In order for two sockets of classes <B>tlm_base_initiator_socket </B>and <B>tlm_base_target_socket </B>to be bound together, they must share the same forward and backward interface types and bus widths </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">n) The method size of the target socket shall call method size of the port in the target socket (on the backward path), and shall return the value returned by size of the port. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">o) The method operator-&gt; of the target socket shall call method operator-&gt; of the port in the target socket (on the backward path), and shall return the value returned by operator-&gt; of the port. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">p) The method operator[] of the target socket shall call method operator[] of the port in the target socket (on the backward path) with the same argument, and shall return the value returned by operator[] of the port. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">q) Class <B>tlm_base_initiator_socket </B>and class <B>tlm_base_target_socket </B>each act as multi-sockets, that is, a single initiator socket may be bound to multiple target sockets, and a single target socket may be bound to multiple initiator sockets. The two class templates have template parameters specifying the number of bindings and the port binding policy, which are used within the class implementation to parameterize the associated <B>sc_port </B>template instantiation. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">r) If an object of class <B>tlm_base_initiator_socket </B>or <B>tlm_base_target_socket </B>is bound multiple times, then the method <B>operator[] </B>can be used to address the corresponding object to which the socket is bound. The index value is determined by the order in which the methods <B>bind </B>or <B>operator() </B>were called to bind the sockets. However, any incoming interface method calls received by such a socket will be <I>anonymous </I>in the sense that there is no mechanism provided to identify the caller. On the other hand, such a mechanism is provided by the convenience sockets. See 9.1.4 Multi-sockets. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">s) For example, consider a socket bound to two separate targets. The calls <B>socket[0]-&gt;nb_transport_fw(...) </B>and <B>socket[1]-&gt;nb_transport_fw() </B>would address the two targets, but there is no way to identify the caller of in incoming <B>nb_transport_bw() </B>method from one of those two targets. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">t) The implementations of the virtual methods <B>get_base_port </B>and <B>get_base_export </B>shall return the port and export objects of the socket, respectively. The implementation of the virtual method <B>get_base_interface </B>shall return the export object in the case of the initiator port, or the socket object itself in the case of the target socket. </SPAN>