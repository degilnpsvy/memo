<B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">7.2.2 Define a new protocol traits class containing a typedef for tlm_generic_payload </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">a) In this case, the transaction type is <B>tlm_generic_payload </B>and the phase type <B>tlm_phase</B>, but the protocol traits class used to specialize the socket is a new application-defined class, not the default <B>tlm_base_protocol_types</B>. This ensures that the extended generic payload is treated as a distinct type, and provides compile-time type checking when the initiator and target sockets are bound. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">b) The new protocol type may set its own rules, and these rules may extend or contradict any of the rules of the base protocol, including the generic payload memory management rules (see 7.5 Generic payload memory management) and the rules for the modifiability of attributes (see 7.7 Default values and modifiability of attributes). However, for the sake of consistency and interoperability it is recommended to follow the rules and coding style of the base protocol as far as possible. See 8.2 Base protocol </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">c) The generic payload extension mechanism may be used for ignorable, non-ignorable or mandatory extensions with no restrictions. The semantics of any extensions should be thoroughly documented with the new protocol traits class. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">d) Because the transaction type is <B>tlm_generic_payload</B>, the transaction can be transported through interconnect components and targets that use the generic payload type, and can be cloned in its entirety, including all extensions. This provides a good starting point for building interoperable components and for creating adapters or bridges between different protocols, but the user should consider the semantics of the extended generic payload very carefully. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">e) It is usual to use one and the same protocol traits class along the entire length of the path followed by a transaction from an initiator through zero or more interconnect components to a target. However, it may be possible to model an adapter or bus bridge as an interconnect component that takes incoming transactions of one protocol type and converts them to outgoing transactions of another protocol type. It is also possible to create a transaction bridge, which acts as a target for incoming transactions and as an initiator for outgoing transactions. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">f) When passing a generic payload transaction between sockets specialized using different protocol traits classes, the user is obliged to consider the semantics of each extension very carefully to ensure that the transaction can be transported through components that are aware of the generic payload but not the extensions. There is no general rule. Some extensions can be transported through components ignorant of the extension without mishap, for example an attribute specifying the security level of the data. Other extensions will require explicit adaption or might not be supportable at all, for example an attribute specifying that the interconnect is to be locked. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">&nbsp;</SPAN>