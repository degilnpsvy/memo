<B><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 11.0pt; mso-font-kerning: 0pt">7.2 Extensions and interoperability </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 11.0pt; mso-font-kerning: 0pt"></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt"><FONT face=Arial>The goal of the generic payload is to enable interoperability between memory-mapped bus models, but all buses are not created equal. Given two transaction-level models that use different protocols and that model those protocols at a detailed level, then just as in a physical system, an adapter or bridge must be inserted between those models to perform protocol conversion and allow them to communicate. On the other hand, many transaction level models produced early in the design flow do not care about the specific details of any </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; FONT-FAMILY: 'Times New Roman'; mso-bidi-font-size: 10.0pt">particular protocol. For such models it is sufficient to copy a block of data starting at a given address, and for those models the generic payload can be used directly to give excellent interoperability. The generic payload extension mechanism permits any number of extensions of any type to be defined and added to a transaction object. Each extension represents a new set of attributes, transported along with the transaction object. Extensions can be created, added, written and read by initiators, interconnect components, and targets alike. The extension mechanism itself does not impose any restrictions. Of course, undisciplined use of this extension mechanism would compromise interoperability, so disciplined use is strongly encouraged. But the flexibility is there where you need it! The use of the extension mechanism represents a trade-off between increased coding convenience when binding sockets, and decreased compile-time type checking. If the undisciplined use of generic payload extensions were allowed, each application would be obliged to detect any incompatibility between extensions by including explicit run-time checks in each interconnect component and target, and there would be no mechanism to enforce the existence of a given extension. The TLM-2.0 standard prescribes specific coding guidelines to avoid these pitfalls. There are three, and only three, recommended alternatives for the transaction template argument TRANS of the blocking and non-blocking transport interfaces and the template argument TYPES of the combined interfaces: </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">a) Use the generic payload directly, with ignorable extensions </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">b) Define a new protocol traits class containing a <B>typedef </B>for <B>tlm_generic_payload</B>. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">c) Define a new protocol traits class and a new transaction type </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">&nbsp;</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">These three alternatives are defined below in order of decreasing interoperability. It should be emphasized that although deriving a new class from the generic payload is possible, it is not the recommended approach for interoperability It should also be emphasized that these three options may be mixed in a single system model. In particular, there is value in mixing the first two options, since the extension mechanism has been designed to permit efficient interoperability. </SPAN>