<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.12 Definitions and Variable Bindings</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Scheme supports the definition of variables in different contexts. Variables can be defined at the top level, so that they are visible in the entire program, and variables can be defined locally to procedures and expressions. This is important for modularity and data abstraction.</P>
<TABLE style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=menu border=0 cellSpacing=0>
<TBODY>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=1 href="https://www.gnu.org/software/guile/manual/guile.html#Top-Level">Top Level</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Top level variable definitions.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=2 href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings">Local Bindings</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Local variable bindings.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=3 href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Definitions">Internal Definitions</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Internal definitions.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=4 href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Reflection">Binding Reflection</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Querying variable bindings.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=5 href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Multiple-Values">Binding Multiple Values</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Binding multiple return values.</TD></TR></TBODY></TABLE>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Top-Level></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings" rel=next>Local Bindings</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs" rel=up>Binding Constructs</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Top-Level-Variable-Definitions></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.12.1 Top Level Variable Definitions</H4><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-variable-definition></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">At the top level of a program (i.e., not nested within any other expression), a definition of the form</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(define a <VAR>value</VAR>)
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">defines a variable called<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and sets it to the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>value</VAR>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">If the variable already exists in the current module, because it has already been created by a previous<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression with the same name, its value is simply changed to the new<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>value</VAR>. In this case, then, the above form is completely equivalent to</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(set! a <VAR>value</VAR>)
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">This equivalence means that<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be used interchangeably with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>set!</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to change the value of variables at the top level of the REPL or a Scheme source file. It is useful during interactive development when reloading a Scheme file that you have modified, because it allows the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions in that file to work as expected both the first time that the file is loaded and on subsequent occasions.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Note, though, that<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>set!</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are not always equivalent. For example, a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>set!</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not allowed if the named variable does not already exist, and the two expressions can behave differently in the case where there are imported variables visible from another module.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-define></A>Scheme Syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>define</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>name value</EM></DT>
<DD>
<P>Create a top level variable named<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>name</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>with value<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>value</VAR>. If the named variable already exists, just change its value. The return value of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression is unspecified.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The C API equivalents of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scm_define</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scm_c_define</CODE>, which differ from each other in whether the variable name is specified as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>SCM</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>symbol or as a null-terminated C string.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-scm_005fdefine></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_define</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(sym, value)</EM></DT>
<DT><A name=index-scm_005fc_005fdefine></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_c_define</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(const char *name, value)</EM></DT>
<DD>
<P>C equivalents of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define</CODE>, with variable name specified either by<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>sym</VAR>, a symbol, or by<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>name</VAR>, a null-terminated C string. Both variants return the new or preexisting variable object.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><CODE>define</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(when it occurs at top level),<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scm_define</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scm_c_define</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>all create or set the value of a variable in the top level environment of the current module. If there was not already a variable with the specified name belonging to the current module, but a similarly named variable from another module was visible through having been imported, the newly created variable in the current module will shadow the imported variable, such that the imported variable is no longer visible.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Attention: Scheme definitions inside local binding constructs (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings">Local Bindings</A>) act differently (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Definitions">Internal Definitions</A>).</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Many people end up in a development style of adding and changing definitions at runtime, building out their program without restarting it. (You can do this using<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>reload-module</CODE>, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>reload</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>REPL command, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>load</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>procedure, or even just pasting code into a REPL.) If you are one of these people, you will find that sometimes you there are some variables that you<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>don&#8217;t</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>want to redefine all the time. For these, use<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define-once</CODE>.</P><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-defvar></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-define_002donce></A>Scheme Syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>define-once</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>name value</EM></DT>
<DD>
<P>Create a top level variable named<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>name</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>with value<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>value</VAR>, but only if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>name</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not already bound in the current module.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Old Lispers probably know<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define-once</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>under its Lisp name,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>defvar</CODE>.</P>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Local-Bindings></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Definitions" rel=next>Internal Definitions</A>, Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Top-Level" rel=prev>Top Level</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs" rel=up>Binding Constructs</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Local-Variable-Bindings></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.12.2 Local Variable Bindings</H4><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-local-bindings></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-local-variables></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">As opposed to definitions at the top level, which creates bindings that are visible to all code in a module, it is also possible to define variables which are only visible in a well-defined part of the program. Normally, this part of a program will be a procedure or a subexpression of a procedure.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">With the constructs for local binding (<CODE>let</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let*</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>letrec</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>letrec*</CODE>), the Scheme language has a block structure like most other programming languages since the days of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SMALL>ALGOL 60</SMALL>. Readers familiar to languages like C or Java should already be used to this concept, but the family of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions has a few properties which are well worth knowing.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The most basic local binding construct is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let</CODE>.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-let></A>syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>let</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>bindings body</EM></DT>
<DD>
<P><VAR>bindings</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>has the form</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>((<VAR>variable1</VAR> <VAR>init1</VAR>) &#8230;)
</PRE></DIV>
<P>that is zero or more two-element lists of a variable and an arbitrary expression each. All<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>variable</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>names must be distinct.</P>
<P>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression is evaluated as follows.</P>
<UL>
<LI>All<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>init</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions are evaluated.</LI>
<LI>New storage is allocated for the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>variables</VAR>.</LI>
<LI>The values of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>init</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions are stored into the variables.</LI>
<LI>The expressions in<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>body</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>are evaluated in order, and the value of the last expression is returned as the value of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression.</LI></UL>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>init</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions are not allowed to refer to any of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>variables</VAR>.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The other binding constructs are variations on the same theme: making new values, binding them to variables, and executing a body in that new, extended lexical context.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-let_002a></A>syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>let*</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>bindings body</EM></DT>
<DD>
<P>Similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let</CODE>, but the variable bindings are performed sequentially, that means that all<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>init</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression are allowed to use the variables defined on their left in the binding list.</P>
<P>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression can always be expressed with nested<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions.</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(let* ((a 1) (b a))
   b)
&#8801;
(let ((a 1))
  (let ((b a))
    b))
</PRE></DIV></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-letrec></A>syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>letrec</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>bindings body</EM></DT>
<DD>
<P>Similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let</CODE>, but it is possible to refer to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>variable</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>from lambda expression created in any of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>inits</VAR>. That is, procedures created in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>init</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression can recursively refer to the defined variables.</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(letrec ((even? (lambda (n)
                  (if (zero? n)
                      #t
                      (odd? (- n 1)))))
         (odd? (lambda (n)
                  (if (zero? n)
                      #f
                      (even? (- n 1))))))
  (even? 88))
&#8658;
#t
</PRE></DIV>
<P>Note that while the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>init</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions may refer to the new variables, they may not access their values. For example, making the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>even?</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>function above creates a closure (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure">About Closure</A>) referencing the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>odd?</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable. But<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>odd?</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>can&#8217;t be called until after execution has entered the body.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-letrec_002a></A>syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>letrec*</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>bindings body</EM></DT>
<DD>
<P>Similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>letrec</CODE>, except the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>init</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions are bound to their variables in order.</P>
<P><CODE>letrec*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>thus relaxes the letrec restriction, in that later<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>init</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>expressions may refer to the values of previously bound variables.</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(letrec ((a 42)
         (b (+ a 10)))  ;; Illegal access
  (* a b))
;; The behavior of the expression above is unspecified

(letrec* ((a 42)
          (b (+ a 10)))
  (* a b))
&#8658; 2184
</PRE></DIV></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">There is also an alternative form of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>form, which is used for expressing iteration. Because of the use as a looping construct, this form (the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>named let</EM>) is documented in the section about iteration (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#while-do">Iteration</A>)</P>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Internal-Definitions></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Reflection" rel=next>Binding Reflection</A>, Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings" rel=prev>Local Bindings</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs" rel=up>Binding Constructs</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Internal-definitions></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.12.3 Internal definitions</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">A<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>form which appears inside the body of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let*</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>letrec</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>letrec*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or equivalent expression is called an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>internal definition</EM>. An internal definition differs from a top level definition (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Top-Level">Top Level</A>), because the definition is only visible inside the complete body of the enclosing form. Let us examine the following example.</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(let ((frumble "froz"))
   (define banana (lambda () (apple 'peach)))
   (define apple (lambda (x) x))
   (banana))
&#8658;
peach
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Here the enclosing form is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let</CODE>, so the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define</CODE>s in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let</CODE>-body are internal definitions. Because the scope of the internal definitions is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>complete</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>body of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let</CODE>-expression, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda</CODE>-expression which gets bound to the variable<CODE>banana</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>may refer to the variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>apple</CODE>, even though its definition appears lexically<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>after</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>banana</CODE>. This is because a sequence of internal definition acts as if it were a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>letrec*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression.</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(let ()
  (define a 1)
  (define b 2)
  (+ a b))
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">is equivalent to</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(let ()
  (letrec* ((a 1) (b 2))
    (+ a b)))
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Internal definitions are only allowed at the beginning of the body of an enclosing expression. They may not be mixed with other expressions.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Another noteworthy difference to top level definitions is that within one group of internal definitions all variable names must be distinct. That means where on the top level a second define for a given variable acts like a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>set!</CODE>, an exception is thrown for internal definitions with duplicate bindings.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">As a historical note, it used to be that internal bindings were expanded in terms of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>letrec</CODE>, not<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>letrec*</CODE>. This was the situation for the R5RS report and before. However with the R6RS, it was recognized that sequential definition was a more intuitive expansion, as in the following case:</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(let ()
  (define a 1)
  (define b (+ a a))
  (+ a b))
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Guile decided to follow the R6RS in this regard, and now expands internal definitions using<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>letrec*</CODE>.</P>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Binding-Reflection></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Multiple-Values" rel=next>Binding Multiple Values</A>, Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Definitions" rel=prev>Internal Definitions</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs" rel=up>Binding Constructs</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Querying-variable-bindings></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.12.4 Querying variable bindings</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Guile provides a procedure for checking whether a symbol is bound in the top level environment.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-defined_003f></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>defined?</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>sym [module]</EM></DT>
<DT><A name=index-scm_005fdefined_005fp></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_defined_p</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(sym, module)</EM></DT>
<DD>
<P>Return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#t</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>sym</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is defined in the module<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>module</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>or the current module when<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>module</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not specified; otherwise return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE>.</P></DD></DL>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Binding-Multiple-Values></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Reflection" rel=prev>Binding Reflection</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs" rel=up>Binding Constructs</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Binding-multiple-return-values></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.12.5 Binding multiple return values</H4>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-define_002dvalues></A>Syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>define-values</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>formals expression</EM></DT>
<DD>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>expression</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is evaluated, and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>formals</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>are bound to the return values in the same way that the formals in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression are matched to the arguments in a procedure call.</P></DD></DL>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=example><PRE class=example>(define-values (q r) (floor/ 10 3))
(list q r) &#8658; (3 1)

(define-values (x . y) (values 1 2 3))
x &#8658; 1
y &#8658; (2 3)

(define-values x (values 1 2 3))
x &#8658; (1 2 3)</PRE></DIV>