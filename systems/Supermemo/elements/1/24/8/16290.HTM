<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.15 Regular Expressions</H3><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-Regular-expressions></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-regular-expressions></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-regex></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-emacs-regexp></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>regular expression</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>(or<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>regexp</EM>) is a pattern that describes a whole class of strings. A full description of regular expressions and their syntax is beyond the scope of this manual; an introduction can be found in the Emacs manual (see<A href="http://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Regexps">Syntax of Regular Expressions</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><CITE>The GNU Emacs Manual</CITE>), or in many general Unix reference books.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">If your system does not include a POSIX regular expression library, and you have not linked Guile with a third-party regexp library such as Rx, these functions will not be available. You can tell whether your Guile installation includes regular expression support by checking whether<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(provided? 'regex)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns true.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The following regexp and string matching features are provided by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(ice-9 regex)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>module. Before using the described functions, you should load this module by executing<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(use-modules (ice-9 regex))</CODE>.</P>
<TABLE style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=menu border=0 cellSpacing=0>
<TBODY>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=1 href="https://www.gnu.org/software/guile/manual/guile.html#Regexp-Functions">Regexp Functions</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Functions that create and match regexps.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=2 href="https://www.gnu.org/software/guile/manual/guile.html#Match-Structures">Match Structures</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Finding what was matched by a regexp.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=3 href="https://www.gnu.org/software/guile/manual/guile.html#Backslash-Escapes">Backslash Escapes</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Removing the special meaning of regexp meta-characters.</TD></TR></TBODY></TABLE>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Regexp-Functions></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Match-Structures" rel=next>Match Structures</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Regular-Expressions" rel=up>Regular Expressions</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Regexp-Functions-1></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.15.1 Regexp Functions</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">By default, Guile supports POSIX extended regular expressions. That means that the characters &#8216;<SAMP>(</SAMP>&#8217;, &#8216;<SAMP>)</SAMP>&#8217;, &#8216;<SAMP>+</SAMP>&#8217; and &#8216;<SAMP>?</SAMP>&#8217; are special, and must be escaped if you wish to match the literal characters.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">This regular expression interface was modeled after that implemented by SCSH, the Scheme Shell. It is intended to be upwardly compatible with SCSH regular expressions.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Zero bytes (<CODE>#\nul</CODE>) cannot be used in regex patterns or input strings, since the underlying C functions treat that as the end of string. If there&#8217;s a zero byte an error is thrown.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Internally, patterns and input strings are converted to the current locale&#8217;s encoding, and then passed to the C library&#8217;s regular expression routines (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Regular-Expressions">Regular Expressions</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><CITE>The GNU C Library Reference Manual</CITE>). The returned match structures always point to characters in the strings, not to individual bytes, even in the case of multi-byte encodings.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-string_002dmatch></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>string-match</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>pattern str [start]</EM></DT>
<DD>
<P>Compile the string<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>pattern</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>into a regular expression and compare it with<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>str</VAR>. The optional numeric argument<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>start</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>specifies the position of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>str</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>at which to begin matching.</P>
<P><CODE>string-match</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>match structure</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>which describes what, if anything, was matched by the regular expression. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Match-Structures">Match Structures</A>. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>str</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not match<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>pattern</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>at all,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>string-match</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE>.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Two examples of a match follow. In the first example, the pattern matches the four digits in the match string. In the second, the pattern matches nothing.</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=example><PRE class=example>(string-match "[0-9][0-9][0-9][0-9]" "blah2002")
&#8658; #("blah2002" (4 . 8))

(string-match "[A-Za-z]" "123456")
&#8658; #f
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Each time<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>string-match</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is called, it must compile its<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>pattern</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument into a regular expression structure. This operation is expensive, which makes<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>string-match</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>inefficient if the same regular expression is used several times (for example, in a loop). For better performance, you can compile a regular expression in advance and then match strings against the compiled regexp.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-make_002dregexp></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>make-regexp</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>pat flag&#8230;</EM></DT>
<DT><A name=index-scm_005fmake_005fregexp></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_make_regexp</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(pat, flaglst)</EM></DT>
<DD>
<P>Compile the regular expression described by<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>pat</VAR>, and return the compiled regexp structure. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>pat</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not describe a legal regular expression,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>make-regexp</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>throws a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regular-expression-syntax</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>error.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>flag</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments change the behavior of the compiled regular expression. The following values may be supplied:</P>
<DL>
<DT><A name=index-regexp_002ficase></A>Variable:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>regexp/icase</STRONG></DT>
<DD>
<P>Consider uppercase and lowercase letters to be the same when matching.</P></DD></DL>
<DL>
<DT><A name=index-regexp_002fnewline></A>Variable:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>regexp/newline</STRONG></DT>
<DD>
<P>If a newline appears in the target string, then permit the &#8216;<SAMP>^</SAMP>&#8217; and &#8216;<SAMP>$</SAMP>&#8217; operators to match immediately after or immediately before the newline, respectively. Also, the &#8216;<SAMP>.</SAMP>&#8217; and &#8216;<SAMP>[^...]</SAMP>&#8217; operators will never match a newline character. The intent of this flag is to treat the target string as a buffer containing many lines of text, and the regular expression as a pattern that may match a single one of those lines.</P></DD></DL>
<DL>
<DT><A name=index-regexp_002fbasic></A>Variable:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>regexp/basic</STRONG></DT>
<DD>
<P>Compile a basic (&#8220;obsolete&#8221;) regexp instead of the extended (&#8220;modern&#8221;) regexps that are the default. Basic regexps do not consider &#8216;<SAMP>|</SAMP>&#8217;, &#8216;<SAMP>+</SAMP>&#8217; or &#8216;<SAMP>?</SAMP>&#8217; to be special characters, and require the &#8216;<SAMP>{...}</SAMP>&#8217; and &#8216;<SAMP>(...)</SAMP>&#8217; metacharacters to be backslash-escaped (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Backslash-Escapes">Backslash Escapes</A>). There are several other differences between basic and extended regular expressions, but these are the most significant.</P></DD></DL>
<DL>
<DT><A name=index-regexp_002fextended></A>Variable:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>regexp/extended</STRONG></DT>
<DD>
<P>Compile an extended regular expression rather than a basic regexp. This is the default behavior; this flag will not usually be needed. If a call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>make-regexp</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>includes both<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp/basic</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp/extended</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>flags, the one which comes last will override the earlier one.</P></DD></DL></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-regexp_002dexec></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>regexp-exec</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>rx str [start [flags]]</EM></DT>
<DT><A name=index-scm_005fregexp_005fexec></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_regexp_exec</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(rx, str, start, flags)</EM></DT>
<DD>
<P>Match the compiled regular expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>rx</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>against<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>str</CODE>. If the optional integer<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>start</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument is provided, begin matching from that position in the string. Return a match structure describing the results of the match, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if no match could be found.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>flags</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument changes the matching behavior. The following flag values may be supplied, use<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>logior</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Bitwise-Operations">Bitwise Operations</A>) to combine them,</P>
<DL>
<DT><A name=index-regexp_002fnotbol></A>Variable:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>regexp/notbol</STRONG></DT>
<DD>
<P>Consider that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>start</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>offset into<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>str</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not the beginning of a line and should not match operator &#8216;<SAMP>^</SAMP>&#8217;.</P>
<P>If<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>rx</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>was created with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp/newline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>option above, &#8216;<SAMP>^</SAMP>&#8217; will still match after a newline in<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>str</VAR>.</P></DD></DL>
<DL>
<DT><A name=index-regexp_002fnoteol></A>Variable:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>regexp/noteol</STRONG></DT>
<DD>
<P>Consider that the end of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>str</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not the end of a line and should not match operator &#8216;<SAMP>$</SAMP>&#8217;.</P>
<P>If<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>rx</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>was created with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp/newline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>option above, &#8216;<SAMP>$</SAMP>&#8217; will still match before a newline in<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>str</VAR>.</P></DD></DL></DD></DL>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>;; Regexp to match uppercase letters
(define r (make-regexp "[A-Z]*"))

;; Regexp to match letters, ignoring case
(define ri (make-regexp "[A-Z]*" regexp/icase))

;; Search for bob using regexp r
(match:substring (regexp-exec r "bob"))
&#8658; ""                  ; no match

;; Search for bob using regexp ri
(match:substring (regexp-exec ri "Bob"))
&#8658; "Bob"               ; matched case insensitive
</PRE></DIV>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-regexp_003f></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>regexp?</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>obj</EM></DT>
<DT><A name=index-scm_005fregexp_005fp></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_regexp_p</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(obj)</EM></DT>
<DD>
<P>Return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#t</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>obj</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a compiled regular expression, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>otherwise.</P></DD></DL><BR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-list_002dmatches></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>list-matches</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>regexp str [flags]</EM></DT>
<DD>
<P>Return a list of match structures which are the non-overlapping matches of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>regexp</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>str</VAR>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>regexp</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be either a pattern string or a compiled regexp. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>flags</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument is as per<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp-exec</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>above.</P>
<DIV style="MARGIN-LEFT: 3.2em" class=example><PRE class=example>(map match:substring (list-matches "[a-z]+" "abc 42 def 78"))
&#8658; ("abc" "def")
</PRE></DIV></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-fold_002dmatches></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>fold-matches</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>regexp str init proc [flags]</EM></DT>
<DD>
<P>Apply<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the non-overlapping matches of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>regexp</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>str</VAR>, to build a result.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>regexp</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be either a pattern string or a compiled regexp. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>flags</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument is as per<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp-exec</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>above.</P>
<P><VAR>proc</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is called as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(<VAR>proc</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>match prev)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>where<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>match</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a match structure and<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>prev</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the previous return from<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR>. For the first call<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>prev</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the given<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>init</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter.<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fold-matches</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns the final value from<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR>.</P>
<P>For example to count matches,</P>
<DIV style="MARGIN-LEFT: 3.2em" class=example><PRE class=example>(fold-matches "[a-z][0-9]" "abc x1 def y2" 0
              (lambda (match count)
                (1+ count)))
&#8658; 2
</PRE></DIV></DD></DL><BR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Regular expressions are commonly used to find patterns in one string and replace them with the contents of another string. The following functions are convenient ways to do this.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-regexp_002dsubstitute></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>regexp-substitute</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>port match item &#8230;</EM></DT>
<DD>
<P>Write to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>port</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>selected parts of the match structure<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>match</VAR>. Or if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>port</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>then form a string from those parts and return that.</P>
<P>Each<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>item</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>specifies a part to be written, and may be one of the following,</P>
<UL>
<LI>A string. String arguments are written out verbatim.</LI>
<LI>An integer. The submatch with that number is written (<CODE>match:substring</CODE>). Zero is the entire match.</LI>
<LI>The symbol &#8216;<SAMP>pre</SAMP>&#8217;. The portion of the matched string preceding the regexp match is written (<CODE>match:prefix</CODE>).</LI>
<LI>The symbol &#8216;<SAMP>post</SAMP>&#8217;. The portion of the matched string following the regexp match is written (<CODE>match:suffix</CODE>).</LI></UL>
<P>For example, changing a match and retaining the text before and after,</P>
<DIV style="MARGIN-LEFT: 3.2em" class=example><PRE class=example>(regexp-substitute #f (string-match "[0-9]+" "number 25 is good")
                   'pre "37" 'post)
&#8658; "number 37 is good"
</PRE></DIV>
<P>Or matching a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SMALL>YYYYMMDD</SMALL><SPAN class=Apple-converted-space>&nbsp;</SPAN>format date such as &#8216;<SAMP>20020828</SAMP>&#8217; and re-ordering and hyphenating the fields.</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(define date-regex
   "([0-9][0-9][0-9][0-9])([0-9][0-9])([0-9][0-9])")
(define s "Date 20020429 12am.")
(regexp-substitute #f (string-match date-regex s)
                   'pre 2 "-" 3 "-" 1 'post " (" 0 ")")
&#8658; "Date 04-29-2002 12am. (20020429)"
</PRE></DIV></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-regexp_002dsubstitute_002fglobal></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>regexp-substitute/global</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>port regexp target item&#8230;</EM></DT>
<DD><A name=index-search-and-replace></A>
<P>Write to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>port</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>selected parts of matches of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>regexp</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>target</VAR>. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>port</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>then form a string from those parts and return that.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>regexp</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be a string or a compiled regex.</P>
<P>This is similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp-substitute</CODE>, but allows global substitutions on<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>target</VAR>. Each<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>item</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>behaves as per<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp-substitute</CODE>, with the following differences,</P>
<UL>
<LI>A function. Called as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(<VAR>item</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>match)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the match structure for the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>regexp</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>match, it should return a string to be written to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>port</VAR>.</LI>
<LI>The symbol &#8216;<SAMP>post</SAMP>&#8217;. This doesn&#8217;t output anything, but instead causes<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp-substitute/global</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to recurse on the unmatched portion of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>target</VAR>.
<P>This<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>must</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>be supplied to perform a global search and replace on<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>target</VAR>; without it<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp-substitute/global</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns after a single match and output.</P></LI></UL>
<P>For example, to collapse runs of tabs and spaces to a single hyphen each,</P>
<DIV style="MARGIN-LEFT: 3.2em" class=example><PRE class=example>(regexp-substitute/global #f "[ \t]+"  "this   is   the text"
                          'pre "-" 'post)
&#8658; "this-is-the-text"
</PRE></DIV>
<P>Or using a function to reverse the letters in each word,</P>
<DIV style="MARGIN-LEFT: 3.2em" class=example><PRE class=example>(regexp-substitute/global #f "[a-z]+"  "to do and not-do"
  'pre (lambda (m) (string-reverse (match:substring m))) 'post)
&#8658; "ot od dna ton-od"
</PRE></DIV>
<P>Without the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>post</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>symbol, just one regexp match is made. For example the following is the date example from<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp-substitute</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>above, without the need for the separate<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>string-match</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>call.</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(define date-regex 
   "([0-9][0-9][0-9][0-9])([0-9][0-9])([0-9][0-9])")
(define s "Date 20020429 12am.")
(regexp-substitute/global #f date-regex s
                          'pre 2 "-" 3 "-" 1 'post " (" 0 ")")

&#8658; "Date 04-29-2002 12am. (20020429)"
</PRE></DIV></DD></DL>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Match-Structures></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Backslash-Escapes" rel=next>Backslash Escapes</A>, Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Regexp-Functions" rel=prev>Regexp Functions</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Regular-Expressions" rel=up>Regular Expressions</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Match-Structures-1></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.15.2 Match Structures</H4><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-match-structures></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>match structure</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the object returned by<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>string-match</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp-exec</CODE>. It describes which portion of a string, if any, matched the given regular expression. Match structures include: a reference to the string that was checked for matches; the starting and ending positions of the regexp match; and, if the regexp included any parenthesized subexpressions, the starting and ending positions of each submatch.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In each of the regexp match functions described below, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>match</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument must be a match structure returned by a previous call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>string-match</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp-exec</CODE>. Most of these functions return some information about the original target string that was matched against a regular expression; we will call that string<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>target</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>for easy reference.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-regexp_002dmatch_003f></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>regexp-match?</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>obj</EM></DT>
<DD>
<P>Return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#t</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>obj</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a match structure returned by a previous call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>regexp-exec</CODE>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>otherwise.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-match_003asubstring></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>match:substring</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>match [n]</EM></DT>
<DD>
<P>Return the portion of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>target</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>matched by subexpression number<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR>. Submatch 0 (the default) represents the entire regexp match. If the regular expression as a whole matched, but the subexpression number<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>did not match, return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE>.</P></DD></DL>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:substring s)
&#8658; "2002"

;; match starting at offset 6 in the string
(match:substring
  (string-match "[0-9][0-9][0-9][0-9]" "blah987654" 6))
&#8658; "7654"
</PRE></DIV>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-match_003astart></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>match:start</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>match [n]</EM></DT>
<DD>
<P>Return the starting position of submatch number<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR>.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In the following example, the result is 4, since the match starts at character index 4:</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:start s)
&#8658; 4
</PRE></DIV>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-match_003aend></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>match:end</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>match [n]</EM></DT>
<DD>
<P>Return the ending position of submatch number<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR>.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In the following example, the result is 8, since the match runs between characters 4 and 8 (i.e. the &#8220;2002&#8221;).</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:end s)
&#8658; 8
</PRE></DIV>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-match_003aprefix></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>match:prefix</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>match</EM></DT>
<DD>
<P>Return the unmatched portion of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>target</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>preceding the regexp match.</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:prefix s)
&#8658; "blah"
</PRE></DIV></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-match_003asuffix></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>match:suffix</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>match</EM></DT>
<DD>
<P>Return the unmatched portion of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>target</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>following the regexp match.</P></DD></DL>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:suffix s)
&#8658; "foo"
</PRE></DIV>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-match_003acount></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>match:count</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>match</EM></DT>
<DD>
<P>Return the number of parenthesized subexpressions from<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>match</VAR>. Note that the entire regular expression match itself counts as a subexpression, and failed submatches are included in the count.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-match_003astring></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>match:string</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>match</EM></DT>
<DD>
<P>Return the original<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>target</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>string.</P></DD></DL>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:string s)
&#8658; "blah2002foo"
</PRE></DIV>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Backslash-Escapes></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Match-Structures" rel=prev>Match Structures</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Regular-Expressions" rel=up>Regular Expressions</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Backslash-Escapes-1></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.15.3 Backslash Escapes</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Sometimes you will want a regexp to match characters like &#8216;<SAMP>*</SAMP>&#8217; or &#8216;<SAMP>$</SAMP>&#8217; exactly. For example, to check whether a particular string represents a menu entry from an Info node, it would be useful to match it against a regexp like &#8216;<SAMP>^* [^:]*::</SAMP>&#8217;. However, this won&#8217;t work; because the asterisk is a metacharacter, it won&#8217;t match the &#8216;<SAMP>*</SAMP>&#8217; at the beginning of the string. In this case, we want to make the first asterisk un-magic.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">You can do this by preceding the metacharacter with a backslash character &#8216;<SAMP>\</SAMP>&#8217;. (This is also called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>quoting</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>the metacharacter, and is known as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>backslash escape</EM>.) When Guile sees a backslash in a regular expression, it considers the following glyph to be an ordinary character, no matter what special meaning it would ordinarily have. Therefore, we can make the above example work by changing the regexp to &#8216;<SAMP>^\* [^:]*::</SAMP>&#8217;. The &#8216;<SAMP>\*</SAMP>&#8217; sequence tells the regular expression engine to match only a single asterisk in the target string.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Since the backslash is itself a metacharacter, you may force a regexp to match a backslash in the target string by preceding the backslash with itself. For example, to find variable references in a TeX program, you might want to find occurrences of the string &#8216;<SAMP>\let\</SAMP>&#8217; followed by any number of alphabetic characters. The regular expression &#8216;<SAMP>\\let\\[A-Za-z]*</SAMP>&#8217; would do this: the double backslashes in the regexp each match a single backslash in the target string.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-regexp_002dquote></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>regexp-quote</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>str</EM></DT>
<DD>
<P>Quote each special character found in<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>str</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a backslash, and return the resulting string.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><STRONG>Very important:</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>Using backslash escapes in Guile source code (as in Emacs Lisp or C) can be tricky, because the backslash character has special meaning for the Guile reader. For example, if Guile encounters the character sequence &#8216;<SAMP>\n</SAMP>&#8217; in the middle of a string while processing Scheme code, it replaces those characters with a newline character. Similarly, the character sequence &#8216;<SAMP>\t</SAMP>&#8217; is replaced by a horizontal tab. Several of these<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>escape sequences</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>are processed by the Guile reader before your code is executed. Unrecognized escape sequences are ignored: if the characters &#8216;<SAMP>\*</SAMP>&#8217; appear in a string, they will be translated to the single character &#8216;<SAMP>*</SAMP>&#8217;.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">This translation is obviously undesirable for regular expressions, since we want to be able to include backslashes in a string in order to escape regexp metacharacters. Therefore, to make sure that a backslash is preserved in a string in your Guile program, you must use<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>two</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>consecutive backslashes:</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(define Info-menu-entry-pattern (make-regexp "^\\* [^:]*"))
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The string in this example is preprocessed by the Guile reader before any code is executed. The resulting argument to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>make-regexp</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the string &#8216;<SAMP>^\* [^:]*</SAMP>&#8217;, which is what we really want.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">This also means that in order to write a regular expression that matches a single backslash character, the regular expression string in the source code must include<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>four</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>backslashes. Each consecutive pair of backslashes gets translated by the Guile reader to a single backslash, and the resulting double-backslash is interpreted by the regexp engine as matching a single backslash character. Hence:</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(define tex-variable-pattern (make-regexp "\\\\let\\\\=[A-Za-z]*"))
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The reason for the unwieldiness of this syntax is historical. Both regular expression pattern matchers and Unix string processing systems have traditionally used backslashes with the special meanings described above. The POSIX regular expression specification and ANSI C standard both require these semantics. Attempting to abandon either convention would cause other kinds of compatibility problems, possibly more severe ones. Therefore, without extending the Scheme reader to support strings with different quoting conventions (an ungainly and confusing extension when implemented in other languages), we must adhere to this cumbersome escape syntax.