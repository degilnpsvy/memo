<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.9 Procedures</H3>
<TABLE style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=menu border=0 cellSpacing=0>
<TBODY>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=1 href="https://www.gnu.org/software/guile/manual/guile.html#Lambda">Lambda</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Basic procedure creation using lambda.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=2 href="https://www.gnu.org/software/guile/manual/guile.html#Primitive-Procedures">Primitive Procedures</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Procedures defined in C.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=3 href="https://www.gnu.org/software/guile/manual/guile.html#Compiled-Procedures">Compiled Procedures</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Scheme procedures can be compiled.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=4 href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments">Optional Arguments</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Handling keyword, optional and rest arguments.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=5 href="https://www.gnu.org/software/guile/manual/guile.html#Case_002dlambda">Case-lambda</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>One function, multiple arities.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=6 href="https://www.gnu.org/software/guile/manual/guile.html#Higher_002dOrder-Functions">Higher-Order Functions</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Function that take or return functions.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=7 href="https://www.gnu.org/software/guile/manual/guile.html#Procedure-Properties">Procedure Properties</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Procedure properties and meta-information.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=8 href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-with-Setters">Procedures with Setters</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Procedures with setters.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=9 href="https://www.gnu.org/software/guile/manual/guile.html#Inlinable-Procedures">Inlinable Procedures</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Procedures that can be inlined.</TD></TR></TBODY></TABLE>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Lambda></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Primitive-Procedures" rel=next>Primitive Procedures</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" rel=up>Procedures</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Lambda_003a-Basic-Procedure-Creation></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.9.1 Lambda: Basic Procedure Creation</H4><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-lambda></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">A<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression evaluates to a procedure. The environment which is in effect when a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression is evaluated is enclosed in the newly created procedure, this is referred to as a<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>closure</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>(see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure">About Closure</A>).</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">When a procedure created by<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is called with some actual arguments, the environment enclosed in the procedure is extended by binding the variables named in the formal argument list to new locations and storing the actual arguments into these locations. Then the body of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>expression is evaluated sequentially. The result of the last expression in the procedure body is then the result of the procedure invocation.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The following examples will show how procedures can be created using<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda</CODE>, and what you can do with these procedures.</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(lambda (x) (+ x x))       &#8658; <SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman>a procedure</SPAN>
((lambda (x) (+ x x)) 4)   &#8658; 8
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The fact that the environment in effect when creating a procedure is enclosed in the procedure is shown with this example:</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(add4 6)                   &#8658; 10
</PRE></DIV>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-lambda-1></A>syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>lambda</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>formals body</EM></DT>
<DD>
<P><VAR>formals</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>should be a formal argument list as described in the following table.</P>
<DL compact>
<DT><CODE>(<VAR>variable1</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>&#8230;)</CODE></DT>
<DD>
<P>The procedure takes a fixed number of arguments; when the procedure is called, the arguments will be stored into the newly created location for the formal variables.</P></DD>
<DT><CODE><VAR>variable</VAR></CODE></DT>
<DD>
<P>The procedure takes any number of arguments; when the procedure is called, the sequence of actual arguments will converted into a list and stored into the newly created location for the formal variable.</P></DD>
<DT><CODE>(<VAR>variable1</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>&#8230;<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>variablen</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>variablen+1</VAR>)</CODE></DT>
<DD>
<P>If a space-delimited period precedes the last variable, then the procedure takes<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>or more variables where<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the number of formal arguments before the period. There must be at least one argument before the period. The first<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>actual arguments will be stored into the newly allocated locations for the first<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>formal arguments and the sequence of the remaining actual arguments is converted into a list and the stored into the location for the last formal argument. If there are exactly<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>actual arguments, the empty list is stored into the location of the last formal argument.</P></DD></DL>
<P>The list in<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>variable</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>variablen+1</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is always newly created and the procedure can modify it if desired. This is the case even when the procedure is invoked via<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>apply</CODE>, the required part of the list argument there will be copied (see<A href="https://www.gnu.org/software/guile/manual/guile.html#Fly-Evaluation">Procedures for On the Fly Evaluation</A>).</P>
<P><VAR>body</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a sequence of Scheme expressions which are evaluated in order when the procedure is invoked.</P></DD></DL>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Primitive-Procedures></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Compiled-Procedures" rel=next>Compiled Procedures</A>, Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Lambda" rel=prev>Lambda</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" rel=up>Procedures</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Primitive-Procedures-1></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.9.2 Primitive Procedures</H4><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-primitives></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-primitive-procedures></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Procedures written in C can be registered for use from Scheme, provided they take only arguments of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>SCM</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>SCM</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>values.<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scm_c_define_gsubr</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is likely to be the most useful mechanism, combining the process of registration (<CODE>scm_c_make_gsubr</CODE>) and definition (<CODE>scm_define</CODE>).</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-scm_005fc_005fmake_005fgsubr></A>Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>SCM</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_c_make_gsubr</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(const char *name, int req, int opt, int rst, fcn)</EM></DT>
<DD>
<P>Register a C procedure<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>fcn</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a &#8220;subr&#8221; &#8212; a primitive subroutine that can be called from Scheme. It will be associated with the given<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>name</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>but no environment binding will be created. The arguments<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>req</VAR>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>opt</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>rst</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>specify the number of required, optional and &#8220;rest&#8221; arguments respectively. The total number of these arguments should match the actual number of arguments to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>fcn</VAR>, but may not exceed 10. The number of rest arguments should be 0 or 1.<CODE>scm_c_make_gsubr</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns a value of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>SCM</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>which is a &#8220;handle&#8221; for the procedure.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-scm_005fc_005fdefine_005fgsubr></A>Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>SCM</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_c_define_gsubr</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(const char *name, int req, int opt, int rst, fcn)</EM></DT>
<DD>
<P>Register a C procedure<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>fcn</VAR>, as for<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scm_c_make_gsubr</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>above, and additionally create a top-level Scheme binding for the procedure in the &#8220;current environment&#8221; using<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scm_define</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scm_c_define_gsubr</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns a handle for the procedure in the same way as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scm_c_make_gsubr</CODE>, which is usually not further required.</P></DD></DL>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Compiled-Procedures></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments" rel=next>Optional Arguments</A>, Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Primitive-Procedures" rel=prev>Primitive Procedures</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" rel=up>Procedures</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Compiled-Procedures-1></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.9.3 Compiled Procedures</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The evaluation strategy given in<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Lambda">Lambda</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>describes how procedures are<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>interpreted</EM>. Interpretation operates directly on expanded Scheme source code, recursively calling the evaluator to obtain the value of nested expressions.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Most procedures are compiled, however. This means that Guile has done some pre-computation on the procedure, to determine what it will need to do each time the procedure runs. Compiled procedures run faster than interpreted procedures.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Loading files is the normal way that compiled procedures come to being. If Guile sees that a file is uncompiled, or that its compiled file is out of date, it will attempt to compile the file when it is loaded, and save the result to disk. Procedures can be compiled at runtime as well. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile">Read/Load/Eval/Compile</A>, for more information on runtime compilation.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Compiled procedures, also known as<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>programs</EM>, respond all procedures that operate on procedures. In addition, there are a few more accessors for low-level details on programs.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Most people won&#8217;t need to use the routines described in this section, but it&#8217;s good to have them documented. You&#8217;ll have to include the appropriate module first, though:</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=example><PRE class=example>(use-modules (system vm program))
</PRE></DIV>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-program_003f></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>program?</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>obj</EM></DT>
<DT><A name=index-scm_005fprogram_005fp></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_program_p</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(obj)</EM></DT>
<DD>
<P>Returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#t</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>obj</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a compiled procedure, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>otherwise.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-program_002dobjcode></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>program-objcode</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>program</EM></DT>
<DT><A name=index-scm_005fprogram_005fobjcode></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_program_objcode</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(program)</EM></DT>
<DD>
<P>Returns the object code associated with this program. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Bytecode-and-Objcode">Bytecode and Objcode</A>, for more information.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-program_002dobjects></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>program-objects</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>program</EM></DT>
<DT><A name=index-scm_005fprogram_005fobjects></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_program_objects</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(program)</EM></DT>
<DD>
<P>Returns the &#8220;object table&#8221; associated with this program, as a vector. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#VM-Programs">VM Programs</A>, for more information.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-program_002dmodule></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>program-module</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>program</EM></DT>
<DT><A name=index-scm_005fprogram_005fmodule></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_program_module</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(program)</EM></DT>
<DD>
<P>Returns the module that was current when this program was created. Can return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the compiler could determine that this information was unnecessary.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-program_002dfree_002dvariables></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>program-free-variables</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>program</EM></DT>
<DT><A name=index-scm_005fprogram_005ffree_005fvariables></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_program_free_variables</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(program)</EM></DT>
<DD>
<P>Returns the set of free variables that this program captures in its closure, as a vector. If a closure is code with data, you can get the code from<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>program-objcode</CODE>, and the data via<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>program-free-variables</CODE>.</P>
<P>Some of the values captured are actually in variable &#8220;boxes&#8221;. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Variables-and-the-VM">Variables and the VM</A>, for more information.</P>
<P>Users must not modify the returned value unless they think they&#8217;re really clever.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-program_002dmeta></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>program-meta</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>program</EM></DT>
<DT><A name=index-scm_005fprogram_005fmeta></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_program_meta</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(program)</EM></DT>
<DD>
<P>Return the metadata thunk of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>program</VAR>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if it has no metadata.</P>
<P>When called, a metadata thunk returns a list of the following form:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(<VAR>bindings</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>sources</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arities</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>properties</VAR>)</CODE>. The format of each of these elements is discussed below.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-program_002dbindings></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>program-bindings</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>program</EM></DT>
<DT><A name=index-make_002dbinding></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>make-binding</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>name boxed? index start end</EM></DT>
<DT><A name=index-binding_003aname></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>binding:name</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>binding</EM></DT>
<DT><A name=index-binding_003aboxed_003f></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>binding:boxed?</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>binding</EM></DT>
<DT><A name=index-binding_003aindex></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>binding:index</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>binding</EM></DT>
<DT><A name=index-binding_003astart></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>binding:start</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>binding</EM></DT>
<DT><A name=index-binding_003aend></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>binding:end</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>binding</EM></DT>
<DD>
<P>Bindings annotations for programs, along with their accessors.</P>
<P>Bindings declare names and liveness extents for block-local variables. The best way to see what these are is to play around with them at a REPL. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#VM-Concepts">VM Concepts</A>, for more information.</P>
<P>Note that bindings information is stored in a program as part of its metadata thunk, so including it in the generated object code does not impose a runtime performance penalty.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-program_002dsources></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>program-sources</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>program</EM></DT>
<DT><A name=index-source_003aaddr></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>source:addr</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>source</EM></DT>
<DT><A name=index-source_003aline></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>source:line</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>source</EM></DT>
<DT><A name=index-source_003acolumn></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>source:column</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>source</EM></DT>
<DT><A name=index-source_003afile></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>source:file</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>source</EM></DT>
<DD>
<P>Source location annotations for programs, along with their accessors.</P>
<P>Source location information propagates through the compiler and ends up being serialized to the program&#8217;s metadata. This information is keyed by the offset of the instruction pointer within the object code of the program. Specifically, it is keyed on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>ip</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>just following</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>an instruction, so that backtraces can find the source location of a call that is in progress.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-program_002darities></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>program-arities</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>program</EM></DT>
<DT><A name=index-scm_005fprogram_005farities></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_program_arities</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(program)</EM></DT>
<DT><A name=index-program_002darity></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>program-arity</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>program ip</EM></DT>
<DT><A name=index-arity_003astart></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>arity:start</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>arity</EM></DT>
<DT><A name=index-arity_003aend></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>arity:end</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>arity</EM></DT>
<DT><A name=index-arity_003anreq></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>arity:nreq</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>arity</EM></DT>
<DT><A name=index-arity_003anopt></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>arity:nopt</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>arity</EM></DT>
<DT><A name=index-arity_003arest_003f></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>arity:rest?</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>arity</EM></DT>
<DT><A name=index-arity_003akw></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>arity:kw</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>arity</EM></DT>
<DT><A name=index-arity_003aallow_002dother_002dkeys_003f></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>arity:allow-other-keys?</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>arity</EM></DT>
<DD>
<P>Accessors for a representation of the &#8220;arity&#8221; of a program.</P>
<P>The normal case is that a procedure has one arity. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(lambda (x) x)</CODE>, takes one required argument, and that&#8217;s it. One could access that number of required arguments via<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(arity:nreq (program-arities (lambda (x) x)))</CODE>. Similarly,<CODE>arity:nopt</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>gets the number of optional arguments, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>arity:rest?</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns a true value if the procedure has a rest arg.</P>
<P><CODE>arity:kw</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns a list of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(<VAR>kw</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>idx</VAR>)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>pairs, if the procedure has keyword arguments. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>idx</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>refers to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>idx</VAR>th local variable; See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Variables-and-the-VM">Variables and the VM</A>, for more information. Finally<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>arity:allow-other-keys?</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns a true value if other keys are allowed. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments">Optional Arguments</A>, for more information.</P>
<P>So what about<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>arity:start</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>arity:end</CODE>, then? They return the range of bytes in the program&#8217;s bytecode for which a given arity is valid. You see, a procedure can actually have more than one arity. The question, &#8220;what is a procedure&#8217;s arity&#8221; only really makes sense at certain points in the program, delimited by these<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>arity:start</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>arity:end</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>values.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-program_002darguments_002dalist></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>program-arguments-alist</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>program [ip]</EM></DT>
<DD>
<P>Return an association list describing the arguments that<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>program</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>accepts, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the information cannot be obtained.</P>
<P>The alist keys that are currently defined are &#8216;required&#8217;, &#8216;optional&#8217;, &#8216;keyword&#8217;, &#8216;allow-other-keys?&#8217;, and &#8216;rest&#8217;. For example:</P>
<DIV style="MARGIN-LEFT: 3.2em" class=example><PRE class=example>(program-arguments-alist
 (lambda* (a b #:optional c #:key (d 1) #:rest e)
   #t)) &#8658;
((required . (a b))
 (optional . (c))
 (keyword . ((#:d . 4)))
 (allow-other-keys? . #f)
 (rest . d))
</PRE></DIV></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-program_002dlambda_002dlist></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>program-lambda-list</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>program [ip]</EM></DT>
<DD>
<P>Return a representation of the arguments of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>program</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a lambda list, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if this information is not available.</P>
<P>For example:</P>
<DIV style="MARGIN-LEFT: 3.2em" class=example><PRE class=example>(program-lambda-list
 (lambda* (a b #:optional c #:key (d 1) #:rest e)
   #t)) &#8658;
</PRE></DIV></DD></DL>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Optional-Arguments></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Case_002dlambda" rel=next>Case-lambda</A>, Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Compiled-Procedures" rel=prev>Compiled Procedures</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" rel=up>Procedures</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Optional-Arguments-1></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.9.4 Optional Arguments</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Scheme procedures, as defined in R5RS, can either handle a fixed number of actual arguments, or a fixed number of actual arguments followed by arbitrarily many additional arguments. Writing procedures of variable arity can be useful, but unfortunately, the syntactic means for handling argument lists of varying length is a bit inconvenient. It is possible to give names to the fixed number of arguments, but the remaining (optional) arguments can be only referenced as a list of values (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Lambda">Lambda</A>).</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">For this reason, Guile provides an extension to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda*</CODE>, which allows the user to define procedures with optional and keyword arguments. In addition, Guile&#8217;s virtual machine has low-level support for optional and keyword argument dispatch. Calls to procedures with optional and keyword arguments can be made cheaply, without allocating a rest list.</P>
<TABLE style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=menu border=0 cellSpacing=0>
<TBODY>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=1 href="https://www.gnu.org/software/guile/manual/guile.html#lambda_002a-and-define_002a">lambda* and define*</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>Creating advanced argument handling procedures.</TD></TR>
<TR>
<TD vAlign=top align=left>&#8226;<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=2 href="https://www.gnu.org/software/guile/manual/guile.html#ice_002d9-optargs">ice-9 optargs</A>:</TD>
<TD>&nbsp;&nbsp;</TD>
<TD vAlign=top align=left>(ice-9 optargs) provides some utilities.</TD></TR></TBODY></TABLE>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=lambda_002a-and-define_002a></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#ice_002d9-optargs" rel=next>ice-9 optargs</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments" rel=up>Optional Arguments</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=lambda_002a-and-define_002a_002e></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsubsection>6.9.4.1 lambda* and define*.</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><CODE>lambda*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is like<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda</CODE>, except with some extensions to allow optional and keyword arguments.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-lambda_002a></A>library syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>lambda*</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>([var&#8230;]<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>[#:optional vardef&#8230;]<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>[#:key vardef&#8230; [#:allow-other-keys]]<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>[#:rest var | . var])<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>body1 body2 &#8230;</EM></DT>
<DD><BR>
<P>Create a procedure which takes optional and/or keyword arguments specified with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:optional</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:key</CODE>. For example,</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(lambda* (a b #:optional c d . e) '())
</PRE></DIV>
<P>is a procedure with fixed arguments<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>a</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>b</VAR>, optional arguments<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>c</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>d</VAR>, and rest argument<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>e</VAR>. If the optional arguments are omitted in a call, the variables for them are bound to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE>.</P><A name=index-define_002a></A>
<P>Likewise,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is syntactic sugar for defining procedures using<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda*</CODE>.</P>
<P><CODE>lambda*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>can also make procedures with keyword arguments. For example, a procedure defined like this:</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(define* (sir-yes-sir #:key action how-high)
  (list action how-high))
</PRE></DIV>
<P>can be called as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(sir-yes-sir #:action 'jump)</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(sir-yes-sir #:how-high 13)</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(sir-yes-sir #:action 'lay-down #:how-high 0)</CODE>, or just<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(sir-yes-sir)</CODE>. Whichever arguments are given as keywords are bound to values (and those not given are<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE>).</P>
<P>Optional and keyword arguments can also have default values to take when not present in a call, by giving a two-element list of variable name and expression. For example in</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(define* (frob foo #:optional (bar 42) #:key (baz 73))
  (list foo bar baz))
</PRE></DIV>
<P><VAR>foo</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a fixed argument,<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>bar</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an optional argument with default value 42, and baz is a keyword argument with default value 73. Default value expressions are not evaluated unless they are needed, and until the procedure is called.</P>
<P>Normally it&#8217;s an error if a call has keywords other than those specified by<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:key</CODE>, but adding<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:allow-other-keys</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the definition (after the keyword argument declarations) will ignore unknown keywords.</P>
<P>If a call has a keyword given twice, the last value is used. For example,</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(define* (flips #:key (heads 0) (tails 0))
  (display (list heads tails)))

(flips #:heads 37 #:tails 42 #:heads 99)
-| (99 42)
</PRE></DIV>
<P><CODE>#:rest</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a synonym for the dotted syntax rest argument. The argument lists<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(a . b)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(a #:rest b)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are equivalent in all respects. This is provided for more similarity to DSSSL, MIT-Scheme and Kawa among others, as well as for refugees from other Lisp dialects.</P>
<P>When<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:key</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used together with a rest argument, the keyword parameters in a call all remain in the rest list. This is the same as Common Lisp. For example,</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>((lambda* (#:key (x 0) #:allow-other-keys #:rest r)
   (display r))
 #:x 123 #:y 456)
-| (#:x 123 #:y 456)
</PRE></DIV>
<P><CODE>#:optional</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:key</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>establish their bindings successively, from left to right. This means default expressions can refer back to prior parameters, for example</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(lambda* (start #:optional (end (+ 10 start)))
  (do ((i start (1+ i)))
      ((&gt; i end))
    (display i)))
</PRE></DIV>
<P>The exception to this left-to-right scoping rule is the rest argument. If there is a rest argument, it is bound after the optional arguments, but before the keyword arguments.</P></DD></DL>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=ice_002d9-optargs></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#lambda_002a-and-define_002a" rel=prev>lambda* and define*</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments" rel=up>Optional Arguments</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=g_t_0028ice_002d9-optargs_0029></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsubsection>6.9.4.2 (ice-9 optargs)</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Before Guile 2.0,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>were implemented using macros that processed rest list arguments. This was not optimal, as calling procedures with optional arguments had to allocate rest lists at every procedure invocation. Guile 2.0 improved this situation by bringing optional and keyword arguments into Guile&#8217;s core.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">However there are occasions in which you have a list and want to parse it for optional or keyword arguments. Guile&#8217;s<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(ice-9 optargs)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>provides some macros to help with that task.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The syntax<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let-optional</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let-optional*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are for destructuring rest argument lists and giving names to the various list elements.<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let-optional</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>binds all variables simultaneously, while<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let-optional*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>binds them sequentially, consistent with<CODE>let</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings">Local Bindings</A>).</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-let_002doptional></A>library syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>let-optional</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>rest-arg (binding &#8230;) body1 body2 &#8230;</EM></DT>
<DT><A name=index-let_002doptional_002a></A>library syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>let-optional*</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>rest-arg (binding &#8230;) body1 body2 &#8230;</EM></DT>
<DD>
<P>These two macros give you an optional argument interface that is very<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>Schemey</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>and introduces no fancy syntax. They are compatible with the scsh macros of the same name, but are slightly extended. Each of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>binding</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>may be of one of the forms<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>var</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(<VAR>var</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>default-value</VAR>)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>rest-arg</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>should be the rest-argument of the procedures these are used from. The items in<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>rest-arg</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>are sequentially bound to the variable names are given. When<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>rest-arg</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>runs out, the remaining vars are bound either to the default values or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if no default value was specified.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>rest-arg</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>remains bound to whatever may have been left of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>rest-arg</VAR>.</P>
<P>After binding the variables, the expressions<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>body1</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>body2</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>&#8230; are evaluated in order.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Similarly,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let-keywords</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let-keywords*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>extract values from keyword style argument lists, binding local variables to those values or to defaults.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-let_002dkeywords></A>library syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>let-keywords</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>args allow-other-keys? (binding &#8230;) body1 body2 &#8230;</EM></DT>
<DT><A name=index-let_002dkeywords_002a></A>library syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>let-keywords*</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>args allow-other-keys? (binding &#8230;) body1 body2 &#8230;</EM></DT>
<DD>
<P><VAR>args</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is evaluated and should give a list of the form<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(#:keyword1 value1 #:keyword2 value2 &#8230;)</CODE>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>binding</VAR>s are variables and default expressions, with the variables to be set (by name) from the keyword values. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>body1</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>body2</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>&#8230; forms are then evaluated and the last is the result. An example will make the syntax clearest,</P>
<DIV style="MARGIN-LEFT: 3.2em" class=example><PRE class=example>(define args '(#:xyzzy "hello" #:foo "world"))

(let-keywords args #t
      ((foo  "default for foo")
       (bar  (string-append "default" "for" "bar")))
  (display foo)
  (display ", ")
  (display bar))
-| world, defaultforbar
</PRE></DIV>
<P>The binding for<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>comes from the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword in<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>args</CODE>. But the binding for<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>bar</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the default in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>let-keywords</CODE>, since there&#8217;s no<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:bar</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the args.</P>
<P><VAR>allow-other-keys?</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is evaluated and controls whether unknown keywords are allowed in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>args</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>list. When true other keys are ignored (such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:xyzzy</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the example), when<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>an error is thrown for anything unknown.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><CODE>(ice-9 optargs)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>also provides some more<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>sugar, which is not so useful with modern Guile coding, but still supported:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define*-public</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define-public</CODE>;<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>defmacro*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>defmacro*-public</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>exist for defining macros with the improved argument list handling possibilities. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-public</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>versions not only define the procedures/macros, but also export them from the current module.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-define_002a_002dpublic></A>library syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>define*-public</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>formals body1 body2 &#8230;</EM></DT>
<DD>
<P>Like a mix of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define-public</CODE>.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-defmacro_002a></A>library syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>defmacro*</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>name formals body1 body2 &#8230;</EM></DT>
<DT><A name=index-defmacro_002a_002dpublic></A>library syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>defmacro*-public</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>name formals body1 body2 &#8230;</EM></DT>
<DD>
<P>These are just like<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>defmacro</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>defmacro-public</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>except that they take<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda*</CODE>-style extended parameter lists, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:optional</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:key</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:allow-other-keys</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:rest</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are allowed with the usual semantics. Here is an example of a macro with an optional argument:</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(defmacro* transmogrify (a #:optional b)
  (a 1))
</PRE></DIV></DD></DL>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Case_002dlambda></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Higher_002dOrder-Functions" rel=next>Higher-Order Functions</A>, Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments" rel=prev>Optional Arguments</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" rel=up>Procedures</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Case_002dlambda-1></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.9.5 Case-lambda</H4><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-SRFI_002d16></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-variable-arity></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-arity_002c-variable></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">R5RS&#8217;s rest arguments are indeed useful and very general, but they often aren&#8217;t the most appropriate or efficient means to get the job done. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a much better solution to the optional argument problem than<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda</CODE>with rest arguments.</P><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-case_002dlambda></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Likewise,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>case-lambda</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>works well for when you want one procedure to do double duty (or triple, or ...), without the penalty of consing a rest list.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">For example:</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(define (make-accum n)
  (case-lambda
    (() n)
    ((m) (set! n (+ n m)) n)))

(define a (make-accum 20))
(a) &#8658; 20
(a 10) &#8658; 30
(a) &#8658; 30
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The value returned by a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>case-lambda</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>form is a procedure which matches the number of actual arguments against the formals in the various clauses, in order. The first matching clause is selected, the corresponding values from the actual parameter list are bound to the variable names in the clauses and the body of the clause is evaluated. If no clause matches, an error is signalled.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The syntax of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>case-lambda</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>form is defined in the following EBNF grammar.<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>Formals</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>means a formal argument list just like with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Lambda">Lambda</A>).</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=example><PRE class=example>&lt;case-lambda&gt;
   --&gt; (case-lambda &lt;case-lambda-clause&gt;*)
   --&gt; (case-lambda &lt;docstring&gt; &lt;case-lambda-clause&gt;*)
&lt;case-lambda-clause&gt;
   --&gt; (&lt;formals&gt; &lt;definition-or-command&gt;*)
&lt;formals&gt;
   --&gt; (&lt;identifier&gt;*)
     | (&lt;identifier&gt;* . &lt;identifier&gt;)
     | &lt;identifier&gt;
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Rest lists can be useful with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>case-lambda</CODE>:</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(define plus
  (case-lambda
    "Return the sum of all arguments."
    (() 0)
    ((a) a)
    ((a b) (+ a b))
    ((a b . rest) (apply plus (+ a b) rest))))
(plus 1 2 3) &#8658; 6
</PRE></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-case_002dlambda_002a></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Also, for completeness. Guile defines<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>case-lambda*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>as well, which is like<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>case-lambda</CODE>, except with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lambda*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>clauses. A<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>case-lambda*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause matches if the arguments fill the required arguments, but are not too many for the optional and/or rest arguments.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Keyword arguments are possible with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>case-lambda*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>as well, but they do not contribute to the &#8220;matching&#8221; behavior, and their interactions with required, optional, and rest arguments can be surprising.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">For the purposes of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>case-lambda*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(and of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>case-lambda</CODE>, as a special case), a clause<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>matches</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>if it has enough required arguments, and not too many positional arguments. The required arguments are any arguments before the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:optional</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:key</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:rest</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments.<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>Positional</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments are the required arguments, together with the optional arguments.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In the absence of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:key</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:rest</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments, it&#8217;s easy to see how there could be too many positional arguments: you pass 5 arguments to a function that only takes 4 arguments, including optional arguments. If there is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:rest</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument, there can never be too many positional arguments: any application with enough required arguments for a clause will match that clause, even if there are also<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:key</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Otherwise, for applications to a clause with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:key</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments (and without a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#:rest</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument), a clause will match there only if there are enough required arguments and if the next argument after binding required and optional arguments, if any, is a keyword. For efficiency reasons, Guile is currently unable to include keyword arguments in the matching algorithm. Clauses match on positional arguments only, not by comparing a given keyword to the available set of keyword arguments that a function has.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Some examples follow.</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=example><PRE class=example>(define f
  (case-lambda*
    ((a #:optional b) 'clause-1)
    ((a #:optional b #:key c) 'clause-2)
    ((a #:key d) 'clause-3)
    ((#:key e #:rest f) 'clause-4)))

(f) &#8658; clause-4
(f 1) &#8658; clause-1
(f) &#8658; clause-4
(f #:e 10) clause-1
(f 1 #:foo) clause-1
(f 1 #:c 2) clause-2
(f #:a #:b #:c #:d #:e) clause-4

;; clause-2 will match anything that clause-3 would match.
(f 1 #:d 2) &#8658; error: bad keyword args in clause 2
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Don&#8217;t forget that the clauses are matched in order, and the first matching clause will be taken. This can result in a keyword being bound to a required argument, as in the case of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>f #:e 10</CODE>.</P>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Higher_002dOrder-Functions></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Procedure-Properties" rel=next>Procedure Properties</A>, Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Case_002dlambda" rel=prev>Case-lambda</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" rel=up>Procedures</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Higher_002dOrder-Functions-1></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.9.6 Higher-Order Functions</H4><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-higher_002dorder-functions></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">As a functional programming language, Scheme allows the definition of<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>higher-order functions</EM>, i.e., functions that take functions as arguments and/or return functions. Utilities to derive procedures from other procedures are provided and described below.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-const></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>const</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>value</EM></DT>
<DD>
<P>Return a procedure that accepts any number of arguments and returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>value</VAR>.</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(procedure? (const 3))        &#8658; #t
((const 'hello))              &#8658; hello
((const 'hello) 'world)       &#8658; hello
</PRE></DIV></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-negate></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>negate</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>proc</EM></DT>
<DD>
<P>Return a procedure with the same arity as<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>that returns the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>not</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR>&#8217;s result.</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(procedure? (negate number?)) &#8658; #t
((negate odd?) 2)             &#8658; #t
((negate real?) 'dream)       &#8658; #t
((negate string-prefix?) "GNU" "GNU Guile")
                              &#8658; #f
(filter (negate number?) '(a 2 "b"))
                              &#8658; (a "b")
</PRE></DIV></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-compose></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>compose</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>proc1 proc2 &#8230;</EM></DT>
<DD>
<P>Compose<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc1</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the procedures<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc2</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>&#8230; such that the last<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument is applied first and<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc1</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>last, and return the resulting procedure. The given procedures must have compatible arity.</P>
<DIV style="MARGIN-LEFT: 3.2em" class=lisp><PRE class=lisp>(procedure? (compose 1+ 1-)) &#8658; #t
((compose sqrt 1+ 1+) 2)     &#8658; 2.0
((compose 1+ sqrt) 3)        &#8658; 2.73205080756888
(eq? (compose 1+) 1+)        &#8658; #t

((compose zip unzip2) '((1 2) (a b)))
                             &#8658; ((1 2) (a b))
</PRE></DIV></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-identity></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>identity</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>x</EM></DT>
<DD>
<P>Return X.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-and_003d_003e></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>and=&gt;</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>value proc</EM></DT>
<DD>
<P>When<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>value</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE>, return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE>. Otherwise, return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(<VAR>proc</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>value</VAR>)</CODE>.</P></DD></DL>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Procedure-Properties></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-with-Setters" rel=next>Procedures with Setters</A>, Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Higher_002dOrder-Functions" rel=prev>Higher-Order Functions</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" rel=up>Procedures</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Procedure-Properties-and-Meta_002dinformation></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.9.7 Procedure Properties and Meta-information</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In addition to the information that is strictly necessary to run, procedures may have other associated information. For example, the name of a procedure is information not for the procedure, but about the procedure. This meta-information can be accessed via the procedure properties interface.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The first group of procedures in this meta-interface are predicates to test whether a Scheme object is a procedure, or a special procedure, respectively.<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>procedure?</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the most general predicates, it returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#t</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>for any kind of procedure.</P><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-procedure_003f-2></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-procedure_003f></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>procedure?</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>obj</EM></DT>
<DT><A name=index-scm_005fprocedure_005fp></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_procedure_p</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(obj)</EM></DT>
<DD>
<P>Return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#t</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>obj</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a procedure.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-thunk_003f></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>thunk?</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>obj</EM></DT>
<DT><A name=index-scm_005fthunk_005fp></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_thunk_p</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(obj)</EM></DT>
<DD>
<P>Return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#t</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>obj</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a thunk&#8212;a procedure that does not accept arguments.</P></DD></DL><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-procedure-properties></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Procedure properties are general properties associated with procedures. These can be the name of a procedure or other relevant information, such as debug hints.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-procedure_002dname></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>procedure-name</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>proc</EM></DT>
<DT><A name=index-scm_005fprocedure_005fname></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_procedure_name</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(proc)</EM></DT>
<DD>
<P>Return the name of the procedure<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR></P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-procedure_002dsource></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>procedure-source</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>proc</EM></DT>
<DT><A name=index-scm_005fprocedure_005fsource></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_procedure_source</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(proc)</EM></DT>
<DD>
<P>Return the source of the procedure<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR>. Returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the source code is not available.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-procedure_002dproperties></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>procedure-properties</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>proc</EM></DT>
<DT><A name=index-scm_005fprocedure_005fproperties></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_procedure_properties</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(proc)</EM></DT>
<DD>
<P>Return the properties associated with<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR>, as an association list.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-procedure_002dproperty></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>procedure-property</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>proc key</EM></DT>
<DT><A name=index-scm_005fprocedure_005fproperty></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_procedure_property</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(proc, key)</EM></DT>
<DD>
<P>Return the property of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>with name<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>key</VAR>.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-set_002dprocedure_002dproperties_0021></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>set-procedure-properties!</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>proc alist</EM></DT>
<DT><A name=index-scm_005fset_005fprocedure_005fproperties_005fx></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_set_procedure_properties_x</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(proc, alist)</EM></DT>
<DD>
<P>Set<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR>&#8217;s property list to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>alist</VAR>.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-set_002dprocedure_002dproperty_0021></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>set-procedure-property!</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>proc key value</EM></DT>
<DT><A name=index-scm_005fset_005fprocedure_005fproperty_005fx></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_set_procedure_property_x</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(proc, key, value)</EM></DT>
<DD>
<P>In<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR>&#8217;s property list, set the property named<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>key</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>value</VAR>.</P></DD></DL><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-procedure-documentation></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Documentation for a procedure can be accessed with the procedure<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>procedure-documentation</CODE>.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-procedure_002ddocumentation></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>procedure-documentation</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>proc</EM></DT>
<DT><A name=index-scm_005fprocedure_005fdocumentation></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_procedure_documentation</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(proc)</EM></DT>
<DD>
<P>Return the documentation string associated with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>proc</CODE>. By convention, if a procedure contains more than one expression and the first expression is a string constant, that string is assumed to contain documentation for that procedure.</P></DD></DL>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Procedures-with-Setters></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Next:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=n href="https://www.gnu.org/software/guile/manual/guile.html#Inlinable-Procedures" rel=next>Inlinable Procedures</A>, Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Procedure-Properties" rel=prev>Procedure Properties</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" rel=up>Procedures</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Procedures-with-Setters-1></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.9.8 Procedures with Setters</H4><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-procedure-with-setter></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-setter></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">A<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>procedure with setter</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a special kind of procedure which normally behaves like any accessor procedure, that is a procedure which accesses a data structure. The difference is that this kind of procedure has a so-called<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>setter</EM>attached, which is a procedure for storing something into a data structure.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Procedures with setters are treated specially when the procedure appears in the special form<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>set!</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(REFFIXME). How it works is best shown by example.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Suppose we have a procedure called<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo-ref</CODE>, which accepts two arguments, a value of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and an integer. The procedure returns the value stored at the given index in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>object. Let<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>be a variable containing such a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>data structure.<A href="https://www.gnu.org/software/guile/manual/guile.html#FOOT9" name=DOCF9><SUP>9</SUP></A></P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(foo-ref f 0)       &#8658; bar
(foo-ref f 1)       &#8658; braz
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Also suppose that a corresponding setter procedure called<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo-set!</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>does exist.</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(foo-set! f 0 'bla)
(foo-ref f 0)       &#8658; bla
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Now we could create a new procedure called<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE>, which is a procedure with setter, by calling<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>make-procedure-with-setter</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the accessor and setter procedures<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo-ref</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo-set!</CODE>. Let us call this new procedure<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE>.</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(define foo (make-procedure-with-setter foo-ref foo-set!))
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><CODE>foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>can from now an be used to either read from the data structure stored in<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>f</CODE>, or to write into the structure.</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=lisp><PRE class=lisp>(set! (foo f 0) 'dum)
(foo f 0)          &#8658; dum
</PRE></DIV>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-make_002dprocedure_002dwith_002dsetter></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>make-procedure-with-setter</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>procedure setter</EM></DT>
<DT><A name=index-scm_005fmake_005fprocedure_005fwith_005fsetter></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_make_procedure_with_setter</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(procedure, setter)</EM></DT>
<DD>
<P>Create a new procedure which behaves like<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>procedure</VAR>, but with the associated setter<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>setter</VAR>.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-procedure_002dwith_002dsetter_003f></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>procedure-with-setter?</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>obj</EM></DT>
<DT><A name=index-scm_005fprocedure_005fwith_005fsetter_005fp></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_procedure_with_setter_p</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(obj)</EM></DT>
<DD>
<P>Return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#t</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>obj</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a procedure with an associated setter procedure.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-procedure-1></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>procedure</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>proc</EM></DT>
<DT><A name=index-scm_005fprocedure></A>C Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>scm_procedure</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(proc)</EM></DT>
<DD>
<P>Return the procedure of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR>, which must be an applicable struct.</P></DD></DL>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-setter-1></A>Scheme Procedure:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>setter</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>proc</EM></DT>
<DD>
<P>Return the setter of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>proc</VAR>, which must be either a procedure with setter or an operator struct.</P></DD></DL>
<HR style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Inlinable-Procedures></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=header>
<P>Previous:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=p href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-with-Setters" rel=prev>Procedures with Setters</A>, Up:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A accessKey=u href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" rel=up>Procedures</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>&nbsp; [<A title="Table of contents" href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel=contents>Contents</A>][<A title=Index href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel=index>Index</A>]</P></DIV><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=Inlinable-Procedures-1></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.9.9 Inlinable Procedures</H4><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-inlining></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-procedure-inlining></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">You can define an<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>inlinable procedure</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>by using<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define-inlinable</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define</CODE>. An inlinable procedure behaves the same as a regular procedure, but direct calls will result in the procedure body being inlined into the caller.</P><A style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" name=index-partial-evaluator></A><SPAN style="TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: medium Simsun; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"></SPAN>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Bear in mind that starting from version 2.0.3, Guile has a partial evaluator that can inline the body of inner procedures when deemed appropriate:</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); MARGIN-LEFT: 3.2em; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=example><PRE class=example>scheme@(guile-user)&gt; ,optimize (define (foo x)
                                 (define (bar) (+ x 3))
                                 (* (bar) 2))
$1 = (define foo
       (lambda (#{x 94}#) (* (+ #{x 94}# 3) 2)))
</PRE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The partial evaluator does not inline top-level bindings, though, so this is a situation where you may find it interesting to use<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define-inlinable</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Procedures defined with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>define-inlinable</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>always</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>inlined, at all direct call sites. This eliminates function call overhead at the expense of an increase in code size. Additionally, the caller will not transparently use the new definition if the inline procedure is redefined. It is not possible to trace an inlined procedures or install a breakpoint in it (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://www.gnu.org/software/guile/manual/guile.html#Traps">Traps</A>). For these reasons, you should not make a procedure inlinable unless it demonstrably improves performance in a crucial way.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In general, only small procedures should be considered for inlining, as making large procedures inlinable will probably result in an increase in code size. Additionally, the elimination of the call overhead rarely matters for large procedures.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><A name=index-define_002dinlinable></A>Scheme Syntax:<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>define-inlinable</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>(name parameter &#8230;) body1 body2 &#8230;</EM></DT>
<DD>
<P>Define<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>name</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a procedure with parameters<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>parameter</VAR>s and bodies<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>body1</VAR>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>body2</VAR>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SMALL class=enddots>...</SMALL>.</P></DD></DL>