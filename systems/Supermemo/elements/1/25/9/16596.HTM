In each of the cases below, <VAR>word</VAR> is subject to tilde expansion, parameter expansion, command substitution, and arithmetic expansion. 
<P></P>
<P>When not performing substring expansion, using the form described below, Bash tests for a parameter that is unset or null. Omitting the colon results in <SPAN class=cloze>[...]</SPAN>. </P>
<DL compact>
<DT><CODE>${<VAR>parameter</VAR>:-<VAR>word</VAR>}</CODE> 
<DD>
<P>If <VAR>parameter</VAR> is unset or null, the expansion of <VAR>word</VAR> is substituted. Otherwise, the value of <VAR>parameter</VAR> is substituted. </P>
<DT><CODE>${<VAR>parameter</VAR>:=<VAR>word</VAR>}</CODE> 
<DD>
<P>If <VAR>parameter</VAR> is unset or null, the expansion of <VAR>word</VAR> is assigned to <VAR>parameter</VAR>. The value of <VAR>parameter</VAR> is then substituted. Positional parameters and special parameters may not be assigned to in this way. </P>
<DT><CODE>${<VAR>parameter</VAR>:?<VAR>word</VAR>}</CODE> 
<DD>
<P>If <VAR>parameter</VAR> is null or unset, the expansion of <VAR>word</VAR> (or a message to that effect if <VAR>word</VAR> is not present) is written to the standard error and the shell, if it is not interactive, exits. Otherwise, the value of <VAR>parameter</VAR> is substituted. </P>
<DT><CODE>${<VAR>parameter</VAR>:+<VAR>word</VAR>}</CODE> 
<DD>
<P>If <VAR>parameter</VAR> is null or unset, nothing is substituted, otherwise the expansion of <VAR>word</VAR> is substituted. </P>
<DT><CODE>${<VAR>parameter</VAR>:<VAR>offset</VAR>}</CODE> 
<DT><CODE>${<VAR>parameter</VAR>:<VAR>offset</VAR>:<VAR>length</VAR>}</CODE> 
<DD>
<P>Expands to up to <VAR>length</VAR> characters of <VAR>parameter</VAR> starting at the character specified by <VAR>offset</VAR>. If <VAR>length</VAR> is omitted, expands to the substring of <VAR>parameter</VAR> starting at the character specified by <VAR>offset</VAR>. <VAR>length</VAR> and <VAR>offset</VAR> are arithmetic expressions (see <A href="http://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-Arithmetic">Shell Arithmetic</A>). This is referred to as Substring Expansion. </P>
<P>If <VAR>offset</VAR> evaluates to a number less than zero, the value is used as an offset from the end of the value of <VAR>parameter</VAR>. If <VAR>length</VAR> evaluates to a number less than zero, and <VAR>parameter</VAR> is not &#8216;<SAMP>@</SAMP>&#8217; and not an indexed or associative array, it is interpreted as an offset from the end of the value of <VAR>parameter</VAR> rather than a number of characters, and the expansion is the characters between the two offsets. If <VAR>parameter</VAR> is &#8216;<SAMP>@</SAMP>&#8217;, the result is <VAR>length</VAR> positional parameters beginning at <VAR>offset</VAR>. If <VAR>parameter</VAR> is an indexed array name subscripted by &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the result is the <VAR>length</VAR> members of the array beginning with <CODE>${<VAR>parameter</VAR>[<VAR>offset</VAR>]}</CODE>. A negative <VAR>offset</VAR> is taken relative to one greater than the maximum index of the specified array. Substring expansion applied to an associative array produces undefined results. </P>
<P>Note that a negative offset must be separated from the colon by at least one space to avoid being confused with the &#8216;<SAMP>:-</SAMP>&#8217; expansion. Substring indexing is zero-based unless the positional parameters are used, in which case the indexing starts at 1 by default. If <VAR>offset</VAR> is 0, and the positional parameters are used, <CODE>$@</CODE> is prefixed to the list. </P>
<DT><CODE>${!<VAR>prefix</VAR>*}</CODE> 
<DT><CODE>${!<VAR>prefix</VAR>@}</CODE> 
<DD>
<P>Expands to the names of variables whose names begin with <VAR>prefix</VAR>, separated by the first character of the <CODE>IFS</CODE> special variable. When &#8216;<SAMP>@</SAMP>&#8217; is used and the expansion appears within double quotes, each variable name expands to a separate word. </P>
<DT><CODE>${!<VAR>name</VAR>[@]}</CODE> 
<DT><CODE>${!<VAR>name</VAR>[*]}</CODE> 
<DD>
<P>If <VAR>name</VAR> is an array variable, expands to the list of array indices (keys) assigned in <VAR>name</VAR>. If <VAR>name</VAR> is not an array, expands to 0 if <VAR>name</VAR> is set and null otherwise. When &#8216;<SAMP>@</SAMP>&#8217; is used and the expansion appears within double quotes, each key expands to a separate word. </P>
<DT><CODE>${#<VAR>parameter</VAR>}</CODE> 
<DD>
<P>The length in characters of the expanded value of <VAR>parameter</VAR> is substituted. If <VAR>parameter</VAR> is &#8216;<SAMP>*</SAMP>&#8217; or &#8216;<SAMP>@</SAMP>&#8217;, the value substituted is the number of positional parameters. If <VAR>parameter</VAR> is an array name subscripted by &#8216;<SAMP>*</SAMP>&#8217; or &#8216;<SAMP>@</SAMP>&#8217;, the value substituted is the number of elements in the array. </P>
<DT><CODE>${<VAR>parameter</VAR>#<VAR>word</VAR>}</CODE> 
<DT><CODE>${<VAR>parameter</VAR>##<VAR>word</VAR>}</CODE> 
<DD>
<P>The <VAR>word</VAR> is expanded to produce a pattern just as in filename expansion (see <A href="http://www.gnu.org/software/bash/manual/html_node/Filename-Expansion.html#Filename-Expansion">Filename Expansion</A>). If the pattern matches the beginning of the expanded value of <VAR>parameter</VAR>, then the result of the expansion is the expanded value of <VAR>parameter</VAR> with the shortest matching pattern (the &#8216;<SAMP>#</SAMP>&#8217; case) or the longest matching pattern (the &#8216;<SAMP>##</SAMP>&#8217; case) deleted. If <VAR>parameter</VAR> is &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list. If <VAR>parameter</VAR> is an array variable subscripted with &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list. </P>
<DT><CODE>${<VAR>parameter</VAR>%<VAR>word</VAR>}</CODE> 
<DT><CODE>${<VAR>parameter</VAR>%%<VAR>word</VAR>}</CODE> 
<DD>
<P>The <VAR>word</VAR> is expanded to produce a pattern just as in filename expansion. If the pattern matches a trailing portion of the expanded value of <VAR>parameter</VAR>, then the result of the expansion is the value of <VAR>parameter</VAR> with the shortest matching pattern (the &#8216;<SAMP>%</SAMP>&#8217; case) or the longest matching pattern (the &#8216;<SAMP>%%</SAMP>&#8217; case) deleted. If <VAR>parameter</VAR> is &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list. If <VAR>parameter</VAR> is an array variable subscripted with &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list. </P>
<DT><CODE>${<VAR>parameter</VAR>/<VAR>pattern</VAR>/<VAR>string</VAR>}</CODE> 
<DD>
<P>The <VAR>pattern</VAR> is expanded to produce a pattern just as in filename expansion. <VAR>Parameter</VAR> is expanded and the longest match of <VAR>pattern</VAR> against its value is replaced with <VAR>string</VAR>. If <VAR>pattern</VAR> begins with &#8216;<SAMP>/</SAMP>&#8217;, all matches of <VAR>pattern</VAR> are replaced with <VAR>string</VAR>. Normally only the first match is replaced. If <VAR>pattern</VAR> begins with &#8216;<SAMP>#</SAMP>&#8217;, it must match at the beginning of the expanded value of <VAR>parameter</VAR>. If <VAR>pattern</VAR> begins with &#8216;<SAMP>%</SAMP>&#8217;, it must match at the end of the expanded value of <VAR>parameter</VAR>. If <VAR>string</VAR> is null, matches of <VAR>pattern</VAR> are deleted and the <CODE>/</CODE> following <VAR>pattern</VAR> may be omitted. If <VAR>parameter</VAR> is &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the substitution operation is applied to each positional parameter in turn, and the expansion is the resultant list. If <VAR>parameter</VAR> is an array variable subscripted with &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the substitution operation is applied to each member of the array in turn, and the expansion is the resultant list. </P>
<DT><CODE>${<VAR>parameter</VAR>^<VAR>pattern</VAR>}</CODE> 
<DT><CODE>${<VAR>parameter</VAR>^^<VAR>pattern</VAR>}</CODE> 
<DT><CODE>${<VAR>parameter</VAR>,<VAR>pattern</VAR>}</CODE> 
<DT><CODE>${<VAR>parameter</VAR>,,<VAR>pattern</VAR>}</CODE> 
<DD>
<P>This expansion modifies the case of alphabetic characters in <VAR>parameter</VAR>. The <VAR>pattern</VAR> is expanded to produce a pattern just as in filename expansion. The &#8216;<SAMP>^</SAMP>&#8217; operator converts lowercase letters matching <VAR>pattern</VAR> to uppercase; the &#8216;<SAMP>,</SAMP>&#8217; operator converts matching uppercase letters to lowercase. The &#8216;<SAMP>^^</SAMP>&#8217; and &#8216;<SAMP>,,</SAMP>&#8217; expansions convert each matched character in the expanded value; the &#8216;<SAMP>^</SAMP>&#8217; and &#8216;<SAMP>,</SAMP>&#8217; expansions match and convert only the first character in the expanded value. If <VAR>pattern</VAR> is omitted, it is treated like a &#8216;<SAMP>?</SAMP>&#8217;, which matches every character. If <VAR>parameter</VAR> is &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the case modification operation is applied to each positional parameter in turn, and the expansion is the resultant list. If <VAR>parameter</VAR> is an array variable subscripted with &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the case modification operation is applied to each member of the array in turn, and the expansion is the resultant list.</P></DD></DL>