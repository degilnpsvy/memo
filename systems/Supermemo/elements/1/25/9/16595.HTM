In each of the cases below, <VAR>word</VAR> is subject to tilde expansion, parameter expansion, command substitution, and arithmetic expansion. 
<P></P>
<P>When not performing substring expansion, using the form described below, Bash tests for a parameter that is unset or null. Omitting the colon results in <FONT class=clozed>a test only for a parameter that is unset. Put another way, if the colon is included, the operator tests for both <VAR>parameter</VAR>&#8217;s existence and that its value is not null; if the colon is omitted, the operator tests only for existence</FONT>. </P>
<DL compact>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>:-<VAR>word</VAR>}</CODE> </FONT>
<DD>
<P><FONT class=extract>If <VAR>parameter</VAR> is unset or null, the expansion of <VAR>word</VAR> is substituted. Otherwise, the value of <VAR>parameter</VAR> is substituted.</FONT> </P>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>:=<VAR>word</VAR>}</CODE> </FONT>
<DD>
<P><FONT class=extract>If <VAR>parameter</VAR> is unset or null, the expansion of <VAR>word</VAR> is assigned to <VAR>parameter</VAR>. The value of <VAR>parameter</VAR> is then substituted. Positional parameters and special parameters may not be assigned to in this way.</FONT> </P>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>:?<VAR>word</VAR>}</CODE> </FONT>
<DD>
<P><FONT class=extract>If <VAR>parameter</VAR> is null or unset, the expansion of <VAR>word</VAR> (or a message to that effect if <VAR>word</VAR> is not present) is written to the standard error and the shell, if it is not interactive, exits. Otherwise, the value of <VAR>parameter</VAR> is substituted.</FONT> </P>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>:+<VAR>word</VAR>}</CODE> </FONT>
<DD>
<P><FONT class=extract>If <VAR>parameter</VAR> is null or unset, nothing is substituted, otherwise the expansion of <VAR>word</VAR> is substituted.</FONT> </P>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>:<VAR>offset</VAR>}</CODE> </FONT>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>:<VAR>offset</VAR>:<VAR>length</VAR>}</CODE> </FONT>
<DD>
<P><FONT class=extract>Expands to up to <VAR>length</VAR> characters of <VAR>parameter</VAR> starting at the character specified by <VAR>offset</VAR>. If <VAR>length</VAR> is omitted, expands to the substring of <VAR>parameter</VAR> starting at the character specified by <VAR>offset</VAR>. <VAR>length</VAR> and <VAR>offset</VAR> are arithmetic expressions (see </FONT><A href="http://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html#Shell-Arithmetic"><FONT class=extract>Shell Arithmetic</FONT></A><FONT class=extract>). This is referred to as Substring Expansion. </FONT></P>
<P><FONT class=extract>If <VAR>offset</VAR> evaluates to a number less than zero, the value is used as an offset from the end of the value of <VAR>parameter</VAR>. If <VAR>length</VAR> evaluates to a number less than zero, and <VAR>parameter</VAR> is not &#8216;<SAMP>@</SAMP>&#8217; and not an indexed or associative array, it is interpreted as an offset from the end of the value of <VAR>parameter</VAR> rather than a number of characters, and the expansion is the characters between the two offsets. If <VAR>parameter</VAR> is &#8216;<SAMP>@</SAMP>&#8217;, the result is <VAR>length</VAR> positional parameters beginning at <VAR>offset</VAR>. If <VAR>parameter</VAR> is an indexed array name subscripted by &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the result is the <VAR>length</VAR> members of the array beginning with <CODE>${<VAR>parameter</VAR>[<VAR>offset</VAR>]}</CODE>. A negative <VAR>offset</VAR> is taken relative to one greater than the maximum index of the specified array. Substring expansion applied to an associative array produces undefined results. </FONT></P>
<P><FONT class=extract>Note that a negative offset must be separated from the colon by at least one space to avoid being confused with the &#8216;<SAMP>:-</SAMP>&#8217; expansion. Substring indexing is zero-based unless the positional parameters are used, in which case the indexing starts at 1 by default. If <VAR>offset</VAR> is 0, and the positional parameters are used, <CODE>$@</CODE> is prefixed to the list.</FONT> </P>
<DT><FONT class=extract><CODE>${!<VAR>prefix</VAR>*}</CODE> </FONT>
<DT><FONT class=extract><CODE>${!<VAR>prefix</VAR>@}</CODE> </FONT>
<DD>
<P><FONT class=extract>Expands to the names of variables whose names begin with <VAR>prefix</VAR>, separated by the first character of the <CODE>IFS</CODE> special variable. When &#8216;<SAMP>@</SAMP>&#8217; is used and the expansion appears within double quotes, each variable name expands to a separate word.</FONT> </P>
<DT><FONT class=extract><CODE>${!<VAR>name</VAR>[@]}</CODE> </FONT>
<DT><FONT class=extract><CODE>${!<VAR>name</VAR>[*]}</CODE> </FONT>
<DD>
<P><FONT class=extract>If <VAR>name</VAR> is an array variable, expands to the list of array indices (keys) assigned in <VAR>name</VAR>. If <VAR>name</VAR> is not an array, expands to 0 if <VAR>name</VAR> is set and null otherwise. When &#8216;<SAMP>@</SAMP>&#8217; is used and the expansion appears within double quotes, each key expands to a separate word.</FONT> </P>
<DT><FONT class=extract><CODE>${#<VAR>parameter</VAR>}</CODE> </FONT>
<DD>
<P><FONT class=extract>The length in characters of the expanded value of <VAR>parameter</VAR> is substituted. If <VAR>parameter</VAR> is &#8216;<SAMP>*</SAMP>&#8217; or &#8216;<SAMP>@</SAMP>&#8217;, the value substituted is the number of positional parameters. If <VAR>parameter</VAR> is an array name subscripted by &#8216;<SAMP>*</SAMP>&#8217; or &#8216;<SAMP>@</SAMP>&#8217;, the value substituted is the number of elements in the array.</FONT> </P>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>#<VAR>word</VAR>}</CODE> </FONT>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>##<VAR>word</VAR>}</CODE> </FONT>
<DD>
<P><FONT class=extract>The <VAR>word</VAR> is expanded to produce a pattern just as in filename expansion (see </FONT><A href="http://www.gnu.org/software/bash/manual/html_node/Filename-Expansion.html#Filename-Expansion"><FONT class=extract>Filename Expansion</FONT></A><FONT class=extract>). If the pattern matches the beginning of the expanded value of <VAR>parameter</VAR>, then the result of the expansion is the expanded value of <VAR>parameter</VAR> with the shortest matching pattern (the &#8216;<SAMP>#</SAMP>&#8217; case) or the longest matching pattern (the &#8216;<SAMP>##</SAMP>&#8217; case) deleted. If <VAR>parameter</VAR> is &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list. If <VAR>parameter</VAR> is an array variable subscripted with &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list.</FONT> </P>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>%<VAR>word</VAR>}</CODE> </FONT>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>%%<VAR>word</VAR>}</CODE> </FONT>
<DD>
<P><FONT class=extract>The <VAR>word</VAR> is expanded to produce a pattern just as in filename expansion. If the pattern matches a trailing portion of the expanded value of <VAR>parameter</VAR>, then the result of the expansion is the value of <VAR>parameter</VAR> with the shortest matching pattern (the &#8216;<SAMP>%</SAMP>&#8217; case) or the longest matching pattern (the &#8216;<SAMP>%%</SAMP>&#8217; case) deleted. If <VAR>parameter</VAR> is &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list. If <VAR>parameter</VAR> is an array variable subscripted with &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list.</FONT> </P>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>/<VAR>pattern</VAR>/<VAR>string</VAR>}</CODE> </FONT>
<DD>
<P><FONT class=extract>The <VAR>pattern</VAR> is expanded to produce a pattern just as in filename expansion. <VAR>Parameter</VAR> is expanded and the longest match of <VAR>pattern</VAR> against its value is replaced with <VAR>string</VAR>. If <VAR>pattern</VAR> begins with &#8216;<SAMP>/</SAMP>&#8217;, all matches of <VAR>pattern</VAR> are replaced with <VAR>string</VAR>. Normally only the first match is replaced. If <VAR>pattern</VAR> begins with &#8216;<SAMP>#</SAMP>&#8217;, it must match at the beginning of the expanded value of <VAR>parameter</VAR>. If <VAR>pattern</VAR> begins with &#8216;<SAMP>%</SAMP>&#8217;, it must match at the end of the expanded value of <VAR>parameter</VAR>. If <VAR>string</VAR> is null, matches of <VAR>pattern</VAR> are deleted and the <CODE>/</CODE> following <VAR>pattern</VAR> may be omitted. If <VAR>parameter</VAR> is &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the substitution operation is applied to each positional parameter in turn, and the expansion is the resultant list. If <VAR>parameter</VAR> is an array variable subscripted with &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the substitution operation is applied to each member of the array in turn, and the expansion is the resultant list.</FONT> </P>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>^<VAR>pattern</VAR>}</CODE> </FONT>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>^^<VAR>pattern</VAR>}</CODE> </FONT>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>,<VAR>pattern</VAR>}</CODE> </FONT>
<DT><FONT class=extract><CODE>${<VAR>parameter</VAR>,,<VAR>pattern</VAR>}</CODE> </FONT>
<DD>
<P><FONT class=extract>This expansion modifies the case of alphabetic characters in <VAR>parameter</VAR>. The <VAR>pattern</VAR> is expanded to produce a pattern just as in filename expansion. The &#8216;<SAMP>^</SAMP>&#8217; operator converts lowercase letters matching <VAR>pattern</VAR> to uppercase; the &#8216;<SAMP>,</SAMP>&#8217; operator converts matching uppercase letters to lowercase. The &#8216;<SAMP>^^</SAMP>&#8217; and &#8216;<SAMP>,,</SAMP>&#8217; expansions convert each matched character in the expanded value; the &#8216;<SAMP>^</SAMP>&#8217; and &#8216;<SAMP>,</SAMP>&#8217; expansions match and convert only the first character in the expanded value. If <VAR>pattern</VAR> is omitted, it is treated like a &#8216;<SAMP>?</SAMP>&#8217;, which matches every character. If <VAR>parameter</VAR> is &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the case modification operation is applied to each positional parameter in turn, and the expansion is the resultant list. If <VAR>parameter</VAR> is an array variable subscripted with &#8216;<SAMP>@</SAMP>&#8217; or &#8216;<SAMP>*</SAMP>&#8217;, the case modification operation is applied to each member of the array in turn, and the expansion is the resultant list.</FONT></P></DD></DL>