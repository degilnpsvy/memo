<H2 style="MARGIN: 12pt 0cm 6pt 28.8pt"><SPAN lang=EN-US style="FONT-SIZE: 20pt; mso-bidi-font-size: 14.0pt"><EM><FONT face=&#23435;&#20307;>1.1 # Introduction </FONT></EM></SPAN></H2>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>The goal of this chapter is to explain why it is important for you to learn SystemC. If you already know why you are studying SystemC, then you can jump ahead to Chapter 2. If you are learning SystemC for a college course or because your boss says you must, then you may benefit from this chapter. If your boss doesn&#8217;t know why you need to spend your time learning SystemC, then you may want to show your boss this chapter. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>SystemC is a system design and modeling language. This language evolved to meet a system designer&#8217;s requirements for designing and integrating today&#8217;s complex electronic systems very quickly while assuring that the final system will meet performance expectations. </FONT></SPAN></P>
<P><FONT face=&#23435;&#20307;><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt">Typically, today&#8217;s systems contain both application-specific hardware and software. Furthermore, the hardware and software are usually co-developed on a tight schedule with tight real-time performance constraints and stringent requirements for low power. Thorough functional (and architectural) verification is required to avoid expensive and sometimes catastrophic failures in the device. In some cases, these failures result in the demise of the company or organization designing the errant system. The prevailing name for this concurrent and multi</SPAN><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt; mso-fareast-font-family: &#23435;&#20307;">-</SPAN><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt">disciplinary approach to the design of complex systems is <FONT class=extract>electronic system-level design or ESL</FONT>. </SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>The drive for concurrent engineering through ESL has side effects that affect more than the design organizations of a company. ESL affects the basic business model of a company and how companies interact with their customers and with their suppliers. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>ESL happens by modeling systems at higher levels of abstraction than traditional methods used in the past. Portions of the system model are subsequently iterated and refined, as needed. A set of techniques has evolved called Transaction-Level Modeling or TLM to aide with this task. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>ESL and TLM impose a set of requirements on a language that is different than the requirements for hardware description languages (HDLs) or the requirements for traditional software languages like C, C++[1We will see later that SystemC is actually a C++ class library that &#8220;sits on top&#8221; of C++.], or Java. The authors believe that SystemC is uniquely positioned to meet these requirements. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>We will discuss all these topics in more detail in the following sections. </FONT></SPAN>