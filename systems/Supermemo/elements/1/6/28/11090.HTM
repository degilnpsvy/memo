<HEAD></HEAD>
<BODY>
<H4 style="MARGIN: 12pt 0cm 6pt 43.2pt"><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><EM><FONT face=&#23435;&#20307;>1.2.2.1 # Traditional System Design Approach </FONT></EM></SPAN></H4>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>In the past, when many systems were a more manageable size, a system could be grasped by one person. This person was known by a variety of titles such as system architect, chief engineer, lead engineer, or project engineer. This guru may have been a software engineer, hardware engineer, or algorithm expert depending on the primary technology leveraged for the system. The complexity was such that this person could keep most or all of the details in his or her head. This technical leader was able to use spreadsheets and paper-based methods to communicate thoughts and concepts to the rest of the team. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>The guru&#8217;s background usually dictated his or her success in communicating requirements to each of the communities involved in the design of the system. The guru&#8217;s past experiences also controlled the quality of the multi-disciplinary tradeoffs such as hardware implementation versus software implementation versus algorithm improvements. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>In most cases, these trade-offs resulted in conceptual disconnects among the three groups. For example, cellular telephone systems consist of very complex algorithms, software, and hardware. Teams working on them have traditionally leveraged more rigorous but still ad-hoc methods. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>The ad-hoc methods usually consist of a software-based model. This model is sometimes called a system architectural model (SAM), written in C, Java, or a similar language. The SAM is a communication vehicle between algorithm, hardware, and software groups. The model can be used for algorithmic refinement or used as basis for deriving hardware and software subsystem specifications. The exact parameters modeled are specific to the system type and application, but the model is typically un-timed (more on this topic in the following section). Typically, each team then uses a different language to refine the design for their portion of the system. The teams leave behind the original multi-discipline system model and in many cases, any informal communication among the groups. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>The traditional approach often resulted in each design group working serially with a series of paper specifications being tossed &#8220;over the wall&#8221; to the other organization. This approach also resulted in a fairly serial process that is many times described as a &#8220;waterfall schedule&#8221; or &#8220;transom engineering&#8221; by many program managers and is illustrated in Fig. 1.2.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><?xml:namespace prefix = v /><v:shapetype id=_x0000_t75 stroked="f" filled="f" path="m@4@5l@4@11@9@11@9@5xe" o:preferrelative="t" o:spt="75" coordsize="21600,21600"><v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:connecttype="rect" gradientshapeok="t" o:extrusionok="f"></v:path><?xml:namespace prefix = o /><o:lock aspectratio="t" v:ext="edit"></o:lock></v:shapetype><v:shape id=_x0000_i1025 style="WIDTH: 498.75pt; HEIGHT: 258pt; mso-wrap-distance-left: 0; mso-wrap-distance-right: 0; mso-position-horizontal: left; mso-position-vertical: top; mso-position-vertical-relative: line" filled="t" o:allowoverlap="f" type="#_x0000_t75"><FONT face=&#23435;&#20307;><v:fill color2="black"></v:fill><v:imagedata o:title="" src="file:///C:\DOCUME~1\DONPOP~1\LOCALS~1\Temp\msohtml1\01\clip_image001.png"></v:imagedata></FONT></v:shape></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Fig. 1.2<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>The traditional approach of waterfall scheduling </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>To minimize the serialization of the design process, many techniques have been used to create some design concurrency. These techniques include processor development boards using a single-chip implementation of the processor. These implementations were used on the SoC or embedded system, FPGA prototypes of algorithms, and hardware emulation systems, just to name a few. These techniques were focused on early development of software, usually the last thing completed before a system is deployed. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>The ESL approach uses these existing techniques. ESL also leverages a virtual system prototype or a TLM model of the system to enable all the system design disciplines to work in parallel. This virtual system prototype is the common specification among the groups. The resulting Gantt chart is illustrated next in Fig. 1.3. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Even though all of the electronic system design organizations will finish their tasks earlier, the primary reason for ESL is earlier development of software. Even getting a product to market a month earlier can mean tens of millions of dollars of business to a company. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Not using ESL methods will likely result in the under-design or over-design of the system. Both of these results are not good. Under-design is obviously not good. The product may be bug-free, but it doesn&#8217;t necessarily meet the customer&#8217;s requirements. The product may not operate fast enough, may not have long enough battery life, or just may not have the features required by the customer. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Over-design is not as obvious, but it is not good either. Over-design takes significantly more resources and time to achieve, and it adds a heavy cost to an organization. In addition, over-designed products usually are more complex, more expensive to manufacture, and are not as reliable. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>The authors have significant anecdotal stories of under-design and over-design of systems. One company built an ASIC with multi-processors that made &#8220;timing closure&#8221; and paired those processors with software that made the &#8220;timing budget.&#8221;</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><v:shape id=_x0000_i1026 style="WIDTH: 498.75pt; HEIGHT: 309.75pt; mso-wrap-distance-left: 0; mso-wrap-distance-right: 0; mso-position-horizontal: left; mso-position-vertical: top; mso-position-vertical-relative: line" filled="t" o:allowoverlap="f" type="#_x0000_t75"><FONT face=&#23435;&#20307;><v:fill color2="black"></v:fill><v:imagedata o:title="" src="file:///C:\DOCUME~1\DONPOP~1\LOCALS~1\Temp\msohtml1\01\clip_image003.png"></v:imagedata></FONT></v:shape></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Fig. 1.3<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>The ESL approach of parallel schedule </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Unfortunately, the ASIC didn&#8217;t meet the customers requirements because of &#8220;on chip&#8221; bottlenecks. Another company related how a significant function on a chip caused weeks of schedule slip for design and verification. However, the function was later found not to be used by the software. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>Things become even more interesting if a system, say a cell phone, are really a subsystem for the customer, who is a mobile phone and infrastructure provider. Now, the customer needs models very early in their design process and will be making system design trade-offs based on a model provided by the subsystem provider (previously system). In addition, the subsystem provider likely relies on third-party intellectual property. The subsystem cell phone supplier will then need a model of the intellectual property used in their subsystem very early in the development cycle to enable their design trade-offs. Customers up and down the value chain may now be making business decisions based on the type and quality of the model provided by their supplier. This hierarchy of reliance is fundamentally a different way of doing business. </FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>The virtual system prototype may have different blocks (or components or subsystems) at different levels of abstraction for a particular task to be performed by one of the system disciplines. Initially, most of the system may be very abstract for software development until the software team is reasonably sure of the functionality. At this point, a more detailed model of the blocks that closely interact with the software can be introduced into the model.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 12.0pt"><FONT face=&#23435;&#20307;>The technique that allows this &#8220;mixing and matching&#8221; of blocks at different levels of abstraction is called Transaction-Level Modeling or TLM. We will discuss TLM in much greater detail in the following section. </FONT></SPAN></P></BODY>