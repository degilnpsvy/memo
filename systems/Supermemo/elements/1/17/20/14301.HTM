<H3 class=section>10.7 Old-Fashioned Suffix Rules</H3>
<P><A name=index-old_002dfashioned-suffix-rules-1021></A><A name=index-suffix-rule-1022></A><DFN>Suffix rules</DFN> are the old-fashioned way of defining implicit rules for <CODE>make</CODE>. Suffix rules are obsolete because pattern rules are more general and clearer. They are supported in GNU <CODE>make</CODE> for compatibility with old makefiles. They come in two kinds: <DFN>double-suffix</DFN> and <DFN>single-suffix</DFN>. 
<P>A double-suffix rule is defined by a pair of suffixes: the target suffix and the source suffix. It matches any file whose name ends with the target suffix. The corresponding implicit prerequisite is made by replacing the target suffix with the source suffix in the file name. A two-suffix rule whose target and source suffixes are &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; is equivalent to the pattern rule &#8216;<SAMP><SPAN class=samp>%.o : %.c</SPAN></SAMP>&#8217;. 
<P>A single-suffix rule is defined by a single suffix, which is the source suffix. It matches any file name, and the corresponding implicit prerequisite name is made by appending the source suffix. A single-suffix rule whose source suffix is &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; is equivalent to the pattern rule &#8216;<SAMP><SPAN class=samp>% : %.c</SPAN></SAMP>&#8217;. 
<P>Suffix rule definitions are recognized by comparing each rule's target against a defined list of known suffixes. When <CODE>make</CODE> sees a rule whose target is a known suffix, this rule is considered a single-suffix rule. When <CODE>make</CODE> sees a rule whose target is two known suffixes concatenated, this rule is taken as a double-suffix rule. 
<P>For example, &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; are both on the default list of known suffixes. Therefore, if you define a rule whose target is &#8216;<SAMP><SPAN class=samp>.c.o</SPAN></SAMP>&#8217;, <CODE>make</CODE> takes it to be a double-suffix rule with source suffix &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; and target suffix &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217;. Here is the old-fashioned way to define the rule for compiling a C source file: <PRE class=example>     .c.o:
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;
</PRE>
<P>Suffix rules cannot have any prerequisites of their own. If they have any, they are treated as normal files with funny names, not as suffix rules. Thus, the rule: <PRE class=example>     .c.o: foo.h
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;
</PRE>
<P class=noindent>tells how to make the file <SAMP><SPAN class=file>.c.o</SPAN></SAMP> from the prerequisite file <SAMP><SPAN class=file>foo.h</SPAN></SAMP>, and is not at all like the pattern rule: <PRE class=example>     %.o: %.c foo.h
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;
</PRE>
<P class=noindent>which tells how to make &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; files from &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; files, and makes all &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; files using this pattern rule also depend on <SAMP><SPAN class=file>foo.h</SPAN></SAMP>. 
<P>Suffix rules with no recipe are also meaningless. They do not remove previous rules as do pattern rules with no recipe (see <A href="https://www.gnu.org/software/make/manual/make.html#Canceling-Rules">Canceling Implicit Rules</A>). They simply enter the suffix or pair of suffixes concatenated as a target in the data base. 
<P><A name=index-g_t_002eSUFFIXES-1023></A>The known suffixes are simply the names of the prerequisites of the special target <CODE>.SUFFIXES</CODE>. You can add your own suffixes by writing a rule for <CODE>.SUFFIXES</CODE> that adds more prerequisites, as in: <PRE class=example>     .SUFFIXES: .hack .win
</PRE>
<P class=noindent>which adds &#8216;<SAMP><SPAN class=samp>.hack</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>.win</SPAN></SAMP>&#8217; to the end of the list of suffixes. 
<P>If you wish to eliminate the default known suffixes instead of just adding to them, write a rule for <CODE>.SUFFIXES</CODE> with no prerequisites. By special dispensation, this eliminates all existing prerequisites of <CODE>.SUFFIXES</CODE>. You can then write another rule to add the suffixes you want. For example, <PRE class=example>     .SUFFIXES:            # <SPAN class=roman><FONT face="Times New Roman">Delete the default suffixes</FONT></SPAN>
     .SUFFIXES: .c .o .h   # <SPAN class=roman><FONT face="Times New Roman">Define our suffix list</FONT></SPAN>
</PRE>
<P>The &#8216;<SAMP><SPAN class=samp>-r</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>--no-builtin-rules</SPAN></SAMP>&#8217; flag causes the default list of suffixes to be empty. 
<P><A name=index-SUFFIXES-1024></A>The variable <CODE>SUFFIXES</CODE> is defined to the default list of suffixes before <CODE>make</CODE> reads any makefiles. You can change the list of suffixes with a rule for the special target <CODE>.SUFFIXES</CODE>, but that does not alter this variable.