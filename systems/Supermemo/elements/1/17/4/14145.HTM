<H2><A name=SECTION02255000000000000000>Exercises</A> </H2>
<P>
<OL>
<LI>Consider the planning problem shown in Figure <A href="http://planning.cs.uiuc.edu/node70.html#fig:fivestateb">2.21</A>. Let <SPAN class=MATH><IMG height=17 alt="$ a$" src="http://planning.cs.uiuc.edu/img458.gif" width=15 align=bottom border=0></SPAN> be the initial state, and let <SPAN class=MATH><IMG height=17 alt="$ e$" src="http://planning.cs.uiuc.edu/img307.gif" width=13 align=bottom border=0></SPAN> be the goal state. 
<OL>
<LI>[(a)] Use backward value iteration to determine the stationary cost-to-go. 
<LI>[(b)] Do the same but instead use forward value iteration. </LI></OL>
<P>
<DIV align=center><A name=fig:fivestateb></A><A name=3366></A>
<TABLE>
<CAPTION align=bottom><STRONG>Figure 2.21:</STRONG> Another five-state discrete planning problem.</CAPTION>
<TBODY>
<TR>
<TD><IMG height=84 alt="\begin{figure}\centerline{\psfig{figure=figs/fivestateb.eps,width=4.5in} }\end{figure}" src="http://planning.cs.uiuc.edu/img627.gif" width=517 border=0></TD></TR></TBODY></TABLE></DIV>
<P></P>
<LI>Try to construct a worst-case example for best-first search that has properties similar to that shown in Figure <A href="http://planning.cs.uiuc.edu/node46.html#fig:spiral3d">2.5</A>, but instead involves moving in a 2D world with obstacles, as introduced in Example <A href="http://planning.cs.uiuc.edu/node38.html#exa:disgrid">2.1</A>. 
<P></P>
<LI>It turns out that value iteration can be generalized to a cost functional of the form 
<P></P>
<DIV class=mathdisplay align=center><A name=eqn:discgcf></A><!-- MATH
 \begin{equation}
L(\pi _K) = \sum_{k=1}^K l(x_k,u_k,x_{k+1}) + l_F(x_F) ,
\end{equation}
 -->
<TABLE class=equation cellPadding=0 width="100%" align=center>
<TBODY>
<TR vAlign=center>
<TD noWrap align=middle><SPAN class=MATH><IMG height=77 alt="$\displaystyle L(\pi _K) = \sum_{k=1}^K l(x_k,u_k,x_{k+1}) + l_F(x_F) ,$" src="http://planning.cs.uiuc.edu/img628.gif" width=304 align=middle border=0></SPAN></TD>
<TD class=eqno noWrap align=right width=10>(<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>41</SPAN>)</TD></TR></TBODY></TABLE></DIV><BR clear=all>
<P></P>in which <!-- MATH
 $l(x_k,u_k)$
 --><SPAN class=MATH><IMG height=37 alt="$ l(x_k,u_k)$" src="http://planning.cs.uiuc.edu/img3.gif" width=71 align=middle border=0></SPAN> in (<A href="http://planning.cs.uiuc.edu/node52.html#eqn:discf">2.4</A>) has been replaced by <!-- MATH
 $l(x_k,u_k,x_{k+1})$
 --><SPAN class=MATH><IMG height=37 alt="$ l(x_k,u_k,x_{k+1})$" src="http://planning.cs.uiuc.edu/img629.gif" width=116 align=middle border=0></SPAN>. 
<OL>
<LI>Show that the dynamic programming principle can be applied in this more general setting to obtain forward and backward value iteration methods that solve the fixed-length optimal planning problem. 
<LI>Do the same but for the more general problem of variable-length plans, which uses termination conditions. </LI></OL>
<LI>The cost functional can be generalized to being <EM>stage-dependent</EM>, which means that the cost might depend on the particular stage <SPAN class=MATH><IMG height=17 alt="$ k$" src="http://planning.cs.uiuc.edu/img91.gif" width=15 align=bottom border=0></SPAN> in addition to the state, <SPAN class=MATH><IMG height=33 alt="$ x_k$" src="http://planning.cs.uiuc.edu/img4.gif" width=24 align=middle border=0></SPAN> and the action <SPAN class=MATH><IMG height=33 alt="$ u_k$" src="http://planning.cs.uiuc.edu/img360.gif" width=24 align=middle border=0></SPAN>. Extend the forward and backward value iteration methods of Section <A href="http://planning.cs.uiuc.edu/node53.html#sec:oflp">2.3.1</A> to work for this case, and show that they give optimal solutions. Each term of the more general cost functional should be denoted as <!-- MATH
 $l(x_k,u_k,k)$
 --><SPAN class=MATH><IMG height=37 alt="$ l(x_k,u_k,k)$" src="http://planning.cs.uiuc.edu/img630.gif" width=90 align=middle border=0></SPAN>. 
<LI>Recall from Section <A href="http://planning.cs.uiuc.edu/node56.html#sec:dopgc">2.3.2</A> the method of defining a termination action <SPAN class=MATH><IMG height=33 alt="$ u_T$" src="http://planning.cs.uiuc.edu/img459.gif" width=26 align=middle border=0></SPAN> to make the value iterations work correctly for variable-length planning. Instead of requiring that one remains at the same state, it is also possible to formulate the problem by creating a special state, called the <EM>terminal state</EM>, <SPAN class=MATH><IMG height=33 alt="$ x_T$" src="http://planning.cs.uiuc.edu/img631.gif" width=26 align=middle border=0></SPAN>. Whenever <SPAN class=MATH><IMG height=33 alt="$ u_T$" src="http://planning.cs.uiuc.edu/img459.gif" width=26 align=middle border=0></SPAN> is applied, the state becomes <SPAN class=MATH><IMG height=33 alt="$ x_T$" src="http://planning.cs.uiuc.edu/img631.gif" width=26 align=middle border=0></SPAN>. Describe in detail how to modify the cost functional, state transition equation, and any other necessary components so that the value iterations correctly compute shortest plans. 
<LI>Dijkstra's algorithm was presented as a kind of forward search in Section <A href="http://planning.cs.uiuc.edu/node40.html#sec:gfs">2.2.1</A>. 
<OL>
<LI>Develop a backward version of Dijkstra's algorithm that starts from the goal. Show that it always yields optimal plans. 
<LI>Describe the relationship between the algorithm from part (a) and the backward value iterations from Section <A href="http://planning.cs.uiuc.edu/node56.html#sec:dopgc">2.3.2</A>. 
<LI>Derive a backward version of the <SPAN class=MATH><IMG height=17 alt="$ A^*$" src="http://planning.cs.uiuc.edu/img288.gif" width=26 align=bottom border=0></SPAN> algorithm and show that it yields optimal plans. </LI></OL>
<LI>Reformulate the general forward search algorithm of Section <A href="http://planning.cs.uiuc.edu/node40.html#sec:gfs">2.2.1</A> so that it is expressed in terms of the STRIPS-like representation. Carefully consider what needs to be explicitly constructed by a planning algorithm and what is considered only implicitly. 
<LI>Rather than using bit strings, develop a set-based formulation of the logic-based planning problem. A state in this case can be expressed as a set of positive literals. 
<LI>Extend Formulation <A href="http://planning.cs.uiuc.edu/node59.html#for:strips">2.4</A> to allow disjunctive goal sets (there are alternative sets of literals that must be satisfied). How does this affect the binary string representation? 
<LI>Make a <SPAN class=MATH><IMG height=17 alt="$ Remove$" src="http://planning.cs.uiuc.edu/img632.gif" width=72 align=bottom border=0></SPAN> operator for Example <A href="http://planning.cs.uiuc.edu/node59.html#fig:flashlight">2.17</A> that takes a battery away from the flashlight. For this operator to apply, the battery must be in the flashlight and must not be blocked by another battery. Extend the model to allow enough information for the <SPAN class=MATH><IMG height=17 alt="$ Remove$" src="http://planning.cs.uiuc.edu/img632.gif" width=72 align=bottom border=0></SPAN> operator to function properly. 
<LI>Model the operation of the sliding-tile puzzle in Figure <A href="http://planning.cs.uiuc.edu/node6.html#fig:rubik">1.1</A>b using the STRIPS-like representation. You may use variables in the operator definitions. 
<LI>Find the complete set of plans that are implicitly encoded by Example <A href="http://planning.cs.uiuc.edu/node62.html#exa:pplan">2.7</A>. 
<LI>Explain why, in Formulation <A href="http://planning.cs.uiuc.edu/node59.html#for:strips">2.4</A>, <SPAN class=MATH><IMG height=17 alt="$ G$" src="http://planning.cs.uiuc.edu/img509.gif" width=20 align=bottom border=0></SPAN> needs to include both positive and negative literals, whereas <SPAN class=MATH><IMG height=17 alt="$ S$" src="http://planning.cs.uiuc.edu/img78.gif" width=17 align=bottom border=0></SPAN> only needs positive literals. As an alternative definition, could <SPAN class=MATH><IMG height=17 alt="$ S$" src="http://planning.cs.uiuc.edu/img78.gif" width=17 align=bottom border=0></SPAN> have contained only negative literals? Explain. 
<LI><A name=exe:lightswitch></A>Using Formulation <A href="http://planning.cs.uiuc.edu/node59.html#for:strips">2.4</A>, model a problem in which a robot checks to determine whether a room is dark, moves to a light switch, and flips on the light. Predicates should indicate whether the robot is at the light switch and whether the light is on. Operators that move the robot and flip the switch are needed. 
<LI>Construct a planning graph for the model developed in Exercise <A href="http://planning.cs.uiuc.edu/node70.html#exe:lightswitch">14</A>. 
<LI>Express the model in Exercise <A href="http://planning.cs.uiuc.edu/node70.html#exe:lightswitch">14</A> as a Boolean satisfiability problem. 
<LI>In the worst case, how many terms are needed for the Boolean expression for planning as satisfiability? Express your answer in terms of <SPAN class=MATH><IMG height=37 alt="$ \vert I\vert$" src="http://planning.cs.uiuc.edu/img633.gif" width=25 align=middle border=0></SPAN>, <SPAN class=MATH><IMG height=37 alt="$ \vert P\vert$" src="http://planning.cs.uiuc.edu/img634.gif" width=30 align=middle border=0></SPAN>, <SPAN class=MATH><IMG height=37 alt="$ \vert O\vert$" src="http://planning.cs.uiuc.edu/img635.gif" width=30 align=middle border=0></SPAN>, <SPAN class=MATH><IMG height=37 alt="$ \vert S\vert$" src="http://planning.cs.uiuc.edu/img636.gif" width=28 align=middle border=0></SPAN>, and <SPAN class=MATH><IMG height=37 alt="$ \vert G\vert$" src="http://planning.cs.uiuc.edu/img637.gif" width=30 align=middle border=0></SPAN>. 
<P><BR><B>Implementations</B> <BR>
<P></P>
<LI><A name=exe:astargrid></A>Using <SPAN class=MATH><IMG height=17 alt="$ A^*$" src="http://planning.cs.uiuc.edu/img288.gif" width=26 align=bottom border=0></SPAN> search, the performance degrades substantially when there are many alternative solutions that are all optimal, or at least close to optimal. Implement <SPAN class=MATH><IMG height=17 alt="$ A^*$" src="http://planning.cs.uiuc.edu/img288.gif" width=26 align=bottom border=0></SPAN> search and evaluate it on various grid-based problems, based on Example <A href="http://planning.cs.uiuc.edu/node38.html#exa:disgrid">2.1</A>. Compare the performance for two different cases: 
<OL>
<LI>Using <!-- MATH
 $|i' - i| + |j' - j|$
 --><SPAN class=MATH><IMG height=37 alt="$ \vert i' - i\vert + \vert j' -&#10;j\vert$" src="http://planning.cs.uiuc.edu/img315.gif" width=135 align=middle border=0></SPAN> as the heuristic, as suggested in Section <A href="http://planning.cs.uiuc.edu/node45.html#sec:astar">2.2.2</A>. 
<LI>Using <!-- MATH
 $\sqrt{(i' - i)^2 + (j' - j)^2}$
 --><SPAN class=MATH><IMG height=44 alt="$ \sqrt{(i' - i)^2 + (j' - j)^2}$" src="http://planning.cs.uiuc.edu/img638.gif" width=177 align=middle border=0></SPAN> as the heuristic. </LI></OL>Which heuristic seems superior? Explain your answer. 
<LI>Implement <SPAN class=MATH><IMG height=17 alt="$ A^*$" src="http://planning.cs.uiuc.edu/img288.gif" width=26 align=bottom border=0></SPAN>, breadth-first, and best-first search for grid-based problems. For each search algorithm, design and demonstrate examples for which one is clearly better than the other two. 
<LI>Experiment with bidirectional search for grid-based planning. Try to understand and explain the trade-off between exploring the state space and the cost of connecting the trees. 
<LI>Try to improve the method used to solve Exercise <A href="http://planning.cs.uiuc.edu/node70.html#exe:astargrid">18</A> by detecting when the search might be caught in a local minimum and performing random walks to try to escape. Try using best-first search instead of <SPAN class=MATH><IMG height=17 alt="$ A^*$" src="http://planning.cs.uiuc.edu/img288.gif" width=26 align=bottom border=0></SPAN>. There is great flexibility in possible approaches. Can you obtain better performance on average for any particular examples? 
<LI>Implement backward value iteration and verify its correctness by reconstructing the costs obtained in Example <A href="http://planning.cs.uiuc.edu/node56.html#exa:fivestate3">2.5</A>. Test the implementation on some complicated examples. 
<LI>For a planning problem under Formulation <A href="http://planning.cs.uiuc.edu/node56.html#for:dop">2.3</A>, implement both Dijkstra's algorithm and forward value iteration. Verify that these find the same plans. Comment on their differences in performance. 
<LI>Consider grid-based problems for which there are mostly large, open rooms. Attempt to develop a multi-resolution search algorithm that first attempts to take larger steps, and only takes smaller steps as larger steps fail. Implement your ideas, conduct experiments on examples, and refine your approach accordingly. </LI></OL>