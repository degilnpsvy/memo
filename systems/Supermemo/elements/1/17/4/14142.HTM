<H4><A name=SECTION02252040000000000000>Plan extraction</A> </H4>
<P>Suppose that the planning graph has been constructed up to <SPAN class=MATH><IMG height=34 alt="$ L_i$" src="http://planning.cs.uiuc.edu/img565.gif" width=23 align=middle border=0></SPAN>. At this point, the planning graph can be searched for a solution. If no solution is found and the planning graph has stabilized, then no solution exists to the problem in general (this was shown in [<A href="http://planning.cs.uiuc.edu/node858.html#BluFur95">117</A>]; see also [<A href="http://planning.cs.uiuc.edu/node858.html#GhaNauTra04">382</A>]). If the planning graph has not stabilized, then it can be extended further by adding <SPAN class=MATH><IMG height=34 alt="$ O_i$" src="http://planning.cs.uiuc.edu/img564.gif" width=24 align=middle border=0></SPAN> and <SPAN class=MATH><IMG height=34 alt="$ L_{i+1}$" src="http://planning.cs.uiuc.edu/img566.gif" width=40 align=middle border=0></SPAN>. The extended graph can then be searched for a solution plan. A planning algorithm derived from the planning graph interleaves the graph extensions and the searches for solutions. Either a solution is reported at some point or the algorithm correctly reports that no solution exists after the planning graph stabilizes. The resulting algorithm is complete. One of the key observations in establishing completeness is that the literal and operator layers each increase monotonically as <SPAN class=MATH><IMG height=16 alt="$ i$" src="http://planning.cs.uiuc.edu/img70.gif" width=11 align=bottom border=0></SPAN> increases. Furthermore, the sets of pairs that are mutex decrease monotonically, until all possible conflicts are resolved. 
<P>Rather than obtaining a fully specified plan, the planning graph yields a <EM>layered plan</EM><A name=4135></A>, which is a special form of partial plan. All of the necessary operators are included, and the layered plan is specified as 
<P></P>
<DIV class=mathdisplay align=center><!-- MATH
 \begin{equation}
(A_1,A_2,\ldots,A_k) ,
\end{equation}
 -->
<TABLE class=equation cellPadding=0 width="100%" align=center>
<TBODY>
<TR vAlign=center>
<TD noWrap align=middle><SPAN class=MATH><IMG height=37 alt="$\displaystyle (A_1,A_2,\ldots,A_k) ,$" src="http://planning.cs.uiuc.edu/img583.gif" width=140 align=middle border=0></SPAN></TD>
<TD class=eqno noWrap align=right width=10>(<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>31</SPAN>)</TD></TR></TBODY></TABLE></DIV><BR clear=all>
<P></P>in which each <SPAN class=MATH><IMG height=34 alt="$ A_i$" src="http://planning.cs.uiuc.edu/img584.gif" width=24 align=middle border=0></SPAN> is a set of operators. Within any <SPAN class=MATH><IMG height=34 alt="$ A_i$" src="http://planning.cs.uiuc.edu/img584.gif" width=24 align=middle border=0></SPAN>, the operators are nonmutex and may be applied in any order without altering the state obtained by the layered plan. The only constraint is that for each <SPAN class=MATH><IMG height=16 alt="$ i$" src="http://planning.cs.uiuc.edu/img70.gif" width=11 align=bottom border=0></SPAN> from <SPAN class=MATH><IMG height=17 alt="$ 1$" src="http://planning.cs.uiuc.edu/img43.gif" width=14 align=bottom border=0></SPAN> to <SPAN class=MATH><IMG height=17 alt="$ k$" src="http://planning.cs.uiuc.edu/img91.gif" width=15 align=bottom border=0></SPAN>, every operator in <SPAN class=MATH><IMG height=34 alt="$ A_i$" src="http://planning.cs.uiuc.edu/img584.gif" width=24 align=middle border=0></SPAN> must be applied before any operators in <SPAN class=MATH><IMG height=34 alt="$ A_{i+1}$" src="http://planning.cs.uiuc.edu/img585.gif" width=41 align=middle border=0></SPAN> can be applied. For the flashlight example, a layered plan that would be constructed from the planning graph in Figure <A href="http://planning.cs.uiuc.edu/node66.html#fig:plangraph">2.20</A> is 
<P></P>
<DIV class=mathdisplay align=center><A name=eqn:flashlplan></A><!-- MATH
 \begin{equation}
(\{RemoveCap\},\{Insert(Battery1),Insert(Battery2)\},\{PlaceCap\}) .
\end{equation}
 -->
<TABLE class=equation cellPadding=0 width="100%" align=center>
<TBODY>
<TR vAlign=center>
<TD noWrap align=middle><SPAN class=MATH><IMG height=37 alt="$\displaystyle (\{RemoveCap\},\{Insert(Battery1),Insert(Battery2)\},\{PlaceCap\}) .$" src="http://planning.cs.uiuc.edu/img586.gif" width=574 align=middle border=0></SPAN></TD>
<TD class=eqno noWrap align=right width=10>(<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>32</SPAN>)</TD></TR></TBODY></TABLE></DIV><BR clear=all>
<P></P>To obtain a fully specified plan, the layered plan needs to be linearized by specifying a linear ordering for the operators that is consistent with the layer constraints. For (<A href="http://planning.cs.uiuc.edu/node67.html#eqn:flashlplan">2.32</A>), this results in (<A href="http://planning.cs.uiuc.edu/node59.html#eqn:flashplan">2.24</A>). The actual plan execution usually involves more stages than the number in the planning graph. For complicated planning problems, this difference is expected to be huge. With a small number of stages, the planning graph can consider very long plans because it can apply several nonmutex operators in a single layer. 
<P>At each level, the search for a plan could be quite costly. The idea is to start from <SPAN class=MATH><IMG height=34 alt="$ L_i$" src="http://planning.cs.uiuc.edu/img565.gif" width=23 align=middle border=0></SPAN> and perform a backward <EM>and/or search</EM>. To even begin the search, the goal literals <SPAN class=MATH><IMG height=17 alt="$ G$" src="http://planning.cs.uiuc.edu/img509.gif" width=20 align=bottom border=0></SPAN> must be a subset of <SPAN class=MATH><IMG height=34 alt="$ L_i$" src="http://planning.cs.uiuc.edu/img565.gif" width=23 align=middle border=0></SPAN>, and no pairs are allowed to be mutex; otherwise, immediate failure is declared. From each literal <SPAN class=MATH><IMG height=34 alt="$ l \in G$" src="http://planning.cs.uiuc.edu/img587.gif" width=49 align=middle border=0></SPAN>, an ``or'' part of the search tries possible operators that produce <SPAN class=MATH><IMG height=17 alt="$ l$" src="http://planning.cs.uiuc.edu/img549.gif" width=11 align=bottom border=0></SPAN> as an effect. The ``and'' part of the search must achieve all literals in the precondition of an operator chosen at the previous ``or'' level. Each of these preconditions must be achieved, which leads to another ``or'' level in the search. The idea is applied recursively until the initial set <SPAN class=MATH><IMG height=34 alt="$ L_1$" src="http://planning.cs.uiuc.edu/img123.gif" width=25 align=middle border=0></SPAN> of literals is obtained. During the and/or search, the computed mutex relations provide information that immediately eliminates some branches. Frequently, triples and higher order tuples are checked for being mutex together, even though they are not pairwise mutex. A hash table is constructed to efficiently retrieve this information as it is considered multiple times in the search. Although the plan extraction is quite costly, superior performance was shown in [<A href="http://planning.cs.uiuc.edu/node858.html#BluFur95">117</A>] on several important benchmarks. In the worst case, the search could require exponential time (otherwise, a polynomial-time algorithm would have been found to an NP-hard problem). <A name=3184></A>