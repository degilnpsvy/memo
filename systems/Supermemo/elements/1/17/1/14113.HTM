<H2><A name=SECTION02212000000000000000><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>1</SPAN>.<SPAN class=arabic>2</SPAN> Examples of Discrete Planning</A> </H2>
<P>
<P>
<DIV><A name=exa:disgrid><B>Example <SPAN class=arabic>2</SPAN>..<SPAN class=arabic>1</SPAN></B></A> (Moving on a 2D Grid) &nbsp; <A name=2388></A>Suppose that a robot moves on a grid in which each grid point has integer coordinates of the form <SPAN class=MATH><IMG height=37 alt="$ (i,j)$" src="http://planning.cs.uiuc.edu/img146.gif" width=43 align=middle border=0></SPAN>. The robot takes discrete steps in one of four directions (up, down, left, right), each of which increments or decrements one coordinate. The motions and corresponding state transition graph are shown in Figure <A href="http://planning.cs.uiuc.edu/node38.html#fig:disgrid">2.1</A>, which can be imagined as stepping from tile to tile on an infinite tile floor. 
<P>
<DIV align=center><A name=fig:disgrid></A><A name=3331></A>
<TABLE>
<CAPTION align=bottom><STRONG>Figure 2.1:</STRONG> The state transition graph for an example problem that involves walking around on an infinite tile floor. </CAPTION>
<TBODY>
<TR>
<TD><IMG height=327 alt="\begin{figure}\centerline{\psfig{figure=figs/disgrid.idr,width=3.0in} }\end{figure}" src="http://planning.cs.uiuc.edu/img267.gif" width=340 border=0></TD></TR></TBODY></TABLE></DIV>
<P>This will be expressed using Formulation <A href="http://planning.cs.uiuc.edu/node37.html#for:dfp">2.1</A>. Let <SPAN class=MATH><IMG height=17 alt="$ X$" src="http://planning.cs.uiuc.edu/img8.gif" width=22 align=bottom border=0></SPAN> be the set of all integer pairs of the form <SPAN class=MATH><IMG height=37 alt="$ (i,j)$" src="http://planning.cs.uiuc.edu/img146.gif" width=43 align=middle border=0></SPAN>, in which <!-- MATH
 $i,j \in
{\mathbb{Z}}$
 --><SPAN class=MATH><IMG height=34 alt="$ i,j \in&#10;{\mathbb{Z}}$" src="http://planning.cs.uiuc.edu/img268.gif" width=64 align=middle border=0></SPAN> (<!-- MATH
 ${\mathbb{Z}}$
 --> <SPAN class=MATH><IMG height=17 alt="$ {\mathbb{Z}}$" src="http://planning.cs.uiuc.edu/img269.gif" width=18 align=bottom border=0></SPAN> denotes the set of all integers). Let <!-- MATH
 $U =
\{(0,1),(0,-1),(1,0),(-1,0)\}$
 --><SPAN class=MATH><IMG height=37 alt="$ U =&#10;\{(0,1),(0,-1),(1,0),(-1,0)\}$" src="http://planning.cs.uiuc.edu/img270.gif" width=285 align=middle border=0></SPAN>. Let <SPAN class=MATH><IMG height=37 alt="$ U(x) = U$" src="http://planning.cs.uiuc.edu/img271.gif" width=84 align=middle border=0></SPAN> for all <SPAN class=MATH><IMG height=34 alt="$ x \in X$" src="http://planning.cs.uiuc.edu/img228.gif" width=56 align=middle border=0></SPAN>. The state transition equation is <!-- MATH
 $f(x,u) = x + u$
 --><SPAN class=MATH><IMG height=37 alt="$ f(x,u) = x + u$" src="http://planning.cs.uiuc.edu/img272.gif" width=130 align=middle border=0></SPAN>, in which <SPAN class=MATH><IMG height=34 alt="$ x \in X$" src="http://planning.cs.uiuc.edu/img228.gif" width=56 align=middle border=0></SPAN> and <SPAN class=MATH><IMG height=34 alt="$ u \in U$" src="http://planning.cs.uiuc.edu/img273.gif" width=54 align=middle border=0></SPAN> are treated as two-dimensional vectors for the purpose of addition. For example, if <SPAN class=MATH><IMG height=37 alt="$ x = (3,4)$" src="http://planning.cs.uiuc.edu/img274.gif" width=82 align=middle border=0></SPAN> and <SPAN class=MATH><IMG height=37 alt="$ u = (0,1)$" src="http://planning.cs.uiuc.edu/img275.gif" width=82 align=middle border=0></SPAN>, then <!-- MATH
 $f(x,u) = (3,5)$
 --><SPAN class=MATH><IMG height=37 alt="$ f(x,u) = (3,5)$" src="http://planning.cs.uiuc.edu/img276.gif" width=127 align=middle border=0></SPAN>. Suppose for convenience that the initial state is <!-- MATH
 ${x_{I}}= (0,0)$
 --><SPAN class=MATH><IMG height=37 alt="$ {x_{I}}= (0,0)$" src="http://planning.cs.uiuc.edu/img277.gif" width=90 align=middle border=0></SPAN>. Many interesting goal sets are possible. Suppose, for example, that <!-- MATH
 ${X_{G}}= \{(100,100)\}$
 --><SPAN class=MATH><IMG height=37 alt="$ {X_{G}}= \{(100,100)\}$" src="http://planning.cs.uiuc.edu/img278.gif" width=155 align=middle border=0></SPAN>. It is easy to find a sequence of actions that transforms the state from <SPAN class=MATH><IMG height=37 alt="$ (0,0)$" src="http://planning.cs.uiuc.edu/img279.gif" width=46 align=middle border=0></SPAN> to <SPAN class=MATH><IMG height=37 alt="$ (100,100)$" src="http://planning.cs.uiuc.edu/img280.gif" width=84 align=middle border=0></SPAN>. 
<P>
<DIV align=center><A name=fig:labyrinth></A><A name=3333></A>
<TABLE>
<CAPTION align=bottom><STRONG>Figure 2.2:</STRONG> Interesting planning problems that involve exploring a labyrinth can be made by shading in tiles.</CAPTION>
<TBODY>
<TR>
<TD><IMG height=231 alt="\begin{figure}\centerline{\psfig{figure=figs/disgrid2.idr,width=3.0in} }\end{figure}" src="http://planning.cs.uiuc.edu/img281.gif" width=345 border=0></TD></TR></TBODY></TABLE></DIV>
<P>The problem can be made more interesting by shading in some of the square tiles to represent obstacles that the robot must avoid, as shown in Figure <A href="http://planning.cs.uiuc.edu/node38.html#fig:labyrinth">2.2</A>. In this case, any tile that is shaded has its corresponding vertex and associated edges deleted from the state transition graph. An outer boundary can be made to fence in a bounded region so that <SPAN class=MATH><IMG height=17 alt="$ X$" src="http://planning.cs.uiuc.edu/img8.gif" width=22 align=bottom border=0></SPAN> becomes finite. Very complicated labyrinths can be constructed. <!-- MATH
 $\blacksquare$
 --><SPAN class=MATH><IMG height=16 alt="$ \blacksquare$" src="http://planning.cs.uiuc.edu/img282.gif" width=20 align=bottom border=0></SPAN> <BR></P></DIV>
<P></P>
<P><A name=2401></A><A name=2402></A>
<P>
<DIV><A name=exa:rubiks><B>Example <SPAN class=arabic>2</SPAN>..<SPAN class=arabic>2</SPAN></B></A> (Rubik's Cube Puzzle) &nbsp; Many puzzles can be expressed as discrete planning problems. For example, the Rubik's cube is a puzzle that looks like an array of <!-- MATH
 $3
\times 3 \times 3$
 --><SPAN class=MATH><IMG height=33 alt="$ 3&#10;\times 3 \times 3$" src="http://planning.cs.uiuc.edu/img283.gif" width=79 align=middle border=0></SPAN> little cubes, which together form a larger cube as shown in Figure <A href="http://planning.cs.uiuc.edu/node6.html#fig:rubik">1.1</A>a (Section <A href="http://planning.cs.uiuc.edu/node5.html#sec:ill">1.2</A>). Each face of the larger cube is painted one of six colors. An action may be applied to the cube by rotating a <!-- MATH
 $3 \times 3$
 --><SPAN class=MATH><IMG height=33 alt="$ 3 \times 3$" src="http://planning.cs.uiuc.edu/img158.gif" width=47 align=middle border=0></SPAN> sheet of cubes by 90 degrees. After applying many actions to the Rubik's cube, each face will generally be a jumble of colors. The state space is the set of configurations for the cube (the orientation of the entire cube is irrelevant). For each state there are 12 possible actions. For some arbitrarily chosen configuration of the Rubik's cube, the planning task is to find a sequence of actions that returns it to the configuration in which each one of its six faces is a single color. <!-- MATH
 $\blacksquare$
 --><SPAN class=MATH><IMG height=16 alt="$ \blacksquare$" src="http://planning.cs.uiuc.edu/img282.gif" width=20 align=bottom border=0></SPAN> <BR></DIV>
<P></P>
<P>It is important to note that a planning problem is usually specified without explicitly representing the entire state transition graph. Instead, it is revealed incrementally in the planning process. In Example <A href="http://planning.cs.uiuc.edu/node38.html#exa:disgrid">2.1</A>, very little information actually needs to be given to specify a graph that is infinite in size. If a planning problem is given as input to an algorithm, close attention must be paid to the encoding when performing a complexity analysis. For a problem in which <SPAN class=MATH><IMG height=17 alt="$ X$" src="http://planning.cs.uiuc.edu/img8.gif" width=22 align=bottom border=0></SPAN> is infinite, the input length must still be finite. For some interesting classes of problems it may be possible to compactly specify a model that is equivalent to Formulation <A href="http://planning.cs.uiuc.edu/node37.html#for:dfp">2.1</A>. Such representation issues have been the basis of much research in artificial intelligence over the past decades as different representation logics have been proposed; see Section <A href="http://planning.cs.uiuc.edu/node58.html#sec:logic">2.4</A> and [<A href="http://planning.cs.uiuc.edu/node858.html#GhaNauTra04">382</A>]. In a sense, these representations can be viewed as input compression schemes. 
<P>Readers experienced in computer engineering might recognize that when <SPAN class=MATH><IMG height=17 alt="$ X$" src="http://planning.cs.uiuc.edu/img8.gif" width=22 align=bottom border=0></SPAN> is finite, Formulation <A href="http://planning.cs.uiuc.edu/node37.html#for:dfp">2.1</A> appears almost identical to the definition of a <EM>finite state machine</EM><A name=3430></A> or <EM>Mealy/Moore machines</EM><A name=3432></A>. Relating the two models, the actions can be interpreted as <EM>inputs</EM> to the state machine, and the output of the machine simply reports its state. Therefore, the feasible planning problem (if <SPAN class=MATH><IMG height=17 alt="$ X$" src="http://planning.cs.uiuc.edu/img8.gif" width=22 align=bottom border=0></SPAN> is finite) may be interpreted as determining whether there exists a sequence of inputs that makes a finite state machine eventually report a desired output. From a planning perspective, it is assumed that the planning algorithm has a complete specification of the machine transitions and is able to read its current state at any time. 
<P>Readers experienced with theoretical computer science may observe similar connections to a <EM>deterministic finite automaton</EM><A name=3434></A> (DFA), which is a special kind of finite state machine that reads an <EM>input string</EM> and makes a decision about whether to <EM>accept</EM> or <EM>reject</EM> the string. The input string is just a finite sequence of inputs, in the same sense as for a finite state machine. A DFA definition includes a set of <EM>accept states</EM>, which in the planning context can be renamed to the <EM>goal set</EM>. This makes the feasible planning problem (if <SPAN class=MATH><IMG height=17 alt="$ X$" src="http://planning.cs.uiuc.edu/img8.gif" width=22 align=bottom border=0></SPAN> is finite) equivalent to determining whether there exists an input string that is accepted by a given DFA. Usually, a <EM>language</EM><A name=3436></A><A name=2423></A> is associated with a DFA, which is the set of all strings it accepts. DFAs are important in the theory of computation because their languages correspond precisely to regular expressions. The planning problem amounts to determining whether the empty language is associated with the DFA. 
<P>Thus, there are several ways to represent and interpret the discrete feasible planning problem that sometimes lead to a very compact, implicit encoding of the problem. This issue will be revisited in Section <A href="http://planning.cs.uiuc.edu/node58.html#sec:logic">2.4</A>. Until then, basic planning algorithms are introduced in Section <A href="http://planning.cs.uiuc.edu/node39.html#sec:search">2.2</A>, and discrete optimal planning is covered in Section <A href="http://planning.cs.uiuc.edu/node52.html#sec:disopt">2.3</A>.