<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>1</SPAN> General Forward Search 
<DIV align=center><A name=fig:gfs></A><A name=3335></A>
<TABLE>
<CAPTION align=bottom><STRONG>Figure 2.4:</STRONG> A general template for forward search. </CAPTION>
<TBODY>
<TR>
<TD><IMG height=330 alt="\begin{figure}\noindent \rule{\columnwidth}{0.25mm}&#10;FORWARD\_SEARCH \\&#10;\begin{t...&#10;... return} FAILURE \\&#10;\end{tabular} \\&#10;\rule{\columnwidth}{0.25mm}\end{figure}" src="http://planning.cs.uiuc.edu/img285.gif" width=556 border=0></TD></TR></TBODY></TABLE></DIV>
<P><A name=2466></A>Figure <A href="http://planning.cs.uiuc.edu/node40.html#fig:gfs">2.4</A> gives a general template of search algorithms, expressed using the state-space representation. At any point during the search, there will be three kinds of states: 
<OL>
<LI><B>Unvisited: </B><A name=2470></A>States that have not been visited yet. Initially, this is every state except <SPAN class=MATH><IMG height=33 alt="$ {x_{I}}$" src="http://planning.cs.uiuc.edu/img261.gif" width=23 align=middle border=0></SPAN>. 
<LI><B>Dead: </B><A name=2472></A>States that have been visited, and for which every possible next state has also been visited. A <EM>next state</EM> of <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN> is a state <SPAN class=MATH><IMG height=18 alt="$ x'$" src="http://planning.cs.uiuc.edu/img254.gif" width=20 align=bottom border=0></SPAN> for which there exists a <!-- MATH
 $u \in
U(x)$
 --><SPAN class=MATH><IMG height=37 alt="$ u \in U(x)$" src="http://planning.cs.uiuc.edu/img156.gif" width=79 align=middle border=0></SPAN> such that <!-- MATH
 $x' = f(x,u)$
 --><SPAN class=MATH><IMG height=37 alt="$ x' = f(x,u)$" src="http://planning.cs.uiuc.edu/img264.gif" width=100 align=middle border=0></SPAN>. In a sense, these states are <I>dead</I> because there is nothing more that they can contribute to the search; there are no new leads that could help in finding a feasible plan. Section <A href="http://planning.cs.uiuc.edu/node57.html#sec:dijrev">2.3.3</A> discusses a variant in which dead states can become alive again in an effort to obtain optimal plans. 
<LI><B>Alive: </B><A name=2477></A>States that have been encountered, but possibly have unvisited next states. These are considered <I>alive</I>. Initially, the only alive state is <SPAN class=MATH><IMG height=33 alt="$ {x_{I}}$" src="http://planning.cs.uiuc.edu/img261.gif" width=23 align=middle border=0></SPAN>. </LI></OL>
<P>The set of alive states is stored in a priority queue, <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN>, for which a priority function must be specified. The only significant difference between various search algorithms is the particular function used to sort <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN>. Many variations will be described later, but for the time being, it might be helpful to pick one. Therefore, assume for now that <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN> is a common FIFO (First-In First-Out) queue; whichever state has been waiting the longest will be chosen when <!-- MATH
 ${Q}.GetFirst()$
 --><SPAN class=MATH><IMG height=37 alt="$ {Q}.GetFirst()$" src="http://planning.cs.uiuc.edu/img286.gif" width=115 align=middle border=0></SPAN> is called. The rest of the general search algorithm is quite simple. Initially, <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN> contains the initial state <SPAN class=MATH><IMG height=33 alt="$ {x_{I}}$" src="http://planning.cs.uiuc.edu/img261.gif" width=23 align=middle border=0></SPAN>. A <B>while</B> loop is then executed, which terminates only when <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN> is empty. This will only occur when the entire graph has been explored without finding any goal states, which results in a FAILURE (unless the reachable portion of <SPAN class=MATH><IMG height=17 alt="$ X$" src="http://planning.cs.uiuc.edu/img8.gif" width=22 align=bottom border=0></SPAN> is infinite, in which case the algorithm should never terminate). In each <B>while</B> iteration, the highest ranked element, <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN>, of <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN> is removed. If <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN> lies in <SPAN class=MATH><IMG height=34 alt="$ {X_{G}}$" src="http://planning.cs.uiuc.edu/img140.gif" width=32 align=middle border=0></SPAN>, then it reports SUCCESS and terminates; otherwise, the algorithm tries applying every possible action, <!-- MATH
 $u \in U(x)$
 --><SPAN class=MATH><IMG height=37 alt="$ u \in U(x)$" src="http://planning.cs.uiuc.edu/img156.gif" width=79 align=middle border=0></SPAN>. For each next state, <!-- MATH
 $x' = f(x,u)$
 --><SPAN class=MATH><IMG height=37 alt="$ x' = f(x,u)$" src="http://planning.cs.uiuc.edu/img264.gif" width=100 align=middle border=0></SPAN>, it must determine whether <SPAN class=MATH><IMG height=18 alt="$ x'$" src="http://planning.cs.uiuc.edu/img254.gif" width=20 align=bottom border=0></SPAN> is being encountered for the first time. If it is unvisited, then it is inserted into <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN>; otherwise, there is no need to consider it because it must be either dead or already in <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN>. 
<P>The algorithm description in Figure <A href="http://planning.cs.uiuc.edu/node40.html#fig:gfs">2.4</A> omits several details that often become important in practice. For example, how efficient is the test to determine whether <!-- MATH
 $x \in {X_{G}}$
 --><SPAN class=MATH><IMG height=34 alt="$ x \in {X_{G}}$" src="http://planning.cs.uiuc.edu/img287.gif" width=66 align=middle border=0></SPAN> in line 4? This depends, of course, on the size of the state space and on the particular representations chosen for <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN> and <SPAN class=MATH><IMG height=34 alt="$ {X_{G}}$" src="http://planning.cs.uiuc.edu/img140.gif" width=32 align=middle border=0></SPAN>. At this level, we do not specify a particular method because the representations are not given. 
<P>One important detail is that the existing algorithm only indicates whether a solution exists, but does not seem to produce a plan, which is a sequence of actions that achieves the goal. This can be fixed by inserting a line after line 7 that associates with <SPAN class=MATH><IMG height=18 alt="$ x'$" src="http://planning.cs.uiuc.edu/img254.gif" width=20 align=bottom border=0></SPAN> its parent, <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN>. If this is performed each time, one can simply trace the pointers from the final state to the initial state to recover the plan. For convenience, one might also store which action was taken, in addition to the pointer from <SPAN class=MATH><IMG height=18 alt="$ x'$" src="http://planning.cs.uiuc.edu/img254.gif" width=20 align=bottom border=0></SPAN> to <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN>. 
<P>Lines 8 and 9 are conceptually simple, but how can one tell whether <SPAN class=MATH><IMG height=18 alt="$ x'$" src="http://planning.cs.uiuc.edu/img254.gif" width=20 align=bottom border=0></SPAN> has been visited? For some problems the state transition graph might actually be a tree, which means that there are no repeated states. Although this does not occur frequently, it is wonderful when it does because there is no need to check whether states have been visited. If the states in <SPAN class=MATH><IMG height=17 alt="$ X$" src="http://planning.cs.uiuc.edu/img8.gif" width=22 align=bottom border=0></SPAN> all lie on a grid, one can simply make a lookup table that can be accessed in constant time to determine whether a state has been visited. In general, however, it might be quite difficult because the state <SPAN class=MATH><IMG height=18 alt="$ x'$" src="http://planning.cs.uiuc.edu/img254.gif" width=20 align=bottom border=0></SPAN> must be compared with every other state in <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN> and with all of the dead states.<A name=2483></A> If the representation of each state is long, as is sometimes the case, this will be very costly. A good hashing scheme or another clever data structure can greatly alleviate this cost, but in many applications the computation time will remain high. One alternative is to simply allow repeated states, but this could lead to an increase in computational cost that far outweighs the benefits. Even if the graph is very small, search algorithms could run in time exponential in the size of the state transition graph, or the search may not terminate at all, even if the graph is finite. 
<P>One final detail is that some search algorithms will require a cost to be computed and associated with every state. If the same state is reached multiple times, the cost may have to be updated, which is performed in line 12, if the particular search algorithm requires it. Such costs may be used in some way to sort the priority queue, or they may enable the recovery of the plan on completion of the algorithm. Instead of storing pointers, as mentioned previously, the optimal cost to return to the initial state could be stored with each state. This cost alone is sufficient to determine the action sequence that leads to any visited state. Starting at a visited state, the path back to <SPAN class=MATH><IMG height=33 alt="$ {x_{I}}$" src="http://planning.cs.uiuc.edu/img261.gif" width=23 align=middle border=0></SPAN> can be obtained by traversing the state transition graph backward in a way that decreases the cost as quickly as possible in each step. For this to succeed, the costs must have a certain monotonicity property, which is obtained by Dijkstra's algorithm and <SPAN class=MATH><IMG height=17 alt="$ A^*$" src="http://planning.cs.uiuc.edu/img288.gif" width=26 align=bottom border=0></SPAN> search, and will be introduced in Section <A href="http://planning.cs.uiuc.edu/node41.html#sec:partsearch">2.2.2</A>. More generally, the costs must form a <EM>navigation function</EM><A name=3512></A>, which is considered in Section <A href="http://planning.cs.uiuc.edu/node368.html#sec:compfb">8.2.2</A> as feedback is incorporated into discrete planning. <A name=2487></A>