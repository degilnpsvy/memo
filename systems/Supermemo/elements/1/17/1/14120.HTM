A-star 
<P><A name=2523></A><A name=2524></A>The <SPAN class=MATH><IMG height=17 alt="$ A^*$" src="http://planning.cs.uiuc.edu/img288.gif" width=26 align=bottom border=0></SPAN> (pronounced ``ay star'') search algorithm is an extension of Dijkstra's algorithm that tries to reduce the total number of states explored by incorporating a heuristic estimate of the cost to get to the goal from a given state. Let <SPAN class=MATH><IMG height=37 alt="$ {C}(x)$" src="http://planning.cs.uiuc.edu/img304.gif" width=45 align=middle border=0></SPAN> denote the cost-to-come from <SPAN class=MATH><IMG height=33 alt="$ {x_{I}}$" src="http://planning.cs.uiuc.edu/img261.gif" width=23 align=middle border=0></SPAN> to <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN>, and let <SPAN class=MATH><IMG height=37 alt="$ {G}(x)$" src="http://planning.cs.uiuc.edu/img313.gif" width=45 align=middle border=0></SPAN> denote the cost-to-go<A name=2525></A> from <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN> to some state in <SPAN class=MATH><IMG height=34 alt="$ {X_{G}}$" src="http://planning.cs.uiuc.edu/img140.gif" width=32 align=middle border=0></SPAN>. It is convenient that <SPAN class=MATH><IMG height=37 alt="$ C^*(x)$" src="http://planning.cs.uiuc.edu/img303.gif" width=52 align=middle border=0></SPAN> can be computed incrementally by dynamic programming; however, there is no way to know the true optimal cost-to-go, <SPAN class=MATH><IMG height=17 alt="$ G^*$" src="http://planning.cs.uiuc.edu/img224.gif" width=27 align=bottom border=0></SPAN>, in advance. Fortunately, in many applications it is possible to construct a reasonable underestimate of this cost. As an example of a typical underestimate, consider planning in the labyrinth depicted in Figure <A href="http://planning.cs.uiuc.edu/node38.html#fig:labyrinth">2.2</A>. Suppose that the cost is the total number of steps in the plan. If one state has coordinates <SPAN class=MATH><IMG height=37 alt="$ (i,j)$" src="http://planning.cs.uiuc.edu/img146.gif" width=43 align=middle border=0></SPAN> and another has <SPAN class=MATH><IMG height=37 alt="$ (i',j')$" src="http://planning.cs.uiuc.edu/img314.gif" width=52 align=middle border=0></SPAN>, then <!-- MATH
 $|i' - i| + |j' -
j|$
 --><SPAN class=MATH><IMG height=37 alt="$ \vert i' - i\vert + \vert j' -&#10;j\vert$" src="http://planning.cs.uiuc.edu/img315.gif" width=135 align=middle border=0></SPAN> is an underestimate because this is the length of a straightforward plan that ignores obstacles. Once obstacles are included, the cost can only increase as the robot tries to get around them (which may not even be possible). Of course, zero could also serve as an underestimate, but that would not provide any helpful information to the algorithm. The aim is to compute an estimate that is as close as possible to the optimal cost-to-go and is also guaranteed to be no greater. Let <!-- MATH
 $\hat{G}^*(x)$
 --><SPAN class=MATH><IMG height=44 alt="$ \hat{G}^*(x)$" src="http://planning.cs.uiuc.edu/img316.gif" width=52 align=middle border=0></SPAN> denote such an estimate. 
<P>The <SPAN class=MATH><IMG height=17 alt="$ A^*$" src="http://planning.cs.uiuc.edu/img288.gif" width=26 align=bottom border=0></SPAN> search algorithm works in exactly the same way as Dijkstra's algorithm. The only difference is the function used to sort <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN>. In the <SPAN class=MATH><IMG height=17 alt="$ A^*$" src="http://planning.cs.uiuc.edu/img288.gif" width=26 align=bottom border=0></SPAN> algorithm, the sum <!-- MATH
 $C^*(x') + \hat{G}^*(x')$
 --><SPAN class=MATH><IMG height=44 alt="$ C^*(x') + \hat{G}^*(x')$" src="http://planning.cs.uiuc.edu/img317.gif" width=132 align=middle border=0></SPAN> is used, implying that the priority queue is sorted by estimates of the optimal cost from <SPAN class=MATH><IMG height=33 alt="$ {x_{I}}$" src="http://planning.cs.uiuc.edu/img261.gif" width=23 align=middle border=0></SPAN> to <SPAN class=MATH><IMG height=34 alt="$ {X_{G}}$" src="http://planning.cs.uiuc.edu/img140.gif" width=32 align=middle border=0></SPAN>. If <!-- MATH
 $\hat{G}^*(x)$
 --><SPAN class=MATH><IMG height=44 alt="$ \hat{G}^*(x)$" src="http://planning.cs.uiuc.edu/img316.gif" width=52 align=middle border=0></SPAN> is an underestimate of the true optimal cost-to-go for all <SPAN class=MATH><IMG height=34 alt="$ x \in X$" src="http://planning.cs.uiuc.edu/img228.gif" width=56 align=middle border=0></SPAN>, the <SPAN class=MATH><IMG height=17 alt="$ A^*$" src="http://planning.cs.uiuc.edu/img288.gif" width=26 align=bottom border=0></SPAN> algorithm is guaranteed to find optimal plans [<A href="http://planning.cs.uiuc.edu/node858.html#FikNil71">337</A>,<A href="http://planning.cs.uiuc.edu/node858.html#Pea84">777</A>]. As <SPAN class=MATH><IMG height=22 alt="$ \hat{G}^*$" src="http://planning.cs.uiuc.edu/img318.gif" width=27 align=bottom border=0></SPAN> becomes closer to <SPAN class=MATH><IMG height=17 alt="$ G^*$" src="http://planning.cs.uiuc.edu/img224.gif" width=27 align=bottom border=0></SPAN>, fewer vertices tend to be explored in comparison with Dijkstra's algorithm. This would always seem advantageous, but in some problems it is difficult or impossible to find a heuristic that is both efficient to evaluate and provides good search guidance. Note that when <!-- MATH
 $\hat{G}^*(x)=0$
 --><SPAN class=MATH><IMG height=44 alt="$ \hat{G}^*(x)=0$" src="http://planning.cs.uiuc.edu/img319.gif" width=87 align=middle border=0></SPAN> for all <SPAN class=MATH><IMG height=34 alt="$ x \in X$" src="http://planning.cs.uiuc.edu/img228.gif" width=56 align=middle border=0></SPAN>, then <SPAN class=MATH><IMG height=17 alt="$ A^*$" src="http://planning.cs.uiuc.edu/img288.gif" width=26 align=bottom border=0></SPAN> degenerates to Dijkstra's algorithm. In any case, the search will always be systematic. <A name=2528></A>