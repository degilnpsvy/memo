<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>2</SPAN> Searching for Feasible Plans 
<P><A name=2429></A>The methods presented in this section are just graph search algorithms, but with the understanding that the state transition graph is revealed incrementally through the application of actions, instead of being fully specified in advance. The presentation in this section can therefore be considered as visiting graph search algorithms from a planning perspective. An important requirement for these or any search algorithms is to be <EM>systematic</EM>. If the graph is finite, this means that the algorithm will visit every reachable state, which enables it to correctly declare in finite time whether or not a solution exists. To be systematic, the algorithm should keep track of states already visited; otherwise, the search may run forever by cycling through the same states. Ensuring that no redundant exploration occurs is sufficient to make the search systematic. 
<P>If the graph is infinite, then we are willing to tolerate a weaker definition for being systematic. If a solution exists, then the search algorithm still must report it in finite time; however, if a solution does not exist, it is acceptable for the algorithm to search forever. This systematic requirement is achieved by ensuring that, in the limit, as the number of search iterations tends to infinity, every reachable vertex in the graph is explored. Since the number of vertices is assumed to be countable, this must always be possible. 
<P>
<DIV align=center><A name=fig:syssearch></A><A name=3334></A>
<TABLE>
<CAPTION align=bottom><STRONG>Figure 2.3:</STRONG> (a) Many search algorithms focus too much on one direction, which may prevent them from being systematic on infinite graphs. (b) If, for example, the search carefully expands in wavefronts, then it becomes systematic. The requirement to be systematic is that, in the limit, as the number of iterations tends to infinity, all reachable vertices are reached. </CAPTION>
<TBODY>
<TR>
<TD><IMG height=317 alt="\begin{figure}\begin{center}&#10;\begin{tabular}{cc}&#10;\psfig{file=figs/syssearch2.idr...&#10;...syssearch.idr,width=2.5in} \\&#10;(a) &amp; (b)&#10;\end{tabular}&#10;\end{center}\end{figure}" src="http://planning.cs.uiuc.edu/img284.gif" width=553 border=0></TD></TR></TBODY></TABLE></DIV>
<P>As an example of this requirement, consider Example <A href="http://planning.cs.uiuc.edu/node38.html#exa:disgrid">2.1</A> on an infinite tile floor with no obstacles. If the search algorithm explores in only one direction, as depicted in Figure <A href="http://planning.cs.uiuc.edu/node39.html#fig:syssearch">2.3</A>a, then in the limit most of the space will be left uncovered, even though no states are revisited. If instead the search proceeds outward from the origin in wavefronts, as depicted in Figure <A href="http://planning.cs.uiuc.edu/node39.html#fig:syssearch">2.3</A>b, then it may be systematic. In practice, each search algorithm has to be carefully analyzed. A search algorithm could expand in multiple directions, or even in wavefronts, but still not be systematic. If the graph is finite, then it is much simpler: Virtually any search algorithm is systematic, provided that it marks visited states to avoid revisiting the same states indefinitely. <A name=2444></A>
<P><BR>
<HR>
<!--Table of Child-Links--><A name=CHILD_LINKS><STRONG>Subsections</STRONG></A> 
<UL class=ChildLinks>
<LI><A href="http://planning.cs.uiuc.edu/node40.html" name=tex2html1876><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>1</SPAN> General Forward Search</A> 
<LI><A href="http://planning.cs.uiuc.edu/node41.html" name=tex2html1877><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>2</SPAN> Particular Forward Search Methods</A> 
<UL>
<LI><A href="http://planning.cs.uiuc.edu/node42.html" name=tex2html1878>Breadth first</A> 
<LI><A href="http://planning.cs.uiuc.edu/node43.html" name=tex2html1879>Depth first</A> 
<LI><A href="http://planning.cs.uiuc.edu/node44.html" name=tex2html1880>Dijkstra's algorithm</A> 
<LI><A href="http://planning.cs.uiuc.edu/node45.html" name=tex2html1881>A-star</A> 
<LI><A href="http://planning.cs.uiuc.edu/node46.html" name=tex2html1882>Best first</A> 
<LI><A href="http://planning.cs.uiuc.edu/node47.html" name=tex2html1883>Iterative deepening</A> </LI></UL><BR>
<LI><A href="http://planning.cs.uiuc.edu/node48.html" name=tex2html1884><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>3</SPAN> Other General Search Schemes</A> 
<UL>
<LI><A href="http://planning.cs.uiuc.edu/node49.html" name=tex2html1885>Backward search</A> 
<LI><A href="http://planning.cs.uiuc.edu/node50.html" name=tex2html1886>Bidirectional search</A> </LI></UL><BR>
<LI><A href="http://planning.cs.uiuc.edu/node51.html" name=tex2html1887><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>4</SPAN> A Unified View of the Search Methods</A> </LI></UL><!--End of Table of Child-Links-->