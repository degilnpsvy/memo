<H4><A name=SECTION02222030000000000000>Dijkstra's algorithm</A> </H4>
<P><A name=2506></A><A name=2507></A>Up to this point, there has been no reason to prefer one action over any other in the search. Section <A href="http://planning.cs.uiuc.edu/node52.html#sec:disopt">2.3</A> will formalize optimal discrete planning and will present several algorithms that find optimal plans. Before going into that, we present a systematic search algorithm that finds optimal plans because it is also useful for finding feasible plans. The result is the well-known Dijkstra's algorithm for finding single-source shortest paths in a graph [<A href="http://planning.cs.uiuc.edu/node858.html#Dij59">273</A>], which is a special form of dynamic programming. More general dynamic programming computations appear in Section <A href="http://planning.cs.uiuc.edu/node52.html#sec:disopt">2.3</A> and throughout the book. 
<P>Suppose that every edge, <SPAN class=MATH><IMG height=34 alt="$ e \in E$" src="http://planning.cs.uiuc.edu/img299.gif" width=52 align=middle border=0></SPAN>, in the graph representation of a discrete planning problem has an associated nonnegative cost <SPAN class=MATH><IMG height=37 alt="$ l(e)$" src="http://planning.cs.uiuc.edu/img300.gif" width=34 align=middle border=0></SPAN>, which is the cost to apply the action. The cost <SPAN class=MATH><IMG height=37 alt="$ l(e)$" src="http://planning.cs.uiuc.edu/img300.gif" width=34 align=middle border=0></SPAN> could be written using the state-space representation as <SPAN class=MATH><IMG height=37 alt="$ l(x,u)$" src="http://planning.cs.uiuc.edu/img301.gif" width=55 align=middle border=0></SPAN>, indicating that it costs <SPAN class=MATH><IMG height=37 alt="$ l(x,u)$" src="http://planning.cs.uiuc.edu/img301.gif" width=55 align=middle border=0></SPAN> to apply action <SPAN class=MATH><IMG height=17 alt="$ u$" src="http://planning.cs.uiuc.edu/img253.gif" width=15 align=bottom border=0></SPAN> from state <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN>. The total cost of a plan is just the sum of the edge costs over the path from the initial state to a goal state. 
<P>The priority queue, <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN>, will be sorted according to a function <!-- MATH
 ${C}: X \rightarrow [0,\infty]$
 --><SPAN class=MATH><IMG height=37 alt="$ {C}: X \rightarrow [0,\infty]$" src="http://planning.cs.uiuc.edu/img302.gif" width=129 align=middle border=0></SPAN>, called the <I>cost-to-come</I>. For each <A name=2512></A>state <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN>, the value <SPAN class=MATH><IMG height=37 alt="$ C^*(x)$" src="http://planning.cs.uiuc.edu/img303.gif" width=52 align=middle border=0></SPAN> is called the <EM>optimal<A href="http://planning.cs.uiuc.edu/footnode.html#foot3336" name=tex2html28><SUP><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>1</SPAN></SUP></A> cost-to-come</EM> from the initial state <SPAN class=MATH><IMG height=33 alt="$ {x_{I}}$" src="http://planning.cs.uiuc.edu/img261.gif" width=23 align=middle border=0></SPAN>. This optimal cost is obtained by summing edge costs, <SPAN class=MATH><IMG height=37 alt="$ l(e)$" src="http://planning.cs.uiuc.edu/img300.gif" width=34 align=middle border=0></SPAN>, over all possible paths from <SPAN class=MATH><IMG height=33 alt="$ {x_{I}}$" src="http://planning.cs.uiuc.edu/img261.gif" width=23 align=middle border=0></SPAN> to <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN> and using the path that produces the least cumulative cost. If the cost is not known to be optimal, then it is written as <SPAN class=MATH><IMG height=37 alt="$ {C}(x)$" src="http://planning.cs.uiuc.edu/img304.gif" width=45 align=middle border=0></SPAN>. 
<P>The cost-to-come is computed incrementally during the execution of the search algorithm in Figure <A href="http://planning.cs.uiuc.edu/node40.html#fig:gfs">2.4</A>. Initially, <!-- MATH
 $C^*({x_{I}}) =
0$
 --><SPAN class=MATH><IMG height=37 alt="$ C^*({x_{I}}) =&#10;0$" src="http://planning.cs.uiuc.edu/img305.gif" width=94 align=middle border=0></SPAN>. Each time the state <SPAN class=MATH><IMG height=18 alt="$ x'$" src="http://planning.cs.uiuc.edu/img254.gif" width=20 align=bottom border=0></SPAN> is generated, a cost is computed as <!-- MATH
 ${C}(x') = C^*(x) + l(e)$
 --><SPAN class=MATH><IMG height=37 alt="$ {C}(x') = C^*(x) + l(e)$" src="http://planning.cs.uiuc.edu/img306.gif" width=174 align=middle border=0></SPAN>, in which <SPAN class=MATH><IMG height=17 alt="$ e$" src="http://planning.cs.uiuc.edu/img307.gif" width=13 align=bottom border=0></SPAN> is the edge from <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN> to <SPAN class=MATH><IMG height=18 alt="$ x'$" src="http://planning.cs.uiuc.edu/img254.gif" width=20 align=bottom border=0></SPAN> (equivalently, we may write <!-- MATH
 ${C}(x') = C^*(x) + l(x,u)$
 --><SPAN class=MATH><IMG height=37 alt="$ {C}(x') = C^*(x) + l(x,u)$" src="http://planning.cs.uiuc.edu/img308.gif" width=195 align=middle border=0></SPAN>). Here, <SPAN class=MATH><IMG height=37 alt="$ {C}(x')$" src="http://planning.cs.uiuc.edu/img309.gif" width=49 align=middle border=0></SPAN> represents the best cost-to-come that is known so far, but we do not write <SPAN class=MATH><IMG height=17 alt="$ C^*$" src="http://planning.cs.uiuc.edu/img310.gif" width=27 align=bottom border=0></SPAN> because it is not yet known whether <SPAN class=MATH><IMG height=18 alt="$ x'$" src="http://planning.cs.uiuc.edu/img254.gif" width=20 align=bottom border=0></SPAN> was reached optimally. Due to this, some work is required in line 12. If <SPAN class=MATH><IMG height=18 alt="$ x'$" src="http://planning.cs.uiuc.edu/img254.gif" width=20 align=bottom border=0></SPAN> already exists in <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN>, then it is possible that the newly discovered path to <SPAN class=MATH><IMG height=18 alt="$ x'$" src="http://planning.cs.uiuc.edu/img254.gif" width=20 align=bottom border=0></SPAN> is more efficient. If so, then the cost-to-come value <SPAN class=MATH><IMG height=37 alt="$ {C}(x')$" src="http://planning.cs.uiuc.edu/img309.gif" width=49 align=middle border=0></SPAN> must be lowered for <SPAN class=MATH><IMG height=18 alt="$ x'$" src="http://planning.cs.uiuc.edu/img254.gif" width=20 align=bottom border=0></SPAN>, and <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN> must be reordered accordingly. 
<P>When does <SPAN class=MATH><IMG height=37 alt="$ {C}(x)$" src="http://planning.cs.uiuc.edu/img304.gif" width=45 align=middle border=0></SPAN> finally become <SPAN class=MATH><IMG height=37 alt="$ C^*(x)$" src="http://planning.cs.uiuc.edu/img303.gif" width=52 align=middle border=0></SPAN> for some state <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN>? Once <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN> is removed from <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN> using <!-- MATH
 ${Q}.GetFirst()$
 --><SPAN class=MATH><IMG height=37 alt="$ {Q}.GetFirst()$" src="http://planning.cs.uiuc.edu/img286.gif" width=115 align=middle border=0></SPAN>, the state becomes dead, and it is known that <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN> cannot be reached with a lower cost. This can be argued by induction. For the initial state, <!-- MATH
 $C^*({x_{I}})$
 --><SPAN class=MATH><IMG height=37 alt="$ C^*({x_{I}})$" src="http://planning.cs.uiuc.edu/img311.gif" width=60 align=middle border=0></SPAN> is known, and this serves as the base case. Now assume that every dead state<A name=2515></A> has its optimal cost-to-come correctly determined. This means that their cost-to-come values can no longer change. For the first element, <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN>, of <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN>, the value must be optimal because any path that has a lower total cost would have to travel through another state in <SPAN class=MATH><IMG height=34 alt="$ {Q}$" src="http://planning.cs.uiuc.edu/img7.gif" width=20 align=middle border=0></SPAN>, but these states already have higher costs. All paths that pass only through dead states<A name=3543></A> were already considered in producing <SPAN class=MATH><IMG height=37 alt="$ {C}(x)$" src="http://planning.cs.uiuc.edu/img304.gif" width=45 align=middle border=0></SPAN>. Once all edges leaving <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN> are explored, then <SPAN class=MATH><IMG height=17 alt="$ x$" src="http://planning.cs.uiuc.edu/img86.gif" width=15 align=bottom border=0></SPAN> can be declared as dead, and the induction continues. This is not enough detail to constitute a proof of optimality; more arguments appear in Section <A href="http://planning.cs.uiuc.edu/node57.html#sec:dijrev">2.3.3</A> and in [<A href="http://planning.cs.uiuc.edu/node858.html#CorLeiRivSte01">243</A>]. The running time is <!-- MATH
 $O(|V| \lg |V| + |E|)$
 --><SPAN class=MATH><IMG height=37 alt="$ O(\vert V\vert \lg \vert V\vert + \vert E\vert)$" src="http://planning.cs.uiuc.edu/img312.gif" width=155 align=middle border=0></SPAN>, in which <SPAN class=MATH><IMG height=37 alt="$ \vert V\vert$" src="http://planning.cs.uiuc.edu/img291.gif" width=30 align=middle border=0></SPAN> and <SPAN class=MATH><IMG height=37 alt="$ \vert E\vert$" src="http://planning.cs.uiuc.edu/img292.gif" width=30 align=middle border=0></SPAN> are the numbers of edges and vertices, respectively, in the graph representation of the discrete planning problem. This assumes that the priority queue is implemented with a Fibonacci heap, and that all other operations, such as determining whether a state has been visited, are performed in constant time. If other data structures are used to implement the priority queue, then higher running times may be obtained. <A name=2519></A><A name=2520></A>