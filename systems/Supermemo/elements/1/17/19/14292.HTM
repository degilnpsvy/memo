<H3 class=section>10.4 Chains of Implicit Rules</H3>
<P><A name=index-chains-of-rules-942></A><A name=index-rule_002c-implicit_002c-chains-of-943></A>Sometimes a file can be made by a sequence of implicit rules. For example, a file <SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> could be made from <SAMP><VAR>n</VAR><SPAN class=file>.y</SPAN></SAMP> by running first Yacc and then <CODE>cc</CODE>. Such a sequence is called a <DFN>chain</DFN>. 
<P>If the file <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> exists, or is mentioned in the makefile, no special searching is required: <CODE>make</CODE> finds that the object file can be made by C compilation from <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP>; later on, when considering how to make <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP>, the rule for running Yacc is used. Ultimately both <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> and <SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> are updated. 
<P><A name=index-intermediate-files-944></A><A name=index-files_002c-intermediate-945></A>However, even if <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> does not exist and is not mentioned, <CODE>make</CODE> knows how to envision it as the missing link between <SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> and <SAMP><VAR>n</VAR><SPAN class=file>.y</SPAN></SAMP>! In this case, <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> is called an <DFN>intermediate file</DFN>. Once <CODE>make</CODE> has decided to use the intermediate file, it is entered in the data base as if it had been mentioned in the makefile, along with the implicit rule that says how to create it. 
<P><FONT class=extract>Intermediate files are remade using their rules just like all other files. But intermediate files are treated differently in two ways. </FONT>
<P><FONT class=extract>The first difference is what happens if the intermediate file does not exist. If an ordinary file <VAR>b</VAR> does not exist, and <CODE>make</CODE> considers a target that depends on <VAR>b</VAR>, it invariably creates <VAR>b</VAR> and then updates the target from <VAR>b</VAR>. But if <VAR>b</VAR> is an intermediate file, then <CODE>make</CODE> can leave well enough alone. It won't bother updating <VAR>b</VAR>, or the ultimate target, unless some prerequisite of <VAR>b</VAR> is newer than that target or there is some other reason to update that target. </FONT>
<P><FONT class=extract>The second difference is that if <CODE>make</CODE> <EM>does</EM> create <VAR>b</VAR> in order to update something else, it deletes <VAR>b</VAR> later on after it is no longer needed. Therefore, an intermediate file which did not exist before <CODE>make</CODE> also does not exist after <CODE>make</CODE>. <CODE>make</CODE> reports the deletion to you by printing a &#8216;<SAMP><SPAN class=samp>rm -f</SPAN></SAMP>&#8217; command showing which file it is deleting. </FONT>
<P><FONT class=extract>Ordinarily, a file cannot be intermediate if it is mentioned in the makefile as a target or prerequisite. However, you can explicitly mark a file as intermediate by listing it as a prerequisite of the special target <CODE>.INTERMEDIATE</CODE>. This takes effect even if the file is mentioned explicitly in some other way. </FONT>
<P><A name=index-intermediate-files_002c-preserving-946></A><A name=index-preserving-intermediate-files-947></A><A name=index-secondary-files-948></A><FONT class=extract>You can prevent automatic deletion of an intermediate file by marking it as a <DFN>secondary</DFN> file. To do this, list it as a prerequisite of the special target <CODE>.SECONDARY</CODE>. When a file is secondary, <CODE>make</CODE> will not create the file merely because it does not already exist, but <CODE>make</CODE> does not automatically delete the file. Marking a file as secondary also marks it as intermediate.</FONT> 
<P><FONT class=extract>You can list the target pattern of an implicit rule (such as &#8216;<SAMP><SPAN class=samp>%.o</SPAN></SAMP>&#8217;) as a prerequisite of the special target <CODE>.PRECIOUS</CODE> to preserve intermediate files made by implicit rules whose target patterns match that file's name; see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Interrupts"><FONT class=extract>Interrupts</FONT></A><FONT class=extract>. </FONT><A name=index-preserving-with-_0040code_007b_002ePRECIOUS_007d-949></A><A name=index-g_t_0040code_007b_002ePRECIOUS_007d-intermediate-files-950></A><FONT class=extract>A chain can involve more than two implicit rules. For example, it is possible to make a file <SAMP><SPAN class=file>foo</SPAN></SAMP> from <SAMP><SPAN class=file>RCS/foo.y,v</SPAN></SAMP> by running RCS, Yacc and <CODE>cc</CODE>. Then both <SAMP><SPAN class=file>foo.y</SPAN></SAMP> and <SAMP><SPAN class=file>foo.c</SPAN></SAMP> are intermediate files that are deleted at the end. </FONT>
<P><FONT class=extract>No single implicit rule can appear more than once in a chain. This means that <CODE>make</CODE> will not even consider such a ridiculous thing as making <SAMP><SPAN class=file>foo</SPAN></SAMP> from <SAMP><SPAN class=file>foo.o.o</SPAN></SAMP> by running the linker twice. This constraint has the added benefit of preventing any infinite loop in the search for an implicit rule chain. </FONT>
<P><FONT class=extract>There are some special implicit rules to optimize certain cases that would otherwise be handled by rule chains. For example, making <SAMP><SPAN class=file>foo</SPAN></SAMP> from <SAMP><SPAN class=file>foo.c</SPAN></SAMP> could be handled by compiling and linking with separate chained rules, using <SAMP><SPAN class=file>foo.o</SPAN></SAMP> as an intermediate file. But what actually happens is that a special rule for this case does the compilation and linking with a single <CODE>cc</CODE> command. The optimized rule is used in preference to the step-by-step chain because it comes earlier in the ordering of rules.</FONT>