<H3><A name=SECTION03011200000000000000>2. Continuous <!-- MATH
 $\rightarrow$
 --><SPAN class=MATH><IMG height=16 alt="$ \rightarrow$" src="http://planning.cs.uiuc.edu/img639.gif" width=24 align=bottom border=0></SPAN> discrete</A> </H3>
<P>A central theme throughout motion planning is to transform the continuous model into a discrete one. Due to this transformation, many algorithms from Chapter <A href="http://planning.cs.uiuc.edu/node35.html#cha:discrete">2</A> are embedded in motion planning algorithms. There are two alternatives to achieving this transformation, which are covered in Chapters <A href="http://planning.cs.uiuc.edu/node181.html#cha:sampling">5</A> and <A href="http://planning.cs.uiuc.edu/node254.html#cha:comb">6</A>, respectively. Chapter <A href="http://planning.cs.uiuc.edu/node254.html#cha:comb">6</A> covers <EM>combinatorial motion planning</EM>, which means that from the input model the algorithms build a discrete representation that <EM>exactly</EM> represents the original problem. This leads to <EM>complete</EM> planning approaches, which are guaranteed to find a solution when it exists, or correctly report failure if one does not exist. Chapter <A href="http://planning.cs.uiuc.edu/node181.html#cha:sampling">5</A> covers <EM>sampling-based motion planning</EM>, which refers to algorithms that use collision detection methods to sample the configuration space and conduct discrete searches that utilize these samples. In this case, completeness is sacrificed, but it is often replaced with a weaker notion, such as <EM>resolution completeness</EM> or <EM>probabilistic completeness</EM>. It is important to study both Chapters <A href="http://planning.cs.uiuc.edu/node181.html#cha:sampling">5</A> and <A href="http://planning.cs.uiuc.edu/node254.html#cha:comb">6</A> because each methodology has its strengths and weaknesses. Combinatorial methods can solve virtually any motion planning problem, and in some restricted cases, very elegant solutions may be efficiently constructed in practice. However, for the majority of ``industrial-grade'' motion planning problems, the running times and implementation difficulties of these algorithms make them unappealing. Sampling-based algorithms have fulfilled much of this need in recent years by solving challenging problems in several settings, such as automobile assembly, humanoid robot planning, and conformational analysis in drug design. Although the completeness guarantees are weaker, the efficiency and ease of implementation of these methods have bolstered interest in applying motion planning algorithms to a wide variety of applications. 
<P><BR>
<P>Two additional chapters appear in Part <A href="http://planning.cs.uiuc.edu/node71.html#par:mp">II</A>. Chapter <A href="http://planning.cs.uiuc.edu/node310.html#cha:eplan">7</A> covers several extensions of the basic motion planning problem from the earlier chapters. These extensions include avoiding moving obstacles, multiple robot coordination, manipulation planning, and planning with closed kinematic chains. Algorithms that solve these problems build on the principles of earlier chapters, but each extension involves new challenges. 
<P>Chapter <A href="http://planning.cs.uiuc.edu/node363.html#cha:feedback">8</A> is a transitional chapter that involves many elements of motion planning but is additionally concerned with gracefully recovering from unexpected deviations during execution. Although uncertainty in predicting the future is not explicitly modeled until Part <A href="http://planning.cs.uiuc.edu/node420.html#par:dtp">III</A>, Chapter <A href="http://planning.cs.uiuc.edu/node363.html#cha:feedback">8</A> redefines the notion of a plan to be a function over state space, as opposed to being a path through it. The function gives the appropriate actions to take during exection, regardless of what configuration is entered. This allows the true configuration to drift away from the commanded configuration. In Part <A href="http://planning.cs.uiuc.edu/node420.html#par:dtp">III</A> such uncertainties will be explicitly modeled, but this comes at greater modeling and computational costs. It is worthwhile to develop effective ways to avoid this.