<H3 class=section>4.14 Generating Prerequisites Automatically</H3>
<P><A name=index-prerequisites_002c-automatic-generation-279></A><A name=index-automatic-generation-of-prerequisites-280></A><A name=index-generating-prerequisites-automatically-281></A>In the makefile for a program, many of the rules you need to write often say only that some object file depends on some header file. For example, if <SAMP><SPAN class=file>main.c</SPAN></SAMP> uses <SAMP><SPAN class=file>defs.h</SPAN></SAMP> via an <CODE>#include</CODE>, you would write: <PRE class=example>     main.o: defs.h
</PRE>
<P class=noindent>You need this rule so that <CODE>make</CODE> knows that it must remake <SAMP><SPAN class=file>main.o</SPAN></SAMP> whenever <SAMP><SPAN class=file>defs.h</SPAN></SAMP> changes. You can see that for a large program you would have to write dozens of such rules in your makefile. And, you must always be very careful to update the makefile every time you add or remove an <CODE>#include</CODE>. <A name=index-g_t_0040code_007b_0023include_007d-282></A><A name=index-g_t_0040code_007b_002dM_007d-_0028to-compiler_0029-283></A><FONT class=extract>To avoid this hassle, most modern C compilers can write these rules for you, by looking at the <CODE>#include</CODE> lines in the source files. Usually this is done with the &#8216;<SAMP><SPAN class=samp>-M</SPAN></SAMP>&#8217; option to the compiler. For example, the command: </FONT><PRE class=example><FONT class=extract>     cc -M main.c
</FONT></PRE>
<P class=noindent><FONT class=extract>generates the output: </FONT><PRE class=example><FONT class=extract>     main.o : main.c defs.h
</FONT></PRE>
<P class=noindent><FONT class=extract>Thus you no longer have to write all those rules yourself. The compiler will do it for you. </FONT>
<P><FONT class=extract>Note that such a rule constitutes mentioning <SAMP><SPAN class=file>main.o</SPAN></SAMP> in a makefile, so it can never be considered an intermediate file by implicit rule search. This means that <CODE>make</CODE> won't ever remove the file after using it; see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Chained-Rules"><FONT class=extract>Chains of Implicit Rules</FONT></A><FONT class=extract>.</FONT> 
<P><A name=index-g_t_0040code_007bmake-depend_007d-284></A><FONT class=extract>With old <CODE>make</CODE> programs, it was traditional practice to use this compiler feature to generate prerequisites on demand with a command like &#8216;<SAMP><SPAN class=samp>make depend</SPAN></SAMP>&#8217;. That command would create a file <SAMP><SPAN class=file>depend</SPAN></SAMP> containing all the automatically-generated prerequisites; then the makefile could use <CODE>include</CODE> to read them in (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Include"><FONT class=extract>Include</FONT></A><FONT class=extract>).</FONT> 
<P>In GNU <CODE>make</CODE>, the feature of remaking makefiles makes this practice obsolete&#8212;you need never tell <CODE>make</CODE> explicitly to regenerate the prerequisites, because it always regenerates any makefile that is out of date. See <A href="https://www.gnu.org/software/make/manual/make.html#Remaking-Makefiles">Remaking Makefiles</A>. 
<P><FONT class=extract>The practice we recommend for automatic prerequisite generation is to have one makefile corresponding to each source file. For each source file <SAMP><VAR>name</VAR><SPAN class=file>.c</SPAN></SAMP> there is a makefile <SAMP><VAR>name</VAR><SPAN class=file>.d</SPAN></SAMP> which lists what files the object file <SAMP><VAR>name</VAR><SPAN class=file>.o</SPAN></SAMP> depends on. That way only the source files that have changed need to be rescanned to produce the new prerequisites. </FONT>
<P><FONT class=extract>Here is the pattern rule to generate a file of prerequisites (i.e., a makefile) called <SAMP><VAR>name</VAR><SPAN class=file>.d</SPAN></SAMP> from a C source file called <SAMP><VAR>name</VAR><SPAN class=file>.c</SPAN></SAMP>: </FONT><PRE class=smallexample><FONT class=extract>     %.d: %.c
             @set -e; rm -f $@; \
              $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \
              sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' &lt; $@.$$$$ &gt; $@; \
              rm -f $@.$$$$
</FONT></PRE>
<P class=noindent><FONT class=extract>See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules"><FONT class=extract>Pattern Rules</FONT></A><FONT class=extract>, for information on defining pattern rules. The &#8216;<SAMP><SPAN class=samp>-e</SPAN></SAMP>&#8217; flag to the shell causes it to exit immediately if the <CODE>$(CC)</CODE> command (or any other command) fails (exits with a nonzero status). </FONT><A name=index-g_t_0040code_007b_002de_007d-_0028shell-flag_0029-285></A><A name=index-g_t_0040code_007b_002dMM_007d-_0028to-GNU-compiler_0029-286></A><FONT class=extract>With the GNU C compiler, you may wish to use the &#8216;<SAMP><SPAN class=samp>-MM</SPAN></SAMP>&#8217; flag instead of &#8216;<SAMP><SPAN class=samp>-M</SPAN></SAMP>&#8217;. This omits prerequisites on system header files. See </FONT><A href="https://www.gnu.org/software/make/manual/gcc.html#Preprocessor-Options"><FONT class=extract>Options Controlling the Preprocessor</FONT></A><FONT class=extract>, for details. </FONT>
<P><A name=index-g_t_0040code_007bsed_007d-_0028shell-command_0029-287></A><FONT class=extract>The purpose of the <CODE>sed</CODE> command is to translate (for example): </FONT><PRE class=example><FONT class=extract>     main.o : main.c defs.h
</FONT></PRE>
<P class=noindent><FONT class=extract>into: </FONT><PRE class=example><FONT class=extract>     main.o main.d : main.c defs.h
</FONT></PRE>
<P class=noindent><A name=index-g_t_0040code_007b_002ed_007d-288></A><FONT class=extract>This makes each &#8216;<SAMP><SPAN class=samp>.d</SPAN></SAMP>&#8217; file depend on all the source and header files that the corresponding &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; file depends on. <CODE>make</CODE> then knows it must regenerate the prerequisites whenever any of the source or header files changes. </FONT>
<P><FONT class=extract>Once you've defined the rule to remake the &#8216;<SAMP><SPAN class=samp>.d</SPAN></SAMP>&#8217; files, you then use the <CODE>include</CODE> directive to read them all in. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Include"><FONT class=extract>Include</FONT></A><FONT class=extract>. For example: </FONT><PRE class=example><FONT class=extract>     sources = foo.c bar.c
     
     include $(sources:.c=.d)
</FONT></PRE>
<P class=noindent><FONT class=extract>(This example uses a substitution variable reference to translate the list of source files &#8216;<SAMP><SPAN class=samp>foo.c bar.c</SPAN></SAMP>&#8217; into a list of prerequisite makefiles, &#8216;<SAMP><SPAN class=samp>foo.d bar.d</SPAN></SAMP>&#8217;. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Substitution-Refs"><FONT class=extract>Substitution Refs</FONT></A><FONT class=extract>, for full information on substitution references.) Since the &#8216;<SAMP><SPAN class=samp>.d</SPAN></SAMP>&#8217; files are makefiles like any others, <CODE>make</CODE> will remake them as necessary with no further work from you. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Remaking-Makefiles"><FONT class=extract>Remaking Makefiles</FONT></A><FONT class=extract>. </FONT>
<P><FONT class=extract>Note that the &#8216;<SAMP><SPAN class=samp>.d</SPAN></SAMP>&#8217; files contain target definitions; you should be sure to place the <CODE>include</CODE> directive <EM>after</EM> the first, default goal in your makefiles or run the risk of having a random object file become the default goal. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#How-Make-Works"><FONT class=extract>How Make Works</FONT></A><FONT class=extract>.</FONT>