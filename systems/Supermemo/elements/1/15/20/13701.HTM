<H2 class=chapter>3 Writing Makefiles</H2>
<P><A name=index-makefile_002c-how-to-write-48></A>The information that tells <CODE>make</CODE> how to recompile a system comes from reading a data base called the <DFN>makefile</DFN>. 
<UL class=menu>
<LI><A accessKey=1 href="https://www.gnu.org/software/make/manual/make.html#Makefile-Contents">Makefile Contents</A>: What makefiles contain. 
<LI><A accessKey=2 href="https://www.gnu.org/software/make/manual/make.html#Makefile-Names">Makefile Names</A>: How to name your makefile. 
<LI><A accessKey=3 href="https://www.gnu.org/software/make/manual/make.html#Include">Include</A>: How one makefile can use another makefile. 
<LI><A accessKey=4 href="https://www.gnu.org/software/make/manual/make.html#MAKEFILES-Variable">MAKEFILES Variable</A>: The environment can specify extra makefiles. 
<LI><A accessKey=5 href="https://www.gnu.org/software/make/manual/make.html#Remaking-Makefiles">Remaking Makefiles</A>: How makefiles get remade. 
<LI><A accessKey=6 href="https://www.gnu.org/software/make/manual/make.html#Overriding-Makefiles">Overriding Makefiles</A>: How to override part of one makefile with another makefile. 
<LI><A accessKey=7 href="https://www.gnu.org/software/make/manual/make.html#Reading-Makefiles">Reading Makefiles</A>: How makefiles are parsed. 
<LI><A accessKey=8 href="https://www.gnu.org/software/make/manual/make.html#Secondary-Expansion">Secondary Expansion</A>: How and when secondary expansion is performed. </LI></UL>
<DIV class=node><A name=Makefile-Contents></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Makefile-Names" rel=next>Makefile Names</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Makefiles" rel=previous>Makefiles</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Makefiles" rel=up>Makefiles</A> </DIV>
<H3 class=section><FONT class=extract>3.1 What Makefiles Contain</FONT></H3>
<P><FONT class=extract>Makefiles contain five kinds of things: <DFN>explicit rules</DFN>, <DFN>implicit rules</DFN>, <DFN>variable definitions</DFN>, <DFN>directives</DFN>, and <DFN>comments</DFN>. Rules, variables, and directives are described at length in later chapters. </FONT><A name=index-rule_002c-explicit_002c-definition-of-49></A><A name=index-explicit-rule_002c-definition-of-50></A>
<UL>
<LI><FONT class=extract>An <DFN>explicit rule</DFN> says when and how to remake one or more files, called the rule's <DFN>targets</DFN>. It lists the other files that the targets depend on, called the <DFN>prerequisites</DFN> of the target, and may also give a recipe to use to create or update the targets. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Rules"><FONT class=extract>Writing Rules</FONT></A><FONT class=extract>. </FONT>
<P><A name=index-rule_002c-implicit_002c-definition-of-51></A><A name=index-implicit-rule_002c-definition-of-52></A></P>
<LI><FONT class=extract>An <DFN>implicit rule</DFN> says when and how to remake a class of files based on their names. It describes how a target may depend on a file with a name similar to the target and gives a recipe to create or update such a target. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules"><FONT class=extract>Using Implicit Rules</FONT></A><FONT class=extract>. </FONT>
<P><A name=index-variable-definition-53></A></P>
<LI><FONT class=extract>A <DFN>variable definition</DFN> is a line that specifies a text string value for a variable that can be substituted into the text later. The simple makefile example shows a variable definition for <CODE>objects</CODE> as a list of all object files (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Variables-Simplify"><FONT class=extract>Variables Make Makefiles Simpler</FONT></A><FONT class=extract>). </FONT>
<P><A name=index-directive-54></A></P>
<LI><FONT class=extract>A <DFN>directive</DFN> is an instruction for <CODE>make</CODE> to do something special while reading the makefile. These include: </FONT>
<UL>
<LI><FONT class=extract>Reading another makefile (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Include"><FONT class=extract>Including Other Makefiles</FONT></A><FONT class=extract>). </FONT>
<LI><FONT class=extract>Deciding (based on the values of variables) whether to use or ignore a part of the makefile (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Conditionals"><FONT class=extract>Conditional Parts of Makefiles</FONT></A><FONT class=extract>). </FONT>
<LI><FONT class=extract>Defining a variable from a verbatim string containing multiple lines (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Multi_002dLine"><FONT class=extract>Defining Multi-Line Variables</FONT></A><FONT class=extract>). </FONT></LI></UL>
<P><A name=index-comments_002c-in-makefile-55><FONT class=extract></FONT></A><A name=index-g_t_0040code_007b_0023_007d-_0028comments_0029_002c-in-makefile-56></A></P>
<LI><FONT class=extract>&#8216;<SAMP><SPAN class=samp>#</SPAN></SAMP>&#8217; in a line of a makefile starts a <DFN>comment</DFN>. It and the rest of the line are ignored, except that a trailing backslash not escaped by another backslash will continue the comment across multiple lines. A line containing just a comment (with perhaps spaces before it) is effectively blank, and is ignored. If you want a literal <CODE>#</CODE>, escape it with a backslash (e.g., <CODE>\#</CODE>). Comments may appear on any line in the makefile, although they are treated specially in certain situations. </FONT>
<P><FONT class=extract>You cannot use comments within variable references or function calls: any instance of <CODE>#</CODE> will be treated literally (rather than as the start of a comment) inside a variable reference or function call. </FONT>
<P><FONT class=extract>Comments within a recipe are passed to the shell, just as with any other recipe text. The shell decides how to interpret it: whether or not this is a comment is up to the shell. </FONT>
<P><FONT class=extract>Within a <CODE>define</CODE> directive, comments are not ignored during the definition of the variable, but rather kept intact in the value of the variable. When the variable is expanded they will either be treated as <CODE>make</CODE> comments or as recipe text, depending on the context in which the variable is evaluated. </FONT></P></LI></UL>
<UL class=menu>
<LI><A accessKey=1 href="https://www.gnu.org/software/make/manual/make.html#Splitting-Lines">Splitting Lines</A>: Splitting long lines in makefiles </LI></UL>
<DIV class=node><A name=Splitting-Lines></A>
<P>
<HR>
Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Makefile-Contents" rel=previous>Makefile Contents</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Makefile-Contents" rel=up>Makefile Contents</A> </DIV>
<H4 class=subsection><FONT class=extract>3.1.1 Splitting Long Lines</FONT></H4>
<P><A name=index-splitting-long-lines-57></A><A name=index-long-lines_002c-splitting-58></A><A name=index-backslash-_0028_0040code_007b_005c_007d_0029_002c-to-quote-newlines-59></A><FONT class=extract>Makefiles use a &#8220;line-based&#8221; syntax in which the newline character is special and marks the end of a statement. GNU <CODE>make</CODE> has no limit on the length of a statement line, up to the amount of memory in your computer. </FONT>
<P><FONT class=extract>However, it is difficult to read lines which are too long to display without wrapping or scrolling. So, you can format your makefiles for readability by adding newlines into the middle of a statement: you do this by escaping the internal newlines with a backslash (<CODE>\</CODE>) character. Where we need to make a distinction we will refer to &#8220;physical lines&#8221; as a single line ending with a newline (regardless of whether it is escaped) and a &#8220;logical line&#8221; being a complete statement including all escaped newlines up to the first non-escaped newline. </FONT>
<P><FONT class=extract>The way in which backslash/newline combinations are handled depends on whether the statement is a recipe line or a non-recipe line. Handling of backslash/newline in a recipe line is discussed later (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Splitting-Recipe-Lines"><FONT class=extract>Splitting Recipe Lines</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>Outside of recipe lines, backslash/newlines are converted into a single space character. Once that is done, all whitespace around the backslash/newline is condensed into a single space: this includes all whitespace preceding the backslash, all whitespace at the beginning of the line after the backslash/newline, and any consecutive backslash/newline combinations. </FONT>
<P><FONT class=extract>If the <CODE>.POSIX</CODE> special target is defined then backslash/newline handling is modified slightly to conform to POSIX.2: first, whitespace preceding a backslash is not removed and second, consecutive backslash/newlines are not condensed. </FONT>
<DIV class=node><A name=Makefile-Names></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Include" rel=next>Include</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Makefile-Contents" rel=previous>Makefile Contents</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Makefiles" rel=up>Makefiles</A> </DIV>
<H3 class=section><FONT class=extract>3.2 What Name to Give Your Makefile</FONT></H3>
<P><A name=index-makefile-name-60></A><A name=index-name-of-makefile-61></A><A name=index-default-makefile-name-62></A><A name=index-file-name-of-makefile-63></A><!-- following paragraph rewritten to avoid overfull hbox --><FONT class=extract>By default, when <CODE>make</CODE> looks for the makefile, it tries the following names, in order: <SAMP><SPAN class=file>GNUmakefile</SPAN></SAMP>, <SAMP><SPAN class=file>makefile</SPAN></SAMP> and <SAMP><SPAN class=file>Makefile</SPAN></SAMP>. </FONT><A name=index-Makefile-64></A><A name=index-GNUmakefile-65></A><A name=index-makefile-66></A><A name=index-g_t_0040code_007bREADME_007d-67></A><FONT class=extract>Normally you should call your makefile either <SAMP><SPAN class=file>makefile</SPAN></SAMP> or <SAMP><SPAN class=file>Makefile</SPAN></SAMP>. (We recommend <SAMP><SPAN class=file>Makefile</SPAN></SAMP> because it appears prominently near the beginning of a directory listing, right near other important files such as <SAMP><SPAN class=file>README</SPAN></SAMP>.) The first name checked, <SAMP><SPAN class=file>GNUmakefile</SPAN></SAMP>, is not recommended for most makefiles. You should use this name if you have a makefile that is specific to GNU <CODE>make</CODE>, and will not be understood by other versions of <CODE>make</CODE>. Other <CODE>make</CODE> programs look for <SAMP><SPAN class=file>makefile</SPAN></SAMP> and <SAMP><SPAN class=file>Makefile</SPAN></SAMP>, but not <SAMP><SPAN class=file>GNUmakefile</SPAN></SAMP>. </FONT>
<P><FONT class=extract>If <CODE>make</CODE> finds none of these names, it does not use any makefile. Then you must specify a goal with a command argument, and <CODE>make</CODE> will attempt to figure out how to remake it using only its built-in implicit rules. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules"><FONT class=extract>Using Implicit Rules</FONT></A><FONT class=extract>. </FONT>
<P><A name=index-g_t_0040code_007b_002df_007d-68></A><A name=index-g_t_0040code_007b_002d_002dfile_007d-69></A><A name=index-g_t_0040code_007b_002d_002dmakefile_007d-70></A><FONT class=extract>If you want to use a nonstandard name for your makefile, you can specify the makefile name with the &#8216;<SAMP><SPAN class=samp>-f</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>--file</SPAN></SAMP>&#8217; option. The arguments &#8216;<SAMP><SPAN class=samp>-f&nbsp;</SPAN><VAR>name</VAR></SAMP>&#8217;<!-- /@w --> or &#8216;<SAMP><SPAN class=samp>--file=</SPAN><VAR>name</VAR></SAMP>&#8217;<!-- /@w --> tell <CODE>make</CODE> to read the file <VAR>name</VAR> as the makefile. If you use more than one &#8216;<SAMP><SPAN class=samp>-f</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>--file</SPAN></SAMP>&#8217; option, you can specify several makefiles. All the makefiles are effectively concatenated in the order specified. The default makefile names <SAMP><SPAN class=file>GNUmakefile</SPAN></SAMP>, <SAMP><SPAN class=file>makefile</SPAN></SAMP> and <SAMP><SPAN class=file>Makefile</SPAN></SAMP> are not checked automatically if you specify &#8216;<SAMP><SPAN class=samp>-f</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>--file</SPAN></SAMP>&#8217;.</FONT> <A name=index-specifying-makefile-name-71></A><A name=index-makefile-name_002c-how-to-specify-72></A><A name=index-name-of-makefile_002c-how-to-specify-73></A><A name=index-file-name-of-makefile_002c-how-to-specify-74></A>
<DIV class=node><A name=Include></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#MAKEFILES-Variable" rel=next>MAKEFILES Variable</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Makefile-Names" rel=previous>Makefile Names</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Makefiles" rel=up>Makefiles</A> </DIV>
<H3 class=section><FONT class=extract>3.3 Including Other Makefiles</FONT></H3>
<P><A name=index-including-other-makefiles-75></A><A name=index-makefile_002c-including-76></A><A name=index-include-77></A><FONT class=extract>The <CODE>include</CODE> directive tells <CODE>make</CODE> to suspend reading the current makefile and read one or more other makefiles before continuing. The directive is a line in the makefile that looks like this: </FONT><PRE class=example><FONT class=extract>     include <VAR>filenames</VAR>...
</FONT></PRE>
<P class=noindent><FONT class=extract><VAR>filenames</VAR> can contain shell file name patterns. If <VAR>filenames</VAR> is empty, nothing is included and no error is printed. </FONT><A name=index-shell-file-name-pattern-_0028in-_0040code_007binclude_007d_0029-78></A><A name=index-shell-wildcards-_0028in-_0040code_007binclude_007d_0029-79></A><A name=index-wildcard_002c-in-_0040code_007binclude_007d-80></A><FONT class=extract>Extra spaces are allowed and ignored at the beginning of the line, but the first character must not be a tab (or the value of <CODE>.RECIPEPREFIX</CODE>)&#8212;if the line begins with a tab, it will be considered a recipe line. Whitespace is required between <CODE>include</CODE> and the file names, and between file names; extra whitespace is ignored there and at the end of the directive. A comment starting with &#8216;<SAMP><SPAN class=samp>#</SPAN></SAMP>&#8217; is allowed at the end of the line. If the file names contain any variable or function references, they are expanded. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Using-Variables"><FONT class=extract>How to Use Variables</FONT></A><FONT class=extract>. </FONT>
<P><FONT class=extract>For example, if you have three <SAMP><SPAN class=file>.mk</SPAN></SAMP> files, <SAMP><SPAN class=file>a.mk</SPAN></SAMP>, <SAMP><SPAN class=file>b.mk</SPAN></SAMP>, and <SAMP><SPAN class=file>c.mk</SPAN></SAMP>, and <CODE>$(bar)</CODE> expands to <CODE>bish bash</CODE>, then the following expression </FONT><PRE class=example><FONT class=extract>     include foo *.mk $(bar)
</FONT></PRE>
<P><FONT class=extract>is equivalent to </FONT><PRE class=example><FONT class=extract>     include foo a.mk b.mk c.mk bish bash
</FONT></PRE>
<P><FONT class=extract>When <CODE>make</CODE> processes an <CODE>include</CODE> directive, it suspends reading of the containing makefile and reads from each listed file in turn. When that is finished, <CODE>make</CODE> resumes reading the makefile in which the directive appears. </FONT>
<P><FONT class=extract>One occasion for using <CODE>include</CODE> directives is when several programs, handled by individual makefiles in various directories, need to use a common set of variable definitions (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Setting"><FONT class=extract>Setting Variables</FONT></A><FONT class=extract>) or pattern rules (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules"><FONT class=extract>Defining and Redefining Pattern Rules</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>Another such occasion is when you want to generate prerequisites from source files automatically; the prerequisites can be put in a file that is included by the main makefile. This practice is generally cleaner than that of somehow appending the prerequisites to the end of the main makefile as has been traditionally done with other versions of <CODE>make</CODE>. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Automatic-Prerequisites"><FONT class=extract>Automatic Prerequisites</FONT></A><FONT class=extract>. </FONT><A name=index-prerequisites_002c-automatic-generation-81></A><A name=index-automatic-generation-of-prerequisites-82></A><A name=index-generating-prerequisites-automatically-83></A><A name=index-g_t_0040code_007b_002dI_007d-84></A><A name=index-g_t_0040code_007b_002d_002dinclude_002ddir_007d-85></A><A name=index-included-makefiles_002c-default-directories-86></A><A name=index-default-directories-for-included-makefiles-87></A><A name=index-g_t_002fusr_002fgnu_002finclude-88></A><A name=index-g_t_002fusr_002flocal_002finclude-89></A><A name=index-g_t_002fusr_002finclude-90></A><FONT class=extract>If the specified name does not start with a slash, and the file is not found in the current directory, several other directories are searched. First, any directories you have specified with the &#8216;<SAMP><SPAN class=samp>-I</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>--include-dir</SPAN></SAMP>&#8217; option are searched (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Options-Summary"><FONT class=extract>Summary of Options</FONT></A><FONT class=extract>). Then the following directories (if they exist) are searched, in this order: <SAMP><VAR>prefix</VAR><SPAN class=file>/include</SPAN></SAMP> (normally <SAMP><SPAN class=file>/usr/local/include</SPAN></SAMP> </FONT><A href="https://www.gnu.org/software/make/manual/make.html#fn-1" rel=footnote name=fnd-1><SUP><FONT class=extract>1</FONT></SUP></A><FONT class=extract>) <SAMP><SPAN class=file>/usr/gnu/include</SPAN></SAMP>, <SAMP><SPAN class=file>/usr/local/include</SPAN></SAMP>, <SAMP><SPAN class=file>/usr/include</SPAN></SAMP>. </FONT>
<P><FONT class=extract>If an included makefile cannot be found in any of these directories, a warning message is generated, but it is not an immediately fatal error; processing of the makefile containing the <CODE>include</CODE> continues. Once it has finished reading makefiles, <CODE>make</CODE> will try to remake any that are out of date or don't exist. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Remaking-Makefiles"><FONT class=extract>How Makefiles Are Remade</FONT></A><FONT class=extract>. Only after it has tried to find a way to remake a makefile and failed, will <CODE>make</CODE> diagnose the missing makefile as a fatal error. </FONT>
<P><FONT class=extract>If you want <CODE>make</CODE> to simply ignore a makefile which does not exist or cannot be remade, with no error message, use the <CODE>-include</CODE><!-- /@w --> directive instead of <CODE>include</CODE>, like this: </FONT><PRE class=example><FONT class=extract>     -include <VAR>filenames</VAR>...
</FONT></PRE>
<P><FONT class=extract>This acts like <CODE>include</CODE> in every way except that there is no error (not even a warning) if any of the <VAR>filenames</VAR> (or any prerequisites of any of the <VAR>filenames</VAR>) do not exist or cannot be remade. </FONT>
<P><FONT class=extract>For compatibility with some other <CODE>make</CODE> implementations, <CODE>sinclude</CODE> is another name for <CODE>-include</CODE><!-- /@w -->.</FONT> 
<DIV class=node><A name=MAKEFILES-Variable></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Remaking-Makefiles" rel=next>Remaking Makefiles</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Include" rel=previous>Include</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Makefiles" rel=up>Makefiles</A> </DIV>
<H3 class=section><FONT class=extract>3.4 The Variable <CODE>MAKEFILES</CODE></FONT></H3>
<P><A name=index-makefile_002c-and-_0040code_007bMAKEFILES_007d-variable-91></A><A name=index-including-_0028_0040code_007bMAKEFILES_007d-variable_0029-92></A><A name=index-MAKEFILES-93></A><FONT class=extract>If the environment variable <CODE>MAKEFILES</CODE> is defined, <CODE>make</CODE> considers its value as a list of names (separated by whitespace) of additional makefiles to be read before the others. This works much like the <CODE>include</CODE> directive: various directories are searched for those files (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Include"><FONT class=extract>Including Other Makefiles</FONT></A><FONT class=extract>). In addition, the default goal is never taken from one of these makefiles (or any makefile included by them) and it is not an error if the files listed in <CODE>MAKEFILES</CODE> are not found. </FONT>
<P><A name=index-recursion_002c-and-_0040code_007bMAKEFILES_007d-variable-94></A><FONT class=extract>The main use of <CODE>MAKEFILES</CODE> is in communication between recursive invocations of <CODE>make</CODE> (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Recursion"><FONT class=extract>Recursive Use of <CODE>make</CODE></FONT></A><FONT class=extract>). It usually is not desirable to set the environment variable before a top-level invocation of <CODE>make</CODE>, because it is usually better not to mess with a makefile from outside. However, if you are running <CODE>make</CODE> without a specific makefile, a makefile in <CODE>MAKEFILES</CODE> can do useful things to help the built-in implicit rules work better, such as defining search paths (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Directory-Search"><FONT class=extract>Directory Search</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>Some users are tempted to set <CODE>MAKEFILES</CODE> in the environment automatically on login, and program makefiles to expect this to be done. This is a very bad idea, because such makefiles will fail to work if run by anyone else. It is much better to write explicit <CODE>include</CODE> directives in the makefiles. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Include"><FONT class=extract>Including Other Makefiles</FONT></A><FONT class=extract>.</FONT> 
<DIV class=node><A name=Remaking-Makefiles></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Overriding-Makefiles" rel=next>Overriding Makefiles</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#MAKEFILES-Variable" rel=previous>MAKEFILES Variable</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Makefiles" rel=up>Makefiles</A> </DIV>
<H3 class=section><FONT class=extract>3.5 How Makefiles Are Remade</FONT></H3>
<P><A name=index-updating-makefiles-95></A><A name=index-remaking-makefiles-96></A><A name=index-makefile_002c-remaking-of-97></A><FONT class=extract>Sometimes makefiles can be remade from other files, such as RCS or SCCS files. If a makefile can be remade from other files, you probably want <CODE>make</CODE> to get an up-to-date version of the makefile to read in. </FONT>
<P><FONT class=extract>To this end, after reading in all makefiles, <CODE>make</CODE> will consider each as a goal target and attempt to update it. If a makefile has a rule which says how to update it (found either in that very makefile or in another one) or if an implicit rule applies to it (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules"><FONT class=extract>Using Implicit Rules</FONT></A><FONT class=extract>), it will be updated if necessary. After all makefiles have been checked, if any have actually been changed, <CODE>make</CODE> starts with a clean slate and reads all the makefiles over again. (It will also attempt to update each of them over again, but normally this will not change them again, since they are already up to date.) </FONT>
<P><FONT class=extract>If you know that one or more of your makefiles cannot be remade and you want to keep <CODE>make</CODE> from performing an implicit rule search on them, perhaps for efficiency reasons, you can use any normal method of preventing implicit rule look-up to do so. For example, you can write an explicit rule with the makefile as the target, and an empty recipe (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Empty-Recipes"><FONT class=extract>Using Empty Recipes</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>If the makefiles specify a double-colon rule to remake a file with a recipe but no prerequisites, that file will always be remade (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Double_002dColon"><FONT class=extract>Double-Colon</FONT></A><FONT class=extract>). In the case of makefiles, a makefile that has a double-colon rule with a recipe but no prerequisites will be remade every time <CODE>make</CODE> is run, and then again after <CODE>make</CODE> starts over and reads the makefiles in again. This would cause an infinite loop: <CODE>make</CODE> would constantly remake the makefile, and never do anything else. So, to avoid this, <CODE>make</CODE> will <STRONG>not</STRONG> attempt to remake makefiles which are specified as targets of a double-colon rule with a recipe but no prerequisites. </FONT>
<P><FONT class=extract>If you do not specify any makefiles to be read with &#8216;<SAMP><SPAN class=samp>-f</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>--file</SPAN></SAMP>&#8217; options, <CODE>make</CODE> will try the default makefile names; see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Makefile-Names"><FONT class=extract>What Name to Give Your Makefile</FONT></A><FONT class=extract>. Unlike makefiles explicitly requested with &#8216;<SAMP><SPAN class=samp>-f</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>--file</SPAN></SAMP>&#8217; options, <CODE>make</CODE> is not certain that these makefiles should exist. However, if a default makefile does not exist but can be created by running <CODE>make</CODE> rules, you probably want the rules to be run so that the makefile can be used. </FONT>
<P><FONT class=extract>Therefore, if none of the default makefiles exists, <CODE>make</CODE> will try to make each of them in the same order in which they are searched for (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Makefile-Names"><FONT class=extract>What Name to Give Your Makefile</FONT></A><FONT class=extract>) until it succeeds in making one, or it runs out of names to try. Note that it is not an error if <CODE>make</CODE> cannot find or make any makefile; a makefile is not always necessary. </FONT>
<P><FONT class=extract>When you use the &#8216;<SAMP><SPAN class=samp>-t</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>--touch</SPAN></SAMP>&#8217; option (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Instead-of-Execution"><FONT class=extract>Instead of Executing Recipes</FONT></A><FONT class=extract>), you would not want to use an out-of-date makefile to decide which targets to touch. So the &#8216;<SAMP><SPAN class=samp>-t</SPAN></SAMP>&#8217; option has no effect on updating makefiles; they are really updated even if &#8216;<SAMP><SPAN class=samp>-t</SPAN></SAMP>&#8217; is specified. Likewise, &#8216;<SAMP><SPAN class=samp>-q</SPAN></SAMP>&#8217; (or &#8216;<SAMP><SPAN class=samp>--question</SPAN></SAMP>&#8217;) and &#8216;<SAMP><SPAN class=samp>-n</SPAN></SAMP>&#8217; (or &#8216;<SAMP><SPAN class=samp>--just-print</SPAN></SAMP>&#8217;) do not prevent updating of makefiles, because an out-of-date makefile would result in the wrong output for other targets. Thus, &#8216;<SAMP><SPAN class=samp>make -f mfile -n foo</SPAN></SAMP>&#8217; will update <SAMP><SPAN class=file>mfile</SPAN></SAMP>, read it in, and then print the recipe to update <SAMP><SPAN class=file>foo</SPAN></SAMP> and its prerequisites without running it. The recipe printed for <SAMP><SPAN class=file>foo</SPAN></SAMP> will be the one specified in the updated contents of <SAMP><SPAN class=file>mfile</SPAN></SAMP>. </FONT>
<P><FONT class=extract>However, on occasion you might actually wish to prevent updating of even the makefiles. You can do this by specifying the makefiles as goals in the command line as well as specifying them as makefiles. When the makefile name is specified explicitly as a goal, the options &#8216;<SAMP><SPAN class=samp>-t</SPAN></SAMP>&#8217; and so on do apply to them. </FONT>
<P><FONT class=extract>Thus, &#8216;<SAMP><SPAN class=samp>make -f mfile -n mfile foo</SPAN></SAMP>&#8217; would read the makefile <SAMP><SPAN class=file>mfile</SPAN></SAMP>, print the recipe needed to update it without actually running it, and then print the recipe needed to update <SAMP><SPAN class=file>foo</SPAN></SAMP> without running that. The recipe for <SAMP><SPAN class=file>foo</SPAN></SAMP> will be the one specified by the existing contents of <SAMP><SPAN class=file>mfile</SPAN></SAMP>.</FONT> 
<DIV class=node><A name=Overriding-Makefiles></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Reading-Makefiles" rel=next>Reading Makefiles</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Remaking-Makefiles" rel=previous>Remaking Makefiles</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Makefiles" rel=up>Makefiles</A> </DIV>
<H3 class=section><FONT class=extract>3.6 Overriding Part of Another Makefile</FONT></H3>
<P><A name=index-overriding-makefiles-98></A><A name=index-makefile_002c-overriding-99></A><FONT class=extract>Sometimes it is useful to have a makefile that is mostly just like another makefile. You can often use the &#8216;<SAMP><SPAN class=samp>include</SPAN></SAMP>&#8217; directive to include one in the other, and add more targets or variable definitions. However, it is invalid for two makefiles to give different recipes for the same target. But there is another way. </FONT>
<P><A name=index-match_002danything-rule_002c-used-to-override-100></A><FONT class=extract>In the containing makefile (the one that wants to include the other), you can use a match-anything pattern rule to say that to remake any target that cannot be made from the information in the containing makefile, <CODE>make</CODE> should look in another makefile. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules"><FONT class=extract>Pattern Rules</FONT></A><FONT class=extract>, for more information on pattern rules. </FONT>
<P><FONT class=extract>For example, if you have a makefile called <SAMP><SPAN class=file>Makefile</SPAN></SAMP> that says how to make the target &#8216;<SAMP><SPAN class=samp>foo</SPAN></SAMP>&#8217; (and other targets), you can write a makefile called <SAMP><SPAN class=file>GNUmakefile</SPAN></SAMP> that contains: </FONT><PRE class=example><FONT class=extract>     foo:
             frobnicate &gt; foo
     
     %: force
             @$(MAKE) -f Makefile $@
     force: ;
</FONT></PRE>
<P><FONT class=extract>If you say &#8216;<SAMP><SPAN class=samp>make foo</SPAN></SAMP>&#8217;, <CODE>make</CODE> will find <SAMP><SPAN class=file>GNUmakefile</SPAN></SAMP>, read it, and see that to make <SAMP><SPAN class=file>foo</SPAN></SAMP>, it needs to run the recipe &#8216;<SAMP><SPAN class=samp>frobnicate &gt; foo</SPAN></SAMP>&#8217;. If you say &#8216;<SAMP><SPAN class=samp>make bar</SPAN></SAMP>&#8217;, <CODE>make</CODE> will find no way to make <SAMP><SPAN class=file>bar</SPAN></SAMP> in <SAMP><SPAN class=file>GNUmakefile</SPAN></SAMP>, so it will use the recipe from the pattern rule: &#8216;<SAMP><SPAN class=samp>make -f Makefile bar</SPAN></SAMP>&#8217;. If <SAMP><SPAN class=file>Makefile</SPAN></SAMP> provides a rule for updating <SAMP><SPAN class=file>bar</SPAN></SAMP>, <CODE>make</CODE> will apply the rule. And likewise for any other target that <SAMP><SPAN class=file>GNUmakefile</SPAN></SAMP> does not say how to make. </FONT>
<P><FONT class=extract>The way this works is that the pattern rule has a pattern of just &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;, so it matches any target whatever. The rule specifies a prerequisite <SAMP><SPAN class=file>force</SPAN></SAMP>, to guarantee that the recipe will be run even if the target file already exists. We give the <SAMP><SPAN class=file>force</SPAN></SAMP> target an empty recipe to prevent <CODE>make</CODE> from searching for an implicit rule to build it&#8212;otherwise it would apply the same match-anything rule to <SAMP><SPAN class=file>force</SPAN></SAMP> itself and create a prerequisite loop! </FONT>
<DIV class=node><A name=Reading-Makefiles></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Secondary-Expansion" rel=next>Secondary Expansion</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Overriding-Makefiles" rel=previous>Overriding Makefiles</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Makefiles" rel=up>Makefiles</A> </DIV>
<H3 class=section><FONT class=extract>3.7 How <CODE>make</CODE> Reads a Makefile</FONT></H3>
<P><A name=index-reading-makefiles-101></A><A name=index-makefile_002c-parsing-102></A><FONT class=extract>GNU <CODE>make</CODE> does its work in two distinct phases. During the first phase it reads all the makefiles, included makefiles, etc. and internalizes all the variables and their values, implicit and explicit rules, and constructs a dependency graph of all the targets and their prerequisites. During the second phase, <CODE>make</CODE> uses these internal structures to determine what targets will need to be rebuilt and to invoke the rules necessary to do so. </FONT>
<P><FONT class=extract>It's important to understand this two-phase approach because it has a direct impact on how variable and function expansion happens; this is often a source of some confusion when writing makefiles. Here we will present a summary of the phases in which expansion happens for different constructs within the makefile. We say that expansion is <DFN>immediate</DFN> if it happens during the first phase: in this case <CODE>make</CODE> will expand any variables or functions in that section of a construct as the makefile is parsed. We say that expansion is <DFN>deferred</DFN> if expansion is not performed immediately. Expansion of a deferred construct is not performed until either the construct appears later in an immediate context, or until the second phase. </FONT>
<P><FONT class=extract>You may not be familiar with some of these constructs yet. You can reference this section as you become familiar with them, in later chapters. </FONT>
<H4 class=subheading><FONT class=extract>Variable Assignment</FONT></H4>
<P><A name=index-g_t_002b_003d_002c-expansion-103></A><A name=index-g_t_003d_002c-expansion-104></A><A name=index-g_t_003f_003d_002c-expansion-105></A><A name=index-g_t_002b_003d_002c-expansion-106></A><A name=index-g_t_0021_003d_002c-expansion-107></A><A name=index-define_002c-expansion-108></A><FONT class=extract>Variable definitions are parsed as follows: </FONT><PRE class=example><FONT class=extract>     <VAR>immediate</VAR> = <VAR>deferred</VAR>
     <VAR>immediate</VAR> ?= <VAR>deferred</VAR>
     <VAR>immediate</VAR> := <VAR>immediate</VAR>
     <VAR>immediate</VAR> ::= <VAR>immediate</VAR>
     <VAR>immediate</VAR> += <VAR>deferred</VAR> or <VAR>immediate</VAR>
     <VAR>immediate</VAR> != <VAR>immediate</VAR>
     
     define <VAR>immediate</VAR>
       <VAR>deferred</VAR>
     endef
     
     define <VAR>immediate</VAR> =
       <VAR>deferred</VAR>
     endef
     
     define <VAR>immediate</VAR> ?=
       <VAR>deferred</VAR>
     endef
     
     define <VAR>immediate</VAR> :=
       <VAR>immediate</VAR>
     endef
     
     define <VAR>immediate</VAR> ::=
       <VAR>immediate</VAR>
     endef
     
     define <VAR>immediate</VAR> +=
       <VAR>deferred</VAR> or <VAR>immediate</VAR>
     endef
     
     define <VAR>immediate</VAR> !=
       <VAR>immediate</VAR>
     endef
</FONT></PRE>
<P><FONT class=extract>For the append operator, &#8216;<SAMP><SPAN class=samp>+=</SPAN></SAMP>&#8217;, the right-hand side is considered immediate if the variable was previously set as a simple variable (&#8216;<SAMP><SPAN class=samp>:=</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>::=</SPAN></SAMP>&#8217;), and deferred otherwise. </FONT>
<P><FONT class=extract>For the shell assignment operator, &#8216;<SAMP><SPAN class=samp>!=</SPAN></SAMP>&#8217;, the right-hand side is evaluated immediately and handed to the shell. The result is stored in the variable named on the left, and that variable becomes a simple variable (and will thus be re-evaluated on each reference). </FONT>
<H4 class=subheading><FONT class=extract>Conditional Directives</FONT></H4>
<P><A name=index-ifdef_002c-expansion-109></A><A name=index-ifeq_002c-expansion-110></A><A name=index-ifndef_002c-expansion-111></A><A name=index-ifneq_002c-expansion-112></A><FONT class=extract>Conditional directives are parsed immediately. This means, for example, that automatic variables cannot be used in conditional directives, as automatic variables are not set until the recipe for that rule is invoked. If you need to use automatic variables in a conditional directive you <EM>must</EM> move the condition into the recipe and use shell conditional syntax instead. </FONT>
<H4 class=subheading><FONT class=extract>Rule Definition</FONT></H4>
<P><A name=index-target_002c-expansion-113></A><A name=index-prerequisite_002c-expansion-114></A><A name=index-implicit-rule_002c-expansion-115></A><A name=index-pattern-rule_002c-expansion-116></A><A name=index-explicit-rule_002c-expansion-117></A><FONT class=extract>A rule is always expanded the same way, regardless of the form: </FONT><PRE class=example><FONT class=extract>     <VAR>immediate</VAR> : <VAR>immediate</VAR> ; <VAR>deferred</VAR>
     	<VAR>deferred</VAR>
</FONT></PRE>
<P><FONT class=extract>That is, the target and prerequisite sections are expanded immediately, and the recipe used to construct the target is always deferred. This general rule is true for explicit rules, pattern rules, suffix rules, static pattern rules, and simple prerequisite definitions.</FONT> 
<DIV class=node><A name=Secondary-Expansion></A>
<P>
<HR>
Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Reading-Makefiles" rel=previous>Reading Makefiles</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Makefiles" rel=up>Makefiles</A> </DIV>
<H3 class=section><FONT class=extract>3.8 Secondary Expansion</FONT></H3>
<P><A name=index-secondary-expansion-118></A><A name=index-expansion_002c-secondary-119></A><A name=index-g_t_002eSECONDEXPANSION-120></A><FONT class=extract>In the previous section we learned that GNU <CODE>make</CODE> works in two distinct phases: a read-in phase and a target-update phase (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Reading-Makefiles"><FONT class=extract>How <CODE>make</CODE> Reads a Makefile</FONT></A><FONT class=extract>). GNU make also has the ability to enable a <EM>second expansion</EM> of the prerequisites (only) for some or all targets defined in the makefile. In order for this second expansion to occur, the special target <CODE>.SECONDEXPANSION</CODE> must be defined before the first prerequisite list that makes use of this feature. </FONT>
<P><FONT class=extract>If that special target is defined then in between the two phases mentioned above, right at the end of the read-in phase, all the prerequisites of the targets defined after the special target are expanded a <EM>second time</EM>. In most circumstances this secondary expansion will have no effect, since all variable and function references will have been expanded during the initial parsing of the makefiles. In order to take advantage of the secondary expansion phase of the parser, then, it's necessary to <EM>escape</EM> the variable or function reference in the makefile. In this case the first expansion merely un-escapes the reference but doesn't expand it, and expansion is left to the secondary expansion phase. For example, consider this makefile: </FONT><PRE class=example><FONT class=extract>     .SECONDEXPANSION:
     ONEVAR = onefile
     TWOVAR = twofile
     myfile: $(ONEVAR) $$(TWOVAR)
</FONT></PRE>
<P><FONT class=extract>After the first expansion phase the prerequisites list of the <SAMP><SPAN class=file>myfile</SPAN></SAMP> target will be <CODE>onefile</CODE> and <CODE>$(TWOVAR)</CODE>; the first (unescaped) variable reference to <VAR>ONEVAR</VAR> is expanded, while the second (escaped) variable reference is simply unescaped, without being recognized as a variable reference. Now during the secondary expansion the first word is expanded again but since it contains no variable or function references it remains the value <SAMP><SPAN class=file>onefile</SPAN></SAMP>, while the second word is now a normal reference to the variable <VAR>TWOVAR</VAR>, which is expanded to the value <SAMP><SPAN class=file>twofile</SPAN></SAMP>. The final result is that there are two prerequisites, <SAMP><SPAN class=file>onefile</SPAN></SAMP> and <SAMP><SPAN class=file>twofile</SPAN></SAMP>. </FONT>
<P><FONT class=extract>Obviously, this is not a very interesting case since the same result could more easily have been achieved simply by having both variables appear, unescaped, in the prerequisites list. One difference becomes apparent if the variables are reset; consider this example: </FONT><PRE class=example><FONT class=extract>     .SECONDEXPANSION:
     AVAR = top
     onefile: $(AVAR)
     twofile: $$(AVAR)
     AVAR = bottom
</FONT></PRE>
<P><FONT class=extract>Here the prerequisite of <SAMP><SPAN class=file>onefile</SPAN></SAMP> will be expanded immediately, and resolve to the value <SAMP><SPAN class=file>top</SPAN></SAMP>, while the prerequisite of <SAMP><SPAN class=file>twofile</SPAN></SAMP> will not be full expanded until the secondary expansion and yield a value of <SAMP><SPAN class=file>bottom</SPAN></SAMP>. </FONT>
<P><FONT class=extract>This is marginally more exciting, but the true power of this feature only becomes apparent when you discover that secondary expansions always take place within the scope of the automatic variables for that target. This means that you can use variables such as <CODE>$@</CODE>, <CODE>$*</CODE>, etc. during the second expansion and they will have their expected values, just as in the recipe. All you have to do is defer the expansion by escaping the <CODE>$</CODE>. Also, secondary expansion occurs for both explicit and implicit (pattern) rules. Knowing this, the possible uses for this feature increase dramatically. For example: </FONT><PRE class=example><FONT class=extract>     .SECONDEXPANSION:
     main_OBJS := main.o try.o test.o
     lib_OBJS := lib.o api.o
     
     main lib: $$($$@_OBJS)
</FONT></PRE>
<P><FONT class=extract>Here, after the initial expansion the prerequisites of both the <SAMP><SPAN class=file>main</SPAN></SAMP> and <SAMP><SPAN class=file>lib</SPAN></SAMP> targets will be <CODE>$($@_OBJS)</CODE>. During the secondary expansion, the <CODE>$@</CODE> variable is set to the name of the target and so the expansion for the <SAMP><SPAN class=file>main</SPAN></SAMP> target will yield <CODE>$(main_OBJS)</CODE>, or <CODE>main.o try.o test.o</CODE>, while the secondary expansion for the <SAMP><SPAN class=file>lib</SPAN></SAMP> target will yield <CODE>$(lib_OBJS)</CODE>, or <CODE>lib.o api.o</CODE>. </FONT>
<P><FONT class=extract>You can also mix in functions here, as long as they are properly escaped: </FONT><PRE class=example><FONT class=extract>     main_SRCS := main.c try.c test.c
     lib_SRCS := lib.c api.c
     
     .SECONDEXPANSION:
     main lib: $$(patsubst %.c,%.o,$$($$@_SRCS))
</FONT></PRE>
<P><FONT class=extract>This version allows users to specify source files rather than object files, but gives the same resulting prerequisites list as the previous example. </FONT>
<P><FONT class=extract>Evaluation of automatic variables during the secondary expansion phase, especially of the target name variable <CODE>$$@</CODE>, behaves similarly to evaluation within recipes. However, there are some subtle differences and &#8220;corner cases&#8221; which come into play for the different types of rule definitions that <CODE>make</CODE> understands. The subtleties of using the different automatic variables are described below. </FONT>
<H4 class=subheading><FONT class=extract>Secondary Expansion of Explicit Rules</FONT></H4>
<P><A name=index-secondary-expansion-and-explicit-rules-121></A><A name=index-explicit-rules_002c-secondary-expansion-of-122></A><FONT class=extract>During the secondary expansion of explicit rules, <CODE>$$@</CODE> and <CODE>$$%</CODE> evaluate, respectively, to the file name of the target and, when the target is an archive member, the target member name. The <CODE>$$&lt;</CODE> variable evaluates to the first prerequisite in the first rule for this target. <CODE>$$^</CODE> and <CODE>$$+</CODE> evaluate to the list of all prerequisites of rules <EM>that have already appeared</EM> for the same target (<CODE>$$+</CODE> with repetitions and <CODE>$$^</CODE> without). The following example will help illustrate these behaviors: </FONT><PRE class=example><FONT class=extract>     .SECONDEXPANSION:
     
     foo: foo.1 bar.1 $$&lt; $$^ $$+    # line #1
     
     foo: foo.2 bar.2 $$&lt; $$^ $$+    # line #2
     
     foo: foo.3 bar.3 $$&lt; $$^ $$+    # line #3
</FONT></PRE>
<P><FONT class=extract>In the first prerequisite list, all three variables (<CODE>$$&lt;</CODE>, <CODE>$$^</CODE>, and <CODE>$$+</CODE>) expand to the empty string. In the second, they will have values <CODE>foo.1</CODE>, <CODE>foo.1 bar.1</CODE>, and <CODE>foo.1 bar.1</CODE> respectively. In the third they will have values <CODE>foo.1</CODE>, <CODE>foo.1 bar.1 foo.2 bar.2</CODE>, and <CODE>foo.1 bar.1 foo.2 bar.2 foo.1 foo.1 bar.1 foo.1 bar.1</CODE> respectively. </FONT>
<P><FONT class=extract>Rules undergo secondary expansion in makefile order, except that the rule with the recipe is always evaluated last. </FONT>
<P><FONT class=extract>The variables <CODE>$$?</CODE> and <CODE>$$*</CODE> are not available and expand to the empty string. </FONT>
<H4 class=subheading><FONT class=extract>Secondary Expansion of Static Pattern Rules</FONT></H4>
<P><A name=index-secondary-expansion-and-static-pattern-rules-123></A><A name=index-static-pattern-rules_002c-secondary-expansion-of-124></A><FONT class=extract>Rules for secondary expansion of static pattern rules are identical to those for explicit rules, above, with one exception: for static pattern rules the <CODE>$$*</CODE> variable is set to the pattern stem. As with explicit rules, <CODE>$$?</CODE> is not available and expands to the empty string. </FONT>
<H4 class=subheading><FONT class=extract>Secondary Expansion of Implicit Rules</FONT></H4>
<P><A name=index-secondary-expansion-and-implicit-rules-125></A><A name=index-implicit-rules_002c-secondary-expansion-of-126></A><FONT class=extract>As <CODE>make</CODE> searches for an implicit rule, it substitutes the stem and then performs secondary expansion for every rule with a matching target pattern. The value of the automatic variables is derived in the same fashion as for static pattern rules. As an example: </FONT><PRE class=example><FONT class=extract>     .SECONDEXPANSION:
     
     foo: bar
     
     foo foz: fo%: bo%
     
     %oo: $$&lt; $$^ $$+ $$*
</FONT></PRE>
<P><FONT class=extract>When the implicit rule is tried for target <SAMP><SPAN class=file>foo</SPAN></SAMP>, <CODE>$$&lt;</CODE> expands to <SAMP><SPAN class=file>bar</SPAN></SAMP>, <CODE>$$^</CODE> expands to <SAMP><SPAN class=file>bar boo</SPAN></SAMP>, <CODE>$$+</CODE> also expands to <SAMP><SPAN class=file>bar boo</SPAN></SAMP>, and <CODE>$$*</CODE> expands to <SAMP><SPAN class=file>f</SPAN></SAMP>. </FONT>
<P><FONT class=extract>Note that the directory prefix (D), as described in </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rule-Search"><FONT class=extract>Implicit Rule Search Algorithm</FONT></A><FONT class=extract>, is appended (after expansion) to all the patterns in the prerequisites list. As an example: </FONT><PRE class=example><FONT class=extract>     .SECONDEXPANSION:
     
     /tmp/foo.o:
     
     %.o: $$(addsuffix /%.c,foo bar) foo.h
             @echo $^
</FONT></PRE>
<P><FONT class=extract>The prerequisite list printed, after the secondary expansion and directory prefix reconstruction, will be <SAMP><SPAN class=file>/tmp/foo/foo.c /tmp/bar/foo.c foo.h</SPAN></SAMP>. If you are not interested in this reconstruction, you can use <CODE>$$*</CODE> instead of <CODE>%</CODE> in the prerequisites list.</FONT>