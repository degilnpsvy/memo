<H2 class=chapter>4 Writing Rules</H2>
<P><A name=index-writing-rules-127></A><A name=index-rule_002c-how-to-write-128></A><A name=index-target-129></A><A name=index-prerequisite-130></A>A <DFN>rule</DFN> appears in the makefile and says when and how to remake certain files, called the rule's <DFN>targets</DFN> (most often only one per rule). It lists the other files that are the <DFN>prerequisites</DFN> of the target, and the <DFN>recipe</DFN> to use to create or update the target. 
<P><A name=index-default-goal-131></A><A name=index-goal_002c-default-132></A><FONT class=extract>The order of rules is not significant, except for determining the <DFN>default goal</DFN>: the target for <CODE>make</CODE> to consider, if you do not otherwise specify one. The default goal is the target of the first rule in the first makefile. If the first rule has multiple targets, only the first target is taken as the default. There are two exceptions: a target starting with a period is not a default unless it contains one or more slashes, &#8216;<SAMP><SPAN class=samp>/</SPAN></SAMP>&#8217;, as well; and, a target that defines a pattern rule has no effect on the default goal. (See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules"><FONT class=extract>Defining and Redefining Pattern Rules</FONT></A><FONT class=extract>.)</FONT> 
<P>Therefore, we usually write the makefile so that the first rule is the one for compiling the entire program or all the programs described by the makefile (often with a target called &#8216;<SAMP><SPAN class=samp>all</SPAN></SAMP>&#8217;). See <A href="https://www.gnu.org/software/make/manual/make.html#Goals">Arguments to Specify the Goals</A>. 
<UL class=menu>
<LI><A accessKey=1 href="https://www.gnu.org/software/make/manual/make.html#Rule-Example">Rule Example</A>: An example explained. 
<LI><A accessKey=2 href="https://www.gnu.org/software/make/manual/make.html#Rule-Syntax">Rule Syntax</A>: General syntax explained. 
<LI><A accessKey=3 href="https://www.gnu.org/software/make/manual/make.html#Prerequisite-Types">Prerequisite Types</A>: There are two types of prerequisites. 
<LI><A accessKey=4 href="https://www.gnu.org/software/make/manual/make.html#Wildcards">Wildcards</A>: Using wildcard characters such as `*'. 
<LI><A accessKey=5 href="https://www.gnu.org/software/make/manual/make.html#Directory-Search">Directory Search</A>: Searching other directories for source files. 
<LI><A accessKey=6 href="https://www.gnu.org/software/make/manual/make.html#Phony-Targets">Phony Targets</A>: Using a target that is not a real file's name. 
<LI><A accessKey=7 href="https://www.gnu.org/software/make/manual/make.html#Force-Targets">Force Targets</A>: You can use a target without a recipe or prerequisites to mark other targets as phony. 
<LI><A accessKey=8 href="https://www.gnu.org/software/make/manual/make.html#Empty-Targets">Empty Targets</A>: When only the date matters and the files are empty. 
<LI><A accessKey=9 href="https://www.gnu.org/software/make/manual/make.html#Special-Targets">Special Targets</A>: Targets with special built-in meanings. 
<LI><A href="https://www.gnu.org/software/make/manual/make.html#Multiple-Targets">Multiple Targets</A>: When to make use of several targets in a rule. 
<LI><A href="https://www.gnu.org/software/make/manual/make.html#Multiple-Rules">Multiple Rules</A>: How to use several rules with the same target. 
<LI><A href="https://www.gnu.org/software/make/manual/make.html#Static-Pattern">Static Pattern</A>: Static pattern rules apply to multiple targets and can vary the prerequisites according to the target name. 
<LI><A href="https://www.gnu.org/software/make/manual/make.html#Double_002dColon">Double-Colon</A>: How to use a special kind of rule to allow several independent rules for one target. 
<LI><A href="https://www.gnu.org/software/make/manual/make.html#Automatic-Prerequisites">Automatic Prerequisites</A>: How to automatically generate rules giving prerequisites from source files themselves. </LI></UL>
<DIV class=node><A name=Rule-Example></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Rule-Syntax" rel=next>Rule Syntax</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=previous>Rules</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV>
<H3 class=section>4.1 Rule Example</H3>
<P>Here is an example of a rule: <PRE class=example>     foo.o : foo.c defs.h       # module for twiddling the frobs
             cc -c -g foo.c
</PRE>
<P>Its target is <SAMP><SPAN class=file>foo.o</SPAN></SAMP> and its prerequisites are <SAMP><SPAN class=file>foo.c</SPAN></SAMP> and <SAMP><SPAN class=file>defs.h</SPAN></SAMP>. It has one command in the recipe: &#8216;<SAMP><SPAN class=samp>cc -c -g foo.c</SPAN></SAMP>&#8217;. The recipe starts with a tab to identify it as a recipe. 
<P>This rule says two things: 
<UL>
<LI>How to decide whether <SAMP><SPAN class=file>foo.o</SPAN></SAMP> is out of date: it is out of date if it does not exist, or if either <SAMP><SPAN class=file>foo.c</SPAN></SAMP> or <SAMP><SPAN class=file>defs.h</SPAN></SAMP> is more recent than it. 
<LI>How to update the file <SAMP><SPAN class=file>foo.o</SPAN></SAMP>: by running <CODE>cc</CODE> as stated. The recipe does not explicitly mention <SAMP><SPAN class=file>defs.h</SPAN></SAMP>, but we presume that <SAMP><SPAN class=file>foo.c</SPAN></SAMP> includes it, and that that is why <SAMP><SPAN class=file>defs.h</SPAN></SAMP> was added to the prerequisites. </LI></UL>
<DIV class=node><A name=Rule-Syntax></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Prerequisite-Types" rel=next>Prerequisite Types</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Rule-Example" rel=previous>Rule Example</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV>
<H3 class=section><FONT class=extract>4.2 Rule Syntax</FONT></H3>
<P><A name=index-rule-syntax-133></A><A name=index-syntax-of-rules-134></A><FONT class=extract>In general, a rule looks like this: </FONT><PRE class=example><FONT class=extract>     <VAR>targets</VAR> : <VAR>prerequisites</VAR>
             <VAR>recipe</VAR>
             ...
</FONT></PRE>
<P class=noindent><FONT class=extract>or like this: </FONT><PRE class=example><FONT class=extract>     <VAR>targets</VAR> : <VAR>prerequisites</VAR> ; <VAR>recipe</VAR>
             <VAR>recipe</VAR>
             ...
</FONT></PRE>
<P><A name=index-targets-135></A><A name=index-rule-targets-136></A><FONT class=extract>The <VAR>targets</VAR> are file names, separated by spaces. Wildcard characters may be used (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Wildcards"><FONT class=extract>Using Wildcard Characters in File Names</FONT></A><FONT class=extract>) and <FONT class=extract>a name of the form <SAMP><VAR>a</VAR><SPAN class=file>(</SPAN><VAR>m</VAR><SPAN class=file>)</SPAN></SAMP> represents member <VAR>m</VAR> in archive file <VAR>a</VAR> (see </FONT></FONT><A href="https://www.gnu.org/software/make/manual/make.html#Archive-Members"><FONT class=extract>Archive Members as Targets</FONT></A><FONT class=extract><FONT class=extract>)</FONT>. Usually there is only one target per rule, but occasionally there is a reason to have more (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Multiple-Targets"><FONT class=extract>Multiple Targets in a Rule</FONT></A><FONT class=extract>). </FONT>
<P><A name=index-recipes-137></A><A name=index-tab-character-_0028in-commands_0029-138></A><FONT class=extract>The <VAR>recipe</VAR> lines start with a tab character (or the first character in the value of the <CODE>.RECIPEPREFIX</CODE> variable; see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Special-Variables"><FONT class=extract>Special Variables</FONT></A><FONT class=extract>). The first recipe line may appear on the line after the prerequisites, with a tab character, or may appear on the same line, with a semicolon. Either way, the effect is the same. There are other differences in the syntax of recipes. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Recipes"><FONT class=extract>Writing Recipes in Rules</FONT></A><FONT class=extract>. </FONT>
<P><A name=index-dollar-sign-_0028_0040code_007b_0024_007d_0029_002c-in-rules-139></A><A name=index-g_t_0040code_007b_0024_007d_002c-in-rules-140></A><A name=index-rules_002c-and-_0040code_007b_0024_007d-141></A><FONT class=extract>Because dollar signs are used to start <CODE>make</CODE> variable references, if you really want a dollar sign in a target or prerequisite you must write two of them, &#8216;<SAMP><SPAN class=samp>$$</SPAN></SAMP>&#8217; (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Using-Variables"><FONT class=extract>How to Use Variables</FONT></A><FONT class=extract><FONT class=extract>).</FONT> <FONT class=extract>If you have enabled secondary expansion (see </FONT></FONT><A href="https://www.gnu.org/software/make/manual/make.html#Secondary-Expansion"><FONT class=extract>Secondary Expansion</FONT></A><FONT class=extract><FONT class=extract>) and you want a literal dollar sign in the prerequisites list, you must actually write <EM>four</EM> dollar signs (&#8216;<SAMP><SPAN class=samp>$$$$</SPAN></SAMP>&#8217;).</FONT> </FONT>
<P><FONT class=extract>You may split a long line by inserting a backslash followed by a newline, but this is not required, as <CODE>make</CODE> places no limit on the length of a line in a makefile. </FONT>
<P><FONT class=extract>A rule tells <CODE>make</CODE> two things: when the targets are out of date, and how to update them when necessary. </FONT>
<P><A name=index-prerequisites-142></A><A name=index-rule-prerequisites-143></A><FONT class=extract>The criterion for being out of date is specified in terms of the <VAR>prerequisites</VAR>, which consist of file names separated by spaces. (Wildcards and archive members (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Archives"><FONT class=extract>Archives</FONT></A><FONT class=extract>) are allowed here too.) A target is out of date if it does not exist or if it is older than any of the prerequisites (by comparison of last-modification times). The idea is that the contents of the target file are computed based on information in the prerequisites, so if any of the prerequisites changes, the contents of the existing target file are no longer necessarily valid. </FONT>
<P><FONT class=extract>How to update is specified by a <VAR>recipe</VAR>. This is one or more lines to be executed by the shell (normally &#8216;<SAMP><SPAN class=samp>sh</SPAN></SAMP>&#8217;), but with some extra features (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Recipes"><FONT class=extract>Writing Recipes in Rules</FONT></A><FONT class=extract>). </FONT>
<DIV class=node><A name=Prerequisite-Types></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Wildcards" rel=next>Wildcards</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Rule-Syntax" rel=previous>Rule Syntax</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV><!-- node-name,  next,  previous,  up -->
<H3 class=section><FONT class=extract>4.3 Types of Prerequisites</FONT></H3>
<P><A name=index-prerequisite-types-144></A><A name=index-types-of-prerequisites-145></A><A name=index-prerequisites_002c-normal-146></A><A name=index-normal-prerequisites-147></A><A name=index-prerequisites_002c-order_002donly-148></A><A name=index-order_002donly-prerequisites-149></A><FONT class=extract><FONT class=extract>There are actually two different types of prerequisites understood by GNU <CODE>make</CODE>: normal prerequisites such as described in the previous section, and <DFN>order-only</DFN> prerequisites.</FONT> A normal prerequisite makes two statements: first, it imposes an order in which recipes will be invoked: the recipes for all prerequisites of a target will be completed before the recipe for the target is run. Second, it imposes a dependency relationship: if any prerequisite is newer than the target, then the target is considered out-of-date and must be rebuilt. </FONT>
<P><FONT class=extract>Normally, this is exactly what you want: if a target's prerequisite is updated, then the target should also be updated. </FONT>
<P><FONT class=extract>Occasionally, however, you have a situation where you want to impose a specific ordering on the rules to be invoked <EM>without</EM> forcing the target to be updated if one of those rules is executed. In that case, you want to define <DFN>order-only</DFN> prerequisites. Order-only prerequisites can be specified by placing a pipe symbol (<CODE>|</CODE>) in the prerequisites list: any prerequisites to the left of the pipe symbol are normal; any prerequisites to the right are order-only: </FONT><PRE class=example><FONT class=extract><FONT class=extract>     <VAR>targets</VAR> : <VAR>normal-prerequisites</VAR> | <VAR>order-only-prerequisites</VAR></FONT>
</FONT></PRE>
<P><FONT class=extract>The normal prerequisites section may of course be empty. Also, you may still declare multiple lines of prerequisites for the same target: they are appended appropriately (normal prerequisites are appended to the list of normal prerequisites; order-only prerequisites are appended to the list of order-only prerequisites). <FONT class=extract>Note that if you declare the same file to be both a normal and an order-only prerequisite, the normal prerequisite takes precedence (since they have a strict superset of the behavior of an order-only prerequisite</FONT>). </FONT>
<P><FONT class=extract>Consider an example where your targets are to be placed in a separate directory, and that directory might not exist before <CODE>make</CODE> is run. In this situation, you want the directory to be created before any targets are placed into it but, because the timestamps on directories change whenever a file is added, removed, or renamed, we certainly don't want to rebuild all the targets whenever the directory's timestamp changes. One way to manage this is with order-only prerequisites: make the directory an order-only prerequisite on all the targets: </FONT><PRE class=example><FONT class=extract>     OBJDIR := objdir
     OBJS := $(addprefix $(OBJDIR)/,foo.o bar.o baz.o)
     
     $(OBJDIR)/%.o : %.c
             $(COMPILE.c) $(OUTPUT_OPTION) $&lt;
     
     all: $(OBJS)
     
     $(OBJS): | $(OBJDIR)
     
     $(OBJDIR):
             mkdir $(OBJDIR)
</FONT></PRE>
<P><FONT class=extract><FONT class=extract>Now the rule to create the <SAMP><SPAN class=file>objdir</SPAN></SAMP> directory will be run, if needed, before any &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; is built, but no &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; will be built because the <SAMP><SPAN class=file>objdir</SPAN></SAMP> directory timestamp changed.</FONT> </FONT>
<DIV class=node><A name=Wildcards></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Directory-Search" rel=next>Directory Search</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Prerequisite-Types" rel=previous>Prerequisite Types</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV>
<H3 class=section><FONT class=extract>4.4 Using Wildcard Characters in File Names</FONT></H3>
<P><A name=index-wildcard-150></A><A name=index-file-name-with-wildcards-151></A><A name=index-globbing-_0028wildcards_0029-152></A><A name=index-g_t_0040code_007b_002a_007d-_0028wildcard-character_0029-153></A><A name=index-g_t_0040code_007b_003f_007d-_0028wildcard-character_0029-154></A><A name=index-g_t_0040code_007b_005b_0040dots_007b_007d_005d_007d-_0028wildcard-characters_0029-155></A><FONT class=extract><FONT class=extract>A single file name can specify many files using <DFN>wildcard characters</DFN>. The wildcard characters in <CODE>make</CODE> are &#8216;<SAMP><SPAN class=samp>*</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>?</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>[...]</SPAN></SAMP>&#8217;, the same as in the Bourne shell.</FONT> For example, <SAMP><SPAN class=file>*.c</SPAN></SAMP> specifies a list of all the files (in the working directory) whose names end in &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217;. </FONT>
<P><A name=index-g_t_0040code_007b_007e_007d-_0028tilde_0029-156></A><A name=index-tilde-_0028_0040code_007b_007e_007d_0029-157></A><A name=index-home-directory-158></A><FONT class=extract>The character &#8216;<SAMP><SPAN class=samp>~</SPAN></SAMP>&#8217; at the beginning of a file name also has special significance. If alone, or followed by a slash, it represents your home directory. For example <SAMP><SPAN class=file>~/bin</SPAN></SAMP> expands to <SAMP><SPAN class=file>/home/you/bin</SPAN></SAMP>. <FONT class=extract>If the &#8216;<SAMP><SPAN class=samp>~</SPAN></SAMP>&#8217; is followed by a word, the string represents the home directory of the user named by that word. For example <SAMP><SPAN class=file>~john/bin</SPAN></SAMP> expands to <SAMP><SPAN class=file>/home/john/bin</SPAN></SAMP>.</FONT> <FONT class=extract>On systems which don't have a home directory for each user (such as MS-DOS or MS-Windows), this functionality can be simulated by setting the environment variable <VAR>HOME</VAR>.</FONT> </FONT>
<P><FONT class=extract><FONT class=extract>Wildcard expansion is performed by <CODE>make</CODE> automatically in targets and in prerequisites. In recipes, the shell is responsible for wildcard expansion. In other contexts, wildcard expansion happens only if you request it explicitly with the <CODE>wildcard</CODE> function.</FONT> </FONT>
<P><FONT class=extract>The special significance of a wildcard character can be turned off by preceding it with a backslash. Thus, <SAMP><SPAN class=file>foo\*bar</SPAN></SAMP> would refer to a specific file whose name consists of &#8216;<SAMP><SPAN class=samp>foo</SPAN></SAMP>&#8217;, an asterisk, and &#8216;<SAMP><SPAN class=samp>bar</SPAN></SAMP>&#8217;. </FONT>
<UL class=menu>
<LI><A accessKey=1 href="https://www.gnu.org/software/make/manual/make.html#Wildcard-Examples"><FONT class=extract>Wildcard Examples</FONT></A><FONT class=extract>: Several examples. </FONT>
<LI><A accessKey=2 href="https://www.gnu.org/software/make/manual/make.html#Wildcard-Pitfall"><FONT class=extract>Wildcard Pitfall</FONT></A><FONT class=extract>: Problems to avoid. </FONT>
<LI><A accessKey=3 href="https://www.gnu.org/software/make/manual/make.html#Wildcard-Function"><FONT class=extract>Wildcard Function</FONT></A><FONT class=extract>: How to cause wildcard expansion where it does not normally take place. </FONT></LI></UL>
<DIV class=node><A name=Wildcard-Examples></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Wildcard-Pitfall" rel=next>Wildcard Pitfall</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Wildcards" rel=previous>Wildcards</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Wildcards" rel=up>Wildcards</A> </DIV>
<H4 class=subsection><FONT class=extract>4.4.1 Wildcard Examples</FONT></H4>
<P><FONT class=extract>Wildcards can be used in the recipe of a rule, where they are expanded by the shell. For example, here is a rule to delete all the object files: </FONT><PRE class=example><FONT class=extract>     clean:
             rm -f *.o
</FONT></PRE>
<P><A name=index-g_t_0040code_007brm_007d-_0028shell-command_0029-159></A><FONT class=extract>Wildcards are also useful in the prerequisites of a rule. With the following rule in the makefile, &#8216;<SAMP><SPAN class=samp>make print</SPAN></SAMP>&#8217; will print all the &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; files that have changed since the last time you printed them: </FONT><PRE class=example><FONT class=extract>     print: *.c
             lpr -p $?
             touch print
</FONT></PRE>
<P><A name=index-g_t_0040code_007bprint_007d-target-160></A><A name=index-g_t_0040code_007blpr_007d-_0028shell-command_0029-161></A><A name=index-g_t_0040code_007btouch_007d-_0028shell-command_0029-162></A><FONT class=extract>This rule uses <SAMP><SPAN class=file>print</SPAN></SAMP> as an empty target file; see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Empty-Targets"><FONT class=extract>Empty Target Files to Record Events</FONT></A><FONT class=extract>. (The automatic variable &#8216;<SAMP><SPAN class=samp>$?</SPAN></SAMP>&#8217; is used to print only those files that have changed; see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables"><FONT class=extract>Automatic Variables</FONT></A><FONT class=extract><FONT class=extract>.)</FONT> </FONT>
<P><FONT class=extract>Wildcard expansion does not happen when you define a variable. Thus, if you write this: </FONT><PRE class=example><FONT class=extract>     objects = *.o
</FONT></PRE>
<P class=noindent><FONT class=extract>then the value of the variable <CODE>objects</CODE> is the actual string &#8216;<SAMP><SPAN class=samp>*.o</SPAN></SAMP>&#8217;. However, if you use the value of <CODE>objects</CODE> in a target or prerequisite, wildcard expansion will take place there. If you use the value of <CODE>objects</CODE> in a recipe, the shell may perform wildcard expansion when the recipe runs. To set <CODE>objects</CODE> to the expansion, instead use: </FONT><PRE class=example><FONT class=extract>     objects := $(wildcard *.o)
</FONT></PRE>
<P class=noindent>See <A href="https://www.gnu.org/software/make/manual/make.html#Wildcard-Function">Wildcard Function</A>. 
<DIV class=node><A name=Wildcard-Pitfall></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Wildcard-Function" rel=next>Wildcard Function</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Wildcard-Examples" rel=previous>Wildcard Examples</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Wildcards" rel=up>Wildcards</A> </DIV>
<H4 class=subsection><FONT class=extract>4.4.2 Pitfalls of Using Wildcards</FONT></H4>
<P><A name=index-wildcard-pitfalls-163></A><A name=index-pitfalls-of-wildcards-164></A><A name=index-mistakes-with-wildcards-165></A><A name=index-errors-with-wildcards-166></A><A name=index-problems-with-wildcards-167></A><FONT class=extract>Now here is an example of a naive way of using wildcard expansion, that does not do what you would intend. Suppose you would like to say that the executable file <SAMP><SPAN class=file>foo</SPAN></SAMP> is made from all the object files in the directory, and you write this: </FONT><PRE class=example><FONT class=extract>     objects = *.o
     
     foo : $(objects)
             cc -o foo $(CFLAGS) $(objects)
</FONT></PRE>
<P class=noindent><FONT class=extract>The value of <CODE>objects</CODE> is the actual string &#8216;<SAMP><SPAN class=samp>*.o</SPAN></SAMP>&#8217;. Wildcard expansion happens in the rule for <SAMP><SPAN class=file>foo</SPAN></SAMP>, so that each <EM>existing</EM> &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; file becomes a prerequisite of <SAMP><SPAN class=file>foo</SPAN></SAMP> and will be recompiled if necessary. </FONT>
<P><FONT class=extract>But what if you delete all the &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; files? When a wildcard matches no files, it is left as it is, so then <SAMP><SPAN class=file>foo</SPAN></SAMP> will depend on the oddly-named file <SAMP><SPAN class=file>*.o</SPAN></SAMP>. Since no such file is likely to exist, <CODE>make</CODE> will give you an error saying it cannot figure out how to make <SAMP><SPAN class=file>*.o</SPAN></SAMP>. This is not what you want! </FONT>
<P><FONT class=extract>Actually it is possible to obtain the desired result with wildcard expansion, but you need more sophisticated techniques, including the <CODE>wildcard</CODE> function and string substitution. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Wildcard-Function"><FONT class=extract>The Function <CODE>wildcard</CODE></FONT></A><FONT class=extract>. </FONT>
<P><A name=index-wildcards-and-MS_002dDOS_002fMS_002dWindows-backslashes-168></A><A name=index-backslashes-in-pathnames-and-wildcard-expansion-169></A><FONT class=extract>Microsoft operating systems (MS-DOS and MS-Windows) use backslashes to separate directories in pathnames, like so: </FONT><PRE class=example><FONT class=extract>       c:\foo\bar\baz.c
</FONT></PRE>
<P><FONT class=extract>This is equivalent to the Unix-style <SAMP><SPAN class=file>c:/foo/bar/baz.c</SPAN></SAMP> (the <SAMP><SPAN class=file>c:</SPAN></SAMP> part is the so-called drive letter). When <CODE>make</CODE> runs on these systems, it supports backslashes as well as the Unix-style forward slashes in pathnames. However, this support does <EM>not</EM> include the wildcard expansion, where backslash is a quote character. Therefore, you <EM>must</EM> use Unix-style slashes in these cases. </FONT>
<DIV class=node><A name=Wildcard-Function></A>
<P>
<HR>
Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Wildcard-Pitfall" rel=previous>Wildcard Pitfall</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Wildcards" rel=up>Wildcards</A> </DIV>
<H4 class=subsection><FONT class=extract>4.4.3 The Function <CODE>wildcard</CODE></FONT></H4>
<P><A name=index-wildcard-170></A><FONT class=extract>Wildcard expansion happens automatically in rules. But wildcard expansion does not normally take place when a variable is set, or inside the arguments of a function. If you want to do wildcard expansion in such places, you need to use the <CODE>wildcard</CODE> function, like this: </FONT><PRE class=example><FONT class=extract>     $(wildcard <VAR>pattern</VAR>...)
</FONT></PRE>
<P class=noindent><FONT class=extract>This string, used anywhere in a makefile, is replaced by a space-separated list of names of existing files that match one of the given file name patterns. If no existing file name matches a pattern, then that pattern is omitted from the output of the <CODE>wildcard</CODE> function. Note that this is different from how unmatched wildcards behave in rules, where they are used verbatim rather than ignored (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Wildcard-Pitfall"><FONT class=extract>Wildcard Pitfall</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>One use of the <CODE>wildcard</CODE> function is to get a list of all the C source files in a directory, like this: </FONT><PRE class=example><FONT class=extract>     $(wildcard *.c)
</FONT></PRE>
<P><FONT class=extract>We can change the list of C source files into a list of object files by replacing the &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; suffix with &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; in the result, like this: </FONT><PRE class=example><FONT class=extract>     $(patsubst %.c,%.o,$(wildcard *.c))
</FONT></PRE>
<P class=noindent><FONT class=extract>(Here we have used another function, <CODE>patsubst</CODE>. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Text-Functions"><FONT class=extract>Functions for String Substitution and Analysis</FONT></A><FONT class=extract>.) </FONT>
<P><FONT class=extract>Thus, a makefile to compile all C source files in the directory and then link them together could be written as follows: </FONT><PRE class=example><FONT class=extract>     objects := $(patsubst %.c,%.o,$(wildcard *.c))
     
     foo : $(objects)
             cc -o foo $(objects)
</FONT></PRE>
<P class=noindent><FONT class=extract>(This takes advantage of the implicit rule for compiling C programs, so there is no need to write explicit rules for compiling the files. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Flavors"><FONT class=extract>The Two Flavors of Variables</FONT></A><FONT class=extract>, for an explanation of &#8216;<SAMP><SPAN class=samp>:=</SPAN></SAMP>&#8217;, which is a variant of &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217;.) </FONT>
<DIV class=node><A name=Directory-Search></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Phony-Targets" rel=next>Phony Targets</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Wildcards" rel=previous>Wildcards</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV>
<H3 class=section><FONT class=extract>4.5 Searching Directories for Prerequisites</FONT></H3>
<P><A name=index-VPATH-171></A><A name=index-vpath-172></A><A name=index-vpath-173></A><A name=index-search-path-for-prerequisites-_0028_0040code_007bVPATH_007d_0029-174></A><A name=index-directory-search-_0028_0040code_007bVPATH_007d_0029-175></A><FONT class=extract>For large systems, it is often desirable to put sources in a separate directory from the binaries. The <DFN>directory search</DFN> features of <CODE>make</CODE> facilitate this by searching several directories automatically to find a prerequisite. When you redistribute the files among directories, you do not need to change the individual rules, just the search paths. </FONT>
<UL class=menu>
<LI><A accessKey=1 href="https://www.gnu.org/software/make/manual/make.html#General-Search"><FONT class=extract>General Search</FONT></A><FONT class=extract>: Specifying a search path that applies to every prerequisite. </FONT>
<LI><A accessKey=2 href="https://www.gnu.org/software/make/manual/make.html#Selective-Search"><FONT class=extract>Selective Search</FONT></A><FONT class=extract>: Specifying a search path for a specified class of names. </FONT>
<LI><A accessKey=3 href="https://www.gnu.org/software/make/manual/make.html#Search-Algorithm"><FONT class=extract>Search Algorithm</FONT></A><FONT class=extract>: When and how search paths are applied. </FONT>
<LI><A accessKey=4 href="https://www.gnu.org/software/make/manual/make.html#Recipes_002fSearch"><FONT class=extract>Recipes/Search</FONT></A><FONT class=extract>: How to write recipes that work together with search paths. </FONT>
<LI><A accessKey=5 href="https://www.gnu.org/software/make/manual/make.html#Implicit_002fSearch"><FONT class=extract>Implicit/Search</FONT></A><FONT class=extract>: How search paths affect implicit rules. </FONT>
<LI><A accessKey=6 href="https://www.gnu.org/software/make/manual/make.html#Libraries_002fSearch"><FONT class=extract>Libraries/Search</FONT></A><FONT class=extract>: Directory search for link libraries. </FONT></LI></UL>
<DIV class=node><A name=General-Search></A>
<P><FONT class=extract></FONT></P><FONT class=extract>
<HR>
Next:&nbsp;</FONT><A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Selective-Search" rel=next><FONT class=extract>Selective Search</FONT></A><FONT class=extract>, Previous:&nbsp;</FONT><A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Directory-Search" rel=previous><FONT class=extract>Directory Search</FONT></A><FONT class=extract>, Up:&nbsp;</FONT><A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Directory-Search" rel=up><FONT class=extract>Directory Search</FONT></A><FONT class=extract> </FONT></DIV>
<H4 class=subsection><FONT class=extract>4.5.1 <CODE>VPATH</CODE>: Search Path for All Prerequisites</FONT></H4>
<P><A name=index-VPATH-176></A><FONT class=extract>The value of the <CODE>make</CODE> variable <CODE>VPATH</CODE> specifies a list of directories that <CODE>make</CODE> should search. Most often, the directories are expected to contain prerequisite files that are not in the current directory; however, <CODE>make</CODE> uses <CODE>VPATH</CODE> as a search list for both prerequisites and targets of rules. </FONT>
<P><FONT class=extract>Thus, if a file that is listed as a target or prerequisite does not exist in the current directory, <CODE>make</CODE> searches the directories listed in <CODE>VPATH</CODE> for a file with that name. If a file is found in one of them, that file may become the prerequisite (see below). Rules may then specify the names of files in the prerequisite list as if they all existed in the current directory. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Recipes_002fSearch"><FONT class=extract>Writing Recipes with Directory Search</FONT></A><FONT class=extract>. </FONT>
<P><FONT class=extract>In the <CODE>VPATH</CODE> variable, directory names are separated by colons or blanks. The order in which directories are listed is the order followed by <CODE>make</CODE> in its search. (On MS-DOS and MS-Windows, semi-colons are used as separators of directory names in <CODE>VPATH</CODE>, since the colon can be used in the pathname itself, after the drive letter.) </FONT>
<P><FONT class=extract>For example, </FONT><PRE class=example><FONT class=extract>     VPATH = src:../headers
</FONT></PRE>
<P class=noindent><FONT class=extract>specifies a path containing two directories, <SAMP><SPAN class=file>src</SPAN></SAMP> and <SAMP><SPAN class=file>../headers</SPAN></SAMP>, which <CODE>make</CODE> searches in that order. </FONT>
<P><FONT class=extract>With this value of <CODE>VPATH</CODE>, the following rule, </FONT><PRE class=example><FONT class=extract>     foo.o : foo.c
</FONT></PRE>
<P class=noindent><FONT class=extract>is interpreted as if it were written like this: </FONT><PRE class=example><FONT class=extract>     foo.o : src/foo.c
</FONT></PRE>
<P class=noindent><FONT class=extract>assuming the file <SAMP><SPAN class=file>foo.c</SPAN></SAMP> does not exist in the current directory but is found in the directory <SAMP><SPAN class=file>src</SPAN></SAMP>. </FONT>
<DIV class=node><A name=Selective-Search></A>
<P><FONT class=extract></FONT></P><FONT class=extract>
<HR>
Next:&nbsp;</FONT><A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Search-Algorithm" rel=next><FONT class=extract>Search Algorithm</FONT></A><FONT class=extract>, Previous:&nbsp;</FONT><A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#General-Search" rel=previous><FONT class=extract>General Search</FONT></A><FONT class=extract>, Up:&nbsp;</FONT><A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Directory-Search" rel=up><FONT class=extract>Directory Search</FONT></A><FONT class=extract> </FONT></DIV>
<H4 class=subsection><FONT class=extract>4.5.2 The <CODE>vpath</CODE> Directive</FONT></H4>
<P><A name=index-vpath-177></A><FONT class=extract>Similar to the <CODE>VPATH</CODE> variable, but more selective, is the <CODE>vpath</CODE> directive (note lower case), which allows you to specify a search path for a particular class of file names: those that match a particular pattern. Thus you can supply certain search directories for one class of file names and other directories (or none) for other file names. </FONT>
<P><FONT class=extract>There are three forms of the <CODE>vpath</CODE> directive: </FONT>
<DL>
<DT><FONT class=extract><CODE>vpath </CODE><VAR>pattern</VAR> <VAR>directories</VAR> </FONT>
<DD><FONT class=extract>Specify the search path <VAR>directories</VAR> for file names that match <VAR>pattern</VAR>. </FONT>
<P><FONT class=extract>The search path, <VAR>directories</VAR>, is a list of directories to be searched, separated by colons (semi-colons on MS-DOS and MS-Windows) or blanks, just like the search path used in the <CODE>VPATH</CODE> variable. <BR></FONT></P>
<DT><FONT class=extract><CODE>vpath </CODE><VAR>pattern</VAR> </FONT>
<DD><FONT class=extract>Clear out the search path associated with <VAR>pattern</VAR>. <!-- Extra blank line makes sure this gets two lines. --><BR></FONT>
<DT><FONT class=extract><CODE>vpath</CODE> </FONT>
<DD><FONT class=extract>Clear all search paths previously specified with <CODE>vpath</CODE> directives. </FONT></DD></DL>
<P><FONT class=extract>A <CODE>vpath</CODE> pattern is a string containing a &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; character. The string must match the file name of a prerequisite that is being searched for, the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; character matching any sequence of zero or more characters (as in pattern rules; see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules"><FONT class=extract>Defining and Redefining Pattern Rules</FONT></A><FONT class=extract>). For example, <CODE>%.h</CODE> matches files that end in <CODE>.h</CODE>. (If there is no &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;, the pattern must match the prerequisite exactly, which is not useful very often.) </FONT>
<P><A name=index-g_t_0040code_007b_0025_007d_002c-quoting-in-_0040code_007bvpath_007d-178></A><A name=index-g_t_0040code_007b_0025_007d_002c-quoting-with-_0040code_007b_005c_007d-_0028backslash_0029-179></A><A name=index-g_t_0040code_007b_005c_007d-_0028backslash_0029_002c-to-quote-_0040code_007b_0025_007d-180></A><A name=index-backslash-_0028_0040code_007b_005c_007d_0029_002c-to-quote-_0040code_007b_0025_007d-181></A><A name=index-quoting-_0040code_007b_0025_007d_002c-in-_0040code_007bvpath_007d-182></A><FONT class=extract>&#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; characters in a <CODE>vpath</CODE> directive's pattern can be quoted with preceding backslashes (&#8216;<SAMP><SPAN class=samp>\</SPAN></SAMP>&#8217;). Backslashes that would otherwise quote &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; characters can be quoted with more backslashes. Backslashes that quote &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; characters or other backslashes are removed from the pattern before it is compared to file names. Backslashes that are not in danger of quoting &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; characters go unmolested. </FONT>
<P><FONT class=extract>When a prerequisite fails to exist in the current directory, if the <VAR>pattern</VAR> in a <CODE>vpath</CODE> directive matches the name of the prerequisite file, then the <VAR>directories</VAR> in that directive are searched just like (and before) the directories in the <CODE>VPATH</CODE> variable. </FONT>
<P><FONT class=extract>For example, </FONT><PRE class=example><FONT class=extract>     vpath %.h ../headers
</FONT></PRE>
<P class=noindent><FONT class=extract>tells <CODE>make</CODE> to look for any prerequisite whose name ends in <SAMP><SPAN class=file>.h</SPAN></SAMP> in the directory <SAMP><SPAN class=file>../headers</SPAN></SAMP> if the file is not found in the current directory. </FONT>
<P><FONT class=extract>If several <CODE>vpath</CODE> patterns match the prerequisite file's name, then <CODE>make</CODE> processes each matching <CODE>vpath</CODE> directive one by one, searching all the directories mentioned in each directive. <CODE>make</CODE> handles multiple <CODE>vpath</CODE> directives in the order in which they appear in the makefile; multiple directives with the same pattern are independent of each other. </FONT>
<P><FONT class=extract>Thus, </FONT><PRE class=example><FONT class=extract>     vpath %.c foo
     vpath %   blish
     vpath %.c bar
</FONT></PRE>
<P class=noindent><FONT class=extract>will look for a file ending in &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; in <SAMP><SPAN class=file>foo</SPAN></SAMP>, then <SAMP><SPAN class=file>blish</SPAN></SAMP>, then <SAMP><SPAN class=file>bar</SPAN></SAMP>, while </FONT><PRE class=example><FONT class=extract>     vpath %.c foo:bar
     vpath %   blish
</FONT></PRE>
<P class=noindent><FONT class=extract>will look for a file ending in &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; in <SAMP><SPAN class=file>foo</SPAN></SAMP>, then <SAMP><SPAN class=file>bar</SPAN></SAMP>, then <SAMP><SPAN class=file>blish</SPAN></SAMP>. </FONT>
<DIV class=node><A name=Search-Algorithm></A>
<P><FONT class=extract></FONT></P><FONT class=extract>
<HR>
Next:&nbsp;</FONT><A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Recipes_002fSearch" rel=next><FONT class=extract>Recipes/Search</FONT></A><FONT class=extract>, Previous:&nbsp;</FONT><A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Selective-Search" rel=previous><FONT class=extract>Selective Search</FONT></A><FONT class=extract>, Up:&nbsp;</FONT><A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Directory-Search" rel=up><FONT class=extract>Directory Search</FONT></A><FONT class=extract> </FONT></DIV>
<H4 class=subsection><FONT class=extract>4.5.3 How Directory Searches are Performed</FONT></H4>
<P><A name=index-algorithm-for-directory-search-183></A><A name=index-directory-search-algorithm-184></A><FONT class=extract>When a prerequisite is found through directory search, regardless of type (general or selective), the pathname located may not be the one that <CODE>make</CODE> actually provides you in the prerequisite list. Sometimes the path discovered through directory search is thrown away. </FONT>
<P><FONT class=extract>The algorithm <CODE>make</CODE> uses to decide whether to keep or abandon a path found via directory search is as follows: </FONT>
<OL type=1>
<LI><FONT class=extract>If a target file does not exist at the path specified in the makefile, directory search is performed. </FONT>
<LI><FONT class=extract>If the directory search is successful, that path is kept and this file is tentatively stored as the target. </FONT>
<LI><FONT class=extract>All prerequisites of this target are examined using this same method. </FONT>
<LI><FONT class=extract>After processing the prerequisites, the target may or may not need to be rebuilt: </FONT>
<OL type=a>
<LI><FONT class=extract>If the target does <EM>not</EM> need to be rebuilt, the path to the file found during directory search is used for any prerequisite lists which contain this target. In short, if <CODE>make</CODE> doesn't need to rebuild the target then you use the path found via directory search. </FONT>
<LI><FONT class=extract>If the target <EM>does</EM> need to be rebuilt (is out-of-date), the pathname found during directory search is <EM>thrown away</EM>, and the target is rebuilt using the file name specified in the makefile. In short, if <CODE>make</CODE> must rebuild, then the target is rebuilt locally, not in the directory found via directory search. </FONT></LI></OL></LI></OL>
<P><FONT class=extract>This algorithm may seem complex, but in practice it is quite often exactly what you want. </FONT>
<P><A name=index-traditional-directory-search-_0028GPATH_0029-185></A><A name=index-directory-search_002c-traditional-_0028GPATH_0029-186></A><FONT class=extract>Other versions of <CODE>make</CODE> use a simpler algorithm: if the file does not exist, and it is found via directory search, then that pathname is always used whether or not the target needs to be built. Thus, if the target is rebuilt it is created at the pathname discovered during directory search. </FONT>
<P><A name=index-GPATH-187></A><FONT class=extract>If, in fact, this is the behavior you want for some or all of your directories, you can use the <CODE>GPATH</CODE> variable to indicate this to <CODE>make</CODE>. </FONT>
<P><FONT class=extract><CODE>GPATH</CODE> has the same syntax and format as <CODE>VPATH</CODE> (that is, a space- or colon-delimited list of pathnames). If an out-of-date target is found by directory search in a directory that also appears in <CODE>GPATH</CODE>, then that pathname is not thrown away. The target is rebuilt using the expanded path. </FONT>
<DIV class=node><A name=Recipes%2fSearch></A><A name=Recipes_002fSearch></A>
<P><FONT class=extract></FONT></P><FONT class=extract>
<HR>
Next:&nbsp;</FONT><A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Implicit_002fSearch" rel=next><FONT class=extract>Implicit/Search</FONT></A><FONT class=extract>, Previous:&nbsp;</FONT><A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Search-Algorithm" rel=previous><FONT class=extract>Search Algorithm</FONT></A><FONT class=extract>, Up:&nbsp;</FONT><A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Directory-Search" rel=up><FONT class=extract>Directory Search</FONT></A><FONT class=extract> </FONT></DIV>
<H4 class=subsection><FONT class=extract>4.5.4 Writing Recipes with Directory Search</FONT></H4>
<P><A name=index-recipes_002c-and-directory-search-188></A><A name=index-directory-search-_0028_0040code_007bVPATH_007d_0029_002c-and-recipes-189></A><FONT class=extract>When a prerequisite is found in another directory through directory search, this cannot change the recipe of the rule; they will execute as written. Therefore, you must write the recipe with care so that it will look for the prerequisite in the directory where <CODE>make</CODE> finds it. </FONT>
<P><FONT class=extract>This is done with the <DFN>automatic variables</DFN> such as &#8216;<SAMP><SPAN class=samp>$^</SPAN></SAMP>&#8217; (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables"><FONT class=extract>Automatic Variables</FONT></A><FONT class=extract>). For instance, the value of &#8216;<SAMP><SPAN class=samp>$^</SPAN></SAMP>&#8217; is a list of all the prerequisites of the rule, including the names of the directories in which they were found, and the value of &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217; is the target. Thus: </FONT><PRE class=example><FONT class=extract>     foo.o : foo.c
             cc -c $(CFLAGS) $^ -o $@
</FONT></PRE>
<P class=noindent><FONT class=extract>(The variable <CODE>CFLAGS</CODE> exists so you can specify flags for C compilation by implicit rules; we use it here for consistency so it will affect all C compilations uniformly; see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Variables"><FONT class=extract>Variables Used by Implicit Rules</FONT></A><FONT class=extract>.) </FONT>
<P><FONT class=extract>Often the prerequisites include header files as well, which you do not want to mention in the recipe. The automatic variable &#8216;<SAMP><SPAN class=samp>$&lt;</SPAN></SAMP>&#8217; is just the first prerequisite: </FONT><PRE class=example><FONT class=extract>     VPATH = src:../headers
     foo.o : foo.c defs.h hack.h
             cc -c $(CFLAGS) $&lt; -o $@
</FONT></PRE>
<DIV class=node><A name=Implicit%2fSearch></A><A name=Implicit_002fSearch></A>
<P><FONT class=extract></FONT></P><FONT class=extract>
<HR>
Next:&nbsp;</FONT><A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Libraries_002fSearch" rel=next><FONT class=extract>Libraries/Search</FONT></A><FONT class=extract>, Previous:&nbsp;</FONT><A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Recipes_002fSearch" rel=previous><FONT class=extract>Recipes/Search</FONT></A><FONT class=extract>, Up:&nbsp;</FONT><A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Directory-Search" rel=up><FONT class=extract>Directory Search</FONT></A><FONT class=extract> </FONT></DIV>
<H4 class=subsection><FONT class=extract>4.5.5 Directory Search and Implicit Rules</FONT></H4>
<P><A name=index-g_t_0040code_007bVPATH_007d_002c-and-implicit-rules-190></A><A name=index-directory-search-_0028_0040code_007bVPATH_007d_0029_002c-and-implicit-rules-191></A><A name=index-search-path-for-prerequisites-_0028_0040code_007bVPATH_007d_0029_002c-and-implicit-rules-192></A><A name=index-implicit-rule_002c-and-directory-search-193></A><A name=index-implicit-rule_002c-and-_0040code_007bVPATH_007d-194></A><A name=index-rule_002c-implicit_002c-and-directory-search-195></A><A name=index-rule_002c-implicit_002c-and-_0040code_007bVPATH_007d-196></A><FONT class=extract>The search through the directories specified in <CODE>VPATH</CODE> or with <CODE>vpath</CODE> also happens during consideration of implicit rules (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules"><FONT class=extract>Using Implicit Rules</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>For example, when a file <SAMP><SPAN class=file>foo.o</SPAN></SAMP> has no explicit rule, <CODE>make</CODE> considers implicit rules, such as the built-in rule to compile <SAMP><SPAN class=file>foo.c</SPAN></SAMP> if that file exists. If such a file is lacking in the current directory, the appropriate directories are searched for it. If <SAMP><SPAN class=file>foo.c</SPAN></SAMP> exists (or is mentioned in the makefile) in any of the directories, the implicit rule for C compilation is applied. </FONT>
<P><FONT class=extract>The recipes of implicit rules normally use automatic variables as a matter of necessity; consequently they will use the file names found by directory search with no extra effort. </FONT>
<DIV class=node><A name=Libraries%2fSearch></A><A name=Libraries_002fSearch></A>
<P><FONT class=extract></FONT></P><FONT class=extract>
<HR>
Previous:&nbsp;</FONT><A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Implicit_002fSearch" rel=previous><FONT class=extract>Implicit/Search</FONT></A><FONT class=extract>, Up:&nbsp;</FONT><A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Directory-Search" rel=up><FONT class=extract>Directory Search</FONT></A><FONT class=extract> </FONT></DIV>
<H4 class=subsection><FONT class=extract>4.5.6 Directory Search for Link Libraries</FONT></H4>
<P><A name=index-link-libraries_002c-and-directory-search-197></A><A name=index-libraries-for-linking_002c-directory-search-198></A><A name=index-directory-search-_0028_0040code_007bVPATH_007d_0029_002c-and-link-libraries-199></A><A name=index-g_t_0040code_007bVPATH_007d_002c-and-link-libraries-200></A><A name=index-search-path-for-prerequisites-_0028_0040code_007bVPATH_007d_0029_002c-and-link-libraries-201></A><A name=index-g_t_0040code_007b_002dl_007d-_0028library-search_0029-202></A><A name=index-link-libraries_002c-patterns-matching-203></A><A name=index-g_t_0040code_007b_002eLIBPATTERNS_007d_002c-and-link-libraries-204></A><A name=index-g_t_002eLIBPATTERNS-205></A><FONT class=extract>Directory search applies in a special way to libraries used with the linker. This special feature comes into play when you write a prerequisite whose name is of the form &#8216;<SAMP><SPAN class=samp>-l</SPAN><VAR>name</VAR></SAMP>&#8217;. (You can tell something strange is going on here because the prerequisite is normally the name of a file, and the <EM>file name</EM> of a library generally looks like <SAMP><SPAN class=file>lib</SPAN><VAR>name</VAR><SPAN class=file>.a</SPAN></SAMP>, not like &#8216;<SAMP><SPAN class=samp>-l</SPAN><VAR>name</VAR></SAMP>&#8217;.) </FONT>
<P><FONT class=extract>When a prerequisite's name has the form &#8216;<SAMP><SPAN class=samp>-l</SPAN><VAR>name</VAR></SAMP>&#8217;, <CODE>make</CODE> handles it specially by searching for the file <SAMP><SPAN class=file>lib</SPAN><VAR>name</VAR><SPAN class=file>.so</SPAN></SAMP>, and, if it is not found, for the file <SAMP><SPAN class=file>lib</SPAN><VAR>name</VAR><SPAN class=file>.a</SPAN></SAMP> in the current directory, in directories specified by matching <CODE>vpath</CODE> search paths and the <CODE>VPATH</CODE> search path, and then in the directories <SAMP><SPAN class=file>/lib</SPAN></SAMP>, <SAMP><SPAN class=file>/usr/lib</SPAN></SAMP>, and <SAMP><VAR>prefix</VAR><SPAN class=file>/lib</SPAN></SAMP> (normally <SAMP><SPAN class=file>/usr/local/lib</SPAN></SAMP>, but MS-DOS/MS-Windows versions of <CODE>make</CODE> behave as if <VAR>prefix</VAR> is defined to be the root of the DJGPP installation tree). </FONT>
<P><FONT class=extract>For example, if there is a <SAMP><SPAN class=file>/usr/lib/libcurses.a</SPAN></SAMP> library on your system (and no <SAMP><SPAN class=file>/usr/lib/libcurses.so</SPAN></SAMP> file), then </FONT><PRE class=example><FONT class=extract>     foo : foo.c -lcurses
             cc $^ -o $@
</FONT></PRE>
<P class=noindent><FONT class=extract>would cause the command &#8216;<SAMP><SPAN class=samp>cc foo.c /usr/lib/libcurses.a -o foo</SPAN></SAMP>&#8217; to be executed when <SAMP><SPAN class=file>foo</SPAN></SAMP> is older than <SAMP><SPAN class=file>foo.c</SPAN></SAMP> or than <SAMP><SPAN class=file>/usr/lib/libcurses.a</SPAN></SAMP>. </FONT>
<P><FONT class=extract>Although the default set of files to be searched for is <SAMP><SPAN class=file>lib</SPAN><VAR>name</VAR><SPAN class=file>.so</SPAN></SAMP> and <SAMP><SPAN class=file>lib</SPAN><VAR>name</VAR><SPAN class=file>.a</SPAN></SAMP>, this is customizable via the <CODE>.LIBPATTERNS</CODE> variable. Each word in the value of this variable is a pattern string. When a prerequisite like &#8216;<SAMP><SPAN class=samp>-l</SPAN><VAR>name</VAR></SAMP>&#8217; is seen, <CODE>make</CODE> will replace the percent in each pattern in the list with <VAR>name</VAR> and perform the above directory searches using each library file name. </FONT>
<P><FONT class=extract>The default value for <CODE>.LIBPATTERNS</CODE> is &#8216;<SAMP><SPAN class=samp>lib%.so lib%.a</SPAN></SAMP>&#8217;, which provides the default behavior described above. </FONT>
<P><FONT class=extract>You can turn off link library expansion completely by setting this variable to an empty value. </FONT>
<DIV class=node><A name=Phony-Targets></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Force-Targets" rel=next>Force Targets</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Directory-Search" rel=previous>Directory Search</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV>
<H3 class=section><FONT class=extract>4.6 Phony Targets</FONT></H3>
<P><A name=index-phony-targets-206></A><A name=index-targets_002c-phony-207></A><A name=index-targets-without-a-file-208></A><FONT class=extract>A phony target is one that is not really the name of a file; rather it is just a name for a recipe to be executed when you make an explicit request. There are two reasons to use a phony target: to avoid a conflict with a file of the same name, and to improve performance. </FONT>
<P><FONT class=extract>If you write a rule whose recipe will not create the target file, the recipe will be executed every time the target comes up for remaking. Here is an example: </FONT><PRE class=example><FONT class=extract>     clean:
             rm *.o temp
</FONT></PRE>
<P class=noindent><FONT class=extract>Because the <CODE>rm</CODE> command does not create a file named <SAMP><SPAN class=file>clean</SPAN></SAMP>, probably no such file will ever exist. Therefore, the <CODE>rm</CODE> command will be executed every time you say &#8216;<SAMP><SPAN class=samp>make clean</SPAN></SAMP>&#8217;. </FONT><A name=index-g_t_0040code_007brm_007d-_0028shell-command_0029-209></A><A name=index-g_t_002ePHONY-210></A><FONT class=extract>The phony target will cease to work if anything ever does create a file named <SAMP><SPAN class=file>clean</SPAN></SAMP> in this directory. Since it has no prerequisites, the file <SAMP><SPAN class=file>clean</SPAN></SAMP> would inevitably be considered up to date, and its recipe would not be executed. To avoid this problem, you can explicitly declare the target to be phony, using the special target <CODE>.PHONY</CODE> (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Special-Targets"><FONT class=extract>Special Built-in Target Names</FONT></A><FONT class=extract>) as follows: </FONT><PRE class=example><FONT class=extract>     .PHONY : clean
</FONT></PRE>
<P class=noindent><FONT class=extract>Once this is done, &#8216;<SAMP><SPAN class=samp>make clean</SPAN></SAMP>&#8217; will run the recipe regardless of whether there is a file named <SAMP><SPAN class=file>clean</SPAN></SAMP>. </FONT>
<P><FONT class=extract>Since it knows that phony targets do not name actual files that could be remade from other files, <CODE>make</CODE> skips the implicit rule search for phony targets (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules"><FONT class=extract>Implicit Rules</FONT></A><FONT class=extract>). This is why declaring a target phony is good for performance, even if you are not worried about the actual file existing. </FONT>
<P><FONT class=extract>Thus, you first write the line that states that <CODE>clean</CODE> is a phony target, then you write the rule, like this: </FONT><PRE class=example><FONT class=extract>     .PHONY: clean
     clean:
             rm *.o temp
</FONT></PRE>
<P><FONT class=extract>Another example of the usefulness of phony targets is in conjunction with recursive invocations of <CODE>make</CODE> (for more information, see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Recursion"><FONT class=extract>Recursive Use of <CODE>make</CODE></FONT></A><FONT class=extract>). In this case the makefile will often contain a variable which lists a number of sub-directories to be built. One way to handle this is with one rule whose recipe is a shell loop over the sub-directories, like this: </FONT><PRE class=example><FONT class=extract>     SUBDIRS = foo bar baz
     
     subdirs:
             for dir in $(SUBDIRS); do \
               $(MAKE) -C $$dir; \
             done
</FONT></PRE>
<P><FONT class=extract>There are problems with this method, however. First, any error detected in a sub-make is ignored by this rule, so it will continue to build the rest of the directories even when one fails. This can be overcome by adding shell commands to note the error and exit, but then it will do so even if <CODE>make</CODE> is invoked with the <CODE>-k</CODE> option, which is unfortunate. Second, and perhaps more importantly, you cannot take advantage of <CODE>make</CODE>'s ability to build targets in parallel (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Parallel"><FONT class=extract>Parallel Execution</FONT></A><FONT class=extract>), since there is only one rule. </FONT>
<P><FONT class=extract>By declaring the sub-directories as phony targets (you must do this as the sub-directory obviously always exists; otherwise it won't be built) you can remove these problems: </FONT><PRE class=example><FONT class=extract>     SUBDIRS = foo bar baz
     
     .PHONY: subdirs $(SUBDIRS)
     
     subdirs: $(SUBDIRS)
     
     $(SUBDIRS):
             $(MAKE) -C $@
     
     foo: baz
</FONT></PRE>
<P><FONT class=extract>Here we've also declared that the <SAMP><SPAN class=file>foo</SPAN></SAMP> sub-directory cannot be built until after the <SAMP><SPAN class=file>baz</SPAN></SAMP> sub-directory is complete; this kind of relationship declaration is particularly important when attempting parallel builds. </FONT>
<P><FONT class=extract>A phony target should not be a prerequisite of a real target file; if it is, its recipe will be run every time <CODE>make</CODE> goes to update that file. As long as a phony target is never a prerequisite of a real target, the phony target recipe will be executed only when the phony target is a specified goal (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Goals"><FONT class=extract>Arguments to Specify the Goals</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>Phony targets can have prerequisites. When one directory contains multiple programs, it is most convenient to describe all of the programs in one makefile <SAMP><SPAN class=file>./Makefile</SPAN></SAMP>. Since the target remade by default will be the first one in the makefile, it is common to make this a phony target named &#8216;<SAMP><SPAN class=samp>all</SPAN></SAMP>&#8217; and give it, as prerequisites, all the individual programs. For example: </FONT><PRE class=example><FONT class=extract>     all : prog1 prog2 prog3
     .PHONY : all
     
     prog1 : prog1.o utils.o
             cc -o prog1 prog1.o utils.o
     
     prog2 : prog2.o
             cc -o prog2 prog2.o
     
     prog3 : prog3.o sort.o utils.o
             cc -o prog3 prog3.o sort.o utils.o
</FONT></PRE>
<P class=noindent><FONT class=extract>Now you can say just &#8216;<SAMP><SPAN class=samp>make</SPAN></SAMP>&#8217; to remake all three programs, or specify as arguments the ones to remake (as in &#8216;<SAMP><SPAN class=samp>make prog1 prog3</SPAN></SAMP>&#8217;). Phoniness is not inherited: the prerequisites of a phony target are not themselves phony, unless explicitly declared to be so. </FONT>
<P><FONT class=extract>When one phony target is a prerequisite of another, it serves as a subroutine of the other. For example, here &#8216;<SAMP><SPAN class=samp>make cleanall</SPAN></SAMP>&#8217; will delete the object files, the difference files, and the file <SAMP><SPAN class=file>program</SPAN></SAMP>: </FONT><PRE class=example><FONT class=extract>     .PHONY: cleanall cleanobj cleandiff
     
     cleanall : cleanobj cleandiff
             rm program
     
     cleanobj :
             rm *.o
     
     cleandiff :
             rm *.diff</FONT>
</PRE>
<DIV class=node><A name=Force-Targets></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Empty-Targets" rel=next>Empty Targets</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Phony-Targets" rel=previous>Phony Targets</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV>
<H3 class=section><FONT class=extract>4.7 Rules without Recipes or Prerequisites</FONT></H3>
<P><A name=index-force-targets-211></A><A name=index-targets_002c-force-212></A><A name=index-g_t_0040code_007bFORCE_007d-213></A><A name=index-rule_002c-no-recipe-or-prerequisites-214></A><FONT class=extract>If a rule has no prerequisites or recipe, and the target of the rule is a nonexistent file, then <CODE>make</CODE> imagines this target to have been updated whenever its rule is run. This implies that all targets depending on this one will always have their recipe run. </FONT>
<P><FONT class=extract>An example will illustrate this: </FONT><PRE class=example><FONT class=extract>     clean: FORCE
             rm $(objects)
     FORCE:
</FONT></PRE>
<P><FONT class=extract>Here the target &#8216;<SAMP><SPAN class=samp>FORCE</SPAN></SAMP>&#8217; satisfies the special conditions, so the target <SAMP><SPAN class=file>clean</SPAN></SAMP> that depends on it is forced to run its recipe. There is nothing special about the name &#8216;<SAMP><SPAN class=samp>FORCE</SPAN></SAMP>&#8217;, but that is one name commonly used this way. </FONT>
<P><FONT class=extract>As you can see, using &#8216;<SAMP><SPAN class=samp>FORCE</SPAN></SAMP>&#8217; this way has the same results as using &#8216;<SAMP><SPAN class=samp>.PHONY: clean</SPAN></SAMP>&#8217;. </FONT>
<P><FONT class=extract>Using &#8216;<SAMP><SPAN class=samp>.PHONY</SPAN></SAMP>&#8217; is more explicit and more efficient. However, other versions of <CODE>make</CODE> do not support &#8216;<SAMP><SPAN class=samp>.PHONY</SPAN></SAMP>&#8217;; thus &#8216;<SAMP><SPAN class=samp>FORCE</SPAN></SAMP>&#8217; appears in many makefiles. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Phony-Targets"><FONT class=extract>Phony Targets</FONT></A><FONT class=extract>. </FONT>
<DIV class=node><A name=Empty-Targets></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Special-Targets" rel=next>Special Targets</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Force-Targets" rel=previous>Force Targets</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV>
<H3 class=section><FONT class=extract>4.8 Empty Target Files to Record Events</FONT></H3>
<P><A name=index-empty-targets-215></A><A name=index-targets_002c-empty-216></A><A name=index-recording-events-with-empty-targets-217></A><FONT class=extract>The <DFN>empty target</DFN> is a variant of the phony target; it is used to hold recipes for an action that you request explicitly from time to time. Unlike a phony target, this target file can really exist; but the file's contents do not matter, and usually are empty. </FONT>
<P><FONT class=extract>The purpose of the empty target file is to record, with its last-modification time, when the rule's recipe was last executed. It does so because one of the commands in the recipe is a <CODE>touch</CODE> command to update the target file. </FONT>
<P><FONT class=extract>The empty target file should have some prerequisites (otherwise it doesn't make sense). When you ask to remake the empty target, the recipe is executed if any prerequisite is more recent than the target; in other words, if a prerequisite has changed since the last time you remade the target. Here is an example: </FONT><PRE class=example><FONT class=extract>     print: foo.c bar.c
             lpr -p $?
             touch print
</FONT></PRE>
<P><A name=index-g_t_0040code_007bprint_007d-target-218></A><A name=index-g_t_0040code_007blpr_007d-_0028shell-command_0029-219></A><A name=index-g_t_0040code_007btouch_007d-_0028shell-command_0029-220></A><FONT class=extract>With this rule, &#8216;<SAMP><SPAN class=samp>make print</SPAN></SAMP>&#8217; will execute the <CODE>lpr</CODE> command if either source file has changed since the last &#8216;<SAMP><SPAN class=samp>make print</SPAN></SAMP>&#8217;. The automatic variable &#8216;<SAMP><SPAN class=samp>$?</SPAN></SAMP>&#8217; is used to print only those files that have changed (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables"><FONT class=extract>Automatic Variables</FONT></A><FONT class=extract>). </FONT>
<DIV class=node><A name=Special-Targets></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Multiple-Targets" rel=next>Multiple Targets</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Empty-Targets" rel=previous>Empty Targets</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV>
<H3 class=section><FONT class=extract>4.9 Special Built-in Target Names</FONT></H3>
<P><A name=index-special-targets-221></A><A name=index-built_002din-special-targets-222></A><A name=index-targets_002c-built_002din-special-223></A><FONT class=extract>Certain names have special meanings if they appear as targets. </FONT><A name=index-g_t_002ePHONY-224></A>
<DL>
<DT><FONT class=extract><CODE>.PHONY</CODE> </FONT>
<DD><FONT class=extract>The prerequisites of the special target <CODE>.PHONY</CODE> are considered to be phony targets. When it is time to consider such a target, <CODE>make</CODE> will run its recipe unconditionally, regardless of whether a file with that name exists or what its last-modification time is. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Phony-Targets"><FONT class=extract>Phony Targets</FONT></A><FONT class=extract>. </FONT>
<P><A name=index-g_t_002eSUFFIXES-225></A><BR></P>
<DT><FONT class=extract><CODE>.SUFFIXES</CODE> </FONT>
<DD><FONT class=extract>The prerequisites of the special target <CODE>.SUFFIXES</CODE> are the list of suffixes to be used in checking for suffix rules. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Suffix-Rules"><FONT class=extract>Old-Fashioned Suffix Rules</FONT></A><FONT class=extract>. </FONT>
<P><A name=index-g_t_002eDEFAULT-226></A><BR></P>
<DT><FONT class=extract><CODE>.DEFAULT</CODE> </FONT>
<DD><FONT class=extract>The recipe specified for <CODE>.DEFAULT</CODE> is used for any target for which no rules are found (either explicit rules or implicit rules). See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Last-Resort"><FONT class=extract>Last Resort</FONT></A><FONT class=extract>. If a <CODE>.DEFAULT</CODE> recipe is specified, every file mentioned as a prerequisite, but not as a target in a rule, will have that recipe executed on its behalf. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rule-Search"><FONT class=extract>Implicit Rule Search Algorithm</FONT></A><FONT class=extract>. </FONT>
<P><A name=index-g_t_002ePRECIOUS-227></A><BR></P>
<DT><FONT class=extract><CODE>.PRECIOUS</CODE> </FONT>
<DD><A name=index-precious-targets-228></A><A name=index-preserving-with-_0040code_007b_002ePRECIOUS_007d-229></A><FONT class=extract>The targets which <CODE>.PRECIOUS</CODE> depends on are given the following special treatment: if <CODE>make</CODE> is killed or interrupted during the execution of their recipes, the target is not deleted. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Interrupts"><FONT class=extract>Interrupting or Killing <CODE>make</CODE></FONT></A><FONT class=extract>. Also, if the target is an intermediate file, it will not be deleted after it is no longer needed, as is normally done. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Chained-Rules"><FONT class=extract>Chains of Implicit Rules</FONT></A><FONT class=extract>. In this latter respect it overlaps with the <CODE>.SECONDARY</CODE> special target. </FONT>
<P><FONT class=extract>You can also list the target pattern of an implicit rule (such as &#8216;<SAMP><SPAN class=samp>%.o</SPAN></SAMP>&#8217;) as a prerequisite file of the special target <CODE>.PRECIOUS</CODE> to preserve intermediate files created by rules whose target patterns match that file's name. </FONT>
<P><A name=index-g_t_002eINTERMEDIATE-230><FONT class=extract></FONT></A><BR></P>
<DT><FONT class=extract><CODE>.INTERMEDIATE</CODE> </FONT>
<DD><A name=index-intermediate-targets_002c-explicit-231></A><FONT class=extract>The targets which <CODE>.INTERMEDIATE</CODE> depends on are treated as intermediate files. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Chained-Rules"><FONT class=extract>Chains of Implicit Rules</FONT></A><FONT class=extract>. <CODE>.INTERMEDIATE</CODE> with no prerequisites has no effect. </FONT>
<P><A name=index-g_t_002eSECONDARY-232></A><BR></P>
<DT><FONT class=extract><CODE>.SECONDARY</CODE> </FONT>
<DD><A name=index-secondary-targets-233></A><A name=index-preserving-with-_0040code_007b_002eSECONDARY_007d-234></A><FONT class=extract>The targets which <CODE>.SECONDARY</CODE> depends on are treated as intermediate files, except that they are never automatically deleted. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Chained-Rules"><FONT class=extract>Chains of Implicit Rules</FONT></A><FONT class=extract>. </FONT>
<P><FONT class=extract><CODE>.SECONDARY</CODE> with no prerequisites causes all targets to be treated as secondary (i.e., no target is removed because it is considered intermediate). </FONT>
<P><A name=index-g_t_002eSECONDEXPANSION-235><FONT class=extract></FONT></A><BR></P>
<DT><FONT class=extract><CODE>.SECONDEXPANSION</CODE> </FONT>
<DD><FONT class=extract>If <CODE>.SECONDEXPANSION</CODE> is mentioned as a target anywhere in the makefile, then all prerequisite lists defined <EM>after</EM> it appears will be expanded a second time after all makefiles have been read in. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Secondary-Expansion"><FONT class=extract>Secondary Expansion</FONT></A><FONT class=extract>. </FONT>
<P><A name=index-g_t_002eDELETE_005fON_005fERROR-236></A><BR></P>
<DT><FONT class=extract><CODE>.DELETE_ON_ERROR</CODE> </FONT>
<DD><A name=index-removing-targets-on-failure-237></A><FONT class=extract>If <CODE>.DELETE_ON_ERROR</CODE> is mentioned as a target anywhere in the makefile, then <CODE>make</CODE> will delete the target of a rule if it has changed and its recipe exits with a nonzero exit status, just as it does when it receives a signal. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Errors"><FONT class=extract>Errors in Recipes</FONT></A><FONT class=extract>. </FONT>
<P><A name=index-g_t_002eIGNORE-238></A><BR></P>
<DT><FONT class=extract><CODE>.IGNORE</CODE> </FONT>
<DD><FONT class=extract>If you specify prerequisites for <CODE>.IGNORE</CODE>, then <CODE>make</CODE> will ignore errors in execution of the recipe for those particular files. The recipe for <CODE>.IGNORE</CODE> (if any) is ignored. </FONT>
<P><FONT class=extract>If mentioned as a target with no prerequisites, <CODE>.IGNORE</CODE> says to ignore errors in execution of recipes for all files. This usage of &#8216;<SAMP><SPAN class=samp>.IGNORE</SPAN></SAMP>&#8217; is supported only for historical compatibility. Since this affects every recipe in the makefile, it is not very useful; we recommend you use the more selective ways to ignore errors in specific recipes. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Errors"><FONT class=extract>Errors in Recipes</FONT></A><FONT class=extract>. </FONT>
<P><A name=index-g_t_002eLOW_005fRESOLUTION_005fTIME-239><FONT class=extract></FONT></A><BR></P>
<DT><FONT class=extract><CODE>.LOW_RESOLUTION_TIME</CODE> </FONT>
<DD><FONT class=extract>If you specify prerequisites for <CODE>.LOW_RESOLUTION_TIME</CODE>, <SAMP><SPAN class=command>make</SPAN></SAMP> assumes that these files are created by commands that generate low resolution time stamps. The recipe for the <CODE>.LOW_RESOLUTION_TIME</CODE> target are ignored. </FONT>
<P><FONT class=extract>The high resolution file time stamps of many modern file systems lessen the chance of <SAMP><SPAN class=command>make</SPAN></SAMP> incorrectly concluding that a file is up to date. Unfortunately, some hosts do not provide a way to set a high resolution file time stamp, so commands like &#8216;<SAMP><SPAN class=samp>cp -p</SPAN></SAMP>&#8217; that explicitly set a file's time stamp must discard its sub-second part. If a file is created by such a command, you should list it as a prerequisite of <CODE>.LOW_RESOLUTION_TIME</CODE> so that <SAMP><SPAN class=command>make</SPAN></SAMP> does not mistakenly conclude that the file is out of date. For example: </FONT><PRE class=example><FONT class=extract>          .LOW_RESOLUTION_TIME: dst
          dst: src
                  cp -p src dst
</FONT></PRE>
<P><FONT class=extract>Since &#8216;<SAMP><SPAN class=samp>cp -p</SPAN></SAMP>&#8217; discards the sub-second part of <SAMP><SPAN class=file>src</SPAN></SAMP>'s time stamp, <SAMP><SPAN class=file>dst</SPAN></SAMP> is typically slightly older than <SAMP><SPAN class=file>src</SPAN></SAMP> even when it is up to date. The <CODE>.LOW_RESOLUTION_TIME</CODE> line causes <SAMP><SPAN class=command>make</SPAN></SAMP> to consider <SAMP><SPAN class=file>dst</SPAN></SAMP> to be up to date if its time stamp is at the start of the same second that <SAMP><SPAN class=file>src</SPAN></SAMP>'s time stamp is in. </FONT>
<P><FONT class=extract>Due to a limitation of the archive format, archive member time stamps are always low resolution. You need not list archive members as prerequisites of <CODE>.LOW_RESOLUTION_TIME</CODE>, as <SAMP><SPAN class=command>make</SPAN></SAMP> does this automatically. </FONT>
<P><A name=index-g_t_002eSILENT-240><FONT class=extract></FONT></A><BR></P>
<DT><FONT class=extract><CODE>.SILENT</CODE> </FONT>
<DD><FONT class=extract>If you specify prerequisites for <CODE>.SILENT</CODE>, then <CODE>make</CODE> will not print the recipe used to remake those particular files before executing them. The recipe for <CODE>.SILENT</CODE> is ignored. </FONT>
<P><FONT class=extract>If mentioned as a target with no prerequisites, <CODE>.SILENT</CODE> says not to print any recipes before executing them. This usage of &#8216;<SAMP><SPAN class=samp>.SILENT</SPAN></SAMP>&#8217; is supported only for historical compatibility. We recommend you use the more selective ways to silence specific recipes. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Echoing"><FONT class=extract>Recipe Echoing</FONT></A><FONT class=extract>. If you want to silence all recipes for a particular run of <CODE>make</CODE>, use the &#8216;<SAMP><SPAN class=samp>-s</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>--silent</SPAN></SAMP>&#8217;<!-- /@w --> option (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Options-Summary"><FONT class=extract>Options Summary</FONT></A><FONT class=extract>). </FONT>
<P><A name=index-g_t_002eEXPORT_005fALL_005fVARIABLES-241><FONT class=extract></FONT></A><BR></P>
<DT><FONT class=extract><CODE>.EXPORT_ALL_VARIABLES</CODE> </FONT>
<DD><FONT class=extract>Simply by being mentioned as a target, this tells <CODE>make</CODE> to export all variables to child processes by default. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Variables_002fRecursion"><FONT class=extract>Communicating Variables to a Sub-<CODE>make</CODE></FONT></A><FONT class=extract>. </FONT>
<P><A name=index-g_t_002eNOTPARALLEL-242></A><BR></P>
<DT><FONT class=extract><CODE>.NOTPARALLEL</CODE> </FONT>
<DD><A name=index-parallel-execution_002c-overriding-243></A><FONT class=extract>If <CODE>.NOTPARALLEL</CODE> is mentioned as a target, then this invocation of <CODE>make</CODE> will be run serially, even if the &#8216;<SAMP><SPAN class=samp>-j</SPAN></SAMP>&#8217; option is given. Any recursively invoked <CODE>make</CODE> command will still run recipes in parallel (unless its makefile also contains this target). Any prerequisites on this target are ignored. </FONT>
<P><A name=index-g_t_002eONESHELL-244></A><BR></P>
<DT><FONT class=extract><CODE>.ONESHELL</CODE> </FONT>
<DD><A name=index-recipe-execution_002c-single-invocation-245></A><FONT class=extract>If <CODE>.ONESHELL</CODE> is mentioned as a target, then when a target is built all lines of the recipe will be given to a single invocation of the shell rather than each line being invoked separately (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Execution"><FONT class=extract>Recipe Execution</FONT></A><FONT class=extract>). </FONT>
<P><A name=index-g_t_002ePOSIX-246></A><BR></P>
<DT><FONT class=extract><CODE>.POSIX</CODE> </FONT>
<DD><A name=index-POSIX_002dconforming-mode_002c-setting-247></A><FONT class=extract>If <CODE>.POSIX</CODE> is mentioned as a target, then the makefile will be parsed and run in POSIX-conforming mode. This does <EM>not</EM> mean that only POSIX-conforming makefiles will be accepted: all advanced GNU <CODE>make</CODE> features are still available. Rather, this target causes <CODE>make</CODE> to behave as required by POSIX in those areas where <CODE>make</CODE>'s default behavior differs. </FONT>
<P><FONT class=extract>In particular, if this target is mentioned then recipes will be invoked as if the shell had been passed the <CODE>-e</CODE> flag: the first failing command in a recipe will cause the recipe to fail immediately. </FONT></P></DD></DL>
<P><FONT class=extract>Any defined implicit rule suffix also counts as a special target if it appears as a target, and so does the concatenation of two suffixes, such as &#8216;<SAMP><SPAN class=samp>.c.o</SPAN></SAMP>&#8217;. These targets are suffix rules, an obsolete way of defining implicit rules (but a way still widely used). In principle, any target name could be special in this way if you break it in two and add both pieces to the suffix list. In practice, suffixes normally begin with &#8216;<SAMP><SPAN class=samp>.</SPAN></SAMP>&#8217;, so these special target names also begin with &#8216;<SAMP><SPAN class=samp>.</SPAN></SAMP>&#8217;. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Suffix-Rules"><FONT class=extract>Old-Fashioned Suffix Rules</FONT></A><FONT class=extract>. </FONT>
<DIV class=node><A name=Multiple-Targets></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Multiple-Rules" rel=next>Multiple Rules</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Special-Targets" rel=previous>Special Targets</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV>
<H3 class=section><FONT class=extract>4.10 Multiple Targets in a Rule</FONT></H3>
<P><A name=index-multiple-targets-248></A><A name=index-several-targets-in-a-rule-249></A><A name=index-targets_002c-multiple-250></A><A name=index-rule_002c-with-multiple-targets-251></A><FONT class=extract>A rule with multiple targets is equivalent to writing many rules, each with one target, and all identical aside from that. The same recipe applies to all the targets, but its effect may vary because you can substitute the actual target name into the recipe using &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217;. The rule contributes the same prerequisites to all the targets also. </FONT>
<P><FONT class=extract>This is useful in two cases. </FONT>
<UL>
<LI><FONT class=extract>You want just prerequisites, no recipe. For example: </FONT><PRE class=example><FONT class=extract>          kbd.o command.o files.o: command.h
</FONT></PRE>
<P class=noindent><FONT class=extract>gives an additional prerequisite to each of the three object files mentioned. </FONT></P>
<LI><FONT class=extract>Similar recipes work for all the targets. The recipes do not need to be absolutely identical, since the automatic variable &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217; can be used to substitute the particular target to be remade into the commands (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables"><FONT class=extract>Automatic Variables</FONT></A><FONT class=extract>). For example: </FONT><PRE class=example><FONT class=extract>          bigoutput littleoutput : text.g
                  generate text.g -$(subst output,,$@) &gt; $@
</FONT></PRE>
<P><A name=index-subst-252></A><FONT class=extract>is equivalent to </FONT><PRE class=example><FONT class=extract>          bigoutput : text.g
                  generate text.g -big &gt; bigoutput
          littleoutput : text.g
                  generate text.g -little &gt; littleoutput
</FONT></PRE>
<P class=noindent><FONT class=extract>Here we assume the hypothetical program <CODE>generate</CODE> makes two types of output, one if given &#8216;<SAMP><SPAN class=samp>-big</SPAN></SAMP>&#8217; and one if given &#8216;<SAMP><SPAN class=samp>-little</SPAN></SAMP>&#8217;. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Text-Functions"><FONT class=extract>Functions for String Substitution and Analysis</FONT></A><FONT class=extract>, for an explanation of the <CODE>subst</CODE> function. </FONT></P></LI></UL>
<P><FONT class=extract>Suppose you would like to vary the prerequisites according to the target, much as the variable &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217; allows you to vary the recipe. You cannot do this with multiple targets in an ordinary rule, but you can do it with a <DFN>static pattern rule</DFN>. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Static-Pattern"><FONT class=extract>Static Pattern Rules</FONT></A><FONT class=extract>. </FONT>
<DIV class=node><A name=Multiple-Rules></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Static-Pattern" rel=next>Static Pattern</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Multiple-Targets" rel=previous>Multiple Targets</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV>
<H3 class=section><FONT class=extract>4.11 Multiple Rules for One Target</FONT></H3>
<P><A name=index-multiple-rules-for-one-target-253></A><A name=index-several-rules-for-one-target-254></A><A name=index-rule_002c-multiple-for-one-target-255></A><A name=index-target_002c-multiple-rules-for-one-256></A><FONT class=extract>One file can be the target of several rules. All the prerequisites mentioned in all the rules are merged into one list of prerequisites for the target. If the target is older than any prerequisite from any rule, the recipe is executed. </FONT>
<P><FONT class=extract>There can only be one recipe to be executed for a file. If more than one rule gives a recipe for the same file, <CODE>make</CODE> uses the last one given and prints an error message. (As a special case, if the file's name begins with a dot, no error message is printed. This odd behavior is only for compatibility with other implementations of <CODE>make</CODE><SMALL class=dots><FONT size=2>...</FONT></SMALL> you should avoid using it). Occasionally it is useful to have the same target invoke multiple recipes which are defined in different parts of your makefile; you can use <DFN>double-colon rules</DFN> (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Double_002dColon"><FONT class=extract>Double-Colon</FONT></A><FONT class=extract>) for this. </FONT>
<P><FONT class=extract>An extra rule with just prerequisites can be used to give a few extra prerequisites to many files at once. For example, makefiles often have a variable, such as <CODE>objects</CODE>, containing a list of all the compiler output files in the system being made. An easy way to say that all of them must be recompiled if <SAMP><SPAN class=file>config.h</SPAN></SAMP> changes is to write the following: </FONT><PRE class=example><FONT class=extract>     objects = foo.o bar.o
     foo.o : defs.h
     bar.o : defs.h test.h
     $(objects) : config.h
</FONT></PRE>
<P><FONT class=extract>This could be inserted or taken out without changing the rules that really specify how to make the object files, making it a convenient form to use if you wish to add the additional prerequisite intermittently. </FONT>
<P><FONT class=extract>Another wrinkle is that the additional prerequisites could be specified with a variable that you set with a command line argument to <CODE>make</CODE> (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Overriding"><FONT class=extract>Overriding Variables</FONT></A><FONT class=extract>). For example, </FONT><PRE class=example><FONT class=extract>     extradeps=
     $(objects) : $(extradeps)
</FONT></PRE>
<P class=noindent><FONT class=extract>means that the command &#8216;<SAMP><SPAN class=samp>make extradeps=foo.h</SPAN></SAMP>&#8217; will consider <SAMP><SPAN class=file>foo.h</SPAN></SAMP> as a prerequisite of each object file, but plain &#8216;<SAMP><SPAN class=samp>make</SPAN></SAMP>&#8217; will not. </FONT>
<P><FONT class=extract>If none of the explicit rules for a target has a recipe, then <CODE>make</CODE> searches for an applicable implicit rule to find one see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules"><FONT class=extract>Using Implicit Rules</FONT></A><FONT class=extract>). </FONT>
<DIV class=node><A name=Static-Pattern></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Double_002dColon" rel=next>Double-Colon</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Multiple-Rules" rel=previous>Multiple Rules</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV>
<H3 class=section><FONT class=extract>4.12 Static Pattern Rules</FONT></H3>
<P><A name=index-static-pattern-rule-257></A><A name=index-rule_002c-static-pattern-258></A><A name=index-pattern-rules_002c-static-_0028not-implicit_0029-259></A><A name=index-varying-prerequisites-260></A><A name=index-prerequisites_002c-varying-_0028static-pattern_0029-261></A><FONT class=extract><DFN>Static pattern rules</DFN> are rules which specify multiple targets and construct the prerequisite names for each target based on the target name. They are more general than ordinary rules with multiple targets because the targets do not have to have identical prerequisites. Their prerequisites must be <EM>analogous</EM>, but not necessarily <EM>identical</EM>. </FONT>
<UL class=menu>
<LI><A accessKey=1 href="https://www.gnu.org/software/make/manual/make.html#Static-Usage"><FONT class=extract>Static Usage</FONT></A><FONT class=extract>: The syntax of static pattern rules. </FONT>
<LI><A accessKey=2 href="https://www.gnu.org/software/make/manual/make.html#Static-versus-Implicit"><FONT class=extract>Static versus Implicit</FONT></A><FONT class=extract>: When are they better than implicit rules? </FONT></LI></UL>
<DIV class=node><A name=Static-Usage></A>
<P><FONT class=extract></FONT></P><FONT class=extract>
<HR>
Next:&nbsp;</FONT><A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Static-versus-Implicit" rel=next><FONT class=extract>Static versus Implicit</FONT></A><FONT class=extract>, Previous:&nbsp;</FONT><A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Static-Pattern" rel=previous><FONT class=extract>Static Pattern</FONT></A><FONT class=extract>, Up:&nbsp;</FONT><A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Static-Pattern" rel=up><FONT class=extract>Static Pattern</FONT></A><FONT class=extract> </FONT></DIV>
<H4 class=subsection><FONT class=extract>4.12.1 Syntax of Static Pattern Rules</FONT></H4>
<P><A name=index-static-pattern-rule_002c-syntax-of-262></A><A name=index-pattern-rules_002c-static_002c-syntax-of-263></A><FONT class=extract>Here is the syntax of a static pattern rule: </FONT><PRE class=example><FONT class=extract>     <VAR>targets</VAR> ...: <VAR>target-pattern</VAR>: <VAR>prereq-patterns</VAR> ...
             <VAR>recipe</VAR>
             ...
</FONT></PRE>
<P class=noindent><FONT class=extract>The <VAR>targets</VAR> list specifies the targets that the rule applies to. The targets can contain wildcard characters, just like the targets of ordinary rules (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Wildcards"><FONT class=extract>Using Wildcard Characters in File Names</FONT></A><FONT class=extract>). </FONT>
<P><A name=index-target-pattern_002c-static-_0028not-implicit_0029-264></A><A name=index-stem-265></A><FONT class=extract>The <VAR>target-pattern</VAR> and <VAR>prereq-patterns</VAR> say how to compute the prerequisites of each target. Each target is matched against the <VAR>target-pattern</VAR> to extract a part of the target name, called the <DFN>stem</DFN>. This stem is substituted into each of the <VAR>prereq-patterns</VAR> to make the prerequisite names (one from each <VAR>prereq-pattern</VAR>). </FONT>
<P><FONT class=extract>Each pattern normally contains the character &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; just once. When the <VAR>target-pattern</VAR> matches a target, the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; can match any part of the target name; this part is called the <DFN>stem</DFN>. The rest of the pattern must match exactly. For example, the target <SAMP><SPAN class=file>foo.o</SPAN></SAMP> matches the pattern &#8216;<SAMP><SPAN class=samp>%.o</SPAN></SAMP>&#8217;, with &#8216;<SAMP><SPAN class=samp>foo</SPAN></SAMP>&#8217; as the stem. The targets <SAMP><SPAN class=file>foo.c</SPAN></SAMP> and <SAMP><SPAN class=file>foo.out</SPAN></SAMP> do not match that pattern. </FONT>
<P><A name=index-prerequisite-pattern_002c-static-_0028not-implicit_0029-266></A><FONT class=extract>The prerequisite names for each target are made by substituting the stem for the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; in each prerequisite pattern. For example, if one prerequisite pattern is <SAMP><SPAN class=file>%.c</SPAN></SAMP>, then substitution of the stem &#8216;<SAMP><SPAN class=samp>foo</SPAN></SAMP>&#8217; gives the prerequisite name <SAMP><SPAN class=file>foo.c</SPAN></SAMP>. It is legitimate to write a prerequisite pattern that does not contain &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;; then this prerequisite is the same for all targets. </FONT>
<P><A name=index-g_t_0040code_007b_0025_007d_002c-quoting-in-static-pattern-267></A><A name=index-g_t_0040code_007b_0025_007d_002c-quoting-with-_0040code_007b_005c_007d-_0028backslash_0029-268></A><A name=index-g_t_0040code_007b_005c_007d-_0028backslash_0029_002c-to-quote-_0040code_007b_0025_007d-269></A><A name=index-backslash-_0028_0040code_007b_005c_007d_0029_002c-to-quote-_0040code_007b_0025_007d-270></A><A name=index-quoting-_0040code_007b_0025_007d_002c-in-static-pattern-271></A><FONT class=extract>&#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; characters in pattern rules can be quoted with preceding backslashes (&#8216;<SAMP><SPAN class=samp>\</SPAN></SAMP>&#8217;). Backslashes that would otherwise quote &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; characters can be quoted with more backslashes. Backslashes that quote &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; characters or other backslashes are removed from the pattern before it is compared to file names or has a stem substituted into it. Backslashes that are not in danger of quoting &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; characters go unmolested. For example, the pattern <SAMP><SPAN class=file>the\%weird\\%pattern\\</SPAN></SAMP> has &#8216;<SAMP><SPAN class=samp>the%weird\</SPAN></SAMP>&#8217; preceding the operative &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; character, and &#8216;<SAMP><SPAN class=samp>pattern\\</SPAN></SAMP>&#8217; following it. The final two backslashes are left alone because they cannot affect any &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; character. </FONT>
<P><FONT class=extract>Here is an example, which compiles each of <SAMP><SPAN class=file>foo.o</SPAN></SAMP> and <SAMP><SPAN class=file>bar.o</SPAN></SAMP> from the corresponding <SAMP><SPAN class=file>.c</SPAN></SAMP> file: </FONT><PRE class=example><FONT class=extract>     objects = foo.o bar.o
     
     all: $(objects)
     
     $(objects): %.o: %.c
             $(CC) -c $(CFLAGS) $&lt; -o $@
</FONT></PRE>
<P class=noindent><FONT class=extract>Here &#8216;<SAMP><SPAN class=samp>$&lt;</SPAN></SAMP>&#8217; is the automatic variable that holds the name of the prerequisite and &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217; is the automatic variable that holds the name of the target; see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables"><FONT class=extract>Automatic Variables</FONT></A><FONT class=extract>. </FONT>
<P><FONT class=extract>Each target specified must match the target pattern; a warning is issued for each target that does not. If you have a list of files, only some of which will match the pattern, you can use the <CODE>filter</CODE> function to remove non-matching file names (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Text-Functions"><FONT class=extract>Functions for String Substitution and Analysis</FONT></A><FONT class=extract>): </FONT><PRE class=example><FONT class=extract>     files = foo.elc bar.o lose.o
     
     $(filter %.o,$(files)): %.o: %.c
             $(CC) -c $(CFLAGS) $&lt; -o $@
     $(filter %.elc,$(files)): %.elc: %.el
             emacs -f batch-byte-compile $&lt;
</FONT></PRE>
<P class=noindent><FONT class=extract>In this example the result of &#8216;<SAMP><SPAN class=samp>$(filter %.o,$(files))</SPAN></SAMP>&#8217; is <SAMP><SPAN class=file>bar.o lose.o</SPAN></SAMP>, and the first static pattern rule causes each of these object files to be updated by compiling the corresponding C source file. The result of &#8216;<SAMP><SPAN class=samp>$(filter&nbsp;%.elc,$(files))</SPAN></SAMP>&#8217;<!-- /@w --> is <SAMP><SPAN class=file>foo.elc</SPAN></SAMP>, so that file is made from <SAMP><SPAN class=file>foo.el</SPAN></SAMP>. </FONT>
<P><FONT class=extract>Another example shows how to use <CODE>$*</CODE> in static pattern rules: </FONT><A name=index-g_t_0024_002a_0040r_007b_002c-and-static-pattern_007d-272></A><PRE class=example><FONT class=extract>     bigoutput littleoutput : %output : text.g
             generate text.g -$* &gt; $@
</FONT></PRE>
<P class=noindent><FONT class=extract>When the <CODE>generate</CODE> command is run, <CODE>$*</CODE> will expand to the stem, either &#8216;<SAMP><SPAN class=samp>big</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>little</SPAN></SAMP>&#8217;. </FONT>
<DIV class=node><A name=Static-versus-Implicit></A>
<P><FONT class=extract></FONT></P><FONT class=extract>
<HR>
Previous:&nbsp;</FONT><A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Static-Usage" rel=previous><FONT class=extract>Static Usage</FONT></A><FONT class=extract>, Up:&nbsp;</FONT><A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Static-Pattern" rel=up><FONT class=extract>Static Pattern</FONT></A><FONT class=extract> </FONT></DIV>
<H4 class=subsection><FONT class=extract>4.12.2 Static Pattern Rules versus Implicit Rules</FONT></H4>
<P><A name=index-rule_002c-static-pattern-versus-implicit-273></A><A name=index-static-pattern-rule_002c-versus-implicit-274></A><FONT class=extract>A static pattern rule has much in common with an implicit rule defined as a pattern rule (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules"><FONT class=extract>Defining and Redefining Pattern Rules</FONT></A><FONT class=extract>). Both have a pattern for the target and patterns for constructing the names of prerequisites. The difference is in how <CODE>make</CODE> decides <EM>when</EM> the rule applies. </FONT>
<P><FONT class=extract>An implicit rule <EM>can</EM> apply to any target that matches its pattern, but it <EM>does</EM> apply only when the target has no recipe otherwise specified, and only when the prerequisites can be found. If more than one implicit rule appears applicable, only one applies; the choice depends on the order of rules. </FONT>
<P><FONT class=extract>By contrast, a static pattern rule applies to the precise list of targets that you specify in the rule. It cannot apply to any other target and it invariably does apply to each of the targets specified. If two conflicting rules apply, and both have recipes, that's an error. </FONT>
<P><FONT class=extract>The static pattern rule can be better than an implicit rule for these reasons: </FONT>
<UL>
<LI><FONT class=extract>You may wish to override the usual implicit rule for a few files whose names cannot be categorized syntactically but can be given in an explicit list. </FONT>
<LI><FONT class=extract>If you cannot be sure of the precise contents of the directories you are using, you may not be sure which other irrelevant files might lead <CODE>make</CODE> to use the wrong implicit rule. The choice might depend on the order in which the implicit rule search is done. With static pattern rules, there is no uncertainty: each rule applies to precisely the targets specified. </FONT></LI></UL>
<DIV class=node><A name=Double-Colon></A><A name=Double_002dColon></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Automatic-Prerequisites" rel=next>Automatic Prerequisites</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Static-Pattern" rel=previous>Static Pattern</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV>
<H3 class=section><FONT class=extract>4.13 Double-Colon Rules</FONT></H3>
<P><A name=index-double_002dcolon-rules-275></A><A name=index-rule_002c-double_002dcolon-_0028_0040code_007b_003a_003a_007d_0029-276></A><A name=index-multiple-rules-for-one-target-_0028_0040code_007b_003a_003a_007d_0029-277></A><A name=index-g_t_0040code_007b_003a_003a_007d-rules-_0028double_002dcolon_0029-278></A><FONT class=extract><DFN>Double-colon</DFN> rules are explicit rules written with &#8216;<SAMP><SPAN class=samp>::</SPAN></SAMP>&#8217; instead of &#8216;<SAMP><SPAN class=samp>:</SPAN></SAMP>&#8217; after the target names. They are handled differently from ordinary rules when the same target appears in more than one rule. Pattern rules with double-colons have an entirely different meaning (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Match_002dAnything-Rules"><FONT class=extract>Match-Anything Rules</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>When a target appears in multiple rules, all the rules must be the same type: all ordinary, or all double-colon. If they are double-colon, each of them is independent of the others. Each double-colon rule's recipe is executed if the target is older than any prerequisites of that rule. If there are no prerequisites for that rule, its recipe is always executed (even if the target already exists). This can result in executing none, any, or all of the double-colon rules. </FONT>
<P><FONT class=extract>Double-colon rules with the same target are in fact completely separate from one another. Each double-colon rule is processed individually, just as rules with different targets are processed. </FONT>
<P><FONT class=extract>The double-colon rules for a target are executed in the order they appear in the makefile. However, the cases where double-colon rules really make sense are those where the order of executing the recipes would not matter. </FONT>
<P><FONT class=extract>Double-colon rules are somewhat obscure and not often very useful; they provide a mechanism for cases in which the method used to update a target differs depending on which prerequisite files caused the update, and such cases are rare. </FONT>
<P><FONT class=extract>Each double-colon rule should specify a recipe; if it does not, an implicit rule will be used if one applies. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules"><FONT class=extract>Using Implicit Rules</FONT></A><FONT class=extract>. </FONT>
<DIV class=node><A name=Automatic-Prerequisites></A>
<P>
<HR>
Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Double_002dColon" rel=previous>Double-Colon</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Rules" rel=up>Rules</A> </DIV>
<H3 class=section><FONT class=extract>4.14 Generating Prerequisites Automatically</FONT></H3>
<P><A name=index-prerequisites_002c-automatic-generation-279></A><A name=index-automatic-generation-of-prerequisites-280></A><A name=index-generating-prerequisites-automatically-281></A><FONT class=extract>In the makefile for a program, many of the rules you need to write often say only that some object file depends on some header file. For example, if <SAMP><SPAN class=file>main.c</SPAN></SAMP> uses <SAMP><SPAN class=file>defs.h</SPAN></SAMP> via an <CODE>#include</CODE>, you would write: </FONT><PRE class=example><FONT class=extract>     main.o: defs.h
</FONT></PRE>
<P class=noindent><FONT class=extract>You need this rule so that <CODE>make</CODE> knows that it must remake <SAMP><SPAN class=file>main.o</SPAN></SAMP> whenever <SAMP><SPAN class=file>defs.h</SPAN></SAMP> changes. You can see that for a large program you would have to write dozens of such rules in your makefile. And, you must always be very careful to update the makefile every time you add or remove an <CODE>#include</CODE>. </FONT><A name=index-g_t_0040code_007b_0023include_007d-282></A><A name=index-g_t_0040code_007b_002dM_007d-_0028to-compiler_0029-283></A><FONT class=extract>To avoid this hassle, most modern C compilers can write these rules for you, by looking at the <CODE>#include</CODE> lines in the source files. Usually this is done with the &#8216;<SAMP><SPAN class=samp>-M</SPAN></SAMP>&#8217; option to the compiler. For example, the command: </FONT><PRE class=example><FONT class=extract>     cc -M main.c
</FONT></PRE>
<P class=noindent><FONT class=extract>generates the output: </FONT><PRE class=example><FONT class=extract>     main.o : main.c defs.h
</FONT></PRE>
<P class=noindent><FONT class=extract>Thus you no longer have to write all those rules yourself. The compiler will do it for you. </FONT>
<P><FONT class=extract>Note that such a rule constitutes mentioning <SAMP><SPAN class=file>main.o</SPAN></SAMP> in a makefile, so it can never be considered an intermediate file by implicit rule search. This means that <CODE>make</CODE> won't ever remove the file after using it; see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Chained-Rules"><FONT class=extract>Chains of Implicit Rules</FONT></A><FONT class=extract>. </FONT>
<P><A name=index-g_t_0040code_007bmake-depend_007d-284></A><FONT class=extract>With old <CODE>make</CODE> programs, it was traditional practice to use this compiler feature to generate prerequisites on demand with a command like &#8216;<SAMP><SPAN class=samp>make depend</SPAN></SAMP>&#8217;. That command would create a file <SAMP><SPAN class=file>depend</SPAN></SAMP> containing all the automatically-generated prerequisites; then the makefile could use <CODE>include</CODE> to read them in (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Include"><FONT class=extract>Include</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>In GNU <CODE>make</CODE>, the feature of remaking makefiles makes this practice obsolete&#8212;you need never tell <CODE>make</CODE> explicitly to regenerate the prerequisites, because it always regenerates any makefile that is out of date. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Remaking-Makefiles"><FONT class=extract>Remaking Makefiles</FONT></A><FONT class=extract>. </FONT>
<P><FONT class=extract>The practice we recommend for automatic prerequisite generation is to have one makefile corresponding to each source file. For each source file <SAMP><VAR>name</VAR><SPAN class=file>.c</SPAN></SAMP> there is a makefile <SAMP><VAR>name</VAR><SPAN class=file>.d</SPAN></SAMP> which lists what files the object file <SAMP><VAR>name</VAR><SPAN class=file>.o</SPAN></SAMP> depends on. That way only the source files that have changed need to be rescanned to produce the new prerequisites. </FONT>
<P><FONT class=extract>Here is the pattern rule to generate a file of prerequisites (i.e., a makefile) called <SAMP><VAR>name</VAR><SPAN class=file>.d</SPAN></SAMP> from a C source file called <SAMP><VAR>name</VAR><SPAN class=file>.c</SPAN></SAMP>: </FONT><PRE class=smallexample><FONT class=extract>     %.d: %.c
             @set -e; rm -f $@; \
              $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \
              sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' &lt; $@.$$$$ &gt; $@; \
              rm -f $@.$$$$
</FONT></PRE>
<P class=noindent><FONT class=extract>See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules"><FONT class=extract>Pattern Rules</FONT></A><FONT class=extract>, for information on defining pattern rules. The &#8216;<SAMP><SPAN class=samp>-e</SPAN></SAMP>&#8217; flag to the shell causes it to exit immediately if the <CODE>$(CC)</CODE> command (or any other command) fails (exits with a nonzero status). </FONT><A name=index-g_t_0040code_007b_002de_007d-_0028shell-flag_0029-285></A><A name=index-g_t_0040code_007b_002dMM_007d-_0028to-GNU-compiler_0029-286></A><FONT class=extract>With the GNU C compiler, you may wish to use the &#8216;<SAMP><SPAN class=samp>-MM</SPAN></SAMP>&#8217; flag instead of &#8216;<SAMP><SPAN class=samp>-M</SPAN></SAMP>&#8217;. This omits prerequisites on system header files. See </FONT><A href="https://www.gnu.org/software/make/manual/gcc.html#Preprocessor-Options"><FONT class=extract>Options Controlling the Preprocessor</FONT></A><FONT class=extract>, for details. </FONT>
<P><A name=index-g_t_0040code_007bsed_007d-_0028shell-command_0029-287></A><FONT class=extract>The purpose of the <CODE>sed</CODE> command is to translate (for example): </FONT><PRE class=example><FONT class=extract>     main.o : main.c defs.h
</FONT></PRE>
<P class=noindent><FONT class=extract>into: </FONT><PRE class=example><FONT class=extract>     main.o main.d : main.c defs.h
</FONT></PRE>
<P class=noindent><A name=index-g_t_0040code_007b_002ed_007d-288></A><FONT class=extract>This makes each &#8216;<SAMP><SPAN class=samp>.d</SPAN></SAMP>&#8217; file depend on all the source and header files that the corresponding &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; file depends on. <CODE>make</CODE> then knows it must regenerate the prerequisites whenever any of the source or header files changes. </FONT>
<P><FONT class=extract>Once you've defined the rule to remake the &#8216;<SAMP><SPAN class=samp>.d</SPAN></SAMP>&#8217; files, you then use the <CODE>include</CODE> directive to read them all in. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Include"><FONT class=extract>Include</FONT></A><FONT class=extract>. For example: </FONT><PRE class=example><FONT class=extract>     sources = foo.c bar.c
     
     include $(sources:.c=.d)
</FONT></PRE>
<P class=noindent><FONT class=extract>(This example uses a substitution variable reference to translate the list of source files &#8216;<SAMP><SPAN class=samp>foo.c bar.c</SPAN></SAMP>&#8217; into a list of prerequisite makefiles, &#8216;<SAMP><SPAN class=samp>foo.d bar.d</SPAN></SAMP>&#8217;. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Substitution-Refs"><FONT class=extract>Substitution Refs</FONT></A><FONT class=extract>, for full information on substitution references.) Since the &#8216;<SAMP><SPAN class=samp>.d</SPAN></SAMP>&#8217; files are makefiles like any others, <CODE>make</CODE> will remake them as necessary with no further work from you. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Remaking-Makefiles"><FONT class=extract>Remaking Makefiles</FONT></A><FONT class=extract>. </FONT>
<P><FONT class=extract>Note that the &#8216;<SAMP><SPAN class=samp>.d</SPAN></SAMP>&#8217; files contain target definitions; you should be sure to place the <CODE>include</CODE> directive <EM>after</EM> the first, default goal in your makefiles or run the risk of having a random object file become the default goal. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#How-Make-Works"><FONT class=extract>How Make Works</FONT></A><FONT class=extract>.</FONT>