<SPAN class=arabic>2</SPAN>. Discrete Planning 
<P>
<P>This chapter provides introductory concepts that serve as an entry point into other parts of the book. The planning problems considered here are the simplest to describe because the state space will be finite in most cases. When it is not finite, it will at least be countably infinite (i.e., a unique integer may be assigned to every state). Therefore, no geometric models or differential equations will be needed to characterize the discrete planning problems. Furthermore, no forms of uncertainty will be considered, which avoids complications such as probability theory. All models are completely known and predictable. 
<P>There are three main parts to this chapter. Sections <A href="http://planning.cs.uiuc.edu/node36.html#sec:dfp">2.1</A> and <A href="http://planning.cs.uiuc.edu/node39.html#sec:search">2.2</A> define and present search methods for feasible planning, in which the only concern is to reach a goal state. The search methods will be used throughout the book in numerous other contexts, including motion planning in continuous state spaces. Following feasible planning, Section <A href="http://planning.cs.uiuc.edu/node52.html#sec:disopt">2.3</A> addresses the problem of optimal planning. The <EM>principle of optimality</EM>, or the <EM>dynamic programming principle</EM>,<A name=2332></A> [<A href="http://planning.cs.uiuc.edu/node858.html#Bel57">84</A>] provides a key insight that greatly reduces the computation effort in many planning algorithms. The <EM>value-iteration</EM> method of dynamic programming is the main focus of Section <A href="http://planning.cs.uiuc.edu/node52.html#sec:disopt">2.3</A>. The relationship between Dijkstra's algorithm<A name=2336></A> and value iteration is also discussed. Finally, Sections <A href="http://planning.cs.uiuc.edu/node58.html#sec:logic">2.4</A> and <A href="http://planning.cs.uiuc.edu/node61.html#sec:logplan">2.5</A> describe logic-based representations of planning and methods that exploit these representations to make the problem easier to solve; material from these sections is not needed in later chapters. 
<P>Although this chapter addresses a form of planning, it encompasses what is sometimes referred to as <EM>problem solving</EM><A name=3395></A>. Throughout the history of artificial intelligence research, the distinction between <EM>problem solving</EM><A name=2341></A> [<A href="http://planning.cs.uiuc.edu/node858.html#NewSim63">735</A>] and <EM>planning</EM> has been rather elusive. The widely used textbook by Russell and Norvig<A name=3397></A> [<A href="http://planning.cs.uiuc.edu/node858.html#RusNor03">839</A>] provides a representative, modern survey of the field of artificial intelligence. Two of its six main parts are termed ``problem-solving'' and ``planning''; however, their definitions are quite similar. The problem-solving part begins by stating, ``Problem solving agents decide what to do by finding sequences of actions that lead to desirable states'' ([<A href="http://planning.cs.uiuc.edu/node858.html#RusNor03">839</A>], p. 59). The planning part begins with, ``The task of coming up with a sequence of actions that will achieve a goal is called planning'' ([<A href="http://planning.cs.uiuc.edu/node858.html#RusNor03">839</A>], p. 375). Also, the STRIPS<A name=3399></A> system [<A href="http://planning.cs.uiuc.edu/node858.html#FikNil71">337</A>] is widely considered as a seminal planning algorithm, and the ``PS'' part of its name stands for ``Problem Solver.'' Thus, problem solving and planning appear to be synonymous. Perhaps the term ``planning'' carries connotations of future time, whereas ``problem solving'' sounds somewhat more general. A problem-solving task might be to take evidence from a crime scene and piece together the actions taken by suspects. It might seem odd to call this a ``plan'' because it occurred in the past. 
<P>Since it is difficult to make clear distinctions between problem solving and planning, we will simply refer to both as planning. This also helps to keep with the theme of this book. Note, however, that some of the concepts apply to a broader set of problems than what is often meant by planning. 
<P><BR>
<HR>
<!--Table of Child-Links--><A name=CHILD_LINKS><STRONG>Subsections</STRONG></A> 
<UL class=ChildLinks>
<LI><A href="http://planning.cs.uiuc.edu/node36.html" name=tex2html1785><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>1</SPAN> Introduction to Discrete Feasible Planning</A> 
<UL>
<LI><A href="http://planning.cs.uiuc.edu/node37.html" name=tex2html1786><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>1</SPAN>.<SPAN class=arabic>1</SPAN> Problem Formulation</A> 
<LI><A href="http://planning.cs.uiuc.edu/node38.html" name=tex2html1787><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>1</SPAN>.<SPAN class=arabic>2</SPAN> Examples of Discrete Planning</A> </LI></UL><BR>
<LI><A href="http://planning.cs.uiuc.edu/node39.html" name=tex2html1788><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>2</SPAN> Searching for Feasible Plans</A> 
<UL>
<LI><A href="http://planning.cs.uiuc.edu/node40.html" name=tex2html1789><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>1</SPAN> General Forward Search</A> 
<LI><A href="http://planning.cs.uiuc.edu/node41.html" name=tex2html1790><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>2</SPAN> Particular Forward Search Methods</A> 
<UL>
<LI><A href="http://planning.cs.uiuc.edu/node42.html" name=tex2html1791>Breadth first</A> 
<LI><A href="http://planning.cs.uiuc.edu/node43.html" name=tex2html1792>Depth first</A> 
<LI><A href="http://planning.cs.uiuc.edu/node44.html" name=tex2html1793>Dijkstra's algorithm</A> 
<LI><A href="http://planning.cs.uiuc.edu/node45.html" name=tex2html1794>A-star</A> 
<LI><A href="http://planning.cs.uiuc.edu/node46.html" name=tex2html1795>Best first</A> 
<LI><A href="http://planning.cs.uiuc.edu/node47.html" name=tex2html1796>Iterative deepening</A> </LI></UL>
<LI><A href="http://planning.cs.uiuc.edu/node48.html" name=tex2html1797><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>3</SPAN> Other General Search Schemes</A> 
<UL>
<LI><A href="http://planning.cs.uiuc.edu/node49.html" name=tex2html1798>Backward search</A> 
<LI><A href="http://planning.cs.uiuc.edu/node50.html" name=tex2html1799>Bidirectional search</A> </LI></UL>
<LI><A href="http://planning.cs.uiuc.edu/node51.html" name=tex2html1800><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>2</SPAN>.<SPAN class=arabic>4</SPAN> A Unified View of the Search Methods</A> </LI></UL><BR>
<LI><A href="http://planning.cs.uiuc.edu/node52.html" name=tex2html1801><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>3</SPAN> Discrete Optimal Planning</A> 
<UL>
<LI><A href="http://planning.cs.uiuc.edu/node53.html" name=tex2html1802><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>3</SPAN>.<SPAN class=arabic>1</SPAN> Optimal Fixed-Length Plans</A> 
<UL>
<LI><A href="http://planning.cs.uiuc.edu/node54.html" name=tex2html1803><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>3</SPAN>.<SPAN class=arabic>1</SPAN>.<SPAN class=arabic>1</SPAN> Backward value iteration</A> 
<LI><A href="http://planning.cs.uiuc.edu/node55.html" name=tex2html1804><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>3</SPAN>.<SPAN class=arabic>1</SPAN>.<SPAN class=arabic>2</SPAN> Forward value iteration</A> </LI></UL>
<LI><A href="http://planning.cs.uiuc.edu/node56.html" name=tex2html1805><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>3</SPAN>.<SPAN class=arabic>2</SPAN> Optimal Plans of Unspecified Lengths</A> 
<LI><A href="http://planning.cs.uiuc.edu/node57.html" name=tex2html1806><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>3</SPAN>.<SPAN class=arabic>3</SPAN> Dijkstra Revisited</A> </LI></UL><BR>
<LI><A href="http://planning.cs.uiuc.edu/node58.html" name=tex2html1807><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>4</SPAN> Using Logic to Formulate Discrete Planning</A> 
<UL>
<LI><A href="http://planning.cs.uiuc.edu/node59.html" name=tex2html1808><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>4</SPAN>.<SPAN class=arabic>1</SPAN> A STRIPS-Like Representation</A> 
<LI><A href="http://planning.cs.uiuc.edu/node60.html" name=tex2html1809><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>4</SPAN>.<SPAN class=arabic>2</SPAN> Converting to the State-Space Representation</A> </LI></UL><BR>
<LI><A href="http://planning.cs.uiuc.edu/node61.html" name=tex2html1810><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>5</SPAN> Logic-Based Planning Methods</A> 
<UL>
<LI><A href="http://planning.cs.uiuc.edu/node62.html" name=tex2html1811><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>5</SPAN>.<SPAN class=arabic>1</SPAN> Searching in a Space of Partial Plans</A> 
<LI><A href="http://planning.cs.uiuc.edu/node63.html" name=tex2html1812><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>5</SPAN>.<SPAN class=arabic>2</SPAN> Building a Planning Graph</A> 
<UL>
<LI><A href="http://planning.cs.uiuc.edu/node64.html" name=tex2html1813>Planning graph definition</A> 
<LI><A href="http://planning.cs.uiuc.edu/node65.html" name=tex2html1814>Layer-by-layer construction</A> 
<LI><A href="http://planning.cs.uiuc.edu/node66.html" name=tex2html1815>Mutex conditions</A> 
<LI><A href="http://planning.cs.uiuc.edu/node67.html" name=tex2html1816>Plan extraction</A> </LI></UL>
<LI><A href="http://planning.cs.uiuc.edu/node68.html" name=tex2html1817><SPAN class=arabic>2</SPAN>.<SPAN class=arabic>5</SPAN>.<SPAN class=arabic>3</SPAN> Planning as Satisfiability</A> 
<LI><A href="http://planning.cs.uiuc.edu/node69.html" name=tex2html1818>Further Reading</A> 
<LI><A href="http://planning.cs.uiuc.edu/node70.html" name=tex2html1819>Exercises</A> </LI></UL></LI></UL><!--End of Table of Child-Links-->