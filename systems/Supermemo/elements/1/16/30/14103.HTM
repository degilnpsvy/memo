<H2><A name=SECTION02141000000000000000><SPAN class=arabic>1</SPAN>.<SPAN class=arabic>4</SPAN>.<SPAN class=arabic>1</SPAN> Algorithms</A> </H2>
<P>What is a planning algorithm? This is a difficult question, and a precise mathematical definition will not be given in this book. Instead, the general idea will be explained, along with many examples of planning algorithms. A more basic question is, What is an algorithm? One answer is the classical Turing machine model, which is used to define an algorithm in theoretical computer science. A <EM>Turing machine</EM><A name=1736></A> is a finite state machine with a special head that can read and write along an infinite piece of tape, as depicted in Figure <A href="http://planning.cs.uiuc.edu/node27.html#fig:turing">1.15</A>. The Church-Turing thesis<A name=1738></A> states that an algorithm <EM>is</EM> a Turing machine (see [<A href="http://planning.cs.uiuc.edu/node858.html#HopUllMot00">462</A>,<A href="http://planning.cs.uiuc.edu/node858.html#Sip97">891</A>] for more details). The <EM>input</EM> to the algorithm is encoded as a string of symbols (usually a binary string) and then is written to the tape. The Turing machine reads the string, performs computations, and then decides whether to <EM>accept</EM> or <EM>reject</EM> the string. This version of the Turing machine only solves <EM>decision problems</EM>; however, there are straightforward extensions that can yield other desired outputs, such as a plan. 
<P>
<DIV align=center><A name=fig:phil1></A><A name=1667></A>
<TABLE>
<CAPTION align=bottom><STRONG>Figure 1.16:</STRONG> (a) The boundary between machine and environment is considered as an arbitrary line that may be drawn in many ways depending on the context. (b) Once the boundary has been drawn, it is assumed that the machine, <SPAN class=MATH><IMG height=17 alt="$ M$" src="http://planning.cs.uiuc.edu/img1.gif" width=25 align=bottom border=0></SPAN>, interacts with the environment, <SPAN class=MATH><IMG height=17 alt="$ E$" src="http://planning.cs.uiuc.edu/img2.gif" width=20 align=bottom border=0></SPAN>, through sensing and actuation. </CAPTION>
<TBODY>
<TR>
<TD><IMG height=167 alt="\begin{figure}\begin{center}&#10;\begin{tabular}{ccc}&#10;\psfig{file=figs/yinyang.eps,w...&#10;...machenv.eps,width=2.5in} \\&#10;(a) &amp; &amp; (b)&#10;\end{tabular}&#10;\end{center}\end{figure}" src="http://planning.cs.uiuc.edu/img244.gif" width=521 border=0></TD></TR></TBODY></TABLE></DIV>
<P>The Turing model is reasonable for many of the algorithms in this book; however, others may not exactly fit. The trouble with using the Turing machine in some situations is that plans often interact with the physical world. As indicated in Figure <A href="http://planning.cs.uiuc.edu/node28.html#fig:phil1">1.16</A>, the boundary between the machine and the environment is an arbitrary line that varies from problem to problem. Once drawn, <EM>sensors</EM> provide information about the environment; this provides input to the machine during execution. The machine then executes actions, which provides <EM>actuation</EM> to the environment. The actuation may alter the environment in some way that is later measured by sensors. Therefore, the machine and its environment are closely coupled during execution. This is fundamental to robotics and many other fields in which planning is used. 
<P>Using the Turing machine as a foundation for algorithms usually implies that the physical world must be first carefully modeled and written on the tape before the algorithm can make decisions. If changes occur in the world during execution of the algorithm, then it is not clear what should happen. For example, a mobile robot could be moving in a cluttered environment in which people are walking around. As another example, a robot might throw an object onto a table without being able to precisely predict how the object will come to rest. It can take measurements of the results with sensors, but it again becomes a difficult task to determine how much information should be explicitly modeled and written on the tape. The <EM>on-line algorithm</EM><A name=1506></A> model is more appropriate for these kinds of problems [<A href="http://planning.cs.uiuc.edu/node858.html#Kar92">510</A>,<A href="http://planning.cs.uiuc.edu/node858.html#PapYan91">768</A>,<A href="http://planning.cs.uiuc.edu/node858.html#SleTar85">892</A>]; however, it still does not capture a notion of algorithms that is broad enough for all of the topics of this book. 
<P>
<DIV align=center><A name=fig:switches></A><A name=1669></A>
<TABLE>
<CAPTION align=bottom><STRONG>Figure 1.17:</STRONG> A robot and an infinite sequence of switches could be used to simulate a Turing machine. Through manipulation, however, many other kinds of behavior could be obtained that fall outside of the Turing model.</CAPTION>
<TBODY>
<TR>
<TD><IMG height=146 alt="\begin{figure}\centerline{\psfig{figure=figs/switches.eps,width=4.5truein} }\end{figure}" src="http://planning.cs.uiuc.edu/img245.gif" width=517 border=0></TD></TR></TBODY></TABLE></DIV>
<P>Processes that occur in a physical world are more complicated than the interaction between a state machine and a piece of tape filled with symbols. It is even possible to simulate the tape by imagining a robot that interacts with a long row of switches as depicted in Figure <A href="http://planning.cs.uiuc.edu/node28.html#fig:switches">1.17</A>. The switches serve the same purpose as the tape, and the robot carries a computer that can simulate the finite state machine.<A href="http://planning.cs.uiuc.edu/footnode.html#foot1513" name=tex2html19><SUP><SPAN class=arabic>1</SPAN>.<SPAN class=arabic>1</SPAN></SUP></A>The complicated interaction allowed between a robot and its environment could give rise to many other models of computation.<A href="http://planning.cs.uiuc.edu/footnode.html#foot1670" name=tex2html20><SUP><SPAN class=arabic>1</SPAN>.<SPAN class=arabic>2</SPAN></SUP></A> Thus, the term <EM>algorithm</EM> will be used somewhat less formally than in the theory of computation. Both <EM>planners</EM> and <EM>plans</EM> are considered as algorithms in this book.