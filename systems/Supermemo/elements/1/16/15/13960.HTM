Here is a realistic example of the use of <CODE>subst</CODE> and <CODE>patsubst</CODE>. Suppose that a makefile uses the <CODE>VPATH</CODE> variable to specify a list of directories that <CODE>make</CODE> should search for prerequisite files (see <A href="https://www.gnu.org/software/make/manual/make.html#General-Search"><CODE>VPATH</CODE> Search Path for All Prerequisites</A>). This example shows how to tell the C compiler to search for header files in the same list of directories. 
<P>The value of <CODE>VPATH</CODE> is a list of directories separated by colons, such as &#8216;<SAMP><SPAN class=samp>src:../headers</SPAN></SAMP>&#8217;. First, the <CODE>subst</CODE> function is used to change the colons to spaces: <PRE class=example>     $(subst :, ,$(VPATH))
</PRE>
<P class=noindent>This produces &#8216;<SAMP><SPAN class=samp>src ../headers</SPAN></SAMP>&#8217;. Then <CODE>patsubst</CODE> is used to turn each directory name into a &#8216;<SAMP><SPAN class=samp>-I</SPAN></SAMP>&#8217; flag. These can be added to the value of the variable <CODE>CFLAGS</CODE>, which is passed automatically to the C compiler, like this: <PRE class=example>     override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))
</PRE>
<P class=noindent>The effect is to append the text &#8216;<SAMP><SPAN class=samp>-Isrc -I../headers</SPAN></SAMP>&#8217; to the previously given value of <CODE>CFLAGS</CODE>. The <CODE>override</CODE> directive is used so that the new value is assigned even if the previous value of <CODE>CFLAGS</CODE> was specified with a command argument (see <A href="https://www.gnu.org/software/make/manual/make.html#Override-Directive">The <CODE>override</CODE> Directive</A>).