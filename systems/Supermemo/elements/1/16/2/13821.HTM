<H2 class=chapter>14 Incompatibilities and Missing Features</H2>
<P><A name=index-incompatibilities-1081></A><A name=index-missing-features-1082></A><A name=index-features_002c-missing-1083></A>The <CODE>make</CODE> programs in various other systems support a few features that are not implemented in GNU <CODE>make</CODE>. The POSIX.2 standard (<CITE>IEEE Standard 1003.2-1992</CITE>) which specifies <CODE>make</CODE> does not require any of these features. 
<UL>
<LI><FONT class=extract>A target of the form &#8216;<SAMP><VAR>file</VAR><SPAN class=samp>((</SPAN><VAR>entry</VAR><SPAN class=samp>))</SPAN></SAMP>&#8217; stands for a member of archive file <VAR>file</VAR>. The member is chosen, not by name, but by being an object file which defines the linker symbol <VAR>entry</VAR>. </FONT>
<P><FONT class=extract>This feature was not put into GNU <CODE>make</CODE> because of the non-modularity of putting knowledge into <CODE>make</CODE> of the internal format of archive file symbol tables. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Archive-Symbols"><FONT class=extract>Updating Archive Symbol Directories</FONT></A><FONT class=extract>. </FONT></P>
<LI>Suffixes (used in suffix rules) that end with the character &#8216;<SAMP><SPAN class=samp>~</SPAN></SAMP>&#8217; have a special meaning to System V <CODE>make</CODE>; they refer to the SCCS file that corresponds to the file one would get without the &#8216;<SAMP><SPAN class=samp>~</SPAN></SAMP>&#8217;. For example, the suffix rule &#8216;<SAMP><SPAN class=samp>.c~.o</SPAN></SAMP>&#8217; would make the file <SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> from the SCCS file <SAMP><SPAN class=file>s.</SPAN><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP>. For complete coverage, a whole series of such suffix rules is required. See <A href="https://www.gnu.org/software/make/manual/make.html#Suffix-Rules">Old-Fashioned Suffix Rules</A>. 
<P>In GNU <CODE>make</CODE>, this entire series of cases is handled by two pattern rules for extraction from SCCS, in combination with the general feature of rule chaining. See <A href="https://www.gnu.org/software/make/manual/make.html#Chained-Rules">Chains of Implicit Rules</A>. </P>
<LI>In System V and 4.3 BSD <CODE>make</CODE>, files found by <CODE>VPATH</CODE> search (see <A href="https://www.gnu.org/software/make/manual/make.html#Directory-Search">Searching Directories for Prerequisites</A>) have their names changed inside recipes. We feel it is much cleaner to always use automatic variables and thus make this feature obsolete. 
<LI><FONT class=extract>In some Unix <CODE>make</CODE>s, the automatic variable <CODE>$*</CODE> appearing in the prerequisites of a rule has the amazingly strange &#8220;feature&#8221; of expanding to the full name of the <EM>target of that rule</EM>. We cannot imagine what went on in the minds of Unix <CODE>make</CODE> developers to do this; it is utterly inconsistent with the normal definition of <CODE>$*</CODE>.</FONT> <A name=index-g_t_002a-_0040r_007b_0028automatic-variable_0029_002c-unsupported-bizarre-usage_007d-1084></A>
<LI>In some Unix <CODE>make</CODE>s, implicit rule search (see <A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules">Using Implicit Rules</A>) is apparently done for <EM>all</EM> targets, not just those without recipes. This means you can do: <PRE class=example>          foo.o:
                  cc -c foo.c
</PRE>
<P class=noindent>and Unix <CODE>make</CODE> will intuit that <SAMP><SPAN class=file>foo.o</SPAN></SAMP> depends on <SAMP><SPAN class=file>foo.c</SPAN></SAMP>. 
<P>We feel that such usage is broken. The prerequisite properties of <CODE>make</CODE> are well-defined (for GNU <CODE>make</CODE>, at least), and doing such a thing simply does not fit the model. </P>
<LI>GNU <CODE>make</CODE> does not include any built-in implicit rules for compiling or preprocessing EFL programs. If we hear of anyone who is using EFL, we will gladly add them. 
<LI>It appears that in SVR4 <CODE>make</CODE>, a suffix rule can be specified with no recipe, and it is treated as if it had an empty recipe (see <A href="https://www.gnu.org/software/make/manual/make.html#Empty-Recipes">Empty Recipes</A>). For example: <PRE class=example>          .c.a:
</PRE>
<P class=noindent>will override the built-in <SAMP><SPAN class=file>.c.a</SPAN></SAMP> suffix rule. 
<P>We feel that it is cleaner for a rule without a recipe to always simply add to the prerequisite list for the target. The above example can be easily rewritten to get the desired behavior in GNU <CODE>make</CODE>: <PRE class=example>          .c.a: ;
</PRE>
<LI><FONT class=extract>Some versions of <CODE>make</CODE> invoke the shell with the &#8216;<SAMP><SPAN class=samp>-e</SPAN></SAMP>&#8217; flag, except under &#8216;<SAMP><SPAN class=samp>-k</SPAN></SAMP>&#8217; (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Testing"><FONT class=extract>Testing the Compilation of a Program</FONT></A><FONT class=extract>). The &#8216;<SAMP><SPAN class=samp>-e</SPAN></SAMP>&#8217; flag tells the shell to exit as soon as any program it runs returns a nonzero status. We feel it is cleaner to write each line of the recipe to stand on its own and not require this special treatment. </FONT></LI></UL>