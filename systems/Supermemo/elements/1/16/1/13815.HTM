<H2 class=chapter>8 Functions for Transforming Text</H2>
<P><A name=index-functions-566></A><DFN>Functions</DFN> allow you to do text processing in the makefile to compute the files to operate on or the commands to use in recipes. You use a function in a <DFN>function call</DFN>, where you give the name of the function and some text (the <DFN>arguments</DFN>) for the function to operate on. The result of the function's processing is substituted into the makefile at the point of the call, just as a variable might be substituted. 
<UL class=menu>
<LI><A accessKey=1 href="https://www.gnu.org/software/make/manual/make.html#Syntax-of-Functions">Syntax of Functions</A>: How to write a function call. 
<LI><A accessKey=2 href="https://www.gnu.org/software/make/manual/make.html#Text-Functions">Text Functions</A>: General-purpose text manipulation functions. 
<LI><A accessKey=3 href="https://www.gnu.org/software/make/manual/make.html#File-Name-Functions">File Name Functions</A>: Functions for manipulating file names. 
<LI><A accessKey=4 href="https://www.gnu.org/software/make/manual/make.html#Conditional-Functions">Conditional Functions</A>: Functions that implement conditions. 
<LI><A accessKey=5 href="https://www.gnu.org/software/make/manual/make.html#Foreach-Function">Foreach Function</A>: Repeat some text with controlled variation. 
<LI><A accessKey=6 href="https://www.gnu.org/software/make/manual/make.html#File-Function">File Function</A>: Write text to a file. 
<LI><A accessKey=7 href="https://www.gnu.org/software/make/manual/make.html#Call-Function">Call Function</A>: Expand a user-defined function. 
<LI><A accessKey=8 href="https://www.gnu.org/software/make/manual/make.html#Value-Function">Value Function</A>: Return the un-expanded value of a variable. 
<LI><A accessKey=9 href="https://www.gnu.org/software/make/manual/make.html#Eval-Function">Eval Function</A>: Evaluate the arguments as makefile syntax. 
<LI><A href="https://www.gnu.org/software/make/manual/make.html#Origin-Function">Origin Function</A>: Find where a variable got its value. 
<LI><A href="https://www.gnu.org/software/make/manual/make.html#Flavor-Function">Flavor Function</A>: Find out the flavor of a variable. 
<LI><A href="https://www.gnu.org/software/make/manual/make.html#Make-Control-Functions">Make Control Functions</A>: Functions that control how make runs. 
<LI><A href="https://www.gnu.org/software/make/manual/make.html#Shell-Function">Shell Function</A>: Substitute the output of a shell command. 
<LI><A href="https://www.gnu.org/software/make/manual/make.html#Guile-Function">Guile Function</A>: Use GNU Guile embedded scripting language. </LI></UL>
<DIV class=node><A name=Syntax-of-Functions></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Text-Functions" rel=next>Text Functions</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=previous>Functions</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV>
<H3 class=section><FONT class=extract>8.1 Function Call Syntax</FONT></H3>
<P><A name=index-g_t_0040code_007b_0024_007d_002c-in-function-call-567></A><A name=index-dollar-sign-_0028_0040code_007b_0024_007d_0029_002c-in-function-call-568></A><A name=index-arguments-of-functions-569></A><A name=index-functions_002c-syntax-of-570></A><FONT class=extract>A functioln call resembles a variable reference. It can appear anywhere a variable reference can appear, and it is expanded using the same rules as variable references. A function call looks like this: </FONT><PRE class=example><FONT class=extract>     $(<VAR>function</VAR> <VAR>arguments</VAR>)
</FONT></PRE>
<P class=noindent><FONT class=extract>or like this: </FONT><PRE class=example><FONT class=extract>     ${<VAR>function</VAR> <VAR>arguments</VAR>}
</FONT></PRE>
<P><FONT class=extract>Here <VAR>function</VAR> is a function name; one of a short list of names that are part of <CODE>make</CODE>. You can also essentially create your own functions by using the <CODE>call</CODE> built-in function. </FONT>
<P><FONT class=extract>The <VAR>arguments</VAR> are the arguments of the function. They are separated from the function name by one or more spaces or tabs, and if there is more than one argument, then they are separated by commas. Such whitespace and commas are not part of an argument's value. The delimiters which you use to surround the function call, whether parentheses or braces, can appear in an argument only in matching pairs; the other kind of delimiters may appear singly. If the arguments themselves contain other function calls or variable references, it is wisest to use the same kind of delimiters for all the references; write &#8216;<SAMP><SPAN class=samp>$(subst&nbsp;a,b,$(x))</SPAN></SAMP>&#8217;<!-- /@w -->, not &#8216;<SAMP><SPAN class=samp>$(subst&nbsp;a,b,${x})</SPAN></SAMP>&#8217;<!-- /@w -->. This is because it is clearer, and because only one type of delimiter is matched to find the end of the reference. </FONT>
<P><FONT class=extract>The text written for each argument is processed by substitution of variables and function calls to produce the argument value, which is the text on which the function acts. The substitution is done in the order in which the arguments appear. </FONT>
<P><FONT class=extract>Commas and unmatched parentheses or braces cannot appear in the text of an argument as written; leading spaces cannot appear in the text of the first argument as written. These characters can be put into the argument value by variable substitution. First define variables <CODE>comma</CODE> and <CODE>space</CODE> whose values are isolated comma and space characters, then substitute these variables where such characters are wanted, like this: </FONT><PRE class=example><FONT class=extract>     comma:= ,
     empty:=
     space:= $(empty) $(empty)
     foo:= a b c
     bar:= $(subst $(space),$(comma),$(foo))
     # <SPAN class=roman><FONT face="Times New Roman">bar is now `a,b,c'.</FONT></SPAN>
</FONT></PRE>
<P class=noindent><FONT class=extract>Here the <CODE>subst</CODE> function replaces each space with a comma, through the value of <CODE>foo</CODE>, and substitutes the result. </FONT>
<DIV class=node><A name=Text-Functions></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#File-Name-Functions" rel=next>File Name Functions</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Syntax-of-Functions" rel=previous>Syntax of Functions</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV>
<H3 class=section><FONT class=extract>8.2 Functions for String Substitution and Analysis</FONT></H3>
<P><A name=index-functions_002c-for-text-571></A><FONT class=extract>Here are some functions that operate on strings: </FONT>
<DL>
<DT><FONT class=extract><CODE>$(subst </CODE><VAR>from</VAR><CODE>,</CODE><VAR>to</VAR><CODE>,</CODE><VAR>text</VAR><CODE>)</CODE> </FONT>
<DD><A name=index-subst-572></A><FONT class=extract>Performs a textual replacement on the text <VAR>text</VAR>: each occurrence of <VAR>from</VAR> is replaced by <VAR>to</VAR>. The result is substituted for the function call. For example, </FONT><PRE class=example><FONT class=extract>          $(subst ee,EE,feet on the street)
</FONT></PRE>
<P><FONT class=extract>substitutes the string &#8216;<SAMP><SPAN class=samp>fEEt on the strEEt</SPAN></SAMP>&#8217;. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(patsubst </CODE><VAR>pattern</VAR><CODE>,</CODE><VAR>replacement</VAR><CODE>,</CODE><VAR>text</VAR><CODE>)</CODE> </FONT>
<DD><A name=index-patsubst-573></A><FONT class=extract>Finds whitespace-separated words in <VAR>text</VAR> that match <VAR>pattern</VAR> and replaces them with <VAR>replacement</VAR>. Here <VAR>pattern</VAR> may contain a &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; which acts as a wildcard, matching any number of any characters within a word. If <VAR>replacement</VAR> also contains a &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;, the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; is replaced by the text that matched the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; in <VAR>pattern</VAR>. Only the first &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; in the <VAR>pattern</VAR> and <VAR>replacement</VAR> is treated this way; any subsequent &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; is unchanged. </FONT>
<P><A name=index-g_t_0040code_007b_0025_007d_002c-quoting-in-_0040code_007bpatsubst_007d-574></A><A name=index-g_t_0040code_007b_0025_007d_002c-quoting-with-_0040code_007b_005c_007d-_0028backslash_0029-575></A><A name=index-g_t_0040code_007b_005c_007d-_0028backslash_0029_002c-to-quote-_0040code_007b_0025_007d-576></A><A name=index-backslash-_0028_0040code_007b_005c_007d_0029_002c-to-quote-_0040code_007b_0025_007d-577></A><A name=index-quoting-_0040code_007b_0025_007d_002c-in-_0040code_007bpatsubst_007d-578></A><FONT class=extract>&#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; characters in <CODE>patsubst</CODE> function invocations can be quoted with preceding backslashes (&#8216;<SAMP><SPAN class=samp>\</SPAN></SAMP>&#8217;). Backslashes that would otherwise quote &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; characters can be quoted with more backslashes. Backslashes that quote &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; characters or other backslashes are removed from the pattern before it is compared file names or has a stem substituted into it. Backslashes that are not in danger of quoting &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; characters go unmolested. For example, the pattern <SAMP><SPAN class=file>the\%weird\\%pattern\\</SPAN></SAMP> has &#8216;<SAMP><SPAN class=samp>the%weird\</SPAN></SAMP>&#8217; preceding the operative &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; character, and &#8216;<SAMP><SPAN class=samp>pattern\\</SPAN></SAMP>&#8217; following it. The final two backslashes are left alone because they cannot affect any &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; character. </FONT>
<P><FONT class=extract>Whitespace between words is folded into single space characters; leading and trailing whitespace is discarded. </FONT>
<P><FONT class=extract>For example, </FONT><PRE class=example><FONT class=extract>          $(patsubst %.c,%.o,x.c.c bar.c)
</FONT></PRE>
<P class=noindent><FONT class=extract>produces the value &#8216;<SAMP><SPAN class=samp>x.c.o bar.o</SPAN></SAMP>&#8217;. </FONT>
<P><FONT class=extract>Substitution references (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Substitution-Refs"><FONT class=extract>Substitution References</FONT></A><FONT class=extract>) are a simpler way to get the effect of the <CODE>patsubst</CODE> function: </FONT><PRE class=example><FONT class=extract>          $(<VAR>var</VAR>:<VAR>pattern</VAR>=<VAR>replacement</VAR>)
</FONT></PRE>
<P class=noindent><FONT class=extract>is equivalent to </FONT><PRE class=example><FONT class=extract>          $(patsubst <VAR>pattern</VAR>,<VAR>replacement</VAR>,$(<VAR>var</VAR>))
</FONT></PRE>
<P><FONT class=extract>The second shorthand simplifies one of the most common uses of <CODE>patsubst</CODE>: replacing the suffix at the end of file names. </FONT><PRE class=example><FONT class=extract>          $(<VAR>var</VAR>:<VAR>suffix</VAR>=<VAR>replacement</VAR>)
</FONT></PRE>
<P class=noindent><FONT class=extract>is equivalent to </FONT><PRE class=example><FONT class=extract>          $(patsubst %<VAR>suffix</VAR>,%<VAR>replacement</VAR>,$(<VAR>var</VAR>))
</FONT></PRE>
<P class=noindent><FONT class=extract>For example, you might have a list of object files: </FONT><PRE class=example><FONT class=extract>          objects = foo.o bar.o baz.o
</FONT></PRE>
<P class=noindent><FONT class=extract>To get the list of corresponding source files, you could simply write: </FONT><PRE class=example><FONT class=extract>          $(objects:.o=.c)
</FONT></PRE>
<P class=noindent><FONT class=extract>instead of using the general form: </FONT><PRE class=example><FONT class=extract>          $(patsubst %.o,%.c,$(objects))
</FONT></PRE><BR>
<DT><FONT class=extract><CODE>$(strip </CODE><VAR>string</VAR><CODE>)</CODE> </FONT>
<DD><A name=index-stripping-whitespace-579></A><A name=index-whitespace_002c-stripping-580></A><A name=index-spaces_002c-stripping-581></A><A name=index-strip-582></A><FONT class=extract>Removes leading and trailing whitespace from <VAR>string</VAR> and replaces each internal sequence of one or more whitespace characters with a single space. Thus, &#8216;<SAMP><SPAN class=samp>$(strip a b c )</SPAN></SAMP>&#8217; results in &#8216;<SAMP><SPAN class=samp>a&nbsp;b&nbsp;c</SPAN></SAMP>&#8217;<!-- /@w -->. </FONT>
<P><FONT class=extract>The function <CODE>strip</CODE> can be very useful when used in conjunction with conditionals. When comparing something with the empty string &#8216;<SAMP></SAMP>&#8217; using <CODE>ifeq</CODE> or <CODE>ifneq</CODE>, you usually want a string of just whitespace to match the empty string (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Conditionals"><FONT class=extract>Conditionals</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>Thus, the following may fail to have the desired results: </FONT><PRE class=example><FONT class=extract>          .PHONY: all
          ifneq   "$(needs_made)" ""
          all: $(needs_made)
          else
          all:;@echo 'Nothing to make!'
          endif
</FONT></PRE>
<P class=noindent><FONT class=extract>Replacing the variable reference &#8216;<SAMP><SPAN class=samp>$(needs_made)</SPAN></SAMP>&#8217;<!-- /@w --> with the function call &#8216;<SAMP><SPAN class=samp>$(strip&nbsp;$(needs_made))</SPAN></SAMP>&#8217;<!-- /@w --> in the <CODE>ifneq</CODE> directive would make it more robust. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(findstring </CODE><VAR>find</VAR><CODE>,</CODE><VAR>in</VAR><CODE>)</CODE> </FONT>
<DD><A name=index-findstring-583></A><A name=index-searching-for-strings-584></A><A name=index-finding-strings-585></A><A name=index-strings_002c-searching-for-586></A><FONT class=extract>Searches <VAR>in</VAR> for an occurrence of <VAR>find</VAR>. If it occurs, the value is <VAR>find</VAR>; otherwise, the value is empty. You can use this function in a conditional to test for the presence of a specific substring in a given string. Thus, the two examples, </FONT><PRE class=example><FONT class=extract>          $(findstring a,a b c)
          $(findstring a,b c)
</FONT></PRE>
<P class=noindent><FONT class=extract>produce the values &#8216;<SAMP><SPAN class=samp>a</SPAN></SAMP>&#8217; and &#8216;<SAMP></SAMP>&#8217; (the empty string), respectively. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Testing-Flags"><FONT class=extract>Testing Flags</FONT></A><FONT class=extract>, for a practical application of <CODE>findstring</CODE>. </FONT>
<P><A name=index-filter-587><FONT class=extract></FONT></A><A name=index-filtering-words-588></A><A name=index-words_002c-filtering-589></A><BR></P>
<DT><FONT class=extract><CODE>$(filter </CODE><VAR>pattern</VAR><CODE>...,</CODE><VAR>text</VAR><CODE>)</CODE> </FONT>
<DD><FONT class=extract>Returns all whitespace-separated words in <VAR>text</VAR> that <EM>do</EM> match any of the <VAR>pattern</VAR> words, removing any words that <EM>do not</EM> match. The patterns are written using &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;, just like the patterns used in the <CODE>patsubst</CODE> function above. </FONT>
<P><FONT class=extract>The <CODE>filter</CODE> function can be used to separate out different types of strings (such as file names) in a variable. For example: </FONT><PRE class=example><FONT class=extract>          sources := foo.c bar.c baz.s ugh.h
          foo: $(sources)
                  cc $(filter %.c %.s,$(sources)) -o foo
</FONT></PRE>
<P class=noindent><FONT class=extract>says that <SAMP><SPAN class=file>foo</SPAN></SAMP> depends of <SAMP><SPAN class=file>foo.c</SPAN></SAMP>, <SAMP><SPAN class=file>bar.c</SPAN></SAMP>, <SAMP><SPAN class=file>baz.s</SPAN></SAMP> and <SAMP><SPAN class=file>ugh.h</SPAN></SAMP> but only <SAMP><SPAN class=file>foo.c</SPAN></SAMP>, <SAMP><SPAN class=file>bar.c</SPAN></SAMP> and <SAMP><SPAN class=file>baz.s</SPAN></SAMP> should be specified in the command to the compiler. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(filter-out </CODE><VAR>pattern</VAR><CODE>...,</CODE><VAR>text</VAR><CODE>)</CODE> </FONT>
<DD><A name=index-filter_002dout-590></A><A name=index-filtering-out-words-591></A><A name=index-words_002c-filtering-out-592></A><FONT class=extract>Returns all whitespace-separated words in <VAR>text</VAR> that <EM>do not</EM> match any of the <VAR>pattern</VAR> words, removing the words that <EM>do</EM> match one or more. This is the exact opposite of the <CODE>filter</CODE> function. </FONT>
<P><FONT class=extract>For example, given: </FONT><PRE class=example><FONT class=extract>          objects=main1.o foo.o main2.o bar.o
          mains=main1.o main2.o
</FONT></PRE>
<P class=noindent><FONT class=extract>the following generates a list which contains all the object files not in &#8216;<SAMP><SPAN class=samp>mains</SPAN></SAMP>&#8217;: </FONT><PRE class=example><FONT class=extract>          $(filter-out $(mains),$(objects))
</FONT></PRE>
<P><A name=index-sort-593><FONT class=extract></FONT></A><A name=index-sorting-words-594></A><BR></P>
<DT><FONT class=extract><CODE>$(sort </CODE><VAR>list</VAR><CODE>)</CODE> </FONT>
<DD><FONT class=extract>Sorts the words of <VAR>list</VAR> in lexical order, removing duplicate words. The output is a list of words separated by single spaces. Thus, </FONT><PRE class=example><FONT class=extract>          $(sort foo bar lose)
</FONT></PRE>
<P class=noindent><FONT class=extract>returns the value &#8216;<SAMP><SPAN class=samp>bar foo lose</SPAN></SAMP>&#8217;. </FONT>
<P><A name=index-removing-duplicate-words-595></A><A name=index-duplicate-words_002c-removing-596></A><A name=index-words_002c-removing-duplicates-597></A><FONT class=extract>Incidentally, since <CODE>sort</CODE> removes duplicate words, you can use it for this purpose even if you don't care about the sort order. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(word </CODE><VAR>n</VAR><CODE>,</CODE><VAR>text</VAR><CODE>)</CODE> </FONT>
<DD><A name=index-word-598></A><A name=index-word_002c-selecting-a-599></A><A name=index-selecting-a-word-600></A><FONT class=extract>Returns the <VAR>n</VAR>th word of <VAR>text</VAR>. The legitimate values of <VAR>n</VAR> start from 1. If <VAR>n</VAR> is bigger than the number of words in <VAR>text</VAR>, the value is empty. For example, </FONT><PRE class=example><FONT class=extract>          $(word 2, foo bar baz)
</FONT></PRE>
<P class=noindent><FONT class=extract>returns &#8216;<SAMP><SPAN class=samp>bar</SPAN></SAMP>&#8217;. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(wordlist </CODE><VAR>s</VAR><CODE>,</CODE><VAR>e</VAR><CODE>,</CODE><VAR>text</VAR><CODE>)</CODE> </FONT>
<DD><A name=index-wordlist-601></A><A name=index-words_002c-selecting-lists-of-602></A><A name=index-selecting-word-lists-603></A><FONT class=extract>Returns the list of words in <VAR>text</VAR> starting with word <VAR>s</VAR> and ending with word <VAR>e</VAR> (inclusive). The legitimate values of <VAR>s</VAR> start from 1; <VAR>e</VAR> may start from 0. If <VAR>s</VAR> is bigger than the number of words in <VAR>text</VAR>, the value is empty. If <VAR>e</VAR> is bigger than the number of words in <VAR>text</VAR>, words up to the end of <VAR>text</VAR> are returned. If <VAR>s</VAR> is greater than <VAR>e</VAR>, nothing is returned. For example, </FONT><PRE class=example><FONT class=extract>          $(wordlist 2, 3, foo bar baz)
</FONT></PRE>
<P class=noindent><FONT class=extract>returns &#8216;<SAMP><SPAN class=samp>bar baz</SPAN></SAMP>&#8217;. <!-- Following item phrased to prevent overfull hbox.  -RJC 17 Jul 92 --><BR></FONT></P>
<DT><FONT class=extract><CODE>$(words </CODE><VAR>text</VAR><CODE>)</CODE> </FONT>
<DD><A name=index-words-604></A><A name=index-words_002c-finding-number-605></A><FONT class=extract>Returns the number of words in <VAR>text</VAR>. Thus, the last word of <VAR>text</VAR> is <CODE>$(word&nbsp;$(words&nbsp;</CODE><VAR>text</VAR><CODE>),</CODE><VAR>text</VAR><CODE>)</CODE><!-- /@w -->. <BR></FONT>
<DT><FONT class=extract><CODE>$(firstword </CODE><VAR>names</VAR><CODE>...)</CODE> </FONT>
<DD><A name=index-firstword-606></A><A name=index-words_002c-extracting-first-607></A><FONT class=extract>The argument <VAR>names</VAR> is regarded as a series of names, separated by whitespace. The value is the first name in the series. The rest of the names are ignored. </FONT>
<P><FONT class=extract>For example, </FONT><PRE class=example><FONT class=extract>          $(firstword foo bar)
</FONT></PRE>
<P class=noindent><FONT class=extract>produces the result &#8216;<SAMP><SPAN class=samp>foo</SPAN></SAMP>&#8217;. Although <CODE>$(firstword </CODE><VAR>text</VAR><CODE>)</CODE> is the same as <CODE>$(word 1,</CODE><VAR>text</VAR><CODE>)</CODE>, the <CODE>firstword</CODE> function is retained for its simplicity. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(lastword </CODE><VAR>names</VAR><CODE>...)</CODE> </FONT>
<DD><A name=index-lastword-608></A><A name=index-words_002c-extracting-last-609></A><FONT class=extract>The argument <VAR>names</VAR> is regarded as a series of names, separated by whitespace. The value is the last name in the series. </FONT>
<P><FONT class=extract>For example, </FONT><PRE class=example><FONT class=extract>          $(lastword foo bar)
</FONT></PRE>
<P class=noindent><FONT class=extract>produces the result &#8216;<SAMP><SPAN class=samp>bar</SPAN></SAMP>&#8217;. Although <CODE>$(lastword </CODE><VAR>text</VAR><CODE>)</CODE> is the same as <CODE>$(word $(words </CODE><VAR>text</VAR><CODE>),</CODE><VAR>text</VAR><CODE>)</CODE>, the <CODE>lastword</CODE> function was added for its simplicity and better performance. </FONT></P></DD></DL>
<P><FONT class=extract>Here is a realistic example of the use of <CODE>subst</CODE> and <CODE>patsubst</CODE>. Suppose that a makefile uses the <CODE>VPATH</CODE> variable to specify a list of directories that <CODE>make</CODE> should search for prerequisite files (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#General-Search"><FONT class=extract><CODE>VPATH</CODE> Search Path for All Prerequisites</FONT></A><FONT class=extract>). This example shows how to tell the C compiler to search for header files in the same list of directories. </FONT>
<P><FONT class=extract>The value of <CODE>VPATH</CODE> is a list of directories separated by colons, such as &#8216;<SAMP><SPAN class=samp>src:../headers</SPAN></SAMP>&#8217;. First, the <CODE>subst</CODE> function is used to change the colons to spaces: </FONT><PRE class=example><FONT class=extract>     $(subst :, ,$(VPATH))
</FONT></PRE>
<P class=noindent><FONT class=extract>This produces &#8216;<SAMP><SPAN class=samp>src ../headers</SPAN></SAMP>&#8217;. Then <CODE>patsubst</CODE> is used to turn each directory name into a &#8216;<SAMP><SPAN class=samp>-I</SPAN></SAMP>&#8217; flag. These can be added to the value of the variable <CODE>CFLAGS</CODE>, which is passed automatically to the C compiler, like this: </FONT><PRE class=example><FONT class=extract>     override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))
</FONT></PRE>
<P class=noindent><FONT class=extract>The effect is to append the text &#8216;<SAMP><SPAN class=samp>-Isrc -I../headers</SPAN></SAMP>&#8217; to the previously given value of <CODE>CFLAGS</CODE>. The <CODE>override</CODE> directive is used so that the new value is assigned even if the previous value of <CODE>CFLAGS</CODE> was specified with a command argument (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Override-Directive"><FONT class=extract>The <CODE>override</CODE> Directive</FONT></A><FONT class=extract>). </FONT>
<DIV class=node><A name=File-Name-Functions></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Conditional-Functions" rel=next>Conditional Functions</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Text-Functions" rel=previous>Text Functions</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV>
<H3 class=section><FONT class=extract>8.3 Functions for File Names</FONT></H3>
<P><A name=index-functions_002c-for-file-names-610></A><A name=index-file-name-functions-611></A><FONT class=extract>Several of the built-in expansion functions relate specifically to taking apart file names or lists of file names. </FONT>
<P><FONT class=extract>Each of the following functions performs a specific transformation on a file name. The argument of the function is regarded as a series of file names, separated by whitespace. (Leading and trailing whitespace is ignored.) Each file name in the series is transformed in the same way and the results are concatenated with single spaces between them. </FONT>
<DL>
<DT><FONT class=extract><CODE>$(dir </CODE><VAR>names</VAR><CODE>...)</CODE> </FONT>
<DD><A name=index-dir-612></A><A name=index-directory-part-613></A><A name=index-file-name_002c-directory-part-614></A><FONT class=extract>Extracts the directory-part of each file name in <VAR>names</VAR>. The directory-part of the file name is everything up through (and including) the last slash in it. If the file name contains no slash, the directory part is the string &#8216;<SAMP><SPAN class=samp>./</SPAN></SAMP>&#8217;. For example, </FONT><PRE class=example><FONT class=extract>          $(dir src/foo.c hacks)
</FONT></PRE>
<P class=noindent><FONT class=extract>produces the result &#8216;<SAMP><SPAN class=samp>src/ ./</SPAN></SAMP>&#8217;. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(notdir </CODE><VAR>names</VAR><CODE>...)</CODE> </FONT>
<DD><A name=index-notdir-615></A><A name=index-file-name_002c-nondirectory-part-616></A><A name=index-nondirectory-part-617></A><FONT class=extract>Extracts all but the directory-part of each file name in <VAR>names</VAR>. If the file name contains no slash, it is left unchanged. Otherwise, everything through the last slash is removed from it. </FONT>
<P><FONT class=extract>A file name that ends with a slash becomes an empty string. This is unfortunate, because it means that the result does not always have the same number of whitespace-separated file names as the argument had; but we do not see any other valid alternative. </FONT>
<P><FONT class=extract>For example, </FONT><PRE class=example><FONT class=extract>          $(notdir src/foo.c hacks)
</FONT></PRE>
<P class=noindent><FONT class=extract>produces the result &#8216;<SAMP><SPAN class=samp>foo.c hacks</SPAN></SAMP>&#8217;. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(suffix </CODE><VAR>names</VAR><CODE>...)</CODE> </FONT>
<DD><A name=index-suffix-618></A><A name=index-suffix_002c-function-to-find-619></A><A name=index-file-name-suffix-620></A><FONT class=extract>Extracts the suffix of each file name in <VAR>names</VAR>. If the file name contains a period, the suffix is everything starting with the last period. Otherwise, the suffix is the empty string. This frequently means that the result will be empty when <VAR>names</VAR> is not, and if <VAR>names</VAR> contains multiple file names, the result may contain fewer file names. </FONT>
<P><FONT class=extract>For example, </FONT><PRE class=example><FONT class=extract>          $(suffix src/foo.c src-1.0/bar.c hacks)
</FONT></PRE>
<P class=noindent><FONT class=extract>produces the result &#8216;<SAMP><SPAN class=samp>.c .c</SPAN></SAMP>&#8217;. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(basename </CODE><VAR>names</VAR><CODE>...)</CODE> </FONT>
<DD><A name=index-basename-621></A><A name=index-basename-622></A><A name=index-file-name_002c-basename-of-623></A><FONT class=extract>Extracts all but the suffix of each file name in <VAR>names</VAR>. If the file name contains a period, the basename is everything starting up to (and not including) the last period. Periods in the directory part are ignored. If there is no period, the basename is the entire file name. For example, </FONT><PRE class=example><FONT class=extract>          $(basename src/foo.c src-1.0/bar hacks)
</FONT></PRE>
<P class=noindent><FONT class=extract>produces the result &#8216;<SAMP><SPAN class=samp>src/foo src-1.0/bar hacks</SPAN></SAMP>&#8217;. <!-- plural convention with dots (be consistent) --><BR></FONT></P>
<DT><FONT class=extract><CODE>$(addsuffix </CODE><VAR>suffix</VAR><CODE>,</CODE><VAR>names</VAR><CODE>...)</CODE> </FONT>
<DD><A name=index-addsuffix-624></A><A name=index-suffix_002c-adding-625></A><A name=index-file-name-suffix_002c-adding-626></A><FONT class=extract>The argument <VAR>names</VAR> is regarded as a series of names, separated by whitespace; <VAR>suffix</VAR> is used as a unit. The value of <VAR>suffix</VAR> is appended to the end of each individual name and the resulting larger names are concatenated with single spaces between them. For example, </FONT><PRE class=example><FONT class=extract>          $(addsuffix .c,foo bar)
</FONT></PRE>
<P class=noindent><FONT class=extract>produces the result &#8216;<SAMP><SPAN class=samp>foo.c bar.c</SPAN></SAMP>&#8217;. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(addprefix </CODE><VAR>prefix</VAR><CODE>,</CODE><VAR>names</VAR><CODE>...)</CODE> </FONT>
<DD><A name=index-addprefix-627></A><A name=index-prefix_002c-adding-628></A><A name=index-file-name-prefix_002c-adding-629></A><FONT class=extract>The argument <VAR>names</VAR> is regarded as a series of names, separated by whitespace; <VAR>prefix</VAR> is used as a unit. The value of <VAR>prefix</VAR> is prepended to the front of each individual name and the resulting larger names are concatenated with single spaces between them. For example, </FONT><PRE class=example><FONT class=extract>          $(addprefix src/,foo bar)
</FONT></PRE>
<P class=noindent><FONT class=extract>produces the result &#8216;<SAMP><SPAN class=samp>src/foo src/bar</SPAN></SAMP>&#8217;. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(join </CODE><VAR>list1</VAR><CODE>,</CODE><VAR>list2</VAR><CODE>)</CODE> </FONT>
<DD><A name=index-join-630></A><A name=index-joining-lists-of-words-631></A><A name=index-words_002c-joining-lists-632></A><FONT class=extract>Concatenates the two arguments word by word: the two first words (one from each argument) concatenated form the first word of the result, the two second words form the second word of the result, and so on. So the <VAR>n</VAR>th word of the result comes from the <VAR>n</VAR>th word of each argument. If one argument has more words that the other, the extra words are copied unchanged into the result. </FONT>
<P><FONT class=extract>For example, &#8216;<SAMP><SPAN class=samp>$(join a b,.c .o)</SPAN></SAMP>&#8217; produces &#8216;<SAMP><SPAN class=samp>a.c b.o</SPAN></SAMP>&#8217;. </FONT>
<P><FONT class=extract>Whitespace between the words in the lists is not preserved; it is replaced with a single space. </FONT>
<P><FONT class=extract>This function can merge the results of the <CODE>dir</CODE> and <CODE>notdir</CODE> functions, to produce the original list of files which was given to those two functions. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(wildcard </CODE><VAR>pattern</VAR><CODE>)</CODE> </FONT>
<DD><A name=index-wildcard-633></A><A name=index-wildcard_002c-function-634></A><FONT class=extract>The argument <VAR>pattern</VAR> is a file name pattern, typically containing wildcard characters (as in shell file name patterns). The result of <CODE>wildcard</CODE> is a space-separated list of the names of existing files that match the pattern. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Wildcards"><FONT class=extract>Using Wildcard Characters in File Names</FONT></A><FONT class=extract>. <BR></FONT>
<DT><FONT class=extract><CODE>$(realpath </CODE><VAR>names</VAR><CODE>...)</CODE> </FONT>
<DD><A name=index-realpath-635></A><A name=index-realpath-636></A><A name=index-file-name_002c-realpath-of-637></A><FONT class=extract>For each file name in <VAR>names</VAR> return the canonical absolute name. A canonical name does not contain any <CODE>.</CODE> or <CODE>..</CODE> components, nor any repeated path separators (<CODE>/</CODE>) or symlinks. In case of a failure the empty string is returned. Consult the <CODE>realpath(3)</CODE> documentation for a list of possible failure causes. <BR></FONT>
<DT><FONT class=extract><CODE>$(abspath </CODE><VAR>names</VAR><CODE>...)</CODE> </FONT>
<DD><A name=index-abspath-638></A><A name=index-abspath-639></A><A name=index-file-name_002c-abspath-of-640></A><FONT class=extract>For each file name in <VAR>names</VAR> return an absolute name that does not contain any <CODE>.</CODE> or <CODE>..</CODE> components, nor any repeated path separators (<CODE>/</CODE>). Note that, in contrast to <CODE>realpath</CODE> function, <CODE>abspath</CODE> does not resolve symlinks and does not require the file names to refer to an existing file or directory. Use the <CODE>wildcard</CODE> function to test for existence. </FONT></DD></DL>
<DIV class=node><A name=Conditional-Functions></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Foreach-Function" rel=next>Foreach Function</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#File-Name-Functions" rel=previous>File Name Functions</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV>
<H3 class=section><FONT class=extract>8.4 Functions for Conditionals</FONT></H3>
<P><A name=index-if-641></A><A name=index-conditional-expansion-642></A><FONT class=extract>There are three functions that provide conditional expansion. A key aspect of these functions is that not all of the arguments are expanded initially. Only those arguments which need to be expanded, will be expanded. </FONT>
<DL>
<DT><FONT class=extract><CODE>$(if </CODE><VAR>condition</VAR><CODE>,</CODE><VAR>then-part</VAR><CODE>[,</CODE><VAR>else-part</VAR><CODE>])</CODE> </FONT>
<DD><A name=index-if-643></A><FONT class=extract>The <CODE>if</CODE> function provides support for conditional expansion in a functional context (as opposed to the GNU <CODE>make</CODE> makefile conditionals such as <CODE>ifeq</CODE> (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Conditional-Syntax"><FONT class=extract>Syntax of Conditionals</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>The first argument, <VAR>condition</VAR>, first has all preceding and trailing whitespace stripped, then is expanded. If it expands to any non-empty string, then the condition is considered to be true. If it expands to an empty string, the condition is considered to be false. </FONT>
<P><FONT class=extract>If the condition is true then the second argument, <VAR>then-part</VAR>, is evaluated and this is used as the result of the evaluation of the entire <CODE>if</CODE> function. </FONT>
<P><FONT class=extract>If the condition is false then the third argument, <VAR>else-part</VAR>, is evaluated and this is the result of the <CODE>if</CODE> function. If there is no third argument, the <CODE>if</CODE> function evaluates to nothing (the empty string). </FONT>
<P><FONT class=extract>Note that only one of the <VAR>then-part</VAR> or the <VAR>else-part</VAR> will be evaluated, never both. Thus, either can contain side-effects (such as <CODE>shell</CODE> function calls, etc.) <BR></FONT></P>
<DT><FONT class=extract><CODE>$(or </CODE><VAR>condition1</VAR><CODE>[,</CODE><VAR>condition2</VAR><CODE>[,</CODE><VAR>condition3</VAR><CODE>...]])</CODE> </FONT>
<DD><A name=index-or-644></A><FONT class=extract>The <CODE>or</CODE> function provides a &#8220;short-circuiting&#8221; OR operation. Each argument is expanded, in order. If an argument expands to a non-empty string the processing stops and the result of the expansion is that string. If, after all arguments are expanded, all of them are false (empty), then the result of the expansion is the empty string. <BR></FONT>
<DT><FONT class=extract><CODE>$(and </CODE><VAR>condition1</VAR><CODE>[,</CODE><VAR>condition2</VAR><CODE>[,</CODE><VAR>condition3</VAR><CODE>...]])</CODE> </FONT>
<DD><A name=index-and-645></A><FONT class=extract>The <CODE>and</CODE> function provides a &#8220;short-circuiting&#8221; AND operation. Each argument is expanded, in order. If an argument expands to an empty string the processing stops and the result of the expansion is the empty string. If all arguments expand to a non-empty string then the result of the expansion is the expansion of the last argument. </FONT></DD></DL>
<DIV class=node><A name=Foreach-Function></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#File-Function" rel=next>File Function</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Conditional-Functions" rel=previous>Conditional Functions</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV>
<H3 class=section><FONT class=extract>8.5 The <CODE>foreach</CODE> Function</FONT></H3>
<P><A name=index-foreach-646></A><A name=index-words_002c-iterating-over-647></A><FONT class=extract>The <CODE>foreach</CODE> function is very different from other functions. It causes one piece of text to be used repeatedly, each time with a different substitution performed on it. It resembles the <CODE>for</CODE> command in the shell <CODE>sh</CODE> and the <CODE>foreach</CODE> command in the C-shell <CODE>csh</CODE>. </FONT>
<P><FONT class=extract>The syntax of the <CODE>foreach</CODE> function is: </FONT><PRE class=example><FONT class=extract>     $(foreach <VAR>var</VAR>,<VAR>list</VAR>,<VAR>text</VAR>)
</FONT></PRE>
<P class=noindent><FONT class=extract>The first two arguments, <VAR>var</VAR> and <VAR>list</VAR>, are expanded before anything else is done; note that the last argument, <VAR>text</VAR>, is <STRONG>not</STRONG> expanded at the same time. Then for each word of the expanded value of <VAR>list</VAR>, the variable named by the expanded value of <VAR>var</VAR> is set to that word, and <VAR>text</VAR> is expanded. Presumably <VAR>text</VAR> contains references to that variable, so its expansion will be different each time. </FONT>
<P><FONT class=extract>The result is that <VAR>text</VAR> is expanded as many times as there are whitespace-separated words in <VAR>list</VAR>. The multiple expansions of <VAR>text</VAR> are concatenated, with spaces between them, to make the result of <CODE>foreach</CODE>. </FONT>
<P><FONT class=extract>This simple example sets the variable &#8216;<SAMP><SPAN class=samp>files</SPAN></SAMP>&#8217; to the list of all files in the directories in the list &#8216;<SAMP><SPAN class=samp>dirs</SPAN></SAMP>&#8217;: </FONT><PRE class=example><FONT class=extract>     dirs := a b c d
     files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))
</FONT></PRE>
<P><FONT class=extract>Here <VAR>text</VAR> is &#8216;<SAMP><SPAN class=samp>$(wildcard $(dir)/*)</SPAN></SAMP>&#8217;. The first repetition finds the value &#8216;<SAMP><SPAN class=samp>a</SPAN></SAMP>&#8217; for <CODE>dir</CODE>, so it produces the same result as &#8216;<SAMP><SPAN class=samp>$(wildcard a/*)</SPAN></SAMP>&#8217;; the second repetition produces the result of &#8216;<SAMP><SPAN class=samp>$(wildcard b/*)</SPAN></SAMP>&#8217;; and the third, that of &#8216;<SAMP><SPAN class=samp>$(wildcard c/*)</SPAN></SAMP>&#8217;. </FONT>
<P><FONT class=extract>This example has the same result (except for setting &#8216;<SAMP><SPAN class=samp>dirs</SPAN></SAMP>&#8217;) as the following example: </FONT><PRE class=example><FONT class=extract>     files := $(wildcard a/* b/* c/* d/*)
</FONT></PRE>
<P><FONT class=extract>When <VAR>text</VAR> is complicated, you can improve readability by giving it a name, with an additional variable: </FONT><PRE class=example><FONT class=extract>     find_files = $(wildcard $(dir)/*)
     dirs := a b c d
     files := $(foreach dir,$(dirs),$(find_files))
</FONT></PRE>
<P class=noindent><FONT class=extract>Here we use the variable <CODE>find_files</CODE> this way. We use plain &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217; to define a recursively-expanding variable, so that its value contains an actual function call to be re-expanded under the control of <CODE>foreach</CODE>; a simply-expanded variable would not do, since <CODE>wildcard</CODE> would be called only once at the time of defining <CODE>find_files</CODE>. </FONT>
<P><FONT class=extract>The <CODE>foreach</CODE> function has no permanent effect on the variable <VAR>var</VAR>; its value and flavor after the <CODE>foreach</CODE> function call are the same as they were beforehand. The other values which are taken from <VAR>list</VAR> are in effect only temporarily, during the execution of <CODE>foreach</CODE>. The variable <VAR>var</VAR> is a simply-expanded variable during the execution of <CODE>foreach</CODE>. If <VAR>var</VAR> was undefined before the <CODE>foreach</CODE> function call, it is undefined after the call. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Flavors"><FONT class=extract>The Two Flavors of Variables</FONT></A><FONT class=extract>. </FONT>
<P><FONT class=extract>You must take care when using complex variable expressions that result in variable names because many strange things are valid variable names, but are probably not what you intended. For example, </FONT><PRE class=smallexample><FONT class=extract>     files := $(foreach Esta-escrito-en-espanol!,b c ch,$(find_files))
</FONT></PRE>
<P class=noindent><FONT class=extract>might be useful if the value of <CODE>find_files</CODE> references the variable whose name is &#8216;<SAMP><SPAN class=samp>Esta-escrito-en-espanol!</SPAN></SAMP>&#8217; (es un nombre bastante largo, no?), but it is more likely to be a mistake. </FONT>
<DIV class=node><A name=File-Function></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Call-Function" rel=next>Call Function</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Foreach-Function" rel=previous>Foreach Function</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV>
<H3 class=section><FONT class=extract>8.6 The <CODE>file</CODE> Function</FONT></H3>
<P><A name=index-file-648></A><A name=index-writing-to-a-file-649></A><A name=index-file_002c-writing-to-650></A><FONT class=extract>The <CODE>file</CODE> function allows the makefile to write to a file. Two modes of writing are supported: overwrite, where the text is written to the beginning of the file and any existing content is lost, and append, where the text is written to the end of the file, preserving the existing content. In all cases the file is created if it does not exist. </FONT>
<P><FONT class=extract>The syntax of the <CODE>file</CODE> function is: </FONT><PRE class=example><FONT class=extract>     $(file <VAR>op</VAR> <VAR>filename</VAR>,<VAR>text</VAR>)
</FONT></PRE>
<P><FONT class=extract>The operator <VAR>op</VAR> can be either <CODE>&gt;</CODE> which indicates overwrite mode, or <CODE>&gt;&gt;</CODE> which indicates append mode. The <VAR>filename</VAR> indicates the file to be written to. There may optionally be whitespace between the operator and the file name. </FONT>
<P><FONT class=extract>When the <CODE>file</CODE> function is expanded all its arguments are expanded first, then the file indicated by <VAR>filename</VAR> will be opened in the mode described by <VAR>op</VAR>. Finally <VAR>text</VAR> will be written to the file. If <VAR>text</VAR> does not already end in a newline, a final newline will be written. The result of evaluating the <CODE>file</CODE> function is always the empty string. </FONT>
<P><FONT class=extract>It is a fatal error if the file cannot be opened for writing, or if the write operation fails. </FONT>
<P><FONT class=extract>For example, the <CODE>file</CODE> function can be useful if your build system has a limited command line size and your recipe runs a command that can accept arguments from a file as well. Many commands use the convention that an argument prefixed with an <CODE>@</CODE> specifies a file containing more arguments. Then you might write your recipe in this way: </FONT><PRE class=example><FONT class=extract>     program: $(OBJECTS)
             $(file &gt;$@.in,$^)
             $(CMD) $(CMDFLAGS) @$@.in
             @rm $@.in
</FONT></PRE>
<P><FONT class=extract>If the command required each argument to be on a separate line of the input file, you might write your recipe like this: </FONT><PRE class=example><FONT class=extract>     program: $(OBJECTS)
             $(file &gt;$@.in,) $(foreach O,$^,$(file &gt;&gt;$@.in,$O))
             $(CMD) $(CMDFLAGS) @$@.in
             @rm $@.in</FONT>
</PRE>
<DIV class=node><A name=Call-Function></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Value-Function" rel=next>Value Function</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#File-Function" rel=previous>File Function</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV>
<H3 class=section><FONT class=extract>8.7 The <CODE>call</CODE> Function</FONT></H3>
<P><A name=index-call-651></A><A name=index-functions_002c-user-defined-652></A><A name=index-user-defined-functions-653></A><FONT class=extract>The <CODE>call</CODE> function is unique in that it can be used to create new parameterized functions. You can write a complex expression as the value of a variable, then use <CODE>call</CODE> to expand it with different values. </FONT>
<P><FONT class=extract>The syntax of the <CODE>call</CODE> function is: </FONT><PRE class=example><FONT class=extract>     $(call <VAR>variable</VAR>,<VAR>param</VAR>,<VAR>param</VAR>,...)
</FONT></PRE>
<P><FONT class=extract>When <CODE>make</CODE> expands this function, it assigns each <VAR>param</VAR> to temporary variables <CODE>$(1)</CODE>, <CODE>$(2)</CODE>, etc. The variable <CODE>$(0)</CODE> will contain <VAR>variable</VAR>. There is no maximum number of parameter arguments. There is no minimum, either, but it doesn't make sense to use <CODE>call</CODE> with no parameters. </FONT>
<P><FONT class=extract>Then <VAR>variable</VAR> is expanded as a <CODE>make</CODE> variable in the context of these temporary assignments. Thus, any reference to <CODE>$(1)</CODE> in the value of <VAR>variable</VAR> will resolve to the first <VAR>param</VAR> in the invocation of <CODE>call</CODE>. </FONT>
<P><FONT class=extract>Note that <VAR>variable</VAR> is the <EM>name</EM> of a variable, not a <EM>reference</EM> to that variable. Therefore you would not normally use a &#8216;<SAMP><SPAN class=samp>$</SPAN></SAMP>&#8217; or parentheses when writing it. (You can, however, use a variable reference in the name if you want the name not to be a constant.) </FONT>
<P><FONT class=extract>If <VAR>variable</VAR> is the name of a built-in function, the built-in function is always invoked (even if a <CODE>make</CODE> variable by that name also exists). </FONT>
<P><FONT class=extract>The <CODE>call</CODE> function expands the <VAR>param</VAR> arguments before assigning them to temporary variables. This means that <VAR>variable</VAR> values containing references to built-in functions that have special expansion rules, like <CODE>foreach</CODE> or <CODE>if</CODE>, may not work as you expect. </FONT>
<P><FONT class=extract>Some examples may make this clearer. </FONT>
<P><FONT class=extract>This macro simply reverses its arguments: </FONT><PRE class=smallexample><FONT class=extract>     reverse = $(2) $(1)
     
     foo = $(call reverse,a,b)
</FONT></PRE>
<P class=noindent><FONT class=extract>Here <VAR>foo</VAR> will contain &#8216;<SAMP><SPAN class=samp>b a</SPAN></SAMP>&#8217;. </FONT>
<P><FONT class=extract>This one is slightly more interesting: it defines a macro to search for the first instance of a program in <CODE>PATH</CODE>: </FONT><PRE class=smallexample><FONT class=extract>     pathsearch = $(firstword $(wildcard $(addsuffix /$(1),$(subst :, ,$(PATH)))))
     
     LS := $(call pathsearch,ls)
</FONT></PRE>
<P class=noindent><FONT class=extract>Now the variable LS contains <CODE>/bin/ls</CODE> or similar. </FONT>
<P><FONT class=extract>The <CODE>call</CODE> function can be nested. Each recursive invocation gets its own local values for <CODE>$(1)</CODE>, etc. that mask the values of higher-level <CODE>call</CODE>. For example, here is an implementation of a <DFN>map</DFN> function: </FONT><PRE class=smallexample><FONT class=extract>     map = $(foreach a,$(2),$(call $(1),$(a)))
</FONT></PRE>
<P><FONT class=extract>Now you can <VAR>map</VAR> a function that normally takes only one argument, such as <CODE>origin</CODE>, to multiple values in one step: </FONT><PRE class=smallexample><FONT class=extract>     o = $(call map,origin,o map MAKE)
</FONT></PRE>
<P><FONT class=extract>and end up with <VAR>o</VAR> containing something like &#8216;<SAMP><SPAN class=samp>file file default</SPAN></SAMP>&#8217;. </FONT>
<P><FONT class=extract>A final caution: be careful when adding whitespace to the arguments to <CODE>call</CODE>. As with other functions, any whitespace contained in the second and subsequent arguments is kept; this can cause strange effects. It's generally safest to remove all extraneous whitespace when providing parameters to <CODE>call</CODE>. </FONT>
<DIV class=node><A name=Value-Function></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Eval-Function" rel=next>Eval Function</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Call-Function" rel=previous>Call Function</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV><!-- node-name,  next,  previous,  up -->
<H3 class=section><FONT class=extract>8.8 The <CODE>value</CODE> Function</FONT></H3>
<P><A name=index-value-654></A><A name=index-variables_002c-unexpanded-value-655></A><FONT class=extract>The <CODE>value</CODE> function provides a way for you to use the value of a variable <EM>without</EM> having it expanded. Please note that this does not undo expansions which have already occurred; for example if you create a simply expanded variable its value is expanded during the definition; in that case the <CODE>value</CODE> function will return the same result as using the variable directly. </FONT>
<P><FONT class=extract>The syntax of the <CODE>value</CODE> function is: </FONT><PRE class=example><FONT class=extract>     $(value <VAR>variable</VAR>)
</FONT></PRE>
<P><FONT class=extract>Note that <VAR>variable</VAR> is the <EM>name</EM> of a variable, not a <EM>reference</EM> to that variable. Therefore you would not normally use a &#8216;<SAMP><SPAN class=samp>$</SPAN></SAMP>&#8217; or parentheses when writing it. (You can, however, use a variable reference in the name if you want the name not to be a constant.) </FONT>
<P><FONT class=extract>The result of this function is a string containing the value of <VAR>variable</VAR>, without any expansion occurring. For example, in this makefile: </FONT><PRE class=example><FONT class=extract>     FOO = $PATH
     
     all:
             @echo $(FOO)
             @echo $(value FOO)
</FONT></PRE>
<P class=noindent><FONT class=extract>The first output line would be <CODE>ATH</CODE>, since the &#8220;$P&#8221; would be expanded as a <CODE>make</CODE> variable, while the second output line would be the current value of your <CODE>$PATH</CODE> environment variable, since the <CODE>value</CODE> function avoided the expansion. </FONT>
<P><FONT class=extract>The <CODE>value</CODE> function is most often used in conjunction with the <CODE>eval</CODE> function (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Eval-Function"><FONT class=extract>Eval Function</FONT></A><FONT class=extract>). </FONT>
<DIV class=node><A name=Eval-Function></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Origin-Function" rel=next>Origin Function</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Value-Function" rel=previous>Value Function</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV><!-- node-name,  next,  previous,  up -->
<H3 class=section><FONT class=extract>8.9 The <CODE>eval</CODE> Function</FONT></H3>
<P><A name=index-eval-656></A><A name=index-evaluating-makefile-syntax-657></A><A name=index-makefile-syntax_002c-evaluating-658></A><FONT class=extract>The <CODE>eval</CODE> function is very special: it allows you to define new makefile constructs that are not constant; which are the result of evaluating other variables and functions. The argument to the <CODE>eval</CODE> function is expanded, then the results of that expansion are parsed as makefile syntax. The expanded results can define new <CODE>make</CODE> variables, targets, implicit or explicit rules, etc. </FONT>
<P><FONT class=extract>The result of the <CODE>eval</CODE> function is always the empty string; thus, it can be placed virtually anywhere in a makefile without causing syntax errors. </FONT>
<P><FONT class=extract>It's important to realize that the <CODE>eval</CODE> argument is expanded <EM>twice</EM>; first by the <CODE>eval</CODE> function, then the results of that expansion are expanded again when they are parsed as makefile syntax. This means you may need to provide extra levels of escaping for &#8220;$&#8221; characters when using <CODE>eval</CODE>. The <CODE>value</CODE> function (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Value-Function"><FONT class=extract>Value Function</FONT></A><FONT class=extract>) can sometimes be useful in these situations, to circumvent unwanted expansions. </FONT>
<P><FONT class=extract>Here is an example of how <CODE>eval</CODE> can be used; this example combines a number of concepts and other functions. Although it might seem overly complex to use <CODE>eval</CODE> in this example, rather than just writing out the rules, consider two things: first, the template definition (in <CODE>PROGRAM_template</CODE>) could need to be much more complex than it is here; and second, you might put the complex, &#8220;generic&#8221; part of this example into another makefile, then include it in all the individual makefiles. Now your individual makefiles are quite straightforward. </FONT><PRE class=example><FONT class=extract>     PROGRAMS    = server client
     
     server_OBJS = server.o server_priv.o server_access.o
     server_LIBS = priv protocol
     
     client_OBJS = client.o client_api.o client_mem.o
     client_LIBS = protocol
     
     # Everything after this is generic
     
     .PHONY: all
     all: $(PROGRAMS)
     
     define PROGRAM_template =
      $(1): $$($(1)_OBJS) $$($(1)_LIBS:%=-l%)
      ALL_OBJS   += $$($(1)_OBJS)
     endef
     
     $(foreach prog,$(PROGRAMS),$(eval $(call PROGRAM_template,$(prog))))
     
     $(PROGRAMS):
             $(LINK.o) $^ $(LDLIBS) -o $@
     
     clean:
             rm -f $(ALL_OBJS) $(PROGRAMS)</FONT>
</PRE>
<DIV class=node><A name=Origin-Function></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Flavor-Function" rel=next>Flavor Function</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Eval-Function" rel=previous>Eval Function</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV>
<H3 class=section><FONT class=extract>8.10 The <CODE>origin</CODE> Function</FONT></H3>
<P><A name=index-origin-659></A><A name=index-variables_002c-origin-of-660></A><A name=index-origin-of-variable-661></A><FONT class=extract>The <CODE>origin</CODE> function is unlike most other functions in that it does not operate on the values of variables; it tells you something <EM>about</EM> a variable. Specifically, it tells you where it came from. </FONT>
<P><FONT class=extract>The syntax of the <CODE>origin</CODE> function is: </FONT><PRE class=example><FONT class=extract>     $(origin <VAR>variable</VAR>)
</FONT></PRE>
<P><FONT class=extract>Note that <VAR>variable</VAR> is the <EM>name</EM> of a variable to inquire about, not a <EM>reference</EM> to that variable. Therefore you would not normally use a &#8216;<SAMP><SPAN class=samp>$</SPAN></SAMP>&#8217; or parentheses when writing it. (You can, however, use a variable reference in the name if you want the name not to be a constant.) </FONT>
<P><FONT class=extract>The result of this function is a string telling you how the variable <VAR>variable</VAR> was defined: </FONT>
<DL>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>undefined</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>if <VAR>variable</VAR> was never defined. <BR></FONT>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>default</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>if <VAR>variable</VAR> has a default definition, as is usual with <CODE>CC</CODE> and so on. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Variables"><FONT class=extract>Variables Used by Implicit Rules</FONT></A><FONT class=extract>. Note that if you have redefined a default variable, the <CODE>origin</CODE> function will return the origin of the later definition. <BR></FONT>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>environment</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>if <VAR>variable</VAR> was inherited from the environment provided to <CODE>make</CODE>. <BR></FONT>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>environment override</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>if <VAR>variable</VAR> was inherited from the environment provided to <CODE>make</CODE>, and is overriding a setting for <VAR>variable</VAR> in the makefile as a result of the &#8216;<SAMP><SPAN class=samp>-e</SPAN></SAMP>&#8217;<!-- /@w --> option (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Options-Summary"><FONT class=extract>Summary of Options</FONT></A><FONT class=extract>). <BR></FONT>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>file</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>if <VAR>variable</VAR> was defined in a makefile. <BR></FONT>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>command line</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>if <VAR>variable</VAR> was defined on the command line. <BR></FONT>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>override</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>if <VAR>variable</VAR> was defined with an <CODE>override</CODE> directive in a makefile (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Override-Directive"><FONT class=extract>The <CODE>override</CODE> Directive</FONT></A><FONT class=extract>). <BR></FONT>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>automatic</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>if <VAR>variable</VAR> is an automatic variable defined for the execution of the recipe for each rule (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables"><FONT class=extract>Automatic Variables</FONT></A><FONT class=extract>). </FONT></DD></DL>
<P><FONT class=extract>This information is primarily useful (other than for your curiosity) to determine if you want to believe the value of a variable. For example, suppose you have a makefile <SAMP><SPAN class=file>foo</SPAN></SAMP> that includes another makefile <SAMP><SPAN class=file>bar</SPAN></SAMP>. You want a variable <CODE>bletch</CODE> to be defined in <SAMP><SPAN class=file>bar</SPAN></SAMP> if you run the command &#8216;<SAMP><SPAN class=samp>make&nbsp;-f&nbsp;bar</SPAN></SAMP>&#8217;<!-- /@w -->, even if the environment contains a definition of <CODE>bletch</CODE>. However, if <SAMP><SPAN class=file>foo</SPAN></SAMP> defined <CODE>bletch</CODE> before including <SAMP><SPAN class=file>bar</SPAN></SAMP>, you do not want to override that definition. This could be done by using an <CODE>override</CODE> directive in <SAMP><SPAN class=file>foo</SPAN></SAMP>, giving that definition precedence over the later definition in <SAMP><SPAN class=file>bar</SPAN></SAMP>; unfortunately, the <CODE>override</CODE> directive would also override any command line definitions. So, <SAMP><SPAN class=file>bar</SPAN></SAMP> could include: </FONT><PRE class=example><FONT class=extract>     ifdef bletch
     ifeq "$(origin bletch)" "environment"
     bletch = barf, gag, etc.
     endif
     endif
</FONT></PRE>
<P class=noindent><FONT class=extract>If <CODE>bletch</CODE> has been defined from the environment, this will redefine it. </FONT>
<P><FONT class=extract>If you want to override a previous definition of <CODE>bletch</CODE> if it came from the environment, even under &#8216;<SAMP><SPAN class=samp>-e</SPAN></SAMP>&#8217;, you could instead write: </FONT><PRE class=example><FONT class=extract>     ifneq "$(findstring environment,$(origin bletch))" ""
     bletch = barf, gag, etc.
     endif
</FONT></PRE>
<P><FONT class=extract>Here the redefinition takes place if &#8216;<SAMP><SPAN class=samp>$(origin bletch)</SPAN></SAMP>&#8217; returns either &#8216;<SAMP><SPAN class=samp>environment</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>environment override</SPAN></SAMP>&#8217;. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Text-Functions"><FONT class=extract>Functions for String Substitution and Analysis</FONT></A><FONT class=extract>. </FONT>
<DIV class=node><A name=Flavor-Function></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Make-Control-Functions" rel=next>Make Control Functions</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Origin-Function" rel=previous>Origin Function</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV>
<H3 class=section><FONT class=extract>8.11 The <CODE>flavor</CODE> Function</FONT></H3>
<P><A name=index-flavor-662></A><A name=index-variables_002c-flavor-of-663></A><A name=index-flavor-of-variable-664></A><FONT class=extract>The <CODE>flavor</CODE> function, like the <CODE>origin</CODE> function, does not operate on the values of variables but rather it tells you something <EM>about</EM> a variable. Specifically, it tells you the flavor of a variable (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Flavors"><FONT class=extract>The Two Flavors of Variables</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>The syntax of the <CODE>flavor</CODE> function is: </FONT><PRE class=example><FONT class=extract>     $(flavor <VAR>variable</VAR>)
</FONT></PRE>
<P><FONT class=extract>Note that <VAR>variable</VAR> is the <EM>name</EM> of a variable to inquire about, not a <EM>reference</EM> to that variable. Therefore you would not normally use a &#8216;<SAMP><SPAN class=samp>$</SPAN></SAMP>&#8217; or parentheses when writing it. (You can, however, use a variable reference in the name if you want the name not to be a constant.) </FONT>
<P><FONT class=extract>The result of this function is a string that identifies the flavor of the variable <VAR>variable</VAR>: </FONT>
<DL>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>undefined</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>if <VAR>variable</VAR> was never defined. <BR></FONT>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>recursive</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>if <VAR>variable</VAR> is a recursively expanded variable. <BR></FONT>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>simple</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>if <VAR>variable</VAR> is a simply expanded variable. </FONT></DD></DL>
<DIV class=node><A name=Make-Control-Functions></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Shell-Function" rel=next>Shell Function</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Flavor-Function" rel=previous>Flavor Function</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV>
<H3 class=section><FONT class=extract>8.12 Functions That Control Make</FONT></H3>
<P><A name=index-functions_002c-for-controlling-make-665></A><A name=index-controlling-make-666></A><FONT class=extract>These functions control the way make runs. Generally, they are used to provide information to the user of the makefile or to cause make to stop if some sort of environmental error is detected. </FONT>
<DL>
<DT><FONT class=extract><CODE>$(error </CODE><VAR>text</VAR><CODE>...)</CODE> </FONT>
<DD><A name=index-error-667></A><A name=index-error_002c-stopping-on-668></A><A name=index-stopping-make-669></A><FONT class=extract>Generates a fatal error where the message is <VAR>text</VAR>. Note that the error is generated whenever this function is evaluated. So, if you put it inside a recipe or on the right side of a recursive variable assignment, it won't be evaluated until later. The <VAR>text</VAR> will be expanded before the error is generated. </FONT>
<P><FONT class=extract>For example, </FONT><PRE class=example><FONT class=extract>          ifdef ERROR1
          $(error error is $(ERROR1))
          endif
</FONT></PRE>
<P class=noindent><FONT class=extract>will generate a fatal error during the read of the makefile if the <CODE>make</CODE> variable <CODE>ERROR1</CODE> is defined. Or, </FONT><PRE class=example><FONT class=extract>          ERR = $(error found an error!)
          
          .PHONY: err
          err: ; $(ERR)
</FONT></PRE>
<P class=noindent><FONT class=extract>will generate a fatal error while <CODE>make</CODE> is running, if the <CODE>err</CODE> target is invoked. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(warning </CODE><VAR>text</VAR><CODE>...)</CODE> </FONT>
<DD><A name=index-warning-670></A><A name=index-warnings_002c-printing-671></A><A name=index-printing-user-warnings-672></A><FONT class=extract>This function works similarly to the <CODE>error</CODE> function, above, except that <CODE>make</CODE> doesn't exit. Instead, <VAR>text</VAR> is expanded and the resulting message is displayed, but processing of the makefile continues. </FONT>
<P><FONT class=extract>The result of the expansion of this function is the empty string. <BR></FONT></P>
<DT><FONT class=extract><CODE>$(info </CODE><VAR>text</VAR><CODE>...)</CODE> </FONT>
<DD><A name=index-info-673></A><A name=index-printing-messages-674></A><FONT class=extract>This function does nothing more than print its (expanded) argument(s) to standard output. No makefile name or line number is added. The result of the expansion of this function is the empty string. </FONT></DD></DL>
<DIV class=node><A name=Shell-Function></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Guile-Function" rel=next>Guile Function</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Make-Control-Functions" rel=previous>Make Control Functions</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV>
<H3 class=section><FONT class=extract>8.13 The <CODE>shell</CODE> Function</FONT></H3>
<P><A name=index-shell-675></A><A name=index-command-expansion-676></A><A name=index-backquotes-677></A><A name=index-shell-command_002c-function-for-678></A><FONT class=extract>The <CODE>shell</CODE> function is unlike any other function other than the <CODE>wildcard</CODE> function (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Wildcard-Function"><FONT class=extract>The Function <CODE>wildcard</CODE></FONT></A><FONT class=extract>) in that it communicates with the world outside of <CODE>make</CODE>. </FONT>
<P><FONT class=extract>The <CODE>shell</CODE> function performs the same function that backquotes (&#8216;<SAMP><SPAN class=samp>`</SPAN></SAMP>&#8217;) perform in most shells: it does <DFN>command expansion</DFN>. This means that it takes as an argument a shell command and evaluates to the output of the command. The only processing <CODE>make</CODE> does on the result is to convert each newline (or carriage-return / newline pair) to a single space. If there is a trailing (carriage-return and) newline it will simply be removed. </FONT>
<P><FONT class=extract>The commands run by calls to the <CODE>shell</CODE> function are run when the function calls are expanded (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Reading-Makefiles"><FONT class=extract>How <CODE>make</CODE> Reads a Makefile</FONT></A><FONT class=extract>). Because this function involves spawning a new shell, you should carefully consider the performance implications of using the <CODE>shell</CODE> function within recursively expanded variables vs. simply expanded variables (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Flavors"><FONT class=extract>The Two Flavors of Variables</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>Here are some examples of the use of the <CODE>shell</CODE> function: </FONT><PRE class=example><FONT class=extract>     contents := $(shell cat foo)
</FONT></PRE>
<P class=noindent><FONT class=extract>sets <CODE>contents</CODE> to the contents of the file <SAMP><SPAN class=file>foo</SPAN></SAMP>, with a space (rather than a newline) separating each line. </FONT><PRE class=example><FONT class=extract>     files := $(shell echo *.c)
</FONT></PRE>
<P class=noindent><FONT class=extract>sets <CODE>files</CODE> to the expansion of &#8216;<SAMP><SPAN class=samp>*.c</SPAN></SAMP>&#8217;. Unless <CODE>make</CODE> is using a very strange shell, this has the same result as &#8216;<SAMP><SPAN class=samp>$(wildcard&nbsp;*.c)</SPAN></SAMP>&#8217;<!-- /@w --> (as long as at least one &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; file exists).</FONT> 
<DIV class=node><A name=Guile-Function></A>
<P>
<HR>
Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Shell-Function" rel=previous>Shell Function</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Functions" rel=up>Functions</A> </DIV>
<H3 class=section><FONT class=extract>8.14 The <CODE>guile</CODE> Function</FONT></H3>
<P><A name=index-guile-679></A><A name=index-Guile-680></A><FONT class=extract>If GNU <CODE>make</CODE> is built with support for GNU Guile as an embedded extension language then the <CODE>guile</CODE> function will be available. The <CODE>guile</CODE> function takes one argument which is first expanded by <CODE>make</CODE> in the normal fashion, then passed to the GNU Guile evaluator. The result of the evaluator is converted into a string and used as the expansion of the <CODE>guile</CODE> function in the makefile. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Guile-Integration"><FONT class=extract>GNU Guile Integration</FONT></A><FONT class=extract> for details on writing extensions to <CODE>make</CODE> in Guile. </FONT>
<P><FONT class=extract>You can determine whether GNU Guile support is available by checking the <CODE>.FEATURES</CODE> variable for the word <VAR>guile</VAR>.</FONT>