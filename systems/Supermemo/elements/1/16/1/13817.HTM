<H2 class=chapter>10 Using Implicit Rules</H2>
<P><A name=index-implicit-rule-810></A><A name=index-rule_002c-implicit-811></A>Certain standard ways of remaking target files are used very often. For example, one customary way to make an object file is from a C source file using the C compiler, <CODE>cc</CODE>. 
<P><DFN>Implicit rules</DFN> tell <CODE>make</CODE> how to use customary techniques so that you do not have to specify them in detail when you want to use them. For example, there is an implicit rule for C compilation. File names determine which implicit rules are run. For example, C compilation typically takes a <SAMP><SPAN class=file>.c</SPAN></SAMP> file and makes a <SAMP><SPAN class=file>.o</SPAN></SAMP> file. So <CODE>make</CODE> applies the implicit rule for C compilation when it sees this combination of file name endings. 
<P>A chain of implicit rules can apply in sequence; for example, <CODE>make</CODE> will remake a <SAMP><SPAN class=file>.o</SPAN></SAMP> file from a <SAMP><SPAN class=file>.y</SPAN></SAMP> file by way of a <SAMP><SPAN class=file>.c</SPAN></SAMP> file. 
<P>The built-in implicit rules use several variables in their recipes so that, by changing the values of the variables, you can change the way the implicit rule works. For example, the variable <CODE>CFLAGS</CODE> controls the flags given to the C compiler by the implicit rule for C compilation. 
<P>You can define your own implicit rules by writing <DFN>pattern rules</DFN>. 
<P><DFN>Suffix rules</DFN> are a more limited way to define implicit rules. Pattern rules are more general and clearer, but suffix rules are retained for compatibility. 
<UL class=menu>
<LI><A accessKey=1 href="https://www.gnu.org/software/make/manual/make.html#Using-Implicit">Using Implicit</A>: How to use an existing implicit rule to get the recipes for updating a file. 
<LI><A accessKey=2 href="https://www.gnu.org/software/make/manual/make.html#Catalogue-of-Rules">Catalogue of Rules</A>: A list of built-in implicit rules. 
<LI><A accessKey=3 href="https://www.gnu.org/software/make/manual/make.html#Implicit-Variables">Implicit Variables</A>: How to change what predefined rules do. 
<LI><A accessKey=4 href="https://www.gnu.org/software/make/manual/make.html#Chained-Rules">Chained Rules</A>: How to use a chain of implicit rules. 
<LI><A accessKey=5 href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules">Pattern Rules</A>: How to define new implicit rules. 
<LI><A accessKey=6 href="https://www.gnu.org/software/make/manual/make.html#Last-Resort">Last Resort</A>: How to define a recipe for rules which cannot find any. 
<LI><A accessKey=7 href="https://www.gnu.org/software/make/manual/make.html#Suffix-Rules">Suffix Rules</A>: The old-fashioned style of implicit rule. 
<LI><A accessKey=8 href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rule-Search">Implicit Rule Search</A>: The precise algorithm for applying implicit rules. </LI></UL>
<DIV class=node><A name=Using-Implicit></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Catalogue-of-Rules" rel=next>Catalogue of Rules</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules" rel=previous>Implicit Rules</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules" rel=up>Implicit Rules</A> </DIV>
<H3 class=section><FONT class=extract>10.1 Using Implicit Rules</FONT></H3>
<P><A name=index-implicit-rule_002c-how-to-use-812></A><A name=index-rule_002c-implicit_002c-how-to-use-813></A><FONT class=extract>To allow <CODE>make</CODE> to find a customary method for updating a target file, all you have to do is refrain from specifying recipes yourself. Either write a rule with no recipe, or don't write a rule at all. Then <CODE>make</CODE> will figure out which implicit rule to use based on which kind of source file exists or can be made. </FONT>
<P><FONT class=extract>For example, suppose the makefile looks like this: </FONT><PRE class=example><FONT class=extract>     foo : foo.o bar.o
             cc -o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
</FONT></PRE>
<P class=noindent><FONT class=extract>Because you mention <SAMP><SPAN class=file>foo.o</SPAN></SAMP> but do not give a rule for it, <CODE>make</CODE> will automatically look for an implicit rule that tells how to update it. This happens whether or not the file <SAMP><SPAN class=file>foo.o</SPAN></SAMP> currently exists. </FONT>
<P><FONT class=extract>If an implicit rule is found, it can supply both a recipe and one or more prerequisites (the source files). You would want to write a rule for <SAMP><SPAN class=file>foo.o</SPAN></SAMP> with no recipe if you need to specify additional prerequisites, such as header files, that the implicit rule cannot supply. </FONT>
<P><FONT class=extract>Each implicit rule has a target pattern and prerequisite patterns. There may be many implicit rules with the same target pattern. For example, numerous rules make &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; files: one, from a &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; file with the C compiler; another, from a &#8216;<SAMP><SPAN class=samp>.p</SPAN></SAMP>&#8217; file with the Pascal compiler; and so on. The rule that actually applies is the one whose prerequisites exist or can be made. So, if you have a file <SAMP><SPAN class=file>foo.c</SPAN></SAMP>, <CODE>make</CODE> will run the C compiler; otherwise, if you have a file <SAMP><SPAN class=file>foo.p</SPAN></SAMP>, <CODE>make</CODE> will run the Pascal compiler; and so on. </FONT>
<P><FONT class=extract>Of course, when you write the makefile, you know which implicit rule you want <CODE>make</CODE> to use, and you know it will choose that one because you know which possible prerequisite files are supposed to exist. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Catalogue-of-Rules"><FONT class=extract>Catalogue of Implicit Rules</FONT></A><FONT class=extract>, for a catalogue of all the predefined implicit rules. </FONT>
<P><FONT class=extract>Above, we said an implicit rule applies if the required prerequisites &#8220;exist or can be made&#8221;. A file &#8220;can be made&#8221; if it is mentioned explicitly in the makefile as a target or a prerequisite, or if an implicit rule can be recursively found for how to make it. When an implicit prerequisite is the result of another implicit rule, we say that <DFN>chaining</DFN> is occurring. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Chained-Rules"><FONT class=extract>Chains of Implicit Rules</FONT></A><FONT class=extract>. </FONT>
<P><FONT class=extract>In general, <CODE>make</CODE> searches for an implicit rule for each target, and for each double-colon rule, that has no recipe. A file that is mentioned only as a prerequisite is considered a target whose rule specifies nothing, so implicit rule search happens for it. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rule-Search"><FONT class=extract>Implicit Rule Search Algorithm</FONT></A><FONT class=extract>, for the details of how the search is done. </FONT>
<P><FONT class=extract>Note that explicit prerequisites do not influence implicit rule search. For example, consider this explicit rule: </FONT><PRE class=example><FONT class=extract>     foo.o: foo.p
</FONT></PRE>
<P class=noindent><FONT class=extract>The prerequisite on <SAMP><SPAN class=file>foo.p</SPAN></SAMP> does not necessarily mean that <CODE>make</CODE> will remake <SAMP><SPAN class=file>foo.o</SPAN></SAMP> according to the implicit rule to make an object file, a <SAMP><SPAN class=file>.o</SPAN></SAMP> file, from a Pascal source file, a <SAMP><SPAN class=file>.p</SPAN></SAMP> file. For example, if <SAMP><SPAN class=file>foo.c</SPAN></SAMP> also exists, the implicit rule to make an object file from a C source file is used instead, because it appears before the Pascal rule in the list of predefined implicit rules (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Catalogue-of-Rules"><FONT class=extract>Catalogue of Implicit Rules</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>If you do not want an implicit rule to be used for a target that has no recipe, you can give that target an empty recipe by writing a semicolon (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Empty-Recipes"><FONT class=extract>Defining Empty Recipes</FONT></A><FONT class=extract>). </FONT>
<DIV class=node><A name=Catalogue-of-Rules></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Implicit-Variables" rel=next>Implicit Variables</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Using-Implicit" rel=previous>Using Implicit</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules" rel=up>Implicit Rules</A> </DIV>
<H3 class=section><FONT class=extract>10.2 Catalogue of Implicit Rules</FONT></H3>
<P><A name=index-implicit-rule_002c-predefined-814></A><A name=index-rule_002c-implicit_002c-predefined-815></A><FONT class=extract>Here is a catalogue of predefined implicit rules which are always available unless the makefile explicitly overrides or cancels them. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Canceling-Rules"><FONT class=extract>Canceling Implicit Rules</FONT></A><FONT class=extract>, for information on canceling or overriding an implicit rule. The &#8216;<SAMP><SPAN class=samp>-r</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>--no-builtin-rules</SPAN></SAMP>&#8217; option cancels all predefined rules. </FONT>
<P><FONT class=extract>This manual only documents the default rules available on POSIX-based operating systems. Other operating systems, such as VMS, Windows, OS/2, etc. may have different sets of default rules. To see the full list of default rules and variables available in your version of GNU <CODE>make</CODE>, run &#8216;<SAMP><SPAN class=samp>make -p</SPAN></SAMP>&#8217; in a directory with no makefile. </FONT>
<P><FONT class=extract>Not all of these rules will always be defined, even when the &#8216;<SAMP><SPAN class=samp>-r</SPAN></SAMP>&#8217; option is not given. Many of the predefined implicit rules are implemented in <CODE>make</CODE> as suffix rules, so which ones will be defined depends on the <DFN>suffix list</DFN> (the list of prerequisites of the special target <CODE>.SUFFIXES</CODE>). The default suffix list is: <CODE>.out</CODE>, <CODE>.a</CODE>, <CODE>.ln</CODE>, <CODE>.o</CODE>, <CODE>.c</CODE>, <CODE>.cc</CODE>, <CODE>.C</CODE>, <CODE>.cpp</CODE>, <CODE>.p</CODE>, <CODE>.f</CODE>, <CODE>.F</CODE>, <CODE>.m</CODE>, <CODE>.r</CODE>, <CODE>.y</CODE>, <CODE>.l</CODE>, <CODE>.ym</CODE>, <CODE>.lm</CODE>, <CODE>.s</CODE>, <CODE>.S</CODE>, <CODE>.mod</CODE>, <CODE>.sym</CODE>, <CODE>.def</CODE>, <CODE>.h</CODE>, <CODE>.info</CODE>, <CODE>.dvi</CODE>, <CODE>.tex</CODE>, <CODE>.texinfo</CODE>, <CODE>.texi</CODE>, <CODE>.txinfo</CODE>, <CODE>.w</CODE>, <CODE>.ch</CODE> <CODE>.web</CODE>, <CODE>.sh</CODE>, <CODE>.elc</CODE>, <CODE>.el</CODE>. All of the implicit rules described below whose prerequisites have one of these suffixes are actually suffix rules. If you modify the suffix list, the only predefined suffix rules in effect will be those named by one or two of the suffixes that are on the list you specify; rules whose suffixes fail to be on the list are disabled. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Suffix-Rules"><FONT class=extract>Old-Fashioned Suffix Rules</FONT></A><FONT class=extract>, for full details on suffix rules. </FONT>
<DL>
<DT><FONT class=extract>Compiling C programs </FONT>
<DD><A name=index-C_002c-rule-to-compile-816></A><A name=index-cc-817></A><A name=index-gcc-818></A><A name=index-g_t_002eo-819></A><A name=index-g_t_002ec-820></A><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> is made automatically from <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> with a recipe of the form &#8216;<SAMP><SPAN class=samp>$(CC) $(CPPFLAGS) $(CFLAGS) -c</SPAN></SAMP>&#8217;. <BR></FONT>
<DT><FONT class=extract>Compiling C++ programs </FONT>
<DD><A name=index-C_002b_002b_002c-rule-to-compile-821></A><A name=index-g_002b_002b-822></A><A name=index-g_t_002ecc-823></A><A name=index-g_t_002ecpp-824></A><A name=index-g_t_002eC-825></A><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> is made automatically from <SAMP><VAR>n</VAR><SPAN class=file>.cc</SPAN></SAMP>, <SAMP><VAR>n</VAR><SPAN class=file>.cpp</SPAN></SAMP>, or <SAMP><VAR>n</VAR><SPAN class=file>.C</SPAN></SAMP> with a recipe of the form &#8216;<SAMP><SPAN class=samp>$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c</SPAN></SAMP>&#8217;. We encourage you to use the suffix &#8216;<SAMP><SPAN class=samp>.cc</SPAN></SAMP>&#8217; for C++ source files instead of &#8216;<SAMP><SPAN class=samp>.C</SPAN></SAMP>&#8217;. <BR></FONT>
<DT><FONT class=extract>Compiling Pascal programs </FONT>
<DD><A name=index-Pascal_002c-rule-to-compile-826></A><A name=index-pc-827></A><A name=index-g_t_002ep-828></A><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> is made automatically from <SAMP><VAR>n</VAR><SPAN class=file>.p</SPAN></SAMP> with the recipe &#8216;<SAMP><SPAN class=samp>$(PC) $(PFLAGS) -c</SPAN></SAMP>&#8217;. <BR></FONT>
<DT><FONT class=extract>Compiling Fortran and Ratfor programs </FONT>
<DD><A name=index-Fortran_002c-rule-to-compile-829></A><A name=index-Ratfor_002c-rule-to-compile-830></A><A name=index-f77-831></A><A name=index-g_t_002ef-832></A><A name=index-g_t_002er-833></A><A name=index-g_t_002eF-834></A><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> is made automatically from <SAMP><VAR>n</VAR><SPAN class=file>.r</SPAN></SAMP>, <SAMP><VAR>n</VAR><SPAN class=file>.F</SPAN></SAMP> or <SAMP><VAR>n</VAR><SPAN class=file>.f</SPAN></SAMP> by running the Fortran compiler. The precise recipe used is as follows: </FONT>
<DL>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>.f</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(FC) $(FFLAGS) -c</SPAN></SAMP>&#8217;. <BR></FONT>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>.F</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(FC) $(FFLAGS) $(CPPFLAGS) -c</SPAN></SAMP>&#8217;. <BR></FONT>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>.r</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(FC) $(FFLAGS) $(RFLAGS) -c</SPAN></SAMP>&#8217;. </FONT></DD></DL><BR>
<DT><FONT class=extract>Preprocessing Fortran and Ratfor programs </FONT>
<DD><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.f</SPAN></SAMP> is made automatically from <SAMP><VAR>n</VAR><SPAN class=file>.r</SPAN></SAMP> or <SAMP><VAR>n</VAR><SPAN class=file>.F</SPAN></SAMP>. This rule runs just the preprocessor to convert a Ratfor or preprocessable Fortran program into a strict Fortran program. The precise recipe used is as follows: </FONT>
<DL>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>.F</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(FC) $(CPPFLAGS) $(FFLAGS) -F</SPAN></SAMP>&#8217;. <BR></FONT>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>.r</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(FC) $(FFLAGS) $(RFLAGS) -F</SPAN></SAMP>&#8217;. </FONT></DD></DL><BR>
<DT><FONT class=extract>Compiling Modula-2 programs </FONT>
<DD><A name=index-Modula_002d2_002c-rule-to-compile-835></A><A name=index-m2c-836></A><A name=index-g_t_002esym-837></A><A name=index-g_t_002edef-838></A><A name=index-g_t_002emod-839></A><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.sym</SPAN></SAMP> is made from <SAMP><VAR>n</VAR><SPAN class=file>.def</SPAN></SAMP> with a recipe of the form &#8216;<SAMP><SPAN class=samp>$(M2C) $(M2FLAGS) $(DEFFLAGS)</SPAN></SAMP>&#8217;. <SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> is made from <SAMP><VAR>n</VAR><SPAN class=file>.mod</SPAN></SAMP>; the form is: &#8216;<SAMP><SPAN class=samp>$(M2C)&nbsp;$(M2FLAGS)&nbsp;$(MODFLAGS)</SPAN></SAMP>&#8217;<!-- /@w -->. <BR></FONT>
<DT><FONT class=extract>Assembling and preprocessing assembler programs </FONT>
<DD><A name=index-assembly_002c-rule-to-compile-840></A><A name=index-as-841></A><A name=index-g_t_002es-842></A><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> is made automatically from <SAMP><VAR>n</VAR><SPAN class=file>.s</SPAN></SAMP> by running the assembler, <CODE>as</CODE>. The precise recipe is &#8216;<SAMP><SPAN class=samp>$(AS) $(ASFLAGS)</SPAN></SAMP>&#8217;. </FONT>
<P><A name=index-g_t_002eS-843></A><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.s</SPAN></SAMP> is made automatically from <SAMP><VAR>n</VAR><SPAN class=file>.S</SPAN></SAMP> by running the C preprocessor, <CODE>cpp</CODE>. The precise recipe is &#8216;<SAMP><SPAN class=samp>$(CPP)&nbsp;$(CPPFLAGS)</SPAN></SAMP>&#8217;<!-- /@w -->. <BR></FONT></P>
<DT><FONT class=extract>Linking a single object file </FONT>
<DD><A name=index-linking_002c-predefined-rule-for-844></A><A name=index-ld-845></A><A name=index-g_t_002eo-846></A><FONT class=extract><SAMP><VAR>n</VAR></SAMP> is made automatically from <SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> by running the linker (usually called <CODE>ld</CODE>) via the C compiler. The precise recipe used is &#8216;<SAMP><SPAN class=samp>$(CC)&nbsp;$(LDFLAGS)&nbsp;</SPAN><VAR>n</VAR><SPAN class=samp>.o&nbsp;$(LOADLIBES)&nbsp;$(LDLIBS)</SPAN></SAMP>&#8217;<!-- /@w -->. </FONT>
<P><FONT class=extract>This rule does the right thing for a simple program with only one source file. It will also do the right thing if there are multiple object files (presumably coming from various other source files), one of which has a name matching that of the executable file. Thus, </FONT><PRE class=example><FONT class=extract>          x: y.o z.o
</FONT></PRE>
<P class=noindent><FONT class=extract>when <SAMP><SPAN class=file>x.c</SPAN></SAMP>, <SAMP><SPAN class=file>y.c</SPAN></SAMP> and <SAMP><SPAN class=file>z.c</SPAN></SAMP> all exist will execute: </FONT><PRE class=example><FONT class=extract>          cc -c x.c -o x.o
          cc -c y.c -o y.o
          cc -c z.c -o z.o
          cc x.o y.o z.o -o x
          rm -f x.o
          rm -f y.o
          rm -f z.o
</FONT></PRE>
<P class=noindent><FONT class=extract>In more complicated cases, such as when there is no object file whose name derives from the executable file name, you must write an explicit recipe for linking. </FONT>
<P><FONT class=extract>Each kind of file automatically made into &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; object files will be automatically linked by using the compiler (&#8216;<SAMP><SPAN class=samp>$(CC)</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>$(FC)</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>$(PC)</SPAN></SAMP>&#8217;; the C compiler &#8216;<SAMP><SPAN class=samp>$(CC)</SPAN></SAMP>&#8217; is used to assemble &#8216;<SAMP><SPAN class=samp>.s</SPAN></SAMP>&#8217; files) without the &#8216;<SAMP><SPAN class=samp>-c</SPAN></SAMP>&#8217; option. This could be done by using the &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; object files as intermediates, but it is faster to do the compiling and linking in one step, so that's how it's done. <BR></FONT></P>
<DT><FONT class=extract>Yacc for C programs </FONT>
<DD><A name=index-yacc-847></A><A name=index-Yacc_002c-rule-to-run-848></A><A name=index-g_t_002ey-849></A><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> is made automatically from <SAMP><VAR>n</VAR><SPAN class=file>.y</SPAN></SAMP> by running Yacc with the recipe &#8216;<SAMP><SPAN class=samp>$(YACC) $(YFLAGS)</SPAN></SAMP>&#8217;. <BR></FONT>
<DT><FONT class=extract>Lex for C programs </FONT>
<DD><A name=index-lex-850></A><A name=index-Lex_002c-rule-to-run-851></A><A name=index-g_t_002el-852></A><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> is made automatically from <SAMP><VAR>n</VAR><SPAN class=file>.l</SPAN></SAMP> by running Lex. The actual recipe is &#8216;<SAMP><SPAN class=samp>$(LEX) $(LFLAGS)</SPAN></SAMP>&#8217;. <BR></FONT>
<DT><FONT class=extract>Lex for Ratfor programs </FONT>
<DD><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.r</SPAN></SAMP> is made automatically from <SAMP><VAR>n</VAR><SPAN class=file>.l</SPAN></SAMP> by running Lex. The actual recipe is &#8216;<SAMP><SPAN class=samp>$(LEX) $(LFLAGS)</SPAN></SAMP>&#8217;. </FONT>
<P><FONT class=extract>The convention of using the same suffix &#8216;<SAMP><SPAN class=samp>.l</SPAN></SAMP>&#8217; for all Lex files regardless of whether they produce C code or Ratfor code makes it impossible for <CODE>make</CODE> to determine automatically which of the two languages you are using in any particular case. If <CODE>make</CODE> is called upon to remake an object file from a &#8216;<SAMP><SPAN class=samp>.l</SPAN></SAMP>&#8217; file, it must guess which compiler to use. It will guess the C compiler, because that is more common. If you are using Ratfor, make sure <CODE>make</CODE> knows this by mentioning <SAMP><VAR>n</VAR><SPAN class=file>.r</SPAN></SAMP> in the makefile. Or, if you are using Ratfor exclusively, with no C files, remove &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; from the list of implicit rule suffixes with: </FONT><PRE class=example><FONT class=extract>          .SUFFIXES:
          .SUFFIXES: .o .r .f .l ...
</FONT></PRE><BR>
<DT><FONT class=extract>Making Lint Libraries from C, Yacc, or Lex programs </FONT>
<DD><A name=index-lint-853></A><A name=index-g_t_0040code_007blint_007d_002c-rule-to-run-854></A><A name=index-g_t_002eln-855></A><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.ln</SPAN></SAMP> is made from <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> by running <CODE>lint</CODE>. The precise recipe is &#8216;<SAMP><SPAN class=samp>$(LINT)&nbsp;$(LINTFLAGS)&nbsp;$(CPPFLAGS)&nbsp;-i</SPAN></SAMP>&#8217;<!-- /@w -->. The same recipe is used on the C code produced from <SAMP><VAR>n</VAR><SPAN class=file>.y</SPAN></SAMP> or <SAMP><VAR>n</VAR><SPAN class=file>.l</SPAN></SAMP>. <BR></FONT>
<DT><FONT class=extract>TeX and Web </FONT>
<DD><A name=index-g_t_0040TeX_007b_007d_002c-rule-to-run-856></A><A name=index-Web_002c-rule-to-run-857></A><A name=index-tex-858></A><A name=index-cweave-859></A><A name=index-weave-860></A><A name=index-tangle-861></A><A name=index-ctangle-862></A><A name=index-g_t_002edvi-863></A><A name=index-g_t_002etex-864></A><A name=index-g_t_002eweb-865></A><A name=index-g_t_002ew-866></A><A name=index-g_t_002ech-867></A><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.dvi</SPAN></SAMP> is made from <SAMP><VAR>n</VAR><SPAN class=file>.tex</SPAN></SAMP> with the recipe &#8216;<SAMP><SPAN class=samp>$(TEX)</SPAN></SAMP>&#8217;. <SAMP><VAR>n</VAR><SPAN class=file>.tex</SPAN></SAMP> is made from <SAMP><VAR>n</VAR><SPAN class=file>.web</SPAN></SAMP> with &#8216;<SAMP><SPAN class=samp>$(WEAVE)</SPAN></SAMP>&#8217;, or from <SAMP><VAR>n</VAR><SPAN class=file>.w</SPAN></SAMP> (and from <SAMP><VAR>n</VAR><SPAN class=file>.ch</SPAN></SAMP> if it exists or can be made) with &#8216;<SAMP><SPAN class=samp>$(CWEAVE)</SPAN></SAMP>&#8217;. <SAMP><VAR>n</VAR><SPAN class=file>.p</SPAN></SAMP> is made from <SAMP><VAR>n</VAR><SPAN class=file>.web</SPAN></SAMP> with &#8216;<SAMP><SPAN class=samp>$(TANGLE)</SPAN></SAMP>&#8217; and <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> is made from <SAMP><VAR>n</VAR><SPAN class=file>.w</SPAN></SAMP> (and from <SAMP><VAR>n</VAR><SPAN class=file>.ch</SPAN></SAMP> if it exists or can be made) with &#8216;<SAMP><SPAN class=samp>$(CTANGLE)</SPAN></SAMP>&#8217;. <BR></FONT>
<DT><FONT class=extract>Texinfo and Info </FONT>
<DD><A name=index-Texinfo_002c-rule-to-format-868></A><A name=index-Info_002c-rule-to-format-869></A><A name=index-texi2dvi-870></A><A name=index-makeinfo-871></A><A name=index-g_t_002etexinfo-872></A><A name=index-g_t_002einfo-873></A><A name=index-g_t_002etexi-874></A><A name=index-g_t_002etxinfo-875></A><FONT class=extract><SAMP><VAR>n</VAR><SPAN class=file>.dvi</SPAN></SAMP> is made from <SAMP><VAR>n</VAR><SPAN class=file>.texinfo</SPAN></SAMP>, <SAMP><VAR>n</VAR><SPAN class=file>.texi</SPAN></SAMP>, or <SAMP><VAR>n</VAR><SPAN class=file>.txinfo</SPAN></SAMP>, with the recipe &#8216;<SAMP><SPAN class=samp>$(TEXI2DVI)&nbsp;$(TEXI2DVI_FLAGS)</SPAN></SAMP>&#8217;<!-- /@w -->. <SAMP><VAR>n</VAR><SPAN class=file>.info</SPAN></SAMP> is made from <SAMP><VAR>n</VAR><SPAN class=file>.texinfo</SPAN></SAMP>, <SAMP><VAR>n</VAR><SPAN class=file>.texi</SPAN></SAMP>, or <SAMP><VAR>n</VAR><SPAN class=file>.txinfo</SPAN></SAMP>, with the recipe &#8216;<SAMP><SPAN class=samp>$(MAKEINFO)&nbsp;$(MAKEINFO_FLAGS)</SPAN></SAMP>&#8217;<!-- /@w -->. <BR></FONT>
<DT><FONT class=extract>RCS </FONT>
<DD><A name=index-RCS_002c-rule-to-extract-from-876></A><A name=index-co-877></A><A name=index-g_t_002cv-_0040r_007b_0028RCS-file-extension_0029_007d-878></A><FONT class=extract>Any file <SAMP><VAR>n</VAR></SAMP> is extracted if necessary from an RCS file named either <SAMP><VAR>n</VAR><SPAN class=file>,v</SPAN></SAMP> or <SAMP><SPAN class=file>RCS/</SPAN><VAR>n</VAR><SPAN class=file>,v</SPAN></SAMP>. The precise recipe used is &#8216;<SAMP><SPAN class=samp>$(CO)&nbsp;$(COFLAGS)</SPAN></SAMP>&#8217;<!-- /@w -->. <SAMP><VAR>n</VAR></SAMP> will not be extracted from RCS if it already exists, even if the RCS file is newer. The rules for RCS are terminal (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Match_002dAnything-Rules"><FONT class=extract>Match-Anything Pattern Rules</FONT></A><FONT class=extract>), so RCS files cannot be generated from another source; they must actually exist. <BR></FONT>
<DT><FONT class=extract>SCCS </FONT>
<DD><A name=index-SCCS_002c-rule-to-extract-from-879></A><A name=index-get-880></A><A name=index-s_002e-_0040r_007b_0028SCCS-file-prefix_0029_007d-881></A><FONT class=extract>Any file <SAMP><VAR>n</VAR></SAMP> is extracted if necessary from an SCCS file named either <SAMP><SPAN class=file>s.</SPAN><VAR>n</VAR></SAMP> or <SAMP><SPAN class=file>SCCS/s.</SPAN><VAR>n</VAR></SAMP>. The precise recipe used is &#8216;<SAMP><SPAN class=samp>$(GET)&nbsp;$(GFLAGS)</SPAN></SAMP>&#8217;<!-- /@w -->. The rules for SCCS are terminal (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Match_002dAnything-Rules"><FONT class=extract>Match-Anything Pattern Rules</FONT></A><FONT class=extract>), so SCCS files cannot be generated from another source; they must actually exist. </FONT>
<P><A name=index-g_t_002esh-882></A><FONT class=extract>For the benefit of SCCS, a file <SAMP><VAR>n</VAR></SAMP> is copied from <SAMP><VAR>n</VAR><SPAN class=file>.sh</SPAN></SAMP> and made executable (by everyone). This is for shell scripts that are checked into SCCS. Since RCS preserves the execution permission of a file, you do not need to use this feature with RCS. </FONT>
<P><FONT class=extract>We recommend that you avoid using of SCCS. RCS is widely held to be superior, and is also free. By choosing free software in place of comparable (or inferior) proprietary software, you support the free software movement. </FONT></P></DD></DL>
<P><FONT class=extract>Usually, you want to change only the variables listed in the table above, which are documented in the following section. </FONT>
<P><FONT class=extract>However, the recipes in built-in implicit rules actually use variables such as <CODE>COMPILE.c</CODE>, <CODE>LINK.p</CODE>, and <CODE>PREPROCESS.S</CODE>, whose values contain the recipes listed above. </FONT>
<P><FONT class=extract><CODE>make</CODE> follows the convention that the rule to compile a <SAMP><SPAN class=file>.</SPAN><VAR>x</VAR></SAMP> source file uses the variable <CODE>COMPILE.</CODE><VAR>x</VAR>. Similarly, the rule to produce an executable from a <SAMP><SPAN class=file>.</SPAN><VAR>x</VAR></SAMP> file uses <CODE>LINK.</CODE><VAR>x</VAR>; and the rule to preprocess a <SAMP><SPAN class=file>.</SPAN><VAR>x</VAR></SAMP> file uses <CODE>PREPROCESS.</CODE><VAR>x</VAR>. </FONT>
<P><A name=index-OUTPUT_005fOPTION-883></A><FONT class=extract>Every rule that produces an object file uses the variable <CODE>OUTPUT_OPTION</CODE>. <CODE>make</CODE> defines this variable either to contain &#8216;<SAMP><SPAN class=samp>-o $@</SPAN></SAMP>&#8217;, or to be empty, depending on a compile-time option. You need the &#8216;<SAMP><SPAN class=samp>-o</SPAN></SAMP>&#8217; option to ensure that the output goes into the right file when the source file is in a different directory, as when using <CODE>VPATH</CODE> (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Directory-Search"><FONT class=extract>Directory Search</FONT></A><FONT class=extract>). However, compilers on some systems do not accept a &#8216;<SAMP><SPAN class=samp>-o</SPAN></SAMP>&#8217; switch for object files. If you use such a system, and use <CODE>VPATH</CODE>, some compilations will put their output in the wrong place. A possible workaround for this problem is to give <CODE>OUTPUT_OPTION</CODE> the value &#8216;<SAMP><SPAN class=samp>;&nbsp;mv&nbsp;$*.o&nbsp;$@</SPAN></SAMP>&#8217;<!-- /@w -->. </FONT>
<DIV class=node><A name=Implicit-Variables></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Chained-Rules" rel=next>Chained Rules</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Catalogue-of-Rules" rel=previous>Catalogue of Rules</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules" rel=up>Implicit Rules</A> </DIV>
<H3 class=section><FONT class=extract>10.3 Variables Used by Implicit Rules</FONT></H3>
<P><A name=index-flags-for-compilers-884></A><FONT class=extract>The recipes in built-in implicit rules make liberal use of certain predefined variables. You can alter the values of these variables in the makefile, with arguments to <CODE>make</CODE>, or in the environment to alter how the implicit rules work without redefining the rules themselves. You can cancel all variables used by implicit rules with the &#8216;<SAMP><SPAN class=samp>-R</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>--no-builtin-variables</SPAN></SAMP>&#8217; option. </FONT>
<P><FONT class=extract>For example, the recipe used to compile a C source file actually says &#8216;<SAMP><SPAN class=samp>$(CC) -c $(CFLAGS) $(CPPFLAGS)</SPAN></SAMP>&#8217;. The default values of the variables used are &#8216;<SAMP><SPAN class=samp>cc</SPAN></SAMP>&#8217; and nothing, resulting in the command &#8216;<SAMP><SPAN class=samp>cc -c</SPAN></SAMP>&#8217;. By redefining &#8216;<SAMP><SPAN class=samp>CC</SPAN></SAMP>&#8217; to &#8216;<SAMP><SPAN class=samp>ncc</SPAN></SAMP>&#8217;, you could cause &#8216;<SAMP><SPAN class=samp>ncc</SPAN></SAMP>&#8217; to be used for all C compilations performed by the implicit rule. By redefining &#8216;<SAMP><SPAN class=samp>CFLAGS</SPAN></SAMP>&#8217; to be &#8216;<SAMP><SPAN class=samp>-g</SPAN></SAMP>&#8217;, you could pass the &#8216;<SAMP><SPAN class=samp>-g</SPAN></SAMP>&#8217; option to each compilation. <EM>All</EM> implicit rules that do C compilation use &#8216;<SAMP><SPAN class=samp>$(CC)</SPAN></SAMP>&#8217; to get the program name for the compiler and <EM>all</EM> include &#8216;<SAMP><SPAN class=samp>$(CFLAGS)</SPAN></SAMP>&#8217; among the arguments given to the compiler. </FONT>
<P><FONT class=extract>The variables used in implicit rules fall into two classes: those that are names of programs (like <CODE>CC</CODE>) and those that contain arguments for the programs (like <CODE>CFLAGS</CODE>). (The &#8220;name of a program&#8221; may also contain some command arguments, but it must start with an actual executable program name.) If a variable value contains more than one argument, separate them with spaces. </FONT>
<P><FONT class=extract>The following tables describe of some of the more commonly-used predefined variables. This list is not exhaustive, and the default values shown here may not be what <CODE>make</CODE> selects for your environment. To see the complete list of predefined variables for your instance of GNU <CODE>make</CODE> you can run &#8216;<SAMP><SPAN class=samp>make -p</SPAN></SAMP>&#8217; in a directory with no makefiles. </FONT>
<P><FONT class=extract>Here is a table of some of the more common variables used as names of programs in built-in rules: </FONT>
<DL>
<DT><FONT class=extract><CODE>AR</CODE> </FONT>
<DD><A name=index-AR-885></A><FONT class=extract>Archive-maintaining program; default &#8216;<SAMP><SPAN class=samp>ar</SPAN></SAMP>&#8217;. </FONT><A name=index-ar-886></A><BR>
<DT><FONT class=extract><CODE>AS</CODE> </FONT>
<DD><A name=index-AS-887></A><FONT class=extract>Program for compiling assembly files; default &#8216;<SAMP><SPAN class=samp>as</SPAN></SAMP>&#8217;. </FONT><A name=index-as-888></A><BR>
<DT><FONT class=extract><CODE>CC</CODE> </FONT>
<DD><A name=index-CC-889></A><FONT class=extract>Program for compiling C programs; default &#8216;<SAMP><SPAN class=samp>cc</SPAN></SAMP>&#8217;. </FONT><A name=index-cc-890></A><BR>
<DT><FONT class=extract><CODE>CXX</CODE> </FONT>
<DD><A name=index-CXX-891></A><FONT class=extract>Program for compiling C++ programs; default &#8216;<SAMP><SPAN class=samp>g++</SPAN></SAMP>&#8217;. </FONT><A name=index-g_002b_002b-892></A><BR>
<DT><FONT class=extract><CODE>CPP</CODE> </FONT>
<DD><A name=index-CPP-893></A><FONT class=extract>Program for running the C preprocessor, with results to standard output; default &#8216;<SAMP><SPAN class=samp>$(CC) -E</SPAN></SAMP>&#8217;. <BR></FONT>
<DT><FONT class=extract><CODE>FC</CODE> </FONT>
<DD><A name=index-FC-894></A><FONT class=extract>Program for compiling or preprocessing Fortran and Ratfor programs; default &#8216;<SAMP><SPAN class=samp>f77</SPAN></SAMP>&#8217;. </FONT><A name=index-f77-895></A><BR>
<DT><FONT class=extract><CODE>M2C</CODE> </FONT>
<DD><A name=index-M2C-896></A><FONT class=extract>Program to use to compile Modula-2 source code; default &#8216;<SAMP><SPAN class=samp>m2c</SPAN></SAMP>&#8217;. </FONT><A name=index-m2c-897></A><BR>
<DT><FONT class=extract><CODE>PC</CODE> </FONT>
<DD><A name=index-PC-898></A><FONT class=extract>Program for compiling Pascal programs; default &#8216;<SAMP><SPAN class=samp>pc</SPAN></SAMP>&#8217;. </FONT><A name=index-pc-899></A><BR>
<DT><FONT class=extract><CODE>CO</CODE> </FONT>
<DD><A name=index-CO-900></A><FONT class=extract>Program for extracting a file from RCS; default &#8216;<SAMP><SPAN class=samp>co</SPAN></SAMP>&#8217;. </FONT><A name=index-co-901></A><BR>
<DT><FONT class=extract><CODE>GET</CODE> </FONT>
<DD><A name=index-GET-902></A><FONT class=extract>Program for extracting a file from SCCS; default &#8216;<SAMP><SPAN class=samp>get</SPAN></SAMP>&#8217;. </FONT><A name=index-get-903></A><BR>
<DT><FONT class=extract><CODE>LEX</CODE> </FONT>
<DD><A name=index-LEX-904></A><FONT class=extract>Program to use to turn Lex grammars into source code; default &#8216;<SAMP><SPAN class=samp>lex</SPAN></SAMP>&#8217;. </FONT><A name=index-lex-905></A><BR>
<DT><FONT class=extract><CODE>YACC</CODE> </FONT>
<DD><A name=index-YACC-906></A><FONT class=extract>Program to use to turn Yacc grammars into source code; default &#8216;<SAMP><SPAN class=samp>yacc</SPAN></SAMP>&#8217;. </FONT><A name=index-yacc-907></A><BR>
<DT><FONT class=extract><CODE>LINT</CODE> </FONT>
<DD><A name=index-LINT-908></A><FONT class=extract>Program to use to run lint on source code; default &#8216;<SAMP><SPAN class=samp>lint</SPAN></SAMP>&#8217;. </FONT><A name=index-lint-909></A><BR>
<DT><FONT class=extract><CODE>MAKEINFO</CODE> </FONT>
<DD><A name=index-MAKEINFO-910></A><FONT class=extract>Program to convert a Texinfo source file into an Info file; default &#8216;<SAMP><SPAN class=samp>makeinfo</SPAN></SAMP>&#8217;. </FONT><A name=index-makeinfo-911></A><BR>
<DT><FONT class=extract><CODE>TEX</CODE> </FONT>
<DD><A name=index-TEX-912></A><FONT class=extract>Program to make TeX <SPAN class=sc>dvi</SPAN> files from TeX source; default &#8216;<SAMP><SPAN class=samp>tex</SPAN></SAMP>&#8217;. </FONT><A name=index-tex-913></A><BR>
<DT><FONT class=extract><CODE>TEXI2DVI</CODE> </FONT>
<DD><A name=index-TEXI2DVI-914></A><FONT class=extract>Program to make TeX <SPAN class=sc>dvi</SPAN> files from Texinfo source; default &#8216;<SAMP><SPAN class=samp>texi2dvi</SPAN></SAMP>&#8217;. </FONT><A name=index-texi2dvi-915></A><BR>
<DT><FONT class=extract><CODE>WEAVE</CODE> </FONT>
<DD><A name=index-WEAVE-916></A><FONT class=extract>Program to translate Web into TeX; default &#8216;<SAMP><SPAN class=samp>weave</SPAN></SAMP>&#8217;. </FONT><A name=index-weave-917></A><BR>
<DT><FONT class=extract><CODE>CWEAVE</CODE> </FONT>
<DD><A name=index-CWEAVE-918></A><FONT class=extract>Program to translate C Web into TeX; default &#8216;<SAMP><SPAN class=samp>cweave</SPAN></SAMP>&#8217;. </FONT><A name=index-cweave-919></A><BR>
<DT><FONT class=extract><CODE>TANGLE</CODE> </FONT>
<DD><A name=index-TANGLE-920></A><FONT class=extract>Program to translate Web into Pascal; default &#8216;<SAMP><SPAN class=samp>tangle</SPAN></SAMP>&#8217;. </FONT><A name=index-tangle-921></A><BR>
<DT><FONT class=extract><CODE>CTANGLE</CODE> </FONT>
<DD><A name=index-CTANGLE-922></A><FONT class=extract>Program to translate C Web into C; default &#8216;<SAMP><SPAN class=samp>ctangle</SPAN></SAMP>&#8217;. </FONT><A name=index-ctangle-923></A><BR>
<DT><FONT class=extract><CODE>RM</CODE> </FONT>
<DD><A name=index-RM-924></A><FONT class=extract>Command to remove a file; default &#8216;<SAMP><SPAN class=samp>rm -f</SPAN></SAMP>&#8217;. </FONT><A name=index-rm-925></A></DD></DL>
<P><FONT class=extract>Here is a table of variables whose values are additional arguments for the programs above. The default values for all of these is the empty string, unless otherwise noted. </FONT>
<DL>
<DT><FONT class=extract><CODE>ARFLAGS</CODE> </FONT>
<DD><A name=index-ARFLAGS-926></A><FONT class=extract>Flags to give the archive-maintaining program; default &#8216;<SAMP><SPAN class=samp>rv</SPAN></SAMP>&#8217;. <BR></FONT>
<DT><FONT class=extract><CODE>ASFLAGS</CODE> </FONT>
<DD><A name=index-ASFLAGS-927></A><FONT class=extract>Extra flags to give to the assembler (when explicitly invoked on a &#8216;<SAMP><SPAN class=samp>.s</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>.S</SPAN></SAMP>&#8217; file). <BR></FONT>
<DT><FONT class=extract><CODE>CFLAGS</CODE> </FONT>
<DD><A name=index-CFLAGS-928></A><FONT class=extract>Extra flags to give to the C compiler. <BR></FONT>
<DT><FONT class=extract><CODE>CXXFLAGS</CODE> </FONT>
<DD><A name=index-CXXFLAGS-929></A><FONT class=extract>Extra flags to give to the C++ compiler. <BR></FONT>
<DT><FONT class=extract><CODE>COFLAGS</CODE> </FONT>
<DD><A name=index-COFLAGS-930></A><FONT class=extract>Extra flags to give to the RCS <CODE>co</CODE> program. <BR></FONT>
<DT><FONT class=extract><CODE>CPPFLAGS</CODE> </FONT>
<DD><A name=index-CPPFLAGS-931></A><FONT class=extract>Extra flags to give to the C preprocessor and programs that use it (the C and Fortran compilers). <BR></FONT>
<DT><FONT class=extract><CODE>FFLAGS</CODE> </FONT>
<DD><A name=index-FFLAGS-932></A><FONT class=extract>Extra flags to give to the Fortran compiler. <BR></FONT>
<DT><FONT class=extract><CODE>GFLAGS</CODE> </FONT>
<DD><A name=index-GFLAGS-933></A><FONT class=extract>Extra flags to give to the SCCS <CODE>get</CODE> program. <BR></FONT>
<DT><FONT class=extract><CODE>LDFLAGS</CODE> </FONT>
<DD><A name=index-LDFLAGS-934></A><FONT class=extract>Extra flags to give to compilers when they are supposed to invoke the linker, &#8216;<SAMP><SPAN class=samp>ld</SPAN></SAMP>&#8217;, such as <CODE>-L</CODE>. Libraries (<CODE>-lfoo</CODE>) should be added to the <CODE>LDLIBS</CODE> variable instead. <BR></FONT>
<DT><FONT class=extract><CODE>LDLIBS</CODE> </FONT>
<DD><A name=index-LDLIBS-935></A><A name=index-LOADLIBES-936></A><FONT class=extract>Library flags or names given to compilers when they are supposed to invoke the linker, &#8216;<SAMP><SPAN class=samp>ld</SPAN></SAMP>&#8217;. <CODE>LOADLIBES</CODE> is a deprecated (but still supported) alternative to <CODE>LDLIBS</CODE>. Non-library linker flags, such as <CODE>-L</CODE>, should go in the <CODE>LDFLAGS</CODE> variable. <BR></FONT>
<DT><FONT class=extract><CODE>LFLAGS</CODE> </FONT>
<DD><A name=index-LFLAGS-937></A><FONT class=extract>Extra flags to give to Lex. <BR></FONT>
<DT><FONT class=extract><CODE>YFLAGS</CODE> </FONT>
<DD><A name=index-YFLAGS-938></A><FONT class=extract>Extra flags to give to Yacc. <BR></FONT>
<DT><FONT class=extract><CODE>PFLAGS</CODE> </FONT>
<DD><A name=index-PFLAGS-939></A><FONT class=extract>Extra flags to give to the Pascal compiler. <BR></FONT>
<DT><FONT class=extract><CODE>RFLAGS</CODE> </FONT>
<DD><A name=index-RFLAGS-940></A><FONT class=extract>Extra flags to give to the Fortran compiler for Ratfor programs. <BR></FONT>
<DT><FONT class=extract><CODE>LINTFLAGS</CODE> </FONT>
<DD><A name=index-LINTFLAGS-941></A><FONT class=extract>Extra flags to give to lint. </FONT></DD></DL>
<DIV class=node><A name=Chained-Rules></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules" rel=next>Pattern Rules</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Implicit-Variables" rel=previous>Implicit Variables</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules" rel=up>Implicit Rules</A> </DIV>
<H3 class=section><FONT class=extract>10.4 Chains of Implicit Rules</FONT></H3>
<P><A name=index-chains-of-rules-942></A><A name=index-rule_002c-implicit_002c-chains-of-943></A><FONT class=extract>Sometimes a file can be made by a sequence of implicit rules. For example, a file <SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> could be made from <SAMP><VAR>n</VAR><SPAN class=file>.y</SPAN></SAMP> by running first Yacc and then <CODE>cc</CODE>. Such a sequence is called a <DFN>chain</DFN>. </FONT>
<P><FONT class=extract>If the file <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> exists, or is mentioned in the makefile, no special searching is required: <CODE>make</CODE> finds that the object file can be made by C compilation from <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP>; later on, when considering how to make <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP>, the rule for running Yacc is used. Ultimately both <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> and <SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> are updated. </FONT>
<P><A name=index-intermediate-files-944></A><A name=index-files_002c-intermediate-945></A><FONT class=extract>However, even if <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> does not exist and is not mentioned, <CODE>make</CODE> knows how to envision it as the missing link between <SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP> and <SAMP><VAR>n</VAR><SPAN class=file>.y</SPAN></SAMP>! In this case, <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> is called an <DFN>intermediate file</DFN>. Once <CODE>make</CODE> has decided to use the intermediate file, it is entered in the data base as if it had been mentioned in the makefile, along with the implicit rule that says how to create it. </FONT>
<P><FONT class=extract>Intermediate files are remade using their rules just like all other files. But intermediate files are treated differently in two ways. </FONT>
<P><FONT class=extract>The first difference is what happens if the intermediate file does not exist. If an ordinary file <VAR>b</VAR> does not exist, and <CODE>make</CODE> considers a target that depends on <VAR>b</VAR>, it invariably creates <VAR>b</VAR> and then updates the target from <VAR>b</VAR>. But if <VAR>b</VAR> is an intermediate file, then <CODE>make</CODE> can leave well enough alone. It won't bother updating <VAR>b</VAR>, or the ultimate target, unless some prerequisite of <VAR>b</VAR> is newer than that target or there is some other reason to update that target. </FONT>
<P><FONT class=extract>The second difference is that if <CODE>make</CODE> <EM>does</EM> create <VAR>b</VAR> in order to update something else, it deletes <VAR>b</VAR> later on after it is no longer needed. Therefore, an intermediate file which did not exist before <CODE>make</CODE> also does not exist after <CODE>make</CODE>. <CODE>make</CODE> reports the deletion to you by printing a &#8216;<SAMP><SPAN class=samp>rm -f</SPAN></SAMP>&#8217; command showing which file it is deleting. </FONT>
<P><FONT class=extract>Ordinarily, a file cannot be intermediate if it is mentioned in the makefile as a target or prerequisite. However, you can explicitly mark a file as intermediate by listing it as a prerequisite of the special target <CODE>.INTERMEDIATE</CODE>. This takes effect even if the file is mentioned explicitly in some other way. </FONT>
<P><A name=index-intermediate-files_002c-preserving-946></A><A name=index-preserving-intermediate-files-947></A><A name=index-secondary-files-948></A><FONT class=extract>You can prevent automatic deletion of an intermediate file by marking it as a <DFN>secondary</DFN> file. To do this, list it as a prerequisite of the special target <CODE>.SECONDARY</CODE>. When a file is secondary, <CODE>make</CODE> will not create the file merely because it does not already exist, but <CODE>make</CODE> does not automatically delete the file. Marking a file as secondary also marks it as intermediate. </FONT>
<P><FONT class=extract>You can list the target pattern of an implicit rule (such as &#8216;<SAMP><SPAN class=samp>%.o</SPAN></SAMP>&#8217;) as a prerequisite of the special target <CODE>.PRECIOUS</CODE> to preserve intermediate files made by implicit rules whose target patterns match that file's name; see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Interrupts"><FONT class=extract>Interrupts</FONT></A><FONT class=extract>. </FONT><A name=index-preserving-with-_0040code_007b_002ePRECIOUS_007d-949></A><A name=index-g_t_0040code_007b_002ePRECIOUS_007d-intermediate-files-950></A><FONT class=extract>A chain can involve more than two implicit rules. For example, it is possible to make a file <SAMP><SPAN class=file>foo</SPAN></SAMP> from <SAMP><SPAN class=file>RCS/foo.y,v</SPAN></SAMP> by running RCS, Yacc and <CODE>cc</CODE>. Then both <SAMP><SPAN class=file>foo.y</SPAN></SAMP> and <SAMP><SPAN class=file>foo.c</SPAN></SAMP> are intermediate files that are deleted at the end. </FONT>
<P><FONT class=extract>No single implicit rule can appear more than once in a chain. This means that <CODE>make</CODE> will not even consider such a ridiculous thing as making <SAMP><SPAN class=file>foo</SPAN></SAMP> from <SAMP><SPAN class=file>foo.o.o</SPAN></SAMP> by running the linker twice. This constraint has the added benefit of preventing any infinite loop in the search for an implicit rule chain. </FONT>
<P><FONT class=extract>There are some special implicit rules to optimize certain cases that would otherwise be handled by rule chains. For example, making <SAMP><SPAN class=file>foo</SPAN></SAMP> from <SAMP><SPAN class=file>foo.c</SPAN></SAMP> could be handled by compiling and linking with separate chained rules, using <SAMP><SPAN class=file>foo.o</SPAN></SAMP> as an intermediate file. But what actually happens is that a special rule for this case does the compilation and linking with a single <CODE>cc</CODE> command. The optimized rule is used in preference to the step-by-step chain because it comes earlier in the ordering of rules. </FONT>
<DIV class=node><A name=Pattern-Rules></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Last-Resort" rel=next>Last Resort</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Chained-Rules" rel=previous>Chained Rules</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules" rel=up>Implicit Rules</A> </DIV>
<H3 class=section><FONT class=extract>10.5 Defining and Redefining Pattern Rules</FONT></H3>
<P><FONT class=extract>You define an implicit rule by writing a <DFN>pattern rule</DFN>. A pattern rule looks like an ordinary rule, except that its target contains the character &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; (exactly one of them). The target is considered a pattern for matching file names; the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; can match any nonempty substring, while other characters match only themselves. The prerequisites likewise use &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; to show how their names relate to the target name. </FONT>
<P><FONT class=extract>Thus, a pattern rule &#8216;<SAMP><SPAN class=samp>%.o : %.c</SPAN></SAMP>&#8217; says how to make any file <SAMP><VAR>stem</VAR><SPAN class=file>.o</SPAN></SAMP> from another file <SAMP><VAR>stem</VAR><SPAN class=file>.c</SPAN></SAMP>. </FONT>
<P><FONT class=extract>Note that expansion using &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; in pattern rules occurs <STRONG>after</STRONG> any variable or function expansions, which take place when the makefile is read. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Using-Variables"><FONT class=extract>How to Use Variables</FONT></A><FONT class=extract>, and </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Functions"><FONT class=extract>Functions for Transforming Text</FONT></A><FONT class=extract>. </FONT>
<UL class=menu>
<LI><A accessKey=1 href="https://www.gnu.org/software/make/manual/make.html#Pattern-Intro"><FONT class=extract>Pattern Intro</FONT></A><FONT class=extract>: An introduction to pattern rules. </FONT>
<LI><A accessKey=2 href="https://www.gnu.org/software/make/manual/make.html#Pattern-Examples"><FONT class=extract>Pattern Examples</FONT></A><FONT class=extract>: Examples of pattern rules. </FONT>
<LI><A accessKey=3 href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables"><FONT class=extract>Automatic Variables</FONT></A><FONT class=extract>: How to use automatic variables in the recipe of implicit rules. </FONT>
<LI><A accessKey=4 href="https://www.gnu.org/software/make/manual/make.html#Pattern-Match"><FONT class=extract>Pattern Match</FONT></A><FONT class=extract>: How patterns match. </FONT>
<LI><A accessKey=5 href="https://www.gnu.org/software/make/manual/make.html#Match_002dAnything-Rules"><FONT class=extract>Match-Anything Rules</FONT></A><FONT class=extract>: Precautions you should take prior to defining rules that can match any target file whatever. </FONT>
<LI><A accessKey=6 href="https://www.gnu.org/software/make/manual/make.html#Canceling-Rules"><FONT class=extract>Canceling Rules</FONT></A><FONT class=extract>: How to override or cancel built-in rules. </FONT></LI></UL>
<DIV class=node><A name=Pattern-Intro></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Pattern-Examples" rel=next>Pattern Examples</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules" rel=previous>Pattern Rules</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules" rel=up>Pattern Rules</A> </DIV>
<H4 class=subsection><FONT class=extract>10.5.1 Introduction to Pattern Rules</FONT></H4>
<P><A name=index-pattern-rule-951></A><A name=index-rule_002c-pattern-952></A><FONT class=extract>A pattern rule contains the character &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; (exactly one of them) in the target; otherwise, it looks exactly like an ordinary rule. The target is a pattern for matching file names; the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; matches any nonempty substring, while other characters match only themselves. </FONT><A name=index-target-pattern_002c-implicit-953></A><A name=index-g_t_0040code_007b_0025_007d_002c-in-pattern-rules-954></A><FONT class=extract>For example, &#8216;<SAMP><SPAN class=samp>%.c</SPAN></SAMP>&#8217; as a pattern matches any file name that ends in &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217;. &#8216;<SAMP><SPAN class=samp>s.%.c</SPAN></SAMP>&#8217; as a pattern matches any file name that starts with &#8216;<SAMP><SPAN class=samp>s.</SPAN></SAMP>&#8217;, ends in &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; and is at least five characters long. (There must be at least one character to match the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;.) The substring that the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; matches is called the <DFN>stem</DFN>. </FONT>
<P><FONT class=extract>&#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; in a prerequisite of a pattern rule stands for the same stem that was matched by the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; in the target. In order for the pattern rule to apply, its target pattern must match the file name under consideration and all of its prerequisites (after pattern substitution) must name files that exist or can be made. These files become prerequisites of the target. </FONT><A name=index-prerequisite-pattern_002c-implicit-955></A><FONT class=extract>Thus, a rule of the form </FONT><PRE class=example><FONT class=extract>     %.o : %.c ; <VAR>recipe</VAR>...
</FONT></PRE>
<P class=noindent><FONT class=extract>specifies how to make a file <SAMP><VAR>n</VAR><SPAN class=file>.o</SPAN></SAMP>, with another file <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> as its prerequisite, provided that <SAMP><VAR>n</VAR><SPAN class=file>.c</SPAN></SAMP> exists or can be made. </FONT>
<P><FONT class=extract>There may also be prerequisites that do not use &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;; such a prerequisite attaches to every file made by this pattern rule. These unvarying prerequisites are useful occasionally. </FONT>
<P><FONT class=extract>A pattern rule need not have any prerequisites that contain &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;, or in fact any prerequisites at all. Such a rule is effectively a general wildcard. It provides a way to make any file that matches the target pattern. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Last-Resort"><FONT class=extract>Last Resort</FONT></A><FONT class=extract>. </FONT>
<P><FONT class=extract>More than one pattern rule may match a target. In this case <CODE>make</CODE> will choose the &#8220;best fit&#8221; rule. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Pattern-Match"><FONT class=extract>How Patterns Match</FONT></A><FONT class=extract>. <!-- !!! The end of of this paragraph should be rewritten.  -bob --></FONT>
<P><FONT class=extract>Pattern rules may have more than one target. Unlike normal rules, this does not act as many different rules with the same prerequisites and recipe. If a pattern rule has multiple targets, <CODE>make</CODE> knows that the rule's recipe is responsible for making all of the targets. The recipe is executed only once to make all the targets. When searching for a pattern rule to match a target, the target patterns of a rule other than the one that matches the target in need of a rule are incidental: <CODE>make</CODE> worries only about giving a recipe and prerequisites to the file presently in question. However, when this file's recipe is run, the other targets are marked as having been updated themselves. </FONT><A name=index-multiple-targets_002c-in-pattern-rule-956></A><A name=index-target_002c-multiple-in-pattern-rule-957></A>
<DIV class=node><A name=Pattern-Examples></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables" rel=next>Automatic Variables</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Pattern-Intro" rel=previous>Pattern Intro</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules" rel=up>Pattern Rules</A> </DIV>
<H4 class=subsection><FONT class=extract>10.5.2 Pattern Rule Examples</FONT></H4>
<P><FONT class=extract>Here are some examples of pattern rules actually predefined in <CODE>make</CODE>. First, the rule that compiles &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; files into &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; files: </FONT><PRE class=example><FONT class=extract>     %.o : %.c
             $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@
</FONT></PRE>
<P class=noindent><FONT class=extract>defines a rule that can make any file <SAMP><VAR>x</VAR><SPAN class=file>.o</SPAN></SAMP> from <SAMP><VAR>x</VAR><SPAN class=file>.c</SPAN></SAMP>. The recipe uses the automatic variables &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>$&lt;</SPAN></SAMP>&#8217; to substitute the names of the target file and the source file in each case where the rule applies (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables"><FONT class=extract>Automatic Variables</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>Here is a second built-in rule: </FONT><PRE class=example><FONT class=extract>     % :: RCS/%,v
             $(CO) $(COFLAGS) $&lt;
</FONT></PRE>
<P class=noindent><FONT class=extract>defines a rule that can make any file <SAMP><VAR>x</VAR></SAMP> whatsoever from a corresponding file <SAMP><VAR>x</VAR><SPAN class=file>,v</SPAN></SAMP> in the sub-directory <SAMP><SPAN class=file>RCS</SPAN></SAMP>. Since the target is &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;, this rule will apply to any file whatever, provided the appropriate prerequisite file exists. The double colon makes the rule <DFN>terminal</DFN>, which means that its prerequisite may not be an intermediate file (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Match_002dAnything-Rules"><FONT class=extract>Match-Anything Pattern Rules</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>This pattern rule has two targets: </FONT><PRE class=example><FONT class=extract>     %.tab.c %.tab.h: %.y
             bison -d $&lt;
</FONT></PRE>
<P class=noindent><!-- The following paragraph is rewritten to avoid overfull hboxes --><FONT class=extract>This tells <CODE>make</CODE> that the recipe &#8216;<SAMP><SPAN class=samp>bison -d </SPAN><VAR>x</VAR><SPAN class=samp>.y</SPAN></SAMP>&#8217; will make both <SAMP><VAR>x</VAR><SPAN class=file>.tab.c</SPAN></SAMP> and <SAMP><VAR>x</VAR><SPAN class=file>.tab.h</SPAN></SAMP>. If the file <SAMP><SPAN class=file>foo</SPAN></SAMP> depends on the files <SAMP><SPAN class=file>parse.tab.o</SPAN></SAMP> and <SAMP><SPAN class=file>scan.o</SPAN></SAMP> and the file <SAMP><SPAN class=file>scan.o</SPAN></SAMP> depends on the file <SAMP><SPAN class=file>parse.tab.h</SPAN></SAMP>, when <SAMP><SPAN class=file>parse.y</SPAN></SAMP> is changed, the recipe &#8216;<SAMP><SPAN class=samp>bison -d parse.y</SPAN></SAMP>&#8217; will be executed only once, and the prerequisites of both <SAMP><SPAN class=file>parse.tab.o</SPAN></SAMP> and <SAMP><SPAN class=file>scan.o</SPAN></SAMP> will be satisfied. (Presumably the file <SAMP><SPAN class=file>parse.tab.o</SPAN></SAMP> will be recompiled from <SAMP><SPAN class=file>parse.tab.c</SPAN></SAMP> and the file <SAMP><SPAN class=file>scan.o</SPAN></SAMP> from <SAMP><SPAN class=file>scan.c</SPAN></SAMP>, while <SAMP><SPAN class=file>foo</SPAN></SAMP> is linked from <SAMP><SPAN class=file>parse.tab.o</SPAN></SAMP>, <SAMP><SPAN class=file>scan.o</SPAN></SAMP>, and its other prerequisites, and it will execute happily ever after.) </FONT>
<DIV class=node><A name=Automatic-Variables></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Pattern-Match" rel=next>Pattern Match</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Pattern-Examples" rel=previous>Pattern Examples</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules" rel=up>Pattern Rules</A> </DIV>
<H4 class=subsection><FONT class=extract>10.5.3 Automatic Variables</FONT></H4>
<P><A name=index-automatic-variables-958></A><A name=index-variables_002c-automatic-959></A><A name=index-variables_002c-and-implicit-rule-960></A><FONT class=extract>Suppose you are writing a pattern rule to compile a &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; file into a &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; file: how do you write the &#8216;<SAMP><SPAN class=samp>cc</SPAN></SAMP>&#8217; command so that it operates on the right source file name? You cannot write the name in the recipe, because the name is different each time the implicit rule is applied. </FONT>
<P><FONT class=extract>What you do is use a special feature of <CODE>make</CODE>, the <DFN>automatic variables</DFN>. These variables have values computed afresh for each rule that is executed, based on the target and prerequisites of the rule. In this example, you would use &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217; for the object file name and &#8216;<SAMP><SPAN class=samp>$&lt;</SPAN></SAMP>&#8217; for the source file name. </FONT>
<P><A name=index-automatic-variables-in-prerequisites-961></A><A name=index-prerequisites_002c-and-automatic-variables-962></A><FONT class=extract>It's very important that you recognize the limited scope in which automatic variable values are available: they only have values within the recipe. In particular, you cannot use them anywhere within the target list of a rule; they have no value there and will expand to the empty string. Also, they cannot be accessed directly within the prerequisite list of a rule. A common mistake is attempting to use <CODE>$@</CODE> within the prerequisites list; this will not work. However, there is a special feature of GNU <CODE>make</CODE>, secondary expansion (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Secondary-Expansion"><FONT class=extract>Secondary Expansion</FONT></A><FONT class=extract>), which will allow automatic variable values to be used in prerequisite lists. </FONT>
<P><FONT class=extract>Here is a table of automatic variables: </FONT><A name=index-g_t_0024_0040_0040-963></A><A name=index-g_t_0040_0040-_0040r_007b_0028automatic-variable_0029_007d-964></A>
<DL>
<DT><FONT class=extract><CODE>$@</CODE> </FONT>
<DD><FONT class=extract>The file name of the target of the rule. If the target is an archive member, then &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217; is the name of the archive file. In a pattern rule that has multiple targets (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Pattern-Intro"><FONT class=extract>Introduction to Pattern Rules</FONT></A><FONT class=extract>), &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217; is the name of whichever target caused the rule's recipe to be run. </FONT>
<P><A name=index-g_t_0024_0025-965></A><A name=index-g_t_0025-_0040r_007b_0028automatic-variable_0029_007d-966></A><BR></P>
<DT><FONT class=extract><CODE>$%</CODE> </FONT>
<DD><FONT class=extract>The target member name, when the target is an archive member. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Archives"><FONT class=extract>Archives</FONT></A><FONT class=extract>. For example, if the target is <SAMP><SPAN class=file>foo.a(bar.o)</SPAN></SAMP> then &#8216;<SAMP><SPAN class=samp>$%</SPAN></SAMP>&#8217; is <SAMP><SPAN class=file>bar.o</SPAN></SAMP> and &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217; is <SAMP><SPAN class=file>foo.a</SPAN></SAMP>. &#8216;<SAMP><SPAN class=samp>$%</SPAN></SAMP>&#8217; is empty when the target is not an archive member. </FONT>
<P><A name=index-g_t_0024_003c-967></A><A name=index-g_t_003c-_0040r_007b_0028automatic-variable_0029_007d-968></A><BR></P>
<DT><FONT class=extract><CODE>$&lt;</CODE> </FONT>
<DD><FONT class=extract>The name of the first prerequisite. If the target got its recipe from an implicit rule, this will be the first prerequisite added by the implicit rule (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules"><FONT class=extract>Implicit Rules</FONT></A><FONT class=extract>). </FONT>
<P><A name=index-g_t_0024_003f-969></A><A name=index-g_t_003f-_0040r_007b_0028automatic-variable_0029_007d-970></A><BR></P>
<DT><FONT class=extract><CODE>$?</CODE> </FONT>
<DD><FONT class=extract>The names of all the prerequisites that are newer than the target, with spaces between them. For prerequisites which are archive members, only the named member is used (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Archives"><FONT class=extract>Archives</FONT></A><FONT class=extract>). </FONT><A name=index-prerequisites_002c-list-of-changed-971></A><A name=index-list-of-changed-prerequisites-972></A><A name=index-g_t_0024_005e-973></A><A name=index-g_t_005e-_0040r_007b_0028automatic-variable_0029_007d-974></A><BR>
<DT><FONT class=extract><CODE>$^</CODE> </FONT>
<DD><FONT class=extract>The names of all the prerequisites, with spaces between them. For prerequisites which are archive members, only the named member is used (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Archives"><FONT class=extract>Archives</FONT></A><FONT class=extract>). A target has only one prerequisite on each other file it depends on, no matter how many times each file is listed as a prerequisite. So if you list a prerequisite more than once for a target, the value of <CODE>$^</CODE> contains just one copy of the name. This list does <STRONG>not</STRONG> contain any of the order-only prerequisites; for those see the &#8216;<SAMP><SPAN class=samp>$|</SPAN></SAMP>&#8217; variable, below. </FONT><A name=index-prerequisites_002c-list-of-all-975></A><A name=index-list-of-all-prerequisites-976></A><A name=index-g_t_0024_002b-977></A><A name=index-g_t_002b-_0040r_007b_0028automatic-variable_0029_007d-978></A><BR>
<DT><FONT class=extract><CODE>$+</CODE> </FONT>
<DD><FONT class=extract>This is like &#8216;<SAMP><SPAN class=samp>$^</SPAN></SAMP>&#8217;, but prerequisites listed more than once are duplicated in the order they were listed in the makefile. This is primarily useful for use in linking commands where it is meaningful to repeat library file names in a particular order. </FONT>
<P><A name=index-g_t_0024_007c-979></A><A name=index-g_t_007c-_0040r_007b_0028automatic-variable_0029_007d-980></A><BR></P>
<DT><FONT class=extract><CODE>$|</CODE> </FONT>
<DD><FONT class=extract>The names of all the order-only prerequisites, with spaces between them. </FONT>
<P><A name=index-g_t_0024_002a-981></A><A name=index-g_t_002a-_0040r_007b_0028automatic-variable_0029_007d-982></A><BR></P>
<DT><FONT class=extract><CODE>$*</CODE> </FONT>
<DD><FONT class=extract>The stem with which an implicit rule matches (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Pattern-Match"><FONT class=extract>How Patterns Match</FONT></A><FONT class=extract>). If the target is <SAMP><SPAN class=file>dir/a.foo.b</SPAN></SAMP> and the target pattern is <SAMP><SPAN class=file>a.%.b</SPAN></SAMP> then the stem is <SAMP><SPAN class=file>dir/foo</SPAN></SAMP>. The stem is useful for constructing names of related files. </FONT><A name=index-stem_002c-variable-for-983></A><FONT class=extract>In a static pattern rule, the stem is part of the file name that matched the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; in the target pattern. </FONT>
<P><FONT class=extract>In an explicit rule, there is no stem; so &#8216;<SAMP><SPAN class=samp>$*</SPAN></SAMP>&#8217; cannot be determined in that way. Instead, if the target name ends with a recognized suffix (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Suffix-Rules"><FONT class=extract>Old-Fashioned Suffix Rules</FONT></A><FONT class=extract>), &#8216;<SAMP><SPAN class=samp>$*</SPAN></SAMP>&#8217; is set to the target name minus the suffix. For example, if the target name is &#8216;<SAMP><SPAN class=samp>foo.c</SPAN></SAMP>&#8217;, then &#8216;<SAMP><SPAN class=samp>$*</SPAN></SAMP>&#8217; is set to &#8216;<SAMP><SPAN class=samp>foo</SPAN></SAMP>&#8217;, since &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; is a suffix. GNU <CODE>make</CODE> does this bizarre thing only for compatibility with other implementations of <CODE>make</CODE>. You should generally avoid using &#8216;<SAMP><SPAN class=samp>$*</SPAN></SAMP>&#8217; except in implicit rules or static pattern rules. </FONT>
<P><FONT class=extract>If the target name in an explicit rule does not end with a recognized suffix, &#8216;<SAMP><SPAN class=samp>$*</SPAN></SAMP>&#8217; is set to the empty string for that rule. </FONT></P></DD></DL>
<P><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$?</SPAN></SAMP>&#8217; is useful even in explicit rules when you wish to operate on only the prerequisites that have changed. For example, suppose that an archive named <SAMP><SPAN class=file>lib</SPAN></SAMP> is supposed to contain copies of several object files. This rule copies just the changed object files into the archive: </FONT><PRE class=example><FONT class=extract>     lib: foo.o bar.o lose.o win.o
             ar r lib $?
</FONT></PRE>
<P><FONT class=extract>Of the variables listed above, four have values that are single file names, and three have values that are lists of file names. These seven have variants that get just the file's directory name or just the file name within the directory. The variant variables' names are formed by appending &#8216;<SAMP><SPAN class=samp>D</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>F</SPAN></SAMP>&#8217;, respectively. These variants are semi-obsolete in GNU <CODE>make</CODE> since the functions <CODE>dir</CODE> and <CODE>notdir</CODE> can be used to get a similar effect (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#File-Name-Functions"><FONT class=extract>Functions for File Names</FONT></A><FONT class=extract>). Note, however, that the &#8216;<SAMP><SPAN class=samp>D</SPAN></SAMP>&#8217; variants all omit the trailing slash which always appears in the output of the <CODE>dir</CODE> function. Here is a table of the variants: </FONT><A name=index-g_t_0024_0028_0040_0040D_0029-984></A><A name=index-g_t_0040_0040D-_0040r_007b_0028automatic-variable_0029_007d-985></A>
<DL>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(@D)</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>The directory part of the file name of the target, with the trailing slash removed. If the value of &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217; is <SAMP><SPAN class=file>dir/foo.o</SPAN></SAMP> then &#8216;<SAMP><SPAN class=samp>$(@D)</SPAN></SAMP>&#8217; is <SAMP><SPAN class=file>dir</SPAN></SAMP>. This value is <SAMP><SPAN class=file>.</SPAN></SAMP> if &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217; does not contain a slash. </FONT>
<P><A name=index-g_t_0024_0028_0040_0040F_0029-986></A><A name=index-g_t_0040_0040F-_0040r_007b_0028automatic-variable_0029_007d-987></A><BR></P>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(@F)</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>The file-within-directory part of the file name of the target. If the value of &#8216;<SAMP><SPAN class=samp>$@</SPAN></SAMP>&#8217; is <SAMP><SPAN class=file>dir/foo.o</SPAN></SAMP> then &#8216;<SAMP><SPAN class=samp>$(@F)</SPAN></SAMP>&#8217; is <SAMP><SPAN class=file>foo.o</SPAN></SAMP>. &#8216;<SAMP><SPAN class=samp>$(@F)</SPAN></SAMP>&#8217; is equivalent to &#8216;<SAMP><SPAN class=samp>$(notdir $@)</SPAN></SAMP>&#8217;. </FONT>
<P><A name=index-g_t_0024_0028_002aD_0029-988></A><A name=index-g_t_002aD-_0040r_007b_0028automatic-variable_0029_007d-989></A><BR></P>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(*D)</SPAN></SAMP>&#8217; </FONT>
<DD><A name=index-g_t_0024_0028_002aF_0029-990><FONT class=extract></FONT></A><A name=index-g_t_002aF-_0040r_007b_0028automatic-variable_0029_007d-991></A>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(*F)</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>The directory part and the file-within-directory part of the stem; <SAMP><SPAN class=file>dir</SPAN></SAMP> and <SAMP><SPAN class=file>foo</SPAN></SAMP> in this example. </FONT>
<P><A name=index-g_t_0024_0028_0025D_0029-992></A><A name=index-g_t_0025D-_0040r_007b_0028automatic-variable_0029_007d-993></A><BR></P>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(%D)</SPAN></SAMP>&#8217; </FONT>
<DD><A name=index-g_t_0024_0028_0025F_0029-994><FONT class=extract></FONT></A><A name=index-g_t_0025F-_0040r_007b_0028automatic-variable_0029_007d-995></A>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(%F)</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>The directory part and the file-within-directory part of the target archive member name. This makes sense only for archive member targets of the form <SAMP><VAR>archive</VAR><SPAN class=file>(</SPAN><VAR>member</VAR><SPAN class=file>)</SPAN></SAMP> and is useful only when <VAR>member</VAR> may contain a directory name. (See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Archive-Members"><FONT class=extract>Archive Members as Targets</FONT></A><FONT class=extract>.) </FONT>
<P><A name=index-g_t_0024_0028_003cD_0029-996></A><A name=index-g_t_003cD-_0040r_007b_0028automatic-variable_0029_007d-997></A><BR></P>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(&lt;D)</SPAN></SAMP>&#8217; </FONT>
<DD><A name=index-g_t_0024_0028_003cF_0029-998><FONT class=extract></FONT></A><A name=index-g_t_003cF-_0040r_007b_0028automatic-variable_0029_007d-999></A>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(&lt;F)</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>The directory part and the file-within-directory part of the first prerequisite. </FONT>
<P><A name=index-g_t_0024_0028_005eD_0029-1000></A><A name=index-g_t_005eD-_0040r_007b_0028automatic-variable_0029_007d-1001></A><BR></P>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(^D)</SPAN></SAMP>&#8217; </FONT>
<DD><A name=index-g_t_0024_0028_005eF_0029-1002><FONT class=extract></FONT></A><A name=index-g_t_005eF-_0040r_007b_0028automatic-variable_0029_007d-1003></A>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(^F)</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>Lists of the directory parts and the file-within-directory parts of all prerequisites. </FONT>
<P><A name=index-g_t_0024_0028_002bD_0029-1004></A><A name=index-g_t_002bD-_0040r_007b_0028automatic-variable_0029_007d-1005></A><BR></P>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(+D)</SPAN></SAMP>&#8217; </FONT>
<DD><A name=index-g_t_0024_0028_002bF_0029-1006><FONT class=extract></FONT></A><A name=index-g_t_002bF-_0040r_007b_0028automatic-variable_0029_007d-1007></A>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(+F)</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>Lists of the directory parts and the file-within-directory parts of all prerequisites, including multiple instances of duplicated prerequisites. </FONT>
<P><A name=index-g_t_0024_0028_003fD_0029-1008></A><A name=index-g_t_003fD-_0040r_007b_0028automatic-variable_0029_007d-1009></A><BR></P>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(?D)</SPAN></SAMP>&#8217; </FONT>
<DD><A name=index-g_t_0024_0028_003fF_0029-1010><FONT class=extract></FONT></A><A name=index-g_t_003fF-_0040r_007b_0028automatic-variable_0029_007d-1011></A>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>$(?F)</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>Lists of the directory parts and the file-within-directory parts of all prerequisites that are newer than the target. </FONT></DD></DL>
<P><FONT class=extract>Note that we use a special stylistic convention when we talk about these automatic variables; we write &#8220;the value of &#8216;<SAMP><SPAN class=samp>$&lt;</SPAN></SAMP>&#8217;&#8221;, rather than &#8220;the&nbsp;variable&nbsp;<CODE>&lt;</CODE>&#8221;<!-- /@w --> as we would write for ordinary variables such as <CODE>objects</CODE> and <CODE>CFLAGS</CODE>. We think this convention looks more natural in this special case. Please do not assume it has a deep significance; &#8216;<SAMP><SPAN class=samp>$&lt;</SPAN></SAMP>&#8217; refers to the variable named <CODE>&lt;</CODE> just as &#8216;<SAMP><SPAN class=samp>$(CFLAGS)</SPAN></SAMP>&#8217; refers to the variable named <CODE>CFLAGS</CODE>. You could just as well use &#8216;<SAMP><SPAN class=samp>$(&lt;)</SPAN></SAMP>&#8217; in place of &#8216;<SAMP><SPAN class=samp>$&lt;</SPAN></SAMP>&#8217;. </FONT>
<DIV class=node><A name=Pattern-Match></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Match_002dAnything-Rules" rel=next>Match-Anything Rules</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables" rel=previous>Automatic Variables</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules" rel=up>Pattern Rules</A> </DIV>
<H4 class=subsection><FONT class=extract>10.5.4 How Patterns Match</FONT></H4>
<P><A name=index-stem-1012></A><FONT class=extract>A target pattern is composed of a &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; between a prefix and a suffix, either or both of which may be empty. The pattern matches a file name only if the file name starts with the prefix and ends with the suffix, without overlap. The text between the prefix and the suffix is called the <DFN>stem</DFN>. Thus, when the pattern &#8216;<SAMP><SPAN class=samp>%.o</SPAN></SAMP>&#8217; matches the file name <SAMP><SPAN class=file>test.o</SPAN></SAMP>, the stem is &#8216;<SAMP><SPAN class=samp>test</SPAN></SAMP>&#8217;. The pattern rule prerequisites are turned into actual file names by substituting the stem for the character &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;. Thus, if in the same example one of the prerequisites is written as &#8216;<SAMP><SPAN class=samp>%.c</SPAN></SAMP>&#8217;, it expands to &#8216;<SAMP><SPAN class=samp>test.c</SPAN></SAMP>&#8217;. </FONT>
<P><FONT class=extract>When the target pattern does not contain a slash (and it usually does not), directory names in the file names are removed from the file name before it is compared with the target prefix and suffix. After the comparison of the file name to the target pattern, the directory names, along with the slash that ends them, are added on to the prerequisite file names generated from the pattern rule's prerequisite patterns and the file name. The directories are ignored only for the purpose of finding an implicit rule to use, not in the application of that rule. Thus, &#8216;<SAMP><SPAN class=samp>e%t</SPAN></SAMP>&#8217; matches the file name <SAMP><SPAN class=file>src/eat</SPAN></SAMP>, with &#8216;<SAMP><SPAN class=samp>src/a</SPAN></SAMP>&#8217; as the stem. When prerequisites are turned into file names, the directories from the stem are added at the front, while the rest of the stem is substituted for the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;. The stem &#8216;<SAMP><SPAN class=samp>src/a</SPAN></SAMP>&#8217; with a prerequisite pattern &#8216;<SAMP><SPAN class=samp>c%r</SPAN></SAMP>&#8217; gives the file name <SAMP><SPAN class=file>src/car</SPAN></SAMP>. </FONT>
<P><A name=index-pattern-rules_002c-order-of-1013></A><A name=index-order-of-pattern-rules-1014></A><FONT class=extract>A pattern rule can be used to build a given file only if there is a target pattern that matches the file name, <EM>and</EM> all prerequisites in that rule either exist or can be built. The rules you write take precedence over those that are built in. Note however, that a rule whose prerequisites actually exist or are mentioned always takes priority over a rule with prerequisites that must be made by chaining other implicit rules. </FONT>
<P><A name=index-stem_002c-shortest-1015></A><FONT class=extract>It is possible that more than one pattern rule will meet these criteria. In that case, <CODE>make</CODE> will choose the rule with the shortest stem (that is, the pattern that matches most specifically). If more than one pattern rule has the shortest stem, <CODE>make</CODE> will choose the first one found in the makefile. </FONT>
<P><FONT class=extract>This algorithm results in more specific rules being preferred over more generic ones; for example: </FONT><PRE class=example><FONT class=extract>     %.o: %.c
             $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@
     
     %.o : %.f
             $(COMPILE.F) $(OUTPUT_OPTION) $&lt;
     
     lib/%.o: lib/%.c
             $(CC) -fPIC -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@
</FONT></PRE>
<P><FONT class=extract>Given these rules and asked to build <SAMP><SPAN class=file>bar.o</SPAN></SAMP> where both <SAMP><SPAN class=file>bar.c</SPAN></SAMP> and <SAMP><SPAN class=file>bar.f</SPAN></SAMP> exist, <CODE>make</CODE> will choose the first rule and compile <SAMP><SPAN class=file>bar.c</SPAN></SAMP> into <SAMP><SPAN class=file>bar.o</SPAN></SAMP>. In the same situation where <SAMP><SPAN class=file>bar.c</SPAN></SAMP> does not exist, then <CODE>make</CODE> will choose the second rule and compile <SAMP><SPAN class=file>bar.f</SPAN></SAMP> into <SAMP><SPAN class=file>bar.o</SPAN></SAMP>. </FONT>
<P><FONT class=extract>If <CODE>make</CODE> is asked to build <SAMP><SPAN class=file>lib/bar.o</SPAN></SAMP> and both <SAMP><SPAN class=file>lib/bar.c</SPAN></SAMP> and <SAMP><SPAN class=file>lib/bar.f</SPAN></SAMP> exist, then the third rule will be chosen since the stem for this rule (&#8216;<SAMP><SPAN class=samp>bar</SPAN></SAMP>&#8217;) is shorter than the stem for the first rule (&#8216;<SAMP><SPAN class=samp>lib/bar</SPAN></SAMP>&#8217;). If <SAMP><SPAN class=file>lib/bar.c</SPAN></SAMP> does not exist then the third rule is not eligible and the second rule will be used, even though the stem is longer. </FONT>
<DIV class=node><A name=Match-Anything-Rules></A><A name=Match_002dAnything-Rules></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Canceling-Rules" rel=next>Canceling Rules</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Pattern-Match" rel=previous>Pattern Match</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules" rel=up>Pattern Rules</A> </DIV>
<H4 class=subsection><FONT class=extract>10.5.5 Match-Anything Pattern Rules</FONT></H4>
<P><A name=index-match_002danything-rule-1016></A><A name=index-terminal-rule-1017></A><FONT class=extract>When a pattern rule's target is just &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;, it matches any file name whatever. We call these rules <DFN>match-anything</DFN> rules. They are very useful, but it can take a lot of time for <CODE>make</CODE> to think about them, because it must consider every such rule for each file name listed either as a target or as a prerequisite. </FONT>
<P><FONT class=extract>Suppose the makefile mentions <SAMP><SPAN class=file>foo.c</SPAN></SAMP>. For this target, <CODE>make</CODE> would have to consider making it by linking an object file <SAMP><SPAN class=file>foo.c.o</SPAN></SAMP>, or by C compilation-and-linking in one step from <SAMP><SPAN class=file>foo.c.c</SPAN></SAMP>, or by Pascal compilation-and-linking from <SAMP><SPAN class=file>foo.c.p</SPAN></SAMP>, and many other possibilities. </FONT>
<P><FONT class=extract>We know these possibilities are ridiculous since <SAMP><SPAN class=file>foo.c</SPAN></SAMP> is a C source file, not an executable. If <CODE>make</CODE> did consider these possibilities, it would ultimately reject them, because files such as <SAMP><SPAN class=file>foo.c.o</SPAN></SAMP> and <SAMP><SPAN class=file>foo.c.p</SPAN></SAMP> would not exist. But these possibilities are so numerous that <CODE>make</CODE> would run very slowly if it had to consider them. </FONT>
<P><FONT class=extract>To gain speed, we have put various constraints on the way <CODE>make</CODE> considers match-anything rules. There are two different constraints that can be applied, and each time you define a match-anything rule you must choose one or the other for that rule. </FONT>
<P><FONT class=extract>One choice is to mark the match-anything rule as <DFN>terminal</DFN> by defining it with a double colon. When a rule is terminal, it does not apply unless its prerequisites actually exist. Prerequisites that could be made with other implicit rules are not good enough. In other words, no further chaining is allowed beyond a terminal rule. </FONT>
<P><FONT class=extract>For example, the built-in implicit rules for extracting sources from RCS and SCCS files are terminal; as a result, if the file <SAMP><SPAN class=file>foo.c,v</SPAN></SAMP> does not exist, <CODE>make</CODE> will not even consider trying to make it as an intermediate file from <SAMP><SPAN class=file>foo.c,v.o</SPAN></SAMP> or from <SAMP><SPAN class=file>RCS/SCCS/s.foo.c,v</SPAN></SAMP>. RCS and SCCS files are generally ultimate source files, which should not be remade from any other files; therefore, <CODE>make</CODE> can save time by not looking for ways to remake them. </FONT>
<P><FONT class=extract>If you do not mark the match-anything rule as terminal, then it is non-terminal. A non-terminal match-anything rule cannot apply to a file name that indicates a specific type of data. A file name indicates a specific type of data if some non-match-anything implicit rule target matches it. </FONT>
<P><FONT class=extract>For example, the file name <SAMP><SPAN class=file>foo.c</SPAN></SAMP> matches the target for the pattern rule &#8216;<SAMP><SPAN class=samp>%.c : %.y</SPAN></SAMP>&#8217; (the rule to run Yacc). Regardless of whether this rule is actually applicable (which happens only if there is a file <SAMP><SPAN class=file>foo.y</SPAN></SAMP>), the fact that its target matches is enough to prevent consideration of any non-terminal match-anything rules for the file <SAMP><SPAN class=file>foo.c</SPAN></SAMP>. Thus, <CODE>make</CODE> will not even consider trying to make <SAMP><SPAN class=file>foo.c</SPAN></SAMP> as an executable file from <SAMP><SPAN class=file>foo.c.o</SPAN></SAMP>, <SAMP><SPAN class=file>foo.c.c</SPAN></SAMP>, <SAMP><SPAN class=file>foo.c.p</SPAN></SAMP>, etc. </FONT>
<P><FONT class=extract>The motivation for this constraint is that non-terminal match-anything rules are used for making files containing specific types of data (such as executable files) and a file name with a recognized suffix indicates some other specific type of data (such as a C source file). </FONT>
<P><FONT class=extract>Special built-in dummy pattern rules are provided solely to recognize certain file names so that non-terminal match-anything rules will not be considered. These dummy rules have no prerequisites and no recipes, and they are ignored for all other purposes. For example, the built-in implicit rule </FONT><PRE class=example><FONT class=extract>     %.p :
</FONT></PRE>
<P class=noindent><FONT class=extract>exists to make sure that Pascal source files such as <SAMP><SPAN class=file>foo.p</SPAN></SAMP> match a specific target pattern and thereby prevent time from being wasted looking for <SAMP><SPAN class=file>foo.p.o</SPAN></SAMP> or <SAMP><SPAN class=file>foo.p.c</SPAN></SAMP>. </FONT>
<P><FONT class=extract>Dummy pattern rules such as the one for &#8216;<SAMP><SPAN class=samp>%.p</SPAN></SAMP>&#8217; are made for every suffix listed as valid for use in suffix rules (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Suffix-Rules"><FONT class=extract>Old-Fashioned Suffix Rules</FONT></A><FONT class=extract>).</FONT> 
<DIV class=node><A name=Canceling-Rules></A>
<P>
<HR>
Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Match_002dAnything-Rules" rel=previous>Match-Anything Rules</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules" rel=up>Pattern Rules</A> </DIV>
<H4 class=subsection><FONT class=extract>10.5.6 Canceling Implicit Rules</FONT></H4>
<P><FONT class=extract>You can override a built-in implicit rule (or one you have defined yourself) by defining a new pattern rule with the same target and prerequisites, but a different recipe. When the new rule is defined, the built-in one is replaced. The new rule's position in the sequence of implicit rules is determined by where you write the new rule. </FONT>
<P><FONT class=extract>You can cancel a built-in implicit rule by defining a pattern rule with the same target and prerequisites, but no recipe. For example, the following would cancel the rule that runs the assembler: </FONT><PRE class=example><FONT class=extract>     %.o : %.s</FONT>
</PRE>
<DIV class=node><A name=Last-Resort></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Suffix-Rules" rel=next>Suffix Rules</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules" rel=previous>Pattern Rules</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules" rel=up>Implicit Rules</A> </DIV>
<H3 class=section><FONT class=extract>10.6 Defining Last-Resort Default Rules</FONT></H3>
<P><A name=index-last_002dresort-default-rules-1018></A><A name=index-default-rules_002c-last_002dresort-1019></A><FONT class=extract>You can define a last-resort implicit rule by writing a terminal match-anything pattern rule with no prerequisites (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Match_002dAnything-Rules"><FONT class=extract>Match-Anything Rules</FONT></A><FONT class=extract>). This is just like any other pattern rule; the only thing special about it is that it will match any target. So such a rule's recipe is used for all targets and prerequisites that have no recipe of their own and for which no other implicit rule applies. </FONT>
<P><FONT class=extract>For example, when testing a makefile, you might not care if the source files contain real data, only that they exist. Then you might do this: </FONT><PRE class=example><FONT class=extract>     %::
             touch $@
</FONT></PRE>
<P class=noindent><FONT class=extract>to cause all the source files needed (as prerequisites) to be created automatically. </FONT>
<P><A name=index-g_t_002eDEFAULT-1020></A><FONT class=extract>You can instead define a recipe to be used for targets for which there are no rules at all, even ones which don't specify recipes. You do this by writing a rule for the target <CODE>.DEFAULT</CODE>. Such a rule's recipe is used for all prerequisites which do not appear as targets in any explicit rule, and for which no implicit rule applies. Naturally, there is no <CODE>.DEFAULT</CODE> rule unless you write one. </FONT>
<P><FONT class=extract>If you use <CODE>.DEFAULT</CODE> with no recipe or prerequisites: </FONT><PRE class=example><FONT class=extract>     .DEFAULT:
</FONT></PRE>
<P class=noindent><FONT class=extract>the recipe previously stored for <CODE>.DEFAULT</CODE> is cleared. Then <CODE>make</CODE> acts as if you had never defined <CODE>.DEFAULT</CODE> at all. </FONT>
<P><FONT class=extract>If you do not want a target to get the recipe from a match-anything pattern rule or <CODE>.DEFAULT</CODE>, but you also do not want any recipe to be run for the target, you can give it an empty recipe (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Empty-Recipes"><FONT class=extract>Defining Empty Recipes</FONT></A><FONT class=extract>). </FONT>
<P><FONT class=extract>You can use a last-resort rule to override part of another makefile. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Overriding-Makefiles"><FONT class=extract>Overriding Part of Another Makefile</FONT></A><FONT class=extract>. </FONT>
<DIV class=node><A name=Suffix-Rules></A>
<P>
<HR>
Next:&nbsp;<A accessKey=n href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rule-Search" rel=next>Implicit Rule Search</A>, Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Last-Resort" rel=previous>Last Resort</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules" rel=up>Implicit Rules</A> </DIV>
<H3 class=section><FONT class=extract>10.7 Old-Fashioned Suffix Rules</FONT></H3>
<P><A name=index-old_002dfashioned-suffix-rules-1021></A><A name=index-suffix-rule-1022></A><FONT class=extract><DFN>Suffix rules</DFN> are the old-fashioned way of defining implicit rules for <CODE>make</CODE>. Suffix rules are obsolete because pattern rules are more general and clearer. They are supported in GNU <CODE>make</CODE> for compatibility with old makefiles. They come in two kinds: <DFN>double-suffix</DFN> and <DFN>single-suffix</DFN>. </FONT>
<P><FONT class=extract>A double-suffix rule is defined by a pair of suffixes: the target suffix and the source suffix. It matches any file whose name ends with the target suffix. The corresponding implicit prerequisite is made by replacing the target suffix with the source suffix in the file name. A two-suffix rule whose target and source suffixes are &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; is equivalent to the pattern rule &#8216;<SAMP><SPAN class=samp>%.o : %.c</SPAN></SAMP>&#8217;. </FONT>
<P><FONT class=extract>A single-suffix rule is defined by a single suffix, which is the source suffix. It matches any file name, and the corresponding implicit prerequisite name is made by appending the source suffix. A single-suffix rule whose source suffix is &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; is equivalent to the pattern rule &#8216;<SAMP><SPAN class=samp>% : %.c</SPAN></SAMP>&#8217;. </FONT>
<P><FONT class=extract>Suffix rule definitions are recognized by comparing each rule's target against a defined list of known suffixes. When <CODE>make</CODE> sees a rule whose target is a known suffix, this rule is considered a single-suffix rule. When <CODE>make</CODE> sees a rule whose target is two known suffixes concatenated, this rule is taken as a double-suffix rule. </FONT>
<P><FONT class=extract>For example, &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; are both on the default list of known suffixes. Therefore, if you define a rule whose target is &#8216;<SAMP><SPAN class=samp>.c.o</SPAN></SAMP>&#8217;, <CODE>make</CODE> takes it to be a double-suffix rule with source suffix &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; and target suffix &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217;. Here is the old-fashioned way to define the rule for compiling a C source file: </FONT><PRE class=example><FONT class=extract>     .c.o:
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;
</FONT></PRE>
<P><FONT class=extract>Suffix rules cannot have any prerequisites of their own. If they have any, they are treated as normal files with funny names, not as suffix rules. Thus, the rule: </FONT><PRE class=example><FONT class=extract>     .c.o: foo.h
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;
</FONT></PRE>
<P class=noindent><FONT class=extract>tells how to make the file <SAMP><SPAN class=file>.c.o</SPAN></SAMP> from the prerequisite file <SAMP><SPAN class=file>foo.h</SPAN></SAMP>, and is not at all like the pattern rule: </FONT><PRE class=example><FONT class=extract>     %.o: %.c foo.h
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;
</FONT></PRE>
<P class=noindent><FONT class=extract>which tells how to make &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; files from &#8216;<SAMP><SPAN class=samp>.c</SPAN></SAMP>&#8217; files, and makes all &#8216;<SAMP><SPAN class=samp>.o</SPAN></SAMP>&#8217; files using this pattern rule also depend on <SAMP><SPAN class=file>foo.h</SPAN></SAMP>. </FONT>
<P><FONT class=extract>Suffix rules with no recipe are also meaningless. They do not remove previous rules as do pattern rules with no recipe (see </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Canceling-Rules"><FONT class=extract>Canceling Implicit Rules</FONT></A><FONT class=extract>). They simply enter the suffix or pair of suffixes concatenated as a target in the data base. </FONT>
<P><A name=index-g_t_002eSUFFIXES-1023></A><FONT class=extract>The known suffixes are simply the names of the prerequisites of the special target <CODE>.SUFFIXES</CODE>. You can add your own suffixes by writing a rule for <CODE>.SUFFIXES</CODE> that adds more prerequisites, as in: </FONT><PRE class=example><FONT class=extract>     .SUFFIXES: .hack .win
</FONT></PRE>
<P class=noindent><FONT class=extract>which adds &#8216;<SAMP><SPAN class=samp>.hack</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>.win</SPAN></SAMP>&#8217; to the end of the list of suffixes. </FONT>
<P><FONT class=extract>If you wish to eliminate the default known suffixes instead of just adding to them, write a rule for <CODE>.SUFFIXES</CODE> with no prerequisites. By special dispensation, this eliminates all existing prerequisites of <CODE>.SUFFIXES</CODE>. You can then write another rule to add the suffixes you want. For example, </FONT><PRE class=example><FONT class=extract>     .SUFFIXES:            # <SPAN class=roman><FONT face="Times New Roman">Delete the default suffixes</FONT></SPAN>
     .SUFFIXES: .c .o .h   # <SPAN class=roman><FONT face="Times New Roman">Define our suffix list</FONT></SPAN>
</FONT></PRE>
<P><FONT class=extract>The &#8216;<SAMP><SPAN class=samp>-r</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>--no-builtin-rules</SPAN></SAMP>&#8217; flag causes the default list of suffixes to be empty. </FONT>
<P><A name=index-SUFFIXES-1024></A><FONT class=extract>The variable <CODE>SUFFIXES</CODE> is defined to the default list of suffixes before <CODE>make</CODE> reads any makefiles. You can change the list of suffixes with a rule for the special target <CODE>.SUFFIXES</CODE>, but that does not alter this variable. </FONT>
<DIV class=node><A name=Implicit-Rule-Search></A>
<P>
<HR>
Previous:&nbsp;<A accessKey=p href="https://www.gnu.org/software/make/manual/make.html#Suffix-Rules" rel=previous>Suffix Rules</A>, Up:&nbsp;<A accessKey=u href="https://www.gnu.org/software/make/manual/make.html#Implicit-Rules" rel=up>Implicit Rules</A> </DIV>
<H3 class=section><FONT class=extract>10.8 Implicit Rule Search Algorithm</FONT></H3>
<P><A name=index-implicit-rule_002c-search-algorithm-1025></A><A name=index-search-algorithm_002c-implicit-rule-1026></A><FONT class=extract>Here is the procedure <CODE>make</CODE> uses for searching for an implicit rule for a target <VAR>t</VAR>. This procedure is followed for each double-colon rule with no recipe, for each target of ordinary rules none of which have a recipe, and for each prerequisite that is not the target of any rule. It is also followed recursively for prerequisites that come from implicit rules, in the search for a chain of rules. </FONT>
<P><FONT class=extract>Suffix rules are not mentioned in this algorithm because suffix rules are converted to equivalent pattern rules once the makefiles have been read in. </FONT>
<P><FONT class=extract>For an archive member target of the form &#8216;<SAMP><VAR>archive</VAR><SPAN class=samp>(</SPAN><VAR>member</VAR><SPAN class=samp>)</SPAN></SAMP>&#8217;, the following algorithm is run twice, first using the entire target name <VAR>t</VAR>, and second using &#8216;<SAMP><SPAN class=samp>(</SPAN><VAR>member</VAR><SPAN class=samp>)</SPAN></SAMP>&#8217; as the target <VAR>t</VAR> if the first run found no rule. </FONT>
<OL type=1>
<LI><FONT class=extract>Split <VAR>t</VAR> into a directory part, called <VAR>d</VAR>, and the rest, called <VAR>n</VAR>. For example, if <VAR>t</VAR> is &#8216;<SAMP><SPAN class=samp>src/foo.o</SPAN></SAMP>&#8217;, then <VAR>d</VAR> is &#8216;<SAMP><SPAN class=samp>src/</SPAN></SAMP>&#8217; and <VAR>n</VAR> is &#8216;<SAMP><SPAN class=samp>foo.o</SPAN></SAMP>&#8217;. </FONT>
<LI><FONT class=extract>Make a list of all the pattern rules one of whose targets matches <VAR>t</VAR> or <VAR>n</VAR>. If the target pattern contains a slash, it is matched against <VAR>t</VAR>; otherwise, against <VAR>n</VAR>. </FONT>
<LI><FONT class=extract>If any rule in that list is <EM>not</EM> a match-anything rule, then remove all non-terminal match-anything rules from the list. </FONT>
<LI><FONT class=extract>Remove from the list all rules with no recipe. </FONT>
<LI><FONT class=extract>For each pattern rule in the list: </FONT>
<OL type=a>
<LI><FONT class=extract>Find the stem <VAR>s</VAR>, which is the nonempty part of <VAR>t</VAR> or <VAR>n</VAR> matched by the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; in the target pattern. </FONT>
<LI><FONT class=extract>Compute the prerequisite names by substituting <VAR>s</VAR> for &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;; if the target pattern does not contain a slash, append <VAR>d</VAR> to the front of each prerequisite name. </FONT>
<LI><FONT class=extract>Test whether all the prerequisites exist or ought to exist. (If a file name is mentioned in the makefile as a target or as an explicit prerequisite, then we say it ought to exist.) </FONT>
<P><FONT class=extract>If all prerequisites exist or ought to exist, or there are no prerequisites, then this rule applies. </FONT></P></LI></OL>
<LI><FONT class=extract>If no pattern rule has been found so far, try harder. For each pattern rule in the list: </FONT>
<OL type=a>
<LI><FONT class=extract>If the rule is terminal, ignore it and go on to the next rule. </FONT>
<LI><FONT class=extract>Compute the prerequisite names as before. </FONT>
<LI><FONT class=extract>Test whether all the prerequisites exist or ought to exist. </FONT>
<LI><FONT class=extract>For each prerequisite that does not exist, follow this algorithm recursively to see if the prerequisite can be made by an implicit rule. </FONT>
<LI><FONT class=extract>If all prerequisites exist, ought to exist, or can be made by implicit rules, then this rule applies. </FONT></LI></OL>
<LI><FONT class=extract>If no implicit rule applies, the rule for <CODE>.DEFAULT</CODE>, if any, applies. In that case, give <VAR>t</VAR> the same recipe that <CODE>.DEFAULT</CODE> has. Otherwise, there is no recipe for <VAR>t</VAR>. </FONT></LI></OL>
<P><FONT class=extract>Once a rule that applies has been found, for each target pattern of the rule other than the one that matched <VAR>t</VAR> or <VAR>n</VAR>, the &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; in the pattern is replaced with <VAR>s</VAR> and the resultant file name is stored until the recipe to remake the target file <VAR>t</VAR> is executed. After the recipe is executed, each of these stored file names are entered into the data base and marked as having been updated and having the same update status as the file <VAR>t</VAR>. </FONT>
<P><FONT class=extract>When the recipe of a pattern rule is executed for <VAR>t</VAR>, the automatic variables are set corresponding to the target and prerequisites. See </FONT><A href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables"><FONT class=extract>Automatic Variables</FONT></A><FONT class=extract>.</FONT>