<B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">9.1.2.1 Introduction </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The <I>simple sockets </I>are so-called because they are intended to be simple to use. They are derived from the interoperability layer sockets <B>tlm_initiator_socket </B>and <B>tlm_target_socket</B>, so can be bound directly to sockets of those types</SPAN><SPAN lang=EN-US style="FONT-SIZE: 13pt; COLOR: black; mso-bidi-font-size: 8.0pt; mso-font-kerning: 0pt">. </SPAN><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Instead of having to bind a socket to an object that implements the corresponding interface, each simple socket provides methods for registering callback methods. Those callbacks are in turn called whenever an incoming interface method call arrives. Callback methods may be registered for each of the interfaces supported by the socket. The user of a simple socket may register a callback for every interface method, but is not obliged to do so. In particular, for the simple target socket, the user need only register one of <B>b_transport </B>and <B>nb_transport_fw</B>, in which case incoming calls to the unregistered method will be converted automatically to calls to the registered method. This conversion process is non-trivial, and is dependent upon the rules of the base protocol being respected by the initiator and target.. The <B>passthrough_target_socket </B>is a variant of the <B>simple_target_socket </B>that does not support conversion between blocking and non-blocking calls. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The current implementation of simple sockets makes use of dynamic processes. Hence, when compiling applications that use simple sockets with current released versions of the OSCI proof-of-concept simulator, it is necessary to define the macro SC_INCLUDE_DYNAMIC_PROCESSES before including the SystemC header file. </SPAN>