<B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">8.2.7 Base protocol rules concerning timing annotation </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">a) These rules should be read in conjunction with 4.1.3 Timing annotation with the transport interfaces </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">b) There are constraints on the way in which the implementations of <B>b_transport </B>and <I>nb_transport </I>are permitted to modify the time argument <B>t </B>such that the effective local time <B>sc_time_stamp() + t </B>is non-decreasing between function call and return. See 4.1.3.1 The sc_time argument </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">c) For successive calls to and returns from <I>nb_transport </I>through a given socket for a given transaction, the sequence of effective local times shall be non-decreasing. The effective local time is given by the expression <B>sc_time_stamp() + t</B>, where <B>t </B>is the time argument to <I>nb_transport</I>. For this purpose, both calls to and returns from the function shall be considered as part of a single sequence. This applies on the forward and backward paths alike. The intent is that time should not run backwards for a given transaction. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">d) The preceding rule also applies between the call to and the return from <B>b_transport</B>. Again, see 4.1.3.1 The sc_time argument </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">e) Moreover, for a given transaction object, as requests are propagated from initiator towards target and responses are propagated from target back towards initiator, the sequence of effective local times given by each successive transport method call and return shall be non-decreasing. Request propagation in this sense includes calls to <B>b_transport </B>and the BEGIN_REQ phase. Response propagation includes returns from <B>b_transport</B>, the BEGIN_RESP phase, and TLM_COMPLETED. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">f) The effective local time may be increased by increasing the value of the timing annotation (the time argument), by advancing SystemC simulation time (<B>b_transport </B>only), or both. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">g) For <I>different </I>transaction objects, there is no obligation that the effective local times of calls to <B>b_transport </B>and <I>nb_transport </I>shall be non-decreasing. Nonetheless, each initiator process is generally recommended to call <B>b_transport </B>and/or <I>nb_transport </I>in non-decreasing effecti<B>v</B>e local time order. Otherwise, downstream components would infer that the out-of-order transactions had originated from separate initiators and would be free to choose the order in which those particular transactions were executed. However, transactions with out-of-order effective local times may arise wherever streams of transactions from different loosely-timed initiators converge<I>. </I></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">h) For a given socket, an initiator is allowed to pass the same transaction object at different times through the blocking and non-blocking transport interfaces, the direct memory interface, and the transport debug interface, Also, an initiator is permitted to re-use the same trans<I>action </I>object fo<I>r different </I>transaction instances, all subject to the memory management rules of the generic payload. See 7.5 Generic payload memory management. </SPAN>