<HEAD></HEAD>
<BODY><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">9.2.4 General guidelines for processes using temporal decoupling </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN>
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">a) For maximum simulation speed, all initiators should use temporal decoupling, and the number of other runnable SystemC processes should be zero or minimized. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">b) In an ideal scenario, the only runnable SystemC processes will belong to temporally decoupled initiators, and each process will run ahead to the end of its time quantum before yielding to the SystemC kernel. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">c) A temporally decoupled initiator is not obliged to use a time quantum if communication with other processes is explicitly synchronized. Where a time quantum is used, it should be chosen to be less than the typical communication interval between initiators, otherwise important process interactions may be lost, and the model broken. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">d) <I>Yield </I>means call <B>wait </B>in the case of a thread process, or return from the function in the case of a method process. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">e) Temporal decoupling runs in the context of the standard SystemC simulation kernel, so events can be scheduled, processes suspended and resumed, and loosely-timed models can be mixed with other coding styles. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">f) There is no obligation for every initiator to use temporal decoupling. Processes with and without temporal decoupling can be mixed. However, any process that is not temporally decoupled is likely to become a simulation speed bottleneck. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">g) Each temporally decoupled initiator may accumulate any local processing delays and communication delays in a local variable, referred to in this clause as the <I>local time offset</I>. It is recommended that the quantum keeper should be used to maintain the local time offset. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">h) Calls to the <B>sc_time_stamp </B>method will return the simulation time as it was at or near the start of the current time quantum. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: 'Lucida Console'; mso-bidi-font-size: 9.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: 'Lucida Console'"><?xml:namespace prefix = v /><v:shapetype id=_x0000_t75 coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"><v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"></v:path><?xml:namespace prefix = o /><o:lock v:ext="edit" aspectratio="t"></o:lock></v:shapetype><v:shape id=_x0000_i1025 style="WIDTH: 590.25pt; HEIGHT: 431.25pt" type="#_x0000_t75"><v:imagedata src="file:///C:\DOCUME~1\DONPOP~1\LOCALS~1\Temp\msohtml1\01\clip_image001.emz" o:title=""></v:imagedata></v:shape></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 17pt; COLOR: black; mso-bidi-font-size: 12.0pt; mso-font-kerning: 0pt">&nbsp;</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">i) The local time offset is unknown to the SystemC scheduler. When using the transport interfaces, the local time offset should be passed as an argument to the <B>b_transport </B>or <I>nb_transport </I>methods. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">j) Use of the <I>nb_transport </I>method with temporal decoupling and the quantum keeper is not ruled out, but is not usually advantageous because the speed advantage to be gained from temporal decoupling would be nullified by the high degree of inter-process communication inherent in the approximately-timed coding style. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">k) The order in which processes resume within the quantum is under the control of the SystemC scheduler, and by the rules of SystemC, is indeterminate. In the absence of any explicit synchronization mechanism, if a variable is modified by one such process and read by another, the value to be read will be indeterminate. The new value may become available in the current quantum or the next quantum, assuming it only changes relatively infrequently compared to the quantum length, and the application would need to be tolerant of precisely when the new value becomes available. If this is not the case, the application should guard the variable access with an appropriate synchronization mechanism. </SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">l) Any access to a variable or object from a temporally decoupled process will give the value it had at the start of the current time quantum unless it has been modified by the current process or by another temporally decoupled process that has already run in the current quantum. In particular, any <B>sc_signal </B>accessed from a temporally decoupled process will have the same value it had at the start of the current time quantum. This is a consequence of the fact that conventional SystemC simulation time (as returned by <B>sc_time_stamp</B>) does not advance within the quantum. </SPAN></P></BODY>