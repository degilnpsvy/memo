<B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">9.3.1 Introduction </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A payload event queue (PEQ) is a class that maintains a queue of SystemC event notifications, where each notification carries an associated transaction object. Each transaction is written into the PEQ annotated with a delay, and each transaction emerges from the back of the PEQ at a time calculated from the current simulation time plus the annotated delay. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Two payload event queues are provided as utilities. As well as being useful in their own right, the PEQ is of conceptual relevance in understanding the semantics of timing annotation with the approximately-timed coding style. However, it is possible to implement approximately-timed models without using the specific payload event queues given here. In an approximately-timed model, it is often appropriate for the recipient of a transaction passed using <I>nb_transport </I>to put the transaction into a PEQ with the annotated delay. The PEQ will schedule the timing point associated with the <I>nb_transport </I>call to occur at the correct simulation time. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Transactions are inserted into a PEQ by calling the <B>notify </B>method of the PEQ, passing a delay as an argument. There is also a <B>notify </B>method that schedules an immediate notification. The delay is added to the current simulation time (<B>sc_time_stamp</B>) to calculate the time at which the transaction will emerge from the back end of the PEQ. The scheduling of the events is managed internally using a SystemC timed event notification, exploiting the property of class <B>sc_event </B>that if the <B>notify </B>method is called whilst there is a notification pending, the notification with the earliest simulation time will remain while the other notification gets cancelled. Transactions emerge in different ways from the two PEQ variants. In the case of <B>peq_with_get</B>, the method <B>get_event </B>returns an event that is notified whenever a transaction is ready to be retrieved. The method <B>get_next_transaction </B>should be called repeatedly to retrieve any available transactions one at a time. In the case of <B>peq_with_cb_and_phase</B>, a callback method is registered as a constructor argument, and that method is called as each transaction emerges. This particular PEQ carries both a transaction object and a phase object with each notification, and both are passed as arguments to the callback method. </SPAN></P><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; FONT-FAMILY: 'Times New Roman'; mso-bidi-font-size: 10.0pt; mso-fareast-font-family: &#23435;&#20307;; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA">For an example, see 8.1 Phases The current implementation of <B>peq_with_cb_and_phase </B>makes use of dynamic processes. Hence, when compiling applications that use <B>peq_with_cb_and_phase </B>with current released versions of the OSCI proof-of-concept simulator, it is necessary to define the macro SC_INCLUDE_DYNAMIC_PROCESSES before including the SystemC header file.</SPAN>