<B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 11.5pt; mso-font-kerning: 0pt">11 Glossary </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; COLOR: black; FONT-FAMILY: Arial; mso-bidi-font-size: 11.5pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Blue = taken from the SystemC LRM </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">This glossary contains brief, informal descriptions for a number of terms and phrases used in this standard. Where appropriate, the complete, formal definition of each term or phrase is given in the main body of the standard. Each glossary entry contains either the clause number of the definition in the main body of the standard or an indication that the term is defined in ISO/IEC 14882:2003 or IEEE Std 1666-2005. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">adapter: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A module that connects a transaction level interface to a pin level interface (in the general sense of the word interface) or that connects together two transaction level interfaces, often at different abstraction levels. An adapter may be used to convert between two sockets specialized with different protocol types. See <I>bridge, transactor</I>. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">approximately timed: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A modeling style for which there exists a one-to-one mapping between the externally observable states of the model and the states of some corresponding detailed reference model such that the mapping preserves the sequence of state transitions but not their precise timing. The degree of timing accuracy is undefined. See <I>cycle approximate</I>. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">attribute (of a transaction): </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Data that is part of and carried with the transaction and is implemented as a member of the transaction object. These may include attributes inherent in the bus or protocol being modeled, and attributes that are artefacts of the simulation model (a timestamp, for example). </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">automatic deletion: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A generic payload extension marked for automatic deletion will be deleted at the end of the transaction lifetime, that is, when the transaction reference count reaches 0. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">backward path: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The calling path by which a target or interconnect component makes interface method calls back in the direction of another interconnect component or the initiator. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">base protocol: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A protocol traits class consisting of the generic payload and tlm_phase types, together with an associated set of protocol rules which together ensure maximal interoperability between transaction-level models </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">bidirectional interface: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A TLM-1 transaction level interface in which a pair of transaction objects, the request and the response, are passed in opposite directions, each being passed according to the rules of the unidirectional interface. For each transaction object, the transaction attributes are strictly readonly in the period between the first timing point and the end of the transaction lifetime. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">blocking: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Permitted to call the <B>wait </B>method. A blocking function may consume simulation time or perform a context switch, and therefore shall not be called from a method process. A blocking interface defines only blocking functions. <B>blocking transport interface: </B>A blocking interface of the TLM-2.0 standard which contains a single method </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">b_transport</SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">. Beware that there still exists a blocking transport method named <B>transport</B>, part of TLM-1. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">bridge: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A component connecting two segments of a communication network together. A bus bridge is a device that connects two similar or dissimilar memory-mapped buses together. See <I>adapter, transaction bridge, transactor</I>.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">caller: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">In a function call, the sequence of statements from which the given function is called. The referent of the term may be a function, a process, or a module. This term is used in preference to <I>initiator </I>to refer to the caller of a function as opposed to the initiator of a transaction. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">callee: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">In a function call, the function that is called by the caller. This term is used in preference to <I>target </I>to refer to the function body as opposed to the target of a transaction. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">channel: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A class that implements one or more interfaces or an instance of such a class. A channel may be a hierarchical channel or a primitive channel or, if neither of these, it is strongly recommended that a channel at least be derived from class <B>sc_object</B>. Channels serve to encapsulate the definition of a communication mechanism or protocol. (SystemC term) </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">child: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">An instance that is within a given module. Module A is a <I>child </I>of module B if module A is <I>within </I>module B. (SystemC Term) </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">combined interfaces: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">Pre-defined groups of core interfaces used to parameterize the socket classes. There are four combined interfaces: the blocking and non-blocking forward and backward interfaces. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">component</SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">: An instance of a SystemC module. This standard recognizes three kinds of component; the initiator, interconnect component, and target. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">convenience socket: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A socket class, derived from <B>tlm_initiator_socket </B>or <B>tlm_target_socket</B>, that implements some additional functionality and is provided for convenience. Several convenience sockets are provided as utilities. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">core interface: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">One of the specific transaction level interfaces defined in this standard, including the blocking and non-blocking transport interface, the direct memory interface, and the debug transport interface. Each core interface is an <I>interface proper</I>. The core interfaces are distinct from the generic payload API. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">cycle accurate: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A modeling style in which it is possible to predict the state of the model in any given cycle at the external boundary of the model and thus to establish a one-to-one correspondence between the states of the model and the externally observable states of a corresponding RTL model in each cycle, but which is not required to explicitly re-evaluate the state of the entire model in every cycle or to explicitly represent the state of every boundary pin or internal register. This term is only applicable to models that have a notion of cycles. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">cycle approximate: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A model for which there exists a one-to-one mapping between the externally observable states of the model and the states of some corresponding cycle accurate model such that the mapping preserves the sequence of state transitions but not their precise timing. The degree of timing accuracy is undefined. This term is only applicable to models that have a notion of cycles. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">cycle count accurate, cycle count accurate at transaction boundaries: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A modeling style in which it is possible to establish a one-to-one correspondence between the states of the model and the externally observable states of a corresponding RTL model as sampled at the timing points marking the boundaries of a transaction. A cycle count accurate model is not required to be cycle accurate in every cycle, but is required to accurately predict both the functional state and the number of cycles at certain key timing points as defined by the boundaries of the transactions through which the model communicates with other models. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">declaration: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A C++ language construct that introduces a name into a C++ program and specifies how the C++ compiler is to interpret that name. Not all declarations are definitions. For example, a class declaration specifies the name of the class but not the class members, while a function declaration specifies the function parameters but not the function body. (See definition.) (C++ term)</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">definition: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The complete specification of a variable, function, type, or template. For example, a class definition specifies the class name and the class members, and a function definition specifies the function parameters and the function body. (See declaration.) (C++ term) </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">effective local time: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The current time within a temporally decoupled initiator. effective_local_time = sc_time_stamp() + local_time_offset </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">exclusion rule: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A rule of the base protocol that prevents a request or a response being sent through a socket if there is already a request or a response (respectively) in progress through that socket. The base protocol has two exclusion rules, the request exclusion rule and the response exclusion rule, which act independently of one another. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">extension: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A user-defined object added to and carried around with a generic payload transaction object, or a user-defined class that extends the set of values that are assignment compatible with the tlm_phase type. An ignorable extension may be used with the base protocol, but a non-ignorable or mandatory extension requires the definition of a new protocol traits class. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">forward path: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The calling path by which an initiator or interconnect component makes interface method calls forward in the direction of another interconnect component or the target. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">generic payload: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A specific set of transaction attributes and their semantics together defining a transaction payload which may be used to achieve a degree of interoperability between loosely timed and approximately timed models for components communicating over a memory-mapped bus. The same transaction class is used for all modeling styles. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">global quantum: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The default time quantum used by every quantum keeper and temporally decoupled initiator. The intent is that all temporally decoupled initiators should typically synchronize on integer multiples of the global quantum, or more frequently on demand. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">hierarchical binding: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">Binding a socket on a child module to a socket on a parent module, or a socket on a parent module to a socket on a child module, passing transactions up or down the module hierarchy. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">hop: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The interface method call path between two adjacent components en route from initiator to target. A hop consists of one initiator socket bound to one target socket. In order to be transported from initiator to target, a transaction may need to pass over multiple hops. The number of hops between an initiator and a target is always one greater than the number of interconnect components. <B>ignorable extension: </B>A generic payload extension that may be ignored by any component other than the component that set the extension. An ignorable extension is not required to be present. Ignorable extensions are permitted by the base protocol. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">ignorable phase: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A phase, created by the macro DECLARE_EXTENDED PHASE, that may be ignored by any component that receives the phase and that cannot demand a response of any kind. Ignorable phases are permitted by the base protocol. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">initiator: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A module that can initiate transactions. The initiator is responsible for initializing the state of the transaction object, and for deleting or reusing the transaction object at the end of the transaction&#8216;s lifetime. An initiator is usually a master and a master is usually an initiator, but the term <I>initiator </I>means that a component can initiate transactions, whereas the term <I>master </I>means that a component can take control of a bus. In the case of the TLM-1 interfaces, the term <I>initiator </I>as defined here may not be strictly applicable, so the terms <I>caller </I>and <I>callee </I>may be used instead for clarity.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">initiator socket: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A class containing a port for interface method calls on the forward path and an export for interface method calls on the backward path. A socket overloads the SystemC binding operators to bind both the port and the export. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">interconnect component: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A module that accesses a transaction object, but does not act as an initiator or a target with respect to that transaction. An interconnect component may or may not be permitted to modify the attributes of the transaction object, depending on the rules of the payload. An arbiter or a router would typically be modeled as an interconnect component, the alternative being to model it as a target for one transaction and an initiator for a separate transaction. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">interface: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A class derived from class <B>sc_interface</B>. An interface proper is an interface, and in the object-oriented sense a channel is also an interface. However, a channel is not an interface proper. (SystemC term) </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">Interface Method Call (IMC): </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A call to an interface method. An interface method is a member function declared within an interface. The IMC paradigm provides a level of indirection between a method call and the implementation of the method within a channel such that one channel can be substituted with another without affecting the caller. (SystemC term) </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">interface proper: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">An abstract class derived from class <B>sc_interface </B>but not derived from class <B>sc_object</B>. An interface proper declares the set of methods to be implemented within a channel and to be called through a port. An interface proper contains pure virtual function declarations, but typically contains no function definitions and no data members. (SystemC term) </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">interoperability: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The ability of two or more transaction level models from diverse sources to exchange information using the interfaces defined in this standard. The intent is that models that implement common memory-mapped bus protocols in the programmers view use case should be interoperable without the need for explicit adapters. Furthermore, the intent is to reduce the amount of engineering effort needed to achieve interoperability for models of divergent protocols or use cases, although it is expected that adapters will be required in general. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">interoperability layer: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The subset of classes in this standard that are necessary for interoperability. The interoperability layer comprises the TLM-2.0 core interfaces, the initiator and target sockets, the generic payload, <B>tlm_global_quantum </B>and <B>tlm_phase</B>. Closely related to the base protocol. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">lifetime (of an object): </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The lifetime of an object starts when storage is allocated and the constructor call has completed, if any. The lifetime of an object ends when storage is released or immediately before the destructor is called, if any. (C++ term) </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">lifetime (of a transaction): </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The period of time that starts when the transaction becomes valid and ends when the transaction becomes invalid. Because it is possible to pool or re-use transaction objects, the lifetime of a transaction object may be longer than the lifetime of the corresponding transaction. For example, a transaction object could be a stack variable passed as an argument to multiple <I>put </I>calls of the TLM-1 interface. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">local quantum: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The amount of simulation time remaining before the initiator is required to synchronize. Typically, the local quantum equals the current simulation time subtracted from the next largest integer multiple of the global quantum, but this calculation can be overridden for a given quantum keeper. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">local time offset: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">Time as measured relative to the most recent quantum boundary in a temporally decoupled initiator. The timing annotation arguments to the <B>b_transport </B>and <I>nb_transport </I>methods are local time offsets. effective_local_time = sc_time_stamp() + local_time_offset</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">loosely timed: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A modeling style that represents minimal timing information sufficient only to support features necessary to boot an operating system and to manage multiple threads in the absence of explicit synchronization between those threads. A loosely timed model may include timer models and a notional arbitration interval or execution slot length. Some users adopt the practice of inserting random delays into loosely timed descriptions in order to test the robustness of their protocols, but this practice does not change the basic characteristics of the modeling style. <B>master: </B>This term has no precise technical definition in this standard, but is used to mean a module or port that can take control of a memory-mapped bus in order to initiate bus traffic, or a component that can execute an autonomous software thread and thus initiate other system activity. Generally, a bus master would be an initiator. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">memory manager: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A user-defined class that performs memory management for a generic payload transaction object. A memory manager must provide a <B>free </B>method, called when the reference count of the transaction reaches 0. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">method: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A function that implements the behavior of a class. This term is synonymous with the C++ term <I>member function</I>. In SystemC, the term <I>method </I>is used in the context of an <I>interface method call</I>. Throughout this standard, the term <I>member function </I>is used when defining C++ classes (for conformance to the C++ standard), and the term <I>method </I>is used in more informal contexts and when discussing interface method calls. (SystemC term) </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">multi-socket: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">One of a family of convenience sockets that can be bound to multiple sockets belonging to other components. An initiator multi-socket can be bound to more than one target socket, and more than one initiator socket can be bound to a single target multi-socket. When calling interface methods through multi-sockets, the destinations are distinguished using the subscript operator. </SPAN></P>
<p><B><I><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">nb_transport</SPAN></I></B><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The <B>nb_transport_fw </B>and <B>nb_transport_bw </B>methods. In this document, the italicized term <I>nb_transport </I>is used to describe both methods in situations where there is no need to distinguish between them. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">non-blocking: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">Not permitted to call the <B>wait </B>method. A non-blocking function is guaranteed to return without consuming simulation time or performing a context switch, and therefore may be called from a thread process or from a method process. A non-blocking interface defines only non-blocking functions. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">non-blocking transport interface: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A non-blocking interface of the TLM-2.0 standard. There a two such interfaces, containing methods named <B>nb_transport_fw </B>and <B>nb_transport_bw</B>. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">object: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A region of storage. Every object has a type and a lifetime. An object created by a definition has a name, whereas an object created by a new expression is anonymous. (C++ term) </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">opposite path: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The path in the opposite direction to a given path. For the forward path, the opposite path is the forward return path or the backward path. For the backward path, the opposite path is the forward path or the backward return path. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">parent: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">The inverse relationship to <I>child</I>. Module A is the <I>parent </I>of module B if module B is a <I>child </I>of module A. (SystemC term) </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">payload event queue (PEQ): </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; COLOR: black; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">A class that maintains a queue of SystemC event notifications, where each notification carries an associated transaction object. Transactions are put into the queue annotated with a delay, and each transaction pops out of the back of queue at the time it was put in plus the given delay. Useful when combining the non-blocking interface with the approximately-timed coding style.</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">phase: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A period in the lifetime of a transaction. The phase is passed as an argument to the non-blocking transport method. Each phase transition is associated with a timing point. The timing point may be delayed by an amount given by the time argument to <I>nb_transport</I>. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">phase transition: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A change to the value of the phase argument of the non-blocking transport method as marked by each call to <I>nb_transport </I>and each return from <I>nb_transport </I>with a value of TLM_UPDATED. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">programmers view (PV): </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The use case of the software programmer who requires a functionally accurate, loosely timed model of the hardware platform for booting an operating system and running application software. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">protocol traits class: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A class containing a <B>typedef </B>for the type of the transaction object and the phase type, which is used to parameterize the combined interfaces, and effectively defines a unique type for a protocol. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">quantum: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">In temporal decoupling, the amount a process is permitted to run ahead of the current simulation time. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">quantum keeper: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A utility class used to store the local time offset from the current simulation time, which it checks against a local quantum. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">request: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">For the base protocol, the stage during the lifetime of a transaction when information is passed from the initiator to the target. In effect, the request transports generic payload attributes from the initiator to the target, including the command, the address, and for a write command, the data array. (The transaction is actually passed by reference and the data array by pointer.) </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">response: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">For the base protocol, the stage during the lifetime of a transaction when information is passed from the target back to the initiator. In effect, the response transports generic payload attributes from the target back to the initiator, including the response status, and for a read command, the data array. (The transaction is actually passed by reference and the data array by pointer.) </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">return path: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The control path by which the call stack of a set of interface method calls is unwound along either the forward path or the backward path. The return path for the forward path can carry information from target to initiator, and the return path for the backward path can carry information from initiator to target. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">simple socket: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">One of a family of convenience sockets that are simple to use because they allows callback methods to be registered directly with the socket object rather than the socket having to be bound to another object that implements the required interfaces. The simple target socket avoids the need for a target to implement both blocking and non-blocking transport interfaces by providing automatic conversion between the two. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">slave: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">This term has no precise technical definition in this standard, but is used to mean a reactive module or port on a memory-mapped bus that is able to respond to commands from bus masters, but is not able itself to initiate bus traffic. Generally, a slave would be modeled as a target. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">socket</SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">: See initiator socket and target socket </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">standard error response</SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">: The behavior prescribed by this standard for a generic payload target that is unable to execute a transaction successfully. A target should either a) execute the transaction successfully or b) set the response status attribute to an error response or c) call the SystemC report handler. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">sticky extension: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A generic payload extension object that is not deleted (either automatically or explicitly) at the end of life of the transaction object, and thus remains with the transaction object when it is pooled. Sticky extensions are not deleted by the memory manager.<B></B></SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">synchronize: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">To yield such that other processes may run, or when using temporal decoupling, to yield and wait until the end of the current time quantum. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">synchronization-on-demand: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The action of a temporally decoupled process when it yields control back to the SystemC scheduler so that simulation time may advance and other processes run in addition to the synchronization points that may occur routinely at the end of each quantum. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">tagged socket: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">One of a family of convenience sockets that add an int id tag to every incoming interface method call in order to identify the socket (or element of a multi-socket) through which the transaction arrived. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">target: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A module that represents the final destination of a transaction, able to respond to transactions generated by an initiator, but not itself able to initiate new transactions. For a write operation, data is copied from the initiator to one or more targets. For a read operation, data is copied from one target to the initiator. A target may read or modify the state of the transaction object. In the case of the TLM-1 interfaces, the term <I>target </I>as defined here may not be strictly applicable, so the terms <I>caller </I>and <I>callee </I>may be used instead for clarity. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">target socket: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A class containing a port for interface method calls on the backward path and an export for interface method calls on the forward path. A socket also overloads the SystemC binding operators to bind both port and export. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">temporal decoupling: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The ability to allow one or more initiators to run ahead of the current simulation time in order to reduce context switching and thus increase simulation speed. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">timing annotation: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The <B>sc_time </B>argument to the <B>b_transport </B>and <I>nb_transport </I>methods. A timing annotation is a local time offset. The recipient of a transaction is required to behave as if it had received the transaction at effective_local_time = sc_time_stamp() + local_time_offset. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">timing point: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A significant time within the lifetime of a transaction. A loosely-timed transaction has two timing points corresponding to the call to and return from <B>b_transport</B>. An approximately-timed base protocol transaction has four timing points, each corresponding to a phase transition. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">TLM-1: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The first major version of the OSCI Transaction Level Modeling standard. TLM-1 was released in 2005. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">TLM-2.0: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The second major version of the OSCI Transaction Level Modeling standard. This document describes TLM-2.0. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">traits class: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">In C++ programming, a class that contains definitions such as typedefs that are used to specialize the behavior of a primary class, typically by having the traits class passed as a template argument to the primary class. The default template parameter provides the default traits for the primary class. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">transaction: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">An abstraction for an interaction or communication between two or more concurrent processes. A transaction carries a set of attributes and is bounded in time, meaning that the attributes are only valid within a specific time window. The timing associated with the transaction is limited to a specific set of timing points, depending on the type of the transaction. Processes may be permitted to read or modify attributes of the transaction, depending on the protocol. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">transaction bridge: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A component that acts as the target for an incoming transaction and as the initiator for an outgoing transaction, usually for the purpose of modeling a bus bridge. See <I>bridge</I></SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">transaction instance: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A unique instance of a transaction. A transaction instance is represented by one transaction object, but the same transaction object may be re-used for several transaction instances. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">transaction object: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The object that stores the attributes associated with a transaction. The type of the transaction object is passed as a template argument to the core interfaces. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">transaction level (TL): </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The abstraction level at which communication between concurrent processes is abstracted away from pin wiggling to transactions. This term does not imply any particular level of granularity with respect to the abstraction of time, structure, or behavior. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">transaction level model, transaction level modeling (TLM): </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A model at the transaction level and the act of creating such a model, respectively. Transaction level models typically communicate using function calls, as opposed to the style of setting events on individual pins or nets as used by RTL models. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">transactor: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A module that connects a transaction level interface to a pin level interface (in the general sense of the word interface) or that connects together two or more transaction level interfaces, often at different abstraction levels. In the typical case, the first transaction level interface represents a memory-mapped bus or other protocol, the second interface represents the implementation of that protocol at a lower abstraction level. However, a single transactor may have multiple transaction level or pin level interfaces. See <I>adapter, bridge</I>. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">transparent component: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A interconnect component with the property that all incoming interface method calls are propagated immediately through the component without delay and without modification to the arguments or to the transaction object (extensions excepted). The intent of a transparent component is to allow checkers and monitors to pass ignorable phases. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">transport interface: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The one and only bidirectional core interface in TLM-1. The transport interface passes a request transaction object from caller to callee, and returns a response transaction object from callee to caller. TLM-2.0 adds separate blocking and non-blocking transport interfaces. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">unidirectional interface: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A TLM-1.0 transaction level interface in which the attributes of the transaction object are strictly readonly in the period between the first timing point and the end of the transaction lifetime. Effectively, the information represented by the transaction object is strictly passed in one direction either from caller to callee or from callee to caller. In the case of <B>void put(const T&amp; t)</B>, the first timing point is marked by the function call. In the case of <B>void get(T&amp; t)</B>, the first timing point is marked by the return from the function. In the case of <B>T get()</B>, strictly speaking there are two separate transaction objects, and the return from the function marks the degenerate end-of-life of the first object and the first timing point of the second. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">untimed: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A modeling style in which there is no explicit mention of time or cycles, but which includes concurrency and sequencing of operations. In the absence of any explicit notion of time as such, the sequencing of operations across multiple concurrent threads must be accomplished using synchronization primitives such as events, mutexes and blocking FIFOs. Some users adopt the practice of inserting random delays into untimed descriptions in order to test the robustness of their protocols, but this practice does not change the basic characteristics of the modeling style. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">utilities: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">A set of classes of the TLM-2.0 standard that are provided for convenience only, and are not strictly necessary to achieve interoperability between transaction-level models. </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">valid: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The state of an object returned from a function by pointer or by reference, during any period in which the object is not deleted and its value or behavior remains accessible to the application. (SystemC term)</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">within: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">The relationship that exists between an instance and a module if the constructor of the instance is called from the constructor of the module, and also provided that the instance is not <I>within </I>a nested module. (SystemC term) </SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">yield: </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 15pt; mso-bidi-font-size: 10.0pt">Return control to the SystemC scheduler. For a thread process, to yield is to call <B>wait</B>. For a method process, to yield is to return from the function.</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: 'Lucida Console'; mso-bidi-font-size: 9.0pt; mso-font-kerning: 0pt; mso-bidi-font-family: 'Lucida Console'"></SPAN>