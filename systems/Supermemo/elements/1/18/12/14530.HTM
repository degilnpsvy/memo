This algorithm results in more specific rules being preferred over more generic ones; for example: <PRE class=example>     %.o: %.c
             $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@
     
     %.o : %.f
             $(COMPILE.F) $(OUTPUT_OPTION) $&lt;
     
     lib/%.o: lib/%.c
             $(CC) -fPIC -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@
</PRE>
<P>Given these rules and asked to build <SAMP><SPAN class=file>bar.o</SPAN></SAMP> where both <SAMP><SPAN class=file>bar.c</SPAN></SAMP> and <SAMP><SPAN class=file>bar.f</SPAN></SAMP> exist, <CODE>make</CODE> will <FONT class=clozed>choose the first rule and compile <SAMP><SPAN class=file>bar.c</SPAN></SAMP> into <SAMP><SPAN class=file>bar.o</SPAN></SAMP>. In the same situation where <SAMP><SPAN class=file>bar.c</SPAN></SAMP> does not exist, then <CODE>make</CODE> will choose the second rule and compile <SAMP><SPAN class=file>bar.f</SPAN></SAMP> into <SAMP><SPAN class=file>bar.o</SPAN></SAMP>.</FONT> 
<P>If <CODE>make</CODE> is asked to build <SAMP><SPAN class=file>lib/bar.o</SPAN></SAMP> and both <SAMP><SPAN class=file>lib/bar.c</SPAN></SAMP> and <SAMP><SPAN class=file>lib/bar.f</SPAN></SAMP> exist, then <SPAN class=cloze>[...]</SPAN>