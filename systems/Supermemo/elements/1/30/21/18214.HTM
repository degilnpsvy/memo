<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT class=extract face=Calibri>no extra assumptions except the presence of the device driver for the monitor.</FONT></SPAN></P>
<P class=MsoNormal style="WORD-SPACING: 0px; MARGIN: 0cm 0cm 0pt; -webkit-text-stroke-width: 0px"><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT class=extract face=Calibri>That means you can use X or Wayland, because those are the graphics driver infrastructure on Linux.</FONT></SPAN></P>
<P class=MsoNormal style="WORD-SPACING: 0px; MARGIN: 0cm 0cm 0pt; -webkit-text-stroke-width: 0px"><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT class=extract face=Calibri>Linux (the Kernel) by itself doesn't contain any graphics primitives. It provides some interfaces to talk to the GPU, allocate memory on it and configure the on-screen framebuffer. But except raw framebuffer memory access the Linux kernel does have no way to perform drawing operations. For that you need some infrastructure in userspace.</FONT></SPAN></P>
<P class=MsoNormal style="WORD-SPACING: 0px; MARGIN: 0cm 0cm 0pt; -webkit-text-stroke-width: 0px"><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT class=extract face=Calibri>Wayland builds on top of DRI2, which in turn talks to the DRM Kernel-API. Then you require GPU dependent state tracker. Mesa has state trackers for a number of GPUs and provides OpenGL and OpenVG frontends.</FONT></SPAN></P>
<P class=MsoNormal style="WORD-SPACING: 0px; MARGIN: 0cm 0cm 0pt; -webkit-text-stroke-width: 0px"><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>The NVidia and ATI propiatary, closed source graphics drivers are designed to work with X only. So with those to make use of the GPU you must use X. That's the way it is.</FONT></SPAN></P>
<P class=MsoNormal style="WORD-SPACING: 0px; MARGIN: 0cm 0cm 0pt; -webkit-text-stroke-width: 0px"><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Outside of that you can manipulate the on-screen framebuffer memory through</FONT></SPAN><SPAN class=apple-converted-space><SPAN lang=EN-US style="FONT-SIZE: 15pt; FONT-FAMILY: 'Arial','sans-serif'; COLOR: black; mso-bidi-font-size: 10.0pt">&nbsp;</SPAN></SPAN><CODE style="WHITE-SPACE: pre-wrap"><SPAN lang=EN-US style="FONT-SIZE: 15pt; BORDER-TOP: windowtext 1pt; FONT-FAMILY: Consolas; BORDER-RIGHT: windowtext 1pt; BACKGROUND: #eeeeee; BORDER-BOTTOM: windowtext 1pt; COLOR: black; PADDING-BOTTOM: 0cm; PADDING-TOP: 0cm; PADDING-LEFT: 0cm; BORDER-LEFT: windowtext 1pt; PADDING-RIGHT: 0cm; mso-bidi-font-size: 10.0pt; mso-border-alt: none windowtext 0cm">/dev/fbdev</SPAN></CODE><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>, but that's mere pixel pushing, without any GPU acceleration.</FONT></SPAN>