<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>vga_accel</FONT></SPAN></B></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Section: Svgalib User Manual (3)<BR>Updated: 27 July 1997<BR></FONT><A href="http://www.fifi.org/cgi-bin/man2html/usr/share/man/man3/vga_accel.3vga.gz#index"><FONT color=#0000ff face=Calibri>Index</FONT></A><FONT face=Calibri>&nbsp;<BR></FONT><A href="http://www.fifi.org/cgi-bin/man2html"><FONT color=#0000ff face=Calibri>Return to Main Contents</FONT></A></SPAN></P>
<DIV style="TEXT-ALIGN: center; MARGIN: 0cm 0cm 0pt" class=MsoNormal align=center><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT color=#0000ff face=Calibri>
<HR style="COLOR: black" align=center SIZE=2 width="100%" noShade>
</FONT></SPAN></DIV>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><A name=lbAB><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>&nbsp;</FONT></SPAN></A><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>NAME</FONT></SPAN></B></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>vga_accel - calls the graphics accelerator&nbsp;</FONT><A name=lbAC><FONT face=Calibri>&nbsp;</FONT></A></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>SYNOPSIS</FONT></SPAN></B></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>#include &lt;</FONT><A href="file://usr/include/vga.h"><FONT color=#0000ff face=Calibri>vga.h</FONT></A><FONT face=Calibri>&gt;</FONT></SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>int vga_accel(unsigned&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>operation</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>,&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>...</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>);</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><A name=lbAD><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>&nbsp;</FONT></SPAN></A><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>DESCRIPTION</FONT></SPAN></B></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>This is the major function of the new accelerator interface which was sketched in version 1.2.3 (Michael: Hmm, it must have been later) but was implemented much later.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>The main goal is to define functions that can be used as part of certain kinds of interesting graphical operations (not necessarily interesting primitives on their own). Obvious useful primitives in their own are FillBox, ScreenCopy, DrawHLineList (solid polygon), DrawLine.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>An interesting purpose is the fast drawing of color bitmaps, both straight and transparent (masked, certain color not written). For masked bitmaps ("sprites"), there is a number of possible methods, the availability of which depends on the chips. Caching in non-visible video memory is often useful. One way is to use a transparency color compare feature of a BITBLT chip, either transferring the image from system memory or cached in video memory. If transparency compare is not available, it may be possible to first clear (zeroe) the mask in the destination area, and then use BITBLT raster-operation to OR the image into the destination (this requires the mask color to be 0). A higher level (library) interface should control this kind of operation.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga.h</SPAN></I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>&nbsp;contains several macros which may be used for&nbsp;<I>operation</I>. Most of them accept several optional arguments which you may specify after them. The&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?accel+6"><FONT color=#0000ff>accel</FONT></A></B>(6) svgalib demo shows basic usage of this function. The function returns -1 if the operation is not available and 0 if it is (or better: wasi and could be performed).</SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Currently the following parameters for&nbsp;<B>vga_accel()</B>&nbsp;are defined:</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_FILLBOX, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>x</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>y</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>w</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>h</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Simple solid fill of a box at pixels&nbsp;<I>x</I>,&nbsp;<I>y</I>&nbsp;with width&nbsp;<I>w</I>&nbsp;and height&nbsp;<I>h</I>&nbsp;in the current foreground color</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SCREENCOPY, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>x1</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>y1</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>x2</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>y2</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>w</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>h</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Simple screen-to-screen blit. It copies a box of width&nbsp;<I>w</I>&nbsp;and height&nbsp;<I>h</I>&nbsp;pixels from position&nbsp;<I>x1</I>,&nbsp;<I>y1</I>&nbsp;to position&nbsp;<I>x2</I>,&nbsp;<I>y2</I>. You may assume that the copy is non corrupting in case of overlapping source and destination areas.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SCREENCOPYMONO, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>x1</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>y1</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>x2</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>y2</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>w</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>h</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Monochrome screen-to-screen blit. It copies a box of width&nbsp;<I>w</I>&nbsp;and height&nbsp;<I>h</I>&nbsp;pixels from position&nbsp;<I>x1</I>,&nbsp;<I>y1</I>&nbsp;to position&nbsp;<I>x2</I>,&nbsp;<I>y2</I>.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>However, each pixel will all bits set to 0 is drawn in the background color, each pixel with all bits set to 1 is drawn in the foreground color. To allow many different architectures supporting this routine, behaviour is undefined for other values. Bitmap transparency might be supported as well.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>You should not expect&nbsp;<B>ACCEL_SCREENCOPYBITMAP</B>&nbsp;handling overlapping screen areas gracefully.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_PUTIMAGE, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>x</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>y</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>w</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>h</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, void *</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>p</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Straight image transfer. It fills the given box with the data in memory area&nbsp;<I>p</I>. The memory buffer must contain the pixels in the same representation as used in the vga memory, starting at the top left corner, from left to right, and then, line by line, from up to down, without any gaps and interline spaces.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_DRAWLINE, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>x1</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>y1</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>x2</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>y2</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>))</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>General line draw. Draws a line from&nbsp;<I>x1</I>,&nbsp;<I>y1</I>&nbsp;to position&nbsp;<I>x2</I>,&nbsp;<I>y2</I>&nbsp;in the foreground color. You should not expect the reverse line from<I>x2</I>,&nbsp;<I>y2</I>&nbsp;to position&nbsp;<I>x1</I>,&nbsp;<I>y1</I>&nbsp;to use the exact same pixels on the screen. Several, esp. hardware, algorithms tend to yield to surprising results.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETFGCOLOR, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>color</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Sets foreground color. It is used by most other draw commands.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETBGCOLOR, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>color</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Set background color. It is used by draw commands which might also</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETTRANSPARENCY, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>mode</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>,&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>...</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Set transparency mode, see the table below for an explanation parameters.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETRASTEROP, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>mode</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Set raster-operation, see the table below for an explanation of parameters.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_PUTBITMAP, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>x</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>y</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>w</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>h</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, void *</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>p</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Color-expand bitmap. This works similar to&nbsp;<B>ACCEL_PUTIMAGE</B>&nbsp;but the bitmap&nbsp;<I>*p</I>&nbsp;is a one bit bitmap. Each pixel related to a set bit in&nbsp;<I>*p</I>&nbsp;is drawn in the foreground color, the other pixels are drawn in the background color.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Each byte at&nbsp;<I>*p</I>&nbsp;contains 8 pixels. The lowest order bit of each byte is leftmost on the screen (contrary to the VGA tradition), irrespective of the bitmap bit order flag. Each scanline is aligned to a multiple of 32-bits.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>If the transparency mode is enabled (irrespective of the transparency color), then bits that are zero in the bitmap are not written (the background color is not used).</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SCREENCOPYBITMAP, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>x1</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>y1</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>x2</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>y2</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>w</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>h</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Color-expand from screen. This works similar to&nbsp;<B>ACCEL_PUTBITMAP</B>&nbsp;but the bitmap lies at position&nbsp;<I>x1</I>,&nbsp;<I>y1</I>&nbsp;and the destination box at<I>x2</I>,&nbsp;<I>y2.</I></FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Alas, the sizes of the pixels in both bitmap are different. The bitmap&nbsp;<I>*p</I>&nbsp;must have the format corresponding to&nbsp;<B>ACCEL_PUTBITMAP</B>but will start at the screen memory location where the pixel (<I>x1</I>,&nbsp;<I>y1</I>) would be (probably in off screen memory).</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>In modes where pixel will not start at byte boundaries (typically those with less then 256 colors), the pixel (<I>x1</I>,&nbsp;<I>y1</I>) must start at a byte boundary (for example in a 16 color mode (4bpp rather than 8bpp for 256 colors) this means that&nbsp;<I>x1</I>&nbsp;should be an even number).</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>The easiest way to achieve this is probably to choose&nbsp;<I>x1</I><B>&nbsp;== 0</B>&nbsp;in these situations.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>You should not expect&nbsp;<B>ACCEL_SCREENCOPYBITMAP</B>&nbsp;handling overlapping screen areas gracefully.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_DRAWHLINELIST, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>y</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>n</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int *</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>x1</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int *</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>x2</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Draw horizontal spans. Each of the&nbsp;<I>*x1</I>&nbsp;and&nbsp;<I>*x2</I>&nbsp;arrays contains&nbsp;<I>n</I>&nbsp;x-coordinate pairs. Starting with a horizontal line from&nbsp;<I>*x1</I>,<I>y</I>&nbsp;to<I>*x2</I>,<I>y</I>&nbsp;consecutive horizontal lines (with increasing&nbsp;<I>y</I>&nbsp;values) are drawn using the start and end points in&nbsp;<I>*x1</I>&nbsp;and&nbsp;<I>*x2</I>. This is usually a very quick operation and useful to draw arbitrary polygons (when the accelerator cannot do an arbitrary polygon fill itself).</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_POLYLINE, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>flag</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>n</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, unsigned short *</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>coords</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>draws a contiguous line through the&nbsp;<I>n</I>&nbsp;points listed in&nbsp;<I>*coords</I>.&nbsp;<I>*coords</I>&nbsp;contains&nbsp;<I>n</I>&nbsp;pairs of shorts, the first is the x coordinate, the second is the y coordinate.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Normally&nbsp;<I>flag</I>&nbsp;should have the value&nbsp;<B>ACCEL_START | ACCEL_END</B>. However, if the evaluation of the points is costly, you can mix calculations and drawings. Your first call to&nbsp;<B>vga_accel(ACCEL_POLYLINE,&nbsp;</B><I>...</I><B>)</B>&nbsp;must have&nbsp;<B>ACCEL_START</B>&nbsp;set. This will initialize the accelerator. If you do not specify&nbsp;<B>ACCEL_END</B>, you can (actually you have to) follow your call with another<B>vga_accel(ACCEL_POLYLINE,&nbsp;</B><I>...</I><B>)</B>&nbsp;call which will give additional points to connect.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>It is important that no other operations (even no color settings) take place between a call with&nbsp;<B>ACCEL_START</B>&nbsp;and the one with the corresponding&nbsp;<B>ACCEL_END</B>. Because of this, it is also important that you lock the console with&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_lockvc+3"><FONT color=#0000ff>vga_lockvc</FONT></A></B>(3) and&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_unlockvc+3"><FONT color=#0000ff>vga_unlockvc</FONT></A></B>(3), s.t. you cannot be interrupted by a console switch.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>It is allowed not to set&nbsp;<B>ACCEL_END</B>&nbsp;for your last call to&nbsp;<B>vga_accel(ACCEL_POLYLINE,&nbsp;</B><I>...</I><B>).</B><I>This</I><B>will</B><I>not</I><B>draw</B><I>the</I><B>last</B><I>pixel</I><B>of</B><I>the</I><B>last</B>line which is important for some raster operations when drawing closed polygons. The accelerator will automatically deinitialize when called with another operation in this situation.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>It is undefined what happens when you specify other values for&nbsp;<I>flag</I>&nbsp;and when your polyline contains only a single point. The line segments must also not be of length zero.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>For implementors: In conjunction with raster operations (<B>ROP_XOR</B>,&nbsp;<B>ROP_INV</B>) it is important that endpoints of inner line section are only drawn once. If you cannot achieve that, you must signal that this function cannot be used in conjunction with raster operations. In this case it is valid to always draw all points of the line segments including the endpoints regardless of the existence of a&nbsp;<B>ACCEL_END</B>&nbsp;parameter.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_POLYHLINE, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>flag</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>y</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>n</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>, unsigned short *</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>xcoords</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>This function combines the features of&nbsp;<B>ACCEL_POLYLINE</B>&nbsp;and&nbsp;<B>ACCEL_DRAWHLINELIST</B>. Starting in row&nbsp;<I>y</I>&nbsp;horizontal lines are drawn from top to bottom. For each horizontal scanline the&nbsp;<I>*coords</I>&nbsp;array will contain a number&nbsp;<I>m</I>&nbsp;followed by&nbsp;<I>m</I>&nbsp;x coordinates in left to right order. Horizontal lines are drawn between the first and the second, the third and the fourth x coordinates, and so on. If the&nbsp;<I>m</I>coordinates are exhausted,&nbsp;<I>y</I>&nbsp;is increased, a new number&nbsp;<I>m</I>&nbsp;is read from the&nbsp;<I>*coords</I>&nbsp;array and operation continues.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>This procedure is done for&nbsp;<I>n</I>&nbsp;scan lines.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>In addition there is a&nbsp;<I>flag parameter which works similar to</I>&nbsp;<B>ACCEL_POLYLINE</B>. Your first call to&nbsp;<B>ACCEL_DRAWHLINELIST</B>&nbsp;must have the&nbsp;<B>ACCEL_START</B>&nbsp;bit set for proper initialization. The&nbsp;<I>y</I>&nbsp;parameter is ignored when&nbsp;<B>ACCEL_START</B>&nbsp;is not given.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>On contrary to&nbsp;<B>ACCEL_POLYLINE</B>&nbsp;it is required that the last call has the&nbsp;<B>ACCEL_END</B>&nbsp;bit set.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>The function is intended for drawing complex filled polygons using horizontal scanlines. By issuing small and fast calls for few scanlines only it is possible to intermix drawing and calculations.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>The operation of&nbsp;<B>ACCEL_POLYHLINE</B>&nbsp;is undefined if the x coordinates are not sorted from left to right or there are zero length segments in any scan line or if&nbsp;<I>n</I>&nbsp;or one of the&nbsp;<I>m</I>&nbsp;counters are zero, or one of the&nbsp;<I>m</I>'s is not even.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_POLYFILLMODE,&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>onoff</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Switches polygon fill mode on (<I>onoff</I>&nbsp;non-zero) or off.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>When in polygon fill mode,&nbsp;<B>ACCEL_DRAWLINE</B>&nbsp;and&nbsp;<B>ACCEL_POLYLINE</B>&nbsp;will only draw a single point on each scanline of each line segment.&nbsp;<B>ACCEL_SCREENCOPYMONO</B>&nbsp;will horizontally scan it's source area and start drawing in the foreground color when it encounters a set pixel. When the next pixel is encountered, it will start using the background color and so on.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>This can be used for hardware filled polygons:</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>1.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Enable polygon fill mode.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>2.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Fill an offscreen rectangular area with a the color with all bits zero (usually black).</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>3.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Draw a (usually closed) polygon outline in this offscreen area in the color with all bits set (usually white). To get the proper bits set for the polygon outline, it is recommended to use&nbsp;<B>ROP_XOR</B>&nbsp;s.t. outlines intersecting in a single point are handled correctly. To ensure that polygon corners are handled right, both start and end points must be drawn (in<B>ROP_XOR</B>&nbsp;mode). Thus it is best to use&nbsp;<B>ACCEL_DRAWLINE</B>&nbsp;instead of&nbsp;<B>ACCEL_POLYLINE</B>. Finally, skip drawing all horizontal lines (which would confuse&nbsp;<B>ACCEL_SCREENCOPYMONO</B>).</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>4.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Set fore- and background colors, raster operation, bitmap transparency to those you want for your polygon.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>5.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Use&nbsp;<B>ACCEL_SCREENCOPYMONO</B>&nbsp;to copy the offscreen pattern to the screen.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>The rasteroperations and transparency which are signalled to be supported for&nbsp;<B>ACCEL_POLYFILLMODE</B>&nbsp;by&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_ext_set+3"><FONT color=#0000ff>vga_ext_set</FONT></A></B>(3) are actually meant to apply to the last&nbsp;<B>ACCEL_SCREENCOPYMONO</B>&nbsp;call.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Because this polygon drawing uses more screen read/write operations it is probably slower than using&nbsp;<B>ACCEL_DRAWHLINELIST</B>&nbsp;or<B>ACCEL_POLYHLINE</B>&nbsp;for drawing a polygon scanline by scanline. However, it is easier to use and it will work mostly without intervention of the CPU which can do other calculations then. See&nbsp;<B>BUGS</B>&nbsp;below.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>It is unspecified if the left or right end points of the scanlines are drawn, and most probably some cards (like Mach32) will omit them on one end, at least. Because of that you should always draw the boundary line in the fill color (or another color) after filling the polygon.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETMODE,&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>mode</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Set blit strategy. There are two choices for&nbsp;<I>mode</I>, namely&nbsp;<B>BLITS_SYNC</B>&nbsp;and&nbsp;<B>BLITS_IN_BACKGROUND</B>. The first ensures that a<B>vga_accel()</B>&nbsp;call only returns when the accelerator has finished its operation. The second allows for an immediate return and thus allows parallel operation of the CPU and the accelerator. Consecutive accelerator operations will wait for each other to complete (and block if necessary). However, direct screen memory access (also when done implicitly by some call to an svgalib function) may find any intermediate state in vga memory or even corrupt the running accelerator operation.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SYNC)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Wait for accelerator to finish when in&nbsp;<B>vga_accel(BLITS_IN_BACKGROUND)</B>&nbsp;mode.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETOFFSET, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>address</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>set a screen offset as&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_setdisplaystart+3"><FONT color=#0000ff>vga_setdisplaystart</FONT></A></B><I>(3)</I>&nbsp;does. The same restrictions for this function as reported by&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_getmodeinfo+3"><FONT color=#0000ff>vga_getmodeinfo</FONT></A></B><I>(3)</I>apply to address.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Whenever the video screen offset is modified, the accelerator's offset will follow. However you can modify it later with this function.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>The following&nbsp;<I>mode</I>&nbsp;values are defined for&nbsp;<B>vga_accel(ACCEL_SETTRANSPARENCY, int&nbsp;</B><I>mode</I><B>,&nbsp;</B><I>...</I><B>)</B></FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETTRANSPARENCY, ENABLE_TRANSPARENCY_COLOR, int&nbsp;</SPAN></B><I><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>color</SPAN></I><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Whenever one of the&nbsp;<B>vga_accel()</B>&nbsp;operations would draw a pixel in color&nbsp;<I>color</I>, no operation is performed and the destination pixel is left unchanged. In fact that color is defined to be transparent.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETTRANSPARENCY, DISABLE_TRANSPARENCY_COLOR)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>disables the previous functionality.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETTRANSPARENCY, ENABLE_BITMAP_TRANSPARENCY)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>in the bitmap expanding operations&nbsp;<B>ACCEL_PUTBITMAP</B>&nbsp;and&nbsp;<B>ACCEL_SCREENCOPYBITMAP</B>&nbsp;whenever a non set bit is encountered, to not perform any draw operation. The 0 bits do not draw in the background color. Instead they are defined to be transparent.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETTRANSPARENCY, DISABLE_BITMAP_TRANSPARENCY)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>disables the previous functionality.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>The following&nbsp;<I>mode</I>&nbsp;values are defined for&nbsp;<B>vga_accel(ACCEL_SETRASTEROP, int&nbsp;</B><I>mode</I><B>)</B></FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETRASTEROP, ROP_COPY)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Straight copy. Pixels drawn by&nbsp;<B>vga_accel()</B>&nbsp;replace the destination.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETRASTEROP, ROP_OR)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Logical or. Pixels drawn by&nbsp;<B>vga_accel()</B>&nbsp;are logical (bitwise) ored to the destination.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETRASTEROP, ROP_AND)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Logical and. Pixels drawn by&nbsp;<B>vga_accel()</B>&nbsp;are logical (bitwise) anded to the destination.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETRASTEROP, ROP_XOR)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Logical exclusive or. Pixels drawn by&nbsp;<B>vga_accel()</B>&nbsp;are logical (bitwise) exclusive ored to the destination (bits set in the drawn pixels flip those pits in the destination).</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>vga_accel(ACCEL_SETRASTEROP, ROP_INV)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Inversion. Pixels drawn by&nbsp;<B>vga_accel()</B>&nbsp;are inverted. Which color is drawn is actually ignored. Any pixel which would be overwritten is simply inverted (bitwise) instead.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>IMPORTANT!</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>&nbsp;Please note that a 0 returned by&nbsp;<B>vga_accel(ACCEL_SETTRANSPARENCY, int&nbsp;</B><I>mode</I><B>,&nbsp;</B><I>...</I><B>)</B>&nbsp;and&nbsp;<B>vga_accel(ACCEL_SETRASTEROP, int&nbsp;</B><I>mode</I><B>)</B>&nbsp;simply means that the set function is available (and thus probably&nbsp;<I>some</I>&nbsp;of above features) but only partial functionality may be available. The&nbsp;<B>VGA_AVAIL_ROPMODES</B>&nbsp;and&nbsp;<B>VGA_AVAIL_TRANSMODES</B>&nbsp;subfunctions of&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_ext_set+3"><FONT color=#0000ff>vga_ext_set</FONT></A></B>(3) allow you to check for valid parameters. The&nbsp;<B>VGA_AVAIL_ROP</B>&nbsp;and&nbsp;<B>VGA_AVAIL_TRANSPARENCY</B>&nbsp;subfunctions return which of the&nbsp;<B>vga_accel</B>&nbsp;operations are actually affected by these set functions.</SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Instead of calling&nbsp;<B>vga_accel()</B>&nbsp;for each operation to find out if it is supported, you can call:</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>#include &lt;</FONT><A href="file://usr/include/vga.h"><FONT color=#0000ff face=Calibri>vga.h</FONT></A><FONT face=Calibri>&gt;</FONT></SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>int vga_ext_set(VGA_EXT_AVAILABLE, VGA_AVAIL_ACCEL)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>When the logical bitwise and of the return value with one of the following predefined (one bit set only) integer constants is non zero, the corresponding operation is available:&nbsp;<B>ACCELFLAG_FILLBOX</B>,&nbsp;<B>ACCELFLAG_SCREENCOPY</B>,&nbsp;<B>ACCELFLAG_PUTIMAGE</B>,&nbsp;<B>ACCELFLAG_DRAWLINE</B>,<B>ACCELFLAG_SETFGCOLOR</B>,&nbsp;<B>ACCELFLAG_SETBGCOLOR</B>,&nbsp;<B>ACCELFLAG_SETTRANSPARENCY</B>,&nbsp;<B>ACCELFLAG_SETRASTEROP</B>,&nbsp;<B>ACCELFLAG_PUTBITMAP</B>,<B>ACCELFLAG_SCREENCOPYBITMAP</B>,&nbsp;<B>ACCELFLAG_DRAWHLINELIST</B>,&nbsp;<B>ACCELFLAG_SETMODE</B>&nbsp;and&nbsp;<B>ACCELFLAG_SYNC</B>.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>In addition, calling</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>#include &lt;</FONT><A href="file://usr/include/vga.h"><FONT color=#0000ff face=Calibri>vga.h</FONT></A><FONT face=Calibri>&gt;</FONT></SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>int vga_ext_set(VGA_EXT_AVAILABLE, VGA_AVAIL_TRANSPARENCY)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>or</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>int vga_ext_set(VGA_EXT_AVAILABLE, VGA_AVAIL_ROP)</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>does&nbsp;<B>not</B>&nbsp;list the supported values for raster operations and transparency but instead returns the&nbsp;<B>ACCELFLAG_</B>&nbsp;values for the accelerator operations which respond the raster operation resp. transparency settings.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>The availability of the operations will usually depend on the current video mode selected. You should not try to use them or check for availability prior to selecting the mode you want to use with&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?set_mode+3"><FONT color=#0000ff>set_mode</FONT></A></B>(3).&nbsp;</FONT><A name=lbAE><FONT face=Calibri>&nbsp;</FONT></A></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>BUGS</FONT></SPAN></B></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>I found the Mach32 buggy in that it occasionally omits drawing last pixels of lines when in polygon fill modes (that means, a single point for the last scanline touched by a line). Obviously this confuses the polygon fill hardware. However, screen corruption will always be restricted to a small area as&nbsp;<B>ACCEL_SCREENCOPYMONO</B>&nbsp;will work only on a limited area. It is not clear if this is a driver error, but it seems to be a hardware bug, and I don't know a clutch to avoid it yet. In case you experience problems with certain applications, try<B>blit nopolyfillmode</B>&nbsp;in the configuration file or the SVGALIB_CONFIG environment variable.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>You must ensure that the given screen coordinates lie in screen memory. Actually you may not really be sure how offscreen areas are handled, you can only really trust that coordinates which are visible are supported. For example, the Mach32 restricts the allowable x and y coordinates to the range -512 .. 1535. However, even on a 1MB VGA memory card, the offscreen point (0, 1599) would identify a valid screen memory location (if you could use it).</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Where supported, the&nbsp;<B>vga_accel(ACCEL_SETOFFSET,&nbsp;</B><I>...</I><B>)</B>&nbsp;directive might help to ease things a bit in such situations.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>Svgalib's accelerator support is a mess. Right now, only the Ark, the Cirrus, the Chips&amp;Technologies, and the Mach32 svga drivers really support this function. The Mach32 still also supports the old style accelerator functions&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_bitblt+3"><FONT color=#0000ff>vga_bitblt</FONT></A></B>(3),&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_blitwait+3"><FONT color=#0000ff>vga_blitwait</FONT></A></B>(3),<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_fillblt+3"><FONT color=#0000ff>vga_fillblt</FONT></A></B>(3),&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_hlinelistblt+3"><FONT color=#0000ff>vga_hlinelistblt</FONT></A></B>(3) and&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_imageblt+3"><FONT color=#0000ff>vga_imageblt</FONT></A></B>(3) which were first designed for the Cirrus cards and thus the Mach32 has its problems emulating them. The&nbsp;<B>gl_</B>&nbsp;functions use the accelerator to some extend. Currently the use both the new and the old style accelerator. You should avoid mixing calls of the new and the old style kinds.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>These functions are not well tested. You should expect weird bugs. In any case, the accelerator is of not much use in many typical svgalib applications. Best if you are not using them.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><FONT face=Calibri><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>BEWARE!</SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US>&nbsp;You should not use the graphics accelerator together with the background feature of&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_runinbackground+3"><FONT color=#0000ff>vga_runinbackground</FONT></A></B>(3). However, you can try using&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_lockvc+3"><FONT color=#0000ff>vga_lockvc</FONT></A></B>(3) to lock the vc prior to using the accelerator.</SPAN></FONT></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>The Mach32 driver does this on it's own, and even keeps the console locked while background accelerator functions are in progress. Other drivers might not be as graceful.</FONT></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><A name=lbAF><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>&nbsp;</FONT></SPAN></A><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>SEE ALSO</FONT></SPAN></B></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><A href="http://www.fifi.org/cgi-bin/man2html?svgalib+7"><FONT color=#0000ff face=Calibri>svgalib</FONT></A></SPAN></B><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>(7),&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vgagl+7"><FONT color=#0000ff>vgagl</FONT></A></B>(7),&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?libvga.config+5"><FONT color=#0000ff>libvga.config</FONT></A></B>(5),&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?accel+6"><FONT color=#0000ff>accel</FONT></A></B>(6),&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_bitblt+3"><FONT color=#0000ff>vga_bitblt</FONT></A></B>(3),&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_blitwait+3"><FONT color=#0000ff>vga_blitwait</FONT></A></B>(3),&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_ext_set+3"><FONT color=#0000ff>vga_ext_set</FONT></A></B>(3),&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_fillblt+3"><FONT color=#0000ff>vga_fillblt</FONT></A></B>(3),<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_getmodeinfo+3"><FONT color=#0000ff>vga_getmodeinfo</FONT></A></B>(3),&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_hlinelistblt+3"><FONT color=#0000ff>vga_hlinelistblt</FONT></A></B>(3),&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_imageblt+3"><FONT color=#0000ff>vga_imageblt</FONT></A></B>(3),&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_runinbackground+3"><FONT color=#0000ff>vga_runinbackground</FONT></A></B>(3),&nbsp;<B><A href="http://www.fifi.org/cgi-bin/man2html?vga_runinbackground_version+3"><FONT color=#0000ff>vga_runinbackground_version</FONT></A></B>(3)&nbsp;</FONT><A name=lbAG><FONT face=Calibri>&nbsp;</FONT></A></SPAN></P>
<P style="MARGIN: 0cm 0cm 0pt" class=MsoNormal><SPAN style="FONT-SIZE: 17.5pt; mso-bidi-font-size: 11.0pt" lang=EN-US><FONT face=Calibri>&nbsp;</FONT></SPAN>