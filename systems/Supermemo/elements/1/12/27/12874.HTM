<DIV class=NAVHEADER style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR>
<TH align=middle colSpan=3>Secure Programming for Linux and Unix HOWTO</TH></TR>
<TR>
<TD vAlign=bottom align=left width="10%"><A href="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/web-authentication.html">Prev</A></TD>
<TD vAlign=bottom align=middle width="80%">Chapter 11. Special Topics</TD>
<TD vAlign=bottom align=right width="10%"><A href="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/protect-secrets.html">Next</A></TD></TR></TBODY></TABLE>
<HR align=left width="100%">
</DIV>
<DIV class=SECT1 style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<H1 class=SECT1><A name=RANDOM-NUMBERS>11.3. Random Numbers</A></H1>
<P>In many cases secure programs must generate ``random'' numbers that cannot be guessed by an adversary. Examples include session keys, public or private keys, symmetric keys, nonces and IVs used in many protocols, salts, and so on. Ideally, you should use a truly random source of data for random numbers, such as values based on radioactive decay (through precise timing of Geiger counter clicks), atmospheric noise, or thermal noise in electrical circuits. Some computers have a hardware component that functions as a real random value generator, and if it's available you should use it.</P>
<P>However, most computers don't have hardware that generates truly random values, so in most cases you need a way to generate random numbers that is sufficiently random that an adversary can't predict it. In general, this means that you'll need three things:</P>
<P></P>
<UL>
<LI>
<P>An ``unguessable'' state; typically this is done by measuring variances in timing of low-level devices (keystrokes, disk drive arm jitter, etc.) in a way that an adversary cannot control.</P></LI>
<LI>
<P>A cryptographically strong pseudo-random number generator (PRNG), which uses the state to generate ``random'' numbers.</P></LI>
<LI>
<P>A large number of bits (in both the seed and the resulting value used). There's no point in having a strong PRNG if you only have a few possible values, because this makes it easy for an attacker to use brute force attacks. The number of bits necessary varies depending on the circumstance, however, since these are often used as cryptographic keys, the normal rules of thumb for keys apply. For a symmetric key (result), I'd use at least 112 bits (3DES), 128 bits is a little better, and 160 bits or more is even safer.</P></LI></UL>Typically the PRNG uses the state to generate some values, and then some of its values and other unguessable inputs are used to update the state. There are lots of ways to attack these systems. For example, if an attacker can control or view inputs to the state (or parts of it), the attacker may be able to determine your supposedly ``random'' number.
<P></P>
<P>A real danger with PRNGs is that most computer language libraries include a large set of pseudo-random number generators (PRNGs) which are<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>inappropriate</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>for security purposes. Let me say it again:<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>do not use typical random number generators for security purposes</EM>. Typical library PRNGs are intended for use in simulations, games, and so on; they are<EM>not</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>sufficiently random for use in security functions such as key generation. Most non-cryptographic library PRNGs are some variation of ``linear congruential generators'', where the ``next'' random value is computed as "(aX+b)&#29193;od&#29193;" (where X is the previous value). Good linear congruential generators are fast and have useful statistical properties, making them appropriate for their intended uses. The problem with such PRNGs is that future values can be easily deduced by an attacker (though they may appear random). Other algorithms for generating random numbers quickly, such as quadratic generators and cubic generators, have also been broken [Schneier 1996]. In short, you have to use cryptographically strong PRNGs to generate random numbers in secure applications - ordinary random number libraries are not sufficient.</P>
<P>Failing to correctly generate truly random values for keys has caused a number of problems, including holes in Kerberos, the X window system, and NFS [Venema 1996].</P>
<P>If possible, you should use system services (typically provided by the operating system) that are expressly designed to create cryptographically secure random values. For example, the Linux kernel (since 1.3.30) includes a random number generator, which is sufficient for many security purposes. This random number generator gathers environmental noise from device drivers and other sources into an entropy pool. When accessed as /dev/random, random bytes are only returned within the estimated number of bits of noise in the entropy pool (when the entropy pool is empty, the call blocks until additional environmental noise is gathered). When accessed as /dev/urandom, as many bytes as are requested are returned even when the entropy pool is exhausted. If you are using the random values for cryptographic purposes (e.g., to generate a key) on Linux, use /dev/random. *BSD systems also include /dev/random. Solaris users with the SUNWski package also have /dev/random. Note that if a hardware random number generator is available and its driver is installed, it will be used instead. More information is available in the system documentation random(4).</P>
<P>On other systems, you'll need to find another way to get truly random results. One possibility for other Unix-like systems is the Entropy Gathering Daemon (EGD), which monitors system activity and hashes it into random values; you can get it at<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="http://www.lothar.com/tech/crypto" target=_top>http://www.lothar.com/tech/crypto</A>. You might consider using a cryptographic hash functions (e.g., SHA-1) on PRNG outputs. By using a hash algorithm, even if the PRNG turns out to be guessable, this means that the attacker must now also break the hash function.</P>
<P>If you have to implement a strong PRNG yourself, a good choice for a cryptographically strong (and patent-unencumbered) PRNG is the Yarrow algorithm; you can learn more about Yarrow from<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="http://www.counterpane.com/yarrow.html" target=_top>http://www.counterpane.com/yarrow.html</A>. Some other PRNGs can be useful, but many widely-used ones have known weaknesses that may or may not matter depending on your application. Before implementing a PRNG yourself, consult the literature, such as [Kelsey 1998] and [McGraw 2000a]. You should also examine<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="http://www.ietf.org/rfc/rfc1750.txt" target=_top>IETF RFC 1750</A>. NIST has some useful information; see the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="http://csrc.nist.gov/publications/nistpubs/800-22/sp-800-22-051501.pdf" target=_top>NIST publication 800-22</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="http://csrc.nist.gov/publications/nistpubs/800-22/errata-sheet.pdf" target=_top>NIST errata</A>. You should know about the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="http://stat.fsu.edu/~geo/diehard.html" target=_top>diehard tests</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>too. You might want to examine the paper titled "how Intel checked its PRNG", but unfortunately that paper appears to be unavailable now.</P></DIV>
<DIV class=NAVFOOTER style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<HR align=left width="100%">

<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=top align=left width="33%"><A href="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/web-authentication.html">Prev</A></TD>
<TD vAlign=top align=middle width="34%"><A href="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/index.html">Home</A></TD>
<TD vAlign=top align=right width="33%"><A href="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/protect-secrets.html">Next</A></TD></TR>
<TR>
<TD vAlign=top align=left width="33%">Authenticating on the Web</TD>
<TD vAlign=top align=middle width="34%"><A href="http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/special.html">Up</A></TD>
<TD vAlign=top align=right width="33%">Specially Protect Secrets (Passwords and Keys) in User Memory</TD></TR></TBODY></TABLE></DIV>