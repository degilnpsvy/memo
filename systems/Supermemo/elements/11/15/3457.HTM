<HEAD><?xml:namespace prefix = st1 /><st1:chsdate w:st="on" Year="1899" Month="12" Day="30" IsLunarDate="False" IsROCDate="False"><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Bold-0-1000-21; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Bold-0-1000-21">1.5.4 </SPAN></B><B><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-BoldItalic-0-1000-45; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-BoldItalic-0-1000-45">P</SPAN></I></B></st1:chsdate></HEAD>
<BODY><SPAN style="mso-bookmark: OLE_LINK1"><B><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-BoldItalic-0-1000-45; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-BoldItalic-0-1000-45">1.5.4 Programmer-Visible Pipeline Effects</SPAN></I></B></SPAN>
<P></P>
<P><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">So far, this has all been what you might expect from a simplified CPU. However, making the instruction set pipeline friendly has some stranger effects as well, and to understand them we</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">re going to draw some pictures.</SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt"></SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19"></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49"></SPAN></I></SPAN>&nbsp;<SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">Delayed branches</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">: The pipeline structure of the MIPS CPU (Figure 1.3) means that when a jump/branch instruction reaches the execute phase and a new program counter is generated, the instruction after the jump will already have been started. Rather than discard this potentially useful work, the architecture dictates that the instruction after a branch must always be executed before the instruction at the target of the branch. The</SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">instruction position following any branch is called the </SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">branch delay slot</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">.</SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">If nothing special was done by the hardware, the decision to branch or not, together with the branch target address, would emerge at the end of the ALU pipestage</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">&#8212;<SPAN lang=EN-US>by which time, as Figure 1.3 shows, you</SPAN></SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">re too late to present an address for an instruction in even the next-but-one pipeline slot.</SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">But branches are important enough to justify special treatment, and you can see from Figure 1.3 that a special path is provided through the ALU to make the branch address available half a clock cycle early. Together with the odd half-clock-cycle shift of the instruction fetch stage, that means that the branch target can be fetched in time to become the next but one, so the hardware runs the branch instruction, then the branch delay slot instruction, and then the branch target</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">&#8212;<SPAN lang=EN-US>with no other delays.</SPAN></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">It is the responsibility of the compiler system or the assembly programming wizard to allow for and even to exploit the branch delay; it turns out that it is usually possible to arrange that the instruction in the branch delay slot does useful work. Quite often, the instruction that would otherwise have been placed before the branch can be moved into the delay slot.</SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">This can be a bit tricky on a conditional branch, where the branch delay instruction must be (at least) harmless on both paths. Where nothing useful can be done, the delay slot is filled with a </SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-65; mso-font-kerning: 0pt; mso-bidi-font-family: Courier-Bold-8r-0-1000-65">nop </SPAN></B></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">instruction. Many MIPS assemblers will hide this odd feature from you unless you</SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">explicitly ask them not to.</SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">Late data from load (load delay slot)</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">: Another consequence of the pipeline is that a load instruction</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">s data arrives from the cache/memory system </SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">after </SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">the next instruction</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">s ALU phase starts</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">&#8212;<SPAN lang=EN-US>so it is not possible to use the data from a load in the following instruction. (See Figure 1.4 for how this works.)</SPAN></SPAN></SPAN></P>
<P><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">The instruction position immediately after the load is called the </SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">load delay slot</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">, and an optimizing compiler will try to do something useful with it. The assembler will hide this from you but may end up putting in a </SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-65; mso-font-kerning: 0pt; mso-bidi-font-family: Courier-Bold-8r-0-1000-65">nop</SPAN></B></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">. On modern MIPS CPUs the load result is interlocked: If you try to use the result too early, the CPU stops until the data arrives. But on early MIPS CPUs, there were no interlocks, and the attempt to use data in the load delay slot led to unpredictable results.</SPAN></SPAN></P></BODY>