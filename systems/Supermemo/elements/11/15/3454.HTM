<HEAD><?xml:namespace prefix = st1 /><st1:chsdate w:st="on" Year="1899" Month="12" Day="30" IsLunarDate="False" IsROCDate="False"><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Bold-0-1000-21; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Bold-0-1000-21">1.5.1</SPAN></B></st1:chsdate></HEAD>
<BODY><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Bold-0-1000-21; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Bold-0-1000-21"></SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-BoldItalic-0-1000-45; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-BoldItalic-0-1000-45"><FONT face=&#24494;&#36719;&#38597;&#40657; color=#080000 size=3>1.5.1 </FONT><STRONG><EM>Constraints on MIPS Instructions</EM></STRONG></SPAN></SPAN> 
<P></P>
<P><FONT class=extract><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">All instructions are 32 bits long</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">: That means that no instruction can fit into only two or three bytes of memory (so MIPS binaries are typically 20 percent to 30 percent bigger than for 680x0 or 80x86) and no instruction can be bigger.</SPAN></SPAN></FONT></P>
<P><FONT class=extract><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">It follows that it is impossible to incorporate a 32-bit constant into a single instruction (there would be no instruction bits left to encode the operation and the target register). The MIPS architects decided to make space for a 26-bit constant to encode the target address of a jump or jump to subroutine; but that</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">s only for a couple of instructions. Other instructions find room only for a 16-bit constant. It follows that loading an arbitrary 32-bit value requires a two-instruction sequence, and conditional branches are limited to a range of 64-K instructions.</SPAN></SPAN></FONT></P>
<P><FONT class=extract><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">Instruction actions must fit the pipeline</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">: Actions can only be carried out in the right pipeline phase and must be complete in one clock. For example, the register write-back phase provides for just one value to be stored in the register file, so instructions can only change one register. Integer multiply and divide instructions are too important to leave out but can</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">t be done in one clock. MIPS CPUs have traditionally provided them by dispatching these operations into a separately pipelined unit we</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">ll talk about later.</SPAN></SPAN></FONT></P>
<P><FONT class=extract><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">Three-operand instructions</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">: Arithmetical/logical operations don</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">t have to specify memory locations, so there are plenty of instruction bits to define two independent sources and one destination register. Compilers love three-operand instructions, which give optimizers much more scope to improve code that handles complex expressions.</SPAN></SPAN></FONT></P>
<P><FONT class=extract><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">The 32 registers</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">: The choice of the number of registers is largely driven by software requirements, and a set of 32 general-purpose registers is easily the most popular in modern architectures. Using 16 would definitely not be as many as modern compilers like, but 32 is enough for a C compiler to keep frequently accessed data in registers in all but the largest and most intricate functions. Using 64 or more registers requires a bigger instruction field to encode registers and also increases context-switch overhead.</SPAN></SPAN></FONT></P>
<P><FONT class=extract><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">Register zero</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">: </SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-65; mso-font-kerning: 0pt; mso-bidi-font-family: Courier-Bold-8r-0-1000-65">$0 </SPAN></B></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">always returns zero, to give a compact encoding of that useful constant. </SPAN></SPAN></FONT></P>
<P><FONT class=extract><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">No condition codes</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">: One feature of the MIPS instruction set that is radical even among the 1985 RISCs is the lack of any condition flags. Many architectures have multiple flags for </SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">&#8220;<SPAN lang=EN-US>carry,</SPAN>&#8221; &#8220;<SPAN lang=EN-US>zero,</SPAN>&#8221; <SPAN lang=EN-US>and so on. CISC architectures typically set these flags according to the result written by any or a large subset of machine instructions, while some RISC architectures retain flags (though typically they are only set explicitly, by compare </SPAN></SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">instructions). The MIPS architects decided to keep all this information in the register file: Compare instructions </SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">set </SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">general-purpose registers and conditional branch instructions </SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">test </SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">general-purpose registers. That does benefit a pipelined implementation, in that whatever clever mechanisms are built in to reduce the effect of dependencies on arithmetical/logical operations will also reduce dependencies in compare/branch pairs.</SPAN></SPAN></FONT></P>
<P><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">We</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">ll see later that efficient conditional branching (at least in one favorite simple pipeline organization) means that the decision about whether to branch or not has to be squeezed into only half a pipeline stage; the architecture helps out by keeping the branch decision tests very simple. So MIPS conditional branches test a single register for sign/zero or a pair of registers for equality.</SPAN></SPAN></P></BODY>