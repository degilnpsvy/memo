<HEAD><?xml:namespace prefix = st1 /><st1:chsdate w:st="on" Year="1899" Month="12" Day="30" IsLunarDate="False" IsROCDate="False"><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Bold-0-1000-21; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Bold-0-1000-21"></SPAN></B><B><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-BoldItalic-0-1000-45; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-BoldItalic-0-1000-45"></SPAN></I></B></st1:chsdate></HEAD>
<BODY><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-BoldItalic-0-1000-45; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-BoldItalic-0-1000-45"><FONT face=&#24494;&#36719;&#38597;&#40657; color=#080000 size=3>1.5.2 A</FONT><STRONG><EM>ddressing and Memory Accesses</EM></STRONG></SPAN></SPAN> 
<P></P>
<P><FONT class=extract><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">Memory references are always plain register loads and stores</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">: Arithmetic on memory variables upsets the pipeline, so it is not done. Every memory reference has an explicit load or store instruction. The large register file makes this much less of a problem than it sounds.</SPAN></SPAN></FONT></P>
<P><FONT class=extract><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">Only one data-addressing mode</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">: Almost all loads and stores select the memory location with a single base register value modified by a 16-bit signed displacement (a limited register-plus-register address mode is available for floating-point data).</SPAN></SPAN></FONT></P>
<P><FONT class=extract><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">Byte-addressed</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">: Once data is in a register of a MIPS CPU, all operations always work on the whole register. But the semantics of languages such as C fit badly on a machine that can</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">t address memory locations down to byte granularity, so MIPS gets a complete set of load/store operations for 8- and 16-bit variables (we will say </SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">byte </SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">and </SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">halfword</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">). Once the data has arrived in a register it will be treated as data of full register length, so partial-word load instructions come in two flavors</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">&#8212;<SPAN lang=EN-US>sign-extend and zero-extend.</SPAN></SPAN></SPAN></FONT></P>
<P><FONT class=extract><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">Load/stores must be aligned</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">: Memory operations can only load or store data from addresses aligned to suit the data type being transferred. Bytes can be transferred at any address, but halfwords must be even-aligned and word transfers aligned to four-byte boundaries. Many CISC microprocessors will load/store a four-byte item from any byte address, but the penalty is extra clock cycles. However, the MIPS instruction set architecture (ISA) does include a couple of peculiar instructions to simplify the job of loading or storing at improperly aligned addresses.</SPAN></SPAN></FONT></P>
<P><FONT class=extract><SPAN style="mso-bookmark: OLE_LINK1"><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-49; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Italic-0-1000-49">Jump instructions</SPAN></I></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">: The limited 32-bit instruction length is a particular problem for branches in an architecture that wants to support very large programs. The smallest opcode field in a MIPS instruction is 6 bits, leaving 26 bits to define the target of a jump. Since all instructions are four-byte aligned in memory, the two least significant address bits need not be stored, allowing an address range of 228 = 256 MB. Rather than make this branch PC relative, this is interpreted as an absolute address within a 256-MB segment. That</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">s inconvenient for single programs larger than this, although it hasn</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">t been much of a problem yet! Branches out of segment can be achieved by using a jump register instruction, which can go to any 32-bit address. Conditional branches have only a 16-bit displacement field</SPAN></SPAN><SPAN style="mso-bookmark: OLE_LINK1"><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">&#8212;<SPAN lang=EN-US>giving a 218-byte range, since instructions are four-byte aligned</SPAN>&#8212;<SPAN lang=EN-US>which is interpreted as a signed PC-relative displacement. Compilers can only code a simple conditional branch instruction if they know that the target will be within 128 KB of the instruction following the branch.</SPAN></SPAN></SPAN></FONT></P></BODY>