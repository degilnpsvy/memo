All possible load/store address formats (addr): 
<P></P>
<P><FONT class=extract>MIPS machine instructions always generate addresses for load/store operations using just the contents of a register plus a 16-bit signed displacement,&#65288;1. Someone always has to break things; there are some register+register address formats but only for load/stores with floating-point registers. This is done in deference to the importance of multidimensional-array organizations in floating-point codes.&#65289; written, for example, lw $1,14($2). MIPS assemblers support quite a few other addressing mode formats; notably lw $1,thing,which loads data from the location whose assembly code label (or external C name) is &#8220;thing.&#8221; See section 9.4 for details; note that all of these modes are quietly available to any assembly instruction that specifies a memory address. We&#8217;ll just write lw t,addr for the assembly instruction and the base+ displacement format for the machine code. </FONT></P>
<P><FONT class=extract>The la (load address) instruction provided by the assembler uses the same addressing-mode syntax, even though it loads or stores nothing&#8212;it just generates the address value in the destination register. </FONT></P>
<P><FONT class=extract>When synthesizing some address formats (particularly on stores) the assembler needs a scratch register and quietly uses at. Programmers working in code where the implicit use of a register might matter (in an interrupt handler that hasn&#8217;t yet saved all preinterrupt register values, for instance) need to take care: The GNU assembler has a .set noat directive that prevents it.</FONT>