Think of the semaphore as having two values: 1 meaning &#8220;in use&#8221; and 0 meaning &#8220;available.&#8221; The signal() is simple; it sets the semaphore to 0.( 14. For a thread-to-thread semaphore in an OS, signal() also has to do something to &#8220;wake up&#8221; any other thread that was waiting on the semaphore.) wait() checks for the variable to have the value 0 and won&#8217;t continue until it does. It then sets the variable to 1 and returns. That should be easy, but you can see that it&#8217;s essential that the process of checking the value of sem and setting it again is itself atomic. <FONT class=extract>High-level atomicity (for threads calling wait()) is dependent on being able to build low-level atomicity, where a test-and-set operation can operate correctly in the face of interrupts (or, on a multiprocessor, in the face of access by other CPUs).</FONT>