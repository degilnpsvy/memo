<P class=Default style="MARGIN: 0cm 0cm 0pt"><B><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 13.5pt">6.1.2. Making </SPAN></B><B><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>errno </FONT></SPAN></B><B><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 13.5pt">reentrant </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 13.5pt"></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">Newlib encloses </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>errno </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">and several related values into a structure of type struct </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>_reent</FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">, and redefines the symbol errno as a macro that references a global </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>_reent* </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">pointer named </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>__impure_ptr</FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">. As a result, when a C statement refers to the value of </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>errno </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">under newlib, it is actually doing a pointer reference that resolves to the </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>errno </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">field in a data structure.3 </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">The code in Figure 2 describes in general how </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>errno </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">is modified under newlib. The code in Figure 3 is a common example of how to use </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>errno </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">in an ANSI C environment; because the reimplementation of </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>errno </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">is transparent to the application, this code works without modification under newlib. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">Figure 2. How errno is modified under newlib. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>#define errno (*__errno()) extern int *__errno ( void ); </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>static struct _reent impure_data = { 0, 0, "", 0, "C", ... }; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>struct _reent * _impure_ptr = &amp;impure_data; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>int * __errno () { return &amp;_impure_ptr-&gt;_errno; } </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>Figure 3. How to use errno. #include </FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 12pt; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt">fp = fopen("myfile.txt", "rw"); if (fp == NULL) { switch (errno) { case EACCES:</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">/* we don't have permissions */ ... </SPAN>