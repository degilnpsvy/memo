<P class=Default style="MARGIN: 0cm 0cm 0pt"><B><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 13.5pt">3.7. An embedded filesystem?! </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 13.5pt"></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">Newlib does not include a filesystem, but it may seem like it requires one for proper operation&#8212;especially considering that it provides file-oriented functions like </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>fprintf() </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">and </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>fseek()</FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">. However, although newlib likes to think that there is a stream-oriented filesystem working behind the scenes, its integration layer has been conveniently organized to not require this. </SPAN></FONT></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">Do not dismiss the utility of a filesystem-like abstraction in an embedded system, even in the most minimal designs. In addition to enabling greater portability between workstation and embedded environments, a file-oriented device API gives a consistent look and feel to your applications, regardless of the target system's underlying implementation. This helps make code more reusable, more cleanly defines the logical boundaries between application-specific and platform-specific code in a system, and provides a more familiar environment for new developers. </SPAN>