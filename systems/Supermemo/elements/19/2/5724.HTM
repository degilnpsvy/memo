<H3 class=section style="WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; LINE-HEIGHT: normal; FONT-STYLE: normal; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; FONT-VARIANT: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">2.25<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__malloc_lock</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__malloc_unlock</CODE>&#8212;lock malloc pool</H3>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><A name=index-g_t_005f_005fmalloc_005flock-55></A><A name=index-g_t_005f_005fmalloc_005funlock-56></A><STRONG>Synopsis</STRONG></P><PRE class=example style="FONT-WEIGHT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; LINE-HEIGHT: normal; FONT-STYLE: normal; LETTER-SPACING: normal; FONT-VARIANT: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">     #include &lt;malloc.h&gt;
     void __malloc_lock (struct _reent *<VAR>reent</VAR>);
     void __malloc_unlock (struct _reent *<VAR>reent</VAR>);
     
</PRE>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><STRONG>Description</STRONG><BR>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>malloc</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>family of routines call these functions when they need to lock the memory pool. The version of these routines supplied in the library use the lock API defined in sys/lock.h. If multiple threads of execution can call<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>malloc</CODE>, or if<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>malloc</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be called reentrantly, then you need to define your own versions of these functions in order to safely lock the memory pool during a call. If you do not, the memory pool may become corrupted.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">A call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>malloc</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>may call<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__malloc_lock</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>recursively; that is, the sequence of calls may go<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__malloc_lock</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__malloc_lock</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__malloc_unlock</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__malloc_unlock</CODE>. Any implementation of these routines must be careful to avoid causing a thread to wait for a lock that it already holds.