<B><SPAN lang=EN-US style="FONT-SIZE: 18pt; COLOR: black; mso-bidi-font-size: 13.5pt; mso-font-kerning: 0pt">6.10. _exit </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 18pt; COLOR: black; mso-bidi-font-size: 13.5pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; mso-bidi-font-size: 11.5pt; mso-font-kerning: 0pt">This stub forcibly terminates the application in response to the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">exit() </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; mso-bidi-font-size: 11.5pt; mso-font-kerning: 0pt">or </SPAN><SPAN lang=EN-US style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">system() </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; mso-bidi-font-size: 11.5pt; mso-font-kerning: 0pt">functions. There are several possiblities here, from allowing a watchdog timeout, to passing control to some kind of secondary application, to simulating a powerup reset in software. The Hitachi SH-2 CPU reads its initial program counter and stack pointer from the first eight bytes of memory, so the code in Figure 13 can be used to simulate a powerup reset. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; mso-bidi-font-size: 11.5pt; mso-font-kerning: 0pt">Figure 13. Simulating a powerup reset (Hitachi SH). </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">mov #-1, r0 ; disable interrupts ldc r0, sr </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">mov #4, r0 ; reset the stack pointer mov.l @r0, r15 </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">mov #0, r0 ; reset the program counter mov.l @r0, r0 jmp @r0 nop </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; mso-bidi-font-size: 11.5pt; mso-font-kerning: 0pt">The same approach can be used for most other processors, but you have to be careful here: this technique does not restore all of the target CPU's registers and peripherals to their powerup states, so application code can not depend on initial values for proper operation. In particular, device drivers cannot enable device interrupts prior to clearing any pending interrupt requests, or a spurious interrupt will result.</SPAN>