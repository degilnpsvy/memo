<H3 class=section style="WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; LINE-HEIGHT: normal; FONT-STYLE: normal; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; FONT-VARIANT: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">4.61<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>sscanf</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fscanf</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE>&#8212;scan and format input</H3>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><A name=index-scanf-297></A><A name=index-g_t_005fscanf_005fr-298></A><A name=index-fscanf-299></A><A name=index-g_t_005ffscanf_005fr-300></A><A name=index-sscanf-301></A><A name=index-g_t_005fsscanf_005fr-302></A><STRONG>Synopsis</STRONG></P><PRE class=example style="FONT-WEIGHT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; LINE-HEIGHT: normal; FONT-STYLE: normal; LETTER-SPACING: normal; FONT-VARIANT: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">     #include &lt;stdio.h&gt;
     
     int scanf(const char *<VAR>format</VAR>, ...);
     int fscanf(FILE *<VAR>fd</VAR>, const char *<VAR>format</VAR>, ...);
     int sscanf(const char *<VAR>str</VAR>, const char *<VAR>format</VAR>, ...);
     
     int _scanf_r(struct _reent *<VAR>ptr</VAR>, const char *<VAR>format</VAR>, ...);
     int _fscanf_r(struct _reent *<VAR>ptr</VAR>, FILE *<VAR>fd</VAR>,
         const char *<VAR>format</VAR>, ...);
     int _sscanf_r(struct _reent *<VAR>ptr</VAR>, const char *<VAR>str</VAR>,
         const char *<VAR>format</VAR>, ...);
     
</PRE>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><STRONG>Description</STRONG><BR><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>scans a series of input fields from standard input, one character at a time. Each field is interpreted according to a format specifier passed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the format string at<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>format</VAR>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>stores the interpreted input from each field at the address passed to it as the corresponding argument following<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>format</VAR>. You must supply the same number of format specifiers and address arguments as there are input fields.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">There must be sufficient address arguments for the given format specifiers; if not the results are unpredictable and likely disasterous. Excess address arguments are merely ignored.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>often produces unexpected results if the input diverges from an expected pattern. Since the combination of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>gets</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fgets</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>followed by<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>sscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is safe and easy, that is the preferred way to be certain that a program is synchronized with input at the end of a line.</FONT></P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><CODE>fscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>sscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are identical to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE>, other than the source of input:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>reads from a file, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>sscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>from a string.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">The routines<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>_scanf_r</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>_fscanf_r</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>_sscanf_r</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are reentrant versions of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fscanf</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>sscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>that take an additional first argument pointing to a reentrancy structure.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract>The string at<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>format</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a character sequence composed of zero or more directives. Directives are composed of one or more whitespace characters, non-whitespace characters, and format specifications.</FONT></P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract>Whitespace characters are blank ( ), tab (<CODE>\t</CODE>), or newline (<CODE>\n</CODE>). When<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>encounters a whitespace character in the format string it will read (but not store) all consecutive whitespace characters up to the next non-whitespace character in the input.</FONT></P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract>Non-whitespace characters are all other ASCII characters except the percent sign (<CODE>%</CODE>). When<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>encounters a non-whitespace character in the format string it will read, but not store a matching non-whitespace character.</FONT></P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract>Format specifications tell<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to read and convert characters from the input field into specific types of values, and store then in the locations specified by the address arguments.</FONT></P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract>Trailing whitespace is left unread unless explicitly matched in the format string.</FONT></P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract>The format specifiers must begin with a percent sign (<CODE>%</CODE>) and have the following form:</FONT></P><PRE class=smallexample style="FONT-WEIGHT: normal; FONT-SIZE: smaller; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; LINE-HEIGHT: normal; FONT-STYLE: normal; LETTER-SPACING: normal; FONT-VARIANT: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract>            %[*][<VAR>width</VAR>][<VAR>size</VAR>]<VAR>type</VAR>
</FONT></PRE>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract>Each format specification begins with the percent character (<CODE>%</CODE>). The other fields are:</FONT></P>
<DL style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DT><FONT class=extract><CODE>*</CODE> </FONT>
<DD><FONT class=extract>an optional marker; if present, it suppresses interpretation and assignment of this input field.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><VAR>width</VAR> </FONT>
<DD><FONT class=extract>an optional maximum field width: a decimal integer, which controls the maximum number of characters that will be read before converting the current input field. If the input field has fewer than<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>width</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>characters,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>reads all the characters in the field, and then proceeds with the next field and its format specification. </FONT>
<P><FONT class=extract>If a whitespace or a non-convertable character occurs before<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>width</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>character are read, the characters up to that character are read, converted, and stored. Then<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>proceeds to the next format specification.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT></P>
<DT><FONT class=extract><CODE>size</CODE> </FONT>
<DD><FONT class=extract><CODE>h</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>j</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>l</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>L</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>t</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>z</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are optional size characters which override the default way that<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>interprets the data type of the corresponding argument.</FONT><PRE class=smallexample style="FONT-SIZE: smaller"><FONT class=extract>          Modifier   Type(s)
             hh      d, i, o, u, x, n  convert input to char,
                                       store in char object
          
             h       d, i, o, u, x, n  convert input to short,
                                       store in short object
          
             h       D, I, O, U, X     no effect
                     e, f, c, s, p
          
             j       d, i, o, u, x, n  convert input to intmax_t,
                                       store in intmax_t object
          
             j       all others        no effect
          
             l       d, i, o, u, x, n  convert input to long,
                                       store in long object
          
             l       e, f, g           convert input to double
                                       store in a double object
          
             l       D, I, O, U, X     no effect
                     c, s, p
          
             ll      d, i, o, u, x, n  convert to long long,
                                       store in long long
          
             L       d, i, o, u, x, n  convert to long long,
                                       store in long long
          
             L       e, f, g, E, G     convert to long double,
                                       store in long double
          
             L       all others        no effect
          
             t       d, i, o, u, x, n  convert input to ptrdiff_t,
                                       store in ptrdiff_t object
          
             t       all others        no effect
          
             z       d, i, o, u, x, n  convert input to size_t,
                                       store in size_t object
          
             z       all others        no effect
          
</FONT></PRE><BR>
<DT><FONT class=extract><VAR>type</VAR> </FONT>
<DD><FONT class=extract>A character to specify what kind of conversion<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>performs. Here is a table of the conversion characters: </FONT>
<DL>
<DT><FONT class=extract><CODE>%</CODE> </FONT>
<DD><FONT class=extract>No conversion is done; the percent character (<CODE>%</CODE>) is stored.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>c</CODE> </FONT>
<DD><FONT class=extract>Scans one character. Corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(char *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>s</CODE> </FONT>
<DD><FONT class=extract>Reads a character string into the array supplied. Corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(char arg[])</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>[</CODE><VAR>pattern</VAR><CODE>]</CODE> </FONT>
<DD><FONT class=extract>Reads a non-empty character string into memory starting at<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>. This area must be large enough to accept the sequence and a terminating null character which will be added automatically. (<VAR>pattern</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is discussed in the paragraph following this table). Corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(char *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>d</CODE> </FONT>
<DD><FONT class=extract>Reads a decimal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(int *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>D</CODE> </FONT>
<DD><FONT class=extract>Reads a decimal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(long *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>o</CODE> </FONT>
<DD><FONT class=extract>Reads an octal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(int *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>O</CODE> </FONT>
<DD><FONT class=extract>Reads an octal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(long *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>u</CODE> </FONT>
<DD><FONT class=extract>Reads an unsigned decimal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(unsigned int *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>U</CODE> </FONT>
<DD><FONT class=extract>Reads an unsigned decimal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(unsigned long *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>x,X</CODE> </FONT>
<DD><FONT class=extract>Read a hexadecimal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(int *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>e, f, g</CODE> </FONT>
<DD><FONT class=extract>Read a floating-point number into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(float *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>E, F, G</CODE> </FONT>
<DD><FONT class=extract>Read a floating-point number into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(double *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>i</CODE> </FONT>
<DD><FONT class=extract>Reads a decimal, octal or hexadecimal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(int *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>I</CODE> </FONT>
<DD><FONT class=extract>Reads a decimal, octal or hexadecimal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(long *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>n</CODE> </FONT>
<DD><FONT class=extract>Stores the number of characters read in the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(int *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>p</CODE> </FONT>
<DD><FONT class=extract>Stores a scanned pointer. ANSI C leaves the details to each implementation; this implementation treats<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>%p</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>exactly the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>%U</CODE>. Corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<CODE>(void **arg)</CODE>.</FONT></DD></DL>
<P><FONT class=extract>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>pattern</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>of characters surrounded by square brackets can be used instead of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>s</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>type character.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>pattern</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a set of characters which define a search set of possible characters making up the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>input field. If the first character in the brackets is a caret (<CODE>^</CODE>), the search set is inverted to include all ASCII characters except those between the brackets. There is also a range facility which you can use as a shortcut.<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>%[0-9]<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE>matches all decimal digits. The hyphen must not be the first or last character in the set. The character prior to the hyphen must be lexically less than the character after it.</FONT></P>
<P><FONT class=extract>Here are some<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>pattern</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>examples:</FONT></P>
<DL>
<DT><FONT class=extract><CODE>%[abcd]</CODE> </FONT>
<DD><FONT class=extract>matches strings containing only<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>b</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>c</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>d</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>%[^abcd]</CODE> </FONT>
<DD><FONT class=extract>matches strings containing any characters except<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>b</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>c</CODE>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>d</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>%[A-DW-Z]</CODE> </FONT>
<DD><FONT class=extract>matches strings containing<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>A</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>B</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>C</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>D</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>W</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>X</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Y</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Z</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></FONT>
<DT><FONT class=extract><CODE>%[z-a]</CODE> </FONT>
<DD><FONT class=extract>matches the characters<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>z</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a</CODE></FONT></DD></DL>
<P><FONT class=extract>Floating point numbers (for field types<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>e</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>f</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>g</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>E</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>F</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>G</CODE>) must correspond to the following general form:</FONT></P><PRE class=smallexample style="FONT-SIZE: smaller"><FONT class=extract>          		[+/-] ddddd[.]ddd [E|e[+|-]ddd]
</FONT></PRE>
<P><FONT class=extract>where objects inclosed in square brackets are optional, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>ddd</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>represents decimal, octal, or hexadecimal digits.</FONT></P></DD></DL>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><BR><STRONG>Returns</STRONG><BR><FONT class=extract><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns the number of input fields successfully scanned, converted and stored; the return value does not include scanned fields which were not stored.</FONT></P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract>If<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attempts to read at end-of-file, the return value is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>EOF</CODE>.</FONT></P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">If no fields were stored, the return value is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>0</CODE>.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>might stop scanning a particular field before reaching the normal field end character, or may terminate entirely.</FONT></P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>stops scanning and storing the current field and moves to the next input field (if any) in any of the following situations:</FONT></P>
<UL style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<LI><FONT class=extract>The assignment suppressing character (<CODE>*</CODE>) appears after the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>%</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the format specification; the current input field is scanned but not stored. </FONT>
<LI><FONT class=extract><VAR>width</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>characters have been read (<VAR>width</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a width specification, a positive decimal integer). </FONT>
<LI><FONT class=extract>The next character read cannot be converted under the the current format (for example, if a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Z</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is read when the format is decimal). </FONT>
<LI><FONT class=extract>The next character in the input field does not appear in the search set (or does appear in the inverted search set).</FONT></LI></UL>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract>When<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>stops scanning the current input field for one of these reasons, the next character is considered unread and used as the first character of the following input field, or the first character in a subsequent read operation on the input.</FONT></P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>will terminate under the following circumstances:</FONT></P>
<UL style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<LI><FONT class=extract>The next character in the input field conflicts with a corresponding non-whitespace character in the format string. </FONT>
<LI><FONT class=extract>The next character in the input field is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>EOF</CODE>. </FONT>
<LI><FONT class=extract>The format string has been exhausted.</FONT></LI></UL>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><FONT class=extract>When the format string contains a character sequence that is not part of a format specification, the same character sequence must appear in the input;<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE>will scan but not store the matched characters. If a conflict occurs, the first conflicting character remains in the input as if it had never been read.</FONT></P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><BR><STRONG>Portability</STRONG><BR><CODE>scanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is ANSI C.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">Supporting OS subroutines required:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>close</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fstat</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>isatty</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lseek</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>read</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>sbrk</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>write</CODE>.