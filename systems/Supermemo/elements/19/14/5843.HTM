<H3 class=section style="WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; LINE-HEIGHT: normal; FONT-STYLE: normal; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; FONT-VARIANT: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">4.63<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>swscanf</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fwscanf</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE>&#8212;scan and format wide character input</H3>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><A name=index-wscanf-309></A><A name=index-g_t_005fwscanf_005fr-310></A><A name=index-fwscanf-311></A><A name=index-g_t_005ffwscanf_005fr-312></A><A name=index-swscanf-313></A><A name=index-g_t_005fswscanf_005fr-314></A><STRONG>Synopsis</STRONG></P><PRE class=example style="FONT-WEIGHT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; LINE-HEIGHT: normal; FONT-STYLE: normal; LETTER-SPACING: normal; FONT-VARIANT: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">     #include &lt;stdio.h&gt;
     
     int wscanf(const wchar_t *<VAR>format</VAR>, ...);
     int fwscanf(FILE *<VAR>fd</VAR>, const wchar_t *<VAR>format</VAR>, ...);
     int swscanf(const wchar_t *<VAR>str</VAR>, const wchar_t *<VAR>format</VAR>, ...);
     
     int _wscanf_r(struct _reent *<VAR>ptr</VAR>, const wchar_t *<VAR>format</VAR>, ...);
     int _fwscanf_r(struct _reent *<VAR>ptr</VAR>, FILE *<VAR>fd</VAR>,
         const wchar_t *<VAR>format</VAR>, ...);
     int _swscanf_r(struct _reent *<VAR>ptr</VAR>, const wchar_t *<VAR>str</VAR>,
         const wchar_t *<VAR>format</VAR>, ...);
     
</PRE>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><STRONG>Description</STRONG><BR><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>scans a series of input fields from standard input, one wide character at a time. Each field is interpreted according to a format specifier passed to<CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the format string at<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>format</VAR>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>stores the interpreted input from each field at the address passed to it as the corresponding argument following<VAR>format</VAR>. You must supply the same number of format specifiers and address arguments as there are input fields.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">There must be sufficient address arguments for the given format specifiers; if not the results are unpredictable and likely disasterous. Excess address arguments are merely ignored.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>often produces unexpected results if the input diverges from an expected pattern. Since the combination of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>gets</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fgets</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>followed by<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>swscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is safe and easy, that is the preferred way to be certain that a program is synchronized with input at the end of a line.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><CODE>fwscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>swscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are identical to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE>, other than the source of input:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fwscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>reads from a file, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>swscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>from a string.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">The routines<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>_wscanf_r</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>_fwscanf_r</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>_swscanf_r</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are reentrant versions of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fwscanf</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>swscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>that take an additional first argument pointing to a reentrancy structure.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">The string at<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>format</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a wide character sequence composed of zero or more directives. Directives are composed of one or more whitespace characters, non-whitespace characters, and format specifications.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">Whitespace characters are blank ( ), tab (<CODE>\t</CODE>), or newline (<CODE>\n</CODE>). When<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>encounters a whitespace character in the format string it will read (but not store) all consecutive whitespace characters up to the next non-whitespace character in the input.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">Non-whitespace characters are all other ASCII characters except the percent sign (<CODE>%</CODE>). When<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>encounters a non-whitespace character in the format string it will read, but not store a matching non-whitespace character.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">Format specifications tell<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to read and convert characters from the input field into specific types of values, and store then in the locations specified by the address arguments.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">Trailing whitespace is left unread unless explicitly matched in the format string.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">The format specifiers must begin with a percent sign (<CODE>%</CODE>) and have the following form:</P><PRE class=smallexample style="FONT-WEIGHT: normal; FONT-SIZE: smaller; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; LINE-HEIGHT: normal; FONT-STYLE: normal; LETTER-SPACING: normal; FONT-VARIANT: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">            %[*][<VAR>width</VAR>][<VAR>size</VAR>]<VAR>type</VAR>
</PRE>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">Each format specification begins with the percent character (<CODE>%</CODE>). The other fields are:</P>
<DL style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<DT><CODE>*</CODE> 
<DD>an optional marker; if present, it suppresses interpretation and assignment of this input field.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><VAR>width</VAR> 
<DD>an optional maximum field width: a decimal integer, which controls the maximum number of characters that will be read before converting the current input field. If the input field has fewer than<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>width</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>characters,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>reads all the characters in the field, and then proceeds with the next field and its format specification. 
<P>If a whitespace or a non-convertable wide character occurs before<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>width</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>character are read, the characters up to that character are read, converted, and stored. Then<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>proceeds to the next format specification.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P>
<DT><CODE>size</CODE> 
<DD><CODE>h</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>j</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>l</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>L</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>t</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>z</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are optional size characters which override the default way that<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>interprets the data type of the corresponding argument.<PRE class=smallexample style="FONT-SIZE: smaller">          Modifier   Type(s)
             hh      d, i, o, u, x, n  convert input to char,
                                       store in char object
          
             h       d, i, o, u, x, n  convert input to short,
                                       store in short object
          
             h       e, f, c, s, p     no effect
          
             j       d, i, o, u, x, n  convert input to intmax_t,
                                       store in intmax_t object
          
             j       all others        no effect
          
             l       d, i, o, u, x, n  convert input to long,
                                       store in long object
          
             l       e, f, g           convert input to double
                                       store in a double object
          
             l       c, s, [           the input is stored in a wchar_t object
          
             l       p                 no effect
          
             ll      d, i, o, u, x, n  convert to long long,
                                       store in long long
          
             L       d, i, o, u, x, n  convert to long long,
                                       store in long long
          
             L       e, f, g, E, G     convert to long double,
                                       store in long double
          
             L       all others        no effect
          
             t       d, i, o, u, x, n  convert input to ptrdiff_t,
                                       store in ptrdiff_t object
          
             t       all others        no effect
          
             z       d, i, o, u, x, n  convert input to size_t,
                                       store in size_t object
          
             z       all others        no effect
          
</PRE><BR>
<DT><VAR>type</VAR> 
<DD>A character to specify what kind of conversion<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>performs. Here is a table of the conversion characters: 
<DL>
<DT><CODE>%</CODE> 
<DD>No conversion is done; the percent character (<CODE>%</CODE>) is stored.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>c</CODE> 
<DD>Scans one wide character. Corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(char *arg)</CODE>. Otherwise, if an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>l</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>specifier is present, the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(wchar_t *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>s</CODE> 
<DD>Reads a character string into the array supplied. Corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(char arg[])</CODE>. If an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>l</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>specifier is present, the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(wchar_t *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>[</CODE><VAR>pattern</VAR><CODE>]</CODE> 
<DD>Reads a non-empty character string into memory starting at<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>. This area must be large enough to accept the sequence and a terminating null character which will be added automatically. (<VAR>pattern</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is discussed in the paragraph following this table). Corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(char *arg)</CODE>. If an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>l</CODE>specifier is present, the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(wchar_t *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>d</CODE> 
<DD>Reads a decimal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(int *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>o</CODE> 
<DD>Reads an octal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(int *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>u</CODE> 
<DD>Reads an unsigned decimal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(unsigned int *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>x,X</CODE> 
<DD>Read a hexadecimal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(int *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>e, f, g</CODE> 
<DD>Read a floating-point number into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(float *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>E, F, G</CODE> 
<DD>Read a floating-point number into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(double *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>i</CODE> 
<DD>Reads a decimal, octal or hexadecimal integer into the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(int *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>n</CODE> 
<DD>Stores the number of characters read in the corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(int *arg)</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>p</CODE> 
<DD>Stores a scanned pointer. ANSI C leaves the details to each implementation; this implementation treats<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>%p</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>exactly the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>%U</CODE>. Corresponding<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>arg</VAR>:<CODE>(void **arg)</CODE>.</DD></DL>
<P>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>pattern</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>of characters surrounded by square brackets can be used instead of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>s</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>type character.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>pattern</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a set of characters which define a search set of possible characters making up the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>input field. If the first character in the brackets is a caret (<CODE>^</CODE>), the search set is inverted to include all ASCII characters except those between the brackets. There is no range facility as is defined in the corresponding non-wide character scanf functions. Ranges are not part of the POSIX standard.</P>
<P>Here are some<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>pattern</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>examples:</P>
<DL>
<DT><CODE>%[abcd]</CODE> 
<DD>matches wide character strings containing only<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>b</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>c</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>d</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>%[^abcd]</CODE> 
<DD>matches wide character strings containing any characters except<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>b</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>c</CODE>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>d</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR>
<DT><CODE>%[A-DW-Z]</CODE> 
<DD>Note: No wide character ranges, so this expression matches wide character strings containing<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>A</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>D</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>W</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Z</CODE>.</DD></DL>
<P>Floating point numbers (for field types<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>e</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>f</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>g</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>E</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>F</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>G</CODE>) must correspond to the following general form:</P><PRE class=smallexample style="FONT-SIZE: smaller">          		[+/-] ddddd[.]ddd [E|e[+|-]ddd]
</PRE>
<P>where objects inclosed in square brackets are optional, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>ddd</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>represents decimal, octal, or hexadecimal digits.</P></DD></DL>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><BR><STRONG>Returns</STRONG><BR><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns the number of input fields successfully scanned, converted and stored; the return value does not include scanned fields which were not stored.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">If<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attempts to read at end-of-file, the return value is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>EOF</CODE>.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">If no fields were stored, the return value is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>0</CODE>.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>might stop scanning a particular field before reaching the normal field end character, or may terminate entirely.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>stops scanning and storing the current field and moves to the next input field (if any) in any of the following situations:</P>
<UL style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<LI>The assignment suppressing character (<CODE>*</CODE>) appears after the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>%</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the format specification; the current input field is scanned but not stored. 
<LI><VAR>width</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>characters have been read (<VAR>width</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a width specification, a positive decimal integer). 
<LI>The next wide character read cannot be converted under the the current format (for example, if a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Z</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is read when the format is decimal). 
<LI>The next wide character in the input field does not appear in the search set (or does appear in the inverted search set).</LI></UL>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">When<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>stops scanning the current input field for one of these reasons, the next character is considered unread and used as the first character of the following input field, or the first character in a subsequent read operation on the input.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>will terminate under the following circumstances:</P>
<UL style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">
<LI>The next wide character in the input field conflicts with a corresponding non-whitespace character in the format string. 
<LI>The next wide character in the input field is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>WEOF</CODE>. 
<LI>The format string has been exhausted.</LI></UL>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">When the format string contains a wide character sequence that is not part of a format specification, the same wide character sequence must appear in the input;<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>will scan but not store the matched characters. If a conflict occurs, the first conflicting wide character remains in the input as if it had never been read.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px"><BR><STRONG>Portability</STRONG><BR><CODE>wscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is C99, POSIX-1.2008.</P>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">Supporting OS subroutines required:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>close</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fstat</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>isatty</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>lseek</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>read</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>sbrk</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>write</CODE>.