<P class=Default style="MARGIN: 0cm 0cm 0pt"><B><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 13.5pt">6.8. </SPAN></B><B><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>__malloc_lock </FONT></SPAN></B><B><SPAN lang=EN-US style="FONT-SIZE: 18pt; mso-bidi-font-size: 13.5pt">and </SPAN></B><FONT size=3><B><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt">__malloc_unlock </SPAN></B><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"></SPAN></FONT></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">Newlib's memory management routines like </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>malloc() </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">call these functions when they need to manipulate the memory heap. By implementing mutual exclusion in them, you make newlib's memory management code reentrant&#8212;or at least thread safe. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">Portions of newlib's memory management code are recursive, so you will often see the following sequence of invocations in response to a </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>malloc() </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">function call: </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>__malloc_lock, __malloc_lock, __malloc_unlock, __malloc_unlock </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">The tricky part here is that, if you aren't careful, the second </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>__malloc_lock </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">will cause itself to wait for a lock that it already holds from the first </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>__malloc_lock</FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">There are two ways to solve this problem. The first is to simply punt, and reimplement </SPAN><SPAN lang=EN-US style="FONT-SIZE: 12pt; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt">malloc() </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">in its entirety using uC/OS's reentrant memory pool API. The second option is to really implement a working </SPAN><SPAN lang=EN-US style="FONT-SIZE: 12pt; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt">__malloc_lock </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">and </SPAN><SPAN lang=EN-US style="FONT-SIZE: 12pt; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt">__malloc_unlock</SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">. Both approaches</SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">have their advantages, and which one you choose will depend on how your application needs to use dynamic memory. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">Figure 11 is an example of how to use uC/OS memory pools to implement </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>malloc()</FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">. In this code, each allocation request consumes one block from the memory pool, whether the allocation needs that much space or not. Furthermore, if the allocation size exceeds the block size then the request fails, because uC/OS's memory block manager does not permit this. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">Figure 11. Implementing </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>malloc() </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">with a memory pool. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* number of bytes per allocation */ #define HEAPBLKSIZE 64 </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* number of allocations available */ #define HEAPBLKS 1024 </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* our heap */ OS_MEM *heap; unsigned char heapmem[HEAPBLKS * HEAPBLKSIZE]; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>void *malloc ( size_t size ) { INT8U err = OS_NO_ERR; void *alloc = 0; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* initialize, if necessary */ OS_ENTER_CRITICAL(); if( !heap ) heap = OSMemCreate( heapmem, HEAPBLKS, HEAPBLKSIZE, &amp;err ); OS_EXIT_CRITICAL(); </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>if( heap &amp;&amp; err == OS_NO_ERR ) { </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* if the request fits the heap block length, then make the allocation from the heap */ if( size &lt;= HEAPBLKSIZE ) alloc = OSMemGet( heap, &amp;err ); </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* otherwise, we're sunk */ else err = OS_MEM_NO_FREE_BLKS; } </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* deny the allocation on errors */ if( err != OS_NO_ERR ) alloc = 0; </FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 12pt; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt">return alloc; }</SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">Using uC/OS's memory pools eliminates fragmentation worries and makes </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>malloc() </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">reentrant, but wastes memory if the pool's block size doesn't match up with the typical allocation request. You reduce some of the waste by providing buffer pools of several different sizes (perhaps corresponding to the sizes of data structures you know you will be frequently allocating memory for), but this approach is hardly generic&#8212;particularly when a distribution of sizes is needed. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">For situations where you need a range of allocation sizes, or the size of the largest potential allocation request is unknown, use newlib's memory allocator and implement </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>__malloc_lock </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">and </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>__malloc_unlock </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">functions. Figure 12 shows how to do that. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">Figure 12. The </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>__malloc_lock </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">and </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>__malloc_unlock </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">functions. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* semaphore to protect the heap */ static OS_EVENT *heapsem; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* id of the task that is currently manipulating the heap */ static int lockid; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* number of times __malloc_lock has recursed */ static int locks; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>void __malloc_lock ( struct _reent *_r ) { OS_TCB tcb; OS_SEM_DATA semdata; INT8U err; int id; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* use our priority as a task id */ OSTaskQuery( OS_PRIO_SELF, &amp;tcb ); id = tcb.OSTCBPrio; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* see if we own the heap already */ OSSemQuery( heapsem, &amp;semdata ); if( semdata.OSEventGrp &amp;&amp; id == lockid ) { </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* we do; just count the recursion */ locks++; } </FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 12pt; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt">else { /* wait on the other task to yield the heap, then claim ownership of it */ OSSemPend( heapsem, 0, &amp;err ); lockid = id; }</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">return; } </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">void __malloc_unlock ( struct _reent *_r ) { /* release the heap once the number of locks == the number of unlocks */ if( (--locks) == 0 ) { lockid = -1; OSSemPost( heapsem ); } } </SPAN>