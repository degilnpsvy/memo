<B><SPAN lang=EN-US style="FONT-SIZE: 18pt; COLOR: black; mso-bidi-font-size: 13.5pt; mso-font-kerning: 0pt">6.7. </SPAN></B><B><SPAN lang=EN-US style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">_sbrk_r </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; mso-bidi-font-size: 11.5pt; mso-font-kerning: 0pt">Newlib calls this stub whenever </SPAN><SPAN lang=EN-US style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">malloc() </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; mso-bidi-font-size: 11.5pt; mso-font-kerning: 0pt">runs out of heap space and wants more. As it turns out, this happens frequently&#8212;newlib's memory allocator will only ask for incremental chunks of memory, a benign artifact of its UNIX heritage. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; mso-bidi-font-size: 11.5pt; mso-font-kerning: 0pt">Assuming a reserved a heap memory area using a character array called </SPAN><SPAN lang=EN-US style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">_heap</SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; mso-bidi-font-size: 11.5pt; mso-font-kerning: 0pt">, the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt">_sbrk_r </SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; COLOR: black; mso-bidi-font-size: 11.5pt; mso-font-kerning: 0pt">stub would look like the code in Figure 10.</SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">Figure 10. The </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>_sbrk_r </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">stub. </SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>unsigned char _heap[HEAPSIZE]; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>caddr_t _sbrk_r ( int incr ) { static unsigned char *heap_end; unsigned char *prev_heap_end; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* initialize */ if( heap_end == 0 ) heap_end = heap; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>prev_heap_end = heap_end; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>if( heap_end + incr - heap &gt; HEAPSIZE ) { </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>/* heap overflow&#8212;announce on stderr */ write( 2, "Heap overflow!\n", 15 ); abort(); } </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>heap_end += incr; </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>return (caddr_t) prev_heap_end; } </FONT></SPAN></P>
<P class=Default style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">Each time </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>malloc() </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">calls </SPAN><SPAN lang=EN-US style="FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt"><FONT size=3>_sbrk_r </FONT></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 11.5pt">the heap end grows by incr bytes. When it encounters the end of the allocated heap space (which hopefully never occurs), the stub sends a message to the standard error stream, then forcibly terminates the program. Another approach to a heap overflow would be to return NULL, and let the application find a way to muddle through on its own. </SPAN>