<B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">ld</SPAN></B><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Arial; mso-font-kerning: 0pt">, the GNU Linker</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">The GNU linker, </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">ld</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">, resolves the code addresses, object and archive files, relocates their data, links the startup code and additional libraries to the binary code, combines symbol references, and, usually as the last step in compiling a program, produces an executable binary image. This means producing a <I>linker script </I>to control every link; such a script derives from the linker command language.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">The main purpose of a linker script is to describe how <I>sections </I>in the input files should map into the output file and to control memory layout of the output file. When necessary, the linker script also directs the linker to perform other operations. For an example of a linker script, see &#8220;The Linker Script&#8221; on page 44.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">The linker combines an output file and each input file in a special data format known as an <I>object file format</I>, with each file being an object file. The output file is often called an executable, but for simplicity, refer to it as an object file.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">Each object file has, among other things, a list of <I>sections</I>. </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">ld </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">reads many object files (partial programs) and combines their contents to form a program that will run. When the GNU assembler, </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">as</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">, emits an object file, the partial program is assumed to start at address, </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">0</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">. Then, </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">ld </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">assigns the final addresses for the partial program, so that different partial programs do not overlap. This is actually an oversimplification of relocation, but it suffices to explain how </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">as </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">uses sections. </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">ld </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">moves blocks of bytes of your program to their run-time addresses. These blocks slide to their run-time addresses as rigid units; their length does not change and neither does the order of bytes within them. Such a rigid unit is called a <I>section</I>. Assigning run-time addresses to sections is called <I>relocation</I>. It includes the task of adjusting mentions of object-file addresses so they refer to the proper run-time addresses. For the H8/300 and H8/500, and for the Hitachi SH, for instance, </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">as </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">pads sections if needed to ensure they end on a word (16 bit) boundary. A section is in an input file as an input section; similarly, a section in an output file is an output section. Each section in an object file has a name and a size. Most sections also have an associated block of data, known as the <I>section contents</I>. A section may be marked as <I>loadable</I>, meaning to load the contents into memory when running the output file. A section with no contents may be <I>allocatable</I>, meaning to set aside an area in memory, but without loading anything there (in some cases this memory must be <I>zeroed out</I>).</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">A section, which is neither loadable nor allocatable, typically contains some sort of debugging information. Every loadable or allocatable output section has two addresses. The first is the <I>virtual memory address </I>(VMA), the address the section will have when the running the output file. The second is the <I>load memory address </I>(LMA), the address at which the section will load. In most cases the two addresses will be the same. An example of when they might be different is when a data section is loaded into ROM, and then copied into RAM when the program starts (this technique is often used to initialize global variables in a ROM-based system); in this case, the ROM address would be the LMA, and the RAM address would be the VMA. To see the sections in an object file, use the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">objdump </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">binary utility with the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">-h </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">option. </SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">Every object file also has a list of <I>symbols</I>, known as the <I>symbol table</I>. A symbol may be defined or undefined. Each symbol has a name, and each defined symbol has an address, among other information. If you compile a C or C++ program into an object file, you will get a defined symbol for every defined function and global or static variable. Every undefined function or global variable, which is referenced in the input file, will become an undefined symbol. You can see the symbols in an object file by using the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">nm </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">binary utility, or by using the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">objdump </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">binary utility with the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">-t </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">option. The linker will use a default script that compiles into the linker executable, if you do not supply one. Use the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">--verbose </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">option to display the default linker script. Certain options (such as </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">-r </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">or </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">-N</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">) will affect the default linker script. Supply your own linker script with the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">-T </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">option. Use linker scripts implicitly by naming them as input files to the linker, as though they were files to be linked.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">ld </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">accepts linker command language files written in a superset of AT&amp;T&#8217;s <I>Link Editor Command Language </I>syntax, to provide explicit and total control over the linking process. </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">ld </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">uses the general purpose BFD libraries to operate on object files (libraries whose name derives from <I>binary file descriptors</I>); </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">ld </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">can then read, combine, and write object files in many different formats, such as COFF or </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">a.out </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">formats, for instance. You can link different formats to produce any available kind of object file. Aside from its flexibility, the GNU linker is more helpful than other linker in providing diagnostic information. Many linkers stop executing upon encountering an error, for example, whereas </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">ld </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">continues executing, whenever possible, allowing you to identify other errors (or, in some cases, to get an output file in despite the error).</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">For more information, see <I>Using </I></SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">ld </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">in <B><I>GNUPro Development Tools</I></B>.</SPAN>