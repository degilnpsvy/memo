<B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">gdb</SPAN></B><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Arial; mso-font-kerning: 0pt">, the Debugging Tool</SPAN></B> 
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">The GNU debugger, </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">gdb</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">, has a principal purpose of allowing you to stop your program before it terminates. When your program stops, you must determine where it stopped and how it got there. With a command line approach when compiling on a </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">file.c </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">file, use </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">gcc -g -o directory file.c </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">as a command; </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">-g </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">produces the debugging information. Then, run the debugger, using the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">gdb file.c </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">command on the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">directory</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">&#8217;s </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">file.c </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">file. See &#8220;Insight, a GUI Debugger&#8221; (below) for an introduction to the graphical user interface for the GNU debugger.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">Set breakpoints with the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">breakpoint </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">command.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">Navigate through the program with the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">step </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">command or the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">next </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">command. The debugger debugs threads, signals, trace information, and other data in a program. Each time your program performs a function call, information generates about the call, a block of data (the <I>stack frame</I>), which shows the location of the call, the arguments, and the local variables of a function. This debugger examines the stack frame to get your program to work.</SPAN></P>
<P><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">To create more efficient, faster running code, before debugging, use profiling (with the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">gprof </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">tool) and test coverage (with the </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">gcov </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">tool) to analyze your programs.</SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">Use a </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier; mso-bidi-font-family: Courier; mso-font-kerning: 0pt">gdb </SPAN><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">backend </SPAN></I><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">with its standard remote protocol. The backend&#8217;s standard remote protocol is for transmitting packets of data when communicating with a target and finding errors when debugging a program. Similar protocols will suffice, as long as they provide for the debugger to have reading and writing of registers and memory, being able to start execution at an address, single stepping, being able to read a last signal, and, often, resetting the hardware. The following two types of backend are the most common:</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: AdobePiStd; mso-bidi-font-family: AdobePiStd; mso-font-kerning: 0pt">n </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">A <I>stub </I>(a subroutine) that serves as an exception handler for breakpoints; it must link to your application. Stubs use the standard remote protocol.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: AdobePiStd; mso-bidi-font-family: AdobePiStd; mso-font-kerning: 0pt">n </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">An existing ROM monitor used as a backend; the most common approach means using the following processes:</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: AdobePiStd; mso-bidi-font-family: AdobePiStd; mso-font-kerning: 0pt">n </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">With a similar protocol to the standard remote protocol</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: AdobePiStd; mso-bidi-font-family: AdobePiStd; mso-font-kerning: 0pt">n </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">With an interface that directly uses the ROM monitor; with such an interface, the debugger only formats and parses commands.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">All the ROM monitor interfaces share a common set of routines. For more information on <FONT class=extract>Cygmon, the GNUPro ROM monitor simulation tool</FONT>, see &#8220;Using Cygmon for Remote Debugging&#8221; on page 57.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt">For more information on the GNU debugger, see <I>Debugging with GDB </I>in <B><I>GNUPro Debugging Tools</I></B>. See also &#8220;Using Insight, the GUI Debugger&#8221; on page 74 and <I>Insight, the GNUPro Debugger GUI Interface </I>in <B><I>GNUPro Debugging Tools</I></B>.</SPAN>