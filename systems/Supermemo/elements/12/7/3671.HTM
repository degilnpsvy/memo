<B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Bold-0-1000-22; mso-bidi-font-family: Minion-Bold-0-1000-22; mso-font-kerning: 0pt">11.2.1 </SPAN></B><B><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-BoldItalic-0-1000-50; mso-bidi-font-family: Minion-BoldItalic-0-1000-50; mso-font-kerning: 0pt">The Stack, Subroutine Linkage, and Parameter Passing</SPAN></I></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">From the very start of MIPS</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt; mso-fareast-font-family: Minion-Regular-0-1000-20; mso-ascii-font-family: Minion-Regular-0-1000-20">&#8217;</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt"> existence in the early 1980s, there was a set of conventions about how to pass arguments to functions (this is C-speak for </SPAN><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">&#8220;<SPAN lang=EN-US>pass parameters to subroutines</SPAN>&#8221;<SPAN lang=EN-US>) and about how to return values from functions.</SPAN></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">These conventions follow logically from an underlying principle: All arguments are allocated space in a data structure on the stack, but the contents that belong to the first few stack locations are in fact passed in CPU registers</SPAN><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">&#8212;<SPAN lang=EN-US>the corresponding memory locations are left undefined. In practice, this means that for most calls, the arguments are all passed in registers; however, the stack data structure (even when nothing is put in it) is the best starting point for understanding the process.</SPAN></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">We</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt; mso-fareast-font-family: Minion-Regular-0-1000-20; mso-ascii-font-family: Minion-Regular-0-1000-20">&#8217;</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">ll describe the argument passing and stack features of the o32 standard in some detail, and then summarize the changes with n32 and n64 in section 11.2.8.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">There has been much discussion about improving these standards: o32 is very old, and programming habits have changed since its invention. We hope something good comes out of all these discussions</SPAN><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">&#8212;<SPAN lang=EN-US>but at the time of writing (Spring 2006) and for the for seeable future, you will be using o32 compilers for embedded applications on 32-bit MIPS CPUs, and you won</SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt; mso-fareast-font-family: Minion-Regular-0-1000-20; mso-ascii-font-family: Minion-Regular-0-1000-20">&#8217;</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">t lose a lot.</SPAN>