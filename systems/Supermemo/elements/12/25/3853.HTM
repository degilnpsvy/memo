<B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Bold-0-1000-23; mso-bidi-font-family: Minion-Bold-0-1000-23; mso-font-kerning: 0pt">10.4.2 </SPAN></B><B><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-BoldItalic-0-1000-34; mso-bidi-font-family: Minion-BoldItalic-0-1000-34; mso-font-kerning: 0pt"><FONT class=extract>Implementing wbflush</FONT></SPAN></I></B> 
<P></P>
<P><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-21; mso-bidi-font-family: Minion-Regular-0-1000-21; mso-font-kerning: 0pt">Most write queues can be emptied out by performing an uncached store to any location and then performing an operation that reads the same data back. A write queue certainly can</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-family: Minion-Regular-0-1000-21; mso-font-kerning: 0pt; mso-fareast-font-family: Minion-Regular-0-1000-21; mso-ascii-font-family: Minion-Regular-0-1000-21">&#8217;</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-21; mso-bidi-font-family: Minion-Regular-0-1000-21; mso-font-kerning: 0pt">t permit the read to overtake the write</SPAN><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-21; mso-bidi-font-family: Minion-Regular-0-1000-21; mso-font-kerning: 0pt">&#8212;<SPAN lang=EN-US>it would return stale data. Put a </SPAN></SPAN><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-73; mso-bidi-font-family: Courier-Bold-8r-0-1000-73; mso-font-kerning: 0pt">sync </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-21; mso-bidi-font-family: Minion-Regular-0-1000-21; mso-font-kerning: 0pt">instruction between the write and the read, and that should be effective on any system compliant with MIPS32/64.</SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-21; mso-bidi-font-family: Minion-Regular-0-1000-21; mso-font-kerning: 0pt">This is effective, but not necessarily efficient; you can minimize the overhead by loading from the fastest memory available. Perhaps your system offers something system-specific but faster. Use it after reading the following note! </SPAN><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Helvetica-Bold-8r-0-1000-91; mso-bidi-font-family: Helvetica-Bold-8r-0-1000-91; mso-font-kerning: 0pt">CAUTION! </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: FuturaBook-0-1000-19; mso-bidi-font-family: FuturaBook-0-1000-19; mso-font-kerning: 0pt">Write buffers are often implemented within the CPU, but may also be implemented outside it; any system controller or memory interface that boasts of a </SPAN><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-26; mso-bidi-font-family: Minion-Italic-0-1000-26; mso-font-kerning: 0pt">write-posting </SPAN></I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: FuturaBook-0-1000-19; mso-bidi-font-family: FuturaBook-0-1000-19; mso-font-kerning: 0pt">feature introduces another level of write buffering to your system.</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: FuturaBook-0-1000-19; mso-bidi-font-family: FuturaBook-0-1000-19; mso-font-kerning: 0pt">Write buffers outside the CPU can give you just the same sort of trouble as those inside it. Take care to find out where all the write buffers are located in your system, and to allow for them in your programming.</SPAN>