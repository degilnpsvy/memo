In CISC architectures, there is often a complex function call instruction that maintains a stack frame similar to that in Figure 11.8 but with an additional frame pointer register that corresponds to the position marked &#8220;sp on entry&#8221; on our diagram. In such a CPU, the caller&#8217;s frame pointer will be stored at some known stack position, allowing a debugger to skip up the stack by analyzing a simple linked list. But in a MIPS CPU, all this extra runtime work is eliminated; most of the time, a compiler knows how much to decrement the stack pointer at the head of a function and how much to increment it before return.