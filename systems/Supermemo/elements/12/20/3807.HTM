<SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">4. Initialize the I-cache first, then the D-cache. Following is C code for I-cache initialization. (You have to believe in the functions or macros like </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-8r-0-1000-77; mso-bidi-font-family: Courier-8r-0-1000-77; mso-font-kerning: 0pt">Index Store Tag I()</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">,which do low-level functions; they</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt; mso-fareast-font-family: Minion-Regular-0-1000-20; mso-ascii-font-family: Minion-Regular-0-1000-20">&#8217;</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">re either trivial assembly code subroutines that run the appropriate machine instructions or</SPAN><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">&#8212;<SPAN lang=EN-US>for the brave GNU C user</SPAN>&#8212;<SPAN lang=EN-US>macros invoking a C </SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-8r-0-1000-77; mso-bidi-font-family: Courier-8r-0-1000-77; mso-font-kerning: 0pt">asm </SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">statement.)</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-8r-0-1000-77; mso-bidi-font-family: Courier-8r-0-1000-77; mso-font-kerning: 0pt">for (addr = KSEG0; addr &lt; KSEG0 + size; addr += lnsize)</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-8r-0-1000-77; mso-bidi-font-family: Courier-8r-0-1000-77; mso-font-kerning: 0pt">/* clear tag to invalidate */</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-8r-0-1000-77; mso-bidi-font-family: Courier-8r-0-1000-77; mso-font-kerning: 0pt">Index_Store_Tag_I (addr);</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-8r-0-1000-77; mso-bidi-font-family: Courier-8r-0-1000-77; mso-font-kerning: 0pt">for (addr = KSEG0; addr &lt; KSEG0 + size; addr += lnsize)</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-8r-0-1000-77; mso-bidi-font-family: Courier-8r-0-1000-77; mso-font-kerning: 0pt">/* fill once, so data field parity is correct */</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-8r-0-1000-77; mso-bidi-font-family: Courier-8r-0-1000-77; mso-font-kerning: 0pt">Fill_I (addr);</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-8r-0-1000-77; mso-bidi-font-family: Courier-8r-0-1000-77; mso-font-kerning: 0pt">for (addr = KSEG0; addr &lt; KSEG0 + size; addr += lnsize)</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-8r-0-1000-77; mso-bidi-font-family: Courier-8r-0-1000-77; mso-font-kerning: 0pt">/* invalidate again---prudent but not strictly necessary */</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-8r-0-1000-77; mso-bidi-font-family: Courier-8r-0-1000-77; mso-font-kerning: 0pt">Index_Store_Tag_I (addr);</SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">We did the fill operation because some CPUs may detect and trap on parity errors, even on apparently invalid cache lines. Unfortunately the </SPAN><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-63; mso-bidi-font-family: Courier-Bold-8r-0-1000-63; mso-font-kerning: 0pt">Fill I </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">operation is not mandated by MIPS32/64. You can reasonably expect that any CPU that implements parity or ECC protection will include it: CPUs that don</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt; mso-fareast-font-family: Minion-Regular-0-1000-20; mso-ascii-font-family: Minion-Regular-0-1000-20">&#8217;</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">t protect cache data need only the first store tag loop.</SPAN></P>
<P><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">Moreover, we use three separate loops rather than combining them, because you have to be careful about the tags; with a two-way cache, a single loop would initialize half the cache twice, since the </SPAN><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-20; mso-bidi-font-family: Minion-Regular-0-1000-20; mso-font-kerning: 0pt">&#8220;<SPAN lang=EN-US>index store tag</SPAN>&#8221;<SPAN lang=EN-US> with a zero tag register will reset the LRU bit, which determines which set of the cache line is to be used on the next cache miss.</SPAN></SPAN></FONT>