Aliases can&#8217;t arise between any pair of translations where the alternative virtual addresses produce the same cache index. With 4-KB pages, the low 12 bits of the cache index are guaranteed to be equal; it&#8217;s only necessary to ensure that any two alternative program addresses for any physical page are separated by a multiple of the largest likely L1 cache set size. If your OS is careful when creating multiple virtual mappings to the same page and makes sure that the virtual page addresses are a multiple of (say) 64 KB apart, it&#8217;s hard to imagine that you&#8217;ll ever have any trouble.( Although CPUs get relentlessly bigger and faster with every year that passes, it&#8217;s unlikely that L1 cache set sizes will get bigger than the current 16-KB record seen in 64-KB four-way set associative caches. L1 caches run at the full CPU clock rate, and smaller is faster; in the future, more highly integrated CPUs will go for on-chip L2 caches instead.) </P>
<P>So it&#8217;s possible to avoid aliases, so long as the OS is careful about where it puts multiple views of the same physical data. Unfortunately, Linux is a portable OS being actively developed by people who don&#8217;t know (or much care) about problems that afflict MIPS CPUs but not any common desktop or server system. </P>
<P>So the Linux kernel avoids most aliases, but attempts to live with others. Simple operating systems either won&#8217;t have multiply mapped pages or will be able to work within such a constraint. But cache aliases are a source of lurking trouble and bugs for operating systems, and it would be good if hardware designers remembered that this is really a bug that was made into a feature for pragmatic reasons 15 years ago.