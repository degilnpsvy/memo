Chapter4 How Caches Work on MIPS Processors 
<P></P>
<P><FONT class=extract>A MIPS CPU without a cache isn&#8217;t really a RISC. Perhaps that&#8217;s not fair; for special purposes you might be able to build a MIPS CPU with a small, tightly coupled memory that can be accessed in a fixed number of pipeline stages (preferably one). But MIPS CPUs have always had cache hardware built tightly into the pipeline. </FONT></P>
<P>This chapter will describe the way MIPS caches work and what the software has to do to make caches useful and reliable. From reset, almost everything about the cache state is undefined, so bootstrap software must be careful to initialize the caches correctly before relying on them. You might also benefit from some hints and tips for use when sizing the caches (it would be bad software practice to assume you know how big the cache is). For the diagnostics programmer, we discuss how to test the cache memory and probe for particular entries.</P>
<P>Some real-time applications writers may want to control exactly what will get cached at run time. We discuss how to do that, even though I am skeptical about the wisdom of using such tricks.</P>
<P>There&#8217;s also some evolution to contend with. In early 32-bit MIPS processors, cache management functions relied upon putting the cache into a special state and then using ordinary reads and writes whose side effects could initialize or invalidate cache locations. But we won&#8217;t dwell on that here; even CPUs that do not fully comply with MIPS32/64 generally use something close to the mechanism described in the following text.