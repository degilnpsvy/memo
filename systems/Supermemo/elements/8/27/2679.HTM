<HEAD></HEAD>
<BODY>
<P>3.4 CP0 Hazards&#8212;A Trap for the Unwary </P>
<P>Since the CPU is pipelined, the effects of CP0 operations may not reach their target until after the later stages of the CP0 instruction&#8212;and even then may take some number of clocks to filter out to the hardware. But even before our CP0 instruction reaches its later stages, other instructions will have been fetched and started. How can we be sure that those instructions will be executed in the light of our CP0 change? </P>
<P>It would in theory be possible for the hardware engineers to find and interlock every possible interaction, producing a CPU where the software engineer had nothing toworry about on this score. SGI&#8217;s R10000 approaches this ideal.But CP0 operations are obscure, many happen rarely, and all are under the control of OS software, which must already be trusted. So it has seemed reasonable to MIPS architects and designers to push some of this trouble onto the shoulders of the software authors. </P>
<P>Historically, they were supposed to do this by analyzing the flow of their program, detect places where the software might malfunction, and apply fixes. The weapons at hand were nop instructions, which safely do nothing while changes propagate, and branch/jump instructions, which &#8220;invalidate&#8221; sequentially prefetched instructions, forcing them to be refetched and re-executed.If you look at the back of a manual of a MIPS CPU that doesn&#8217;t conform to the 2003 (second) revision of MIPS32/64, you will usually find a table of CP0 hazards, detailing how many clocks various changes take to propagate before you can guarantee they will be seen as done by subsequent instructions. </P>
<P>Even with early CPUs with simple pipelines, this was a bit of a challenge. As the pipelines grew longer and more complicated, it became a real nuisance for portable software. Once there were CPUs that executed instructions in parallel (simple dual-issue or even out-of-order), it became difficult to count how many nops were required. For a while, we even got the ssnop (&#8220;superscalar no-op&#8221;) instruction, guaranteed to burn a whole clock time by issuing alone.</P>
<P>But MIPS32/64 CPUs now have a more sensible approach: hazard barrier instructions. These are special instructions, which need only be placed where needed, where they have the effect of delaying subsequent instructions until all the side effects of preceding CP0 instructions have propagated.</P>
<P>MIPS32/64 distinguishes two flavors of CP0 hazard, depending on which stage of a dependent instruction&#8217;s operation may be affected. <FONT class=extract>Execution hazards are those where the dependent instruction will not be affected until it reads a CP0 register value; instruction hazards are those where the dependent instruction is affected in its very earliest stages&#8212;at worst, at the time it is fetched from cache or memory.</FONT></P>
<P>Another interesting distinction is between hazards that strictly affect only other CP0 instructions (which must be part of the OS) and those (we might call them user hazards) that can affect ordinary instructions<SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">.<?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /><o:p></o:p></SPAN></P></BODY>