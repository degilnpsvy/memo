<B><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-BoldItalic-0-1000-27; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-BoldItalic-0-1000-27">Floating-Point Data in Memory</SPAN></I></B> 
<P></P>
<P><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">Loads into floating-point registers from memory move data without any interpretation</SPAN><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">&#8212;<SPAN lang=EN-US>you can load an invalid floating-point number (in fact, an arbitrary bit pattern) and no FP error will result until you try to do arithmetic with it.</SPAN></SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19"><FONT class=extract>On 32-bit processors, this allows you to load single-precision values by a load into an even-numbered floating-point register, but you can also load a double-precision value by a macro instruction, so that on a 32-bit CPU the assembly instruction:</FONT></SPAN></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-34; mso-font-kerning: 0pt; mso-bidi-font-family: Courier-Bold-8r-0-1000-34"><FONT class=extract>l.d $f2, 24(t1)</FONT></SPAN></B></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19"><FONT class=extract>is expanded to two loads to consecutive registers:</FONT></SPAN></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-34; mso-font-kerning: 0pt; mso-bidi-font-family: Courier-Bold-8r-0-1000-34"><FONT class=extract>lwc1 $f2, 24(t1)</FONT></SPAN></B></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-34; mso-font-kerning: 0pt; mso-bidi-font-family: Courier-Bold-8r-0-1000-34"><FONT class=extract>lwc1 $f3, 28(t1)</FONT></SPAN></B></P>
<P><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">On a 64-bit CPU, </SPAN><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-34; mso-font-kerning: 0pt; mso-bidi-font-family: Courier-Bold-8r-0-1000-34">l.d </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">is the preferred alias for the machine instruction </SPAN><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-34; mso-font-kerning: 0pt; mso-bidi-font-family: Courier-Bold-8r-0-1000-34">ldc1</SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">, which does the whole job.</SPAN></FONT></P>
<P><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">Any C compiler that complies with the MIPS/SGI rules aligns eight-byte long double-precision floating-point variables to eight-byte boundaries. The 32-bit hardware does not require this alignment, but it</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">s done for forward compatibility: 64-bit CPUs will trap if asked to load a double from a location that is not eight-byte aligned.</SPAN></FONT>