<HEAD></HEAD>
<BODY>
<P><B><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-BoldItalic-0-1000-27; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-BoldItalic-0-1000-27">Unaligned Loads and Stores</SPAN></I></B></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">Normal loads and stores in the MIPS architecture must be aligned; halfwords may be loaded only from two-byte boundaries and words only from four-byte boundaries. <FONT class=extract>A load instruction with an unaligned address will produce a trap.</FONT> <FONT class=extract>Because CISC architectures such as the MC680x0 and Intel x86 do handle unaligned loads and stores, you may come across this as a problem when porting software; in extremity, you may even decide to install a trap handler that will emulate the desired load operation and hide this feature from the application</FONT></SPAN><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19"><FONT class=extract>&#8212;<SPAN lang=EN-US>but that</SPAN>&#8217;<SPAN lang=EN-US>s going to be horribly slow unless the references are very rare.</SPAN></FONT></SPAN></P>
<P><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">All data items declared by C code will be correctly aligned. Where you know in advance that you want to code a transfer from an address whose alignment is unknown and that may turn out to be unaligned, the architecture does allow for a two-instruction sequence (much more efficient than a series of byte loads, shifts, and adds). The operation of the constituent instructions is obscure and hard to grasp, but they are normally generated by the macro-instruction </SPAN><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-34; mso-font-kerning: 0pt; mso-bidi-font-family: Courier-Bold-8r-0-1000-34">ulw </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">(unaligned load word). They</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19; mso-fareast-font-family: Minion-Regular-0-1000-19; mso-ascii-font-family: Minion-Regular-0-1000-19">&#8217;</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">re described fully in section <?xml:namespace prefix = st1 /><st1:chsdate w:st="on" Year="1899" Month="12" Day="30" IsLunarDate="False" IsROCDate="False">8.5.1</st1:chsdate>.</SPAN></FONT></P>
<P><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">A macro-instruction </SPAN><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-34; mso-font-kerning: 0pt; mso-bidi-font-family: Courier-Bold-8r-0-1000-34">ulh </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">(unaligned load half) is also provided and is synthesized by two loads, a shift, and a bitwise </SPAN><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">&#8220;<SPAN lang=EN-US>or</SPAN>&#8221;<SPAN lang=EN-US> operation.</SPAN></SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">By default, a C compiler takes trouble to align all data correctly, but there are occasions (e.g., when importing data from a file or sharing data with a different CPU) when being able to handle unaligned integer data efficiently is a requirement. Most compilers permit you to flag a data type as potentially unaligned and will generate (reasonably efficient) special code to cope</SPAN><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-19; mso-font-kerning: 0pt; mso-bidi-font-family: Minion-Regular-0-1000-19">&#8212;<SPAN lang=EN-US>see section <st1:chsdate w:st="on" Year="1899" Month="12" Day="30" IsLunarDate="False" IsROCDate="False">11.1.5</st1:chsdate>.</SPAN></SPAN></P></BODY>