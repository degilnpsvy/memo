9.8. The Lisp Modes 
<P></P>
<P><FONT class=extract>Emacs has three Lisp modes, listed here by their command names: </FONT></P>
<P><FONT class=extract>emacs-lisp-mode&#65306;Used for editing Emacs Lisp code, as covered in Chapter 11 (filename .emacs or suffix .el). </FONT></P>
<P><FONT class=extract>lisp-mode&#65306;Used for editing Lisp code intended for another Lisp system (suffix .l or .lisp). </FONT></P>
<P><FONT class=extract>lisp-interaction-mode&#65306;Used for editing and running Emacs Lisp code.~</FONT></P>
<P class=docText>All three modes have the same basic functionality; they differ only in the support they give to running Lisp code.</P>
<P class=docText>All three Lisp modes understand the basic syntax elements common to all language modes. In addition, they have various commands that apply to the more advanced syntactic concepts of S-expressions, lists, and defuns. <FONT class=extract>An <SPAN class=docEmphasis>S-expression</SPAN> (or syntactic expression) is any syntactically correct Lisp expression, be it an atom (number, symbol, variable, etc.), or parenthesized list. <SPAN class=docEmphasis>Lists</SPAN> are special cases of S-expressions, and <SPAN class=docEmphasis>defuns</SPAN> (function definitions) are special cases of lists.</FONT> Several commands deal with these syntactic concepts; you will most likely become comfortable with a subset of them.</P>
<P class=docText><A class=docLink href="file:///D:/&#25105;&#30340;&#37239;&#30424;/&#24037;&#20316;&#30446;&#24405;/Now/learning-gnu-emacs-3rd/0596006489/gnu3-chp-9-sect-8.html#gnu3-chp-9-table-11">Table 9-11</A> shows the commands that <A name=gnu3-CHP-9-ITERM-2616></A><A name=gnu3-CHP-9-ITERM-2617></A><A name=gnu3-CHP-9-ITERM-2618></A>handle S-expressions.</P><A name=gnu3-CHP-9-TABLE-11></A>
<H5 class=docTableTitle><FONT class=extract>Table 9-11. S-expression commands</FONT></H5>
<TABLE cellSpacing=0 cellPadding=4 rules=all width="100%" border=1>
<COLGROUP><FONT class=extract>
<COL>
<COL>
<COL></FONT></COLGROUP>
<THEAD>
<TR>
<TH class=thead scope=col>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>Keystrokes</SPAN> </FONT></P></TH>
<TH class=thead scope=col>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>Command name</SPAN> </FONT></P></TH>
<TH class=thead scope=col>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>Action</SPAN> </FONT></P></TH></TR></THEAD>
<TBODY>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>C-M-b</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>backward-sexp</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Move backward by one S-expression.</FONT></P></TD></TR>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>C-M-f</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>forward-sexp</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Move forward by one S-expression.</FONT></P></TD></TR>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>C-M-t</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>transpose-sexps</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Transpose the two S-expressions around the cursor.</FONT></P></TD></TR>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>C-M-@</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>mark-sexp</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Set mark to the end of the current S-expression; set the cursor to the beginning.</FONT></P></TD></TR>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>C-M-k</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>kill-sexp</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Delete the S-expression following the cursor.</FONT></P></TD></TR>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract>(<SPAN class=docEmphasis>none</SPAN>)</FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>backward-kill-sexp</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Delete the S-expression preceding the cursor.</FONT></P></TD></TR></TBODY></TABLE><BR>
<P class=docText>Since an S-expression can be a wide variety of things, the actions of commands that handle S-expressions are determined by where your cursor is when you invoke them. If your cursor is on a <SPAN class=docEmphBold>(</SPAN> or on a space preceding one, the S-expression in question is taken to be the list that starts with that <SPAN class=docEmphBold>(</SPAN>. If your cursor is on some other character such as a letter or number (or preceding whitespace), the S-expression is taken to be an atom (symbol, variable, or constant).</P>
<P class=docText>For example, suppose your cursor is in this position:</P><PRE>(mary bob<SPAN class=docEmphCursor>_</SPAN>(dave (pete)) ed)
</PRE><BR>
<P class=docText>If you type <SPAN class=docEmphBold>C-M-f</SPAN>, the cursor moves like this:</P><PRE>(mary bob (dave (pete))<SPAN class=docEmphCursor>_</SPAN>ed)
</PRE><BR>
<P class=docText>That is, the cursor moves forward past the S-expression <SPAN class=docEmphBold>(dave (pete))</SPAN>, which is a list. However, say your cursor is positioned like this:</P><PRE>(mary<SPAN class=docEmphCursor>_</SPAN>bob (dave (pete)) ed)
</PRE><BR>
<P class=docText>When you type <SPAN class=docEmphBold>C-M-f</SPAN>, it moves here:</P><PRE>(mary bob<SPAN class=docEmphCursor>_</SPAN>(dave (pete)) ed)
</PRE><BR>
<P class=docText>In this case, the S-expression is the atom <SPAN class=docEmphBold>bob</SPAN>.</P>
<P class=docText><FONT class=extract>The commands moving in lists are shown in </FONT><A class=docLink href="file:///D:/&#25105;&#30340;&#37239;&#30424;/&#24037;&#20316;&#30446;&#24405;/Now/learning-gnu-emacs-3rd/0596006489/gnu3-chp-9-sect-8.html#gnu3-chp-9-table-12"><FONT class=extract>Table 9-12</FONT></A><FONT class=extract>.</FONT></P><A name=gnu3-CHP-9-TABLE-12></A>
<H5 class=docTableTitle><FONT class=extract>Table 9-12. Commands for moving in lists</FONT></H5>
<TABLE cellSpacing=0 cellPadding=4 rules=all width="100%" border=1>
<COLGROUP><FONT class=extract>
<COL>
<COL>
<COL></FONT></COLGROUP>
<THEAD>
<TR>
<TH class=thead scope=col>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>Keystrokes</SPAN> </FONT></P></TH>
<TH class=thead scope=col>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>Command name</SPAN> </FONT></P></TH>
<TH class=thead scope=col>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>Action</SPAN> </FONT></P></TH></TR></THEAD>
<TBODY>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>C-M-n</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>forward-list</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Move forward by one list.</FONT></P></TD></TR>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>C-M-p</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>backward-list</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Move backward by one list.</FONT></P></TD></TR>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>C-M-d</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>down-list</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Move forward and down one parenthesis level.</FONT></P></TD></TR>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract>(<SPAN class=docEmphasis>none</SPAN>)</FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>up-list</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Move forward out of one parenthesis level.</FONT></P></TD></TR>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>C-M-u</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>backward-up-list</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Move backward out of one parenthesis level.</FONT></P></TD></TR></TBODY></TABLE><BR>
<P class=docText>As a mnemonic device, you can think of lists as analogous to lines and S-expressions as analogous to characters; thus, <SPAN class=docEmphBold>C-n</SPAN> and <SPAN class=docEmphBold>C-p</SPAN> appear in list motion commands, whereas <SPAN class=docEmphBold>C-f</SPAN> and <SPAN class=docEmphBold>C-b</SPAN> appear in S-expression motion commands. <SPAN class=docEmphBold>C-M-n</SPAN> and <SPAN class=docEmphBold>C-M-p</SPAN> work similarly to <SPAN class=docEmphBold>C-M-f</SPAN> and <SPAN class=docEmphBold>C-M-b</SPAN>, respectively, except that you must position the cursor so that there is a list in front or back of it to move across&#8212;that is, there must be an opening or closing parenthesis on, after, or before the cursor. If there is no parenthesis, Emacs signals an error. For example, if your cursor is positioned like this:</P><PRE>(fred bob (dave (pe_<SPAN class=docEmphCursor>t</SPAN>e)<SPAN class=docEmphasis>)</SPAN> ed)
</PRE><BR>
<P class=docText>and you type <SPAN class=docEmphBold>C-M-n</SPAN>, Emacs complains with the message:</P><PRE>Containing expression ends prematurely
</PRE><BR>
<P class=docText>However, if your cursor is here:</P><PRE>(fred <SPAN class=docEmphCursor>_</SPAN>b<SPAN class=docEmphasis>o</SPAN>b (dave (pete)) ed)
</PRE><BR>
<P class=docText>the "next list" is actually <SPAN class=docEmphBold>(dave (pete))</SPAN>, and the cursor ends up like this if you type <SPAN class=docEmphBold>C-M-n</SPAN>:</P><PRE>(fred bob (dave (pete))<SPAN class=docEmphCursor>_</SPAN>ed)
</PRE><BR>
<P class=docText>The commands for moving up or down lists enable you to get inside or outside them. For example, say your cursor is here:</P><PRE><SPAN class=docEmphCursor>_(</SPAN>fred bob (dave (pete)) ed)
</PRE><BR>
<P class=docText>typing <SPAN class=docEmphBold>C-M-d</SPAN> moves the cursor here:</P><PRE>(_<SPAN class=docEmphCursor>f</SPAN>red bob (_dave (pete)) ed)
</PRE><BR>
<P class=docText>This is the result because <SPAN class=docEmphBold>fred</SPAN> is the next level down after its enclosing list. Typing <SPAN class=docEmphBold>C-M-d</SPAN> again has this result:</P><PRE>(fred bob (_<SPAN class=docEmphCursor>d</SPAN>ave (pete)) ed)
</PRE><BR>
<P class=docText>You are now inside the list <SPAN class=docEmphBold>(dave (pete))</SPAN>. At this point, typing <SPAN class=docEmphBold>C-M-u</SPAN> does the opposite of what <SPAN class=docEmphBold>C-M-d</SPAN> does: it moves the cursor back and outside of the two lists. But if you type <SPAN class=docEmphBold>M-x up-list Enter</SPAN>, you will move forward as well as out, resulting in this:</P><PRE>(fred bob (dave (pete))<SPAN class=docEmphCursor>_</SPAN>ed)
</PRE><BR>
<P class=docText>The commands for defuns listed in <A class=docLink href="file:///D:/&#25105;&#30340;&#37239;&#30424;/&#24037;&#20316;&#30446;&#24405;/Now/learning-gnu-emacs-3rd/0596006489/gnu3-chp-9-sect-8.html#gnu3-chp-9-table-13">Table 9-13</A> are more straightforward.</P><A name=gnu3-CHP-9-TABLE-13></A>
<H5 class=docTableTitle>Table 9-13. <FONT class=extract>Commands for working with functions</FONT></H5>
<TABLE cellSpacing=0 cellPadding=4 rules=all width="100%" border=1>
<COLGROUP><FONT class=extract>
<COL>
<COL>
<COL></FONT></COLGROUP>
<THEAD>
<TR>
<TH class=thead scope=col>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>Keystrokes</SPAN> </FONT></P></TH>
<TH class=thead scope=col>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>Command name</SPAN> </FONT></P></TH>
<TH class=thead scope=col>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>Action</SPAN> </FONT></P></TH></TR></THEAD>
<TBODY>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>C-M-a</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>beginning-of-defun</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Move to the beginning of the current function.</FONT></P></TD></TR>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>C-M-e</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>end-of-defun</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Move to the end of the current function.</FONT></P></TD></TR>
<TR>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>C-M-h</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract><SPAN class=docEmphBold>mark-defun</SPAN> </FONT></P></TD>
<TD class=docTableCell>
<P class=docText><FONT class=extract>Put the cursor at the beginning of the function, put the mark at the end.</FONT></P></TD></TR></TBODY></TABLE><BR>
<P class=docText>These commands work properly only when the <SPAN class=docEmphBold>(defun</SPAN> that starts the current function is at the beginning of a line.</P><A name=gnu3-CHP-9-SECT-8.1></A>
<H4 class=docSection2Title>9.8.1 Indentation in Lisp Modes</H4>
<P class=docText>The Lisp modes provide "flashing" <A name=gnu3-CHP-9-ITERM-2619></A><A name=gnu3-CHP-9-ITERM-2620></A><A name=gnu3-CHP-9-ITERM-2621></A>of matching left parentheses; if the matching parenthesis is outside of the current window, the line it is on appears in the minibuffer. <FONT class=extract>The Lisp modes also provide indentation via the <SPAN class=docEmphBold>Tab</SPAN> key and <SPAN class=docEmphBold>C-j</SPAN> for <SPAN class=docEmphBold>newline-and-indent</SPAN> (except in Lisp interaction mode, described later in this chapter).</FONT> The indentation style supported by the Lisp modes "knows" a lot about Lisp keywords and list syntax; unfortunately, it is not easily customized.<SUP class=docFootnote><A class=docLink href="file:///D:/&#25105;&#30340;&#37239;&#30424;/&#24037;&#20316;&#30446;&#24405;/Now/learning-gnu-emacs-3rd/0596006489/gnu3-chp-9-sect-8.html#gnu3-chp-9-fnote-12">[12]</A></SUP></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=gnu3-CHP-9-FNOTE-12>[12]</A></SUP> The indentation style is bound up in the Emacs Lisp code for Lisp mode. If you are an experienced Lisp hacker, you can examine the code for <SPAN class=docEmphBold>lisp-mode.el</SPAN> in the Emacs Lisp directory and determine how to customize indentation the way you wish. A good place to start looking is the function <SPAN class=docEmphBold>lisp-indent-line</SPAN>.</P></BLOCKQUOTE>
<P class=docText>Here is an example, a Lisp equivalent of the "times" C function shown earlier in the chapter, that illustrates the indentation style:</P><PRE>(defun times (x y)


  (let ((i 0)


        (result 0))


    (while (&lt; i x)


      (setq result (+ result y)


            i (1+ i)))


    result))
</PRE><BR>
<P class=docText>The basic indentation value is 2; this value is used whenever code on the next line goes down a level in nesting. For example, the body of the function, after the line containing <SPAN class=docEmphBold>defun</SPAN>, is indented by 2. The <SPAN class=docEmphBold>(while..</SPAN>. and <SPAN class=docEmphBold>result))</SPAN> lines are indented by 2 with respect to the <SPAN class=docEmphBold>let</SPAN> because they are the body of the block <SPAN class=docEmphBold>let</SPAN> introduces.</P>
<P class=docText>Things like <SPAN class=docEmphBold>defun</SPAN>, <SPAN class=docEmphBold>let</SPAN>, and <SPAN class=docEmphBold>while</SPAN> are function calls, even though they act like keywords. The indentation convention for function calls is that if there are arguments on lines after the line where the function name and first argument appear, the additional arguments line up with the first one. In other words, this has the form:</P><PRE>(function-name arg1


               arg2


               arg3


               ...)
</PRE><BR>
<P class=docText>The multiple arguments to <SPAN class=docEmphBold>setq</SPAN> in the preceding function provide another example of this.</P>
<P class=docText>However, the indentation of the line <SPAN class=docEmphBold>(result 0)</SPAN> shows that something a bit different happens with lists that are not function calls. The list in question is actually <SPAN class=docEmphBold>((i 0) (result 0))</SPAN>, which is a list with two elements (both of which are also lists). The indentation style supported by the Lisp modes lines up these two elements.</P>
<P class=docText>Even though keyword-like terms such as <SPAN class=docEmphBold>let</SPAN> and <SPAN class=docEmphBold>while</SPAN> are actually function calls, the Lisp modes "understand" these functions to the extent that special indentation conventions are set up for them. For example, if we were to put the condition for the while-loop on a separate line and press <SPAN class=docEmphBold>Tab</SPAN> to indent it properly, the result would be:</P><PRE>    (while 


        (&lt; i x)


      (setq result (+ result y)


            i (1+ i)))
</PRE><BR>
<P class=docText>Similar things happen with <SPAN class=docEmphBold>if</SPAN> and <SPAN class=docEmphBold>cond</SPAN> control structures; <A class=docLink href="file:///D:/&#25105;&#30340;&#37239;&#30424;/&#24037;&#20316;&#30446;&#24405;/Now/learning-gnu-emacs-3rd/0596006489/gnu3-chp-11.html#gnu3-chp-11">Chapter 11</A> contains properly indented examples.</P>
<P class=docText>Another remark about indentation conventions: the Lisp modes are geared toward a style in which multiple right parentheses are put on the same line immediately following each other, instead of on separate lines. For example, the line <SPAN class=docEmphBold>i (1+ i)))</SPAN> contains right parentheses that close off the <SPAN class=docEmphBold>1+</SPAN> function, the <SPAN class=docEmphBold>setq</SPAN>, and the <SPAN class=docEmphBold>while</SPAN> respectively. If you prefer, you can put your closing parentheses on separate lines, but if you press <SPAN class=docEmphBold>Tab</SPAN> to indent them, they won't line up properly with their matching open parentheses; you have to indent them manually.</P>
<P class=docText>In addition to the <SPAN class=docEmphBold>Tab</SPAN> and <SPAN class=docEmphBold>C-j</SPAN> commands for indentation, the Lisp modes support the command <SPAN class=docEmphBold>C-M-q</SPAN> (for <SPAN class=docEmphBold>indent-sexp</SPAN>), which indents every line in the S-expression just following the cursor. You can use this command, for example, to indent an entire function definition: just put the cursor right before the <SPAN class=docEmphBold>defun</SPAN> and type <SPAN class=docEmphBold>C-M-q</SPAN>.</P><A name=gnu3-CHP-9-SECT-8.2></A>
<H4 class=docSection2Title>9.8.2 Comments in Lisp Modes</H4>
<P class=docText><FONT class=extract>Comments in the Lisp modes are handled </FONT><A name=gnu3-CHP-9-ITERM-2622></A><A name=gnu3-CHP-9-ITERM-2623></A><A name=gnu3-CHP-9-ITERM-2624></A><FONT class=extract>by the universal comment command <SPAN class=docEmphBold>M-;</SPAN>, which indents out to <SPAN class=docEmphBold>comment-column</SPAN> (or, if there is text at that column, one space past the last character), inserts a semicolon, and puts the cursor just past it.</FONT> If you want a comment to occupy an entire line (or to start anywhere other than at <SPAN class=docEmphBold>comment-column</SPAN>), you must move to where you want the comment to start and type the semicolon yourself. Note that if you press <SPAN class=docEmphBold>Tab</SPAN> on any line that contains only a comment, the comment moves out to <SPAN class=docEmphBold>comment-column</SPAN>. To get around this, use two or more semicolons; doing so causes <SPAN class=docEmphBold>Tab</SPAN> to leave the comments where they are. The Lisp modes also support the other comment commands discussed earlier in the chapter, including <FONT class=extract><SPAN class=docEmphBold>M-j</SPAN> to extend a comment to another line</FONT> and <SPAN class=docEmphBold>M-x kill-comment Enter</SPAN> to get rid of a single-line comment. These features are common to all three Lisp modes; next, we discuss the features unique to each.</P><A name=gnu3-CHP-9-SECT-8.3></A>
<H4 class=docSection2Title>9.8.3 Emacs Lisp Mode Differences</H4>
<P class=docText>Emacs Lisp mode was designed <A name=gnu3-CHP-9-ITERM-2625></A>to be used with code meant to run within Emacs itself, so it facilitates running the code you type. <FONT class=extract>Lisp is an interpreted (as opposed to purely compiled) language, so it is possible to blur the line between the write and run/debug phases of Lisp programming</FONT>; Emacs Lisp mode takes some advantage of this opportunity, whereas Lisp interaction mode goes even further, as we'll see later. <FONT class=extract>In Emacs Lisp mode, the command <SPAN class=docEmphBold>C-M-x</SPAN> (<SPAN class=docEmphBold>eval-defun</SPAN>) picks up the function definition around or after the cursor and evaluates it, meaning that it parses the function and stores it so that Emacs "knows" about the function when you invoke it.</FONT></P>
<P class=docText><FONT class=extract>Emacs Lisp mode also includes the command M-Tab (for lisp-complete-symbol),[13] which performs completion on the symbol (variable, function name, etc.) preceding the cursor, as described in Chapter 14.</FONT> Thus, you can type the shortest unambiguous prefix for the symbol, followed by <SPAN class=docEmphBold>M-Tab</SPAN>, and Emacs tries to complete the symbol's name for you as far as it can. If it completes the symbol name, you can go on with whatever you are doing. If it doesn't, you haven't provided an unambiguous prefix. You can type more characters (to disambiguate further), or you can type <SPAN class=docEmphBold>M-Tab</SPAN> again, and a help window showing the choices pops up. Then you can type more characters and complete the symbol yourself, or you can try for completion again.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=gnu3-CHP-9-FNOTE-13>[13]</A></SUP> <FONT class=extract>This key binding may not work on all platforms. If it is intercepted by the operating system (as it is on Red Hat Linux), type <SPAN class=docEmphBold>Esc Tab</SPAN> instead (remember to release <SPAN class=docEmphBold>Esc</SPAN> before you press <SPAN class=docEmphBold>Tab</SPAN>).</FONT></P></BLOCKQUOTE><A name=gnu3-CHP-9-SECT-8.4></A>
<H4 class=docSection2Title>9.8.4 Lisp Mode Differences</H4>
<P class=docText>Lisp mode (as opposed to Emacs Lisp mode) is meant for use with Lisp processors other than the Emacs Lisp interpreter. Therefore it includes a couple of commands for interfacing to an external Lisp interpreter. <FONT class=extract>The Lisp mode command <SPAN class=docEmphBold>C-c C-z</SPAN> (<SPAN class=docEmphBold>run-lisp</SPAN>) starts up your system's Lisp interpreter as a subprocess and creates the <TT>*lisp*</TT> buffer (with an associated window) for input and output.</FONT><SUP class=docFootnote><A class=docLink href="file:///D:/&#25105;&#30340;&#37239;&#30424;/&#24037;&#20316;&#30446;&#24405;/Now/learning-gnu-emacs-3rd/0596006489/gnu3-chp-9-sect-8.html#gnu3-chp-9-fnote-14">[14]</A></SUP> <FONT class=extract>If a Lisp subprocess already exists, <SPAN class=docEmphBold>C-c C-z</SPAN> uses it rather than creating a second one.</FONT> <FONT class=extract>You can send function definitions to the Lisp subprocess by putting the cursor anywhere within a function's definition and using <SPAN class=docEmphBold>C-M-x</SPAN>, which in this case stands for <SPAN class=docEmphBold>lisp-send-defun</SPAN>. This procedure causes the functions you define to become known to the Lisp interpreter so that you can invoke them later.</FONT></P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=gnu3-CHP-9-FNOTE-14>[14]</A></SUP> This Lisp mode command (<SPAN class=docEmphBold>run-lisp</SPAN>) was designed to run with the franz Lisp system on BSD Unix systems, though it should work with other Lisp interpreters.</P></BLOCKQUOTE><A name=gnu3-CHP-9-SECT-8.5></A>
<H4 class=docSection2Title>9.8.5 Working with Lisp Fragments</H4>
<P class=docText>Emacs Lisp mode is probably the best <A name=gnu3-CHP-9-ITERM-2626></A><A name=gnu3-CHP-9-ITERM-2627></A>thing to use if you are editing entire files of Emacs Lisp code, for example, if you are programming your own mode (as described in <A class=docLink href="file:///D:/&#25105;&#30340;&#37239;&#30424;/&#24037;&#20316;&#30446;&#24405;/Now/learning-gnu-emacs-3rd/0596006489/gnu3-chp-11.html#gnu3-chp-11">Chapter 11</A>) or modifying an existing one. However, if you are editing "little" pieces of Lisp code (for example, making additions or modifications to your <SPAN class=docEmphasis>.emacs</SPAN> file), Emacs has more powerful features you can use that further blur the line between writing and running code.</P><A name=gnu3-CHP-9-SECT-8.5.1></A>
<H5 class=docSection3Title>9.8.5.1 Commands for evaluating a line of Lisp</H5>
<P class=docText><FONT class=extract>The first of these </FONT><A name=gnu3-CHP-9-ITERM-2628></A><FONT class=extract>is the command <SPAN class=docEmphBold>M-</SPAN>: (for <SPAN class=docEmphBold>eval-expression</SPAN>). This command enables you to type a one-line Lisp expression of any kind in the minibuffer; the expression is evaluated, and the result is printed in the minibuffer. This is an excellent, quick way to check the values of Emacs variables and to experiment with "internal" Emacs functions that aren't bound to keys or that require arguments. You can use the symbol completion command <SPAN class=docEmphBold>M-Tab</SPAN> while you are using <SPAN class=docEmphBold>eval-expression</SPAN>.</FONT></P>
<P class=docText>Unfortunately (or fortunately, depending on your point of view), Emacs doesn't normally let you use <SPAN class=docEmphBold>eval-expression</SPAN>. If you try pressing <SPAN class=docEmphBold>M-</SPAN>:, you will see the message <TT>loading novice . .</TT> . in the minibuffer. Then a window pops up with a message on the order of, "You didn't really mean to type that, did you?" You get three options: press <SPAN class=docEmphBold>Space</SPAN> to try the command only once, <SPAN class=docEmphBold>y</SPAN> to try it and enable it for future use with no questions asked, or <SPAN class=docEmphBold>n</SPAN> to do nothing.</P>
<P class=docText>If you want to use <SPAN class=docEmphBold>eval-expression</SPAN>, type <SPAN class=docEmphBold>y</SPAN>. This command actually results in the following line being put in your <SPAN class=docEmphasis>.emacs</SPAN> file:</P><PRE>(put 'eval-expression 'disabled nil)
</PRE><BR>
<P class=docText>If you are a knowledgeable Lisp programmer, you will understand that this addition sets the property <SPAN class=docEmphBold>disabled</SPAN> of the symbol <SPAN class=docEmphBold>eval-expression</SPAN> to <SPAN class=docEmphBold>nil</SPAN>. In other words, Emacs considers certain commands to be verboten to novice users and thus allows commands to be disabled. If you want to skip this entire procedure and just use <SPAN class=docEmphBold>eval-expression</SPAN>, simply put the above line in your <SPAN class=docEmphasis>.emacs</SPAN> file yourself (make sure you include the single quotes).</P>
<P class=docText><FONT class=extract>Another feature that helps you exercise Emacs Lisp code is <SPAN class=docEmphBold>C-x C-e</SPAN> (for <SPAN class=docEmphBold>eval-last-sexp</SPAN>). This command runs the line of Lisp that your cursor is on and prints its value in the minibuffer. <SPAN class=docEmphBold>C-x C-e</SPAN> is handy for testing single lines of code in an Emacs Lisp file.</FONT></P><A name=gnu3-CHP-9-SECT-8.5.2></A>
<H5 class=docSection3Title>9.8.5.2 Using Lisp interaction mode</H5>
<P class=docText>An even more powerful feature is <A name=gnu3-CHP-9-ITERM-2629></A><A name=gnu3-CHP-9-ITERM-2630></A><A name=gnu3-CHP-9-ITERM-2631></A>Lisp interaction mode. This is the mode the default buffer <TT>*scratch*</TT> is in. <FONT class=extract>Filenames with no suffixes normally cause Emacs to go into Lisp interaction mode, though you can change this using the variable <SPAN class=docEmphBold>auto-mode-alist</SPAN>, described earlier in this chapter and in more detail in </FONT><A class=docLink href="file:///D:/&#25105;&#30340;&#37239;&#30424;/&#24037;&#20316;&#30446;&#24405;/Now/learning-gnu-emacs-3rd/0596006489/gnu3-chp-10.html#gnu3-chp-10"><FONT class=extract>Chapter 10</FONT></A><FONT class=extract>.</FONT> You can also put any buffer in Lisp interaction mode by typing <SPAN class=docEmphBold>M-x lisp-interaction-mode Enter</SPAN>; to create an extra Lisp interaction buffer, just type <SPAN class=docEmphBold>C-x b</SPAN> (for <SPAN class=docEmphBold>switch-to-buffer</SPAN>), supply a buffer name, and put it in Lisp interaction mode.</P>
<P class=docText><FONT class=extract>Lisp interaction mode is identical to Emacs Lisp mode except for one important feature: <SPAN class=docEmphBold>C-j</SPAN> is bound to the command <SPAN class=docEmphBold>eval-print-last-sexp</SPAN>.</FONT> This command takes the S-expression just before point, evaluates it, and prints the result in the buffer. To get the usual <SPAN class=docEmphBold>newline-and-indent</SPAN> functionality attached to <SPAN class=docEmphBold>C-j</SPAN> in other modes, you must press <SPAN class=docEmphBold>Enter</SPAN>, followed by <SPAN class=docEmphBold>Tab</SPAN>.</P>
<P class=docText>Remember that an S-expression is any syntactically valid expression in Lisp. Therefore, you can use <SPAN class=docEmphBold>C-j</SPAN> in Lisp interaction mode to check the values of variables, enter function definitions, run functions, and so on. For example, if you type <SPAN class=docEmphBold>auto-save-interval</SPAN> and press <SPAN class=docEmphBold>C-j</SPAN>, the value of that variable (300 by default) appears. If you type a <SPAN class=docEmphBold>defun</SPAN> and press <SPAN class=docEmphBold>C-j</SPAN> after the last right parenthesis, Emacs stores the function defined (for future invocation) and prints its name; in this case, <SPAN class=docEmphBold>C-j</SPAN> is similar to <SPAN class=docEmphBold>C-M-x</SPAN> (for <SPAN class=docEmphBold>eval-defun</SPAN>) except that the cursor must be after (as opposed to before or in the middle of) the function being defined. If you invoke a function, Emacs evaluates (runs) the expression and responds with whatever value the function returns.</P>
<P class=docText><SPAN class=docEmphBold>C-j</SPAN> in Lisp interaction mode gives you an excellent way to play with, incrementally develop, and debug Emacs Lisp code, and since Emacs Lisp is "true" Lisp, it is even useful for developing some bits of code for other Lisp systems.