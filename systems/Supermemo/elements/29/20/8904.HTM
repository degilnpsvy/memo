<H4 class=subsection style="FONT-SIZE: medium; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; LINE-HEIGHT: normal; FONT-STYLE: normal; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; FONT-VARIANT: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">2.7.4 typedef asymbol</H4>
<P style="WORD-SPACING: 0px; FONT: medium Simsun; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; WHITE-SPACE: normal; LETTER-SPACING: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">An<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asymbol</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>has the form:</P><PRE class=example style="FONT-WEIGHT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); TEXT-INDENT: 0px; LINE-HEIGHT: normal; FONT-STYLE: normal; LETTER-SPACING: normal; FONT-VARIANT: normal; orphans: auto; widows: auto; -webkit-text-stroke-width: 0px">     
     typedef struct bfd_symbol
     {
       /* A pointer to the BFD which owns the symbol. This information
          is necessary so that a back end can work out what additional
          information (invisible to the application writer) is carried
          with the symbol.
     
          This field is *almost* redundant, since you can use section-&gt;owner
          instead, except that some symbols point to the global sections
          bfd_{abs,com,und}_section.  This could be fixed by making
          these globals be per-bfd (or per-target-flavor).  FIXME.  */
       struct bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field.  */
     
       /* The text of the symbol. The name is left alone, and not copied; the
          application may not alter it.  */
       const char *name;
     
       /* The value of the symbol.  This really should be a union of a
          numeric value with a pointer, since some flags indicate that
          a pointer to another symbol is stored here.  */
       symvalue value;
     
       /* Attributes of a symbol.  */
     #define BSF_NO_FLAGS           0x00
     
       /* The symbol has local scope; <CODE>static</CODE> in <CODE>C</CODE>. The value
          is the offset into the section of the data.  */
     #define BSF_LOCAL              (1 &lt;&lt; 0)
     
       /* The symbol has global scope; initialized data in <CODE>C</CODE>. The
          value is the offset into the section of the data.  */
     #define BSF_GLOBAL             (1 &lt;&lt; 1)
     
       /* The symbol has global scope and is exported. The value is
          the offset into the section of the data.  */
     #define BSF_EXPORT     BSF_GLOBAL /* No real difference.  */
     
       /* A normal C symbol would be one of:
          <CODE>BSF_LOCAL</CODE>, <CODE>BSF_COMMON</CODE>,  <CODE>BSF_UNDEFINED</CODE> or
          <CODE>BSF_GLOBAL</CODE>.  */
     
       /* The symbol is a debugging record. The value has an arbitrary
          meaning, unless BSF_DEBUGGING_RELOC is also set.  */
     #define BSF_DEBUGGING          (1 &lt;&lt; 2)
     
       /* The symbol denotes a function entry point.  Used in ELF,
          perhaps others someday.  */
     #define BSF_FUNCTION           (1 &lt;&lt; 3)
     
       /* Used by the linker.  */
     #define BSF_KEEP               (1 &lt;&lt; 5)
     #define BSF_KEEP_G             (1 &lt;&lt; 6)
     
       /* A weak global symbol, overridable without warnings by
          a regular global symbol of the same name.  */
     #define BSF_WEAK               (1 &lt;&lt; 7)
     
       /* This symbol was created to point to a section, e.g. ELF's
          STT_SECTION symbols.  */
     #define BSF_SECTION_SYM        (1 &lt;&lt; 8)
     
       /* The symbol used to be a common symbol, but now it is
          allocated.  */
     #define BSF_OLD_COMMON         (1 &lt;&lt; 9)
     
       /* In some files the type of a symbol sometimes alters its
          location in an output file - ie in coff a <CODE>ISFCN</CODE> symbol
          which is also <CODE>C_EXT</CODE> symbol appears where it was
          declared and not at the end of a section.  This bit is set
          by the target BFD part to convey this information.  */
     #define BSF_NOT_AT_END         (1 &lt;&lt; 10)
     
       /* Signal that the symbol is the label of constructor section.  */
     #define BSF_CONSTRUCTOR        (1 &lt;&lt; 11)
     
       /* Signal that the symbol is a warning symbol.  The name is a
          warning.  The name of the next symbol is the one to warn about;
          if a reference is made to a symbol with the same name as the next
          symbol, a warning is issued by the linker.  */
     #define BSF_WARNING            (1 &lt;&lt; 12)
     
       /* Signal that the symbol is indirect.  This symbol is an indirect
          pointer to the symbol with the same name as the next symbol.  */
     #define BSF_INDIRECT           (1 &lt;&lt; 13)
     
       /* BSF_FILE marks symbols that contain a file name.  This is used
          for ELF STT_FILE symbols.  */
     #define BSF_FILE               (1 &lt;&lt; 14)
     
       /* Symbol is from dynamic linking information.  */
     #define BSF_DYNAMIC            (1 &lt;&lt; 15)
     
       /* The symbol denotes a data object.  Used in ELF, and perhaps
          others someday.  */
     #define BSF_OBJECT             (1 &lt;&lt; 16)
     
       /* This symbol is a debugging symbol.  The value is the offset
          into the section of the data.  BSF_DEBUGGING should be set
          as well.  */
     #define BSF_DEBUGGING_RELOC    (1 &lt;&lt; 17)
     
       /* This symbol is thread local.  Used in ELF.  */
     #define BSF_THREAD_LOCAL       (1 &lt;&lt; 18)
     
       /* This symbol represents a complex relocation expression,
          with the expression tree serialized in the symbol name.  */
     #define BSF_RELC               (1 &lt;&lt; 19)
     
       /* This symbol represents a signed complex relocation expression,
          with the expression tree serialized in the symbol name.  */
     #define BSF_SRELC              (1 &lt;&lt; 20)
     
       /* This symbol was created by bfd_get_synthetic_symtab.  */
     #define BSF_SYNTHETIC          (1 &lt;&lt; 21)
     
       /* This symbol is an indirect code object.  Unrelated to BSF_INDIRECT.
          The dynamic linker will compute the value of this symbol by
          calling the function that it points to.  BSF_FUNCTION must
          also be also set.  */
     #define BSF_GNU_INDIRECT_FUNCTION (1 &lt;&lt; 22)
       /* This symbol is a globally unique data object.  The dynamic linker
          will make sure that in the entire process there is just one symbol
          with this name and type in use.  BSF_OBJECT must also be set.  */
     #define BSF_GNU_UNIQUE         (1 &lt;&lt; 23)
     
       flagword flags;
     
       /* A pointer to the section to which this symbol is
          relative.  This will always be non NULL, there are special
          sections for undefined and absolute symbols.  */
       struct bfd_section *section;
     
       /* Back end special data.  */
       union
         {
           void *p;
           bfd_vma i;
         }
       udata;
     }
     asymbol;
     </PRE>