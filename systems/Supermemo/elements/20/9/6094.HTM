Should you merge or rebase? </P>
<P>So, should you merge or rebase your changes during a pull operation? The short answer is &#8220;Do either as you wish.&#8221; So, why would you choose to do one over the other? Here are some issues to consider. </P>
<P>By using merge, you will potentially incur an additional merge commit at each pull to record the updated changes simultaneously present in each branch. In a sense, it is a true reflection of the two paths of development that took place independently and were then, well, merged together. Conflicts will have to be resolved during the merge. Each sequence of commits on each branch will be based on exactly the commit on which it was originally written. When pushed upstream, any merge commits will continue to be present. Some consider these superfluous merges and would rather not see them cluttering up the history. Others consider these merges a more accurate portrayal of the development history and want to see them retained.</P>
<P>As a rebase fundamentally changes the notion of when and where a sequence of commits was developed, some aspects of the development history will be lost. Specifically, the original commit on which your development was originally based will be changed to be the newly pulled HEAD of the remote-tracking branch. That will make the development appear to happen later (in commit sequence) than it actually did. If that&#8217;s OK with you, it&#8217;s OK with me. It&#8217;ll just be different and simpler than if the history was merged. Naturally, you will have to resolve conflicts during the rebase operation as needed still. As the changes that are being rebased are still strictly local within your repository and haven&#8217;t been published yet, there&#8217;s really no reason to fear the &#8220;don&#8217;t change history&#8221; mantra with this rebase.</P>
<P>With both merge and rebase, you should consider that the new, final content is different from what was present on either development branch independently. As such, it might warrant some form of validation in its new form: perhaps a compilation and test cycle prior to being pushed to an upstream repository.</P>
<P>I tend to like to see simpler, linear histories. During most of my personal development, I&#8217;m usually not too concerned by a slight reordering of my changes with respect to those of my coworker&#8217;s that came in on a remote-tracking branch fetch, so I am fond of using the rebase option.</P>
<P>If you really want to set up one consistent approach, consider setting config options branch.autosetupmerge or branch.autosetuprebase to true, false, or always as desired. There are also a few other options to handle behavior between purely local branches and not just between a local and a remote branch.