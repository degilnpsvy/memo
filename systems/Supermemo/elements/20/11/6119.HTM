Bare Repositories and git push </P>
<P>As a consequence of the peer-to-peer semantics of Git repositories, all repositories are of equal stature. You can push to and fetch from development and bare repositories equally, because there is no fundamental implementation distinction between them. This symmetric design is critically important to Git, but it also leads to some unexpected behavior if you try to treat bare and development repositories as exact equals. </P>
<P>Recall that the git push command does not check out files in the receiving repository. It simply transfers objects from the source repository to the receiving repository and then updates the corresponding refs on the receivingend. </P>
<P>In a bare repository, this behavior is all that can be expected, because there is no working directory that might be updated by checked out files. That&#8217;s good. However, in a development repository that is the recipient of a push operation, it can later cause confusion to anyone using the development repository. </P>
<P>The push operation can update the repository state, including the HEAD commit. That is, even though the developer at the remote end has done nothing, the branch refs and HEAD might change, becoming out of sync with the checked out files and index. </P>
<P>A developer who is actively working in a repository into which an asynchronous push happens will not see the push. But a subsequent commit by that developer will occur on an unexpected HEAD, creating an odd history. A forced push will lose pushed commits from the other developer. The developer at that repository also may find herself unable to reconcile her history with either an upstream repository or a downstream clone because they are no longer simple fast-forwards as they should be. And she won&#8217;t know why: the repository has silently changed out from underneath her. Cats and dogs will live together. It&#8217;ll be bad. </P>
<P>As a result, you are encouraged to push only into a bare repository. This is not a hardand- fast rule, but it&#8217;s a good guide to the average developer and is considered a best practice. There are a few instances and use cases where you might want to push into a development repository, but you should fully understand its implications. When you do want to push into a development repository, you may want to follow one of two basic approaches. </P>
<P>In the first scenario, you really do want to have a working directory with a branch checked out in the receiving repository. You may know, for example, that no other developer will ever be doing active development there and therefore there is no one who might be blind sided by silent changes being pushed into his repository. </P>
<P>In this case, you may want to enable a hook in the receiving repository to perform a checkout of some branch, perhaps the one just pushed, into the working directory as well. To verify that the receiving repository is in a sane state prior to having an automatic checkout, the hook should ensure that the nonbare repository&#8217;s working directory contains no edits or modified files and that its index has no files in the staged but uncommitted state when the push happens. When these conditions are not met, you run the risk of losing those edits or changes as the checkout overwrites them. </P>
<P>There is another scenario where pushing into a nonbare repository can work reasonably well. By agreement, each developer who pushes changes must push to a non&#8211;checked out branch that is considered simply a receiving branch. A developer never pushes to a branch that is expected to be checked out. It is up to some developer in particular to manage what branch is checked out and when. Perhaps that person is responsible for handling the receiving branches and merging them into a master branch before it is checked out.