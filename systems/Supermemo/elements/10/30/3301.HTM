<B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Bold-0-1000-23; mso-bidi-font-family: Minion-Bold-0-1000-23; mso-font-kerning: 0pt">8.5.7 </SPAN></B><B><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-BoldItalic-0-1000-21; mso-bidi-font-family: Minion-BoldItalic-0-1000-21; mso-font-kerning: 0pt">Multiple FP Condition Bits</SPAN></I></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt">Prior to MIPS IV, all tests on floating-point numbers communicated with the main instruction set through a single condition bit, which was set explicitly by compare instructions and tested explicitly by special conditional branch instructions. The architecture grew like this because in the early days the floating-point unit was a separate chip, and the FP condition bit was implemented with a signal wire that passed into the main CPU.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt">The trouble with the single bit is that it creates dependencies that reduce the potential for launching multiple instructions in parallel. There is an unavoidable write-to-read dependency between the compare instruction that creates a condition and the branch instruction that tests it, while there</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt; mso-fareast-font-family: Minion-Regular-0-1000-18; mso-ascii-font-family: Minion-Regular-0-1000-18">&#8217;</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt">s an avoidable read-to-write interaction where a subsequent compare instruction must be delayed until the branch has seen and acted on its previous value.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt">FP array calculations benefit from a compilation technique called </SPAN><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Italic-0-1000-19; mso-bidi-font-family: Minion-Italic-0-1000-19; mso-font-kerning: 0pt">software pipelining</SPAN></I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt">, where a loop is unrolled and the computations of successive loop iterations are deliberately interleaved to make maximum use of multiple FP units. But if something in the loop body requires a test and branch, the single condition unit will make this impossible; hence, multiple conditions can make a big difference.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt">Modern FPUs provide 8 bits, not just 1; compare and FP conditional branch instructions specify which condition bit should be used. Older compilers set reserved fields to zero, so old code will run correctly using just condition code zero.</SPAN>