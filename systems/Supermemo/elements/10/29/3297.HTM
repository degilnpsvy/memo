<B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Bold-0-1000-23; mso-bidi-font-family: Minion-Bold-0-1000-23; mso-font-kerning: 0pt">8.5.3 </SPAN></B><B><I><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-BoldItalic-0-1000-21; mso-bidi-font-family: Minion-BoldItalic-0-1000-21; mso-font-kerning: 0pt">Conditional Move Instructions</SPAN></I></B> 
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt"><FONT class=extract>A conditional move instruction copies data from one register to another, but only if some condition is satisfied</FONT></SPAN><SPAN style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt"><FONT class=extract>&#8212;</FONT><SPAN lang=EN-US><FONT class=extract>otherwise, it does nothing.</FONT> They were featured in other RISC architectures (ARM may have been first) before making a MIPS debut with the MIPS IV instruction set (first implemented in the R8000, R10000, and R5000 in 1995</SPAN>&#8211;<SPAN lang=EN-US>1996). Conditional moves allow compilers to generate code with fewer conditional branches</SPAN>&#8212;<SPAN lang=EN-US>which is good, because conditional branches are bad for pipeline efficiency.</SPAN></SPAN></P>
<P><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt">CPUs built with the simple five-stage pipeline described in Chapter 1 don</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt; mso-fareast-font-family: Minion-Regular-0-1000-18; mso-ascii-font-family: Minion-Regular-0-1000-18">&#8217;</SPAN><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt">t have much trouble with branches; the branch delay slot instruction is usually executed, and the CPU then moves straight to the branch target. With these simple CPUs, most branches are free (provided the branch delay slot contains a useful instruction) and the others cost only one clock cycle.</SPAN></FONT></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt"><FONT class=extract>But more extravagant implementations of the MIPS ISA may lose many instruction-execution opportunities while waiting for the branch condition to be resolved and the target instruction to be fetched. The long-pipeline R4400, for example, always pays a two-clock-cycle penalty on every taken branch. In the highly superscalar R10000 (which can issue four instructions per clock cycle) you might lose seven instruction issue opportunities waiting for the branch condition to be resolved. To reduce the effect of this, the R10000 has special branch prediction circuits that guess the branch outcome and run ahead accordingly, while keeping the ability to back off from those speculative instructions. This is quite complicated: If the compiler can reduce the frequency with which it relies on the complicated features, it will run faster.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt"><FONT class=extract>How do conditional move instructions get rid of branches? Consider a piece of code generating the minimum of two values:</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-8r-0-1000-31; mso-bidi-font-family: Courier-8r-0-1000-31; mso-font-kerning: 0pt"><FONT class=extract>n = (a &lt; b) ? a: b;</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt"><FONT class=extract>Assuming that the compiler has managed to get all the variables into registers, this would normally compile to a sequence like the following (this is logical assembly language sequence, before making pipeline adjustments for delay slots):</FONT></SPAN></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-30; mso-bidi-font-family: Courier-Bold-8r-0-1000-30; mso-font-kerning: 0pt"><FONT class=extract>slt t0, a, b</FONT></SPAN></B></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-30; mso-bidi-font-family: Courier-Bold-8r-0-1000-30; mso-font-kerning: 0pt"><FONT class=extract>move n, a</FONT></SPAN></B></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-30; mso-bidi-font-family: Courier-Bold-8r-0-1000-30; mso-font-kerning: 0pt"><FONT class=extract>bne zero, t0, 1f</FONT></SPAN></B></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-30; mso-bidi-font-family: Courier-Bold-8r-0-1000-30; mso-font-kerning: 0pt"><FONT class=extract>move n, b</FONT></SPAN></B></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-30; mso-bidi-font-family: Courier-Bold-8r-0-1000-30; mso-font-kerning: 0pt"><FONT class=extract>1:</FONT></SPAN></B></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt"><FONT class=extract>can be replaced with:</FONT></SPAN></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-30; mso-bidi-font-family: Courier-Bold-8r-0-1000-30; mso-font-kerning: 0pt"><FONT class=extract>slt t0, a, b</FONT></SPAN></B></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-30; mso-bidi-font-family: Courier-Bold-8r-0-1000-30; mso-font-kerning: 0pt"><FONT class=extract>move n, a</FONT></SPAN></B></P>
<P><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-30; mso-bidi-font-family: Courier-Bold-8r-0-1000-30; mso-font-kerning: 0pt"><FONT class=extract>movz n, b, t0</FONT></SPAN></B></P>
<P><FONT class=extract><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt">Although the conditional move instruction </SPAN><B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Courier-Bold-8r-0-1000-30; mso-bidi-font-family: Courier-Bold-8r-0-1000-30; mso-font-kerning: 0pt">movz </SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 14pt; FONT-FAMILY: Minion-Regular-0-1000-18; mso-bidi-font-family: Minion-Regular-0-1000-18; mso-font-kerning: 0pt">looks strange, its role in the pipeline is exactly like any other register/register computational instruction. A branch has been removed and our highly pipelined CPU will go faster.</SPAN></FONT>