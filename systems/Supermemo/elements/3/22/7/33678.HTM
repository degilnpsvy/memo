#if !defined(CONFIG_USER_ONLY) || !defined(TARGET_AARCH64)<BR>static bool arm_v7m_cpu_exec_interrupt(CPUState *cs, int interrupt_request)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUClass *cc = CPU_GET_CLASS(cs);<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; bool ret = false; 
<P></P>
<P><BR>&nbsp;&nbsp;&nbsp; if (interrupt_request &amp; CPU_INTERRUPT_FIQ<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !(env-&gt;daif &amp; PSTATE_F)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = EXCP_FIQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc-&gt;do_interrupt(cs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = true;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* ARMv7-M interrupt return works by loading a magic value<BR>&nbsp;&nbsp;&nbsp;&nbsp; * into the PC.&nbsp; On real hardware the load causes the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * return to occur.&nbsp; The qemu implementation performs the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * jump normally, then does the exception return when the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * CPU tries to execute code at the magic address.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This will cause the magic PC value to be pushed to<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the stack if an interrupt occurred at the wrong time.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * We avoid this by disabling interrupts when<BR>&nbsp;&nbsp;&nbsp;&nbsp; * pc contains a magic address.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (interrupt_request &amp; CPU_INTERRUPT_HARD<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !(env-&gt;daif &amp; PSTATE_I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (env-&gt;regs[15] &lt; 0xfffffff0)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = EXCP_IRQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc-&gt;do_interrupt(cs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = true;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return ret;<BR>}<BR>#endif