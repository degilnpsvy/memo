# qemu:cpus.c 
<P></P>
<P>/*<BR>&nbsp;* QEMU System Emulator<BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2003-2008 Fabrice Bellard<BR>&nbsp;*<BR>&nbsp;* Permission is hereby granted, free of charge, to any person obtaining a copy<BR>&nbsp;* of this software and associated documentation files (the "Software"), to deal<BR>&nbsp;* in the Software without restriction, including without limitation the rights<BR>&nbsp;* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<BR>&nbsp;* copies of the Software, and to permit persons to whom the Software is<BR>&nbsp;* furnished to do so, subject to the following conditions:<BR>&nbsp;*<BR>&nbsp;* The above copyright notice and this permission notice shall be included in<BR>&nbsp;* all copies or substantial portions of the Software.<BR>&nbsp;*<BR>&nbsp;* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<BR>&nbsp;* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<BR>&nbsp;* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL<BR>&nbsp;* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<BR>&nbsp;* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<BR>&nbsp;* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<BR>&nbsp;* THE SOFTWARE.<BR>&nbsp;*/</P>
<P></P>
<P>/* Needed early for CONFIG_BSD etc. */<BR>#include "qemu/osdep.h"</P>
<P>#include "monitor/monitor.h"<BR>#include "qapi/qmp/qerror.h"<BR>#include "qemu/error-report.h"<BR>#include "sysemu/sysemu.h"<BR>#include "exec/gdbstub.h"<BR>#include "sysemu/dma.h"<BR>#include "sysemu/kvm.h"<BR>#include "qmp-commands.h"</P>
<P>#include "qemu/thread.h"<BR>#include "sysemu/cpus.h"<BR>#include "sysemu/qtest.h"<BR>#include "qemu/main-loop.h"<BR>#include "qemu/bitmap.h"<BR>#include "qemu/seqlock.h"<BR>#include "qapi-event.h"<BR>#include "hw/nmi.h"<BR>#include "sysemu/replay.h"</P>
<P>#ifndef _WIN32<BR>#include "qemu/compatfd.h"<BR>#endif</P>
<P>#ifdef CONFIG_LINUX</P>
<P>#include &lt;sys/prctl.h&gt;</P>
<P>#ifndef PR_MCE_KILL<BR>#define PR_MCE_KILL 33<BR>#endif</P>
<P>#ifndef PR_MCE_KILL_SET<BR>#define PR_MCE_KILL_SET 1<BR>#endif</P>
<P>#ifndef PR_MCE_KILL_EARLY<BR>#define PR_MCE_KILL_EARLY 1<BR>#endif</P>
<P>#endif /* CONFIG_LINUX */</P>
<P>static CPUState *next_cpu;<BR>int64_t max_delay;<BR>int64_t max_advance;</P>
<P>/* vcpu throttling controls */<BR>static QEMUTimer *throttle_timer;<BR>static unsigned int throttle_percentage;</P>
<P>#define CPU_THROTTLE_PCT_MIN 1<BR>#define CPU_THROTTLE_PCT_MAX 99<BR>#define CPU_THROTTLE_TIMESLICE_NS 10000000</P>
<P>bool cpu_is_stopped(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; return cpu-&gt;stopped || !runstate_is_running();<BR>}</P>
<P>static bool cpu_thread_is_idle(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (cpu-&gt;stop || cpu-&gt;queued_work_first) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (cpu_is_stopped(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (!cpu-&gt;halted || cpu_has_work(cpu) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kvm_halt_in_kernel()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return true;<BR>}</P>
<P>static bool all_cpu_threads_idle(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!cpu_thread_is_idle(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return true;<BR>}</P>
<P>/***********************************************************/<BR>/* guest cycle counter */</P>
<P>/* Protected by TimersState seqlock */</P>
<P>static bool icount_sleep = true;<BR>static int64_t vm_clock_warp_start = -1;<BR>/* Conversion factor from emulated instructions to virtual clock ticks.&nbsp; */<BR>static int icount_time_shift;<BR>/* Arbitrarily pick 1MIPS as the minimum allowable speed.&nbsp; */<BR>#define MAX_ICOUNT_SHIFT 10</P>
<P>static QEMUTimer *icount_rt_timer;<BR>static QEMUTimer *icount_vm_timer;<BR>static QEMUTimer *icount_warp_timer;</P>
<P>typedef struct TimersState {<BR>&nbsp;&nbsp;&nbsp; /* Protected by BQL.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int64_t cpu_ticks_prev;<BR>&nbsp;&nbsp;&nbsp; int64_t cpu_ticks_offset;</P>
<P>&nbsp;&nbsp;&nbsp; /* cpu_clock_offset can be read out of BQL, so protect it with<BR>&nbsp;&nbsp;&nbsp;&nbsp; * this lock.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; QemuSeqLock vm_clock_seqlock;<BR>&nbsp;&nbsp;&nbsp; int64_t cpu_clock_offset;<BR>&nbsp;&nbsp;&nbsp; int32_t cpu_ticks_enabled;<BR>&nbsp;&nbsp;&nbsp; int64_t dummy;</P>
<P>&nbsp;&nbsp;&nbsp; /* Compensate for varying guest execution speed.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int64_t qemu_icount_bias;<BR>&nbsp;&nbsp;&nbsp; /* Only written by TCG thread */<BR>&nbsp;&nbsp;&nbsp; int64_t qemu_icount;<BR>} TimersState;</P>
<P>static TimersState timers_state;</P>
<P>int64_t cpu_get_icount_raw(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; int64_t icount;<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu = current_cpu;</P>
<P>&nbsp;&nbsp;&nbsp; icount = timers_state.qemu_icount;<BR>&nbsp;&nbsp;&nbsp; if (cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!cpu-&gt;can_do_io) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Bad icount read\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icount -= (cpu-&gt;icount_decr.u16.low + cpu-&gt;icount_extra);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return icount;<BR>}</P>
<P>/* Return the virtual CPU time, based on the instruction counter.&nbsp; */<BR>static int64_t cpu_get_icount_locked(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; int64_t icount = cpu_get_icount_raw();<BR>&nbsp;&nbsp;&nbsp; return timers_state.qemu_icount_bias + cpu_icount_to_ns(icount);<BR>}</P>
<P>int64_t cpu_get_icount(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; int64_t icount;<BR>&nbsp;&nbsp;&nbsp; unsigned start;</P>
<P>&nbsp;&nbsp;&nbsp; do {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start = seqlock_read_begin(&amp;timers_state.vm_clock_seqlock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icount = cpu_get_icount_locked();<BR>&nbsp;&nbsp;&nbsp; } while (seqlock_read_retry(&amp;timers_state.vm_clock_seqlock, start));</P>
<P>&nbsp;&nbsp;&nbsp; return icount;<BR>}</P>
<P>int64_t cpu_icount_to_ns(int64_t icount)<BR>{<BR>&nbsp;&nbsp;&nbsp; return icount &lt;&lt; icount_time_shift;<BR>}</P>
<P>/* return the host CPU cycle counter and handle stop/restart */<BR>/* Caller must hold the BQL */<BR>int64_t cpu_get_ticks(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; int64_t ticks;</P>
<P>&nbsp;&nbsp;&nbsp; if (use_icount) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return cpu_get_icount();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; ticks = timers_state.cpu_ticks_offset;<BR>&nbsp;&nbsp;&nbsp; if (timers_state.cpu_ticks_enabled) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ticks += cpu_get_host_ticks();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (timers_state.cpu_ticks_prev &gt; ticks) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note: non increasing ticks may happen if the host uses<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; software suspend */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timers_state.cpu_ticks_offset += timers_state.cpu_ticks_prev - ticks;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ticks = timers_state.cpu_ticks_prev;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; timers_state.cpu_ticks_prev = ticks;<BR>&nbsp;&nbsp;&nbsp; return ticks;<BR>}</P>
<P>static int64_t cpu_get_clock_locked(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; int64_t ticks;</P>
<P>&nbsp;&nbsp;&nbsp; ticks = timers_state.cpu_clock_offset;<BR>&nbsp;&nbsp;&nbsp; if (timers_state.cpu_ticks_enabled) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ticks += get_clock();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return ticks;<BR>}</P>
<P>/* return the host CPU monotonic timer and handle stop/restart */<BR>int64_t cpu_get_clock(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; int64_t ti;<BR>&nbsp;&nbsp;&nbsp; unsigned start;</P>
<P>&nbsp;&nbsp;&nbsp; do {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start = seqlock_read_begin(&amp;timers_state.vm_clock_seqlock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ti = cpu_get_clock_locked();<BR>&nbsp;&nbsp;&nbsp; } while (seqlock_read_retry(&amp;timers_state.vm_clock_seqlock, start));</P>
<P>&nbsp;&nbsp;&nbsp; return ti;<BR>}</P>
<P>/* enable cpu_get_ticks()<BR>&nbsp;* Caller must hold BQL which server as mutex for vm_clock_seqlock.<BR>&nbsp;*/<BR>void cpu_enable_ticks(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Here, the really thing protected by seqlock is cpu_clock_offset. */<BR>&nbsp;&nbsp;&nbsp; seqlock_write_lock(&amp;timers_state.vm_clock_seqlock);<BR>&nbsp;&nbsp;&nbsp; if (!timers_state.cpu_ticks_enabled) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timers_state.cpu_ticks_offset -= cpu_get_host_ticks();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timers_state.cpu_clock_offset -= get_clock();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timers_state.cpu_ticks_enabled = 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; seqlock_write_unlock(&amp;timers_state.vm_clock_seqlock);<BR>}</P>
<P>/* disable cpu_get_ticks() : the clock is stopped. You must not call<BR>&nbsp;* cpu_get_ticks() after that.<BR>&nbsp;* Caller must hold BQL which server as mutex for vm_clock_seqlock.<BR>&nbsp;*/<BR>void cpu_disable_ticks(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Here, the really thing protected by seqlock is cpu_clock_offset. */<BR>&nbsp;&nbsp;&nbsp; seqlock_write_lock(&amp;timers_state.vm_clock_seqlock);<BR>&nbsp;&nbsp;&nbsp; if (timers_state.cpu_ticks_enabled) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timers_state.cpu_ticks_offset += cpu_get_host_ticks();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timers_state.cpu_clock_offset = cpu_get_clock_locked();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timers_state.cpu_ticks_enabled = 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; seqlock_write_unlock(&amp;timers_state.vm_clock_seqlock);<BR>}</P>
<P>/* Correlation between real and virtual time is always going to be<BR>&nbsp;&nbsp; fairly approximate, so ignore small variation.<BR>&nbsp;&nbsp; When the guest is idle real and virtual time will be aligned in<BR>&nbsp;&nbsp; the IO wait loop.&nbsp; */<BR>#define ICOUNT_WOBBLE (get_ticks_per_sec() / 10)</P>
<P>static void icount_adjust(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; int64_t cur_time;<BR>&nbsp;&nbsp;&nbsp; int64_t cur_icount;<BR>&nbsp;&nbsp;&nbsp; int64_t delta;</P>
<P>&nbsp;&nbsp;&nbsp; /* Protected by TimersState mutex.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; static int64_t last_delta;</P>
<P>&nbsp;&nbsp;&nbsp; /* If the VM is not running, then do nothing.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!runstate_is_running()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; seqlock_write_lock(&amp;timers_state.vm_clock_seqlock);<BR>&nbsp;&nbsp;&nbsp; cur_time = cpu_get_clock_locked();<BR>&nbsp;&nbsp;&nbsp; cur_icount = cpu_get_icount_locked();</P>
<P>&nbsp;&nbsp;&nbsp; delta = cur_icount - cur_time;<BR>&nbsp;&nbsp;&nbsp; /* FIXME: This is a very crude algorithm, somewhat prone to oscillation.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (delta &gt; 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; last_delta + ICOUNT_WOBBLE &lt; delta * 2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; icount_time_shift &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The guest is getting too far ahead.&nbsp; Slow time down.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icount_time_shift--;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (delta &lt; 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; last_delta - ICOUNT_WOBBLE &gt; delta * 2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; icount_time_shift &lt; MAX_ICOUNT_SHIFT) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The guest is getting too far behind.&nbsp; Speed time up.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icount_time_shift++;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; last_delta = delta;<BR>&nbsp;&nbsp;&nbsp; timers_state.qemu_icount_bias = cur_icount<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - (timers_state.qemu_icount &lt;&lt; icount_time_shift);<BR>&nbsp;&nbsp;&nbsp; seqlock_write_unlock(&amp;timers_state.vm_clock_seqlock);<BR>}</P>
<P>static void icount_adjust_rt(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; timer_mod(icount_rt_timer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL_RT) + 1000);<BR>&nbsp;&nbsp;&nbsp; icount_adjust();<BR>}</P>
<P>static void icount_adjust_vm(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; timer_mod(icount_vm_timer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_ticks_per_sec() / 10);<BR>&nbsp;&nbsp;&nbsp; icount_adjust();<BR>}</P>
<P>static int64_t qemu_icount_round(int64_t count)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (count + (1 &lt;&lt; icount_time_shift) - 1) &gt;&gt; icount_time_shift;<BR>}</P>
<P>static void icount_warp_rt(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* The icount_warp_timer is rescheduled soon after vm_clock_warp_start<BR>&nbsp;&nbsp;&nbsp;&nbsp; * changes from -1 to another value, so the race here is okay.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (atomic_read(&amp;vm_clock_warp_start) == -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; seqlock_write_lock(&amp;timers_state.vm_clock_seqlock);<BR>&nbsp;&nbsp;&nbsp; if (runstate_is_running()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int64_t clock = REPLAY_CLOCK(REPLAY_CLOCK_VIRTUAL_RT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_get_clock_locked());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int64_t warp_delta;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; warp_delta = clock - vm_clock_warp_start;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (use_icount == 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * In adaptive mode, do not let QEMU_CLOCK_VIRTUAL run too<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * far ahead of real time.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int64_t cur_icount = cpu_get_icount_locked();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int64_t delta = clock - cur_icount;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; warp_delta = MIN(warp_delta, delta);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timers_state.qemu_icount_bias += warp_delta;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; vm_clock_warp_start = -1;<BR>&nbsp;&nbsp;&nbsp; seqlock_write_unlock(&amp;timers_state.vm_clock_seqlock);</P>
<P>&nbsp;&nbsp;&nbsp; if (qemu_clock_expired(QEMU_CLOCK_VIRTUAL)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_clock_notify(QEMU_CLOCK_VIRTUAL);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void icount_timer_cb(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* No need for a checkpoint because the timer already synchronizes<BR>&nbsp;&nbsp;&nbsp;&nbsp; * with CHECKPOINT_CLOCK_VIRTUAL_RT.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; icount_warp_rt();<BR>}</P>
<P>void qtest_clock_warp(int64_t dest)<BR>{<BR>&nbsp;&nbsp;&nbsp; int64_t clock = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);<BR>&nbsp;&nbsp;&nbsp; AioContext *aio_context;<BR>&nbsp;&nbsp;&nbsp; assert(qtest_enabled());<BR>&nbsp;&nbsp;&nbsp; aio_context = qemu_get_aio_context();<BR>&nbsp;&nbsp;&nbsp; while (clock &lt; dest) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int64_t deadline = qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int64_t warp = qemu_soonest_timeout(dest - clock, deadline);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seqlock_write_lock(&amp;timers_state.vm_clock_seqlock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timers_state.qemu_icount_bias += warp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seqlock_write_unlock(&amp;timers_state.vm_clock_seqlock);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_clock_run_timers(QEMU_CLOCK_VIRTUAL);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timerlist_run_timers(aio_context-&gt;tlg.tl[QEMU_CLOCK_VIRTUAL]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clock = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; qemu_clock_notify(QEMU_CLOCK_VIRTUAL);<BR>}</P>
<P>void qemu_start_warp_timer(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; int64_t clock;<BR>&nbsp;&nbsp;&nbsp; int64_t deadline;</P>
<P>&nbsp;&nbsp;&nbsp; if (!use_icount) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Nothing to do if the VM is stopped: QEMU_CLOCK_VIRTUAL timers<BR>&nbsp;&nbsp;&nbsp;&nbsp; * do not fire, so computing the deadline does not make sense.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!runstate_is_running()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* warp clock deterministically in record/replay mode */<BR>&nbsp;&nbsp;&nbsp; if (!replay_checkpoint(CHECKPOINT_CLOCK_WARP_START)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (!all_cpu_threads_idle()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (qtest_enabled()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* When testing, qtest commands advance icount.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* We want to use the earliest deadline from ALL vm_clocks */<BR>&nbsp;&nbsp;&nbsp; clock = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_RT);<BR>&nbsp;&nbsp;&nbsp; deadline = qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL);<BR>&nbsp;&nbsp;&nbsp; if (deadline &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static bool notified;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!icount_sleep &amp;&amp; !notified) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_report("WARNING: icount sleep disabled and no active timers");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; notified = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (deadline &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Ensure QEMU_CLOCK_VIRTUAL proceeds even when the virtual CPU goes to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * sleep.&nbsp; Otherwise, the CPU might be waiting for a future timer<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * interrupt to wake it up, but the interrupt never comes because<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the vCPU isn't running any insns and thus doesn't advance the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * QEMU_CLOCK_VIRTUAL.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!icount_sleep) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * We never let VCPUs sleep in no sleep icount mode.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * If there is a pending QEMU_CLOCK_VIRTUAL timer we just advance<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * to the next QEMU_CLOCK_VIRTUAL event and notify it.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * It is useful when we want a deterministic execution time,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * isolated from host latencies.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seqlock_write_lock(&amp;timers_state.vm_clock_seqlock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timers_state.qemu_icount_bias += deadline;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seqlock_write_unlock(&amp;timers_state.vm_clock_seqlock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_clock_notify(QEMU_CLOCK_VIRTUAL);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * We do stop VCPUs and only advance QEMU_CLOCK_VIRTUAL after some<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * "real" time, (related to the time left until the next event) has<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * passed. The QEMU_CLOCK_VIRTUAL_RT clock will do this.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * This avoids that the warps are visible externally; for example,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * you will not be sending network packets continuously instead of<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * every 100ms.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seqlock_write_lock(&amp;timers_state.vm_clock_seqlock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (vm_clock_warp_start == -1 || vm_clock_warp_start &gt; clock) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vm_clock_warp_start = clock;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seqlock_write_unlock(&amp;timers_state.vm_clock_seqlock);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timer_mod_anticipate(icount_warp_timer, clock + deadline);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else if (deadline == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_clock_notify(QEMU_CLOCK_VIRTUAL);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void qemu_account_warp_timer(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (!use_icount || !icount_sleep) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Nothing to do if the VM is stopped: QEMU_CLOCK_VIRTUAL timers<BR>&nbsp;&nbsp;&nbsp;&nbsp; * do not fire, so computing the deadline does not make sense.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!runstate_is_running()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* warp clock deterministically in record/replay mode */<BR>&nbsp;&nbsp;&nbsp; if (!replay_checkpoint(CHECKPOINT_CLOCK_WARP_ACCOUNT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; timer_del(icount_warp_timer);<BR>&nbsp;&nbsp;&nbsp; icount_warp_rt();<BR>}</P>
<P>static bool icount_state_needed(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; return use_icount;<BR>}</P>
<P>/*<BR>&nbsp;* This is a subsection for icount migration.<BR>&nbsp;*/<BR>static const VMStateDescription icount_vmstate_timers = {<BR>&nbsp;&nbsp;&nbsp; .name = "timer/icount",<BR>&nbsp;&nbsp;&nbsp; .version_id = 1,<BR>&nbsp;&nbsp;&nbsp; .minimum_version_id = 1,<BR>&nbsp;&nbsp;&nbsp; .needed = icount_state_needed,<BR>&nbsp;&nbsp;&nbsp; .fields = (VMStateField[]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_INT64(qemu_icount_bias, TimersState),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_INT64(qemu_icount, TimersState),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_END_OF_LIST()<BR>&nbsp;&nbsp;&nbsp; }<BR>};</P>
<P>static const VMStateDescription vmstate_timers = {<BR>&nbsp;&nbsp;&nbsp; .name = "timer",<BR>&nbsp;&nbsp;&nbsp; .version_id = 2,<BR>&nbsp;&nbsp;&nbsp; .minimum_version_id = 1,<BR>&nbsp;&nbsp;&nbsp; .fields = (VMStateField[]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_INT64(cpu_ticks_offset, TimersState),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_INT64(dummy, TimersState),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_INT64_V(cpu_clock_offset, TimersState, 2),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_END_OF_LIST()<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; .subsections = (const VMStateDescription*[]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;icount_vmstate_timers,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL<BR>&nbsp;&nbsp;&nbsp; }<BR>};</P>
<P>static void cpu_throttle_thread(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; double pct;<BR>&nbsp;&nbsp;&nbsp; double throttle_ratio;<BR>&nbsp;&nbsp;&nbsp; long sleeptime_ns;</P>
<P>&nbsp;&nbsp;&nbsp; if (!cpu_throttle_get_percentage()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; pct = (double)cpu_throttle_get_percentage()/100;<BR>&nbsp;&nbsp;&nbsp; throttle_ratio = pct / (1 - pct);<BR>&nbsp;&nbsp;&nbsp; sleeptime_ns = (long)(throttle_ratio * CPU_THROTTLE_TIMESLICE_NS);</P>
<P>&nbsp;&nbsp;&nbsp; qemu_mutex_unlock_iothread();<BR>&nbsp;&nbsp;&nbsp; atomic_set(&amp;cpu-&gt;throttle_thread_scheduled, 0);<BR>&nbsp;&nbsp;&nbsp; g_usleep(sleeptime_ns / 1000); /* Convert ns to us for usleep call */<BR>&nbsp;&nbsp;&nbsp; qemu_mutex_lock_iothread();<BR>}</P>
<P>static void cpu_throttle_timer_tick(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;<BR>&nbsp;&nbsp;&nbsp; double pct;</P>
<P>&nbsp;&nbsp;&nbsp; /* Stop the timer if needed */<BR>&nbsp;&nbsp;&nbsp; if (!cpu_throttle_get_percentage()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!atomic_xchg(&amp;cpu-&gt;throttle_thread_scheduled, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; async_run_on_cpu(cpu, cpu_throttle_thread, cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; pct = (double)cpu_throttle_get_percentage()/100;<BR>&nbsp;&nbsp;&nbsp; timer_mod(throttle_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_RT) +<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPU_THROTTLE_TIMESLICE_NS / (1-pct));<BR>}</P>
<P>void cpu_throttle_set(int new_throttle_pct)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Ensure throttle percentage is within valid range */<BR>&nbsp;&nbsp;&nbsp; new_throttle_pct = MIN(new_throttle_pct, CPU_THROTTLE_PCT_MAX);<BR>&nbsp;&nbsp;&nbsp; new_throttle_pct = MAX(new_throttle_pct, CPU_THROTTLE_PCT_MIN);</P>
<P>&nbsp;&nbsp;&nbsp; atomic_set(&amp;throttle_percentage, new_throttle_pct);</P>
<P>&nbsp;&nbsp;&nbsp; timer_mod(throttle_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_RT) +<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPU_THROTTLE_TIMESLICE_NS);<BR>}</P>
<P>void cpu_throttle_stop(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; atomic_set(&amp;throttle_percentage, 0);<BR>}</P>
<P>bool cpu_throttle_active(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (cpu_throttle_get_percentage() != 0);<BR>}</P>
<P>int cpu_throttle_get_percentage(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; return atomic_read(&amp;throttle_percentage);<BR>}</P>
<P>void cpu_ticks_init(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; seqlock_init(&amp;timers_state.vm_clock_seqlock, NULL);<BR>&nbsp;&nbsp;&nbsp; vmstate_register(NULL, 0, &amp;vmstate_timers, &amp;timers_state);<BR>&nbsp;&nbsp;&nbsp; throttle_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL_RT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_throttle_timer_tick, NULL);<BR>}</P>
<P>void configure_icount(QemuOpts *opts, Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; const char *option;<BR>&nbsp;&nbsp;&nbsp; char *rem_str = NULL;</P>
<P>&nbsp;&nbsp;&nbsp; option = qemu_opt_get(opts, "shift");<BR>&nbsp;&nbsp;&nbsp; if (!option) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (qemu_opt_get(opts, "align") != NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "Please specify shift option when using align");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; icount_sleep = qemu_opt_get_bool(opts, "sleep", true);<BR>&nbsp;&nbsp;&nbsp; if (icount_sleep) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icount_warp_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL_RT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icount_timer_cb, NULL);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; icount_align_option = qemu_opt_get_bool(opts, "align", false);</P>
<P>&nbsp;&nbsp;&nbsp; if (icount_align_option &amp;&amp; !icount_sleep) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "align=on and sleep=off are incompatible");<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (strcmp(option, "auto") != 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errno = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icount_time_shift = strtol(option, &amp;rem_str, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (errno != 0 || *rem_str != '\0' || !strlen(option)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "icount: Invalid shift value");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use_icount = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; } else if (icount_align_option) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "shift=auto and align=on are incompatible");<BR>&nbsp;&nbsp;&nbsp; } else if (!icount_sleep) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "shift=auto and sleep=off are incompatible");<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; use_icount = 2;</P>
<P>&nbsp;&nbsp;&nbsp; /* 125MIPS seems a reasonable initial guess at the guest speed.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It will be corrected fairly quickly anyway.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; icount_time_shift = 3;</P>
<P>&nbsp;&nbsp;&nbsp; /* Have both realtime and virtual time triggers for speed adjustment.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The realtime trigger catches emulated time passing too slowly,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the virtual time trigger catches emulated time passing too fast.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Realtime triggers occur even when idle, so use them less frequently<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; than VM triggers.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; icount_rt_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL_RT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icount_adjust_rt, NULL);<BR>&nbsp;&nbsp;&nbsp; timer_mod(icount_rt_timer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL_RT) + 1000);<BR>&nbsp;&nbsp;&nbsp; icount_vm_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icount_adjust_vm, NULL);<BR>&nbsp;&nbsp;&nbsp; timer_mod(icount_vm_timer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_ticks_per_sec() / 10);<BR>}</P>
<P>/***********************************************************/<BR>void hw_error(const char *fmt, ...)<BR>{<BR>&nbsp;&nbsp;&nbsp; va_list ap;<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;</P>
<P>&nbsp;&nbsp;&nbsp; va_start(ap, fmt);<BR>&nbsp;&nbsp;&nbsp; fprintf(stderr, "qemu: hardware error: ");<BR>&nbsp;&nbsp;&nbsp; vfprintf(stderr, fmt, ap);<BR>&nbsp;&nbsp;&nbsp; fprintf(stderr, "\n");<BR>&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "CPU #%d:\n", cpu-&gt;cpu_index);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_dump_state(cpu, stderr, fprintf, CPU_DUMP_FPU);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; va_end(ap);<BR>&nbsp;&nbsp;&nbsp; abort();<BR>}</P>
<P>void cpu_synchronize_all_states(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_synchronize_state(cpu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void cpu_synchronize_all_post_reset(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_synchronize_post_reset(cpu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void cpu_synchronize_all_post_init(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_synchronize_post_init(cpu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static int do_vm_stop(RunState state)<BR>{<BR>&nbsp;&nbsp;&nbsp; int ret = 0;</P>
<P>&nbsp;&nbsp;&nbsp; if (runstate_is_running()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_disable_ticks();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause_all_vcpus();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; runstate_set(state);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vm_state_notify(0, state);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qapi_event_send_stop(&amp;error_abort);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; bdrv_drain_all();<BR>&nbsp;&nbsp;&nbsp; ret = bdrv_flush_all();</P>
<P>&nbsp;&nbsp;&nbsp; return ret;<BR>}</P>
<P>static bool cpu_can_run(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (cpu-&gt;stop) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (cpu_is_stopped(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return true;<BR>}</P>
<P>static void cpu_handle_guest_debug(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; gdb_set_stop_cpu(cpu);<BR>&nbsp;&nbsp;&nbsp; qemu_system_debug_request();<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;stopped = true;<BR>}</P>
<P>#ifdef CONFIG_LINUX<BR>static void sigbus_reraise(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; sigset_t set;<BR>&nbsp;&nbsp;&nbsp; struct sigaction action;</P>
<P>&nbsp;&nbsp;&nbsp; memset(&amp;action, 0, sizeof(action));<BR>&nbsp;&nbsp;&nbsp; action.sa_handler = SIG_DFL;<BR>&nbsp;&nbsp;&nbsp; if (!sigaction(SIGBUS, &amp;action, NULL)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise(SIGBUS);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigemptyset(&amp;set);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigaddset(&amp;set, SIGBUS);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigprocmask(SIG_UNBLOCK, &amp;set, NULL);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; perror("Failed to re-raise SIGBUS!\n");<BR>&nbsp;&nbsp;&nbsp; abort();<BR>}</P>
<P>static void sigbus_handler(int n, struct qemu_signalfd_siginfo *siginfo,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *ctx)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (kvm_on_sigbus(siginfo-&gt;ssi_code,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void *)(intptr_t)siginfo-&gt;ssi_addr)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigbus_reraise();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void qemu_init_sigbus(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; struct sigaction action;</P>
<P>&nbsp;&nbsp;&nbsp; memset(&amp;action, 0, sizeof(action));<BR>&nbsp;&nbsp;&nbsp; action.sa_flags = SA_SIGINFO;<BR>&nbsp;&nbsp;&nbsp; action.sa_sigaction = (void (*)(int, siginfo_t*, void*))sigbus_handler;<BR>&nbsp;&nbsp;&nbsp; sigaction(SIGBUS, &amp;action, NULL);</P>
<P>&nbsp;&nbsp;&nbsp; prctl(PR_MCE_KILL, PR_MCE_KILL_SET, PR_MCE_KILL_EARLY, 0, 0);<BR>}</P>
<P>static void qemu_kvm_eat_signals(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; struct timespec ts = { 0, 0 };<BR>&nbsp;&nbsp;&nbsp; siginfo_t siginfo;<BR>&nbsp;&nbsp;&nbsp; sigset_t waitset;<BR>&nbsp;&nbsp;&nbsp; sigset_t chkset;<BR>&nbsp;&nbsp;&nbsp; int r;</P>
<P>&nbsp;&nbsp;&nbsp; sigemptyset(&amp;waitset);<BR>&nbsp;&nbsp;&nbsp; sigaddset(&amp;waitset, SIG_IPI);<BR>&nbsp;&nbsp;&nbsp; sigaddset(&amp;waitset, SIGBUS);</P>
<P>&nbsp;&nbsp;&nbsp; do {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = sigtimedwait(&amp;waitset, &amp;siginfo, &amp;ts);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r == -1 &amp;&amp; !(errno == EAGAIN || errno == EINTR)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("sigtimedwait");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (r) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case SIGBUS:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (kvm_on_sigbus_vcpu(cpu, siginfo.si_code, siginfo.si_addr)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigbus_reraise();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = sigpending(&amp;chkset);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r == -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("sigpending");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } while (sigismember(&amp;chkset, SIG_IPI) || sigismember(&amp;chkset, SIGBUS));<BR>}</P>
<P>#else /* !CONFIG_LINUX */</P>
<P>static void qemu_init_sigbus(void)<BR>{<BR>}</P>
<P>static void qemu_kvm_eat_signals(CPUState *cpu)<BR>{<BR>}<BR>#endif /* !CONFIG_LINUX */</P>
<P>#ifndef _WIN32<BR>static void dummy_signal(int sig)<BR>{<BR>}</P>
<P>static void qemu_kvm_init_cpu_signals(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; int r;<BR>&nbsp;&nbsp;&nbsp; sigset_t set;<BR>&nbsp;&nbsp;&nbsp; struct sigaction sigact;</P>
<P>&nbsp;&nbsp;&nbsp; memset(&amp;sigact, 0, sizeof(sigact));<BR>&nbsp;&nbsp;&nbsp; sigact.sa_handler = dummy_signal;<BR>&nbsp;&nbsp;&nbsp; sigaction(SIG_IPI, &amp;sigact, NULL);</P>
<P>&nbsp;&nbsp;&nbsp; pthread_sigmask(SIG_BLOCK, NULL, &amp;set);<BR>&nbsp;&nbsp;&nbsp; sigdelset(&amp;set, SIG_IPI);<BR>&nbsp;&nbsp;&nbsp; sigdelset(&amp;set, SIGBUS);<BR>&nbsp;&nbsp;&nbsp; r = kvm_set_signal_mask(cpu, &amp;set);<BR>&nbsp;&nbsp;&nbsp; if (r) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "kvm_set_signal_mask: %s\n", strerror(-r));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>#else /* _WIN32 */<BR>static void qemu_kvm_init_cpu_signals(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; abort();<BR>}<BR>#endif /* _WIN32 */</P>
<P>static QemuMutex qemu_global_mutex;<BR>static QemuCond qemu_io_proceeded_cond;<BR>static unsigned iothread_requesting_mutex;</P>
<P>static QemuThread io_thread;</P>
<P>/* cpu creation */<BR>static QemuCond qemu_cpu_cond;<BR>/* system init */<BR>static QemuCond qemu_pause_cond;<BR>static QemuCond qemu_work_cond;</P>
<P>void qemu_init_cpu_loop(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; qemu_init_sigbus();<BR>&nbsp;&nbsp;&nbsp; qemu_cond_init(&amp;qemu_cpu_cond);<BR>&nbsp;&nbsp;&nbsp; qemu_cond_init(&amp;qemu_pause_cond);<BR>&nbsp;&nbsp;&nbsp; qemu_cond_init(&amp;qemu_work_cond);<BR>&nbsp;&nbsp;&nbsp; qemu_cond_init(&amp;qemu_io_proceeded_cond);<BR>&nbsp;&nbsp;&nbsp; qemu_mutex_init(&amp;qemu_global_mutex);</P>
<P>&nbsp;&nbsp;&nbsp; qemu_thread_get_self(&amp;io_thread);<BR>}</P>
<P>void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)<BR>{<BR>&nbsp;&nbsp;&nbsp; struct qemu_work_item wi;</P>
<P>&nbsp;&nbsp;&nbsp; if (qemu_cpu_is_self(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func(data);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; wi.func = func;<BR>&nbsp;&nbsp;&nbsp; wi.data = data;<BR>&nbsp;&nbsp;&nbsp; wi.free = false;</P>
<P>&nbsp;&nbsp;&nbsp; qemu_mutex_lock(&amp;cpu-&gt;work_mutex);<BR>&nbsp;&nbsp;&nbsp; if (cpu-&gt;queued_work_first == NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;queued_work_first = &amp;wi;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;queued_work_last-&gt;next = &amp;wi;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;queued_work_last = &amp;wi;<BR>&nbsp;&nbsp;&nbsp; wi.next = NULL;<BR>&nbsp;&nbsp;&nbsp; wi.done = false;<BR>&nbsp;&nbsp;&nbsp; qemu_mutex_unlock(&amp;cpu-&gt;work_mutex);</P>
<P>&nbsp;&nbsp;&nbsp; qemu_cpu_kick(cpu);<BR>&nbsp;&nbsp;&nbsp; while (!atomic_mb_read(&amp;wi.done)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUState *self_cpu = current_cpu;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cond_wait(&amp;qemu_work_cond, &amp;qemu_global_mutex);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_cpu = self_cpu;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void async_run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)<BR>{<BR>&nbsp;&nbsp;&nbsp; struct qemu_work_item *wi;</P>
<P>&nbsp;&nbsp;&nbsp; if (qemu_cpu_is_self(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; func(data);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; wi = g_malloc0(sizeof(struct qemu_work_item));<BR>&nbsp;&nbsp;&nbsp; wi-&gt;func = func;<BR>&nbsp;&nbsp;&nbsp; wi-&gt;data = data;<BR>&nbsp;&nbsp;&nbsp; wi-&gt;free = true;</P>
<P>&nbsp;&nbsp;&nbsp; qemu_mutex_lock(&amp;cpu-&gt;work_mutex);<BR>&nbsp;&nbsp;&nbsp; if (cpu-&gt;queued_work_first == NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;queued_work_first = wi;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;queued_work_last-&gt;next = wi;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;queued_work_last = wi;<BR>&nbsp;&nbsp;&nbsp; wi-&gt;next = NULL;<BR>&nbsp;&nbsp;&nbsp; wi-&gt;done = false;<BR>&nbsp;&nbsp;&nbsp; qemu_mutex_unlock(&amp;cpu-&gt;work_mutex);</P>
<P>&nbsp;&nbsp;&nbsp; qemu_cpu_kick(cpu);<BR>}</P>
<P>static void flush_queued_work(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; struct qemu_work_item *wi;</P>
<P>&nbsp;&nbsp;&nbsp; if (cpu-&gt;queued_work_first == NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; qemu_mutex_lock(&amp;cpu-&gt;work_mutex);<BR>&nbsp;&nbsp;&nbsp; while (cpu-&gt;queued_work_first != NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wi = cpu-&gt;queued_work_first;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;queued_work_first = wi-&gt;next;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!cpu-&gt;queued_work_first) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;queued_work_last = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_unlock(&amp;cpu-&gt;work_mutex);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wi-&gt;func(wi-&gt;data);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_lock(&amp;cpu-&gt;work_mutex);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (wi-&gt;free) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_free(wi);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomic_mb_set(&amp;wi-&gt;done, true);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; qemu_mutex_unlock(&amp;cpu-&gt;work_mutex);<BR>&nbsp;&nbsp;&nbsp; qemu_cond_broadcast(&amp;qemu_work_cond);<BR>}</P>
<P>static void qemu_wait_io_event_common(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (cpu-&gt;stop) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;stop = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;stopped = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cond_broadcast(&amp;qemu_pause_cond);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; flush_queued_work(cpu);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;thread_kicked = false;<BR>}</P>
<P>static void qemu_tcg_wait_io_event(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; while (all_cpu_threads_idle()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cond_wait(cpu-&gt;halt_cond, &amp;qemu_global_mutex);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; while (iothread_requesting_mutex) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cond_wait(&amp;qemu_io_proceeded_cond, &amp;qemu_global_mutex);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_wait_io_event_common(cpu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void qemu_kvm_wait_io_event(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; while (cpu_thread_is_idle(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cond_wait(cpu-&gt;halt_cond, &amp;qemu_global_mutex);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; qemu_kvm_eat_signals(cpu);<BR>&nbsp;&nbsp;&nbsp; qemu_wait_io_event_common(cpu);<BR>}</P>
<P>static void *qemu_kvm_cpu_thread_fn(void *arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu = arg;<BR>&nbsp;&nbsp;&nbsp; int r;</P>
<P>&nbsp;&nbsp;&nbsp; rcu_register_thread();</P>
<P>&nbsp;&nbsp;&nbsp; qemu_mutex_lock_iothread();<BR>&nbsp;&nbsp;&nbsp; qemu_thread_get_self(cpu-&gt;thread);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;thread_id = qemu_get_thread_id();<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;can_do_io = 1;<BR>&nbsp;&nbsp;&nbsp; current_cpu = cpu;</P>
<P>&nbsp;&nbsp;&nbsp; r = kvm_init_vcpu(cpu);<BR>&nbsp;&nbsp;&nbsp; if (r &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "kvm_init_vcpu failed: %s\n", strerror(-r));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; qemu_kvm_init_cpu_signals(cpu);</P>
<P>&nbsp;&nbsp;&nbsp; /* signal CPU creation */<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;created = true;<BR>&nbsp;&nbsp;&nbsp; qemu_cond_signal(&amp;qemu_cpu_cond);</P>
<P>&nbsp;&nbsp;&nbsp; while (1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cpu_can_run(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = kvm_cpu_exec(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r == EXCP_DEBUG) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_handle_guest_debug(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_kvm_wait_io_event(cpu);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return NULL;<BR>}</P>
<P>static void *qemu_dummy_cpu_thread_fn(void *arg)<BR>{<BR>#ifdef _WIN32<BR>&nbsp;&nbsp;&nbsp; fprintf(stderr, "qtest is not supported under Windows\n");<BR>&nbsp;&nbsp;&nbsp; exit(1);<BR>#else<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu = arg;<BR>&nbsp;&nbsp;&nbsp; sigset_t waitset;<BR>&nbsp;&nbsp;&nbsp; int r;</P>
<P>&nbsp;&nbsp;&nbsp; rcu_register_thread();</P>
<P>&nbsp;&nbsp;&nbsp; qemu_mutex_lock_iothread();<BR>&nbsp;&nbsp;&nbsp; qemu_thread_get_self(cpu-&gt;thread);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;thread_id = qemu_get_thread_id();<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;can_do_io = 1;</P>
<P>&nbsp;&nbsp;&nbsp; sigemptyset(&amp;waitset);<BR>&nbsp;&nbsp;&nbsp; sigaddset(&amp;waitset, SIG_IPI);</P>
<P>&nbsp;&nbsp;&nbsp; /* signal CPU creation */<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;created = true;<BR>&nbsp;&nbsp;&nbsp; qemu_cond_signal(&amp;qemu_cpu_cond);</P>
<P>&nbsp;&nbsp;&nbsp; current_cpu = cpu;<BR>&nbsp;&nbsp;&nbsp; while (1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_cpu = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_unlock_iothread();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sig;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = sigwait(&amp;waitset, &amp;sig);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } while (r == -1 &amp;&amp; (errno == EAGAIN || errno == EINTR));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r == -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("sigwait");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_lock_iothread();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_cpu = cpu;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_wait_io_event_common(cpu);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return NULL;<BR>#endif<BR>}</P>
<P>static void tcg_exec_all(void);</P>
<P>static void *qemu_tcg_cpu_thread_fn(void *arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu = arg;</P>
<P>&nbsp;&nbsp;&nbsp; rcu_register_thread();</P>
<P>&nbsp;&nbsp;&nbsp; qemu_mutex_lock_iothread();<BR>&nbsp;&nbsp;&nbsp; qemu_thread_get_self(cpu-&gt;thread);</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;thread_id = qemu_get_thread_id();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;created = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;can_do_io = 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; qemu_cond_signal(&amp;qemu_cpu_cond);</P>
<P>&nbsp;&nbsp;&nbsp; /* wait for initial kick-off after machine start */<BR>&nbsp;&nbsp;&nbsp; while (first_cpu-&gt;stopped) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cond_wait(first_cpu-&gt;halt_cond, &amp;qemu_global_mutex);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* process any pending work */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_wait_io_event_common(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* process any pending work */<BR>&nbsp;&nbsp;&nbsp; atomic_mb_set(&amp;exit_request, 1);</P>
<P>&nbsp;&nbsp;&nbsp; while (1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_exec_all();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (use_icount) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int64_t deadline = qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (deadline == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_clock_notify(QEMU_CLOCK_VIRTUAL);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_tcg_wait_io_event(QTAILQ_FIRST(&amp;cpus));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return NULL;<BR>}</P>
<P>static void qemu_cpu_kick_thread(CPUState *cpu)<BR>{<BR>#ifndef _WIN32<BR>&nbsp;&nbsp;&nbsp; int err;</P>
<P>&nbsp;&nbsp;&nbsp; if (cpu-&gt;thread_kicked) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;thread_kicked = true;<BR>&nbsp;&nbsp;&nbsp; err = pthread_kill(cpu-&gt;thread-&gt;thread, SIG_IPI);<BR>&nbsp;&nbsp;&nbsp; if (err) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "qemu:%s: %s", __func__, strerror(err));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>&nbsp;&nbsp;&nbsp; }<BR>#else /* _WIN32 */<BR>&nbsp;&nbsp;&nbsp; abort();<BR>#endif<BR>}</P>
<P>static void qemu_cpu_kick_no_halt(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;<BR>&nbsp;&nbsp;&nbsp; /* Ensure whatever caused the exit has reached the CPU threads before<BR>&nbsp;&nbsp;&nbsp;&nbsp; * writing exit_request.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; atomic_mb_set(&amp;exit_request, 1);<BR>&nbsp;&nbsp;&nbsp; cpu = atomic_mb_read(&amp;tcg_current_cpu);<BR>&nbsp;&nbsp;&nbsp; if (cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_exit(cpu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void qemu_cpu_kick(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; qemu_cond_broadcast(cpu-&gt;halt_cond);<BR>&nbsp;&nbsp;&nbsp; if (tcg_enabled()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cpu_kick_no_halt();<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cpu_kick_thread(cpu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void qemu_cpu_kick_self(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; assert(current_cpu);<BR>&nbsp;&nbsp;&nbsp; qemu_cpu_kick_thread(current_cpu);<BR>}</P>
<P>bool qemu_cpu_is_self(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; return qemu_thread_is_self(cpu-&gt;thread);<BR>}</P>
<P>bool qemu_in_vcpu_thread(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; return current_cpu &amp;&amp; qemu_cpu_is_self(current_cpu);<BR>}</P>
<P>static __thread bool iothread_locked = false;</P>
<P>bool qemu_mutex_iothread_locked(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; return iothread_locked;<BR>}</P>
<P>void qemu_mutex_lock_iothread(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; atomic_inc(&amp;iothread_requesting_mutex);<BR>&nbsp;&nbsp;&nbsp; /* In the simple case there is no need to bump the VCPU thread out of<BR>&nbsp;&nbsp;&nbsp;&nbsp; * TCG code execution.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!tcg_enabled() || qemu_in_vcpu_thread() ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !first_cpu || !first_cpu-&gt;created) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_lock(&amp;qemu_global_mutex);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomic_dec(&amp;iothread_requesting_mutex);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (qemu_mutex_trylock(&amp;qemu_global_mutex)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cpu_kick_no_halt();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_lock(&amp;qemu_global_mutex);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atomic_dec(&amp;iothread_requesting_mutex);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cond_broadcast(&amp;qemu_io_proceeded_cond);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; iothread_locked = true;<BR>}</P>
<P>void qemu_mutex_unlock_iothread(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; iothread_locked = false;<BR>&nbsp;&nbsp;&nbsp; qemu_mutex_unlock(&amp;qemu_global_mutex);<BR>}</P>
<P>static int all_vcpus_paused(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!cpu-&gt;stopped) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return 1;<BR>}</P>
<P>void pause_all_vcpus(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;</P>
<P>&nbsp;&nbsp;&nbsp; qemu_clock_enable(QEMU_CLOCK_VIRTUAL, false);<BR>&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;stop = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cpu_kick(cpu);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (qemu_in_vcpu_thread()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_stop_current();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!kvm_enabled()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;stop = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;stopped = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; while (!all_vcpus_paused()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cond_wait(&amp;qemu_pause_cond, &amp;qemu_global_mutex);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cpu_kick(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void cpu_resume(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;stop = false;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;stopped = false;<BR>&nbsp;&nbsp;&nbsp; qemu_cpu_kick(cpu);<BR>}</P>
<P>void resume_all_vcpus(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;</P>
<P>&nbsp;&nbsp;&nbsp; qemu_clock_enable(QEMU_CLOCK_VIRTUAL, true);<BR>&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_resume(cpu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* For temporary buffers for forming a name */<BR>#define VCPU_THREAD_NAME_SIZE 16</P>
<P>static void qemu_tcg_init_vcpu(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; char thread_name[VCPU_THREAD_NAME_SIZE];<BR>&nbsp;&nbsp;&nbsp; static QemuCond *tcg_halt_cond;<BR>&nbsp;&nbsp;&nbsp; static QemuThread *tcg_cpu_thread;</P>
<P>&nbsp;&nbsp;&nbsp; /* share a single thread for all cpus with TCG */<BR>&nbsp;&nbsp;&nbsp; if (!tcg_cpu_thread) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;thread = g_malloc0(sizeof(QemuThread));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;halt_cond = g_malloc0(sizeof(QemuCond));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cond_init(cpu-&gt;halt_cond);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_halt_cond = cpu-&gt;halt_cond;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; snprintf(thread_name, VCPU_THREAD_NAME_SIZE, "CPU %d/TCG",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;cpu_index);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_thread_create(cpu-&gt;thread, thread_name, qemu_tcg_cpu_thread_fn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu, QEMU_THREAD_JOINABLE);<BR>#ifdef _WIN32<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;hThread = qemu_thread_get_handle(cpu-&gt;thread);<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (!cpu-&gt;created) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cond_wait(&amp;qemu_cpu_cond, &amp;qemu_global_mutex);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_cpu_thread = cpu-&gt;thread;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;thread = tcg_cpu_thread;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;halt_cond = tcg_halt_cond;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void qemu_kvm_start_vcpu(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; char thread_name[VCPU_THREAD_NAME_SIZE];</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;thread = g_malloc0(sizeof(QemuThread));<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;halt_cond = g_malloc0(sizeof(QemuCond));<BR>&nbsp;&nbsp;&nbsp; qemu_cond_init(cpu-&gt;halt_cond);<BR>&nbsp;&nbsp;&nbsp; snprintf(thread_name, VCPU_THREAD_NAME_SIZE, "CPU %d/KVM",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;cpu_index);<BR>&nbsp;&nbsp;&nbsp; qemu_thread_create(cpu-&gt;thread, thread_name, qemu_kvm_cpu_thread_fn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu, QEMU_THREAD_JOINABLE);<BR>&nbsp;&nbsp;&nbsp; while (!cpu-&gt;created) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cond_wait(&amp;qemu_cpu_cond, &amp;qemu_global_mutex);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void qemu_dummy_start_vcpu(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; char thread_name[VCPU_THREAD_NAME_SIZE];</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;thread = g_malloc0(sizeof(QemuThread));<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;halt_cond = g_malloc0(sizeof(QemuCond));<BR>&nbsp;&nbsp;&nbsp; qemu_cond_init(cpu-&gt;halt_cond);<BR>&nbsp;&nbsp;&nbsp; snprintf(thread_name, VCPU_THREAD_NAME_SIZE, "CPU %d/DUMMY",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;cpu_index);<BR>&nbsp;&nbsp;&nbsp; qemu_thread_create(cpu-&gt;thread, thread_name, qemu_dummy_cpu_thread_fn, cpu,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QEMU_THREAD_JOINABLE);<BR>&nbsp;&nbsp;&nbsp; while (!cpu-&gt;created) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cond_wait(&amp;qemu_cpu_cond, &amp;qemu_global_mutex);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void qemu_init_vcpu(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;nr_cores = smp_cores;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;nr_threads = smp_threads;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;stopped = true;</P>
<P>&nbsp;&nbsp;&nbsp; if (!cpu-&gt;as) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If the target cpu hasn't set up any address spaces itself,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * give it the default one.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddressSpace *as = address_space_init_shareable(cpu-&gt;memory,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "cpu-memory");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;num_ases = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_address_space_init(cpu, as, 0);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (kvm_enabled()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_kvm_start_vcpu(cpu);<BR>&nbsp;&nbsp;&nbsp; } else if (tcg_enabled()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_tcg_init_vcpu(cpu);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_dummy_start_vcpu(cpu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void cpu_stop_current(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (current_cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_cpu-&gt;stop = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_cpu-&gt;stopped = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_exit(current_cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_cond_broadcast(&amp;qemu_pause_cond);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>int vm_stop(RunState state)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (qemu_in_vcpu_thread()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_system_vmstop_request_prepare();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_system_vmstop_request(state);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * FIXME: should not return to device code in case<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * vm_stop() has been requested.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_stop_current();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return do_vm_stop(state);<BR>}</P>
<P>/* does a state transition even if the VM is already stopped,<BR>&nbsp;&nbsp; current state is forgotten forever */<BR>int vm_stop_force_state(RunState state)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (runstate_is_running()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return vm_stop(state);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; runstate_set(state);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bdrv_drain_all();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Make sure to return an error if the flush in a previous vm_stop()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * failed. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return bdrv_flush_all();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static int64_t tcg_get_icount_limit(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; int64_t deadline;</P>
<P>&nbsp;&nbsp;&nbsp; if (replay_mode != REPLAY_MODE_PLAY) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deadline = qemu_clock_deadline_ns_all(QEMU_CLOCK_VIRTUAL);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Maintain prior (possibly buggy) behaviour where if no deadline<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * was set (as there is no QEMU_CLOCK_VIRTUAL timer) or it is more than<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * INT32_MAX nanoseconds ahead, we still use INT32_MAX<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * nanoseconds.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((deadline &lt; 0) || (deadline &gt; INT32_MAX)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deadline = INT32_MAX;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return qemu_icount_round(deadline);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return replay_get_instructions();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P><FONT class=extract>static int tcg_cpu_exec(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; int ret;<BR>#ifdef CONFIG_PROFILER<BR>&nbsp;&nbsp;&nbsp; int64_t ti;<BR>#endif</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_PROFILER<BR>&nbsp;&nbsp;&nbsp; ti = profile_getclock();<BR>#endif<BR>&nbsp;&nbsp;&nbsp; if (use_icount) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int64_t count;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int decr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timers_state.qemu_icount -= (cpu-&gt;icount_decr.u16.low<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + cpu-&gt;icount_extra);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;icount_decr.u16.low = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;icount_extra = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = tcg_get_icount_limit();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timers_state.qemu_icount += count;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decr = (count &gt; 0xffff) ? 0xffff : count;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count -= decr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;icount_decr.u16.low = decr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;icount_extra = count;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; ret = cpu_exec(cpu);<BR>#ifdef CONFIG_PROFILER<BR>&nbsp;&nbsp;&nbsp; tcg_time += profile_getclock() - ti;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; if (use_icount) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Fold pending instructions back into the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instruction counter, and clear the interrupt flag.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timers_state.qemu_icount -= (cpu-&gt;icount_decr.u16.low<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + cpu-&gt;icount_extra);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;icount_decr.u32 = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;icount_extra = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replay_account_executed_instructions();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return ret;<BR>}</FONT></P>
<P><FONT class=extract>static void tcg_exec_all(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; int r;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Account partial waits to QEMU_CLOCK_VIRTUAL.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; qemu_account_warp_timer();</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (next_cpu == NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next_cpu = first_cpu;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; for (; next_cpu != NULL &amp;&amp; !exit_request; next_cpu = CPU_NEXT(next_cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUState *cpu = next_cpu;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_clock_enable(QEMU_CLOCK_VIRTUAL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (cpu-&gt;singlestep_enabled &amp; SSTEP_NOTIMER) == 0);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cpu_can_run(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = tcg_cpu_exec(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r == EXCP_DEBUG) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_handle_guest_debug(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (cpu-&gt;stop || cpu-&gt;stopped) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Pairs with smp_wmb in qemu_cpu_kick.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; atomic_mb_set(&amp;exit_request, 0);<BR>}</FONT></P>
<P>void list_cpus(FILE *f, fprintf_function cpu_fprintf, const char *optarg)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* XXX: implement xxx_cpu_list for targets that still miss it */<BR>#if defined(cpu_list)<BR>&nbsp;&nbsp;&nbsp; cpu_list(f, cpu_fprintf);<BR>#endif<BR>}</P>
<P>CpuInfoList *qmp_query_cpus(Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; CpuInfoList *head = NULL, *cur_item = NULL;<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CpuInfoList *info;<BR>#if defined(TARGET_I386)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86CPU *x86_cpu = X86_CPU(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUX86State *env = &amp;x86_cpu-&gt;env;<BR>#elif defined(TARGET_PPC)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PowerPCCPU *ppc_cpu = POWERPC_CPU(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUPPCState *env = &amp;ppc_cpu-&gt;env;<BR>#elif defined(TARGET_SPARC)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPARCCPU *sparc_cpu = SPARC_CPU(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUSPARCState *env = &amp;sparc_cpu-&gt;env;<BR>#elif defined(TARGET_MIPS)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MIPSCPU *mips_cpu = MIPS_CPU(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUMIPSState *env = &amp;mips_cpu-&gt;env;<BR>#elif defined(TARGET_TRICORE)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TriCoreCPU *tricore_cpu = TRICORE_CPU(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUTriCoreState *env = &amp;tricore_cpu-&gt;env;<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_synchronize_state(cpu);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info = g_malloc0(sizeof(*info));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value = g_malloc0(sizeof(*info-&gt;value));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;CPU = cpu-&gt;cpu_index;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;current = (cpu == first_cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;halted = cpu-&gt;halted;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;qom_path = object_get_canonical_path(OBJECT(cpu));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;thread_id = cpu-&gt;thread_id;<BR>#if defined(TARGET_I386)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;arch = CPU_INFO_ARCH_X86;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;u.x86.pc = env-&gt;eip + env-&gt;segs[R_CS].base;<BR>#elif defined(TARGET_PPC)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;arch = CPU_INFO_ARCH_PPC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;u.ppc.nip = env-&gt;nip;<BR>#elif defined(TARGET_SPARC)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;arch = CPU_INFO_ARCH_SPARC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;u.q_sparc.pc = env-&gt;pc;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;u.q_sparc.npc = env-&gt;npc;<BR>#elif defined(TARGET_MIPS)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;arch = CPU_INFO_ARCH_MIPS;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;u.q_mips.PC = env-&gt;active_tc.PC;<BR>#elif defined(TARGET_TRICORE)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;arch = CPU_INFO_ARCH_TRICORE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;u.tricore.PC = env-&gt;PC;<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;value-&gt;arch = CPU_INFO_ARCH_OTHER;<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* XXX: waiting for the qapi to support GSList */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!cur_item) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head = cur_item = info;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur_item-&gt;next = info;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur_item = info;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return head;<BR>}</P>
<P>void qmp_memsave(int64_t addr, int64_t size, const char *filename,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool has_cpu, int64_t cpu_index, Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; FILE *f;<BR>&nbsp;&nbsp;&nbsp; uint32_t l;<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;<BR>&nbsp;&nbsp;&nbsp; uint8_t buf[1024];<BR>&nbsp;&nbsp;&nbsp; int64_t orig_addr = addr, orig_size = size;</P>
<P>&nbsp;&nbsp;&nbsp; if (!has_cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_index = 0;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cpu = qemu_get_cpu(cpu_index);<BR>&nbsp;&nbsp;&nbsp; if (cpu == NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, QERR_INVALID_PARAMETER_VALUE, "cpu-index",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "a CPU number");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; f = fopen(filename, "wb");<BR>&nbsp;&nbsp;&nbsp; if (!f) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg_file_open(errp, errno, filename);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; while (size != 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = sizeof(buf);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (l &gt; size)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = size;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cpu_memory_rw_debug(cpu, addr, buf, l, 0) != 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "Invalid addr 0x%016" PRIx64 "/size %" PRId64<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " specified", orig_addr, orig_size);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto exit;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fwrite(buf, 1, l, f) != l) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, QERR_IO_ERROR);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto exit;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr += l;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size -= l;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>exit:<BR>&nbsp;&nbsp;&nbsp; fclose(f);<BR>}</P>
<P>void qmp_pmemsave(int64_t addr, int64_t size, const char *filename,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; FILE *f;<BR>&nbsp;&nbsp;&nbsp; uint32_t l;<BR>&nbsp;&nbsp;&nbsp; uint8_t buf[1024];</P>
<P>&nbsp;&nbsp;&nbsp; f = fopen(filename, "wb");<BR>&nbsp;&nbsp;&nbsp; if (!f) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg_file_open(errp, errno, filename);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; while (size != 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = sizeof(buf);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (l &gt; size)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = size;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_physical_memory_read(addr, buf, l);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fwrite(buf, 1, l, f) != l) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, QERR_IO_ERROR);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto exit;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr += l;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size -= l;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>exit:<BR>&nbsp;&nbsp;&nbsp; fclose(f);<BR>}</P>
<P>void qmp_inject_nmi(Error **errp)<BR>{<BR>#if defined(TARGET_I386)<BR>&nbsp;&nbsp;&nbsp; CPUState *cs;</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86CPU *cpu = X86_CPU(cs);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!cpu-&gt;apic_state) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_interrupt(cs, CPU_INTERRUPT_NMI);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; apic_deliver_nmi(cpu-&gt;apic_state);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>#else<BR>&nbsp;&nbsp;&nbsp; nmi_monitor_handle(monitor_get_cpu_index(), errp);<BR>#endif<BR>}</P>
<P>void dump_drift_info(FILE *f, fprintf_function cpu_fprintf)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (!use_icount) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cpu_fprintf(f, "Host - Guest clock&nbsp; %"PRIi64" ms\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (cpu_get_clock() - cpu_get_icount())/SCALE_MS);<BR>&nbsp;&nbsp;&nbsp; if (icount_align_option) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_fprintf(f, "Max guest delay&nbsp;&nbsp;&nbsp;&nbsp; %"PRIi64" ms\n", -max_delay/SCALE_MS);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_fprintf(f, "Max guest advance&nbsp;&nbsp; %"PRIi64" ms\n", max_advance/SCALE_MS);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_fprintf(f, "Max guest delay&nbsp;&nbsp;&nbsp;&nbsp; NA\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_fprintf(f, "Max guest advance&nbsp;&nbsp; NA\n");<BR>&nbsp;&nbsp;&nbsp; }<BR>}