B2.2.4 Aligned memory accesses 
<P></P>
<P>The MemA[] function performs a memory access at the current privilege level, and the MemA_unpriv[] function performs an access that is always unprivileged. In both cases the architecture requires the access to be aligned, and generates an Alignment fault if it is not.</P>
<P>// MemA[]<BR>// ======</P>
<P>bits(8*size) MemA[bits(32) address, integer size]<BR>&nbsp;&nbsp;&nbsp; return MemA_with_priv[address, size, FindPriv()];<BR>&nbsp;&nbsp;&nbsp; <BR>MemA[bits(32) address, integer size] = bits(8*size) value<BR>&nbsp;&nbsp;&nbsp; MemA_with_priv[address, size, FindPriv()] = value;<BR>&nbsp;&nbsp;&nbsp; return;</P>
<P>// MemA_unpriv[]<BR>// =============</P>
<P>bits(8*size) MemA_unpriv[bits(32) address, integer size]<BR>&nbsp;&nbsp;&nbsp; return MemA_with_priv[address, size, FALSE];<BR>&nbsp;&nbsp;&nbsp; <BR>MemA_unpriv[bits(32) address, integer size] = bits(8*size) value<BR>&nbsp;&nbsp;&nbsp; MemA_with_priv[address, size, FALSE] = value;<BR>&nbsp;&nbsp;&nbsp; return;</P>
<P>// MemA_with_priv[]<BR>// ================</P>
<P><FONT class=extract>// Non-assignment form<BR>bits(8*size) MemA_with_priv[bits(32) address, integer size, boolean privileged]</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; // Sort out alignment<BR>&nbsp;&nbsp;&nbsp; if address != Align(address, size) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.UNALIGNED = &#8217;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; // default address map or MPU<BR>&nbsp;&nbsp;&nbsp; memaddrdesc = ValidateAddress(address, privileged, FALSE, FALSE);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; // Memory array access, and sort out endianness<BR>&nbsp;&nbsp;&nbsp; value = _Mem[memaddrdesc, size];<BR>&nbsp;&nbsp;&nbsp; if AIRCR.ENDIANNESS == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = BigEndianReverse(value, size);<BR>&nbsp;&nbsp;&nbsp; return value;</FONT></P>
<P><FONT class=extract>// Assignment form<BR>MemA_with_priv[bits(32) address, integer size, boolean privileged] = bits(8*size) value</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; // Sort out alignment<BR>&nbsp;&nbsp;&nbsp; if address != Align(address, size) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.UNALIGNED = &#8217;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // default address map or MPU<BR>&nbsp;&nbsp;&nbsp; memaddrdesc = ValidateAddress(address, privileged, TRUE, FALSE);<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // Effect on exclusives<BR>&nbsp;&nbsp;&nbsp; if memaddrdesc.memattrs.shareable then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearExclusiveByAddress(memaddrdesc.physicaladdress, ProcessorID(), size);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // Sort out endianness, then memory array access<BR>&nbsp;&nbsp;&nbsp; if AIRCR.ENDIANNESS == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = BigEndianReverse(value, size);<BR>&nbsp;&nbsp;&nbsp; _Mem[memaddrdesc,size] = value;<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; return;</FONT>