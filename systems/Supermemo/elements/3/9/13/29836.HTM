B2.2.5 Unaligned memory accesses</P>
<P>The MemU[] function performs a memory access at the current privilege level, and the MemU_unpriv[] function performs an access that is always unprivileged.<BR>In both cases:<BR>&#8226; if the CCR.UNALIGN_TRP bit is 0, unaligned accesses are supported<BR>&#8226; if the CCR.UNALIGN_TRP bit is 1, unaligned accesses produce Alignment faults.</P>
<P>// MemU[]<BR>// ======</P>
<P>bits(8*size) MemU[bits(32) address, integer size]<BR>&nbsp;&nbsp;&nbsp; return MemU_with_priv[address, size, FindPriv()];<BR>&nbsp;&nbsp;&nbsp; <BR>MemU[bits(32) address, integer size] = bits(8*size) value<BR>&nbsp;&nbsp;&nbsp; MemU_with_priv[address, size, FindPriv()] = value;<BR>&nbsp;&nbsp;&nbsp; return;</P>
<P>// MemU_unpriv[]<BR>// =============</P>
<P>bits(8*size) MemU_unpriv[bits(32) address, integer size]<BR>&nbsp;&nbsp;&nbsp; return MemU_with_priv[address, size, FALSE];<BR>&nbsp;&nbsp;&nbsp; <BR>MemU_unpriv[bits(32) address, integer size] = bits(8*size) value<BR>&nbsp;&nbsp;&nbsp; MemU_with_priv[address, size, FALSE] = value;<BR>&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; <BR>// MemU_with_priv[]<BR>// ================<BR>//<BR>// Due to single-copy atomicity constraints, the aligned accesses are distinguished from<BR>// the unaligned accesses:<BR>// * aligned accesses are performed at their size<BR>// * unaligned accesses are expressed as a set of bytes.</P>
<P>// Non-assignment form</P>
<P>bits(8*size) MemU_with_priv[bits(32) address, integer size, boolean privileged]</P>
<P>&nbsp;&nbsp;&nbsp; bits(8*size) value;<BR>&nbsp;&nbsp;&nbsp; // Do aligned access, take alignment fault, or do sequence of bytes<BR>&nbsp;&nbsp;&nbsp; if address == Align(address, size) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = MemA_with_priv[address, size, privileged];<BR>&nbsp;&nbsp;&nbsp; elsif CCR.UNALIGN_TRP == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.UNALIGNED = &#8217;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault);<BR>&nbsp;&nbsp;&nbsp; else // if unaligned access<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i = 0 to size-1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value&lt;8*i+7:8*i&gt; = MemA_with_priv[address+i, 1, privileged];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if AIRCR.ENDIANNESS == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = BigEndianReverse(value, size);<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; return value;</P>
<P>// Assignment form</P>
<P>MemU_with_priv[bits(32) address, integer size, boolean privileged] = bits(8*size) value</P>
<P>&nbsp;&nbsp;&nbsp; // Do aligned access, take alignment fault, or do sequence of bytes<BR>&nbsp;&nbsp;&nbsp; if address == Align(address, size) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemA_with_priv[address, value, privileged] = value;<BR>&nbsp;&nbsp;&nbsp; elsif CCR.UNALIGN_TRP == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.UNALIGNED = &#8217;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault);<BR>&nbsp;&nbsp;&nbsp; else // if unaligned access<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if AIRCR.ENDIANNESS == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = BigEndianReverse(value, size);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i = 0 to size-1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemA_with_priv[address+i, 1, privileged] = value&lt;8*i+7:8*i&gt;;<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; return;