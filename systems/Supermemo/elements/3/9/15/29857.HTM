ExclusiveMonitorsPass
<P></P>
<P>// ExclusiveMonitorsPass()<BR>// =======================</P>
<P>boolean ExclusiveMonitorsPass(bits(32) address, integer size)</P>
<P>&nbsp;&nbsp;&nbsp; // It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens<BR>&nbsp;&nbsp;&nbsp; // before or after the check on the local Exclusive Monitor. As a result a failure<BR>&nbsp;&nbsp;&nbsp; // of the local monitor can occur on some implementations even if the memory<BR>&nbsp;&nbsp;&nbsp; // access would give a memory abort.<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; if address != Align(address, size) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.UNALIGNED = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault);<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memaddrdesc = ValidateAddress(address, FindPriv(), TRUE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; passed = IsExclusiveLocal(memaddrdesc.physicaladdress, ProcessorID(), size);<BR>&nbsp;&nbsp;&nbsp; if memaddrdesc.memattrs.shareable then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; passed = passed &amp;&amp; IsExclusiveGlobal(memaddrdesc.physicaladdress, ProcessorID(), size);<BR>&nbsp;&nbsp;&nbsp; if passed then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearExclusiveLocal(ProcessorID());<BR>&nbsp;&nbsp;&nbsp; return passed;