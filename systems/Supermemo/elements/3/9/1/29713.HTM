/*<BR>&nbsp;* Because this function is inlined, the 'state' parameter will be<BR>&nbsp;* constant, and thus optimised away by the compiler.&nbsp; Likewise the<BR>&nbsp;* 'timeout' parameter for the cases without timeouts.<BR>&nbsp;*/<BR>static inline int __sched __down_common(struct semaphore *sem, long state,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long timeout)<BR>{<BR>&nbsp;struct task_struct *task = current;<BR>&nbsp;struct semaphore_waiter waiter;</P>
<P>&nbsp;list_add_tail(&amp;waiter.list, &amp;sem-&gt;wait_list);<BR>&nbsp;waiter.task = task;<BR>&nbsp;waiter.up = false;</P>
<P>&nbsp;for (;;) {<BR>&nbsp;&nbsp;if (signal_pending_state(state, task))<BR>&nbsp;&nbsp;&nbsp;goto interrupted;<BR>&nbsp;&nbsp;if (unlikely(timeout &lt;= 0))<BR>&nbsp;&nbsp;&nbsp;goto timed_out;<BR>&nbsp;&nbsp;__set_task_state(task, state);<BR>&nbsp;&nbsp;raw_spin_unlock_irq(&amp;sem-&gt;lock);<BR>&nbsp;&nbsp;timeout = schedule_timeout(timeout);<BR>&nbsp;&nbsp;raw_spin_lock_irq(&amp;sem-&gt;lock);<BR>&nbsp;&nbsp;if (waiter.up)<BR>&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;}</P>
<P>&nbsp;timed_out:<BR>&nbsp;list_del(&amp;waiter.list);<BR>&nbsp;return -ETIME;</P>
<P>&nbsp;interrupted:<BR>&nbsp;list_del(&amp;waiter.list);<BR>&nbsp;return -EINTR;<BR>}