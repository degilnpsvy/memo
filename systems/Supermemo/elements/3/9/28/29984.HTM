<H5 class=subsubsection>6.44.3.4 Constraints for Particular Machines</H5>
<P><A name=index-machine-specific-constraints-3702></A><A name=index-constraints_002c-machine-specific-3703></A>Whenever possible, you should use the general-purpose constraint letters in <CODE>asm</CODE> arguments, since they will convey meaning more readily to people reading your code. Failing that, use the constraint letters that usually have very similar meanings across architectures. The most commonly used constraints are &#8216;<SAMP><SPAN class=samp>m</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>r</SPAN></SAMP>&#8217; (for memory and general-purpose registers respectively; see <A href="https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints">Simple Constraints</A>), and &#8216;<SAMP><SPAN class=samp>I</SPAN></SAMP>&#8217;, usually the letter indicating the most common immediate-constant format. </P>
<P>Each architecture defines additional constraints. These constraints are used by the compiler itself for instruction generation, as well as for <CODE>asm</CODE> statements; therefore, some of the constraints are not particularly useful for <CODE>asm</CODE>. Here is a summary of some of the machine-dependent constraints available on some particular machines; it includes both constraints that are useful for <CODE>asm</CODE> and constraints that aren't. The compiler source file mentioned in the table heading for each architecture is the definitive reference for the meanings of that architecture's constraints. </P>
<DL>
<DT><EM>AArch64 family&#8212;</EM><SAMP><SPAN class=file>config/aarch64/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>k</CODE></DT>
<DD>The stack pointer register (<CODE>SP</CODE>) <BR></DD>
<DT><CODE>w</CODE></DT>
<DD>Floating point or SIMD vector register <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>Integer constant that is valid as an immediate operand in an <CODE>ADD</CODE> instruction <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Integer constant that is valid as an immediate operand in a <CODE>SUB</CODE> instruction (once negated) <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Integer constant that can be used with a 32-bit logical instruction <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Integer constant that can be used with a 64-bit logical instruction <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>Integer constant that is valid as an immediate operand in a 32-bit <CODE>MOV</CODE> pseudo instruction. The <CODE>MOV</CODE> may be assembled to one of several different machine instructions depending on the value <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>Integer constant that is valid as an immediate operand in a 64-bit <CODE>MOV</CODE> pseudo instruction <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>An absolute symbolic address or a label reference <BR></DD>
<DT><CODE>Y</CODE></DT>
<DD>Floating point constant zero <BR></DD>
<DT><CODE>Z</CODE></DT>
<DD>Integer constant zero <BR></DD>
<DT><CODE>Ush</CODE></DT>
<DD>The high part (bits 12 and upwards) of the pc-relative address of a symbol within 4GB of the instruction <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>A memory address which uses a single base register with no offset <BR></DD>
<DT><CODE>Ump</CODE></DT>
<DD>A memory address suitable for a load/store pair instruction in SI, DI, SF and DF modes </DD></DL><BR></DD>
<DT><EM>ARC &#8212;</EM><SAMP><SPAN class=file>config/arc/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>q</CODE></DT>
<DD>Registers usable in ARCompact 16-bit instructions: <CODE>r0</CODE>-<CODE>r3</CODE>, <CODE>r12</CODE>-<CODE>r15</CODE>. This constraint can only match when the <SAMP><SPAN class=option>-mq</SPAN></SAMP> option is in effect. <BR></DD>
<DT><CODE>e</CODE></DT>
<DD>Registers usable as base-regs of memory addresses in ARCompact 16-bit memory instructions: <CODE>r0</CODE>-<CODE>r3</CODE>, <CODE>r12</CODE>-<CODE>r15</CODE>, <CODE>sp</CODE>. This constraint can only match when the <SAMP><SPAN class=option>-mq</SPAN></SAMP> option is in effect. <BR></DD>
<DT><CODE>D</CODE></DT>
<DD>ARC FPX (dpfp) 64-bit registers. <CODE>D0</CODE>, <CODE>D1</CODE>. <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>A signed 12-bit integer constant. <BR></DD>
<DT><CODE>Cal</CODE></DT>
<DD>constant for arithmetic/logical operations. This might be any constant that can be put into a long immediate by the assmbler or linker without involving a PIC relocation. <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>A 3-bit unsigned integer constant. <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>A 6-bit unsigned integer constant. <BR></DD>
<DT><CODE>CnL</CODE></DT>
<DD>One's complement of a 6-bit unsigned integer constant. <BR></DD>
<DT><CODE>CmL</CODE></DT>
<DD>Two's complement of a 6-bit unsigned integer constant. <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>A 5-bit unsigned integer constant. <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>A 7-bit unsigned integer constant. <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>A 8-bit unsigned integer constant. <BR></DD>
<DT><CODE>H</CODE></DT>
<DD>Any const_double value. </DD></DL><BR></DD>
<DT><EM>ARM family&#8212;</EM><SAMP><SPAN class=file>config/arm/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>h</CODE></DT>
<DD>In Thumb state, the core registers <CODE>r8</CODE>-<CODE>r15</CODE>. <BR></DD>
<DT><CODE>k</CODE></DT>
<DD>The stack pointer register. <BR></DD>
<DT><CODE>l</CODE></DT>
<DD>In Thumb State the core registers <CODE>r0</CODE>-<CODE>r7</CODE>. In ARM state this is an alias for the <CODE>r</CODE> constraint. <BR></DD>
<DT><CODE>t</CODE></DT>
<DD>VFP floating-point registers <CODE>s0</CODE>-<CODE>s31</CODE>. Used for 32 bit values. <BR></DD>
<DT><CODE>w</CODE></DT>
<DD>VFP floating-point registers <CODE>d0</CODE>-<CODE>d31</CODE> and the appropriate subset <CODE>d0</CODE>-<CODE>d15</CODE> based on command line options. Used for 64 bit values only. Not valid for Thumb1. <BR></DD>
<DT><CODE>y</CODE></DT>
<DD>The iWMMX co-processor registers. <BR></DD>
<DT><CODE>z</CODE></DT>
<DD>The iWMMX GR registers. <BR></DD>
<DT><CODE>G</CODE></DT>
<DD>The floating-point constant 0.0 <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>Integer that is valid as an immediate operand in a data processing instruction. That is, an integer in the range 0 to 255 rotated by a multiple of 2 <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Integer in the range &#8722;4095 to 4095 <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Integer that satisfies constraint &#8216;<SAMP><SPAN class=samp>I</SPAN></SAMP>&#8217; when inverted (ones complement) <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Integer that satisfies constraint &#8216;<SAMP><SPAN class=samp>I</SPAN></SAMP>&#8217; when negated (twos complement) <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>Integer in the range 0 to 32 <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>A memory reference where the exact address is in a single register (`&#8216;<SAMP><SPAN class=samp>m</SPAN></SAMP>&#8217;' is preferable for <CODE>asm</CODE> statements) <BR></DD>
<DT><CODE>R</CODE></DT>
<DD>An item in the constant pool <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>A symbol in the text segment of the current file <BR></DD>
<DT><CODE>Uv</CODE></DT>
<DD>A memory reference suitable for VFP load/store insns (reg+constant offset) <BR></DD>
<DT><CODE>Uy</CODE></DT>
<DD>A memory reference suitable for iWMMXt load/store instructions. <BR></DD>
<DT><CODE>Uq</CODE></DT>
<DD>A memory reference suitable for the ARMv4 ldrsb instruction. </DD></DL><BR></DD>
<DT><EM>AVR family&#8212;</EM><SAMP><SPAN class=file>config/avr/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>l</CODE></DT>
<DD>Registers from r0 to r15 <BR></DD>
<DT><CODE>a</CODE></DT>
<DD>Registers from r16 to r23 <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>Registers from r16 to r31 <BR></DD>
<DT><CODE>w</CODE></DT>
<DD>Registers from r24 to r31. These registers can be used in &#8216;<SAMP><SPAN class=samp>adiw</SPAN></SAMP>&#8217; command <BR></DD>
<DT><CODE>e</CODE></DT>
<DD>Pointer register (r26&#8211;r31) <BR></DD>
<DT><CODE>b</CODE></DT>
<DD>Base pointer register (r28&#8211;r31) <BR></DD>
<DT><CODE>q</CODE></DT>
<DD>Stack pointer register (SPH:SPL) <BR></DD>
<DT><CODE>t</CODE></DT>
<DD>Temporary register r0 <BR></DD>
<DT><CODE>x</CODE></DT>
<DD>Register pair X (r27:r26) <BR></DD>
<DT><CODE>y</CODE></DT>
<DD>Register pair Y (r29:r28) <BR></DD>
<DT><CODE>z</CODE></DT>
<DD>Register pair Z (r31:r30) <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>Constant greater than &#8722;1, less than 64 <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Constant greater than &#8722;64, less than 1 <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Constant integer 2 <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Constant integer 0 <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>Constant that fits in 8 bits <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>Constant integer &#8722;1 <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>Constant integer 8, 16, or 24 <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>Constant integer 1 <BR></DD>
<DT><CODE>G</CODE></DT>
<DD>A floating point constant 0.0 <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>A memory address based on Y or Z pointer with displacement. </DD></DL><BR></DD>
<DT><EM>Blackfin family&#8212;</EM><SAMP><SPAN class=file>config/bfin/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>a</CODE></DT>
<DD>P register <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>D register <BR></DD>
<DT><CODE>z</CODE></DT>
<DD>A call clobbered P register. <BR></DD>
<DT><CODE>q</CODE><VAR>n</VAR></DT>
<DD>A single register. If <VAR>n</VAR> is in the range 0 to 7, the corresponding D register. If it is <CODE>A</CODE>, then the register P0. <BR></DD>
<DT><CODE>D</CODE></DT>
<DD>Even-numbered D register <BR></DD>
<DT><CODE>W</CODE></DT>
<DD>Odd-numbered D register <BR></DD>
<DT><CODE>e</CODE></DT>
<DD>Accumulator register. <BR></DD>
<DT><CODE>A</CODE></DT>
<DD>Even-numbered accumulator register. <BR></DD>
<DT><CODE>B</CODE></DT>
<DD>Odd-numbered accumulator register. <BR></DD>
<DT><CODE>b</CODE></DT>
<DD>I register <BR></DD>
<DT><CODE>v</CODE></DT>
<DD>B register <BR></DD>
<DT><CODE>f</CODE></DT>
<DD>M register <BR></DD>
<DT><CODE>c</CODE></DT>
<DD>Registers used for circular buffering, i.e. I, B, or L registers. <BR></DD>
<DT><CODE>C</CODE></DT>
<DD>The CC register. <BR></DD>
<DT><CODE>t</CODE></DT>
<DD>LT0 or LT1. <BR></DD>
<DT><CODE>k</CODE></DT>
<DD>LC0 or LC1. <BR></DD>
<DT><CODE>u</CODE></DT>
<DD>LB0 or LB1. <BR></DD>
<DT><CODE>x</CODE></DT>
<DD>Any D, P, B, M, I or L register. <BR></DD>
<DT><CODE>y</CODE></DT>
<DD>Additional registers typically used only in prologues and epilogues: RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP. <BR></DD>
<DT><CODE>w</CODE></DT>
<DD>Any register except accumulators or CC. <BR></DD>
<DT><CODE>Ksh</CODE></DT>
<DD>Signed 16 bit integer (in the range &#8722;32768 to 32767) <BR></DD>
<DT><CODE>Kuh</CODE></DT>
<DD>Unsigned 16 bit integer (in the range 0 to 65535) <BR></DD>
<DT><CODE>Ks7</CODE></DT>
<DD>Signed 7 bit integer (in the range &#8722;64 to 63) <BR></DD>
<DT><CODE>Ku7</CODE></DT>
<DD>Unsigned 7 bit integer (in the range 0 to 127) <BR></DD>
<DT><CODE>Ku5</CODE></DT>
<DD>Unsigned 5 bit integer (in the range 0 to 31) <BR></DD>
<DT><CODE>Ks4</CODE></DT>
<DD>Signed 4 bit integer (in the range &#8722;8 to 7) <BR></DD>
<DT><CODE>Ks3</CODE></DT>
<DD>Signed 3 bit integer (in the range &#8722;3 to 4) <BR></DD>
<DT><CODE>Ku3</CODE></DT>
<DD>Unsigned 3 bit integer (in the range 0 to 7) <BR></DD>
<DT><CODE>P</CODE><VAR>n</VAR></DT>
<DD>Constant <VAR>n</VAR>, where <VAR>n</VAR> is a single-digit constant in the range 0 to 4. <BR></DD>
<DT><CODE>PA</CODE></DT>
<DD>An integer equal to one of the MACFLAG_XXX constants that is suitable for use with either accumulator. <BR></DD>
<DT><CODE>PB</CODE></DT>
<DD>An integer equal to one of the MACFLAG_XXX constants that is suitable for use only with accumulator A1. <BR></DD>
<DT><CODE>M1</CODE></DT>
<DD>Constant 255. <BR></DD>
<DT><CODE>M2</CODE></DT>
<DD>Constant 65535. <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>An integer constant with exactly a single bit set. <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>An integer constant with all bits set except exactly one. <BR></DD>
<DT><CODE>H</CODE> <BR></DT>
<DT><CODE>Q</CODE></DT>
<DD>Any SYMBOL_REF. </DD></DL><BR></DD>
<DT><EM>CR16 Architecture&#8212;</EM><SAMP><SPAN class=file>config/cr16/cr16.h</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>b</CODE></DT>
<DD>Registers from r0 to r14 (registers without stack pointer) <BR></DD>
<DT><CODE>t</CODE></DT>
<DD>Register from r0 to r11 (all 16-bit registers) <BR></DD>
<DT><CODE>p</CODE></DT>
<DD>Register from r12 to r15 (all 32-bit registers) <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>Signed constant that fits in 4 bits <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Signed constant that fits in 5 bits <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Signed constant that fits in 6 bits <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Unsigned constant that fits in 4 bits <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>Signed constant that fits in 32 bits <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>Check for 64 bits wide constants for add/sub instructions <BR></DD>
<DT><CODE>G</CODE></DT>
<DD>Floating point constant that is legal for store immediate </DD></DL><BR></DD>
<DT><EM>Epiphany&#8212;</EM><SAMP><SPAN class=file>config/epiphany/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>U16</CODE></DT>
<DD>An unsigned 16-bit constant. <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>An unsigned 5-bit constant. <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>A signed 11-bit constant. <BR></DD>
<DT><CODE>Cm1</CODE></DT>
<DD>A signed 11-bit constant added to &#8722;1. Can only match when the <SAMP><SPAN class=option>-m1reg-</SPAN><VAR>reg</VAR></SAMP> option is active. <BR></DD>
<DT><CODE>Cl1</CODE></DT>
<DD>Left-shift of &#8722;1, i.e., a bit mask with a block of leading ones, the rest being a block of trailing zeroes. Can only match when the <SAMP><SPAN class=option>-m1reg-</SPAN><VAR>reg</VAR></SAMP> option is active. <BR></DD>
<DT><CODE>Cr1</CODE></DT>
<DD>Right-shift of &#8722;1, i.e., a bit mask with a trailing block of ones, the rest being zeroes. Or to put it another way, one less than a power of two. Can only match when the <SAMP><SPAN class=option>-m1reg-</SPAN><VAR>reg</VAR></SAMP> option is active. <BR></DD>
<DT><CODE>Cal</CODE></DT>
<DD>Constant for arithmetic/logical operations. This is like <CODE>i</CODE>, except that for position independent code, no symbols / expressions needing relocations are allowed. <BR></DD>
<DT><CODE>Csy</CODE></DT>
<DD>Symbolic constant for call/jump instruction. <BR></DD>
<DT><CODE>Rcs</CODE></DT>
<DD>The register class usable in short insns. This is a register class constraint, and can thus drive register allocation. This constraint won't match unless <SAMP><SPAN class=option>-mprefer-short-insn-regs</SPAN></SAMP> is in effect. <BR></DD>
<DT><CODE>Rsc</CODE></DT>
<DD>The the register class of registers that can be used to hold a sibcall call address. I.e., a caller-saved register. <BR></DD>
<DT><CODE>Rct</CODE></DT>
<DD>Core control register class. <BR></DD>
<DT><CODE>Rgs</CODE></DT>
<DD>The register group usable in short insns. This constraint does not use a register class, so that it only passively matches suitable registers, and doesn't drive register allocation. <BR></DD>
<DT><CODE>Rra</CODE></DT>
<DD>Matches the return address if it can be replaced with the link register. <BR></DD>
<DT><CODE>Rcc</CODE></DT>
<DD>Matches the integer condition code register. <BR></DD>
<DT><CODE>Sra</CODE></DT>
<DD>Matches the return address if it is in a stack slot. <BR></DD>
<DT><CODE>Cfm</CODE></DT>
<DD>Matches control register values to switch fp mode, which are encapsulated in <CODE>UNSPEC_FP_MODE</CODE>. </DD></DL><BR></DD>
<DT><EM>FRV&#8212;</EM><SAMP><SPAN class=file>config/frv/frv.h</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>a</CODE></DT>
<DD>Register in the class <CODE>ACC_REGS</CODE> (<CODE>acc0</CODE> to <CODE>acc7</CODE>). <BR></DD>
<DT><CODE>b</CODE></DT>
<DD>Register in the class <CODE>EVEN_ACC_REGS</CODE> (<CODE>acc0</CODE> to <CODE>acc7</CODE>). <BR></DD>
<DT><CODE>c</CODE></DT>
<DD>Register in the class <CODE>CC_REGS</CODE> (<CODE>fcc0</CODE> to <CODE>fcc3</CODE> and <CODE>icc0</CODE> to <CODE>icc3</CODE>). <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>Register in the class <CODE>GPR_REGS</CODE> (<CODE>gr0</CODE> to <CODE>gr63</CODE>). <BR></DD>
<DT><CODE>e</CODE></DT>
<DD>Register in the class <CODE>EVEN_REGS</CODE> (<CODE>gr0</CODE> to <CODE>gr63</CODE>). Odd registers are excluded not in the class but through the use of a machine mode larger than 4 bytes. <BR></DD>
<DT><CODE>f</CODE></DT>
<DD>Register in the class <CODE>FPR_REGS</CODE> (<CODE>fr0</CODE> to <CODE>fr63</CODE>). <BR></DD>
<DT><CODE>h</CODE></DT>
<DD>Register in the class <CODE>FEVEN_REGS</CODE> (<CODE>fr0</CODE> to <CODE>fr63</CODE>). Odd registers are excluded not in the class but through the use of a machine mode larger than 4 bytes. <BR></DD>
<DT><CODE>l</CODE></DT>
<DD>Register in the class <CODE>LR_REG</CODE> (the <CODE>lr</CODE> register). <BR></DD>
<DT><CODE>q</CODE></DT>
<DD>Register in the class <CODE>QUAD_REGS</CODE> (<CODE>gr2</CODE> to <CODE>gr63</CODE>). Register numbers not divisible by 4 are excluded not in the class but through the use of a machine mode larger than 8 bytes. <BR></DD>
<DT><CODE>t</CODE></DT>
<DD>Register in the class <CODE>ICC_REGS</CODE> (<CODE>icc0</CODE> to <CODE>icc3</CODE>). <BR></DD>
<DT><CODE>u</CODE></DT>
<DD>Register in the class <CODE>FCC_REGS</CODE> (<CODE>fcc0</CODE> to <CODE>fcc3</CODE>). <BR></DD>
<DT><CODE>v</CODE></DT>
<DD>Register in the class <CODE>ICR_REGS</CODE> (<CODE>cc4</CODE> to <CODE>cc7</CODE>). <BR></DD>
<DT><CODE>w</CODE></DT>
<DD>Register in the class <CODE>FCR_REGS</CODE> (<CODE>cc0</CODE> to <CODE>cc3</CODE>). <BR></DD>
<DT><CODE>x</CODE></DT>
<DD>Register in the class <CODE>QUAD_FPR_REGS</CODE> (<CODE>fr0</CODE> to <CODE>fr63</CODE>). Register numbers not divisible by 4 are excluded not in the class but through the use of a machine mode larger than 8 bytes. <BR></DD>
<DT><CODE>z</CODE></DT>
<DD>Register in the class <CODE>SPR_REGS</CODE> (<CODE>lcr</CODE> and <CODE>lr</CODE>). <BR></DD>
<DT><CODE>A</CODE></DT>
<DD>Register in the class <CODE>QUAD_ACC_REGS</CODE> (<CODE>acc0</CODE> to <CODE>acc7</CODE>). <BR></DD>
<DT><CODE>B</CODE></DT>
<DD>Register in the class <CODE>ACCG_REGS</CODE> (<CODE>accg0</CODE> to <CODE>accg7</CODE>). <BR></DD>
<DT><CODE>C</CODE></DT>
<DD>Register in the class <CODE>CR_REGS</CODE> (<CODE>cc0</CODE> to <CODE>cc7</CODE>). <BR></DD>
<DT><CODE>G</CODE></DT>
<DD>Floating point constant zero <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>6-bit signed integer constant <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>10-bit signed integer constant <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>16-bit signed integer constant <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>16-bit unsigned integer constant <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>12-bit signed integer constant that is negative&#8212;i.e. in the range of &#8722;2048 to &#8722;1 <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>Constant zero <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>12-bit signed integer constant that is greater than zero&#8212;i.e. in the range of 1 to 2047. </DD></DL><BR></DD>
<DT><EM>FT32&#8212;</EM><SAMP><SPAN class=file>config/ft32/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>A</CODE></DT>
<DD>An absolute address <BR></DD>
<DT><CODE>B</CODE></DT>
<DD>An offset address <BR></DD>
<DT><CODE>W</CODE></DT>
<DD>A register indirect memory operand <BR></DD>
<DT><CODE>e</CODE></DT>
<DD>An offset address. <BR></DD>
<DT><CODE>f</CODE></DT>
<DD>An offset address. <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>The constant zero or one <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>A 16-bit signed constant (&#8722;32768 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 32767) <BR></DD>
<DT><CODE>w</CODE></DT>
<DD>A bitfield mask suitable for bext or bins <BR></DD>
<DT><CODE>x</CODE></DT>
<DD>An inverted bitfield mask suitable for bext or bins <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>A 16-bit unsigned constant, multiple of 4 (0 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 65532) <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>A 20-bit signed constant (&#8722;524288 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 524287) <BR></DD>
<DT><CODE>b</CODE></DT>
<DD>A constant for a bitfield width (1 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 16) <BR></DD>
<DT><CODE>KA</CODE></DT>
<DD>A 10-bit signed constant (&#8722;512 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 511) </DD></DL><BR></DD>
<DT><EM>Hewlett-Packard PA-RISC&#8212;</EM><SAMP><SPAN class=file>config/pa/pa.h</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>a</CODE></DT>
<DD>General register 1 <BR></DD>
<DT><CODE>f</CODE></DT>
<DD>Floating point register <BR></DD>
<DT><CODE>q</CODE></DT>
<DD>Shift amount register <BR></DD>
<DT><CODE>x</CODE></DT>
<DD>Floating point register (deprecated) <BR></DD>
<DT><CODE>y</CODE></DT>
<DD>Upper floating point register (32-bit), floating point register (64-bit) <BR></DD>
<DT><CODE>Z</CODE></DT>
<DD>Any register <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>Signed 11-bit integer constant <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Signed 14-bit integer constant <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Integer constant that can be deposited with a <CODE>zdepi</CODE> instruction <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Signed 5-bit integer constant <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>Integer constant 0 <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>Integer constant that can be loaded with a <CODE>ldil</CODE> instruction <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>Integer constant whose value plus one is a power of 2 <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>Integer constant that can be used for <CODE>and</CODE> operations in <CODE>depi</CODE> and <CODE>extru</CODE> instructions <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>Integer constant 31 <BR></DD>
<DT><CODE>U</CODE></DT>
<DD>Integer constant 63 <BR></DD>
<DT><CODE>G</CODE></DT>
<DD>Floating-point constant 0.0 <BR></DD>
<DT><CODE>A</CODE></DT>
<DD>A <CODE>lo_sum</CODE> data-linkage-table memory operand <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>A memory operand that can be used as the destination operand of an integer store instruction <BR></DD>
<DT><CODE>R</CODE></DT>
<DD>A scaled or unscaled indexed memory operand <BR></DD>
<DT><CODE>T</CODE></DT>
<DD>A memory operand for floating-point loads and stores <BR></DD>
<DT><CODE>W</CODE></DT>
<DD>A register indirect memory operand </DD></DL><BR></DD>
<DT><EM>Intel IA-64&#8212;</EM><SAMP><SPAN class=file>config/ia64/ia64.h</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>a</CODE></DT>
<DD>General register <CODE>r0</CODE> to <CODE>r3</CODE> for <CODE>addl</CODE> instruction <BR></DD>
<DT><CODE>b</CODE></DT>
<DD>Branch register <BR></DD>
<DT><CODE>c</CODE></DT>
<DD>Predicate register (&#8216;<SAMP><SPAN class=samp>c</SPAN></SAMP>&#8217; as in &#8220;conditional&#8221;) <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>Application register residing in M-unit <BR></DD>
<DT><CODE>e</CODE></DT>
<DD>Application register residing in I-unit <BR></DD>
<DT><CODE>f</CODE></DT>
<DD>Floating-point register <BR></DD>
<DT><CODE>m</CODE></DT>
<DD>Memory operand. If used together with &#8216;<SAMP><SPAN class=samp>&lt;</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>&gt;</SPAN></SAMP>&#8217;, the operand can have postincrement and postdecrement which require printing with &#8216;<SAMP><SPAN class=samp>%Pn</SPAN></SAMP>&#8217; on IA-64. <BR></DD>
<DT><CODE>G</CODE></DT>
<DD>Floating-point constant 0.0 or 1.0 <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>14-bit signed integer constant <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>22-bit signed integer constant <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>8-bit signed integer constant for logical instructions <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>8-bit adjusted signed integer constant for compare pseudo-ops <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>6-bit unsigned integer constant for shift counts <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>9-bit signed integer constant for load and store postincrements <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>The constant zero <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>0 or &#8722;1 for <CODE>dep</CODE> instruction <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>Non-volatile memory for floating-point loads and stores <BR></DD>
<DT><CODE>R</CODE></DT>
<DD>Integer constant in the range 1 to 4 for <CODE>shladd</CODE> instruction <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>Memory operand except postincrement and postdecrement. This is now roughly the same as &#8216;<SAMP><SPAN class=samp>m</SPAN></SAMP>&#8217; when not used together with &#8216;<SAMP><SPAN class=samp>&lt;</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>&gt;</SPAN></SAMP>&#8217;. </DD></DL><BR></DD>
<DT><EM>M32C&#8212;</EM><SAMP><SPAN class=file>config/m32c/m32c.c</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>Rsp</CODE></DT>
<DT><CODE>Rfb</CODE></DT>
<DT><CODE>Rsb</CODE></DT>
<DD>&#8216;<SAMP><SPAN class=samp>$sp</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>$fb</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>$sb</SPAN></SAMP>&#8217;. <BR></DD>
<DT><CODE>Rcr</CODE></DT>
<DD>Any control register, when they're 16 bits wide (nothing if control registers are 24 bits wide) <BR></DD>
<DT><CODE>Rcl</CODE></DT>
<DD>Any control register, when they're 24 bits wide. <BR></DD>
<DT><CODE>R0w</CODE></DT>
<DT><CODE>R1w</CODE></DT>
<DT><CODE>R2w</CODE></DT>
<DT><CODE>R3w</CODE></DT>
<DD>$r0, $r1, $r2, $r3. <BR></DD>
<DT><CODE>R02</CODE></DT>
<DD>$r0 or $r2, or $r2r0 for 32 bit values. <BR></DD>
<DT><CODE>R13</CODE></DT>
<DD>$r1 or $r3, or $r3r1 for 32 bit values. <BR></DD>
<DT><CODE>Rdi</CODE></DT>
<DD>A register that can hold a 64 bit value. <BR></DD>
<DT><CODE>Rhl</CODE></DT>
<DD>$r0 or $r1 (registers with addressable high/low bytes) <BR></DD>
<DT><CODE>R23</CODE></DT>
<DD>$r2 or $r3 <BR></DD>
<DT><CODE>Raa</CODE></DT>
<DD>Address registers <BR></DD>
<DT><CODE>Raw</CODE></DT>
<DD>Address registers when they're 16 bits wide. <BR></DD>
<DT><CODE>Ral</CODE></DT>
<DD>Address registers when they're 24 bits wide. <BR></DD>
<DT><CODE>Rqi</CODE></DT>
<DD>Registers that can hold QI values. <BR></DD>
<DT><CODE>Rad</CODE></DT>
<DD>Registers that can be used with displacements ($a0, $a1, $sb). <BR></DD>
<DT><CODE>Rsi</CODE></DT>
<DD>Registers that can hold 32 bit values. <BR></DD>
<DT><CODE>Rhi</CODE></DT>
<DD>Registers that can hold 16 bit values. <BR></DD>
<DT><CODE>Rhc</CODE></DT>
<DD>Registers chat can hold 16 bit values, including all control registers. <BR></DD>
<DT><CODE>Rra</CODE></DT>
<DD>$r0 through R1, plus $a0 and $a1. <BR></DD>
<DT><CODE>Rfl</CODE></DT>
<DD>The flags register. <BR></DD>
<DT><CODE>Rmm</CODE></DT>
<DD>The memory-based pseudo-registers $mem0 through $mem15. <BR></DD>
<DT><CODE>Rpi</CODE></DT>
<DD>Registers that can hold pointers (16 bit registers for r8c, m16c; 24 bit registers for m32cm, m32c). <BR></DD>
<DT><CODE>Rpa</CODE></DT>
<DD>Matches multiple registers in a PARALLEL to form a larger register. Used to match function return values. <BR></DD>
<DT><CODE>Is3</CODE></DT>
<DD>&#8722;8 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 7 <BR></DD>
<DT><CODE>IS1</CODE></DT>
<DD>&#8722;128 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 127 <BR></DD>
<DT><CODE>IS2</CODE></DT>
<DD>&#8722;32768 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 32767 <BR></DD>
<DT><CODE>IU2</CODE></DT>
<DD>0 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 65535 <BR></DD>
<DT><CODE>In4</CODE></DT>
<DD>&#8722;8 <SMALL class=dots><FONT size=2>...</FONT></SMALL> &#8722;1 or 1 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 8 <BR></DD>
<DT><CODE>In5</CODE></DT>
<DD>&#8722;16 <SMALL class=dots><FONT size=2>...</FONT></SMALL> &#8722;1 or 1 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 16 <BR></DD>
<DT><CODE>In6</CODE></DT>
<DD>&#8722;32 <SMALL class=dots><FONT size=2>...</FONT></SMALL> &#8722;1 or 1 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 32 <BR></DD>
<DT><CODE>IM2</CODE></DT>
<DD>&#8722;65536 <SMALL class=dots><FONT size=2>...</FONT></SMALL> &#8722;1 <BR></DD>
<DT><CODE>Ilb</CODE></DT>
<DD>An 8 bit value with exactly one bit set. <BR></DD>
<DT><CODE>Ilw</CODE></DT>
<DD>A 16 bit value with exactly one bit set. <BR></DD>
<DT><CODE>Sd</CODE></DT>
<DD>The common src/dest memory addressing modes. <BR></DD>
<DT><CODE>Sa</CODE></DT>
<DD>Memory addressed using $a0 or $a1. <BR></DD>
<DT><CODE>Si</CODE></DT>
<DD>Memory addressed with immediate addresses. <BR></DD>
<DT><CODE>Ss</CODE></DT>
<DD>Memory addressed using the stack pointer ($sp). <BR></DD>
<DT><CODE>Sf</CODE></DT>
<DD>Memory addressed using the frame base register ($fb). <BR></DD>
<DT><CODE>Ss</CODE></DT>
<DD>Memory addressed using the small base register ($sb). <BR></DD>
<DT><CODE>S1</CODE></DT>
<DD>$r1h </DD></DL><BR></DD>
<DT><EM>MicroBlaze&#8212;</EM><SAMP><SPAN class=file>config/microblaze/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>d</CODE></DT>
<DD>A general register (<CODE>r0</CODE> to <CODE>r31</CODE>). <BR></DD>
<DT><CODE>z</CODE></DT>
<DD>A status register (<CODE>rmsr</CODE>, <CODE>$fcc1</CODE> to <CODE>$fcc7</CODE>). </DD></DL><BR></DD>
<DT><EM>MIPS&#8212;</EM><SAMP><SPAN class=file>config/mips/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>d</CODE></DT>
<DD>An address register. This is equivalent to <CODE>r</CODE> unless generating MIPS16 code. <BR></DD>
<DT><CODE>f</CODE></DT>
<DD>A floating-point register (if available). <BR></DD>
<DT><CODE>h</CODE></DT>
<DD>Formerly the <CODE>hi</CODE> register. This constraint is no longer supported. <BR></DD>
<DT><CODE>l</CODE></DT>
<DD>The <CODE>lo</CODE> register. Use this register to store values that are no bigger than a word. <BR></DD>
<DT><CODE>x</CODE></DT>
<DD>The concatenated <CODE>hi</CODE> and <CODE>lo</CODE> registers. Use this register to store doubleword values. <BR></DD>
<DT><CODE>c</CODE></DT>
<DD>A register suitable for use in an indirect jump. This will always be <CODE>$25</CODE> for <SAMP><SPAN class=option>-mabicalls</SPAN></SAMP>. <BR></DD>
<DT><CODE>v</CODE></DT>
<DD>Register <CODE>$3</CODE>. Do not use this constraint in new code; it is retained only for compatibility with glibc. <BR></DD>
<DT><CODE>y</CODE></DT>
<DD>Equivalent to <CODE>r</CODE>; retained for backwards compatibility. <BR></DD>
<DT><CODE>z</CODE></DT>
<DD>A floating-point condition code register. <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>A signed 16-bit constant (for arithmetic instructions). <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Integer zero. <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>An unsigned 16-bit constant (for logic instructions). <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>A signed 32-bit constant in which the lower 16 bits are zero. Such constants can be loaded using <CODE>lui</CODE>. <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>A constant that cannot be loaded using <CODE>lui</CODE>, <CODE>addiu</CODE> or <CODE>ori</CODE>. <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>A constant in the range &#8722;65535 to &#8722;1 (inclusive). <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>A signed 15-bit constant. <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>A constant in the range 1 to 65535 (inclusive). <BR></DD>
<DT><CODE>G</CODE></DT>
<DD>Floating-point zero. <BR></DD>
<DT><CODE>R</CODE></DT>
<DD>An address that can be used in a non-macro load or store. <BR></DD>
<DT><CODE>ZC</CODE></DT>
<DD>A memory operand whose address is formed by a base register and offset that is suitable for use in instructions with the same addressing mode as <CODE>ll</CODE> and <CODE>sc</CODE>. <BR></DD>
<DT><CODE>ZD</CODE></DT>
<DD>An address suitable for a <CODE>prefetch</CODE> instruction, or for any other instruction with the same addressing mode as <CODE>prefetch</CODE>. </DD></DL><BR></DD>
<DT><EM>Motorola 680x0&#8212;</EM><SAMP><SPAN class=file>config/m68k/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>a</CODE></DT>
<DD>Address register <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>Data register <BR></DD>
<DT><CODE>f</CODE></DT>
<DD>68881 floating-point register, if available <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>Integer in the range 1 to 8 <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>16-bit signed number <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Signed number whose magnitude is greater than 0x80 <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Integer in the range &#8722;8 to &#8722;1 <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>Signed number whose magnitude is greater than 0x100 <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>Range 24 to 31, rotatert:SI 8 to 1 expressed as rotate <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>16 (for rotate using swap) <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>Range 8 to 15, rotatert:HI 8 to 1 expressed as rotate <BR></DD>
<DT><CODE>R</CODE></DT>
<DD>Numbers that mov3q can handle <BR></DD>
<DT><CODE>G</CODE></DT>
<DD>Floating point constant that is not a 68881 constant <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>Operands that satisfy 'm' when -mpcrel is in effect <BR></DD>
<DT><CODE>T</CODE></DT>
<DD>Operands that satisfy 's' when -mpcrel is not in effect <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>Address register indirect addressing mode <BR></DD>
<DT><CODE>U</CODE></DT>
<DD>Register offset addressing <BR></DD>
<DT><CODE>W</CODE></DT>
<DD>const_call_operand <BR></DD>
<DT><CODE>Cs</CODE></DT>
<DD>symbol_ref or const <BR></DD>
<DT><CODE>Ci</CODE></DT>
<DD>const_int <BR></DD>
<DT><CODE>C0</CODE></DT>
<DD>const_int 0 <BR></DD>
<DT><CODE>Cj</CODE></DT>
<DD>Range of signed numbers that don't fit in 16 bits <BR></DD>
<DT><CODE>Cmvq</CODE></DT>
<DD>Integers valid for mvq <BR></DD>
<DT><CODE>Capsw</CODE></DT>
<DD>Integers valid for a moveq followed by a swap <BR></DD>
<DT><CODE>Cmvz</CODE></DT>
<DD>Integers valid for mvz <BR></DD>
<DT><CODE>Cmvs</CODE></DT>
<DD>Integers valid for mvs <BR></DD>
<DT><CODE>Ap</CODE></DT>
<DD>push_operand <BR></DD>
<DT><CODE>Ac</CODE></DT>
<DD>Non-register operands allowed in clr </DD></DL><BR></DD>
<DT><EM>Moxie&#8212;</EM><SAMP><SPAN class=file>config/moxie/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>A</CODE></DT>
<DD>An absolute address <BR></DD>
<DT><CODE>B</CODE></DT>
<DD>An offset address <BR></DD>
<DT><CODE>W</CODE></DT>
<DD>A register indirect memory operand <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>A constant in the range of 0 to 255. <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>A constant in the range of 0 to &#8722;255. </DD></DL><BR></DD>
<DT><EM>MSP430&#8211;</EM><SAMP><SPAN class=file>config/msp430/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>R12</CODE></DT>
<DD>Register R12. <BR></DD>
<DT><CODE>R13</CODE></DT>
<DD>Register R13. <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Integer constant 1. <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Integer constant -1^20..1^19. <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>Integer constant 1-4. <BR></DD>
<DT><CODE>Ya</CODE></DT>
<DD>Memory references which do not require an extended MOVX instruction. <BR></DD>
<DT><CODE>Yl</CODE></DT>
<DD>Memory reference, labels only. <BR></DD>
<DT><CODE>Ys</CODE></DT>
<DD>Memory reference, stack only. </DD></DL><BR></DD>
<DT><EM>NDS32&#8212;</EM><SAMP><SPAN class=file>config/nds32/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>w</CODE></DT>
<DD>LOW register class $r0 to $r7 constraint for V3/V3M ISA. <BR></DD>
<DT><CODE>l</CODE></DT>
<DD>LOW register class $r0 to $r7. <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>MIDDLE register class $r0 to $r11, $r16 to $r19. <BR></DD>
<DT><CODE>h</CODE></DT>
<DD>HIGH register class $r12 to $r14, $r20 to $r31. <BR></DD>
<DT><CODE>t</CODE></DT>
<DD>Temporary assist register $ta (i.e. $r15). <BR></DD>
<DT><CODE>k</CODE></DT>
<DD>Stack register $sp. <BR></DD>
<DT><CODE>Iu03</CODE></DT>
<DD>Unsigned immediate 3-bit value. <BR></DD>
<DT><CODE>In03</CODE></DT>
<DD>Negative immediate 3-bit value in the range of &#8722;7&#8211;0. <BR></DD>
<DT><CODE>Iu04</CODE></DT>
<DD>Unsigned immediate 4-bit value. <BR></DD>
<DT><CODE>Is05</CODE></DT>
<DD>Signed immediate 5-bit value. <BR></DD>
<DT><CODE>Iu05</CODE></DT>
<DD>Unsigned immediate 5-bit value. <BR></DD>
<DT><CODE>In05</CODE></DT>
<DD>Negative immediate 5-bit value in the range of &#8722;31&#8211;0. <BR></DD>
<DT><CODE>Ip05</CODE></DT>
<DD>Unsigned immediate 5-bit value for movpi45 instruction with range 16&#8211;47. <BR></DD>
<DT><CODE>Iu06</CODE></DT>
<DD>Unsigned immediate 6-bit value constraint for addri36.sp instruction. <BR></DD>
<DT><CODE>Iu08</CODE></DT>
<DD>Unsigned immediate 8-bit value. <BR></DD>
<DT><CODE>Iu09</CODE></DT>
<DD>Unsigned immediate 9-bit value. <BR></DD>
<DT><CODE>Is10</CODE></DT>
<DD>Signed immediate 10-bit value. <BR></DD>
<DT><CODE>Is11</CODE></DT>
<DD>Signed immediate 11-bit value. <BR></DD>
<DT><CODE>Is15</CODE></DT>
<DD>Signed immediate 15-bit value. <BR></DD>
<DT><CODE>Iu15</CODE></DT>
<DD>Unsigned immediate 15-bit value. <BR></DD>
<DT><CODE>Ic15</CODE></DT>
<DD>A constant which is not in the range of imm15u but ok for bclr instruction. <BR></DD>
<DT><CODE>Ie15</CODE></DT>
<DD>A constant which is not in the range of imm15u but ok for bset instruction. <BR></DD>
<DT><CODE>It15</CODE></DT>
<DD>A constant which is not in the range of imm15u but ok for btgl instruction. <BR></DD>
<DT><CODE>Ii15</CODE></DT>
<DD>A constant whose compliment value is in the range of imm15u and ok for bitci instruction. <BR></DD>
<DT><CODE>Is16</CODE></DT>
<DD>Signed immediate 16-bit value. <BR></DD>
<DT><CODE>Is17</CODE></DT>
<DD>Signed immediate 17-bit value. <BR></DD>
<DT><CODE>Is19</CODE></DT>
<DD>Signed immediate 19-bit value. <BR></DD>
<DT><CODE>Is20</CODE></DT>
<DD>Signed immediate 20-bit value. <BR></DD>
<DT><CODE>Ihig</CODE></DT>
<DD>The immediate value that can be simply set high 20-bit. <BR></DD>
<DT><CODE>Izeb</CODE></DT>
<DD>The immediate value 0xff. <BR></DD>
<DT><CODE>Izeh</CODE></DT>
<DD>The immediate value 0xffff. <BR></DD>
<DT><CODE>Ixls</CODE></DT>
<DD>The immediate value 0x01. <BR></DD>
<DT><CODE>Ix11</CODE></DT>
<DD>The immediate value 0x7ff. <BR></DD>
<DT><CODE>Ibms</CODE></DT>
<DD>The immediate value with power of 2. <BR></DD>
<DT><CODE>Ifex</CODE></DT>
<DD>The immediate value with power of 2 minus 1. <BR></DD>
<DT><CODE>U33</CODE></DT>
<DD>Memory constraint for 333 format. <BR></DD>
<DT><CODE>U45</CODE></DT>
<DD>Memory constraint for 45 format. <BR></DD>
<DT><CODE>U37</CODE></DT>
<DD>Memory constraint for 37 format. </DD></DL><BR></DD>
<DT><EM>Nios II family&#8212;</EM><SAMP><SPAN class=file>config/nios2/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>I</CODE></DT>
<DD>Integer that is valid as an immediate operand in an instruction taking a signed 16-bit number. Range &#8722;32768 to 32767. <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Integer that is valid as an immediate operand in an instruction taking an unsigned 16-bit number. Range 0 to 65535. <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Integer that is valid as an immediate operand in an instruction taking only the upper 16-bits of a 32-bit number. Range 32-bit numbers with the lower 16-bits being 0. <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Integer that is valid as an immediate operand for a shift instruction. Range 0 to 31. <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>Integer that is valid as an immediate operand for only the value 0. Can be used in conjunction with the format modifier <CODE>z</CODE> to use <CODE>r0</CODE> instead of <CODE>0</CODE> in the assembly output. <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>Integer that is valid as an immediate operand for a custom instruction opcode. Range 0 to 255. <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>An immediate operand for R2 andchi/andci instructions. <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>Matches immediates which are addresses in the small data section and therefore can be added to <CODE>gp</CODE> as a 16-bit immediate to re-create their 32-bit value. <BR></DD>
<DT><CODE>U</CODE></DT>
<DD>Matches constants suitable as an operand for the rdprs and cache instructions. <BR></DD>
<DT><CODE>v</CODE></DT>
<DD>A memory operand suitable for Nios II R2 load/store exclusive instructions. <BR></DD>
<DT><CODE>w</CODE></DT>
<DD>A memory operand suitable for load/store IO and cache instructions. </DD></DL><BR></DD>
<DT><EM>PDP-11&#8212;</EM><SAMP><SPAN class=file>config/pdp11/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>a</CODE></DT>
<DD>Floating point registers AC0 through AC3. These can be loaded from/to memory with a single instruction. <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>Odd numbered general registers (R1, R3, R5). These are used for 16-bit multiply operations. <BR></DD>
<DT><CODE>f</CODE></DT>
<DD>Any of the floating point registers (AC0 through AC5). <BR></DD>
<DT><CODE>G</CODE></DT>
<DD>Floating point constant 0. <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>An integer constant that fits in 16 bits. <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>An integer constant whose low order 16 bits are zero. <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>An integer constant that does not meet the constraints for codes &#8216;<SAMP><SPAN class=samp>I</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>J</SPAN></SAMP>&#8217;. <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>The integer constant 1. <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>The integer constant &#8722;1. <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>The integer constant 0. <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>Integer constants &#8722;4 through &#8722;1 and 1 through 4; shifts by these amounts are handled as multiple single-bit shifts rather than a single variable-length shift. <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>A memory reference which requires an additional word (address or offset) after the opcode. <BR></DD>
<DT><CODE>R</CODE></DT>
<DD>A memory reference that is encoded within the opcode. </DD></DL><BR></DD>
<DT><EM>PowerPC and IBM RS6000&#8212;</EM><SAMP><SPAN class=file>config/rs6000/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>b</CODE></DT>
<DD>Address base register <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>Floating point register (containing 64-bit value) <BR></DD>
<DT><CODE>f</CODE></DT>
<DD>Floating point register (containing 32-bit value) <BR></DD>
<DT><CODE>v</CODE></DT>
<DD>Altivec vector register <BR></DD>
<DT><CODE>wa</CODE></DT>
<DD>Any VSX register if the -mvsx option was used or NO_REGS. 
<P>When using any of the register constraints (<CODE>wa</CODE>, <CODE>wd</CODE>, <CODE>wf</CODE>, <CODE>wg</CODE>, <CODE>wh</CODE>, <CODE>wi</CODE>, <CODE>wj</CODE>, <CODE>wk</CODE>, <CODE>wl</CODE>, <CODE>wm</CODE>, <CODE>wo</CODE>, <CODE>wp</CODE>, <CODE>wq</CODE>, <CODE>ws</CODE>, <CODE>wt</CODE>, <CODE>wu</CODE>, <CODE>wv</CODE>, <CODE>ww</CODE>, or <CODE>wy</CODE>) that take VSX registers, you must use <CODE>%x&lt;n&gt;</CODE> in the template so that the correct register is used. Otherwise the register number output in the assembly file will be incorrect if an Altivec register is an operand of a VSX instruction that expects VSX register numbering. </P><PRE class=smallexample>               asm ("xvadddp %x0,%x1,%x2" : "=wa" (v1) : "wa" (v2), "wa" (v3));
</PRE>
<P>is correct, but: </P><PRE class=smallexample>               asm ("xvadddp %0,%1,%2" : "=wa" (v1) : "wa" (v2), "wa" (v3));
</PRE>
<P>is not correct. </P>
<P>If an instruction only takes Altivec registers, you do not want to use <CODE>%x&lt;n&gt;</CODE>. </P><PRE class=smallexample>               asm ("xsaddqp %0,%1,%2" : "=v" (v1) : "v" (v2), "v" (v3));
</PRE>
<P>is correct because the <CODE>xsaddqp</CODE> instruction only takes Altivec registers, while: </P><PRE class=smallexample>               asm ("xsaddqp %x0,%x1,%x2" : "=v" (v1) : "v" (v2), "v" (v3));
</PRE>
<P>is incorrect. <BR></P></DD>
<DT><CODE>wb</CODE></DT>
<DD>Altivec register if <SAMP><SPAN class=option>-mcpu=power9</SPAN></SAMP> is used or NO_REGS. <BR></DD>
<DT><CODE>wd</CODE></DT>
<DD>VSX vector register to hold vector double data or NO_REGS. <BR></DD>
<DT><CODE>we</CODE></DT>
<DD>VSX register if the <SAMP><SPAN class=option>-mcpu=power9</SPAN></SAMP> and <SAMP><SPAN class=option>-m64</SPAN></SAMP> options were used or NO_REGS. <BR></DD>
<DT><CODE>wf</CODE></DT>
<DD>VSX vector register to hold vector float data or NO_REGS. <BR></DD>
<DT><CODE>wg</CODE></DT>
<DD>If <SAMP><SPAN class=option>-mmfpgpr</SPAN></SAMP> was used, a floating point register or NO_REGS. <BR></DD>
<DT><CODE>wh</CODE></DT>
<DD>Floating point register if direct moves are available, or NO_REGS. <BR></DD>
<DT><CODE>wi</CODE></DT>
<DD>FP or VSX register to hold 64-bit integers for VSX insns or NO_REGS. <BR></DD>
<DT><CODE>wj</CODE></DT>
<DD>FP or VSX register to hold 64-bit integers for direct moves or NO_REGS. <BR></DD>
<DT><CODE>wk</CODE></DT>
<DD>FP or VSX register to hold 64-bit doubles for direct moves or NO_REGS. <BR></DD>
<DT><CODE>wl</CODE></DT>
<DD>Floating point register if the LFIWAX instruction is enabled or NO_REGS. <BR></DD>
<DT><CODE>wm</CODE></DT>
<DD>VSX register if direct move instructions are enabled, or NO_REGS. <BR></DD>
<DT><CODE>wn</CODE></DT>
<DD>No register (NO_REGS). <BR></DD>
<DT><CODE>wo</CODE></DT>
<DD>VSX register to use for ISA 3.0 vector instructions, or NO_REGS. <BR></DD>
<DT><CODE>wp</CODE></DT>
<DD>VSX register to use for IEEE 128-bit floating point TFmode, or NO_REGS. <BR></DD>
<DT><CODE>wq</CODE></DT>
<DD>VSX register to use for IEEE 128-bit floating point, or NO_REGS. <BR></DD>
<DT><CODE>wr</CODE></DT>
<DD>General purpose register if 64-bit instructions are enabled or NO_REGS. <BR></DD>
<DT><CODE>ws</CODE></DT>
<DD>VSX vector register to hold scalar double values or NO_REGS. <BR></DD>
<DT><CODE>wt</CODE></DT>
<DD>VSX vector register to hold 128 bit integer or NO_REGS. <BR></DD>
<DT><CODE>wu</CODE></DT>
<DD>Altivec register to use for float/32-bit int loads/stores or NO_REGS. <BR></DD>
<DT><CODE>wv</CODE></DT>
<DD>Altivec register to use for double loads/stores or NO_REGS. <BR></DD>
<DT><CODE>ww</CODE></DT>
<DD>FP or VSX register to perform float operations under <SAMP><SPAN class=option>-mvsx</SPAN></SAMP> or NO_REGS. <BR></DD>
<DT><CODE>wx</CODE></DT>
<DD>Floating point register if the STFIWX instruction is enabled or NO_REGS. <BR></DD>
<DT><CODE>wy</CODE></DT>
<DD>FP or VSX register to perform ISA 2.07 float ops or NO_REGS. <BR></DD>
<DT><CODE>wz</CODE></DT>
<DD>Floating point register if the LFIWZX instruction is enabled or NO_REGS. <BR></DD>
<DT><CODE>wB</CODE></DT>
<DD>Signed 5-bit constant integer that can be loaded into an altivec register. <BR></DD>
<DT><CODE>wD</CODE></DT>
<DD>Int constant that is the element number of the 64-bit scalar in a vector. <BR></DD>
<DT><CODE>wE</CODE></DT>
<DD>Vector constant that can be loaded with the XXSPLTIB instruction. <BR></DD>
<DT><CODE>wF</CODE></DT>
<DD>Memory operand suitable for power9 fusion load/stores. <BR></DD>
<DT><CODE>wG</CODE></DT>
<DD>Memory operand suitable for TOC fusion memory references. <BR></DD>
<DT><CODE>wL</CODE></DT>
<DD>Int constant that is the element number that the MFVSRLD instruction. targets. <BR></DD>
<DT><CODE>wM</CODE></DT>
<DD>Match vector constant with all 1's if the XXLORC instruction is available. <BR></DD>
<DT><CODE>wO</CODE></DT>
<DD>A memory operand suitable for the ISA 3.0 vector d-form instructions. <BR></DD>
<DT><CODE>wQ</CODE></DT>
<DD>A memory address that will work with the <CODE>lq</CODE> and <CODE>stq</CODE> instructions. <BR></DD>
<DT><CODE>wS</CODE></DT>
<DD>Vector constant that can be loaded with XXSPLTIB &amp; sign extension. <BR></DD>
<DT><CODE>h</CODE></DT>
<DD>&#8216;<SAMP><SPAN class=samp>MQ</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>CTR</SPAN></SAMP>&#8217;, or &#8216;<SAMP><SPAN class=samp>LINK</SPAN></SAMP>&#8217; register <BR></DD>
<DT><CODE>c</CODE></DT>
<DD>&#8216;<SAMP><SPAN class=samp>CTR</SPAN></SAMP>&#8217; register <BR></DD>
<DT><CODE>l</CODE></DT>
<DD>&#8216;<SAMP><SPAN class=samp>LINK</SPAN></SAMP>&#8217; register <BR></DD>
<DT><CODE>x</CODE></DT>
<DD>&#8216;<SAMP><SPAN class=samp>CR</SPAN></SAMP>&#8217; register (condition register) number 0 <BR></DD>
<DT><CODE>y</CODE></DT>
<DD>&#8216;<SAMP><SPAN class=samp>CR</SPAN></SAMP>&#8217; register (condition register) <BR></DD>
<DT><CODE>z</CODE></DT>
<DD>&#8216;<SAMP><SPAN class=samp>XER[CA]</SPAN></SAMP>&#8217; carry bit (part of the XER register) <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>Signed 16-bit constant <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Unsigned 16-bit constant shifted left 16 bits (use &#8216;<SAMP><SPAN class=samp>L</SPAN></SAMP>&#8217; instead for <CODE>SImode</CODE> constants) <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Unsigned 16-bit constant <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Signed 16-bit constant shifted left 16 bits <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>Constant larger than 31 <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>Exact power of 2 <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>Zero <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>Constant whose negation is a signed 16-bit constant <BR></DD>
<DT><CODE>G</CODE></DT>
<DD>Floating point constant that can be loaded into a register with one instruction per word <BR></DD>
<DT><CODE>H</CODE></DT>
<DD>Integer/Floating point constant that can be loaded into a register using three instructions <BR></DD>
<DT><CODE>m</CODE></DT>
<DD>Memory operand. Normally, <CODE>m</CODE> does not allow addresses that update the base register. If &#8216;<SAMP><SPAN class=samp>&lt;</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>&gt;</SPAN></SAMP>&#8217; constraint is also used, they are allowed and therefore on PowerPC targets in that case it is only safe to use &#8216;<SAMP><SPAN class=samp>m&lt;&gt;</SPAN></SAMP>&#8217; in an <CODE>asm</CODE> statement if that <CODE>asm</CODE> statement accesses the operand exactly once. The <CODE>asm</CODE> statement must also use &#8216;<SAMP><SPAN class=samp>%U</SPAN><VAR>&lt;opno&gt;</VAR></SAMP>&#8217; as a placeholder for the &#8220;update&#8221; flag in the corresponding load or store instruction. For example: <PRE class=smallexample>               asm ("st%U0 %1,%0" : "=m&lt;&gt;" (mem) : "r" (val));
</PRE>
<P>is correct but: </P><PRE class=smallexample>               asm ("st %1,%0" : "=m&lt;&gt;" (mem) : "r" (val));
</PRE>
<P>is not. <BR></P></DD>
<DT><CODE>es</CODE></DT>
<DD>A &#8220;stable&#8221; memory operand; that is, one which does not include any automodification of the base register. This used to be useful when &#8216;<SAMP><SPAN class=samp>m</SPAN></SAMP>&#8217; allowed automodification of the base register, but as those are now only allowed when &#8216;<SAMP><SPAN class=samp>&lt;</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>&gt;</SPAN></SAMP>&#8217; is used, &#8216;<SAMP><SPAN class=samp>es</SPAN></SAMP>&#8217; is basically the same as &#8216;<SAMP><SPAN class=samp>m</SPAN></SAMP>&#8217; without &#8216;<SAMP><SPAN class=samp>&lt;</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>&gt;</SPAN></SAMP>&#8217;. <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>Memory operand that is an offset from a register (it is usually better to use &#8216;<SAMP><SPAN class=samp>m</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>es</SPAN></SAMP>&#8217; in <CODE>asm</CODE> statements) <BR></DD>
<DT><CODE>Z</CODE></DT>
<DD>Memory operand that is an indexed or indirect from a register (it is usually better to use &#8216;<SAMP><SPAN class=samp>m</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>es</SPAN></SAMP>&#8217; in <CODE>asm</CODE> statements) <BR></DD>
<DT><CODE>R</CODE></DT>
<DD>AIX TOC entry <BR></DD>
<DT><CODE>a</CODE></DT>
<DD>Address operand that is an indexed or indirect from a register (&#8216;<SAMP><SPAN class=samp>p</SPAN></SAMP>&#8217; is preferable for <CODE>asm</CODE> statements) <BR></DD>
<DT><CODE>U</CODE></DT>
<DD>System V Release 4 small data area reference <BR></DD>
<DT><CODE>W</CODE></DT>
<DD>Vector constant that does not require memory <BR></DD>
<DT><CODE>j</CODE></DT>
<DD>Vector constant that is all zeros. </DD></DL><BR></DD>
<DT><EM>RL78&#8212;</EM><SAMP><SPAN class=file>config/rl78/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>Int3</CODE></DT>
<DD>An integer constant in the range 1 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 7. <BR></DD>
<DT><CODE>Int8</CODE></DT>
<DD>An integer constant in the range 0 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 255. <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>An integer constant in the range &#8722;255 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 0 <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>The integer constant 1. <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>The integer constant -1. <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>The integer constant 0. <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>The integer constant 2. <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>The integer constant -2. <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>An integer constant in the range 1 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 15. <BR></DD>
<DT><CODE>Qbi</CODE></DT>
<DD>The built-in compare types&#8211;eq, ne, gtu, ltu, geu, and leu. <BR></DD>
<DT><CODE>Qsc</CODE></DT>
<DD>The synthetic compare types&#8211;gt, lt, ge, and le. <BR></DD>
<DT><CODE>Wab</CODE></DT>
<DD>A memory reference with an absolute address. <BR></DD>
<DT><CODE>Wbc</CODE></DT>
<DD>A memory reference using <CODE>BC</CODE> as a base register, with an optional offset. <BR></DD>
<DT><CODE>Wca</CODE></DT>
<DD>A memory reference using <CODE>AX</CODE>, <CODE>BC</CODE>, <CODE>DE</CODE>, or <CODE>HL</CODE> for the address, for calls. <BR></DD>
<DT><CODE>Wcv</CODE></DT>
<DD>A memory reference using any 16-bit register pair for the address, for calls. <BR></DD>
<DT><CODE>Wd2</CODE></DT>
<DD>A memory reference using <CODE>DE</CODE> as a base register, with an optional offset. <BR></DD>
<DT><CODE>Wde</CODE></DT>
<DD>A memory reference using <CODE>DE</CODE> as a base register, without any offset. <BR></DD>
<DT><CODE>Wfr</CODE></DT>
<DD>Any memory reference to an address in the far address space. <BR></DD>
<DT><CODE>Wh1</CODE></DT>
<DD>A memory reference using <CODE>HL</CODE> as a base register, with an optional one-byte offset. <BR></DD>
<DT><CODE>Whb</CODE></DT>
<DD>A memory reference using <CODE>HL</CODE> as a base register, with <CODE>B</CODE> or <CODE>C</CODE> as the index register. <BR></DD>
<DT><CODE>Whl</CODE></DT>
<DD>A memory reference using <CODE>HL</CODE> as a base register, without any offset. <BR></DD>
<DT><CODE>Ws1</CODE></DT>
<DD>A memory reference using <CODE>SP</CODE> as a base register, with an optional one-byte offset. <BR></DD>
<DT><CODE>Y</CODE></DT>
<DD>Any memory reference to an address in the near address space. <BR></DD>
<DT><CODE>A</CODE></DT>
<DD>The <CODE>AX</CODE> register. <BR></DD>
<DT><CODE>B</CODE></DT>
<DD>The <CODE>BC</CODE> register. <BR></DD>
<DT><CODE>D</CODE></DT>
<DD>The <CODE>DE</CODE> register. <BR></DD>
<DT><CODE>R</CODE></DT>
<DD><CODE>A</CODE> through <CODE>L</CODE> registers. <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>The <CODE>SP</CODE> register. <BR></DD>
<DT><CODE>T</CODE></DT>
<DD>The <CODE>HL</CODE> register. <BR></DD>
<DT><CODE>Z08W</CODE></DT>
<DD>The 16-bit <CODE>R8</CODE> register. <BR></DD>
<DT><CODE>Z10W</CODE></DT>
<DD>The 16-bit <CODE>R10</CODE> register. <BR></DD>
<DT><CODE>Zint</CODE></DT>
<DD>The registers reserved for interrupts (<CODE>R24</CODE> to <CODE>R31</CODE>). <BR></DD>
<DT><CODE>a</CODE></DT>
<DD>The <CODE>A</CODE> register. <BR></DD>
<DT><CODE>b</CODE></DT>
<DD>The <CODE>B</CODE> register. <BR></DD>
<DT><CODE>c</CODE></DT>
<DD>The <CODE>C</CODE> register. <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>The <CODE>D</CODE> register. <BR></DD>
<DT><CODE>e</CODE></DT>
<DD>The <CODE>E</CODE> register. <BR></DD>
<DT><CODE>h</CODE></DT>
<DD>The <CODE>H</CODE> register. <BR></DD>
<DT><CODE>l</CODE></DT>
<DD>The <CODE>L</CODE> register. <BR></DD>
<DT><CODE>v</CODE></DT>
<DD>The virtual registers. <BR></DD>
<DT><CODE>w</CODE></DT>
<DD>The <CODE>PSW</CODE> register. <BR></DD>
<DT><CODE>x</CODE></DT>
<DD>The <CODE>X</CODE> register. </DD></DL><BR></DD>
<DT><EM>RX&#8212;</EM><SAMP><SPAN class=file>config/rx/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>Q</CODE></DT>
<DD>An address which does not involve register indirect addressing or pre/post increment/decrement addressing. <BR></DD>
<DT><CODE>Symbol</CODE></DT>
<DD>A symbol reference. <BR></DD>
<DT><CODE>Int08</CODE></DT>
<DD>A constant in the range &#8722;256 to 255, inclusive. <BR></DD>
<DT><CODE>Sint08</CODE></DT>
<DD>A constant in the range &#8722;128 to 127, inclusive. <BR></DD>
<DT><CODE>Sint16</CODE></DT>
<DD>A constant in the range &#8722;32768 to 32767, inclusive. <BR></DD>
<DT><CODE>Sint24</CODE></DT>
<DD>A constant in the range &#8722;8388608 to 8388607, inclusive. <BR></DD>
<DT><CODE>Uint04</CODE></DT>
<DD>A constant in the range 0 to 15, inclusive. </DD></DL><BR></DD>
<DT><EM>S/390 and zSeries&#8212;</EM><SAMP><SPAN class=file>config/s390/s390.h</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>a</CODE></DT>
<DD>Address register (general purpose register except r0) <BR></DD>
<DT><CODE>c</CODE></DT>
<DD>Condition code register <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>Data register (arbitrary general purpose register) <BR></DD>
<DT><CODE>f</CODE></DT>
<DD>Floating-point register <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>Unsigned 8-bit constant (0&#8211;255) <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Unsigned 12-bit constant (0&#8211;4095) <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Signed 16-bit constant (&#8722;32768&#8211;32767) <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Value appropriate as displacement. 
<DL>
<DT><CODE>(0..4095)</CODE></DT>
<DD>for short displacement <BR></DD>
<DT><CODE>(&#8722;524288..524287)</CODE></DT>
<DD>for long displacement </DD></DL><BR></DD>
<DT><CODE>M</CODE></DT>
<DD>Constant integer with a value of 0x7fffffff. <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>Multiple letter constraint followed by 4 parameter letters. 
<DL>
<DT><CODE>0..9:</CODE></DT>
<DD>number of the part counting from most to least significant <BR></DD>
<DT><CODE>H,Q:</CODE></DT>
<DD>mode of the part <BR></DD>
<DT><CODE>D,S,H:</CODE></DT>
<DD>mode of the containing operand <BR></DD>
<DT><CODE>0,F:</CODE></DT>
<DD>value of the other parts (F&#8212;all bits set) </DD></DL>The constraint matches if the specified part of a constant has a value different from its other parts. <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>Memory reference without index register and with short displacement. <BR></DD>
<DT><CODE>R</CODE></DT>
<DD>Memory reference with index register and short displacement. <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>Memory reference without index register but with long displacement. <BR></DD>
<DT><CODE>T</CODE></DT>
<DD>Memory reference with index register and long displacement. <BR></DD>
<DT><CODE>U</CODE></DT>
<DD>Pointer with short displacement. <BR></DD>
<DT><CODE>W</CODE></DT>
<DD>Pointer with long displacement. <BR></DD>
<DT><CODE>Y</CODE></DT>
<DD>Shift count operand. </DD></DL><BR></DD>
<DT><EM>SPARC&#8212;</EM><SAMP><SPAN class=file>config/sparc/sparc.h</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>f</CODE></DT>
<DD>Floating-point register on the SPARC-V8 architecture and lower floating-point register on the SPARC-V9 architecture. <BR></DD>
<DT><CODE>e</CODE></DT>
<DD>Floating-point register. It is equivalent to &#8216;<SAMP><SPAN class=samp>f</SPAN></SAMP>&#8217; on the SPARC-V8 architecture and contains both lower and upper floating-point registers on the SPARC-V9 architecture. <BR></DD>
<DT><CODE>c</CODE></DT>
<DD>Floating-point condition code register. <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>Lower floating-point register. It is only valid on the SPARC-V9 architecture when the Visual Instruction Set is available. <BR></DD>
<DT><CODE>b</CODE></DT>
<DD>Floating-point register. It is only valid on the SPARC-V9 architecture when the Visual Instruction Set is available. <BR></DD>
<DT><CODE>h</CODE></DT>
<DD>64-bit global or out register for the SPARC-V8+ architecture. <BR></DD>
<DT><CODE>C</CODE></DT>
<DD>The constant all-ones, for floating-point. <BR></DD>
<DT><CODE>A</CODE></DT>
<DD>Signed 5-bit constant <BR></DD>
<DT><CODE>D</CODE></DT>
<DD>A vector constant <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>Signed 13-bit constant <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Zero <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>32-bit constant with the low 12 bits clear (a constant that can be loaded with the <CODE>sethi</CODE> instruction) <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>A constant in the range supported by <CODE>movcc</CODE> instructions (11-bit signed immediate) <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>A constant in the range supported by <CODE>movrcc</CODE> instructions (10-bit signed immediate) <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>Same as &#8216;<SAMP><SPAN class=samp>K</SPAN></SAMP>&#8217;, except that it verifies that bits that are not in the lower 32-bit range are all zero. Must be used instead of &#8216;<SAMP><SPAN class=samp>K</SPAN></SAMP>&#8217; for modes wider than <CODE>SImode</CODE> <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>The constant 4096 <BR></DD>
<DT><CODE>G</CODE></DT>
<DD>Floating-point zero <BR></DD>
<DT><CODE>H</CODE></DT>
<DD>Signed 13-bit constant, sign-extended to 32 or 64 bits <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>The constant -1 <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>Floating-point constant whose integral representation can be moved into an integer register using a single sethi instruction <BR></DD>
<DT><CODE>R</CODE></DT>
<DD>Floating-point constant whose integral representation can be moved into an integer register using a single mov instruction <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>Floating-point constant whose integral representation can be moved into an integer register using a high/lo_sum instruction sequence <BR></DD>
<DT><CODE>T</CODE></DT>
<DD>Memory address aligned to an 8-byte boundary <BR></DD>
<DT><CODE>U</CODE></DT>
<DD>Even register <BR></DD>
<DT><CODE>W</CODE></DT>
<DD>Memory address for &#8216;<SAMP><SPAN class=samp>e</SPAN></SAMP>&#8217; constraint registers <BR></DD>
<DT><CODE>w</CODE></DT>
<DD>Memory address with only a base register <BR></DD>
<DT><CODE>Y</CODE></DT>
<DD>Vector zero </DD></DL><BR></DD>
<DT><EM>SPU&#8212;</EM><SAMP><SPAN class=file>config/spu/spu.h</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>a</CODE></DT>
<DD>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 64 bit value. <BR></DD>
<DT><CODE>c</CODE></DT>
<DD>An immediate for and/xor/or instructions. const_int is treated as a 64 bit value. <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>An immediate for the <CODE>iohl</CODE> instruction. const_int is treated as a 64 bit value. <BR></DD>
<DT><CODE>f</CODE></DT>
<DD>An immediate which can be loaded with <CODE>fsmbi</CODE>. <BR></DD>
<DT><CODE>A</CODE></DT>
<DD>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 32 bit value. <BR></DD>
<DT><CODE>B</CODE></DT>
<DD>An immediate for most arithmetic instructions. const_int is treated as a 32 bit value. <BR></DD>
<DT><CODE>C</CODE></DT>
<DD>An immediate for and/xor/or instructions. const_int is treated as a 32 bit value. <BR></DD>
<DT><CODE>D</CODE></DT>
<DD>An immediate for the <CODE>iohl</CODE> instruction. const_int is treated as a 32 bit value. <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>A constant in the range [&#8722;64, 63] for shift/rotate instructions. <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>An unsigned 7-bit constant for conversion/nop/channel instructions. <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>A signed 10-bit constant for most arithmetic instructions. <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>A signed 16 bit immediate for <CODE>stop</CODE>. <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>An unsigned 16-bit constant for <CODE>iohl</CODE> and <CODE>fsmbi</CODE>. <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>An unsigned 7-bit constant whose 3 least significant bits are 0. <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>An unsigned 3-bit constant for 16-byte rotates and shifts <BR></DD>
<DT><CODE>R</CODE></DT>
<DD>Call operand, reg, for indirect calls <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>Call operand, symbol, for relative calls. <BR></DD>
<DT><CODE>T</CODE></DT>
<DD>Call operand, const_int, for absolute calls. <BR></DD>
<DT><CODE>U</CODE></DT>
<DD>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is sign extended to 128 bit. <BR></DD>
<DT><CODE>W</CODE></DT>
<DD>An immediate for shift and rotate instructions. const_int is treated as a 32 bit value. <BR></DD>
<DT><CODE>Y</CODE></DT>
<DD>An immediate for and/xor/or instructions. const_int is sign extended as a 128 bit. <BR></DD>
<DT><CODE>Z</CODE></DT>
<DD>An immediate for the <CODE>iohl</CODE> instruction. const_int is sign extended to 128 bit. </DD></DL><BR></DD>
<DT><EM>TI C6X family&#8212;</EM><SAMP><SPAN class=file>config/c6x/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>a</CODE></DT>
<DD>Register file A (A0&#8211;A31). <BR></DD>
<DT><CODE>b</CODE></DT>
<DD>Register file B (B0&#8211;B31). <BR></DD>
<DT><CODE>A</CODE></DT>
<DD>Predicate registers in register file A (A0&#8211;A2 on C64X and higher, A1 and A2 otherwise). <BR></DD>
<DT><CODE>B</CODE></DT>
<DD>Predicate registers in register file B (B0&#8211;B2). <BR></DD>
<DT><CODE>C</CODE></DT>
<DD>A call-used register in register file B (B0&#8211;B9, B16&#8211;B31). <BR></DD>
<DT><CODE>Da</CODE></DT>
<DD>Register file A, excluding predicate registers (A3&#8211;A31, plus A0 if not C64X or higher). <BR></DD>
<DT><CODE>Db</CODE></DT>
<DD>Register file B, excluding predicate registers (B3&#8211;B31). <BR></DD>
<DT><CODE>Iu4</CODE></DT>
<DD>Integer constant in the range 0 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 15. <BR></DD>
<DT><CODE>Iu5</CODE></DT>
<DD>Integer constant in the range 0 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 31. <BR></DD>
<DT><CODE>In5</CODE></DT>
<DD>Integer constant in the range &#8722;31 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 0. <BR></DD>
<DT><CODE>Is5</CODE></DT>
<DD>Integer constant in the range &#8722;16 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 15. <BR></DD>
<DT><CODE>I5x</CODE></DT>
<DD>Integer constant that can be the operand of an ADDA or a SUBA insn. <BR></DD>
<DT><CODE>IuB</CODE></DT>
<DD>Integer constant in the range 0 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 65535. <BR></DD>
<DT><CODE>IsB</CODE></DT>
<DD>Integer constant in the range &#8722;32768 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 32767. <BR></DD>
<DT><CODE>IsC</CODE></DT>
<DD>Integer constant in the range -2^20 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 2^20 - 1. <BR></DD>
<DT><CODE>Jc</CODE></DT>
<DD>Integer constant that is a valid mask for the clr instruction. <BR></DD>
<DT><CODE>Js</CODE></DT>
<DD>Integer constant that is a valid mask for the set instruction. <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>Memory location with A base register. <BR></DD>
<DT><CODE>R</CODE></DT>
<DD>Memory location with B base register. <BR></DD>
<DT><CODE>Z</CODE></DT>
<DD>Register B14 (aka DP). </DD></DL><BR></DD>
<DT><EM>TILE-Gx&#8212;</EM><SAMP><SPAN class=file>config/tilegx/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>R00</CODE></DT>
<DT><CODE>R01</CODE></DT>
<DT><CODE>R02</CODE></DT>
<DT><CODE>R03</CODE></DT>
<DT><CODE>R04</CODE></DT>
<DT><CODE>R05</CODE></DT>
<DT><CODE>R06</CODE></DT>
<DT><CODE>R07</CODE></DT>
<DT><CODE>R08</CODE></DT>
<DT><CODE>R09</CODE></DT>
<DT><CODE>R10</CODE></DT>
<DD>Each of these represents a register constraint for an individual register, from r0 to r10. <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>Signed 8-bit integer constant. <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Signed 16-bit integer constant. <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Unsigned 16-bit integer constant. <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Integer constant that fits in one signed byte when incremented by one (&#8722;129 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 126). <BR></DD>
<DT><CODE>m</CODE></DT>
<DD>Memory operand. If used together with &#8216;<SAMP><SPAN class=samp>&lt;</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>&gt;</SPAN></SAMP>&#8217;, the operand can have postincrement which requires printing with &#8216;<SAMP><SPAN class=samp>%In</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>%in</SPAN></SAMP>&#8217; on TILE-Gx. For example: <PRE class=smallexample>               asm ("st_add %I0,%1,%i0" : "=m&lt;&gt;" (*mem) : "r" (val));
</PRE><BR></DD>
<DT><CODE>M</CODE></DT>
<DD>A bit mask suitable for the BFINS instruction. <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>Integer constant that is a byte tiled out eight times. <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>The integer zero constant. <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>Integer constant that is a sign-extended byte tiled out as four shorts. <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>Integer constant that fits in one signed byte when incremented (&#8722;129 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 126), but excluding -1. <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>Integer constant that has all 1 bits consecutive and starting at bit 0. <BR></DD>
<DT><CODE>T</CODE></DT>
<DD>A 16-bit fragment of a got, tls, or pc-relative reference. <BR></DD>
<DT><CODE>U</CODE></DT>
<DD>Memory operand except postincrement. This is roughly the same as &#8216;<SAMP><SPAN class=samp>m</SPAN></SAMP>&#8217; when not used together with &#8216;<SAMP><SPAN class=samp>&lt;</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>&gt;</SPAN></SAMP>&#8217;. <BR></DD>
<DT><CODE>W</CODE></DT>
<DD>An 8-element vector constant with identical elements. <BR></DD>
<DT><CODE>Y</CODE></DT>
<DD>A 4-element vector constant with identical elements. <BR></DD>
<DT><CODE>Z0</CODE></DT>
<DD>The integer constant 0xffffffff. <BR></DD>
<DT><CODE>Z1</CODE></DT>
<DD>The integer constant 0xffffffff00000000. </DD></DL><BR></DD>
<DT><EM>TILEPro&#8212;</EM><SAMP><SPAN class=file>config/tilepro/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>R00</CODE></DT>
<DT><CODE>R01</CODE></DT>
<DT><CODE>R02</CODE></DT>
<DT><CODE>R03</CODE></DT>
<DT><CODE>R04</CODE></DT>
<DT><CODE>R05</CODE></DT>
<DT><CODE>R06</CODE></DT>
<DT><CODE>R07</CODE></DT>
<DT><CODE>R08</CODE></DT>
<DT><CODE>R09</CODE></DT>
<DT><CODE>R10</CODE></DT>
<DD>Each of these represents a register constraint for an individual register, from r0 to r10. <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>Signed 8-bit integer constant. <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Signed 16-bit integer constant. <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Nonzero integer constant with low 16 bits zero. <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Integer constant that fits in one signed byte when incremented by one (&#8722;129 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 126). <BR></DD>
<DT><CODE>m</CODE></DT>
<DD>Memory operand. If used together with &#8216;<SAMP><SPAN class=samp>&lt;</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>&gt;</SPAN></SAMP>&#8217;, the operand can have postincrement which requires printing with &#8216;<SAMP><SPAN class=samp>%In</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>%in</SPAN></SAMP>&#8217; on TILEPro. For example: <PRE class=smallexample>               asm ("swadd %I0,%1,%i0" : "=m&lt;&gt;" (mem) : "r" (val));
</PRE><BR></DD>
<DT><CODE>M</CODE></DT>
<DD>A bit mask suitable for the MM instruction. <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>Integer constant that is a byte tiled out four times. <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>The integer zero constant. <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>Integer constant that is a sign-extended byte tiled out as two shorts. <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>Integer constant that fits in one signed byte when incremented (&#8722;129 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 126), but excluding -1. <BR></DD>
<DT><CODE>T</CODE></DT>
<DD>A symbolic operand, or a 16-bit fragment of a got, tls, or pc-relative reference. <BR></DD>
<DT><CODE>U</CODE></DT>
<DD>Memory operand except postincrement. This is roughly the same as &#8216;<SAMP><SPAN class=samp>m</SPAN></SAMP>&#8217; when not used together with &#8216;<SAMP><SPAN class=samp>&lt;</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>&gt;</SPAN></SAMP>&#8217;. <BR></DD>
<DT><CODE>W</CODE></DT>
<DD>A 4-element vector constant with identical elements. <BR></DD>
<DT><CODE>Y</CODE></DT>
<DD>A 2-element vector constant with identical elements. </DD></DL><BR></DD>
<DT><EM>Visium&#8212;</EM><SAMP><SPAN class=file>config/visium/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>b</CODE></DT>
<DD>EAM register <CODE>mdb</CODE> <BR></DD>
<DT><CODE>c</CODE></DT>
<DD>EAM register <CODE>mdc</CODE> <BR></DD>
<DT><CODE>f</CODE></DT>
<DD>Floating point register <BR></DD>
<DT><CODE>l</CODE></DT>
<DD>General register, but not <CODE>r29</CODE>, <CODE>r30</CODE> and <CODE>r31</CODE> <BR></DD>
<DT><CODE>t</CODE></DT>
<DD>Register <CODE>r1</CODE> <BR></DD>
<DT><CODE>u</CODE></DT>
<DD>Register <CODE>r2</CODE> <BR></DD>
<DT><CODE>v</CODE></DT>
<DD>Register <CODE>r3</CODE> <BR></DD>
<DT><CODE>G</CODE></DT>
<DD>Floating-point constant 0.0 <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Integer constant in the range 0 .. 65535 (16-bit immediate) <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Integer constant in the range 1 .. 31 (5-bit immediate) <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Integer constant in the range &#8722;65535 .. &#8722;1 (16-bit negative immediate) <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>Integer constant &#8722;1 <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>Integer constant 0 <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>Integer constant 32 </DD></DL><BR></DD>
<DT><EM>x86 family&#8212;</EM><SAMP><SPAN class=file>config/i386/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>R</CODE></DT>
<DD>Legacy register&#8212;the eight integer registers available on all i386 processors (<CODE>a</CODE>, <CODE>b</CODE>, <CODE>c</CODE>, <CODE>d</CODE>, <CODE>si</CODE>, <CODE>di</CODE>, <CODE>bp</CODE>, <CODE>sp</CODE>). <BR></DD>
<DT><CODE>q</CODE></DT>
<DD>Any register accessible as <VAR>r</VAR><CODE>l</CODE>. In 32-bit mode, <CODE>a</CODE>, <CODE>b</CODE>, <CODE>c</CODE>, and <CODE>d</CODE>; in 64-bit mode, any integer register. <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>Any register accessible as <VAR>r</VAR><CODE>h</CODE>: <CODE>a</CODE>, <CODE>b</CODE>, <CODE>c</CODE>, and <CODE>d</CODE>. <BR></DD>
<DT><CODE>a</CODE></DT>
<DD>The <CODE>a</CODE> register. <BR></DD>
<DT><CODE>b</CODE></DT>
<DD>The <CODE>b</CODE> register. <BR></DD>
<DT><CODE>c</CODE></DT>
<DD>The <CODE>c</CODE> register. <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>The <CODE>d</CODE> register. <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>The <CODE>si</CODE> register. <BR></DD>
<DT><CODE>D</CODE></DT>
<DD>The <CODE>di</CODE> register. <BR></DD>
<DT><CODE>A</CODE></DT>
<DD>The <CODE>a</CODE> and <CODE>d</CODE> registers. This class is used for instructions that return double word results in the <CODE>ax:dx</CODE> register pair. Single word values will be allocated either in <CODE>ax</CODE> or <CODE>dx</CODE>. For example on i386 the following implements <CODE>rdtsc</CODE>: <PRE class=smallexample>               unsigned long long rdtsc (void)
               {
                 unsigned long long tick;
                 __asm__ __volatile__("rdtsc":"=A"(tick));
                 return tick;
               }
</PRE>
<P>This is not correct on x86-64 as it would allocate tick in either <CODE>ax</CODE> or <CODE>dx</CODE>. You have to use the following variant instead: </P><PRE class=smallexample>               unsigned long long rdtsc (void)
               {
                 unsigned int tickl, tickh;
                 __asm__ __volatile__("rdtsc":"=a"(tickl),"=d"(tickh));
                 return ((unsigned long long)tickh &lt;&lt; 32)|tickl;
               }
</PRE><BR></DD>
<DT><CODE>f</CODE></DT>
<DD>Any 80387 floating-point (stack) register. <BR></DD>
<DT><CODE>t</CODE></DT>
<DD>Top of 80387 floating-point stack (<CODE>%st(0)</CODE>). <BR></DD>
<DT><CODE>u</CODE></DT>
<DD>Second from top of 80387 floating-point stack (<CODE>%st(1)</CODE>). <BR></DD>
<DT><CODE>y</CODE></DT>
<DD>Any MMX register. <BR></DD>
<DT><CODE>x</CODE></DT>
<DD>Any SSE register. <BR></DD>
<DT><CODE>Yz</CODE></DT>
<DD>First SSE register (<CODE>%xmm0</CODE>). <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>Integer constant in the range 0 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 31, for 32-bit shifts. <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Integer constant in the range 0 <SMALL class=dots><FONT size=2>...</FONT></SMALL> 63, for 64-bit shifts. <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Signed 8-bit integer constant. <BR></DD>
<DT><CODE>L</CODE></DT>
<DD><CODE>0xFF</CODE> or <CODE>0xFFFF</CODE>, for andsi as a zero-extending move. <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>0, 1, 2, or 3 (shifts for the <CODE>lea</CODE> instruction). <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>Unsigned 8-bit integer constant (for <CODE>in</CODE> and <CODE>out</CODE> instructions). <BR></DD>
<DT><CODE>G</CODE></DT>
<DD>Standard 80387 floating point constant. <BR></DD>
<DT><CODE>C</CODE></DT>
<DD>SSE constant zero operand. <BR></DD>
<DT><CODE>e</CODE></DT>
<DD>32-bit signed integer constant, or a symbolic reference known to fit that range (for immediate operands in sign-extending x86-64 instructions). <BR></DD>
<DT><CODE>Z</CODE></DT>
<DD>32-bit unsigned integer constant, or a symbolic reference known to fit that range (for immediate operands in zero-extending x86-64 instructions). </DD></DL><BR></DD>
<DT><EM>Xstormy16&#8212;</EM><SAMP><SPAN class=file>config/stormy16/stormy16.h</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>a</CODE></DT>
<DD>Register r0. <BR></DD>
<DT><CODE>b</CODE></DT>
<DD>Register r1. <BR></DD>
<DT><CODE>c</CODE></DT>
<DD>Register r2. <BR></DD>
<DT><CODE>d</CODE></DT>
<DD>Register r8. <BR></DD>
<DT><CODE>e</CODE></DT>
<DD>Registers r0 through r7. <BR></DD>
<DT><CODE>t</CODE></DT>
<DD>Registers r0 and r1. <BR></DD>
<DT><CODE>y</CODE></DT>
<DD>The carry register. <BR></DD>
<DT><CODE>z</CODE></DT>
<DD>Registers r8 and r9. <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>A constant between 0 and 3 inclusive. <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>A constant that has exactly one bit set. <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>A constant that has exactly one bit clear. <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>A constant between 0 and 255 inclusive. <BR></DD>
<DT><CODE>M</CODE></DT>
<DD>A constant between &#8722;255 and 0 inclusive. <BR></DD>
<DT><CODE>N</CODE></DT>
<DD>A constant between &#8722;3 and 0 inclusive. <BR></DD>
<DT><CODE>O</CODE></DT>
<DD>A constant between 1 and 4 inclusive. <BR></DD>
<DT><CODE>P</CODE></DT>
<DD>A constant between &#8722;4 and &#8722;1 inclusive. <BR></DD>
<DT><CODE>Q</CODE></DT>
<DD>A memory reference that is a stack push. <BR></DD>
<DT><CODE>R</CODE></DT>
<DD>A memory reference that is a stack pop. <BR></DD>
<DT><CODE>S</CODE></DT>
<DD>A memory reference that refers to a constant address of known value. <BR></DD>
<DT><CODE>T</CODE></DT>
<DD>The register indicated by Rx (not implemented yet). <BR></DD>
<DT><CODE>U</CODE></DT>
<DD>A constant that is not between 2 and 15 inclusive. <BR></DD>
<DT><CODE>Z</CODE></DT>
<DD>The constant 0. </DD></DL><BR></DD>
<DT><EM>Xtensa&#8212;</EM><SAMP><SPAN class=file>config/xtensa/constraints.md</SPAN></SAMP></DT>
<DD>
<DL>
<DT><CODE>a</CODE></DT>
<DD>General-purpose 32-bit register <BR></DD>
<DT><CODE>b</CODE></DT>
<DD>One-bit boolean register <BR></DD>
<DT><CODE>A</CODE></DT>
<DD>MAC16 40-bit accumulator register <BR></DD>
<DT><CODE>I</CODE></DT>
<DD>Signed 12-bit integer constant, for use in MOVI instructions <BR></DD>
<DT><CODE>J</CODE></DT>
<DD>Signed 8-bit integer constant, for use in ADDI instructions <BR></DD>
<DT><CODE>K</CODE></DT>
<DD>Integer constant valid for BccI instructions <BR></DD>
<DT><CODE>L</CODE></DT>
<DD>Unsigned constant valid for BccUI instructions </DD></DL></DD></DL>