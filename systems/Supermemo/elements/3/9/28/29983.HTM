<H5 class=subsubsection>6.44.3.3 Constraint Modifier Characters</H5>
<P><A name=index-modifiers-in-constraints-3695></A><A name=index-constraint-modifier-characters-3696></A>Here are constraint modifier characters. <A name=index-g_t_0040samp_007b_003d_007d-in-constraint-3697></A></P>
<DL>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>Means that this operand is written to by this instruction: the previous value is discarded and replaced by new data.</FONT> 
<P><A name=index-g_t_0040samp_007b_002b_007d-in-constraint-3698></A><BR></P>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>+</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>Means that this operand is both read and written by the instruction. </FONT>
<P><FONT class=extract>When the compiler fixes up the operands to satisfy the constraints, it needs to know which operands are read by the instruction and which are written by it. &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217; identifies an operand which is only written; &#8216;<SAMP><SPAN class=samp>+</SPAN></SAMP>&#8217; identifies an operand that is both read and written; all other operands are assumed to only be read. </FONT></P>
<P><FONT class=extract>If you specify &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>+</SPAN></SAMP>&#8217; in a constraint, you put it in the first character of the constraint string.</FONT> </P>
<P><A name=index-g_t_0040samp_007b_0026_007d-in-constraint-3699></A><A name=index-earlyclobber-operand-3700></A><BR></P>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>&amp;</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>Means (in a particular alternative) that this operand is an <DFN>earlyclobber</DFN> operand, which is written before the instruction is finished using the input operands. Therefore, this operand may not lie in a register that is read by the instruction or as part of any memory address. </FONT>
<P><FONT class=extract>&#8216;<SAMP><SPAN class=samp>&amp;</SPAN></SAMP>&#8217; applies only to the alternative in which it is written. In constraints with multiple alternatives, sometimes one alternative requires &#8216;<SAMP><SPAN class=samp>&amp;</SPAN></SAMP>&#8217; while others do not. See, for example, the &#8216;<SAMP><SPAN class=samp>movdf</SPAN></SAMP>&#8217; insn of the 68000. </FONT></P>
<P><FONT class=extract>A operand which is read by the instruction can be tied to an earlyclobber operand if its only use as an input occurs before the early result is written. Adding alternatives of this form often allows GCC to produce better code when only some of the read operands can be affected by the earlyclobber. See, for example, the &#8216;<SAMP><SPAN class=samp>mulsi3</SPAN></SAMP>&#8217; insn of the ARM. </FONT></P>
<P><FONT class=extract>Furthermore, if the <DFN>earlyclobber</DFN> operand is also a read/write operand, then that operand is written only after it's used. </FONT></P>
<P><FONT class=extract>&#8216;<SAMP><SPAN class=samp>&amp;</SPAN></SAMP>&#8217; does not obviate the need to write &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>+</SPAN></SAMP>&#8217;. As <DFN>earlyclobber</DFN> operands are always written, a read-only <DFN>earlyclobber</DFN> operand is ill-formed and will be rejected by the compiler.</FONT> </P>
<P><A name=index-g_t_0040samp_007b_0025_007d-in-constraint-3701></A><BR></P>
<DT><FONT class=extract>&#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; </FONT>
<DD><FONT class=extract>Declares the instruction to be commutative for this operand and the following operand. This means that the compiler may interchange the two operands if that is the cheapest way to make all operands fit the constraints. &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; applies to all alternatives and must appear as the first character in the constraint. Only read-only operands can use &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;. </FONT>
<P><FONT class=extract>GCC can only handle one commutative pair in an asm; if you use more, the compiler may fail. Note that you need not use the modifier if the two alternatives are strictly identical; this would only waste time in the reload pass.</FONT> </P></DD></DL>