<H5 class=subsubsection>6.44.5.1 Defining Global Register Variables</H5>
<P><A name=Global-Reg-Vars></A><A name=index-global-register-variables-3710></A><A name=index-registers_002c-global-variables-in-3711></A><A name=index-registers_002c-global-allocation-3712></A>You can define a global register variable and associate it with a specified register like this: </P><PRE class=smallexample>     register int *foo asm ("r12");
</PRE>
<P class=noindent>Here <CODE>r12</CODE> is the name of the register that should be used. Note that this is the same syntax used for defining local register variables, but for a global variable the declaration appears outside a function. The <CODE>register</CODE> keyword is required, and cannot be combined with <CODE>static</CODE>. The register name must be a valid register name for the target platform. </P>
<P>Registers are a scarce resource on most systems and allowing the compiler to manage their usage usually results in the best code. However, under special circumstances it can make sense to reserve some globally. For example this may be useful in programs such as programming language interpreters that have a couple of global variables that are accessed very often. </P>
<P>After defining a global register variable, for the current compilation unit: </P>
<UL>
<LI>The register is reserved entirely for this use, and will not be allocated for any other purpose. </LI>
<LI>The register is not saved and restored by any functions. </LI>
<LI>Stores into this register are never deleted even if they appear to be dead, but references may be deleted, moved or simplified. </LI></UL>
<P>Note that these points <EM>only</EM> apply to code that is compiled with the definition. The behavior of code that is merely linked in (for example code from libraries) is not affected. </P>
<P>If you want to recompile source files that do not actually use your global register variable so they do not use the specified register for any other purpose, you need not actually add the global register declaration to their source code. It suffices to specify the compiler option <SAMP><SPAN class=option>-ffixed-</SPAN><VAR>reg</VAR></SAMP> (see <A href="https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html#Code-Gen-Options">Code Gen Options</A>) to reserve the register. </P>
<H5 class=subsubheading>Declaring the variable</H5>
<P>Global register variables can not have initial values, because an executable file has no means to supply initial contents for a register. </P>
<P>When selecting a register, choose one that is normally saved and restored by function calls on your machine. This ensures that code which is unaware of this reservation (such as library routines) will restore it before returning. </P>
<P>On machines with register windows, be sure to choose a global register that is not affected magically by the function call mechanism. </P>
<H5 class=subsubheading>Using the variable</H5>
<P><A name=index-g_t_0040code_007bqsort_007d_002c-and-global-register-variables-3713></A>When calling routines that are not aware of the reservation, be cautious if those routines call back into code which uses them. As an example, if you call the system library version of <CODE>qsort</CODE>, it may clobber your registers during execution, but (if you have selected appropriate registers) it will restore them before returning. However it will <EM>not</EM> restore them before calling <CODE>qsort</CODE>'s comparison function. As a result, global values will not reliably be available to the comparison function unless the <CODE>qsort</CODE> function itself is rebuilt. </P>
<P>Similarly, it is not safe to access the global register variables from signal handlers or from more than one thread of control. Unless you recompile them specially for the task at hand, the system library routines may temporarily use the register for other things. </P>
<P><A name=index-register-variable-after-_0040code_007blongjmp_007d-3714></A><A name=index-global-register-after-_0040code_007blongjmp_007d-3715></A><A name=index-value-after-_0040code_007blongjmp_007d-3716></A><A name=index-longjmp-3717></A><A name=index-setjmp-3718></A>On most machines, <CODE>longjmp</CODE> restores to each global register variable the value it had at the time of the <CODE>setjmp</CODE>. On some machines, however, <CODE>longjmp</CODE> does not change the value of global register variables. To be portable, the function that called <CODE>setjmp</CODE> should make other arrangements to save the values of the global register variables, and to restore them in a <CODE>longjmp</CODE>. This way, the same thing happens regardless of what <CODE>longjmp</CODE> does. </P>
<P>Eventually there may be a way of asking the compiler to choose a register automatically, but first we need to figure out how it should choose and how to enable you to guide the choice. No solution is evident.