<H5 class=subsubsection>6.44.3.2 Multiple Alternative Constraints</H5>
<P><A name=index-multiple-alternative-constraints-3694></A>Sometimes a single instruction has multiple alternative sets of possible operands. For example, on the 68000, a logical-or instruction can combine register or an immediate value into memory, or it can combine any kind of operand into a register; but it cannot combine one memory location into another. </P>
<P>These constraints are represented as multiple alternatives. An alternative can be described by a series of letters for each operand. The overall constraint for an operand is made from the letters for this operand from the first alternative, a comma, the letters for this operand from the second alternative, a comma, and so on until the last alternative. All operands for a single instruction must have the same number of alternatives. </P>
<P>So the first alternative for the 68000's logical-or could be written as <CODE>"+m" (output) : "ir" (input)</CODE>. The second could be <CODE>"+r" (output): "irm" (input)</CODE>. However, the fact that two memory locations cannot be used in a single instruction prevents simply using <CODE>"+rm" (output) : "irm" (input)</CODE>. Using multi-alternatives, this might be written as <CODE>"+m,r" (output) : "ir,irm" (input)</CODE>. This describes all the available alternatives to the compiler, allowing it to choose the most efficient one for the current conditions. </P>
<P>There is no way within the template to determine which alternative was chosen. However you may be able to wrap your <CODE>asm</CODE> statements with builtins such as <CODE>__builtin_constant_p</CODE> to achieve the desired results.