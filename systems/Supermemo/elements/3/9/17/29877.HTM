// Assignment form<BR>MemA_with_priv[bits(32) address, integer size, boolean privileged] = bits(8*size) value</P>
<P>&nbsp;&nbsp;&nbsp; // Sort out alignment<BR>&nbsp;&nbsp;&nbsp; if address != Align(address, size) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.UNALIGNED = &#8217;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // default address map or MPU<BR>&nbsp;&nbsp;&nbsp; memaddrdesc = ValidateAddress(address, privileged, TRUE, FALSE);<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // Effect on exclusives<BR>&nbsp;&nbsp;&nbsp; if memaddrdesc.memattrs.shareable then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearExclusiveByAddress(memaddrdesc.physicaladdress, ProcessorID(), size);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // Sort out endianness, then memory array access<BR>&nbsp;&nbsp;&nbsp; if AIRCR.ENDIANNESS == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = BigEndianReverse(value, size);<BR>&nbsp;&nbsp;&nbsp; _Mem[memaddrdesc,size] = value;<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; return;