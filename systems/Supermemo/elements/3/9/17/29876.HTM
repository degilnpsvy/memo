// Non-assignment form<BR>bits(8*size) MemA_with_priv[bits(32) address, integer size, boolean privileged] 
<P></P>
<P>&nbsp;&nbsp;&nbsp; // Sort out alignment<BR>&nbsp;&nbsp;&nbsp; if address != Align(address, size) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.UNALIGNED = &#8217;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault);</P>
<P>&nbsp;&nbsp;&nbsp; // default address map or MPU<BR>&nbsp;&nbsp;&nbsp; memaddrdesc = ValidateAddress(address, privileged, FALSE, FALSE);</P>
<P>&nbsp;&nbsp;&nbsp; // Memory array access, and sort out endianness<BR>&nbsp;&nbsp;&nbsp; value = _Mem[memaddrdesc, size];<BR>&nbsp;&nbsp;&nbsp; if AIRCR.ENDIANNESS == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = BigEndianReverse(value, size);<BR>&nbsp;&nbsp;&nbsp; return value;