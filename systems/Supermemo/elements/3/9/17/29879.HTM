// Non-assignment form 
<P></P>
<P>bits(8*size) MemU_with_priv[bits(32) address, integer size, boolean privileged]</P>
<P>&nbsp;&nbsp;&nbsp; bits(8*size) value;<BR>&nbsp;&nbsp;&nbsp; // Do aligned access, take alignment fault, or do sequence of bytes<BR>&nbsp;&nbsp;&nbsp; if address == Align(address, size) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = MemA_with_priv[address, size, privileged];<BR>&nbsp;&nbsp;&nbsp; elsif<FONT class=clozed> CCR.UNALIGN_TRP == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.UNALIGNED = &#8217;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault)</FONT>;<BR>&nbsp;&nbsp;&nbsp; else // if unaligned access<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i = 0 to size-1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value&lt;8*i+7:8*i&gt; = MemA_with_priv[address+i, 1, privileged];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if AIRCR.ENDIANNESS == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = BigEndianReverse(value, size);<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; return value;