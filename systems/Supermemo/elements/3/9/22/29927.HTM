/* Constants for qemu_ld and qemu_st for the Memory Operation field.&nbsp; */<BR>typedef enum TCGMemOp {<BR>&nbsp;&nbsp;&nbsp; MO_8&nbsp;&nbsp;&nbsp;&nbsp; = 0,<BR>&nbsp;&nbsp;&nbsp; MO_16&nbsp;&nbsp;&nbsp; = 1,<BR>&nbsp;&nbsp;&nbsp; MO_32&nbsp;&nbsp;&nbsp; = 2,<BR>&nbsp;&nbsp;&nbsp; MO_64&nbsp;&nbsp;&nbsp; = 3,<BR>&nbsp;&nbsp;&nbsp; MO_SIZE&nbsp; = 3,&nbsp;&nbsp; /* Mask for the above.&nbsp; */ 
<P></P>
<P>&nbsp;&nbsp;&nbsp; MO_SIGN&nbsp; = 4,&nbsp;&nbsp; /* Sign-extended, otherwise zero-extended.&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp; MO_BSWAP = 8,&nbsp;&nbsp; /* Host reverse endian.&nbsp; */<BR>#ifdef HOST_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp; MO_LE&nbsp;&nbsp;&nbsp; = MO_BSWAP,<BR>&nbsp;&nbsp;&nbsp; MO_BE&nbsp;&nbsp;&nbsp; = 0,<BR>#else<BR>&nbsp;&nbsp;&nbsp; MO_LE&nbsp;&nbsp;&nbsp; = 0,<BR>&nbsp;&nbsp;&nbsp; MO_BE&nbsp;&nbsp;&nbsp; = MO_BSWAP,<BR>#endif<BR>#ifdef TARGET_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp; MO_TE&nbsp;&nbsp;&nbsp; = MO_BE,<BR>#else<BR>&nbsp;&nbsp;&nbsp; MO_TE&nbsp;&nbsp;&nbsp; = MO_LE,<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; /* MO_UNALN accesses are never checked for alignment.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * MO_ALIGN accesses will result in a call to the CPU's<BR>&nbsp;&nbsp;&nbsp;&nbsp; * do_unaligned_access hook if the guest address is not aligned.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * The default depends on whether the target CPU defines ALIGNED_ONLY.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Some architectures (e.g. ARMv8) need the address which is aligned<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to a size more than the size of the memory access.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * To support such check it's enough the current costless alignment<BR>&nbsp;&nbsp;&nbsp;&nbsp; * check implementation in QEMU, but we need to support<BR>&nbsp;&nbsp;&nbsp;&nbsp; * an alignment size specifying.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * MO_ALIGN supposes a natural alignment<BR>&nbsp;&nbsp;&nbsp;&nbsp; * (i.e. the alignment size is the size of a memory access).<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Note that an alignment size must be equal or greater<BR>&nbsp;&nbsp;&nbsp;&nbsp; * than an access size.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * There are three options:<BR>&nbsp;&nbsp;&nbsp;&nbsp; * - an alignment to the size of an access (MO_ALIGN);<BR>&nbsp;&nbsp;&nbsp;&nbsp; * - an alignment to the specified size that is equal or greater than<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; an access size (MO_ALIGN_x where 'x' is a size in bytes);<BR>&nbsp;&nbsp;&nbsp;&nbsp; * - unaligned access permitted (MO_UNALN).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; MO_ASHIFT = 4,<BR>&nbsp;&nbsp;&nbsp; MO_AMASK = 7 &lt;&lt; MO_ASHIFT,<BR>#ifdef ALIGNED_ONLY<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN = 0,<BR>&nbsp;&nbsp;&nbsp; MO_UNALN = MO_AMASK,<BR>#else<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN = MO_AMASK,<BR>&nbsp;&nbsp;&nbsp; MO_UNALN = 0,<BR>#endif<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN_2&nbsp; = 1 &lt;&lt; MO_ASHIFT,<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN_4&nbsp; = 2 &lt;&lt; MO_ASHIFT,<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN_8&nbsp; = 3 &lt;&lt; MO_ASHIFT,<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN_16 = 4 &lt;&lt; MO_ASHIFT,<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN_32 = 5 &lt;&lt; MO_ASHIFT,<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN_64 = 6 &lt;&lt; MO_ASHIFT,</P>
<P>&nbsp;&nbsp;&nbsp; /* Combinations of the above, for ease of use.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; MO_UB&nbsp;&nbsp;&nbsp; = MO_8,<BR>&nbsp;&nbsp;&nbsp; MO_UW&nbsp;&nbsp;&nbsp; = MO_16,<BR>&nbsp;&nbsp;&nbsp; MO_UL&nbsp;&nbsp;&nbsp; = MO_32,<BR>&nbsp;&nbsp;&nbsp; MO_SB&nbsp;&nbsp;&nbsp; = MO_SIGN | MO_8,<BR>&nbsp;&nbsp;&nbsp; MO_SW&nbsp;&nbsp;&nbsp; = MO_SIGN | MO_16,<BR>&nbsp;&nbsp;&nbsp; MO_SL&nbsp;&nbsp;&nbsp; = MO_SIGN | MO_32,<BR>&nbsp;&nbsp;&nbsp; MO_Q&nbsp;&nbsp;&nbsp;&nbsp; = MO_64,</P>
<P>&nbsp;&nbsp;&nbsp; MO_LEUW&nbsp; = MO_LE | MO_UW,<BR>&nbsp;&nbsp;&nbsp; MO_LEUL&nbsp; = MO_LE | MO_UL,<BR>&nbsp;&nbsp;&nbsp; MO_LESW&nbsp; = MO_LE | MO_SW,<BR>&nbsp;&nbsp;&nbsp; MO_LESL&nbsp; = MO_LE | MO_SL,<BR>&nbsp;&nbsp;&nbsp; MO_LEQ&nbsp;&nbsp; = MO_LE | MO_Q,</P>
<P>&nbsp;&nbsp;&nbsp; MO_BEUW&nbsp; = MO_BE | MO_UW,<BR>&nbsp;&nbsp;&nbsp; MO_BEUL&nbsp; = MO_BE | MO_UL,<BR>&nbsp;&nbsp;&nbsp; MO_BESW&nbsp; = MO_BE | MO_SW,<BR>&nbsp;&nbsp;&nbsp; MO_BESL&nbsp; = MO_BE | MO_SL,<BR>&nbsp;&nbsp;&nbsp; MO_BEQ&nbsp;&nbsp; = MO_BE | MO_Q,</P>
<P>&nbsp;&nbsp;&nbsp; MO_TEUW&nbsp; = MO_TE | MO_UW,<BR>&nbsp;&nbsp;&nbsp; MO_TEUL&nbsp; = MO_TE | MO_UL,<BR>&nbsp;&nbsp;&nbsp; MO_TESW&nbsp; = MO_TE | MO_SW,<BR>&nbsp;&nbsp;&nbsp; MO_TESL&nbsp; = MO_TE | MO_SL,<BR>&nbsp;&nbsp;&nbsp; MO_TEQ&nbsp;&nbsp; = MO_TE | MO_Q,</P>
<P>&nbsp;&nbsp;&nbsp; MO_SSIZE = MO_SIZE | MO_SIGN,<BR>} TCGMemOp;