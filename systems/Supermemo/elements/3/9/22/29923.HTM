#&nbsp;qemu:tcg/tcg.h 
<P></P>
<P>/*<BR>&nbsp;* Tiny Code Generator for QEMU<BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2008 Fabrice Bellard<BR>&nbsp;*<BR>&nbsp;* Permission is hereby granted, free of charge, to any person obtaining a copy<BR>&nbsp;* of this software and associated documentation files (the "Software"), to deal<BR>&nbsp;* in the Software without restriction, including without limitation the rights<BR>&nbsp;* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<BR>&nbsp;* copies of the Software, and to permit persons to whom the Software is<BR>&nbsp;* furnished to do so, subject to the following conditions:<BR>&nbsp;*<BR>&nbsp;* The above copyright notice and this permission notice shall be included in<BR>&nbsp;* all copies or substantial portions of the Software.<BR>&nbsp;*<BR>&nbsp;* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<BR>&nbsp;* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<BR>&nbsp;* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL<BR>&nbsp;* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<BR>&nbsp;* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<BR>&nbsp;* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<BR>&nbsp;* THE SOFTWARE.<BR>&nbsp;*/</P>
<P></P>
<P>#ifndef TCG_H<BR>#define TCG_H</P>
<P><FONT class=extract>#include "qemu-common.h"<BR>#include "cpu.h"<BR>#include "exec/tb-context.h"<BR>#include "qemu/bitops.h"<BR>#include "tcg-target.h"</FONT></P>
<P><FONT class=extract>/* XXX: make safe guess about sizes */<BR>#define MAX_OP_PER_INSTR 266</FONT></P>
<P><FONT class=extract>#if HOST_LONG_BITS == 32<BR>#define MAX_OPC_PARAM_PER_ARG 2<BR>#else<BR>#define MAX_OPC_PARAM_PER_ARG 1<BR>#endif<BR>#define MAX_OPC_PARAM_IARGS 5<BR>#define MAX_OPC_PARAM_OARGS 1<BR>#define MAX_OPC_PARAM_ARGS (MAX_OPC_PARAM_IARGS + MAX_OPC_PARAM_OARGS)</FONT></P>
<P><FONT class=extract>/* A Call op needs up to 4 + 2N parameters on 32-bit archs,<BR>&nbsp;* and up to 4 + N parameters on 64-bit archs<BR>&nbsp;* (N = number of input arguments + output arguments).&nbsp; */<BR>#define MAX_OPC_PARAM (4 + (MAX_OPC_PARAM_PER_ARG * MAX_OPC_PARAM_ARGS))<BR>#define OPC_BUF_SIZE 640<BR>#define OPC_MAX_SIZE (OPC_BUF_SIZE - MAX_OP_PER_INSTR)</FONT></P>
<P><FONT class=extract>#define OPPARAM_BUF_SIZE (OPC_BUF_SIZE * MAX_OPC_PARAM)</FONT></P>
<P><FONT class=extract>#define CPU_TEMP_BUF_NLONGS 128</FONT></P>
<P><FONT class=extract>/* Default target word size to pointer size.&nbsp; */<BR>#ifndef TCG_TARGET_REG_BITS<BR># if UINTPTR_MAX == UINT32_MAX<BR>#&nbsp; define TCG_TARGET_REG_BITS 32<BR># elif UINTPTR_MAX == UINT64_MAX<BR>#&nbsp; define TCG_TARGET_REG_BITS 64<BR># else<BR>#&nbsp; error Unknown pointer size for tcg target<BR># endif<BR>#endif</FONT></P>
<P><FONT class=extract>#if TCG_TARGET_REG_BITS == 32<BR>typedef int32_t tcg_target_long;<BR>typedef uint32_t tcg_target_ulong;<BR>#define TCG_PRIlx PRIx32<BR>#define TCG_PRIld PRId32<BR>#elif TCG_TARGET_REG_BITS == 64<BR>typedef int64_t tcg_target_long;<BR>typedef uint64_t tcg_target_ulong;<BR>#define TCG_PRIlx PRIx64<BR>#define TCG_PRIld PRId64<BR>#else<BR>#error unsupported<BR>#endif</FONT></P>
<P><FONT class=extract>#if TCG_TARGET_NB_REGS &lt;= 32<BR>typedef uint32_t TCGRegSet;<BR>#elif TCG_TARGET_NB_REGS &lt;= 64<BR>typedef uint64_t TCGRegSet;<BR>#else<BR>#error unsupported<BR>#endif</FONT></P>
<P><FONT class=extract>#if TCG_TARGET_REG_BITS == 32<BR>/* Turn some undef macros into false macros.&nbsp; */<BR>#define TCG_TARGET_HAS_extrl_i64_i32&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_extrh_i64_i32&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_div_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_rem_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_div2_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_rot_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_ext8s_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_ext16s_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_ext32s_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_ext8u_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_ext16u_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_ext32u_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_bswap16_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_bswap32_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_bswap64_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_neg_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_not_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_andc_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_orc_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_eqv_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_nand_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_nor_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_deposit_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_movcond_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_add2_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_sub2_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_mulu2_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_muls2_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_muluh_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_mulsh_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>/* Turn some undef macros into true macros.&nbsp; */<BR>#define TCG_TARGET_HAS_add2_i32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<BR>#define TCG_TARGET_HAS_sub2_i32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef TCG_TARGET_deposit_i32_valid<BR>#define TCG_TARGET_deposit_i32_valid(ofs, len) 1<BR>#endif<BR>#ifndef TCG_TARGET_deposit_i64_valid<BR>#define TCG_TARGET_deposit_i64_valid(ofs, len) 1<BR>#endif</FONT></P>
<P><FONT class=extract>/* Only one of DIV or DIV2 should be defined.&nbsp; */<BR>#if defined(TCG_TARGET_HAS_div_i32)<BR>#define TCG_TARGET_HAS_div2_i32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#elif defined(TCG_TARGET_HAS_div2_i32)<BR>#define TCG_TARGET_HAS_div_i32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_rem_i32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#endif<BR>#if defined(TCG_TARGET_HAS_div_i64)<BR>#define TCG_TARGET_HAS_div2_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#elif defined(TCG_TARGET_HAS_div2_i64)<BR>#define TCG_TARGET_HAS_div_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define TCG_TARGET_HAS_rem_i64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#endif</FONT></P>
<P><FONT class=extract>/* For 32-bit targets, some sort of unsigned widening multiply is required.&nbsp; */<BR>#if TCG_TARGET_REG_BITS == 32 \<BR>&nbsp;&nbsp;&nbsp; &amp;&amp; !(defined(TCG_TARGET_HAS_mulu2_i32) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || defined(TCG_TARGET_HAS_muluh_i32))<BR># error "Missing unsigned widening multiply"<BR>#endif</FONT></P>
<P>#ifndef TARGET_INSN_START_EXTRA_WORDS<BR># define TARGET_INSN_START_WORDS 1<BR>#else<BR># define TARGET_INSN_START_WORDS (1 + TARGET_INSN_START_EXTRA_WORDS)<BR>#endif</P>
<P><FONT class=extract>typedef enum TCGOpcode {<BR>#define DEF(name, oargs, iargs, cargs, flags) INDEX_op_ ## name,<BR>#include "tcg-opc.h"<BR>#undef DEF<BR>&nbsp;&nbsp;&nbsp; NB_OPS,<BR>} TCGOpcode;</FONT></P>
<P>#define tcg_regset_clear(d) (d) = 0<BR>#define tcg_regset_set(d, s) (d) = (s)<BR>#define tcg_regset_set32(d, reg, val32) (d) |= (val32) &lt;&lt; (reg)<BR>#define tcg_regset_set_reg(d, r) (d) |= 1L &lt;&lt; (r)<BR>#define tcg_regset_reset_reg(d, r) (d) &amp;= ~(1L &lt;&lt; (r))<BR>#define tcg_regset_test_reg(d, r) (((d) &gt;&gt; (r)) &amp; 1)<BR>#define tcg_regset_or(d, a, b) (d) = (a) | (b)<BR>#define tcg_regset_and(d, a, b) (d) = (a) &amp; (b)<BR>#define tcg_regset_andnot(d, a, b) (d) = (a) &amp; ~(b)<BR>#define tcg_regset_not(d, a) (d) = ~(a)</P>
<P>#ifndef TCG_TARGET_INSN_UNIT_SIZE<BR># error "Missing TCG_TARGET_INSN_UNIT_SIZE"<BR>#elif TCG_TARGET_INSN_UNIT_SIZE == 1<BR>typedef uint8_t tcg_insn_unit;<BR>#elif TCG_TARGET_INSN_UNIT_SIZE == 2<BR>typedef uint16_t tcg_insn_unit;<BR>#elif TCG_TARGET_INSN_UNIT_SIZE == 4<BR>typedef uint32_t tcg_insn_unit;<BR>#elif TCG_TARGET_INSN_UNIT_SIZE == 8<BR>typedef uint64_t tcg_insn_unit;<BR>#else<BR>/* The port better have done this.&nbsp; */<BR>#endif</P>
<P><BR>#if defined CONFIG_DEBUG_TCG || defined QEMU_STATIC_ANALYSIS<BR># define tcg_debug_assert(X) do { assert(X); } while (0)<BR>#elif QEMU_GNUC_PREREQ(4, 5)<BR># define tcg_debug_assert(X) \<BR>&nbsp;&nbsp;&nbsp; do { if (!(X)) { __builtin_unreachable(); } } while (0)<BR>#else<BR># define tcg_debug_assert(X) do { (void)(X); } while (0)<BR>#endif</P>
<P>typedef struct TCGRelocation {<BR>&nbsp;&nbsp;&nbsp; struct TCGRelocation *next;<BR>&nbsp;&nbsp;&nbsp; int type;<BR>&nbsp;&nbsp;&nbsp; tcg_insn_unit *ptr;<BR>&nbsp;&nbsp;&nbsp; intptr_t addend;<BR>} TCGRelocation; </P>
<P>typedef struct TCGLabel {<BR>&nbsp;&nbsp;&nbsp; unsigned has_value : 1;<BR>&nbsp;&nbsp;&nbsp; unsigned id : 31;<BR>&nbsp;&nbsp;&nbsp; union {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uintptr_t value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_insn_unit *value_ptr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGRelocation *first_reloc;<BR>&nbsp;&nbsp;&nbsp; } u;<BR>} TCGLabel;</P>
<P><FONT class=extract>typedef struct TCGPool {<BR>&nbsp;&nbsp;&nbsp; struct TCGPool *next;<BR>&nbsp;&nbsp;&nbsp; int size;<BR>&nbsp;&nbsp;&nbsp; uint8_t data[0] __attribute__ ((aligned));<BR>} TCGPool;</FONT></P>
<P>#define TCG_POOL_CHUNK_SIZE 32768</P>
<P>#define TCG_MAX_TEMPS 512<BR>#define TCG_MAX_INSNS 512</P>
<P>/* when the size of the arguments of a called function is smaller than<BR>&nbsp;&nbsp; this value, they are statically allocated in the TB stack frame */<BR>#define TCG_STATIC_CALL_ARGS_SIZE 128</P>
<P>typedef enum TCGType {<BR>&nbsp;&nbsp;&nbsp; TCG_TYPE_I32,<BR>&nbsp;&nbsp;&nbsp; TCG_TYPE_I64,<BR>&nbsp;&nbsp;&nbsp; TCG_TYPE_COUNT, /* number of different types */</P>
<P>&nbsp;&nbsp;&nbsp; /* An alias for the size of the host register.&nbsp; */<BR>#if TCG_TARGET_REG_BITS == 32<BR>&nbsp;&nbsp;&nbsp; TCG_TYPE_REG = TCG_TYPE_I32,<BR>#else<BR>&nbsp;&nbsp;&nbsp; TCG_TYPE_REG = TCG_TYPE_I64,<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; /* An alias for the size of the native pointer.&nbsp; */<BR>#if UINTPTR_MAX == UINT32_MAX<BR>&nbsp;&nbsp;&nbsp; TCG_TYPE_PTR = TCG_TYPE_I32,<BR>#else<BR>&nbsp;&nbsp;&nbsp; TCG_TYPE_PTR = TCG_TYPE_I64,<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; /* An alias for the size of the target "long", aka register.&nbsp; */<BR>#if TARGET_LONG_BITS == 64<BR>&nbsp;&nbsp;&nbsp; TCG_TYPE_TL = TCG_TYPE_I64,<BR>#else<BR>&nbsp;&nbsp;&nbsp; TCG_TYPE_TL = TCG_TYPE_I32,<BR>#endif<BR>} TCGType;</P>
<P><FONT class=extract>/* Constants for qemu_ld and qemu_st for the Memory Operation field.&nbsp; */<BR>typedef enum TCGMemOp {<BR>&nbsp;&nbsp;&nbsp; MO_8&nbsp;&nbsp;&nbsp;&nbsp; = 0,<BR>&nbsp;&nbsp;&nbsp; MO_16&nbsp;&nbsp;&nbsp; = 1,<BR>&nbsp;&nbsp;&nbsp; MO_32&nbsp;&nbsp;&nbsp; = 2,<BR>&nbsp;&nbsp;&nbsp; MO_64&nbsp;&nbsp;&nbsp; = 3,<BR>&nbsp;&nbsp;&nbsp; MO_SIZE&nbsp; = 3,&nbsp;&nbsp; /* Mask for the above.&nbsp; */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; MO_SIGN&nbsp; = 4,&nbsp;&nbsp; /* Sign-extended, otherwise zero-extended.&nbsp; */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; MO_BSWAP = 8,&nbsp;&nbsp; /* Host reverse endian.&nbsp; */<BR>#ifdef HOST_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp; MO_LE&nbsp;&nbsp;&nbsp; = MO_BSWAP,<BR>&nbsp;&nbsp;&nbsp; MO_BE&nbsp;&nbsp;&nbsp; = 0,<BR>#else<BR>&nbsp;&nbsp;&nbsp; MO_LE&nbsp;&nbsp;&nbsp; = 0,<BR>&nbsp;&nbsp;&nbsp; MO_BE&nbsp;&nbsp;&nbsp; = MO_BSWAP,<BR>#endif<BR>#ifdef TARGET_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp; MO_TE&nbsp;&nbsp;&nbsp; = MO_BE,<BR>#else<BR>&nbsp;&nbsp;&nbsp; MO_TE&nbsp;&nbsp;&nbsp; = MO_LE,<BR>#endif</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* MO_UNALN accesses are never checked for alignment.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * MO_ALIGN accesses will result in a call to the CPU's<BR>&nbsp;&nbsp;&nbsp;&nbsp; * do_unaligned_access hook if the guest address is not aligned.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * The default depends on whether the target CPU defines ALIGNED_ONLY.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Some architectures (e.g. ARMv8) need the address which is aligned<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to a size more than the size of the memory access.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * To support such check it's enough the current costless alignment<BR>&nbsp;&nbsp;&nbsp;&nbsp; * check implementation in QEMU, but we need to support<BR>&nbsp;&nbsp;&nbsp;&nbsp; * an alignment size specifying.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * MO_ALIGN supposes a natural alignment<BR>&nbsp;&nbsp;&nbsp;&nbsp; * (i.e. the alignment size is the size of a memory access).<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Note that an alignment size must be equal or greater<BR>&nbsp;&nbsp;&nbsp;&nbsp; * than an access size.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * There are three options:<BR>&nbsp;&nbsp;&nbsp;&nbsp; * - an alignment to the size of an access (MO_ALIGN);<BR>&nbsp;&nbsp;&nbsp;&nbsp; * - an alignment to the specified size that is equal or greater than<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; an access size (MO_ALIGN_x where 'x' is a size in bytes);<BR>&nbsp;&nbsp;&nbsp;&nbsp; * - unaligned access permitted (MO_UNALN).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; MO_ASHIFT = 4,<BR>&nbsp;&nbsp;&nbsp; MO_AMASK = 7 &lt;&lt; MO_ASHIFT,<BR>#ifdef ALIGNED_ONLY<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN = 0,<BR>&nbsp;&nbsp;&nbsp; MO_UNALN = MO_AMASK,<BR>#else<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN = MO_AMASK,<BR>&nbsp;&nbsp;&nbsp; MO_UNALN = 0,<BR>#endif<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN_2&nbsp; = 1 &lt;&lt; MO_ASHIFT,<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN_4&nbsp; = 2 &lt;&lt; MO_ASHIFT,<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN_8&nbsp; = 3 &lt;&lt; MO_ASHIFT,<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN_16 = 4 &lt;&lt; MO_ASHIFT,<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN_32 = 5 &lt;&lt; MO_ASHIFT,<BR>&nbsp;&nbsp;&nbsp; MO_ALIGN_64 = 6 &lt;&lt; MO_ASHIFT,</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Combinations of the above, for ease of use.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; MO_UB&nbsp;&nbsp;&nbsp; = MO_8,<BR>&nbsp;&nbsp;&nbsp; MO_UW&nbsp;&nbsp;&nbsp; = MO_16,<BR>&nbsp;&nbsp;&nbsp; MO_UL&nbsp;&nbsp;&nbsp; = MO_32,<BR>&nbsp;&nbsp;&nbsp; MO_SB&nbsp;&nbsp;&nbsp; = MO_SIGN | MO_8,<BR>&nbsp;&nbsp;&nbsp; MO_SW&nbsp;&nbsp;&nbsp; = MO_SIGN | MO_16,<BR>&nbsp;&nbsp;&nbsp; MO_SL&nbsp;&nbsp;&nbsp; = MO_SIGN | MO_32,<BR>&nbsp;&nbsp;&nbsp; MO_Q&nbsp;&nbsp;&nbsp;&nbsp; = MO_64,</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; MO_LEUW&nbsp; = MO_LE | MO_UW,<BR>&nbsp;&nbsp;&nbsp; MO_LEUL&nbsp; = MO_LE | MO_UL,<BR>&nbsp;&nbsp;&nbsp; MO_LESW&nbsp; = MO_LE | MO_SW,<BR>&nbsp;&nbsp;&nbsp; MO_LESL&nbsp; = MO_LE | MO_SL,<BR>&nbsp;&nbsp;&nbsp; MO_LEQ&nbsp;&nbsp; = MO_LE | MO_Q,</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; MO_BEUW&nbsp; = MO_BE | MO_UW,<BR>&nbsp;&nbsp;&nbsp; MO_BEUL&nbsp; = MO_BE | MO_UL,<BR>&nbsp;&nbsp;&nbsp; MO_BESW&nbsp; = MO_BE | MO_SW,<BR>&nbsp;&nbsp;&nbsp; MO_BESL&nbsp; = MO_BE | MO_SL,<BR>&nbsp;&nbsp;&nbsp; MO_BEQ&nbsp;&nbsp; = MO_BE | MO_Q,</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; MO_TEUW&nbsp; = MO_TE | MO_UW,<BR>&nbsp;&nbsp;&nbsp; MO_TEUL&nbsp; = MO_TE | MO_UL,<BR>&nbsp;&nbsp;&nbsp; MO_TESW&nbsp; = MO_TE | MO_SW,<BR>&nbsp;&nbsp;&nbsp; MO_TESL&nbsp; = MO_TE | MO_SL,<BR>&nbsp;&nbsp;&nbsp; MO_TEQ&nbsp;&nbsp; = MO_TE | MO_Q,</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; MO_SSIZE = MO_SIZE | MO_SIGN,<BR>} TCGMemOp;</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* get_alignment_bits<BR>&nbsp;* @memop: TCGMemOp value<BR>&nbsp;*<BR>&nbsp;* Extract the alignment size from the memop.<BR>&nbsp;*<BR>&nbsp;* Returns: 0 in case of byte access (which is always aligned);<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; positive value - number of alignment bits;<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; negative value if unaligned access enabled<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and this is not a byte access.<BR>&nbsp;*/<BR>static inline int get_alignment_bits(TCGMemOp memop)<BR>{<BR>&nbsp;&nbsp;&nbsp; int a = memop &amp; MO_AMASK;<BR>&nbsp;&nbsp;&nbsp; int s = memop &amp; MO_SIZE;<BR>&nbsp;&nbsp;&nbsp; int r;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (a == MO_UNALN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Negative value if unaligned access enabled,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * or zero value in case of byte access.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -s;<BR>&nbsp;&nbsp;&nbsp; } else if (a == MO_ALIGN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* A natural alignment: return a number of access size bits */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = s;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Specific alignment size. It must be equal or greater<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * than the access size.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = a &gt;&gt; MO_ASHIFT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_debug_assert(r &gt;= s);<BR>&nbsp;&nbsp;&nbsp; }<BR>#if defined(CONFIG_SOFTMMU)<BR>&nbsp;&nbsp;&nbsp; /* The requested alignment cannot overlap the TLB flags.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert((TLB_FLAGS_MASK &amp; ((1 &lt;&lt; r) - 1)) == 0);<BR>#endif<BR>&nbsp;&nbsp;&nbsp; return r;<BR>}</FONT></P>
<P><FONT class=extract>typedef tcg_target_ulong TCGArg;</FONT></P>
<P><FONT class=extract>/* Define a type and accessor macros for variables.&nbsp; Using pointer types<BR>&nbsp;&nbsp; is nice because it gives some level of type safely.&nbsp; Converting to and<BR>&nbsp;&nbsp; from intptr_t rather than int reduces the number of sign-extension<BR>&nbsp;&nbsp; instructions that get implied on 64-bit hosts.&nbsp; Users of tcg_gen_* don't<BR>&nbsp;&nbsp; need to know about any of this, and should treat TCGv as an opaque type.<BR>&nbsp;&nbsp; In addition we do typechecking for different types of variables.&nbsp; TCGv_i32<BR>&nbsp;&nbsp; and TCGv_i64 are 32/64-bit variables respectively.&nbsp; TCGv and TCGv_ptr<BR>&nbsp;&nbsp; are aliases for target_ulong and host pointer sized values respectively.&nbsp; */</FONT></P>
<P><FONT class=extract>typedef struct TCGv_i32_d *TCGv_i32;<BR>typedef struct TCGv_i64_d *TCGv_i64;<BR>typedef struct TCGv_ptr_d *TCGv_ptr;<BR>typedef TCGv_ptr TCGv_env;<BR>#if TARGET_LONG_BITS == 32<BR>#define TCGv TCGv_i32<BR>#elif TARGET_LONG_BITS == 64<BR>#define TCGv TCGv_i64<BR>#else<BR>#error Unhandled TARGET_LONG_BITS value<BR>#endif</FONT></P>
<P><FONT class=extract>static inline TCGv_i32 QEMU_ARTIFICIAL MAKE_TCGV_I32(intptr_t i)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (TCGv_i32)i;<BR>}</FONT></P>
<P><FONT class=extract>static inline TCGv_i64 QEMU_ARTIFICIAL MAKE_TCGV_I64(intptr_t i)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (TCGv_i64)i;<BR>}</FONT></P>
<P><FONT class=extract>static inline TCGv_ptr QEMU_ARTIFICIAL MAKE_TCGV_PTR(intptr_t i)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (TCGv_ptr)i;<BR>}</FONT></P>
<P><FONT class=extract>static inline intptr_t QEMU_ARTIFICIAL GET_TCGV_I32(TCGv_i32 t)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (intptr_t)t;<BR>}</FONT></P>
<P><FONT class=extract>static inline intptr_t QEMU_ARTIFICIAL GET_TCGV_I64(TCGv_i64 t)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (intptr_t)t;<BR>}</FONT></P>
<P><FONT class=extract>static inline intptr_t QEMU_ARTIFICIAL GET_TCGV_PTR(TCGv_ptr t)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (intptr_t)t;<BR>}</FONT></P>
<P><FONT class=extract>#if TCG_TARGET_REG_BITS == 32<BR>#define TCGV_LOW(t) MAKE_TCGV_I32(GET_TCGV_I64(t))<BR>#define TCGV_HIGH(t) MAKE_TCGV_I32(GET_TCGV_I64(t) + 1)<BR>#endif</FONT></P>
<P><FONT class=extract>#define TCGV_EQUAL_I32(a, b) (GET_TCGV_I32(a) == GET_TCGV_I32(b))<BR>#define TCGV_EQUAL_I64(a, b) (GET_TCGV_I64(a) == GET_TCGV_I64(b))<BR>#define TCGV_EQUAL_PTR(a, b) (GET_TCGV_PTR(a) == GET_TCGV_PTR(b))</FONT></P>
<P><FONT class=extract>/* Dummy definition to avoid compiler warnings.&nbsp; */<BR>#define TCGV_UNUSED_I32(x) x = MAKE_TCGV_I32(-1)<BR>#define TCGV_UNUSED_I64(x) x = MAKE_TCGV_I64(-1)<BR>#define TCGV_UNUSED_PTR(x) x = MAKE_TCGV_PTR(-1)</FONT></P>
<P><FONT class=extract>#define TCGV_IS_UNUSED_I32(x) (GET_TCGV_I32(x) == -1)<BR>#define TCGV_IS_UNUSED_I64(x) (GET_TCGV_I64(x) == -1)<BR>#define TCGV_IS_UNUSED_PTR(x) (GET_TCGV_PTR(x) == -1)</FONT></P>
<P><FONT class=extract>/* call flags */<BR>/* Helper does not read globals (either directly or through an exception). It<BR>&nbsp;&nbsp; implies TCG_CALL_NO_WRITE_GLOBALS. */<BR>#define TCG_CALL_NO_READ_GLOBALS&nbsp;&nbsp;&nbsp; 0x0010<BR>/* Helper does not write globals */<BR>#define TCG_CALL_NO_WRITE_GLOBALS&nbsp;&nbsp; 0x0020<BR>/* Helper can be safely suppressed if the return value is not used. */<BR>#define TCG_CALL_NO_SIDE_EFFECTS&nbsp;&nbsp;&nbsp; 0x0040</FONT></P>
<P><FONT class=extract>/* convenience version of most used call flags */<BR>#define TCG_CALL_NO_RWG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCG_CALL_NO_READ_GLOBALS<BR>#define TCG_CALL_NO_WG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCG_CALL_NO_WRITE_GLOBALS<BR>#define TCG_CALL_NO_SE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCG_CALL_NO_SIDE_EFFECTS<BR>#define TCG_CALL_NO_RWG_SE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (TCG_CALL_NO_RWG | TCG_CALL_NO_SE)<BR>#define TCG_CALL_NO_WG_SE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (TCG_CALL_NO_WG | TCG_CALL_NO_SE)</FONT></P>
<P><FONT class=extract>/* used to align parameters */<BR>#define TCG_CALL_DUMMY_TCGV&nbsp;&nbsp;&nbsp;&nbsp; MAKE_TCGV_I32(-1)<BR>#define TCG_CALL_DUMMY_ARG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((TCGArg)(-1))</FONT></P>
<P><FONT class=extract>/* Conditions.&nbsp; Note that these are laid out for easy manipulation by<BR>&nbsp;&nbsp; the functions below:<BR>&nbsp;&nbsp;&nbsp;&nbsp; bit 0 is used for inverting;<BR>&nbsp;&nbsp;&nbsp;&nbsp; bit 1 is signed,<BR>&nbsp;&nbsp;&nbsp;&nbsp; bit 2 is unsigned,<BR>&nbsp;&nbsp;&nbsp;&nbsp; bit 3 is used with bit 0 for swapping signed/unsigned.&nbsp; */<BR>typedef enum {<BR>&nbsp;&nbsp;&nbsp; /* non-signed */<BR>&nbsp;&nbsp;&nbsp; TCG_COND_NEVER&nbsp; = 0 | 0 | 0 | 0,<BR>&nbsp;&nbsp;&nbsp; TCG_COND_ALWAYS = 0 | 0 | 0 | 1,<BR>&nbsp;&nbsp;&nbsp; TCG_COND_EQ&nbsp;&nbsp;&nbsp;&nbsp; = 8 | 0 | 0 | 0,<BR>&nbsp;&nbsp;&nbsp; TCG_COND_NE&nbsp;&nbsp;&nbsp;&nbsp; = 8 | 0 | 0 | 1,<BR>&nbsp;&nbsp;&nbsp; /* signed */<BR>&nbsp;&nbsp;&nbsp; TCG_COND_LT&nbsp;&nbsp;&nbsp;&nbsp; = 0 | 0 | 2 | 0,<BR>&nbsp;&nbsp;&nbsp; TCG_COND_GE&nbsp;&nbsp;&nbsp;&nbsp; = 0 | 0 | 2 | 1,<BR>&nbsp;&nbsp;&nbsp; TCG_COND_LE&nbsp;&nbsp;&nbsp;&nbsp; = 8 | 0 | 2 | 0,<BR>&nbsp;&nbsp;&nbsp; TCG_COND_GT&nbsp;&nbsp;&nbsp;&nbsp; = 8 | 0 | 2 | 1,<BR>&nbsp;&nbsp;&nbsp; /* unsigned */<BR>&nbsp;&nbsp;&nbsp; TCG_COND_LTU&nbsp;&nbsp;&nbsp; = 0 | 4 | 0 | 0,<BR>&nbsp;&nbsp;&nbsp; TCG_COND_GEU&nbsp;&nbsp;&nbsp; = 0 | 4 | 0 | 1,<BR>&nbsp;&nbsp;&nbsp; TCG_COND_LEU&nbsp;&nbsp;&nbsp; = 8 | 4 | 0 | 0,<BR>&nbsp;&nbsp;&nbsp; TCG_COND_GTU&nbsp;&nbsp;&nbsp; = 8 | 4 | 0 | 1,<BR>} TCGCond;</FONT></P>
<P><FONT class=extract>/* Invert the sense of the comparison.&nbsp; */<BR>static inline TCGCond tcg_invert_cond(TCGCond c)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (TCGCond)(c ^ 1);<BR>}</FONT></P>
<P><FONT class=extract>/* Swap the operands in a comparison.&nbsp; */<BR>static inline TCGCond tcg_swap_cond(TCGCond c)<BR>{<BR>&nbsp;&nbsp;&nbsp; return c &amp; 6 ? (TCGCond)(c ^ 9) : c;<BR>}</FONT></P>
<P><FONT class=extract>/* Create an "unsigned" version of a "signed" comparison.&nbsp; */<BR>static inline TCGCond tcg_unsigned_cond(TCGCond c)<BR>{<BR>&nbsp;&nbsp;&nbsp; return c &amp; 2 ? (TCGCond)(c ^ 6) : c;<BR>}</FONT></P>
<P><FONT class=extract>/* Must a comparison be considered unsigned?&nbsp; */<BR>static inline bool is_unsigned_cond(TCGCond c)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (c &amp; 4) != 0;<BR>}</FONT></P>
<P><FONT class=extract>/* Create a "high" version of a double-word comparison.<BR>&nbsp;&nbsp; This removes equality from a LTE or GTE comparison.&nbsp; */<BR>static inline TCGCond tcg_high_cond(TCGCond c)<BR>{<BR>&nbsp;&nbsp;&nbsp; switch (c) {<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_GE:<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_LE:<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_GEU:<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_LEU:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (TCGCond)(c ^ 8);<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return c;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>typedef enum TCGTempVal {<BR>&nbsp;&nbsp;&nbsp; TEMP_VAL_DEAD,<BR>&nbsp;&nbsp;&nbsp; TEMP_VAL_REG,<BR>&nbsp;&nbsp;&nbsp; TEMP_VAL_MEM,<BR>&nbsp;&nbsp;&nbsp; TEMP_VAL_CONST,<BR>} TCGTempVal;</FONT></P>
<P><FONT class=extract>typedef struct TCGTemp {<BR>&nbsp;&nbsp;&nbsp; TCGReg reg:8;<BR>&nbsp;&nbsp;&nbsp; TCGTempVal val_type:8;<BR>&nbsp;&nbsp;&nbsp; TCGType base_type:8;<BR>&nbsp;&nbsp;&nbsp; TCGType type:8;<BR>&nbsp;&nbsp;&nbsp; unsigned int fixed_reg:1;<BR>&nbsp;&nbsp;&nbsp; unsigned int indirect_reg:1;<BR>&nbsp;&nbsp;&nbsp; unsigned int indirect_base:1;<BR>&nbsp;&nbsp;&nbsp; unsigned int mem_coherent:1;<BR>&nbsp;&nbsp;&nbsp; unsigned int mem_allocated:1;<BR>&nbsp;&nbsp;&nbsp; unsigned int temp_local:1; /* If true, the temp is saved across<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; basic blocks. Otherwise, it is not<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; preserved across basic blocks. */<BR>&nbsp;&nbsp;&nbsp; unsigned int temp_allocated:1; /* never used for code gen */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_target_long val;<BR>&nbsp;&nbsp;&nbsp; struct TCGTemp *mem_base;<BR>&nbsp;&nbsp;&nbsp; intptr_t mem_offset;<BR>&nbsp;&nbsp;&nbsp; const char *name;<BR>} TCGTemp;</FONT></P>
<P>typedef struct TCGContext TCGContext;</P>
<P><FONT class=extract>typedef struct TCGTempSet {<BR>&nbsp;&nbsp;&nbsp; unsigned long l[BITS_TO_LONGS(TCG_MAX_TEMPS)];<BR>} TCGTempSet;</FONT></P>
<P><FONT class=extract>/* While we limit helpers to 6 arguments, for 32-bit hosts, with padding,<BR>&nbsp;&nbsp; this imples a max of 6*2 (64-bit in) + 2 (64-bit out) = 14 operands.<BR>&nbsp;&nbsp; There are never more than 2 outputs, which means that we can store all<BR>&nbsp;&nbsp; dead + sync data within 16 bits.&nbsp; */<BR>#define DEAD_ARG&nbsp; 4<BR>#define SYNC_ARG&nbsp; 1<BR>typedef uint16_t TCGLifeData;</FONT></P>
<P><FONT class=extract>/* The layout here is designed to avoid crossing of a 32-bit boundary.<BR>&nbsp;&nbsp; If we do so, gcc adds padding, expanding the size to 12.&nbsp; */<BR>typedef struct TCGOp {<BR>&nbsp;&nbsp;&nbsp; TCGOpcode opc&nbsp;&nbsp; : 8;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; 8 */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Index of the prev/next op, or 0 for the end of the list.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; unsigned prev&nbsp;&nbsp; : 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 18 */<BR>&nbsp;&nbsp;&nbsp; unsigned next&nbsp;&nbsp; : 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 28 */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* The number of out and in parameter for a call.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; unsigned calli&nbsp; : 4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 32 */<BR>&nbsp;&nbsp;&nbsp; unsigned callo&nbsp; : 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 34 */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Index of the arguments for this op, or 0 for zero-operand ops.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; unsigned args&nbsp;&nbsp; : 14;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 48 */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Lifetime data of the operands.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; unsigned life&nbsp;&nbsp; : 16;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 64 */<BR>} TCGOp;</FONT></P>
<P><FONT class=extract>/* Make sure operands fit in the bitfields above.&nbsp; */<BR>QEMU_BUILD_BUG_ON(NB_OPS &gt; (1 &lt;&lt; 8));<BR>QEMU_BUILD_BUG_ON(OPC_BUF_SIZE &gt; (1 &lt;&lt; 10));<BR>QEMU_BUILD_BUG_ON(OPPARAM_BUF_SIZE &gt; (1 &lt;&lt; 14));</FONT></P>
<P><FONT class=extract>/* Make sure that we don't overflow 64 bits without noticing.&nbsp; */<BR>QEMU_BUILD_BUG_ON(sizeof(TCGOp) &gt; 8);</FONT></P>
<P><FONT class=extract>struct TCGContext {<BR>&nbsp;&nbsp;&nbsp; uint8_t *pool_cur, *pool_end;<BR>&nbsp;&nbsp;&nbsp; TCGPool *pool_first, *pool_current, *pool_first_large;<BR>&nbsp;&nbsp;&nbsp; int nb_labels;<BR>&nbsp;&nbsp;&nbsp; int nb_globals;<BR>&nbsp;&nbsp;&nbsp; int nb_temps;<BR>&nbsp;&nbsp;&nbsp; int nb_indirects;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* goto_tb support */<BR>&nbsp;&nbsp;&nbsp; tcg_insn_unit *code_buf;<BR>&nbsp;&nbsp;&nbsp; uint16_t *tb_jmp_reset_offset; /* tb-&gt;jmp_reset_offset */<BR>&nbsp;&nbsp;&nbsp; uint16_t *tb_jmp_insn_offset; /* tb-&gt;jmp_insn_offset if USE_DIRECT_JUMP */<BR>&nbsp;&nbsp;&nbsp; uintptr_t *tb_jmp_target_addr; /* tb-&gt;jmp_target_addr if !USE_DIRECT_JUMP */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; TCGRegSet reserved_regs;<BR>&nbsp;&nbsp;&nbsp; intptr_t current_frame_offset;<BR>&nbsp;&nbsp;&nbsp; intptr_t frame_start;<BR>&nbsp;&nbsp;&nbsp; intptr_t frame_end;<BR>&nbsp;&nbsp;&nbsp; TCGTemp *frame_temp;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_insn_unit *code_ptr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; GHashTable *helpers;</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_PROFILER<BR>&nbsp;&nbsp;&nbsp; /* profiling info */<BR>&nbsp;&nbsp;&nbsp; int64_t tb_count1;<BR>&nbsp;&nbsp;&nbsp; int64_t tb_count;<BR>&nbsp;&nbsp;&nbsp; int64_t op_count; /* total insn count */<BR>&nbsp;&nbsp;&nbsp; int op_count_max; /* max insn per TB */<BR>&nbsp;&nbsp;&nbsp; int64_t temp_count;<BR>&nbsp;&nbsp;&nbsp; int temp_count_max;<BR>&nbsp;&nbsp;&nbsp; int64_t del_op_count;<BR>&nbsp;&nbsp;&nbsp; int64_t code_in_len;<BR>&nbsp;&nbsp;&nbsp; int64_t code_out_len;<BR>&nbsp;&nbsp;&nbsp; int64_t search_out_len;<BR>&nbsp;&nbsp;&nbsp; int64_t interm_time;<BR>&nbsp;&nbsp;&nbsp; int64_t code_time;<BR>&nbsp;&nbsp;&nbsp; int64_t la_time;<BR>&nbsp;&nbsp;&nbsp; int64_t opt_time;<BR>&nbsp;&nbsp;&nbsp; int64_t restore_count;<BR>&nbsp;&nbsp;&nbsp; int64_t restore_time;<BR>#endif</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_DEBUG_TCG<BR>&nbsp;&nbsp;&nbsp; int temps_in_use;<BR>&nbsp;&nbsp;&nbsp; int goto_tb_issue_mask;<BR>#endif</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; int gen_next_op_idx;<BR>&nbsp;&nbsp;&nbsp; int gen_next_parm_idx;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Code generation.&nbsp; Note that we specifically do not use tcg_insn_unit<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; here, because there's too much arithmetic throughout that relies<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; on addition and subtraction working on bytes.&nbsp; Rely on the GCC<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extension that allows arithmetic on void*.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int code_gen_max_blocks;<BR>&nbsp;&nbsp;&nbsp; void *code_gen_prologue;<BR>&nbsp;&nbsp;&nbsp; void *code_gen_buffer;<BR>&nbsp;&nbsp;&nbsp; size_t code_gen_buffer_size;<BR>&nbsp;&nbsp;&nbsp; void *code_gen_ptr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Threshold to flush the translated code buffer.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; void *code_gen_highwater;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; TBContext tb_ctx;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Track which vCPU triggers events */<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* *_trans */<BR>&nbsp;&nbsp;&nbsp; TCGv_env tcg_env;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* *_exec&nbsp; */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* The TCGBackendData structure is private to tcg-target.inc.c.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; struct TCGBackendData *be;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; TCGTempSet free_temps[TCG_TYPE_COUNT * 2];<BR>&nbsp;&nbsp;&nbsp; TCGTemp temps[TCG_MAX_TEMPS]; /* globals first, temps after */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Tells which temporary holds a given register.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It does not take into account fixed registers */<BR>&nbsp;&nbsp;&nbsp; TCGTemp *reg_to_temp[TCG_TARGET_NB_REGS];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; TCGOp gen_op_buf[OPC_BUF_SIZE];<BR>&nbsp;&nbsp;&nbsp; TCGArg gen_opparam_buf[OPPARAM_BUF_SIZE];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; uint16_t gen_insn_end_off[TCG_MAX_INSNS];<BR>&nbsp;&nbsp;&nbsp; target_ulong gen_insn_data[TCG_MAX_INSNS][TARGET_INSN_START_WORDS];<BR>};</FONT></P>
<P><FONT class=extract>extern TCGContext tcg_ctx;</FONT></P>
<P><FONT class=extract>static inline void tcg_set_insn_param(int op_idx, int arg, TCGArg v)<BR>{<BR>&nbsp;&nbsp;&nbsp; int op_argi = tcg_ctx.gen_op_buf[op_idx].args;<BR>&nbsp;&nbsp;&nbsp; tcg_ctx.gen_opparam_buf[op_argi + arg] = v;<BR>}</FONT></P>
<P><FONT class=extract>/* The number of opcodes emitted so far.&nbsp; */<BR>static inline int tcg_op_buf_count(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; return tcg_ctx.gen_next_op_idx;<BR>}</FONT></P>
<P><FONT class=extract>/* Test for whether to terminate the TB for using too many opcodes.&nbsp; */<BR>static inline bool tcg_op_buf_full(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; return tcg_op_buf_count() &gt;= OPC_MAX_SIZE;<BR>}</FONT></P>
<P>/* pool based memory allocation */</P>
<P>void *tcg_malloc_internal(TCGContext *s, int size);<BR>void tcg_pool_reset(TCGContext *s);<BR>void tcg_pool_delete(TCGContext *s);</P>
<P>void tb_lock(void);<BR>void tb_unlock(void);<BR>void tb_lock_reset(void);</P>
<P><FONT class=extract>static inline void *tcg_malloc(int size)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGContext *s = &amp;tcg_ctx;<BR>&nbsp;&nbsp;&nbsp; uint8_t *ptr, *ptr_end;<BR>&nbsp;&nbsp;&nbsp; size = (size + sizeof(long) - 1) &amp; ~(sizeof(long) - 1);<BR>&nbsp;&nbsp;&nbsp; ptr = s-&gt;pool_cur;<BR>&nbsp;&nbsp;&nbsp; ptr_end = ptr + size;<BR>&nbsp;&nbsp;&nbsp; if (unlikely(ptr_end &gt; s-&gt;pool_end)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tcg_malloc_internal(&amp;tcg_ctx, size);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;pool_cur = ptr_end;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ptr;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P>void tcg_context_init(TCGContext *s);<BR>void tcg_prologue_init(TCGContext *s);<BR>void tcg_func_start(TCGContext *s);</P>
<P>int tcg_gen_code(TCGContext *s, TranslationBlock *tb);</P>
<P>void tcg_set_frame(TCGContext *s, TCGReg reg, intptr_t start, intptr_t size);</P>
<P>int tcg_global_mem_new_internal(TCGType, TCGv_ptr, intptr_t, const char *);</P>
<P>TCGv_i32 tcg_global_reg_new_i32(TCGReg reg, const char *name);<BR>TCGv_i64 tcg_global_reg_new_i64(TCGReg reg, const char *name);</P>
<P>TCGv_i32 tcg_temp_new_internal_i32(int temp_local);<BR>TCGv_i64 tcg_temp_new_internal_i64(int temp_local);</P>
<P>void tcg_temp_free_i32(TCGv_i32 arg);<BR>void tcg_temp_free_i64(TCGv_i64 arg);</P>
<P><FONT class=extract>static inline TCGv_i32 tcg_global_mem_new_i32(TCGv_ptr reg, intptr_t offset,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name)<BR>{<BR>&nbsp;&nbsp;&nbsp; int idx = tcg_global_mem_new_internal(TCG_TYPE_I32, reg, offset, name);<BR>&nbsp;&nbsp;&nbsp; return MAKE_TCGV_I32(idx);<BR>}</FONT></P>
<P><FONT class=extract>static inline TCGv_i32 tcg_temp_new_i32(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; return tcg_temp_new_internal_i32(0);<BR>}</FONT></P>
<P><FONT class=extract>static inline TCGv_i32 tcg_temp_local_new_i32(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; return tcg_temp_new_internal_i32(1);<BR>}</FONT></P>
<P>static inline TCGv_i64 tcg_global_mem_new_i64(TCGv_ptr reg, intptr_t offset,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name)<BR>{<BR>&nbsp;&nbsp;&nbsp; int idx = tcg_global_mem_new_internal(TCG_TYPE_I64, reg, offset, name);<BR>&nbsp;&nbsp;&nbsp; return MAKE_TCGV_I64(idx);<BR>}</P>
<P>static inline TCGv_i64 tcg_temp_new_i64(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; return tcg_temp_new_internal_i64(0);<BR>}</P>
<P>static inline TCGv_i64 tcg_temp_local_new_i64(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; return tcg_temp_new_internal_i64(1);<BR>}</P>
<P>#if defined(CONFIG_DEBUG_TCG)<BR>/* If you call tcg_clear_temp_count() at the start of a section of<BR>&nbsp;* code which is not supposed to leak any TCG temporaries, then<BR>&nbsp;* calling tcg_check_temp_count() at the end of the section will<BR>&nbsp;* return 1 if the section did in fact leak a temporary.<BR>&nbsp;*/<BR>void tcg_clear_temp_count(void);<BR>int tcg_check_temp_count(void);<BR>#else<BR>#define tcg_clear_temp_count() do { } while (0)<BR>#define tcg_check_temp_count() 0<BR>#endif</P>
<P>void tcg_dump_info(FILE *f, fprintf_function cpu_fprintf);<BR>void tcg_dump_op_count(FILE *f, fprintf_function cpu_fprintf);</P>
<P>#define TCG_CT_ALIAS&nbsp; 0x80<BR>#define TCG_CT_IALIAS 0x40<BR>#define TCG_CT_REG&nbsp;&nbsp;&nbsp; 0x01<BR>#define TCG_CT_CONST&nbsp; 0x02 /* any constant of register size */</P>
<P>typedef struct TCGArgConstraint {<BR>&nbsp;&nbsp;&nbsp; uint16_t ct;<BR>&nbsp;&nbsp;&nbsp; uint8_t alias_index;<BR>&nbsp;&nbsp;&nbsp; union {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGRegSet regs;<BR>&nbsp;&nbsp;&nbsp; } u;<BR>} TCGArgConstraint;</P>
<P>#define TCG_MAX_OP_ARGS 16</P>
<P><FONT class=extract>/* Bits for TCGOpDef-&gt;flags, 8 bits available.&nbsp; */<BR>enum {<BR>&nbsp;&nbsp;&nbsp; /* Instruction defines the end of a basic block.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; TCG_OPF_BB_END&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x01,<BR>&nbsp;&nbsp;&nbsp; /* Instruction clobbers call registers and potentially update globals.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; TCG_OPF_CALL_CLOBBER = 0x02,<BR>&nbsp;&nbsp;&nbsp; /* Instruction has side effects: it cannot be removed if its outputs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; are not used, and might trigger exceptions.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; TCG_OPF_SIDE_EFFECTS = 0x04,<BR>&nbsp;&nbsp;&nbsp; /* Instruction operands are 64-bits (otherwise 32-bits).&nbsp; */<BR>&nbsp;&nbsp;&nbsp; TCG_OPF_64BIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x08,<BR>&nbsp;&nbsp;&nbsp; /* Instruction is optional and not implemented by the host, or insn<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is generic and should not be implemened by the host.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; TCG_OPF_NOT_PRESENT&nbsp; = 0x10,<BR>};</FONT></P>
<P><FONT class=extract>typedef struct TCGOpDef {<BR>&nbsp;&nbsp;&nbsp; const char *name;<BR>&nbsp;&nbsp;&nbsp; uint8_t nb_oargs, nb_iargs, nb_cargs, nb_args;<BR>&nbsp;&nbsp;&nbsp; uint8_t flags;<BR>&nbsp;&nbsp;&nbsp; TCGArgConstraint *args_ct;<BR>&nbsp;&nbsp;&nbsp; int *sorted_args;<BR>#if defined(CONFIG_DEBUG_TCG)<BR>&nbsp;&nbsp;&nbsp; int used;<BR>#endif<BR>} TCGOpDef;</FONT></P>
<P><FONT class=extract>extern TCGOpDef tcg_op_defs[];<BR>extern const size_t tcg_op_defs_max;</FONT></P>
<P><FONT class=extract>typedef struct TCGTargetOpDef {<BR>&nbsp;&nbsp;&nbsp; TCGOpcode op;<BR>&nbsp;&nbsp;&nbsp; const char *args_ct_str[TCG_MAX_OP_ARGS];<BR>} TCGTargetOpDef;</FONT></P>
<P><FONT class=extract>#define tcg_abort() \<BR>do {\<BR>&nbsp;&nbsp;&nbsp; fprintf(stderr, "%s:%d: tcg fatal error\n", __FILE__, __LINE__);\<BR>&nbsp;&nbsp;&nbsp; abort();\<BR>} while (0)</FONT></P>
<P>void tcg_add_target_add_op_defs(const TCGTargetOpDef *tdefs);</P>
<P>#if UINTPTR_MAX == UINT32_MAX<BR>#define TCGV_NAT_TO_PTR(n) MAKE_TCGV_PTR(GET_TCGV_I32(n))<BR>#define TCGV_PTR_TO_NAT(n) MAKE_TCGV_I32(GET_TCGV_PTR(n))</P>
<P>#define tcg_const_ptr(V) TCGV_NAT_TO_PTR(tcg_const_i32((intptr_t)(V)))<BR>#define tcg_global_reg_new_ptr(R, N) \<BR>&nbsp;&nbsp;&nbsp; TCGV_NAT_TO_PTR(tcg_global_reg_new_i32((R), (N)))<BR><FONT class=extract>#define tcg_global_mem_new_ptr(R, O, N) \<BR>&nbsp;&nbsp;&nbsp; TCGV_NAT_TO_PTR(tcg_global_mem_new_i32((R), (O), (N)))</FONT><BR><FONT class=extract>#define tcg_temp_new_ptr() TCGV_NAT_TO_PTR(tcg_temp_new_i32())</FONT><BR><FONT class=extract>#define tcg_temp_free_ptr(T) tcg_temp_free_i32(TCGV_PTR_TO_NAT(T))</FONT><BR>#else<BR>#define TCGV_NAT_TO_PTR(n) MAKE_TCGV_PTR(GET_TCGV_I64(n))<BR>#define TCGV_PTR_TO_NAT(n) MAKE_TCGV_I64(GET_TCGV_PTR(n))</P>
<P>#define tcg_const_ptr(V) TCGV_NAT_TO_PTR(tcg_const_i64((intptr_t)(V)))<BR>#define tcg_global_reg_new_ptr(R, N) \<BR>&nbsp;&nbsp;&nbsp; TCGV_NAT_TO_PTR(tcg_global_reg_new_i64((R), (N)))<BR>#define tcg_global_mem_new_ptr(R, O, N) \<BR>&nbsp;&nbsp;&nbsp; TCGV_NAT_TO_PTR(tcg_global_mem_new_i64((R), (O), (N)))<BR>#define tcg_temp_new_ptr() TCGV_NAT_TO_PTR(tcg_temp_new_i64())<BR>#define tcg_temp_free_ptr(T) tcg_temp_free_i64(TCGV_PTR_TO_NAT(T))<BR>#endif</P>
<P>void tcg_gen_callN(TCGContext *s, void *func,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg ret, int nargs, TCGArg *args);</P>
<P>void tcg_op_remove(TCGContext *s, TCGOp *op);<BR>TCGOp *tcg_op_insert_before(TCGContext *s, TCGOp *op, TCGOpcode opc, int narg);<BR>TCGOp *tcg_op_insert_after(TCGContext *s, TCGOp *op, TCGOpcode opc, int narg);</P>
<P>void tcg_optimize(TCGContext *s);</P>
<P>/* only used for debugging purposes */<BR>void tcg_dump_ops(TCGContext *s);</P>
<P>void dump_ops(const uint16_t *opc_buf, const TCGArg *opparam_buf);<BR>TCGv_i32 tcg_const_i32(int32_t val);<BR>TCGv_i64 tcg_const_i64(int64_t val);<BR>TCGv_i32 tcg_const_local_i32(int32_t val);<BR>TCGv_i64 tcg_const_local_i64(int64_t val);</P>
<P>TCGLabel *gen_new_label(void);</P>
<P>/**<BR>&nbsp;* label_arg<BR>&nbsp;* @l: label<BR>&nbsp;*<BR>&nbsp;* Encode a label for storage in the TCG opcode stream.<BR>&nbsp;*/</P>
<P>static inline TCGArg label_arg(TCGLabel *l)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (uintptr_t)l;<BR>}</P>
<P>/**<BR>&nbsp;* arg_label<BR>&nbsp;* @i: value<BR>&nbsp;*<BR>&nbsp;* The opposite of label_arg.&nbsp; Retrieve a label from the<BR>&nbsp;* encoding of the TCG opcode stream.<BR>&nbsp;*/</P>
<P>static inline TCGLabel *arg_label(TCGArg i)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (TCGLabel *)(uintptr_t)i;<BR>}</P>
<P>/**<BR>&nbsp;* tcg_ptr_byte_diff<BR>&nbsp;* @a, @b: addresses to be differenced<BR>&nbsp;*<BR>&nbsp;* There are many places within the TCG backends where we need a byte<BR>&nbsp;* difference between two pointers.&nbsp; While this can be accomplished<BR>&nbsp;* with local casting, it's easy to get wrong -- especially if one is<BR>&nbsp;* concerned with the signedness of the result.<BR>&nbsp;*<BR>&nbsp;* This version relies on GCC's void pointer arithmetic to get the<BR>&nbsp;* correct result.<BR>&nbsp;*/</P>
<P>static inline ptrdiff_t tcg_ptr_byte_diff(void *a, void *b)<BR>{<BR>&nbsp;&nbsp;&nbsp; return a - b;<BR>}</P>
<P>/**<BR>&nbsp;* tcg_pcrel_diff<BR>&nbsp;* @s: the tcg context<BR>&nbsp;* @target: address of the target<BR>&nbsp;*<BR>&nbsp;* Produce a pc-relative difference, from the current code_ptr<BR>&nbsp;* to the destination address.<BR>&nbsp;*/</P>
<P>static inline ptrdiff_t tcg_pcrel_diff(TCGContext *s, void *target)<BR>{<BR>&nbsp;&nbsp;&nbsp; return tcg_ptr_byte_diff(target, s-&gt;code_ptr);<BR>}</P>
<P>/**<BR>&nbsp;* tcg_current_code_size<BR>&nbsp;* @s: the tcg context<BR>&nbsp;*<BR>&nbsp;* Compute the current code size within the translation block.<BR>&nbsp;* This is used to fill in qemu's data structures for goto_tb.<BR>&nbsp;*/</P>
<P>static inline size_t tcg_current_code_size(TCGContext *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; return tcg_ptr_byte_diff(s-&gt;code_ptr, s-&gt;code_buf);<BR>}</P>
<P>/* Combine the TCGMemOp and mmu_idx parameters into a single value.&nbsp; */<BR>typedef uint32_t TCGMemOpIdx;</P>
<P>/**<BR>&nbsp;* make_memop_idx<BR>&nbsp;* @op: memory operation<BR>&nbsp;* @idx: mmu index<BR>&nbsp;*<BR>&nbsp;* Encode these values into a single parameter.<BR>&nbsp;*/<BR>static inline TCGMemOpIdx make_memop_idx(TCGMemOp op, unsigned idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(idx &lt;= 15);<BR>&nbsp;&nbsp;&nbsp; return (op &lt;&lt; 4) | idx;<BR>}</P>
<P>/**<BR>&nbsp;* get_memop<BR>&nbsp;* @oi: combined op/idx parameter<BR>&nbsp;*<BR>&nbsp;* Extract the memory operation from the combined value.<BR>&nbsp;*/<BR>static inline TCGMemOp get_memop(TCGMemOpIdx oi)<BR>{<BR>&nbsp;&nbsp;&nbsp; return oi &gt;&gt; 4;<BR>}</P>
<P>/**<BR>&nbsp;* get_mmuidx<BR>&nbsp;* @oi: combined op/idx parameter<BR>&nbsp;*<BR>&nbsp;* Extract the mmu index from the combined value.<BR>&nbsp;*/<BR>static inline unsigned get_mmuidx(TCGMemOpIdx oi)<BR>{<BR>&nbsp;&nbsp;&nbsp; return oi &amp; 15;<BR>}</P>
<P><FONT class=extract>/**<BR>&nbsp;* tcg_qemu_tb_exec:<BR>&nbsp;* @env: pointer to CPUArchState for the CPU<BR>&nbsp;* @tb_ptr: address of generated code for the TB to execute<BR>&nbsp;*<BR>&nbsp;* Start executing code from a given translation block.<BR>&nbsp;* Where translation blocks have been linked, execution<BR>&nbsp;* may proceed from the given TB into successive ones.<BR>&nbsp;* Control eventually returns only when some action is needed<BR>&nbsp;* from the top-level loop: either control must pass to a TB<BR>&nbsp;* which has not yet been directly linked, or an asynchronous<BR>&nbsp;* event such as an interrupt needs handling.<BR>&nbsp;*<BR>&nbsp;* Return: The return value is the value passed to the corresponding<BR>&nbsp;* tcg_gen_exit_tb() at translation time of the last TB attempted to execute.<BR>&nbsp;* The value is either zero or a 4-byte aligned pointer to that TB combined<BR>&nbsp;* with additional information in its two least significant bits. The<BR>&nbsp;* additional information is encoded as follows:<BR>&nbsp;*&nbsp; 0, 1: the link between this TB and the next is via the specified<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TB index (0 or 1). That is, we left the TB via (the equivalent<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of) "goto_tb &lt;index&gt;". The main loop uses this to determine<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; how to link the TB just executed to the next.<BR>&nbsp;*&nbsp; 2:&nbsp;&nbsp;&nbsp; we are using instruction counting code generation, and we<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; did not start executing this TB because the instruction counter<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; would hit zero midway through it. In this case the pointer<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returned is the TB we were about to execute, and the caller must<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arrange to execute the remaining count of instructions.<BR>&nbsp;*&nbsp; 3:&nbsp;&nbsp;&nbsp; we stopped because the CPU's exit_request flag was set<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (usually meaning that there is an interrupt that needs to be<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handled). The pointer returned is the TB we were about to execute<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when we noticed the pending exit request.<BR>&nbsp;*<BR>&nbsp;* If the bottom two bits indicate an exit-via-index then the CPU<BR>&nbsp;* state is correctly synchronised and ready for execution of the next<BR>&nbsp;* TB (and in particular the guest PC is the address to execute next).<BR>&nbsp;* Otherwise, we gave up on execution of this TB before it started, and<BR>&nbsp;* the caller must fix up the CPU state by calling the CPU's<BR>&nbsp;* synchronize_from_tb() method with the TB pointer we return (falling<BR>&nbsp;* back to calling the CPU's set_pc method with tb-&gt;pb if no<BR>&nbsp;* synchronize_from_tb() method exists).<BR>&nbsp;*<BR>&nbsp;* Note that TCG targets may use a different definition of tcg_qemu_tb_exec<BR>&nbsp;* to this default (which just calls the prologue.code emitted by<BR>&nbsp;* tcg_target_qemu_prologue()).<BR>&nbsp;*/<BR>#define TB_EXIT_MASK 3<BR>#define TB_EXIT_IDX0 0<BR>#define TB_EXIT_IDX1 1<BR>#define TB_EXIT_ICOUNT_EXPIRED 2<BR>#define TB_EXIT_REQUESTED 3</FONT></P>
<P><FONT class=extract>#ifdef HAVE_TCG_QEMU_TB_EXEC<BR>uintptr_t tcg_qemu_tb_exec(CPUArchState *env, uint8_t *tb_ptr);<BR>#else<BR># define tcg_qemu_tb_exec(env, tb_ptr) \<BR>&nbsp;&nbsp;&nbsp; ((uintptr_t (*)(void *, void *))tcg_ctx.code_gen_prologue)(env, tb_ptr)<BR>#endif</FONT></P>
<P>void tcg_register_jit(void *buf, size_t buf_size);</P>
<P>/*<BR>&nbsp;* Memory helpers that will be used by TCG generated code.<BR>&nbsp;*/<BR>#ifdef CONFIG_SOFTMMU<BR>/* Value zero-extended to tcg register size.&nbsp; */<BR>tcg_target_ulong helper_ret_ldub_mmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>tcg_target_ulong helper_le_lduw_mmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>tcg_target_ulong helper_le_ldul_mmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>uint64_t helper_le_ldq_mmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>tcg_target_ulong helper_be_lduw_mmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>tcg_target_ulong helper_be_ldul_mmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>uint64_t helper_be_ldq_mmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);</P>
<P>/* Value sign-extended to tcg register size.&nbsp; */<BR>tcg_target_ulong helper_ret_ldsb_mmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>tcg_target_ulong helper_le_ldsw_mmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>tcg_target_ulong helper_le_ldsl_mmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>tcg_target_ulong helper_be_ldsw_mmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>tcg_target_ulong helper_be_ldsl_mmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);</P>
<P>void helper_ret_stb_mmu(CPUArchState *env, target_ulong addr, uint8_t val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>void helper_le_stw_mmu(CPUArchState *env, target_ulong addr, uint16_t val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>void helper_le_stl_mmu(CPUArchState *env, target_ulong addr, uint32_t val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>void helper_le_stq_mmu(CPUArchState *env, target_ulong addr, uint64_t val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>void helper_be_stw_mmu(CPUArchState *env, target_ulong addr, uint16_t val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>void helper_be_stl_mmu(CPUArchState *env, target_ulong addr, uint32_t val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>void helper_be_stq_mmu(CPUArchState *env, target_ulong addr, uint64_t val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);</P>
<P>uint8_t helper_ret_ldb_cmmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>uint16_t helper_le_ldw_cmmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>uint32_t helper_le_ldl_cmmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>uint64_t helper_le_ldq_cmmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>uint16_t helper_be_ldw_cmmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>uint32_t helper_be_ldl_cmmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);<BR>uint64_t helper_be_ldq_cmmu(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi, uintptr_t retaddr);</P>
<P>/* Temporary aliases until backends are converted.&nbsp; */<BR>#ifdef TARGET_WORDS_BIGENDIAN<BR># define helper_ret_ldsw_mmu&nbsp; helper_be_ldsw_mmu<BR># define helper_ret_lduw_mmu&nbsp; helper_be_lduw_mmu<BR># define helper_ret_ldsl_mmu&nbsp; helper_be_ldsl_mmu<BR># define helper_ret_ldul_mmu&nbsp; helper_be_ldul_mmu<BR># define helper_ret_ldl_mmu&nbsp;&nbsp; helper_be_ldul_mmu<BR># define helper_ret_ldq_mmu&nbsp;&nbsp; helper_be_ldq_mmu<BR># define helper_ret_stw_mmu&nbsp;&nbsp; helper_be_stw_mmu<BR># define helper_ret_stl_mmu&nbsp;&nbsp; helper_be_stl_mmu<BR># define helper_ret_stq_mmu&nbsp;&nbsp; helper_be_stq_mmu<BR># define helper_ret_ldw_cmmu&nbsp; helper_be_ldw_cmmu<BR># define helper_ret_ldl_cmmu&nbsp; helper_be_ldl_cmmu<BR># define helper_ret_ldq_cmmu&nbsp; helper_be_ldq_cmmu<BR>#else<BR># define helper_ret_ldsw_mmu&nbsp; helper_le_ldsw_mmu<BR># define helper_ret_lduw_mmu&nbsp; helper_le_lduw_mmu<BR># define helper_ret_ldsl_mmu&nbsp; helper_le_ldsl_mmu<BR># define helper_ret_ldul_mmu&nbsp; helper_le_ldul_mmu<BR># define helper_ret_ldl_mmu&nbsp;&nbsp; helper_le_ldul_mmu<BR># define helper_ret_ldq_mmu&nbsp;&nbsp; helper_le_ldq_mmu<BR># define helper_ret_stw_mmu&nbsp;&nbsp; helper_le_stw_mmu<BR># define helper_ret_stl_mmu&nbsp;&nbsp; helper_le_stl_mmu<BR># define helper_ret_stq_mmu&nbsp;&nbsp; helper_le_stq_mmu<BR># define helper_ret_ldw_cmmu&nbsp; helper_le_ldw_cmmu<BR># define helper_ret_ldl_cmmu&nbsp; helper_le_ldl_cmmu<BR># define helper_ret_ldq_cmmu&nbsp; helper_le_ldq_cmmu<BR>#endif</P>
<P>#endif /* CONFIG_SOFTMMU */</P>
<P>#endif /* TCG_H */