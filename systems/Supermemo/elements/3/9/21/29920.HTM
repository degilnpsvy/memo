#&nbsp;qemu:tcg/tcg-opc.h&nbsp; 
<P></P>
<P>/*<BR>&nbsp;* Tiny Code Generator for QEMU<BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2008 Fabrice Bellard<BR>&nbsp;*<BR>&nbsp;* Permission is hereby granted, free of charge, to any person obtaining a copy<BR>&nbsp;* of this software and associated documentation files (the "Software"), to deal<BR>&nbsp;* in the Software without restriction, including without limitation the rights<BR>&nbsp;* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<BR>&nbsp;* copies of the Software, and to permit persons to whom the Software is<BR>&nbsp;* furnished to do so, subject to the following conditions:<BR>&nbsp;*<BR>&nbsp;* The above copyright notice and this permission notice shall be included in<BR>&nbsp;* all copies or substantial portions of the Software.<BR>&nbsp;*<BR>&nbsp;* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<BR>&nbsp;* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<BR>&nbsp;* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL<BR>&nbsp;* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<BR>&nbsp;* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<BR>&nbsp;* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<BR>&nbsp;* THE SOFTWARE.<BR>&nbsp;*/</P>
<P></P>
<P>/*<BR>&nbsp;* DEF(name, oargs, iargs, cargs, flags)<BR>&nbsp;*/</P>
<P>/* predefined ops */<BR>DEF(discard, 1, 0, 0, TCG_OPF_NOT_PRESENT)<BR>DEF(set_label, 0, 0, 1, TCG_OPF_BB_END | TCG_OPF_NOT_PRESENT)</P>
<P>/* variable number of parameters */<BR>DEF(call, 0, 0, 3, TCG_OPF_CALL_CLOBBER | TCG_OPF_NOT_PRESENT)</P>
<P>DEF(br, 0, 0, 1, TCG_OPF_BB_END)</P>
<P><FONT class=extract>#define IMPL(X) (__builtin_constant_p(X) &amp;&amp; !(X) ? TCG_OPF_NOT_PRESENT : 0)<BR>#if TCG_TARGET_REG_BITS == 32<BR># define IMPL64&nbsp; TCG_OPF_64BIT | TCG_OPF_NOT_PRESENT<BR>#else<BR># define IMPL64&nbsp; TCG_OPF_64BIT<BR>#endif</FONT></P>
<P>DEF(mov_i32, 1, 1, 0, TCG_OPF_NOT_PRESENT)<BR>DEF(movi_i32, 1, 0, 1, TCG_OPF_NOT_PRESENT)<BR>DEF(setcond_i32, 1, 2, 1, 0)<BR>DEF(movcond_i32, 1, 4, 1, IMPL(TCG_TARGET_HAS_movcond_i32))<BR>/* load/store */<BR>DEF(ld8u_i32, 1, 1, 1, 0)<BR>DEF(ld8s_i32, 1, 1, 1, 0)<BR>DEF(ld16u_i32, 1, 1, 1, 0)<BR>DEF(ld16s_i32, 1, 1, 1, 0)<BR>DEF(ld_i32, 1, 1, 1, 0)<BR>DEF(st8_i32, 0, 2, 1, 0)<BR>DEF(st16_i32, 0, 2, 1, 0)<BR>DEF(st_i32, 0, 2, 1, 0)<BR>/* arith */<BR>DEF(add_i32, 1, 2, 0, 0)<BR>DEF(sub_i32, 1, 2, 0, 0)<BR>DEF(mul_i32, 1, 2, 0, 0)<BR>DEF(div_i32, 1, 2, 0, IMPL(TCG_TARGET_HAS_div_i32))<BR>DEF(divu_i32, 1, 2, 0, IMPL(TCG_TARGET_HAS_div_i32))<BR>DEF(rem_i32, 1, 2, 0, IMPL(TCG_TARGET_HAS_rem_i32))<BR>DEF(remu_i32, 1, 2, 0, IMPL(TCG_TARGET_HAS_rem_i32))<BR>DEF(div2_i32, 2, 3, 0, IMPL(TCG_TARGET_HAS_div2_i32))<BR>DEF(divu2_i32, 2, 3, 0, IMPL(TCG_TARGET_HAS_div2_i32))<BR>DEF(and_i32, 1, 2, 0, 0)<BR>DEF(or_i32, 1, 2, 0, 0)<BR>DEF(xor_i32, 1, 2, 0, 0)<BR>/* shifts/rotates */<BR>DEF(shl_i32, 1, 2, 0, 0)<BR>DEF(shr_i32, 1, 2, 0, 0)<BR>DEF(sar_i32, 1, 2, 0, 0)<BR>DEF(rotl_i32, 1, 2, 0, IMPL(TCG_TARGET_HAS_rot_i32))<BR>DEF(rotr_i32, 1, 2, 0, IMPL(TCG_TARGET_HAS_rot_i32))<BR>DEF(deposit_i32, 1, 2, 2, IMPL(TCG_TARGET_HAS_deposit_i32))</P>
<P>DEF(brcond_i32, 0, 2, 2, TCG_OPF_BB_END)</P>
<P>DEF(add2_i32, 2, 4, 0, IMPL(TCG_TARGET_HAS_add2_i32))<BR>DEF(sub2_i32, 2, 4, 0, IMPL(TCG_TARGET_HAS_sub2_i32))<BR>DEF(mulu2_i32, 2, 2, 0, IMPL(TCG_TARGET_HAS_mulu2_i32))<BR>DEF(muls2_i32, 2, 2, 0, IMPL(TCG_TARGET_HAS_muls2_i32))<BR>DEF(muluh_i32, 1, 2, 0, IMPL(TCG_TARGET_HAS_muluh_i32))<BR>DEF(mulsh_i32, 1, 2, 0, IMPL(TCG_TARGET_HAS_mulsh_i32))<BR>DEF(brcond2_i32, 0, 4, 2, TCG_OPF_BB_END | IMPL(TCG_TARGET_REG_BITS == 32))<BR>DEF(setcond2_i32, 1, 4, 1, IMPL(TCG_TARGET_REG_BITS == 32))</P>
<P>DEF(ext8s_i32, 1, 1, 0, IMPL(TCG_TARGET_HAS_ext8s_i32))<BR>DEF(ext16s_i32, 1, 1, 0, IMPL(TCG_TARGET_HAS_ext16s_i32))<BR>DEF(ext8u_i32, 1, 1, 0, IMPL(TCG_TARGET_HAS_ext8u_i32))<BR>DEF(ext16u_i32, 1, 1, 0, IMPL(TCG_TARGET_HAS_ext16u_i32))<BR>DEF(bswap16_i32, 1, 1, 0, IMPL(TCG_TARGET_HAS_bswap16_i32))<BR>DEF(bswap32_i32, 1, 1, 0, IMPL(TCG_TARGET_HAS_bswap32_i32))<BR>DEF(not_i32, 1, 1, 0, IMPL(TCG_TARGET_HAS_not_i32))<BR>DEF(neg_i32, 1, 1, 0, IMPL(TCG_TARGET_HAS_neg_i32))<BR>DEF(andc_i32, 1, 2, 0, IMPL(TCG_TARGET_HAS_andc_i32))<BR>DEF(orc_i32, 1, 2, 0, IMPL(TCG_TARGET_HAS_orc_i32))<BR>DEF(eqv_i32, 1, 2, 0, IMPL(TCG_TARGET_HAS_eqv_i32))<BR>DEF(nand_i32, 1, 2, 0, IMPL(TCG_TARGET_HAS_nand_i32))<BR>DEF(nor_i32, 1, 2, 0, IMPL(TCG_TARGET_HAS_nor_i32))</P>
<P>DEF(mov_i64, 1, 1, 0, TCG_OPF_64BIT | TCG_OPF_NOT_PRESENT)<BR>DEF(movi_i64, 1, 0, 1, TCG_OPF_64BIT | TCG_OPF_NOT_PRESENT)<BR>DEF(setcond_i64, 1, 2, 1, IMPL64)<BR>DEF(movcond_i64, 1, 4, 1, IMPL64 | IMPL(TCG_TARGET_HAS_movcond_i64))<BR>/* load/store */<BR>DEF(ld8u_i64, 1, 1, 1, IMPL64)<BR>DEF(ld8s_i64, 1, 1, 1, IMPL64)<BR>DEF(ld16u_i64, 1, 1, 1, IMPL64)<BR>DEF(ld16s_i64, 1, 1, 1, IMPL64)<BR>DEF(ld32u_i64, 1, 1, 1, IMPL64)<BR>DEF(ld32s_i64, 1, 1, 1, IMPL64)<BR>DEF(ld_i64, 1, 1, 1, IMPL64)<BR>DEF(st8_i64, 0, 2, 1, IMPL64)<BR>DEF(st16_i64, 0, 2, 1, IMPL64)<BR>DEF(st32_i64, 0, 2, 1, IMPL64)<BR>DEF(st_i64, 0, 2, 1, IMPL64)<BR>/* arith */<BR>DEF(add_i64, 1, 2, 0, IMPL64)<BR>DEF(sub_i64, 1, 2, 0, IMPL64)<BR>DEF(mul_i64, 1, 2, 0, IMPL64)<BR>DEF(div_i64, 1, 2, 0, IMPL64 | IMPL(TCG_TARGET_HAS_div_i64))<BR>DEF(divu_i64, 1, 2, 0, IMPL64 | IMPL(TCG_TARGET_HAS_div_i64))<BR>DEF(rem_i64, 1, 2, 0, IMPL64 | IMPL(TCG_TARGET_HAS_rem_i64))<BR>DEF(remu_i64, 1, 2, 0, IMPL64 | IMPL(TCG_TARGET_HAS_rem_i64))<BR>DEF(div2_i64, 2, 3, 0, IMPL64 | IMPL(TCG_TARGET_HAS_div2_i64))<BR>DEF(divu2_i64, 2, 3, 0, IMPL64 | IMPL(TCG_TARGET_HAS_div2_i64))<BR>DEF(and_i64, 1, 2, 0, IMPL64)<BR>DEF(or_i64, 1, 2, 0, IMPL64)<BR>DEF(xor_i64, 1, 2, 0, IMPL64)<BR>/* shifts/rotates */<BR>DEF(shl_i64, 1, 2, 0, IMPL64)<BR>DEF(shr_i64, 1, 2, 0, IMPL64)<BR>DEF(sar_i64, 1, 2, 0, IMPL64)<BR>DEF(rotl_i64, 1, 2, 0, IMPL64 | IMPL(TCG_TARGET_HAS_rot_i64))<BR>DEF(rotr_i64, 1, 2, 0, IMPL64 | IMPL(TCG_TARGET_HAS_rot_i64))<BR>DEF(deposit_i64, 1, 2, 2, IMPL64 | IMPL(TCG_TARGET_HAS_deposit_i64))</P>
<P>/* size changing ops */<BR>DEF(ext_i32_i64, 1, 1, 0, IMPL64)<BR>DEF(extu_i32_i64, 1, 1, 0, IMPL64)<BR>DEF(extrl_i64_i32, 1, 1, 0,<BR>&nbsp;&nbsp;&nbsp; IMPL(TCG_TARGET_HAS_extrl_i64_i32)<BR>&nbsp;&nbsp;&nbsp; | (TCG_TARGET_REG_BITS == 32 ? TCG_OPF_NOT_PRESENT : 0))<BR>DEF(extrh_i64_i32, 1, 1, 0,<BR>&nbsp;&nbsp;&nbsp; IMPL(TCG_TARGET_HAS_extrh_i64_i32)<BR>&nbsp;&nbsp;&nbsp; | (TCG_TARGET_REG_BITS == 32 ? TCG_OPF_NOT_PRESENT : 0))</P>
<P>DEF(brcond_i64, 0, 2, 2, TCG_OPF_BB_END | IMPL64)<BR>DEF(ext8s_i64, 1, 1, 0, IMPL64 | IMPL(TCG_TARGET_HAS_ext8s_i64))<BR>DEF(ext16s_i64, 1, 1, 0, IMPL64 | IMPL(TCG_TARGET_HAS_ext16s_i64))<BR>DEF(ext32s_i64, 1, 1, 0, IMPL64 | IMPL(TCG_TARGET_HAS_ext32s_i64))<BR>DEF(ext8u_i64, 1, 1, 0, IMPL64 | IMPL(TCG_TARGET_HAS_ext8u_i64))<BR>DEF(ext16u_i64, 1, 1, 0, IMPL64 | IMPL(TCG_TARGET_HAS_ext16u_i64))<BR>DEF(ext32u_i64, 1, 1, 0, IMPL64 | IMPL(TCG_TARGET_HAS_ext32u_i64))<BR>DEF(bswap16_i64, 1, 1, 0, IMPL64 | IMPL(TCG_TARGET_HAS_bswap16_i64))<BR>DEF(bswap32_i64, 1, 1, 0, IMPL64 | IMPL(TCG_TARGET_HAS_bswap32_i64))<BR>DEF(bswap64_i64, 1, 1, 0, IMPL64 | IMPL(TCG_TARGET_HAS_bswap64_i64))<BR>DEF(not_i64, 1, 1, 0, IMPL64 | IMPL(TCG_TARGET_HAS_not_i64))<BR>DEF(neg_i64, 1, 1, 0, IMPL64 | IMPL(TCG_TARGET_HAS_neg_i64))<BR>DEF(andc_i64, 1, 2, 0, IMPL64 | IMPL(TCG_TARGET_HAS_andc_i64))<BR>DEF(orc_i64, 1, 2, 0, IMPL64 | IMPL(TCG_TARGET_HAS_orc_i64))<BR>DEF(eqv_i64, 1, 2, 0, IMPL64 | IMPL(TCG_TARGET_HAS_eqv_i64))<BR>DEF(nand_i64, 1, 2, 0, IMPL64 | IMPL(TCG_TARGET_HAS_nand_i64))<BR>DEF(nor_i64, 1, 2, 0, IMPL64 | IMPL(TCG_TARGET_HAS_nor_i64))</P>
<P>DEF(add2_i64, 2, 4, 0, IMPL64 | IMPL(TCG_TARGET_HAS_add2_i64))<BR>DEF(sub2_i64, 2, 4, 0, IMPL64 | IMPL(TCG_TARGET_HAS_sub2_i64))<BR>DEF(mulu2_i64, 2, 2, 0, IMPL64 | IMPL(TCG_TARGET_HAS_mulu2_i64))<BR>DEF(muls2_i64, 2, 2, 0, IMPL64 | IMPL(TCG_TARGET_HAS_muls2_i64))<BR>DEF(muluh_i64, 1, 2, 0, IMPL(TCG_TARGET_HAS_muluh_i64))<BR>DEF(mulsh_i64, 1, 2, 0, IMPL(TCG_TARGET_HAS_mulsh_i64))</P>
<P>#define TLADDR_ARGS&nbsp; (TARGET_LONG_BITS &lt;= TCG_TARGET_REG_BITS ? 1 : 2)<BR>#define DATA64_ARGS&nbsp; (TCG_TARGET_REG_BITS == 64 ? 1 : 2)</P>
<P>/* QEMU specific */<BR>DEF(insn_start, 0, 0, TLADDR_ARGS * TARGET_INSN_START_WORDS,<BR>&nbsp;&nbsp;&nbsp; TCG_OPF_NOT_PRESENT)<BR>DEF(exit_tb, 0, 0, 1, TCG_OPF_BB_END)<BR>DEF(goto_tb, 0, 0, 1, TCG_OPF_BB_END)</P>
<P>DEF(qemu_ld_i32, 1, TLADDR_ARGS, 1,<BR>&nbsp;&nbsp;&nbsp; TCG_OPF_CALL_CLOBBER | TCG_OPF_SIDE_EFFECTS)<BR>DEF(qemu_st_i32, 0, TLADDR_ARGS + 1, 1,<BR>&nbsp;&nbsp;&nbsp; TCG_OPF_CALL_CLOBBER | TCG_OPF_SIDE_EFFECTS)<BR>DEF(qemu_ld_i64, DATA64_ARGS, TLADDR_ARGS, 1,<BR>&nbsp;&nbsp;&nbsp; TCG_OPF_CALL_CLOBBER | TCG_OPF_SIDE_EFFECTS | TCG_OPF_64BIT)<BR>DEF(qemu_st_i64, 0, TLADDR_ARGS + DATA64_ARGS, 1,<BR>&nbsp;&nbsp;&nbsp; TCG_OPF_CALL_CLOBBER | TCG_OPF_SIDE_EFFECTS | TCG_OPF_64BIT)</P>
<P>#undef TLADDR_ARGS<BR>#undef DATA64_ARGS<BR>#undef IMPL<BR>#undef IMPL64<BR>#undef DEF