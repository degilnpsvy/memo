#&nbsp;qemu:tcg/tcg-op.c 
<P></P>
<P>/*<BR>&nbsp;* Tiny Code Generator for QEMU<BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2008 Fabrice Bellard<BR>&nbsp;*<BR>&nbsp;* Permission is hereby granted, free of charge, to any person obtaining a copy<BR>&nbsp;* of this software and associated documentation files (the "Software"), to deal<BR>&nbsp;* in the Software without restriction, including without limitation the rights<BR>&nbsp;* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<BR>&nbsp;* copies of the Software, and to permit persons to whom the Software is<BR>&nbsp;* furnished to do so, subject to the following conditions:<BR>&nbsp;*<BR>&nbsp;* The above copyright notice and this permission notice shall be included in<BR>&nbsp;* all copies or substantial portions of the Software.<BR>&nbsp;*<BR>&nbsp;* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<BR>&nbsp;* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<BR>&nbsp;* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL<BR>&nbsp;* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<BR>&nbsp;* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<BR>&nbsp;* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<BR>&nbsp;* THE SOFTWARE.<BR>&nbsp;*/</P>
<P></P>
<P>#include "qemu/osdep.h"<BR>#include "qemu-common.h"<BR>#include "cpu.h"<BR>#include "exec/exec-all.h"<BR>#include "tcg.h"<BR>#include "tcg-op.h"<BR>#include "trace-tcg.h"<BR>#include "trace/mem.h"</P>
<P>/* Reduce the number of ifdefs below.&nbsp; This assumes that all uses of<BR>&nbsp;&nbsp; TCGV_HIGH and TCGV_LOW are properly protected by a conditional that<BR>&nbsp;&nbsp; the compiler can eliminate.&nbsp; */<BR>#if TCG_TARGET_REG_BITS == 64<BR>extern TCGv_i32 TCGV_LOW_link_error(TCGv_i64);<BR>extern TCGv_i32 TCGV_HIGH_link_error(TCGv_i64);<BR>#define TCGV_LOW&nbsp; TCGV_LOW_link_error<BR>#define TCGV_HIGH TCGV_HIGH_link_error<BR>#endif</P>
<P>/* Note that this is optimized for sequential allocation during translate.<BR>&nbsp;&nbsp; Up to and including filling in the forward link immediately.&nbsp; We'll do<BR>&nbsp;&nbsp; proper termination of the end of the list after we finish translation.&nbsp; */</P>
<P><FONT class=extract>static void tcg_emit_op(TCGContext *ctx, TCGOpcode opc, int args)<BR>{<BR>&nbsp;&nbsp;&nbsp; int oi = ctx-&gt;gen_next_op_idx;<BR>&nbsp;&nbsp;&nbsp; int ni = oi + 1;<BR>&nbsp;&nbsp;&nbsp; int pi = oi - 1;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_debug_assert(oi &lt; OPC_BUF_SIZE);<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_op_buf[0].prev = oi;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_next_op_idx = ni;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_op_buf[oi] = (TCGOp){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc = opc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .args = args,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .prev = pi,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .next = ni<BR>&nbsp;&nbsp;&nbsp; };<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_op1(TCGContext *ctx, TCGOpcode opc, TCGArg a1)<BR>{<BR>&nbsp;&nbsp;&nbsp; int pi = ctx-&gt;gen_next_parm_idx;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_debug_assert(pi + 1 &lt;= OPPARAM_BUF_SIZE);<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_next_parm_idx = pi + 1;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi] = a1;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_emit_op(ctx, opc, pi);<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_op2(TCGContext *ctx, TCGOpcode opc, TCGArg a1, TCGArg a2)<BR>{<BR>&nbsp;&nbsp;&nbsp; int pi = ctx-&gt;gen_next_parm_idx;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_debug_assert(pi + 2 &lt;= OPPARAM_BUF_SIZE);<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_next_parm_idx = pi + 2;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 0] = a1;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 1] = a2;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_emit_op(ctx, opc, pi);<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_op3(TCGContext *ctx, TCGOpcode opc, TCGArg a1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg a2, TCGArg a3)<BR>{<BR>&nbsp;&nbsp;&nbsp; int pi = ctx-&gt;gen_next_parm_idx;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_debug_assert(pi + 3 &lt;= OPPARAM_BUF_SIZE);<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_next_parm_idx = pi + 3;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 0] = a1;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 1] = a2;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 2] = a3;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_emit_op(ctx, opc, pi);<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_op4(TCGContext *ctx, TCGOpcode opc, TCGArg a1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg a2, TCGArg a3, TCGArg a4)<BR>{<BR>&nbsp;&nbsp;&nbsp; int pi = ctx-&gt;gen_next_parm_idx;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_debug_assert(pi + 4 &lt;= OPPARAM_BUF_SIZE);<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_next_parm_idx = pi + 4;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 0] = a1;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 1] = a2;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 2] = a3;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 3] = a4;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_emit_op(ctx, opc, pi);<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_op5(TCGContext *ctx, TCGOpcode opc, TCGArg a1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg a2, TCGArg a3, TCGArg a4, TCGArg a5)<BR>{<BR>&nbsp;&nbsp;&nbsp; int pi = ctx-&gt;gen_next_parm_idx;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_debug_assert(pi + 5 &lt;= OPPARAM_BUF_SIZE);<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_next_parm_idx = pi + 5;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 0] = a1;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 1] = a2;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 2] = a3;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 3] = a4;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 4] = a5;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_emit_op(ctx, opc, pi);<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_op6(TCGContext *ctx, TCGOpcode opc, TCGArg a1, TCGArg a2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg a3, TCGArg a4, TCGArg a5, TCGArg a6)<BR>{<BR>&nbsp;&nbsp;&nbsp; int pi = ctx-&gt;gen_next_parm_idx;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_debug_assert(pi + 6 &lt;= OPPARAM_BUF_SIZE);<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_next_parm_idx = pi + 6;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 0] = a1;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 1] = a2;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 2] = a3;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 3] = a4;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 4] = a5;<BR>&nbsp;&nbsp;&nbsp; ctx-&gt;gen_opparam_buf[pi + 5] = a6;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_emit_op(ctx, opc, pi);<BR>}</FONT></P>
<P>/* 32 bit ops */</P>
<P><FONT class=extract>void tcg_gen_addi_i32(TCGv_i32 ret, TCGv_i32 arg1, int32_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* some cases can be optimized here */<BR>&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_const_i32(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_add_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_subfi_i32(TCGv_i32 ret, int32_t arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arg1 == 0 &amp;&amp; TCG_TARGET_HAS_neg_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Don't recurse with tcg_gen_neg_i32.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i32(INDEX_op_neg_i32, ret, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_const_i32(arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i32(ret, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_subi_i32(TCGv_i32 ret, TCGv_i32 arg1, int32_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* some cases can be optimized here */<BR>&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_const_i32(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_andi_i32(TCGv_i32 ret, TCGv_i32 arg1, uint32_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 t0;<BR>&nbsp;&nbsp;&nbsp; /* Some cases can be optimized here.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; switch (arg2) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(ret, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; case 0xffffffffu:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; case 0xffu:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Don't recurse with tcg_gen_ext8u_i32.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_ext8u_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i32(INDEX_op_ext8u_i32, ret, arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 0xffffu:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_ext16u_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i32(INDEX_op_ext16u_i32, ret, arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; t0 = tcg_const_i32(arg2);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_and_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_ori_i32(TCGv_i32 ret, TCGv_i32 arg1, int32_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Some cases can be optimized here.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arg2 == -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(ret, -1);<BR>&nbsp;&nbsp;&nbsp; } else if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_const_i32(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_xori_i32(TCGv_i32 ret, TCGv_i32 arg1, int32_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Some cases can be optimized here.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else if (arg2 == -1 &amp;&amp; TCG_TARGET_HAS_not_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Don't recurse with tcg_gen_not_i32.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i32(INDEX_op_not_i32, ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_const_i32(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_shli_i32(TCGv_i32 ret, TCGv_i32 arg1, unsigned arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(arg2 &lt; 32);<BR>&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_const_i32(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shl_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_shri_i32(TCGv_i32 ret, TCGv_i32 arg1, unsigned arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(arg2 &lt; 32);<BR>&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_const_i32(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shr_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_sari_i32(TCGv_i32 ret, TCGv_i32 arg1, unsigned arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(arg2 &lt; 32);<BR>&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_const_i32(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sar_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_brcond_i32(TCGCond cond, TCGv_i32 arg1, TCGv_i32 arg2, TCGLabel *l)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (cond == TCG_COND_ALWAYS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_br(l);<BR>&nbsp;&nbsp;&nbsp; } else if (cond != TCG_COND_NEVER) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op4ii_i32(INDEX_op_brcond_i32, arg1, arg2, cond, label_arg(l));<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_brcondi_i32(TCGCond cond, TCGv_i32 arg1, int32_t arg2, TCGLabel *l)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (cond == TCG_COND_ALWAYS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_br(l);<BR>&nbsp;&nbsp;&nbsp; } else if (cond != TCG_COND_NEVER) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_const_i32(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_brcond_i32(cond, arg1, t0, l);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_setcond_i32(TCGCond cond, TCGv_i32 ret,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (cond == TCG_COND_ALWAYS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(ret, 1);<BR>&nbsp;&nbsp;&nbsp; } else if (cond == TCG_COND_NEVER) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(ret, 0);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op4i_i32(INDEX_op_setcond_i32, ret, arg1, arg2, cond);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_setcondi_i32(TCGCond cond, TCGv_i32 ret,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 arg1, int32_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_const_i32(arg2);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_setcond_i32(cond, ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_muli_i32(TCGv_i32 ret, TCGv_i32 arg1, int32_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_const_i32(arg2);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mul_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_div_i32(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_div_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_div_i32, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_div2_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(t0, arg1, 31);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op5_i32(INDEX_op_div2_i32, ret, t0, arg1, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_div_i32(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_rem_i32(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_rem_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_rem_i32, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_div_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_div_i32, t0, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mul_i32(t0, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_div2_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(t0, arg1, 31);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op5_i32(INDEX_op_div2_i32, t0, ret, arg1, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_rem_i32(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_divu_i32(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_div_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_divu_i32, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_div2_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(t0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op5_i32(INDEX_op_divu2_i32, ret, t0, arg1, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_divu_i32(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_remu_i32(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_rem_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_remu_i32, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_div_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_divu_i32, t0, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mul_i32(t0, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_div2_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(t0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op5_i32(INDEX_op_divu2_i32, t0, ret, arg1, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_remu_i32(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_andc_i32(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_andc_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_andc_i32, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_not_i32(t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_and_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_eqv_i32(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_eqv_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_eqv_i32, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_not_i32(ret, ret);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_nand_i32(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_nand_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_nand_i32, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_and_i32(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_not_i32(ret, ret);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_nor_i32(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_nor_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_nor_i32, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_not_i32(ret, ret);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_orc_i32(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_orc_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_orc_i32, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_not_i32(t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_rotl_i32(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_rot_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_rotl_i32, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0, t1;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shl_i32(t0, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_subfi_i32(t1, 32, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shr_i32(t1, arg1, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(ret, t0, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_rotli_i32(TCGv_i32 ret, TCGv_i32 arg1, unsigned arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(arg2 &lt; 32);<BR>&nbsp;&nbsp;&nbsp; /* some cases can be optimized here */<BR>&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_rot_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_const_i32(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_rotl_i32(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0, t1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(t0, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i32(t1, arg1, 32 - arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(ret, t0, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_rotr_i32(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_rot_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_rotr_i32, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0, t1;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shr_i32(t0, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_subfi_i32(t1, 32, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shl_i32(t1, arg1, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(ret, t0, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_rotri_i32(TCGv_i32 ret, TCGv_i32 arg1, unsigned arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(arg2 &lt; 32);<BR>&nbsp;&nbsp;&nbsp; /* some cases can be optimized here */<BR>&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_rotli_i32(ret, arg1, 32 - arg2);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_deposit_i32(TCGv_i32 ret, TCGv_i32 arg1, TCGv_i32 arg2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int ofs, unsigned int len)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t mask;<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 t1;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_debug_assert(ofs &lt; 32);<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(len &lt;= 32);<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(ofs + len &lt;= 32);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (ofs == 0 &amp;&amp; len == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_deposit_i32 &amp;&amp; TCG_TARGET_deposit_i32_valid(ofs, len)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op5ii_i32(INDEX_op_deposit_i32, ret, arg1, arg2, ofs, len);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; mask = (1u &lt;&lt; len) - 1;<BR>&nbsp;&nbsp;&nbsp; t1 = tcg_temp_new_i32();</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (ofs + len &lt; 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(t1, arg2, mask);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(t1, t1, ofs);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(t1, arg2, ofs);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(ret, arg1, ~(mask &lt;&lt; ofs));<BR>&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(ret, ret, t1);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t1);<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_movcond_i32(TCGCond cond, TCGv_i32 ret, TCGv_i32 c1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 c2, TCGv_i32 v1, TCGv_i32 v2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (cond == TCG_COND_ALWAYS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, v1);<BR>&nbsp;&nbsp;&nbsp; } else if (cond == TCG_COND_NEVER) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, v2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_movcond_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op6i_i32(INDEX_op_movcond_i32, ret, c1, c2, v1, v2, cond);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t1 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_setcond_i32(cond, t0, c1, c2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_neg_i32(t0, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_and_i32(t1, v1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andc_i32(ret, v2, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(ret, ret, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_add2_i32(TCGv_i32 rl, TCGv_i32 rh, TCGv_i32 al,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 ah, TCGv_i32 bl, TCGv_i32 bh)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_add2_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op6_i32(INDEX_op_add2_i32, rl, rh, al, ah, bl, bh);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t1 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_concat_i32_i64(t0, al, ah);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_concat_i32_i64(t1, bl, bh);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_add_i64(t0, t0, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extr_i64_i32(rl, rh, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_sub2_i32(TCGv_i32 rl, TCGv_i32 rh, TCGv_i32 al,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 ah, TCGv_i32 bl, TCGv_i32 bh)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_sub2_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op6_i32(INDEX_op_sub2_i32, rl, rh, al, ah, bl, bh);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t1 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_concat_i32_i64(t0, al, ah);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_concat_i32_i64(t1, bl, bh);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i64(t0, t0, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extr_i64_i32(rl, rh, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_mulu2_i32(TCGv_i32 rl, TCGv_i32 rh, TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_mulu2_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op4_i32(INDEX_op_mulu2_i32, rl, rh, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_muluh_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_mul_i32, t, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_muluh_i32, rh, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(rl, t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t1 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(t0, arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(t1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mul_i64(t0, t0, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extr_i64_i32(rl, rh, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_muls2_i32(TCGv_i32 rl, TCGv_i32 rh, TCGv_i32 arg1, TCGv_i32 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_muls2_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op4_i32(INDEX_op_muls2_i32, rl, rh, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_mulsh_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_mul_i32, t, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i32(INDEX_op_mulsh_i32, rh, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(rl, t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t1 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t2 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t3 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mulu2_i32(t0, t1, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Adjust for negative inputs.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(t2, arg1, 31);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(t3, arg2, 31);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_and_i32(t2, t2, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_and_i32(t3, t3, arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i32(rh, t1, t2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i32(rh, rh, t3);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(rl, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t3);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t1 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ext_i32_i64(t0, arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ext_i32_i64(t1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mul_i64(t0, t0, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extr_i64_i32(rl, rh, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_ext8s_i32(TCGv_i32 ret, TCGv_i32 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_ext8s_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i32(INDEX_op_ext8s_i32, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(ret, arg, 24);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(ret, ret, 24);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_ext16s_i32(TCGv_i32 ret, TCGv_i32 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_ext16s_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i32(INDEX_op_ext16s_i32, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(ret, arg, 16);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(ret, ret, 16);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_ext8u_i32(TCGv_i32 ret, TCGv_i32 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_ext8u_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i32(INDEX_op_ext8u_i32, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(ret, arg, 0xffu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_ext16u_i32(TCGv_i32 ret, TCGv_i32 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_ext16u_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i32(INDEX_op_ext16u_i32, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(ret, arg, 0xffffu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>/* Note: we assume the two high bytes are set to zero */<BR>void tcg_gen_bswap16_i32(TCGv_i32 ret, TCGv_i32 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_bswap16_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i32(INDEX_op_bswap16_i32, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_temp_new_i32();</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ext8u_i32(t0, arg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(t0, t0, 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i32(ret, arg, 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(ret, ret, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_bswap32_i32(TCGv_i32 ret, TCGv_i32 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_bswap32_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i32(INDEX_op_bswap32_i32, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0, t1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = tcg_temp_new_i32();</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(t0, arg, 24);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(t1, arg, 0x0000ff00);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(t1, t1, 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(t0, t0, t1);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i32(t1, arg, 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(t1, t1, 0x0000ff00);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(t0, t0, t1);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i32(t1, arg, 24);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(ret, t0, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P>/* 64-bit ops */</P>
<P>#if TCG_TARGET_REG_BITS == 32<BR>/* These are all inline for TCG_TARGET_REG_BITS == 64.&nbsp; */</P>
<P>void tcg_gen_discard_i64(TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_discard_i32(TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp; tcg_gen_discard_i32(TCGV_HIGH(arg));<BR>}</P>
<P>void tcg_gen_mov_i64(TCGv_i64 ret, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_LOW(ret), TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_HIGH(ret), TCGV_HIGH(arg));<BR>}</P>
<P>void tcg_gen_movi_i64(TCGv_i64 ret, int64_t arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_LOW(ret), arg);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_HIGH(ret), arg &gt;&gt; 32);<BR>}</P>
<P>void tcg_gen_ld8u_i64(TCGv_i64 ret, TCGv_ptr arg2, tcg_target_long offset)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ld8u_i32(TCGV_LOW(ret), arg2, offset);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_HIGH(ret), 0);<BR>}</P>
<P>void tcg_gen_ld8s_i64(TCGv_i64 ret, TCGv_ptr arg2, tcg_target_long offset)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ld8s_i32(TCGV_LOW(ret), arg2, offset);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(TCGV_HIGH(ret), TCGV_HIGH(ret), 31);<BR>}</P>
<P>void tcg_gen_ld16u_i64(TCGv_i64 ret, TCGv_ptr arg2, tcg_target_long offset)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ld16u_i32(TCGV_LOW(ret), arg2, offset);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_HIGH(ret), 0);<BR>}</P>
<P>void tcg_gen_ld16s_i64(TCGv_i64 ret, TCGv_ptr arg2, tcg_target_long offset)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ld16s_i32(TCGV_LOW(ret), arg2, offset);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(TCGV_HIGH(ret), TCGV_LOW(ret), 31);<BR>}</P>
<P>void tcg_gen_ld32u_i64(TCGv_i64 ret, TCGv_ptr arg2, tcg_target_long offset)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ld_i32(TCGV_LOW(ret), arg2, offset);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_HIGH(ret), 0);<BR>}</P>
<P>void tcg_gen_ld32s_i64(TCGv_i64 ret, TCGv_ptr arg2, tcg_target_long offset)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ld_i32(TCGV_LOW(ret), arg2, offset);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(TCGV_HIGH(ret), TCGV_LOW(ret), 31);<BR>}</P>
<P>void tcg_gen_ld_i64(TCGv_i64 ret, TCGv_ptr arg2, tcg_target_long offset)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Since arg2 and ret have different types,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; they cannot be the same temporary */<BR>#ifdef HOST_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ld_i32(TCGV_HIGH(ret), arg2, offset);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ld_i32(TCGV_LOW(ret), arg2, offset + 4);<BR>#else<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ld_i32(TCGV_LOW(ret), arg2, offset);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ld_i32(TCGV_HIGH(ret), arg2, offset + 4);<BR>#endif<BR>}</P>
<P>void tcg_gen_st_i64(TCGv_i64 arg1, TCGv_ptr arg2, tcg_target_long offset)<BR>{<BR>#ifdef HOST_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp; tcg_gen_st_i32(TCGV_HIGH(arg1), arg2, offset);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_st_i32(TCGV_LOW(arg1), arg2, offset + 4);<BR>#else<BR>&nbsp;&nbsp;&nbsp; tcg_gen_st_i32(TCGV_LOW(arg1), arg2, offset);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_st_i32(TCGV_HIGH(arg1), arg2, offset + 4);<BR>#endif<BR>}</P>
<P>void tcg_gen_and_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_and_i32(TCGV_LOW(ret), TCGV_LOW(arg1), TCGV_LOW(arg2));<BR>&nbsp;&nbsp;&nbsp; tcg_gen_and_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1), TCGV_HIGH(arg2));<BR>}</P>
<P>void tcg_gen_or_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(TCGV_LOW(ret), TCGV_LOW(arg1), TCGV_LOW(arg2));<BR>&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1), TCGV_HIGH(arg2));<BR>}</P>
<P>void tcg_gen_xor_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(TCGV_LOW(ret), TCGV_LOW(arg1), TCGV_LOW(arg2));<BR>&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1), TCGV_HIGH(arg2));<BR>}</P>
<P>void tcg_gen_shl_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; gen_helper_shl_i64(ret, arg1, arg2);<BR>}</P>
<P>void tcg_gen_shr_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; gen_helper_shr_i64(ret, arg1, arg2);<BR>}</P>
<P>void tcg_gen_sar_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; gen_helper_sar_i64(ret, arg1, arg2);<BR>}</P>
<P>void tcg_gen_mul_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 t0;<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 t1;</P>
<P>&nbsp;&nbsp;&nbsp; t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp; t1 = tcg_temp_new_i32();</P>
<P>&nbsp;&nbsp;&nbsp; tcg_gen_mulu2_i32(TCGV_LOW(t0), TCGV_HIGH(t0),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGV_LOW(arg1), TCGV_LOW(arg2));</P>
<P>&nbsp;&nbsp;&nbsp; tcg_gen_mul_i32(t1, TCGV_LOW(arg1), TCGV_HIGH(arg2));<BR>&nbsp;&nbsp;&nbsp; tcg_gen_add_i32(TCGV_HIGH(t0), TCGV_HIGH(t0), t1);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mul_i32(t1, TCGV_HIGH(arg1), TCGV_LOW(arg2));<BR>&nbsp;&nbsp;&nbsp; tcg_gen_add_i32(TCGV_HIGH(t0), TCGV_HIGH(t0), t1);</P>
<P>&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, t0);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t1);<BR>}<BR>#endif /* TCG_TARGET_REG_SIZE == 32 */</P>
<P>void tcg_gen_addi_i64(TCGv_i64 ret, TCGv_i64 arg1, int64_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* some cases can be optimized here */<BR>&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_const_i64(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_add_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_subfi_i64(TCGv_i64 ret, int64_t arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arg1 == 0 &amp;&amp; TCG_TARGET_HAS_neg_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Don't recurse with tcg_gen_neg_i64.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_neg_i64, ret, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_const_i64(arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i64(ret, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_subi_i64(TCGv_i64 ret, TCGv_i64 arg1, int64_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* some cases can be optimized here */<BR>&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_const_i64(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_andi_i64(TCGv_i64 ret, TCGv_i64 arg1, uint64_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 t0;</P>
<P>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(TCGV_LOW(ret), TCGV_LOW(arg1), arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1), arg2 &gt;&gt; 32);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Some cases can be optimized here.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; switch (arg2) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i64(ret, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; case 0xffffffffffffffffull:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; case 0xffull:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Don't recurse with tcg_gen_ext8u_i64.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_ext8u_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_ext8u_i64, ret, arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 0xffffu:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_ext16u_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_ext16u_i64, ret, arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 0xffffffffull:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_ext32u_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_ext32u_i64, ret, arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; t0 = tcg_const_i64(arg2);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_and_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>}</P>
<P>void tcg_gen_ori_i64(TCGv_i64 ret, TCGv_i64 arg1, int64_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ori_i32(TCGV_LOW(ret), TCGV_LOW(arg1), arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ori_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1), arg2 &gt;&gt; 32);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* Some cases can be optimized here.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arg2 == -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i64(ret, -1);<BR>&nbsp;&nbsp;&nbsp; } else if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_const_i64(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_xori_i64(TCGv_i64 ret, TCGv_i64 arg1, int64_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_xori_i32(TCGV_LOW(ret), TCGV_LOW(arg1), arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_xori_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1), arg2 &gt;&gt; 32);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* Some cases can be optimized here.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else if (arg2 == -1 &amp;&amp; TCG_TARGET_HAS_not_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Don't recurse with tcg_gen_not_i64.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_not_i64, ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_const_i64(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_xor_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static inline void tcg_gen_shifti_i64(TCGv_i64 ret, TCGv_i64 arg1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned c, bool right, bool arith)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(c &lt; 64);<BR>&nbsp;&nbsp;&nbsp; if (c == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_LOW(ret), TCGV_LOW(arg1));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1));<BR>&nbsp;&nbsp;&nbsp; } else if (c &gt;= 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c -= 32;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (right) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arith) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(TCGV_LOW(ret), TCGV_HIGH(arg1), c);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1), 31);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i32(TCGV_LOW(ret), TCGV_HIGH(arg1), c);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_HIGH(ret), 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(TCGV_HIGH(ret), TCGV_LOW(arg1), c);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_LOW(ret), 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0, t1;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (right) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(t0, TCGV_HIGH(arg1), 32 - c);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arith) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(t1, TCGV_HIGH(arg1), c);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i32(t1, TCGV_HIGH(arg1), c);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i32(TCGV_LOW(ret), TCGV_LOW(arg1), c);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(TCGV_LOW(ret), TCGV_LOW(ret), t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_HIGH(ret), t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i32(t0, TCGV_LOW(arg1), 32 - c);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note: ret can be the same as arg1, so we use t1 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(t1, TCGV_LOW(arg1), c);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1), c);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(TCGV_HIGH(ret), TCGV_HIGH(ret), t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_LOW(ret), t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_shli_i64(TCGv_i64 ret, TCGv_i64 arg1, unsigned arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(arg2 &lt; 64);<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shifti_i64(ret, arg1, arg2, 0, 0);<BR>&nbsp;&nbsp;&nbsp; } else if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_const_i64(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shl_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_shri_i64(TCGv_i64 ret, TCGv_i64 arg1, unsigned arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(arg2 &lt; 64);<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shifti_i64(ret, arg1, arg2, 1, 0);<BR>&nbsp;&nbsp;&nbsp; } else if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_const_i64(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shr_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_sari_i64(TCGv_i64 ret, TCGv_i64 arg1, unsigned arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(arg2 &lt; 64);<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shifti_i64(ret, arg1, arg2, 1, 1);<BR>&nbsp;&nbsp;&nbsp; } else if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_const_i64(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sar_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_brcond_i64(TCGCond cond, TCGv_i64 arg1, TCGv_i64 arg2, TCGLabel *l)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (cond == TCG_COND_ALWAYS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_br(l);<BR>&nbsp;&nbsp;&nbsp; } else if (cond != TCG_COND_NEVER) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op6ii_i32(INDEX_op_brcond2_i32, TCGV_LOW(arg1),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGV_HIGH(arg1), TCGV_LOW(arg2),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGV_HIGH(arg2), cond, label_arg(l));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op4ii_i64(INDEX_op_brcond_i64, arg1, arg2, cond,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_arg(l));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_brcondi_i64(TCGCond cond, TCGv_i64 arg1, int64_t arg2, TCGLabel *l)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (cond == TCG_COND_ALWAYS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_br(l);<BR>&nbsp;&nbsp;&nbsp; } else if (cond != TCG_COND_NEVER) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_const_i64(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_brcond_i64(cond, arg1, t0, l);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_setcond_i64(TCGCond cond, TCGv_i64 ret,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (cond == TCG_COND_ALWAYS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i64(ret, 1);<BR>&nbsp;&nbsp;&nbsp; } else if (cond == TCG_COND_NEVER) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i64(ret, 0);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op6i_i32(INDEX_op_setcond2_i32, TCGV_LOW(ret),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGV_LOW(arg1), TCGV_HIGH(arg1),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGV_LOW(arg2), TCGV_HIGH(arg2), cond);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_HIGH(ret), 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op4i_i64(INDEX_op_setcond_i64, ret, arg1, arg2, cond);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_setcondi_i64(TCGCond cond, TCGv_i64 ret,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 arg1, int64_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_const_i64(arg2);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_setcond_i64(cond, ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>}</P>
<P>void tcg_gen_muli_i64(TCGv_i64 ret, TCGv_i64 arg1, int64_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_const_i64(arg2);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mul_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>}</P>
<P>void tcg_gen_div_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_div_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_div_i64, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_div2_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i64(t0, arg1, 63);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op5_i64(INDEX_op_div2_i64, ret, t0, arg1, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_div_i64(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_rem_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_rem_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_rem_i64, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_div_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_div_i64, t0, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mul_i64(t0, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_div2_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i64(t0, arg1, 63);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op5_i64(INDEX_op_div2_i64, t0, ret, arg1, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_rem_i64(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_divu_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_div_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_divu_i64, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_div2_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i64(t0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op5_i64(INDEX_op_divu2_i64, ret, t0, arg1, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_divu_i64(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_remu_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_rem_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_remu_i64, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_div_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_divu_i64, t0, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mul_i64(t0, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_div2_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i64(t0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op5_i64(INDEX_op_divu2_i64, t0, ret, arg1, t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_remu_i64(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_ext8s_i64(TCGv_i64 ret, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ext8s_i32(TCGV_LOW(ret), TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(TCGV_HIGH(ret), TCGV_LOW(ret), 31);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_ext8s_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_ext8s_i64, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(ret, arg, 56);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i64(ret, ret, 56);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_ext16s_i64(TCGv_i64 ret, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ext16s_i32(TCGV_LOW(ret), TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(TCGV_HIGH(ret), TCGV_LOW(ret), 31);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_ext16s_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_ext16s_i64, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(ret, arg, 48);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i64(ret, ret, 48);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_ext32s_i64(TCGv_i64 ret, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_LOW(ret), TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(TCGV_HIGH(ret), TCGV_LOW(ret), 31);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_ext32s_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_ext32s_i64, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(ret, arg, 32);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i64(ret, ret, 32);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_ext8u_i64(TCGv_i64 ret, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ext8u_i32(TCGV_LOW(ret), TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_HIGH(ret), 0);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_ext8u_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_ext8u_i64, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i64(ret, arg, 0xffu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_ext16u_i64(TCGv_i64 ret, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ext16u_i32(TCGV_LOW(ret), TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_HIGH(ret), 0);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_ext16u_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_ext16u_i64, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i64(ret, arg, 0xffffu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_ext32u_i64(TCGv_i64 ret, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_LOW(ret), TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_HIGH(ret), 0);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_ext32u_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_ext32u_i64, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i64(ret, arg, 0xffffffffu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Note: we assume the six high bytes are set to zero */<BR>void tcg_gen_bswap16_i64(TCGv_i64 ret, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_bswap16_i32(TCGV_LOW(ret), TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_HIGH(ret), 0);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_bswap16_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_bswap16_i64, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ext8u_i64(t0, arg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(t0, t0, 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i64(ret, arg, 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(ret, ret, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Note: we assume the four high bytes are set to zero */<BR>void tcg_gen_bswap32_i64(TCGv_i64 ret, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_bswap32_i32(TCGV_LOW(ret), TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_HIGH(ret), 0);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_bswap32_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_bswap32_i64, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0, t1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = tcg_temp_new_i64();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(t0, arg, 24);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ext32u_i64(t0, t0);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i64(t1, arg, 0x0000ff00);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(t1, t1, 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(t0, t0, t1);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i64(t1, arg, 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i64(t1, t1, 0x0000ff00);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(t0, t0, t1);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i64(t1, arg, 24);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(ret, t0, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_bswap64_i64(TCGv_i64 ret, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0, t1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = tcg_temp_new_i32();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_bswap32_i32(t0, TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_bswap32_i32(t1, TCGV_HIGH(arg));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_LOW(ret), t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_HIGH(ret), t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t1);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_bswap64_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_bswap64_i64, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t1 = tcg_temp_new_i64();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(t0, arg, 56);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i64(t1, arg, 0x0000ff00);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(t1, t1, 40);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(t0, t0, t1);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i64(t1, arg, 0x00ff0000);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(t1, t1, 24);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(t0, t0, t1);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i64(t1, arg, 0xff000000);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(t1, t1, 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(t0, t0, t1);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i64(t1, arg, 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i64(t1, t1, 0xff000000);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(t0, t0, t1);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i64(t1, arg, 24);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i64(t1, t1, 0x00ff0000);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(t0, t0, t1);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i64(t1, arg, 40);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i64(t1, t1, 0x0000ff00);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(t0, t0, t1);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i64(t1, arg, 56);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(ret, t0, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_not_i64(TCGv_i64 ret, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_not_i32(TCGV_LOW(ret), TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_not_i32(TCGV_HIGH(ret), TCGV_HIGH(arg));<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_not_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2_i64(INDEX_op_not_i64, ret, arg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_xori_i64(ret, arg, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_andc_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andc_i32(TCGV_LOW(ret), TCGV_LOW(arg1), TCGV_LOW(arg2));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andc_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1), TCGV_HIGH(arg2));<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_andc_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_andc_i64, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_not_i64(t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_and_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_eqv_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_eqv_i32(TCGV_LOW(ret), TCGV_LOW(arg1), TCGV_LOW(arg2));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_eqv_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1), TCGV_HIGH(arg2));<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_eqv_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_eqv_i64, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_xor_i64(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_not_i64(ret, ret);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_nand_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_nand_i32(TCGV_LOW(ret), TCGV_LOW(arg1), TCGV_LOW(arg2));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_nand_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1), TCGV_HIGH(arg2));<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_nand_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_nand_i64, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_and_i64(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_not_i64(ret, ret);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_nor_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_nor_i32(TCGV_LOW(ret), TCGV_LOW(arg1), TCGV_LOW(arg2));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_nor_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1), TCGV_HIGH(arg2));<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_nor_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_nor_i64, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_not_i64(ret, ret);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_orc_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_orc_i32(TCGV_LOW(ret), TCGV_LOW(arg1), TCGV_LOW(arg2));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_orc_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1), TCGV_HIGH(arg2));<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_orc_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_orc_i64, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_not_i64(t0, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_rotl_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_rot_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_rotl_i64, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0, t1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shl_i64(t0, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_subfi_i64(t1, 64, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shr_i64(t1, arg1, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(ret, t0, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_rotli_i64(TCGv_i64 ret, TCGv_i64 arg1, unsigned arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(arg2 &lt; 64);<BR>&nbsp;&nbsp;&nbsp; /* some cases can be optimized here */<BR>&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_rot_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_const_i64(arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_rotl_i64(ret, arg1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0, t1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(t0, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i64(t1, arg1, 64 - arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(ret, t0, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_rotr_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_rot_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_rotr_i64, ret, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0, t1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shr_i64(t0, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_subfi_i64(t1, 64, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shl_i64(t1, arg1, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(ret, t0, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_rotri_i64(TCGv_i64 ret, TCGv_i64 arg1, unsigned arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(arg2 &lt; 64);<BR>&nbsp;&nbsp;&nbsp; /* some cases can be optimized here */<BR>&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, arg1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_rotli_i64(ret, arg1, 64 - arg2);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_deposit_i64(TCGv_i64 ret, TCGv_i64 arg1, TCGv_i64 arg2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int ofs, unsigned int len)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t mask;<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 t1;</P>
<P>&nbsp;&nbsp;&nbsp; tcg_debug_assert(ofs &lt; 64);<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(len &lt;= 64);<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(ofs + len &lt;= 64);</P>
<P>&nbsp;&nbsp;&nbsp; if (ofs == 0 &amp;&amp; len == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_deposit_i64 &amp;&amp; TCG_TARGET_deposit_i64_valid(ofs, len)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op5ii_i64(INDEX_op_deposit_i64, ret, arg1, arg2, ofs, len);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ofs &gt;= 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_deposit_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGV_LOW(arg2), ofs - 32, len);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_LOW(ret), TCGV_LOW(arg1));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ofs + len &lt;= 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_deposit_i32(TCGV_LOW(ret), TCGV_LOW(arg1),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGV_LOW(arg2), ofs, len);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_HIGH(ret), TCGV_HIGH(arg1));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; mask = (1ull &lt;&lt; len) - 1;<BR>&nbsp;&nbsp;&nbsp; t1 = tcg_temp_new_i64();</P>
<P>&nbsp;&nbsp;&nbsp; if (ofs + len &lt; 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i64(t1, arg2, mask);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(t1, t1, ofs);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(t1, arg2, ofs);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_gen_andi_i64(ret, arg1, ~(mask &lt;&lt; ofs));<BR>&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(ret, ret, t1);</P>
<P>&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>}</P>
<P>void tcg_gen_movcond_i64(TCGCond cond, TCGv_i64 ret, TCGv_i64 c1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 c2, TCGv_i64 v1, TCGv_i64 v2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (cond == TCG_COND_ALWAYS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, v1);<BR>&nbsp;&nbsp;&nbsp; } else if (cond == TCG_COND_NEVER) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(ret, v2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t0 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 t1 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op6i_i32(INDEX_op_setcond2_i32, t0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGV_LOW(c1), TCGV_HIGH(c1),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGV_LOW(c2), TCGV_HIGH(c2), cond);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_movcond_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(t1, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movcond_i32(TCG_COND_NE, TCGV_LOW(ret), t0, t1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGV_LOW(v1), TCGV_LOW(v2));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movcond_i32(TCG_COND_NE, TCGV_HIGH(ret), t0, t1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGV_HIGH(v1), TCGV_HIGH(v2));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_neg_i32(t0, t0);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_and_i32(t1, TCGV_LOW(v1), t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andc_i32(TCGV_LOW(ret), TCGV_LOW(v2), t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(TCGV_LOW(ret), TCGV_LOW(ret), t1);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_and_i32(t1, TCGV_HIGH(v1), t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andc_i32(TCGV_HIGH(ret), TCGV_HIGH(v2), t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(TCGV_HIGH(ret), TCGV_HIGH(ret), t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t1);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_movcond_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op6i_i64(INDEX_op_movcond_i64, ret, c1, c2, v1, v2, cond);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t1 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_setcond_i64(cond, t0, c1, c2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_neg_i64(t0, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_and_i64(t1, v1, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andc_i64(ret, v2, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(ret, ret, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_add2_i64(TCGv_i64 rl, TCGv_i64 rh, TCGv_i64 al,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 ah, TCGv_i64 bl, TCGv_i64 bh)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_add2_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op6_i64(INDEX_op_add2_i64, rl, rh, al, ah, bl, bh);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t1 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_add_i64(t0, al, bl);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_setcond_i64(TCG_COND_LTU, t1, t0, al);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_add_i64(rh, ah, bh);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_add_i64(rh, rh, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(rl, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_sub2_i64(TCGv_i64 rl, TCGv_i64 rh, TCGv_i64 al,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 ah, TCGv_i64 bl, TCGv_i64 bh)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_sub2_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op6_i64(INDEX_op_sub2_i64, rl, rh, al, ah, bl, bh);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t1 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i64(t0, al, bl);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_setcond_i64(TCG_COND_LTU, t1, al, bl);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i64(rh, ah, bh);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i64(rh, rh, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(rl, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_mulu2_i64(TCGv_i64 rl, TCGv_i64 rh, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_mulu2_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op4_i64(INDEX_op_mulu2_i64, rl, rh, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_muluh_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_mul_i64, t, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_muluh_i64, rh, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(rl, t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mul_i64(t0, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_muluh_i64(rh, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(rl, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void tcg_gen_muls2_i64(TCGv_i64 rl, TCGv_i64 rh, TCGv_i64 arg1, TCGv_i64 arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_muls2_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op4_i64(INDEX_op_muls2_i64, rl, rh, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_mulsh_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_mul_i64, t, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3_i64(INDEX_op_mulsh_i64, rh, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(rl, t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t);<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_mulu2_i64 || TCG_TARGET_HAS_muluh_i64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t1 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t2 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t3 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mulu2_i64(t0, t1, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Adjust for negative inputs.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i64(t2, arg1, 63);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i64(t3, arg2, 63);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_and_i64(t2, t2, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_and_i64(t3, t3, arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i64(rh, t1, t2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sub_i64(rh, rh, t3);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(rl, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t3);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mul_i64(t0, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_mulsh_i64(rh, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i64(rl, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Size changing operations.&nbsp; */</P>
<P><FONT class=extract>void tcg_gen_extrl_i64_i32(TCGv_i32 ret, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_extrl_i64_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2(&amp;tcg_ctx, INDEX_op_extrl_i64_i32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GET_TCGV_I32(ret), GET_TCGV_I64(arg));<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, MAKE_TCGV_I32(GET_TCGV_I64(arg)));<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_extrh_i64_i32(TCGv_i32 ret, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, TCGV_HIGH(arg));<BR>&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_HAS_extrh_i64_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2(&amp;tcg_ctx, INDEX_op_extrh_i64_i32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GET_TCGV_I32(ret), GET_TCGV_I64(arg));<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 t = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i64(t, arg, 32);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(ret, MAKE_TCGV_I32(GET_TCGV_I64(t)));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(t);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_extu_i32_i64(TCGv_i64 ret, TCGv_i32 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_LOW(ret), arg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_HIGH(ret), 0);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2(&amp;tcg_ctx, INDEX_op_extu_i32_i64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GET_TCGV_I64(ret), GET_TCGV_I32(arg));<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_ext_i32_i64(TCGv_i64 ret, TCGv_i32 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_LOW(ret), arg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(TCGV_HIGH(ret), TCGV_LOW(ret), 31);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op2(&amp;tcg_ctx, INDEX_op_ext_i32_i64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GET_TCGV_I64(ret), GET_TCGV_I32(arg));<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_concat_i32_i64(TCGv_i64 dest, TCGv_i32 low, TCGv_i32 high)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 tmp;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_LOW(dest), low);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(TCGV_HIGH(dest), high);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tmp = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp; /* These extensions are only needed for type correctness.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We may be able to do better given target specific information.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(tmp, high);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(dest, low);<BR>&nbsp;&nbsp;&nbsp; /* If deposit is available, use it.&nbsp; Otherwise use the extra<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; knowledge that we have of the zero-extensions above.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_deposit_i64 &amp;&amp; TCG_TARGET_deposit_i64_valid(32, 32)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_deposit_i64(dest, dest, tmp, 32, 32);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(tmp, tmp, 32);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i64(dest, dest, tmp);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(tmp);<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_extr_i64_i32(TCGv_i32 lo, TCGv_i32 hi, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(lo, TCGV_LOW(arg));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(hi, TCGV_HIGH(arg));<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extrl_i64_i32(lo, arg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extrh_i64_i32(hi, arg);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_extr32_i64(TCGv_i64 lo, TCGv_i64 hi, TCGv_i64 arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ext32u_i64(lo, arg);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_shri_i64(hi, arg, 32);<BR>}</FONT></P>
<P>/* QEMU specific operations.&nbsp; */</P>
<P><FONT class=extract>void tcg_gen_goto_tb(unsigned idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* We only support two chained exits.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(idx &lt;= 1);<BR>#ifdef CONFIG_DEBUG_TCG<BR>&nbsp;&nbsp;&nbsp; /* Verify that we havn't seen this numbered exit before.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert((tcg_ctx.goto_tb_issue_mask &amp; (1 &lt;&lt; idx)) == 0);<BR>&nbsp;&nbsp;&nbsp; tcg_ctx.goto_tb_issue_mask |= 1 &lt;&lt; idx;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; tcg_gen_op1i(INDEX_op_goto_tb, idx);<BR>}</FONT></P>
<P><FONT class=extract>static inline TCGMemOp tcg_canonicalize_memop(TCGMemOp op, bool is64, bool st)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Trigger the asserts within as early as possible.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; (void)get_alignment_bits(op);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; switch (op &amp; MO_SIZE) {<BR>&nbsp;&nbsp;&nbsp; case MO_8:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; op &amp;= ~MO_BSWAP;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case MO_16:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case MO_32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!is64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; op &amp;= ~MO_SIGN;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case MO_64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!is64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (st) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; op &amp;= ~MO_SIGN;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return op;<BR>}</FONT></P>
<P><FONT class=extract>static void gen_ldst_i32(TCGOpcode opc, TCGv_i32 val, TCGv addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOp memop, TCGArg idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi = make_memop_idx(memop, idx);<BR>#if TARGET_LONG_BITS == 32<BR>&nbsp;&nbsp;&nbsp; tcg_gen_op3i_i32(opc, val, addr, oi);<BR>#else<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op4i_i32(opc, val, TCGV_LOW(addr), TCGV_HIGH(addr), oi);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3(&amp;tcg_ctx, opc, GET_TCGV_I32(val), GET_TCGV_I64(addr), oi);<BR>&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>}</FONT></P>
<P><FONT class=extract>static void gen_ldst_i64(TCGOpcode opc, TCGv_i64 val, TCGv addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOp memop, TCGArg idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi = make_memop_idx(memop, idx);<BR>#if TARGET_LONG_BITS == 32<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op4i_i32(opc, TCGV_LOW(val), TCGV_HIGH(val), addr, oi);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3(&amp;tcg_ctx, opc, GET_TCGV_I64(val), GET_TCGV_I32(addr), oi);<BR>&nbsp;&nbsp;&nbsp; }<BR>#else<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op5i_i32(opc, TCGV_LOW(val), TCGV_HIGH(val),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGV_LOW(addr), TCGV_HIGH(addr), oi);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_op3i_i64(opc, val, addr, oi);<BR>&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_qemu_ld_i32(TCGv_i32 val, TCGv addr, TCGArg idx, TCGMemOp memop)<BR>{<BR>&nbsp;&nbsp;&nbsp; memop = tcg_canonicalize_memop(memop, 0, 0);<BR>&nbsp;&nbsp;&nbsp; trace_guest_mem_before_tcg(tcg_ctx.cpu, tcg_ctx.tcg_env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr, trace_mem_get_info(memop, 0));<BR>&nbsp;&nbsp;&nbsp; gen_ldst_i32(INDEX_op_qemu_ld_i32, val, addr, memop, idx);<BR>}</FONT></P>
<P><FONT class=extract>void tcg_gen_qemu_st_i32(TCGv_i32 val, TCGv addr, TCGArg idx, TCGMemOp memop)<BR>{<BR>&nbsp;&nbsp;&nbsp; memop = tcg_canonicalize_memop(memop, 0, 1);<BR>&nbsp;&nbsp;&nbsp; trace_guest_mem_before_tcg(tcg_ctx.cpu, tcg_ctx.tcg_env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr, trace_mem_get_info(memop, 1));<BR>&nbsp;&nbsp;&nbsp; gen_ldst_i32(INDEX_op_qemu_st_i32, val, addr, memop, idx);<BR>}</FONT></P>
<P>void tcg_gen_qemu_ld_i64(TCGv_i64 val, TCGv addr, TCGArg idx, TCGMemOp memop)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32 &amp;&amp; (memop &amp; MO_SIZE) &lt; MO_64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_qemu_ld_i32(TCGV_LOW(val), addr, idx, memop);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (memop &amp; MO_SIGN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(TCGV_HIGH(val), TCGV_LOW(val), 31);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(TCGV_HIGH(val), 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; memop = tcg_canonicalize_memop(memop, 1, 0);<BR>&nbsp;&nbsp;&nbsp; trace_guest_mem_before_tcg(tcg_ctx.cpu, tcg_ctx.tcg_env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr, trace_mem_get_info(memop, 0));<BR>&nbsp;&nbsp;&nbsp; gen_ldst_i64(INDEX_op_qemu_ld_i64, val, addr, memop, idx);<BR>}</P>
<P>void tcg_gen_qemu_st_i64(TCGv_i64 val, TCGv addr, TCGArg idx, TCGMemOp memop)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32 &amp;&amp; (memop &amp; MO_SIZE) &lt; MO_64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_qemu_st_i32(TCGV_LOW(val), addr, idx, memop);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; memop = tcg_canonicalize_memop(memop, 1, 1);<BR>&nbsp;&nbsp;&nbsp; trace_guest_mem_before_tcg(tcg_ctx.cpu, tcg_ctx.tcg_env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr, trace_mem_get_info(memop, 1));<BR>&nbsp;&nbsp;&nbsp; gen_ldst_i64(INDEX_op_qemu_st_i64, val, addr, memop, idx);<BR>}