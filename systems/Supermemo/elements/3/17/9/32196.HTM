<H3 class=docSection1Title>2.2. How to Use Software Metaphors</H3>
<TABLE cellSpacing=0 cellPadding=1 width="90%" border=0>
<TBODY>
<TR>
<TD vAlign=top width=60><IMG border=0 alt="" src="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/keypoint.gif" width=70 height=71></TD>
<TD vAlign=top>
<P class=docText>A software metaphor is more like a searchlight than a road map. It doesn't tell you where to find the answer; it tells you how to look for it. A metaphor serves more as a heuristic than it does as an algorithm.</P></TD></TR></TBODY></TABLE><BR>
<P class=docText>An algorithm is a set of well-defined instructions for carrying out a particular task. An algorithm is predictable, deterministic, and not subject to chance. An algorithm tells <A name=ind2465></A><A name=ind2454></A><A name=ind1877></A><A name=ind0092></A>you how to go from point A to point B with no detours, no side trips to points D, E, and F, and no stopping to smell the roses or have a cup of joe.</P>
<P class=docText>A heuristic is a technique that helps you look for an answer. Its results are subject to chance because a heuristic tells you only how to look, not what to find. It doesn't tell you how to get directly from point A to point B; it might not even know where point A and point B are. In effect, a heuristic is an algorithm in a clown suit. It's less predictable, it's more fun, and it comes without a 30-day, money-back guarantee.</P>
<P class=docText>Here is an algorithm for driving to someone's house: Take Highway 167 south to Puyallup. Take the South Hill Mall exit and drive 4.5 miles up the hill. Turn right at the light by the grocery store, and then take the first left. Turn into the driveway of the large tan house on the left, at 714 North Cedar.</P><A name=ch02note01></A>
<DIV class=docNote>
<P class=docNoteTitle>Cross-Reference</P>
<P class=docText>For details on how to use heuristics in designing software, see "<A class=docLink href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/ch05lev1sec1.html#ch05lev2sec6">Design Is a Heuristic Process</A>" in <A class=docLink href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/ch05lev1sec1.html#ch05lev1sec1">Section 5.1</A>.</P></DIV><BR>
<P class=docText>Here's a heuristic for getting to someone's house: Find the last letter we mailed you. Drive to the town in the return address. When you get to town, ask someone where our house is. Everyone knows us&#8212;someone will be glad to help you. If you can't find anyone, call us from a public phone, and we'll come get you.</P>
<P class=docText>The difference between an algorithm and a heuristic is subtle, and the two terms overlap somewhat. For the purposes of this book, the main difference between the two is the level of indirection from the solution. An algorithm gives you the instructions directly. A heuristic tells you how to discover the instructions for yourself, or at least where to look for them.</P>
<P class=docText>Having directions that told you exactly how to solve your programming problems would certainly make programming easier and the results more predictable. But programming science isn't yet that advanced and may never be. The most challenging part of programming is conceptualizing the problem, and many errors in programming are conceptual errors. Because each program is conceptually unique, it's difficult or impossible to create a general set of directions that lead to a solution in every case. Thus, knowing how to approach problems in general is at least as valuable as knowing specific solutions for specific problems.</P>
<P class=docText>How do you use software metaphors? Use them to give you insight into your programming problems and processes. Use them to help you think about your programming activities and to help you imagine better ways of doing things. You won't be able to look at a line of code and say that it violates one of the metaphors described in this chapter. Over time, though, the person who uses metaphors to illuminate the software-development process will be perceived as someone who has a better understanding of programming and produces better code faster than people who don't use them.