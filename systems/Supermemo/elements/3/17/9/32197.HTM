<H3 class=docSection1Title>2.3. Common Software Metaphors</H3>
<P class=docText><A name=ind4019></A><A name=ind3848></A><A name=ind3131></A><A name=ind2482></A><A name=ind2479></A><A name=ind2474></A><A name=ind2462></A><A name=ind2274></A>A confusing abundance of metaphors has grown up around software development. David Gries says writing software is a science (1981). Donald Knuth says it's an art (1998). Watts Humphrey says it's a process (1989). P. J. Plauger and Kent Beck say it's like driving a car, although they draw nearly opposite conclusions (Plauger 1993, Beck 2000). Alistair Cockburn says it's a game (2002). Eric Raymond says it's like a bazaar (2000). Andy Hunt and Dave Thomas say it's like gardening. Paul Heckel says it's like filming <SPAN class=docEmphasis>Snow White and the Seven Dwarfs</SPAN> (1994). Fred Brooks says that it's like farming, hunting werewolves, or drowning with dinosaurs in a tar pit (1995). Which are the best metaphors?</P><A name=ch02lev2sec1></A>
<H4 class=docSection2Title>Software Penmanship: Writing Code</H4>
<P class=docText>The most primitive metaphor for software development grows out of the expression "writing code." The writing metaphor suggests that developing a program is like writing a casual letter&#8212;you sit down with pen, ink, and paper and write it from start to finish. It doesn't require any formal planning, and you figure out what you want to say as you go.</P>
<P class=docText>Many ideas derive from the writing metaphor. Jon Bentley says you should be able to sit down by the fire with a glass of brandy, a good cigar, and your favorite hunting dog to enjoy a "literate program" the way you would a good novel. Brian Kernighan and P. J. Plauger named their programming-style book <SPAN class=docEmphasis>The Elements of Programming Style</SPAN>(1978) after the writing-style book <SPAN class=docEmphasis>The Elements of Style</SPAN> (Strunk and White 2000). Programmers often talk about "program readability."</P>
<TABLE cellSpacing=0 cellPadding=1 width="90%" border=0>
<TBODY>
<TR>
<TD vAlign=top width=60><IMG border=0 alt="" src="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/harddata.gif" width=73 height=63></TD>
<TD vAlign=top>
<P class=docText>For an individual's work or for small-scale projects, the letter-writing metaphor works adequately, but for other purposes it leaves the party early&#8212;it doesn't describe software development fully or adequately. Writing is usually a one-person activity, whereas a software project will most likely involve many people with many different responsibilities. When you finish writing a letter, you stuff it into an envelope and mail it. You can't change it anymore, and for all intents and purposes it's complete. Software isn't as difficult to change and is hardly ever fully complete. As much as 90 percent of the development effort on a typical software system comes after its initial release, with two-thirds being typical (Pigoski 1997). In writing, a high premium is placed on originality. In software construction, trying to create truly original work is often less effective than focusing on the reuse of design ideas, code, and test cases from previous projects. In short, the writing metaphor implies a software-development process that's too simple and rigid to be healthy.</P></TD></TR></TBODY></TABLE><BR>
<P class=docText><A name=ind2464></A><A name=ind2463></A><A name=ind1820></A><A name=ind1649></A>Unfortunately, the letter-writing metaphor has been perpetuated by one of the most popular software books on the planet, Fred Brooks's <SPAN class=docEmphasis>The Mythical Man-Month</SPAN> (Brooks 1995). Brooks says, "Plan to throw one away; you will, anyhow." This conjures up an image of a pile of half-written drafts thrown into a wastebasket, as shown in <A class=docLink href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/ch02lev1sec3.html#ch02fig01">Figure 2-1</A>.</P><A name=ch02fig01></A>
<P></P>
<CENTER>
<H5 class=docFigureTitle>Figure 2-1. The letter-writing metaphor suggests that the software process relies on expensive trial and error rather than careful planning and design</H5>
<P class=docText></P>
<DIV class=v1><A href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/02fig01_alt.gif" target=_blank>[View full size image]</A></DIV><IMG border=0 alt="" src="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/02fig01.gif" width=500 height=184>
<P></P></CENTER>
<P></P><BR>
<BLOCKQUOTE>
<P class=docText>Plan to throw one away; you will, anyhow.</P>
<P class=docText>&#8212;Fred Brooks</P></BLOCKQUOTE>
<BLOCKQUOTE>
<P class=docText>If you plan to throw one away, you will throw away two.</P>
<P class=docText>&#8212;Craig Zerouni</P></BLOCKQUOTE>
<P class=docText>Planning to throw one away might be practical when you're writing a polite how-do-you-do to your aunt. But extending the metaphor of "writing" software to a plan to throw one away is poor advice for software development, where a major system already costs as much as a 10-story office building or an ocean liner. It's easy to grab the brass ring if you can afford to sit on your favorite wooden pony for an unlimited number of spins around the carousel. The trick is to get it the first time around&#8212;or to take several chances when they're cheapest. Other metaphors better illuminate ways of attaining such goals.</P><A name=ch02lev2sec2></A>
<H4 class=docSection2Title>Software Farming: Growing a System</H4>
<P class=docText>In contrast to the rigid writing metaphor, some software developers say you should envision creating software as something like planting seeds and growing crops. You design a piece, code a piece, test a piece, and add it to the system a little bit at a time. By taking small steps, you minimize the trouble you can get into at any one time.</P>
<TABLE cellSpacing=0 cellPadding=1 width="90%" border=0>
<TBODY>
<TR>
<TD vAlign=top width=60><IMG border=0 alt="" src="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/keypoint.gif" width=70 height=71></TD>
<TD vAlign=top>
<P class=docText>Sometimes a good technique is described with a bad metaphor. In such cases, try to keep the technique and come up with a better metaphor. In this case, the incremental technique is valuable, but the farming metaphor is terrible.</P></TD></TR></TBODY></TABLE><BR><A name=ch02note02></A>
<DIV class=docNote>
<P class=docNoteTitle>Further Reading</P>
<P class=docText>For an illustration of a different farming metaphor, one that's applied to software maintenance, see the chapter "On the Origins of Designer Intuition" in <SPAN class=docEmphasis>Rethinking Systems Analysis and Design</SPAN> (Weinberg 1988).</P></DIV><BR>
<P class=docText>The idea of doing a little bit at a time might bear some resemblance to the way crops grow, but the farming analogy is weak and uninformative, and it's easy to replace with the better metaphors described in the following sections. It's hard to extend the farming metaphor beyond the simple idea of doing things a little bit at a time. If you buy into the farming metaphor, imagined in <A class=docLink href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/ch02lev1sec3.html#ch02fig02">Figure 2-2</A>, you might find yourself talking about fertilizing the system plan, thinning the detailed design, increasing code yields through effective land management, and harvesting the code itself. You'll talk about <A name=ind3530></A><A name=ind2653></A><A name=ind2471></A><A name=ind2467></A><A name=ind5043></A><A name=ind5042></A><A name=ind2452></A><A name=ind5037></A><A name=ind1929></A><A name=ind0051></A>rotating in a crop of C++ instead of barley, of letting the land rest for a year to increase the supply of nitrogen in the hard disk.</P><A name=ch02fig02></A>
<P></P>
<CENTER>
<H5 class=docFigureTitle>Figure 2-2. It's hard to extend the farming metaphor to software development appropriately</H5>
<P class=docText></P>
<DIV class=v1><A href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/02fig02_alt.gif" target=_blank>[View full size image]</A></DIV><IMG border=0 alt="" src="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/02fig02.gif" width=500 height=147>
<P></P></CENTER>
<P></P><BR>
<P class=docText>The weakness in the software-farming metaphor is its suggestion that you don't have any direct control over how the software develops. You plant the code seeds in the spring. <SPAN class=docEmphasis>Farmer's Almanac</SPAN> and the Great Pumpkin willing, you'll have a bumper crop of code in the fall.</P><A name=ch02lev2sec3></A>
<H4 class=docSection2Title>Software Oyster Farming: System Accretion</H4>
<P class=docText>Sometimes people talk about growing software when they really mean software accretion. The two metaphors are closely related, but software accretion is the more insightful image. "Accretion," in case you don't have a dictionary handy, means any growth or increase in size by a gradual external addition or inclusion. Accretion describes the way an oyster makes a pearl, by gradually adding small amounts of calcium carbonate. In geology, "accretion" means a slow addition to land by the deposit of waterborne sediment. In legal terms, "accretion" means an increase of land along the shores of a body of water by the deposit of waterborne sediment.</P>
<P class=docText>This doesn't mean that you have to learn how to make code out of waterborne sediment; it means that you have to learn how to add to your software systems a small amount at a time. Other words closely related to accretion are "incremental," "iterative," "adaptive," and "evolutionary." Incremental designing, building, and testing are some of the most powerful software-development concepts available.</P><A name=ch02note03></A>
<DIV class=docNote>
<P class=docNoteTitle>Cross-Reference</P>
<P class=docText>For details on how to apply incremental strategies to system integration, see <A class=docLink href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/ch29lev1sec2.html#ch29lev1sec2">Section 29.2</A>, "<A class=docLink href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/ch29lev1sec2.html#ch29lev1sec2">Integration Frequency&#8212;Phased or Incremental?</A>"</P></DIV><BR>
<P class=docText>In incremental development, you first make the simplest possible version of the system that will run. It doesn't have to accept realistic input, it doesn't have to perform realistic manipulations on data, it doesn't have to produce realistic output&#8212;it just has to be a skeleton strong enough to hold the real system as it's developed. It might call dummy classes for each of the basic functions you have identified. This basic beginning is like the oyster's beginning a pearl with a small grain of sand.</P>
<P class=docText>After you've formed the skeleton, little by little you lay on the muscle and skin. You change each of the dummy classes to real classes. Instead of having your program <A name=ind2477></A><A name=ind2455></A><A name=ind0314></A>pretend to accept input, you drop in code that accepts real input. Instead of having your program pretend to produce output, you drop in code that produces real output. You add a little bit of code at a time until you have a fully working system.</P>
<P class=docText>The anecdotal evidence in favor of this approach is impressive. Fred Brooks, who in 1975 advised building one to throw away, said that nothing in the decade after he wrote his landmark book <SPAN class=docEmphasis>The Mythical Man-Month</SPAN> so radically changed his own practice or its effectiveness as incremental development (1995). Tom Gilb made the same point in his breakthrough book, <SPAN class=docEmphasis>Principles of Software Engineering Management</SPAN> (1988), which introduced Evolutionary Delivery and laid the groundwork for much of today's Agile programming approach. Numerous current methodologies are based on this idea (Beck 2000, Cockburn 2002, Highsmith 2002, Reifer 2002, Martin 2003, Larman 2004).</P>
<P class=docText>As a metaphor, the strength of the incremental metaphor is that it doesn't overpromise. It's harder than the farming metaphor to extend inappropriately. The image of an oyster forming a pearl is a good way to visualize incremental development, or accretion.</P><A name=ch02lev2sec4></A>
<H4 class=docSection2Title>Software Construction: Building Software</H4>
<TABLE cellSpacing=0 cellPadding=1 width="90%" border=0>
<TBODY>
<TR>
<TD vAlign=top width=60><IMG border=0 alt="" src="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/keypoint.gif" width=70 height=71></TD>
<TD vAlign=top>
<P class=docText>The image of "building" software is more useful than that of "writing" or "growing" software. It's compatible with the idea of software accretion and provides more detailed guidance. Building software implies various stages of planning, preparation, and execution that vary in kind and degree depending on what's being built. When you explore the metaphor, you find many other parallels.</P></TD></TR></TBODY></TABLE><BR>
<P class=docText>Building a four-foot tower requires a steady hand, a level surface, and 10 undamaged beer cans. Building a tower 100 times that size doesn't merely require 100 times as many beer cans. It requires a different kind of planning and construction altogether.</P>
<P class=docText>If you're building a simple structure&#8212;a doghouse, say&#8212;you can drive to the lumber store and buy some wood and nails. By the end of the afternoon, you'll have a new house for Fido. If you forget to provide for a door, as shown in <A class=docLink href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/ch02lev1sec3.html#ch02fig03">Figure 2-3</A>, or make some other mistake, it's not a big problem; you can fix it or even start over from the beginning. All you've wasted is part of an afternoon. This loose approach is appropriate for small software projects too. If you use the wrong design for 1000 lines of code, you can refactor or start over completely without losing much.</P><A name=ch02fig03></A>
<P></P>
<CENTER>
<H5 class=docFigureTitle>Figure 2-3. The penalty for a mistake on a simple structure is only a little time and maybe some embarrassment</H5>
<P class=docText></P>
<DIV class=v1><A href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/02fig03_alt.gif" target=_blank>[View full size image]</A></DIV><IMG border=0 alt="" src="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/02fig03.gif" width=500 height=259>
<P></P></CENTER>
<P></P><BR>
<P class=docText>If you're building a house, the building process is more complicated, and so are the consequences of poor design. First you have to decide what kind of house you want to build&#8212;analogous in software development to problem definition. Then you and an architect have to come up with a general design and get it approved. This is similar to software architectural design. You draw detailed blueprints and hire a contractor. This is similar to detailed software design. You prepare the building site, lay a foundation, frame the house, put siding and a roof on it, and plumb and wire it. This is similar to software construction. When most of the house is done, the landscapers, painters, and decorators come in to make the best of your property and the home you've built. This is similar to software optimization. Throughout the process, various inspectors come to check the site, foundation, frame, wiring, and other inspectables. This is similar to software reviews and inspections.</P>
<P class=docText>Greater complexity and size imply greater consequences in both activities. In building a house, materials are somewhat expensive, but the main expense is labor. Ripping out a wall and moving it six inches is expensive not because you waste a lot of nails but because you have to pay the people for the extra time it takes to move the wall. You have to make the design as good as possible, as suggested by <A class=docLink href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/ch02lev1sec3.html#ch02fig04">Figure 2-4</A>, so that you don't waste time fixing mistakes that could have been avoided. In building a software product, materials are even less expensive, but labor costs just as much. Changing a report format is just as expensive as moving a wall in a house because the main cost component in both cases is people's time.</P><A name=ch02fig04></A>
<P></P>
<CENTER>
<H5 class=docFigureTitle>Figure 2-4. More complicated structures require more careful planning</H5>
<P class=docText></P>
<DIV class=v1><A href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/02fig04_alt.gif" target=_blank>[View full size image]</A></DIV><IMG border=0 alt="" src="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/02fig04.gif" width=500 height=261>
<P></P></CENTER>
<P></P><BR>
<P class=docText><A name=ind2780></A><A name=ind2459></A><A name=ind2456></A><A name=ind1063></A><A name=ind0884></A><A name=ind0320></A><A name=ind0315></A>What other parallels do the two activities share? In building a house, you won't try to build things you can buy already built. You'll buy a washer and dryer, dishwasher, refrigerator, and freezer. Unless you're a mechanical wizard, you won't consider building them yourself. You'll also buy prefabricated cabinets, counters, windows, doors, and bathroom fixtures. If you're building a software system, you'll do the same thing. You'll make extensive use of high-level language features rather than writing your own operating-system-level code. You might also use prebuilt libraries of container classes, scientific functions, user interface classes, and database-manipulation classes. It generally doesn't make sense to code things you can buy ready-made.</P>
<P class=docText>If you're building a fancy house with first-class furnishings, however, you might have your cabinets custom-made. You might have a dishwasher, refrigerator, and freezer built in to look like the rest of your cabinets. You might have windows custom-made in unusual shapes and sizes. This customization has parallels in software development. If you're building a first-class software product, you might build your own scientific functions for better speed or accuracy. You might build your own container classes, user interface classes, and database classes to give your system a seamless, perfectly consistent look and feel.</P>
<P class=docText>Both building construction and software construction benefit from appropriate levels of planning. If you build software in the wrong order, it's hard to code, hard to test, and hard to debug. It can take longer to complete, or the project can fall apart because everyone's work is too complex and therefore too confusing when it's all combined.</P>
<P class=docText>Careful planning doesn't necessarily mean exhaustive planning or over-planning. You can plan out the structural supports and decide later whether to put in hardwood floors or carpeting, what color to paint the walls, what roofing material to use, and so <A name=ind3509></A><A name=ind2478></A>on. A well-planned project improves your ability to change your mind later about details. The more experience you have with the kind of software you're building, the more details you can take for granted. You just want to be sure that you plan enough so that lack of planning doesn't create major problems later.</P>
<P class=docText>The construction analogy also helps explain why different software projects benefit from different development approaches. In building, you'd use different levels of planning, design, and quality assurance if you're building a warehouse or a toolshed than if you're building a medical center or a nuclear reactor. You'd use still different approaches for building a school, a skyscraper, or a three-bedroom home. Likewise, in software you might generally use flexible, lightweight development approaches, but sometimes you'll need rigid, heavyweight approaches to achieve safety goals and other goals.</P>
<P class=docText>Making changes in the software brings up another parallel with building construction. To move a wall six inches costs more if the wall is load-bearing than if it's merely a partition between rooms. Similarly, making structural changes in a program costs more than adding or deleting peripheral features.</P>
<P class=docText>Finally, the construction analogy provides insight into extremely large software projects. Because the penalty for failure in an extremely large structure is severe, the structure has to be over-engineered. Builders make and inspect their plans carefully. They build in margins of safety; it's better to pay 10 percent more for stronger material than to have a skyscraper fall over. A great deal of attention is paid to timing. When the Empire State Building was built, each delivery truck had a 15-minute margin in which to make its delivery. If a truck wasn't in place at the right time, the whole project was delayed.</P>
<P class=docText>Likewise, for extremely large software projects, planning of a higher order is needed than for projects that are merely large. Capers Jones reports that a software system with one million lines of code requires an average of 69 <SPAN class=docEmphasis>kinds</SPAN> of documentation (1998). The requirements specification for such a system would typically be about 4000&#8211;5000 pages long, and the design documentation can easily be two or three times as extensive as the requirements. It's unlikely that an individual would be able to understand the complete design for a project of this size&#8212;or even read it. A greater degree of preparation is appropriate.</P>
<P class=docText>We build software projects comparable in economic size to the Empire State Building, and technical and managerial controls of similar stature are needed.</P>
<P class=docText>The building-construction metaphor could be extended in a variety of other directions, which is why the metaphor is so powerful. Many terms common in software development derive from the building metaphor: software architecture, scaffolding, construction, foundation classes, and tearing code apart. You'll probably hear many more.</P><A name=ch02note04></A>
<DIV class=docNote>
<P class=docNoteTitle>Further Reading</P>
<P class=docText>For some good comments about extending the construction metaphor, see "What Supports the Roof?" (Starr 2003).</P></DIV><BR><A name=ch02lev2sec5></A>
<H4 class=docSection2Title>Applying Software Techniques: The Intellectual Toolbox</H4>
<TABLE cellSpacing=0 cellPadding=1 width="90%" border=0>
<TBODY>
<TR>
<TD vAlign=top width=60><IMG border=0 alt="" src="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/keypoint.gif" width=70 height=71></TD>
<TD vAlign=top>
<P class=docText><A name=ind3851></A><A name=ind2480></A><A name=ind2457></A><A name=ind2098></A>People who are effective at developing high-quality software have spent years accumulating dozens of techniques, tricks, and magic incantations. The techniques are not rules; they are analytical tools. A good craftsman knows the right tool for the job and knows how to use it correctly. Programmers do, too. The more you learn about programming, the more you fill your mental toolbox with analytical tools and the knowledge of when to use them and how to use them correctly.</P></TD></TR></TBODY></TABLE><BR><A name=ch02note05></A>
<DIV class=docNote>
<P class=docNoteTitle>Cross-Reference</P>
<P class=docText>For details on selecting and combining methods in design, see <A class=docLink href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/ch05lev1sec3.html#ch05lev1sec3">Section 5.3</A>, "<A class=docLink href="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/ch05lev1sec3.html#ch05lev1sec3">Design Building Blocks: Heuristics</A>."</P></DIV><BR>
<P class=docText>In software, consultants sometimes tell you to buy into certain software-development methods to the exclusion of other methods. That's unfortunate because if you buy into any single methodology 100 percent, you'll see the whole world in terms of that methodology. In some instances, you'll miss opportunities to use other methods better suited to your current problem. The toolbox metaphor helps to keep all the methods, techniques, and tips in perspective&#8212;ready for use when appropriate.</P><A name=ch02lev2sec6></A>
<H4 class=docSection2Title>Combining Metaphors</H4>
<TABLE cellSpacing=0 cellPadding=1 width="90%" border=0>
<TBODY>
<TR>
<TD vAlign=top width=60><IMG border=0 alt="" src="file:///D:/BaiduYunDownload/Microsoft.Press.Code.Complete.Second.Edition/0735619670/images/0735619670/graphics/keypoint.gif" width=70 height=71></TD>
<TD vAlign=top>
<P class=docText>Because metaphors are heuristic rather than algorithmic, they are not mutually exclusive. You can use both the accretion and the construction metaphors. You can use writing if you want to, and you can combine writing with driving, hunting for werewolves, or drowning in a tar pit with dinosaurs. Use whatever metaphor or combination of metaphors stimulates your own thinking or communicates well with others on your team.</P></TD></TR></TBODY></TABLE><BR>
<P class=docText>Using metaphors is a fuzzy business. You have to extend them to benefit from the heuristic insights they provide. But if you extend them too far or in the wrong direction, they'll mislead you. Just as you can misuse any powerful tool, you can misuse metaphors, but their power makes them a valuable part of your intellectual toolbox.</P><A name=ch02lev2sec7></A>
<H4 class=docSection2Title>Additional Resources</H4>
<P class=docText><A class=docLink href="http://www.cc2e.com/0285" target=_blank>cc2e.com/0285</A></P>
<P class=docText>Among general books on metaphors, models, and paradigms, the touchstone book is by Thomas Kuhn.</P>
<P class=docText>Kuhn, Thomas S. <SPAN class=docEmphasis>The Structure of Scientific Revolutions</SPAN>, 3d ed. Chicago, IL: The University of Chicago Press, 1996. Kuhn's book on how scientific theories emerge, evolve, and succumb to other theories in a Darwinian cycle set the philosophy of science on its ear when it was first published in 1962. It's clear and short, and it's loaded with interesting examples of the rise and fall of metaphors, models, and paradigms in science.</P>
<P class=docText>Floyd, Robert W. "The Paradigms of Programming." 1978 Turing Award Lecture. <SPAN class=docEmphasis>Communications of the ACM</SPAN>, August 1979, pp. 455&#8211;60. This is a fascinating discussion of models in software development, and Floyd applies Kuhn's ideas to the topic.