#define PAS_OP(pfx) \<BR>&nbsp;&nbsp;&nbsp; switch (op2) {&nbsp; \<BR>&nbsp;&nbsp;&nbsp; case 0: gen_pas_helper(glue(pfx,add16)); break; \<BR>&nbsp;&nbsp;&nbsp; case 1: gen_pas_helper(glue(pfx,addsubx)); break; \<BR>&nbsp;&nbsp;&nbsp; case 2: gen_pas_helper(glue(pfx,subaddx)); break; \<BR>&nbsp;&nbsp;&nbsp; case 3: gen_pas_helper(glue(pfx,sub16)); break; \<BR>&nbsp;&nbsp;&nbsp; case 4: gen_pas_helper(glue(pfx,add8)); break; \<BR>&nbsp;&nbsp;&nbsp; case 7: gen_pas_helper(glue(pfx,sub8)); break; \<BR>&nbsp;&nbsp;&nbsp; }<BR>static void gen_arm_parallel_addsub(int op1, int op2, TCGv_i32 a, TCGv_i32 b)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_ptr tmp;</P>
<P>&nbsp;&nbsp;&nbsp; switch (op1) {<BR>#define gen_pas_helper(name) glue(gen_helper_,name)(a, a, b, tmp)<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = tcg_temp_new_ptr();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_addi_ptr(tmp, cpu_env, offsetof(CPUARMState, GE));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAS_OP(s)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_ptr(tmp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 5:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = tcg_temp_new_ptr();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_addi_ptr(tmp, cpu_env, offsetof(CPUARMState, GE));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAS_OP(u)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_ptr(tmp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>#undef gen_pas_helper<BR>#define gen_pas_helper(name) glue(gen_helper_,name)(a, a, b)<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAS_OP(q);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAS_OP(sh);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 6:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAS_OP(uq);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 7:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAS_OP(uh);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>#undef gen_pas_helper<BR>&nbsp;&nbsp;&nbsp; }<BR>}<BR>#undef PAS_OP</P>
<P>/* For unknown reasons Arm and Thumb-2 use arbitrarily different encodings.&nbsp; */<BR>#define PAS_OP(pfx) \<BR>&nbsp;&nbsp;&nbsp; switch (op1) {&nbsp; \<BR>&nbsp;&nbsp;&nbsp; case 0: gen_pas_helper(glue(pfx,add8)); break; \<BR>&nbsp;&nbsp;&nbsp; case 1: gen_pas_helper(glue(pfx,add16)); break; \<BR>&nbsp;&nbsp;&nbsp; case 2: gen_pas_helper(glue(pfx,addsubx)); break; \<BR>&nbsp;&nbsp;&nbsp; case 4: gen_pas_helper(glue(pfx,sub8)); break; \<BR>&nbsp;&nbsp;&nbsp; case 5: gen_pas_helper(glue(pfx,sub16)); break; \<BR>&nbsp;&nbsp;&nbsp; case 6: gen_pas_helper(glue(pfx,subaddx)); break; \<BR>&nbsp;&nbsp;&nbsp; }<BR>static void gen_thumb2_parallel_addsub(int op1, int op2, TCGv_i32 a, TCGv_i32 b)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_ptr tmp;</P>
<P>&nbsp;&nbsp;&nbsp; switch (op2) {<BR>#define gen_pas_helper(name) glue(gen_helper_,name)(a, a, b, tmp)<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = tcg_temp_new_ptr();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_addi_ptr(tmp, cpu_env, offsetof(CPUARMState, GE));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAS_OP(s)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_ptr(tmp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 4:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = tcg_temp_new_ptr();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_addi_ptr(tmp, cpu_env, offsetof(CPUARMState, GE));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAS_OP(u)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_ptr(tmp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>#undef gen_pas_helper<BR>#define gen_pas_helper(name) glue(gen_helper_,name)(a, a, b)<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAS_OP(q);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAS_OP(sh);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 5:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAS_OP(uq);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 6:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PAS_OP(uh);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>#undef gen_pas_helper<BR>&nbsp;&nbsp;&nbsp; }<BR>}<BR>#undef PAS_OP</P>
<P>/*<BR>&nbsp;* Generate a conditional based on ARM condition code cc.<BR>&nbsp;* This is common between ARM and Aarch64 targets.<BR>&nbsp;*/<BR>void arm_test_cc(DisasCompare *cmp, int cc)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 value;<BR>&nbsp;&nbsp;&nbsp; TCGCond cond;<BR>&nbsp;&nbsp;&nbsp; bool global = true;</P>
<P>&nbsp;&nbsp;&nbsp; switch (cc) {<BR>&nbsp;&nbsp;&nbsp; case 0: /* eq: Z */<BR>&nbsp;&nbsp;&nbsp; case 1: /* ne: !Z */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cond = TCG_COND_EQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = cpu_ZF;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case 2: /* cs: C */<BR>&nbsp;&nbsp;&nbsp; case 3: /* cc: !C */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cond = TCG_COND_NE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = cpu_CF;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case 4: /* mi: N */<BR>&nbsp;&nbsp;&nbsp; case 5: /* pl: !N */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cond = TCG_COND_LT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = cpu_NF;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case 6: /* vs: V */<BR>&nbsp;&nbsp;&nbsp; case 7: /* vc: !V */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cond = TCG_COND_LT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = cpu_VF;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case 8: /* hi: C &amp;&amp; !Z */<BR>&nbsp;&nbsp;&nbsp; case 9: /* ls: !C || Z -&gt; !(C &amp;&amp; !Z) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cond = TCG_COND_NE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; global = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* CF is 1 for C, so -CF is an all-bits-set mask for C;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZF is non-zero for !Z; so AND the two subexpressions.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_neg_i32(value, cpu_CF);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_and_i32(value, value, cpu_ZF);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case 10: /* ge: N == V -&gt; N ^ V == 0 */<BR>&nbsp;&nbsp;&nbsp; case 11: /* lt: N != V -&gt; N ^ V != 0 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Since we're only interested in the sign bit, == 0 is &gt;= 0.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cond = TCG_COND_GE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; global = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(value, cpu_VF, cpu_NF);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case 12: /* gt: !Z &amp;&amp; N == V */<BR>&nbsp;&nbsp;&nbsp; case 13: /* le: Z || N != V */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cond = TCG_COND_NE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; global = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* (N == V) is equal to the sign bit of ~(NF ^ VF).&nbsp; Propagate<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the sign bit then AND with ZF to yield the result.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(value, cpu_VF, cpu_NF);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(value, value, 31);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andc_i32(value, cpu_ZF, value);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case 14: /* always */<BR>&nbsp;&nbsp;&nbsp; case 15: /* always */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Use the ALWAYS condition, which will fold early.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * It doesn't matter what we use for the value.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cond = TCG_COND_ALWAYS;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = cpu_ZF;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto no_invert;</P>
<P>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Bad condition code 0x%x\n", cc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (cc &amp; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cond = tcg_invert_cond(cond);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;no_invert:<BR>&nbsp;&nbsp;&nbsp; cmp-&gt;cond = cond;<BR>&nbsp;&nbsp;&nbsp; cmp-&gt;value = value;<BR>&nbsp;&nbsp;&nbsp; cmp-&gt;value_global = global;<BR>}</P>
<P>void arm_free_cc(DisasCompare *cmp)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (!cmp-&gt;value_global) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(cmp-&gt;value);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void arm_jump_cc(DisasCompare *cmp, TCGLabel *label)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_brcondi_i32(cmp-&gt;cond, cmp-&gt;value, 0, label);<BR>}</P>
<P>void arm_gen_test_cc(int cc, TCGLabel *label)<BR>{<BR>&nbsp;&nbsp;&nbsp; DisasCompare cmp;<BR>&nbsp;&nbsp;&nbsp; arm_test_cc(&amp;cmp, cc);<BR>&nbsp;&nbsp;&nbsp; arm_jump_cc(&amp;cmp, label);<BR>&nbsp;&nbsp;&nbsp; arm_free_cc(&amp;cmp);<BR>}</P>
<P>static const uint8_t table_logic_cc[16] = {<BR>&nbsp;&nbsp;&nbsp; 1, /* and */<BR>&nbsp;&nbsp;&nbsp; 1, /* xor */<BR>&nbsp;&nbsp;&nbsp; 0, /* sub */<BR>&nbsp;&nbsp;&nbsp; 0, /* rsb */<BR>&nbsp;&nbsp;&nbsp; 0, /* add */<BR>&nbsp;&nbsp;&nbsp; 0, /* adc */<BR>&nbsp;&nbsp;&nbsp; 0, /* sbc */<BR>&nbsp;&nbsp;&nbsp; 0, /* rsc */<BR>&nbsp;&nbsp;&nbsp; 1, /* andl */<BR>&nbsp;&nbsp;&nbsp; 1, /* xorl */<BR>&nbsp;&nbsp;&nbsp; 0, /* cmp */<BR>&nbsp;&nbsp;&nbsp; 0, /* cmn */<BR>&nbsp;&nbsp;&nbsp; 1, /* orr */<BR>&nbsp;&nbsp;&nbsp; 1, /* mov */<BR>&nbsp;&nbsp;&nbsp; 1, /* bic */<BR>&nbsp;&nbsp;&nbsp; 1, /* mvn */<BR>};</P>
<P>/* Set PC and Thumb state from an immediate address.&nbsp; */<BR>static inline void gen_bx_im(DisasContext *s, uint32_t addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp;</P>
<P>&nbsp;&nbsp;&nbsp; s-&gt;is_jmp = DISAS_JUMP;<BR>&nbsp;&nbsp;&nbsp; if (s-&gt;thumb != (addr &amp; 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(tmp, addr &amp; 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_st_i32(tmp, cpu_env, offsetof(CPUARMState, thumb));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(cpu_R[15], addr &amp; ~1);<BR>}</P>
<P>/* Set PC and Thumb state from var.&nbsp; var is marked as dead.&nbsp; */<BR>static inline void gen_bx(DisasContext *s, TCGv_i32 var)<BR>{<BR>&nbsp;&nbsp;&nbsp; s-&gt;is_jmp = DISAS_JUMP;<BR>&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(cpu_R[15], var, ~1);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(var, var, 1);<BR>&nbsp;&nbsp;&nbsp; store_cpu_field(var, thumb);<BR>}</P>
<P>/* Variant of store_reg which uses branch&amp;exchange logic when storing<BR>&nbsp;&nbsp; to r15 in ARM architecture v7 and above. The source must be a temporary<BR>&nbsp;&nbsp; and will be marked as dead. */<BR>static inline void store_reg_bx(DisasContext *s, int reg, TCGv_i32 var)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (reg == 15 &amp;&amp; ENABLE_ARCH_7) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_bx(s, var);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; store_reg(s, reg, var);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Variant of store_reg which uses branch&amp;exchange logic when storing<BR>&nbsp;* to r15 in ARM architecture v5T and above. This is used for storing<BR>&nbsp;* the results of a LDR/LDM/POP into r15, and corresponds to the cases<BR>&nbsp;* in the ARM ARM which use the LoadWritePC() pseudocode function. */<BR>static inline void store_reg_from_load(DisasContext *s, int reg, TCGv_i32 var)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (reg == 15 &amp;&amp; ENABLE_ARCH_5) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_bx(s, var);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; store_reg(s, reg, var);<BR>&nbsp;&nbsp;&nbsp; }<BR>}