<FONT class=extract>static inline void gen_set_pc_im(DisasContext *s, target_ulong val)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(cpu_R[15], val);<BR>}</FONT> 
<P></P>
<P>static inline void gen_hvc(DisasContext *s, int imm16)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* The pre HVC helper handles cases when HVC gets trapped<BR>&nbsp;&nbsp;&nbsp;&nbsp; * as an undefined insn by runtime configuration (ie before<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the insn really executes).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; gen_set_pc_im(s, s-&gt;pc - 4);<BR>&nbsp;&nbsp;&nbsp; gen_helper_pre_hvc(cpu_env);<BR>&nbsp;&nbsp;&nbsp; /* Otherwise we will treat this as a real exception which<BR>&nbsp;&nbsp;&nbsp;&nbsp; * happens after execution of the insn. (The distinction matters<BR>&nbsp;&nbsp;&nbsp;&nbsp; * for the PC value reported to the exception handler and also<BR>&nbsp;&nbsp;&nbsp;&nbsp; * for single stepping.)<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; s-&gt;svc_imm = imm16;<BR>&nbsp;&nbsp;&nbsp; gen_set_pc_im(s, s-&gt;pc);<BR>&nbsp;&nbsp;&nbsp; s-&gt;is_jmp = DISAS_HVC;<BR>}</P>
<P>static inline void gen_smc(DisasContext *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* As with HVC, we may take an exception either before or after<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the insn executes.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp;</P>
<P>&nbsp;&nbsp;&nbsp; gen_set_pc_im(s, s-&gt;pc - 4);<BR>&nbsp;&nbsp;&nbsp; tmp = tcg_const_i32(syn_aa32_smc());<BR>&nbsp;&nbsp;&nbsp; gen_helper_pre_smc(cpu_env, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>&nbsp;&nbsp;&nbsp; gen_set_pc_im(s, s-&gt;pc);<BR>&nbsp;&nbsp;&nbsp; s-&gt;is_jmp = DISAS_SMC;<BR>}</P>
<P>static inline void<BR>gen_set_condexec (DisasContext *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (s-&gt;condexec_mask) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t val = (s-&gt;condexec_cond &lt;&lt; 4) | (s-&gt;condexec_mask &gt;&gt; 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(tmp, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; store_cpu_field(tmp, condexec_bits);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void gen_exception_internal_insn(DisasContext *s, int offset, int excp)<BR>{<BR>&nbsp;&nbsp;&nbsp; gen_set_condexec(s);<BR>&nbsp;&nbsp;&nbsp; gen_set_pc_im(s, s-&gt;pc - offset);<BR>&nbsp;&nbsp;&nbsp; gen_exception_internal(excp);<BR>&nbsp;&nbsp;&nbsp; s-&gt;is_jmp = DISAS_JUMP;<BR>}</P>
<P>static void gen_exception_insn(DisasContext *s, int offset, int excp,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int syn, uint32_t target_el)<BR>{<BR>&nbsp;&nbsp;&nbsp; gen_set_condexec(s);<BR>&nbsp;&nbsp;&nbsp; gen_set_pc_im(s, s-&gt;pc - offset);<BR>&nbsp;&nbsp;&nbsp; gen_exception(excp, syn, target_el);<BR>&nbsp;&nbsp;&nbsp; s-&gt;is_jmp = DISAS_JUMP;<BR>}</P>
<P>/* Force a TB lookup after an instruction that changes the CPU state.&nbsp; */<BR>static inline void gen_lookup_tb(DisasContext *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(cpu_R[15], s-&gt;pc &amp; ~1);<BR>&nbsp;&nbsp;&nbsp; s-&gt;is_jmp = DISAS_JUMP;<BR>}