/* Set CF to the top bit of var.&nbsp; */<BR>static void gen_set_CF_bit31(TCGv_i32 var)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_shri_i32(cpu_CF, var, 31);<BR>}</P>
<P>/* Set N and Z flags from var.&nbsp; */<BR>static inline void gen_logic_CC(TCGv_i32 var)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(cpu_NF, var);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(cpu_ZF, var);<BR>}</P>
<P>/* T0 += T1 + CF.&nbsp; */<BR>static void gen_adc(TCGv_i32 t0, TCGv_i32 t1)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_add_i32(t0, t0, t1);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_add_i32(t0, t0, cpu_CF);<BR>}</P>
<P>/* dest = T0 + T1 + CF. */<BR>static void gen_add_carry(TCGv_i32 dest, TCGv_i32 t0, TCGv_i32 t1)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_add_i32(dest, t0, t1);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_add_i32(dest, dest, cpu_CF);<BR>}</P>
<P>/* dest = T0 - T1 + CF - 1.&nbsp; */<BR>static void gen_sub_carry(TCGv_i32 dest, TCGv_i32 t0, TCGv_i32 t1)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_sub_i32(dest, t0, t1);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_add_i32(dest, dest, cpu_CF);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_subi_i32(dest, dest, 1);<BR>}</P>
<P>/* dest = T0 + T1. Compute C, N, V and Z flags */<BR>static void gen_add_CC(TCGv_i32 dest, TCGv_i32 t0, TCGv_i32 t1)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(tmp, 0);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_add2_i32(cpu_NF, cpu_CF, t0, tmp, t1, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(cpu_ZF, cpu_NF);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(cpu_VF, cpu_NF, t0);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(tmp, t0, t1);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_andc_i32(cpu_VF, cpu_VF, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(dest, cpu_NF);<BR>}</P>
<P>/* dest = T0 + T1 + CF.&nbsp; Compute C, N, V and Z flags */<BR>static void gen_adc_CC(TCGv_i32 dest, TCGv_i32 t0, TCGv_i32 t1)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_HAS_add2_i32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(tmp, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_add2_i32(cpu_NF, cpu_CF, t0, tmp, cpu_CF, tmp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_add2_i32(cpu_NF, cpu_CF, cpu_NF, cpu_CF, t1, tmp);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 q0 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 q1 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(q0, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(q1, t1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_add_i64(q0, q0, q1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(q1, cpu_CF);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_add_i64(q0, q0, q1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extr_i64_i32(cpu_NF, cpu_CF, q0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(q0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(q1);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(cpu_ZF, cpu_NF);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(cpu_VF, cpu_NF, t0);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(tmp, t0, t1);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_andc_i32(cpu_VF, cpu_VF, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(dest, cpu_NF);<BR>}</P>
<P>/* dest = T0 - T1. Compute C, N, V and Z flags */<BR>static void gen_sub_CC(TCGv_i32 dest, TCGv_i32 t0, TCGv_i32 t1)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp;<BR>&nbsp;&nbsp;&nbsp; tcg_gen_sub_i32(cpu_NF, t0, t1);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(cpu_ZF, cpu_NF);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_setcond_i32(TCG_COND_GEU, cpu_CF, t0, t1);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(cpu_VF, cpu_NF, t0);<BR>&nbsp;&nbsp;&nbsp; tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(tmp, t0, t1);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_and_i32(cpu_VF, cpu_VF, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(dest, cpu_NF);<BR>}</P>
<P>/* dest = T0 + ~T1 + CF.&nbsp; Compute C, N, V and Z flags */<BR>static void gen_sbc_CC(TCGv_i32 dest, TCGv_i32 t0, TCGv_i32 t1)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_not_i32(tmp, t1);<BR>&nbsp;&nbsp;&nbsp; gen_adc_CC(dest, t0, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>}