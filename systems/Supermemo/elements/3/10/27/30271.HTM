static void gen_smul_dual(TCGv_i32 a, TCGv_i32 b)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp1 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp2 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ext16s_i32(tmp1, a);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ext16s_i32(tmp2, b);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mul_i32(tmp1, tmp1, tmp2);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp2);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(a, a, 16);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(b, b, 16);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mul_i32(b, b, a);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(a, tmp1);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp1);<BR>}</P>
<P>/* Byteswap each halfword.&nbsp; */<BR>static void gen_rev16(TCGv_i32 var)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_shri_i32(tmp, var, 8);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(tmp, tmp, 0x00ff00ff);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(var, var, 8);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(var, var, 0xff00ff00);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(var, var, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>}</P>
<P>/* Byteswap low halfword and sign extend.&nbsp; */<BR>static void gen_revsh(TCGv_i32 var)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ext16u_i32(var, var);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_bswap16_i32(var, var);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_ext16s_i32(var, var);<BR>}</P>
<P>/* Unsigned bitfield extract.&nbsp; */<BR>static void gen_ubfx(TCGv_i32 var, int shift, uint32_t mask)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (shift)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_shri_i32(var, var, shift);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(var, var, mask);<BR>}</P>
<P>/* Signed bitfield extract.&nbsp; */<BR>static void gen_sbfx(TCGv_i32 var, int shift, int width)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t signbit;</P>
<P>&nbsp;&nbsp;&nbsp; if (shift)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_sari_i32(var, var, shift);<BR>&nbsp;&nbsp;&nbsp; if (shift + width &lt; 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signbit = 1u &lt;&lt; (width - 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(var, var, (1u &lt;&lt; width) - 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_xori_i32(var, var, signbit);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_subi_i32(var, var, signbit);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Return (b &lt;&lt; 32) + a. Mark inputs as dead */<BR>static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv_i32 b)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 tmp64 = tcg_temp_new_i64();</P>
<P>&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(tmp64, b);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(b);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(tmp64, tmp64, 32);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_add_i64(a, tmp64, a);</P>
<P>&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(tmp64);<BR>&nbsp;&nbsp;&nbsp; return a;<BR>}</P>
<P>/* Return (b &lt;&lt; 32) - a. Mark inputs as dead. */<BR>static TCGv_i64 gen_subq_msw(TCGv_i64 a, TCGv_i32 b)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 tmp64 = tcg_temp_new_i64();</P>
<P>&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(tmp64, b);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(b);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_shli_i64(tmp64, tmp64, 32);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_sub_i64(a, tmp64, a);</P>
<P>&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(tmp64);<BR>&nbsp;&nbsp;&nbsp; return a;<BR>}</P>
<P>/* 32x32-&gt;64 multiply.&nbsp; Marks inputs as dead.&nbsp; */<BR>static TCGv_i64 gen_mulu_i64_i32(TCGv_i32 a, TCGv_i32 b)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 lo = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 hi = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 ret;</P>
<P>&nbsp;&nbsp;&nbsp; tcg_gen_mulu2_i32(lo, hi, a, b);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(a);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(b);</P>
<P>&nbsp;&nbsp;&nbsp; ret = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_concat_i32_i64(ret, lo, hi);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(lo);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(hi);</P>
<P>&nbsp;&nbsp;&nbsp; return ret;<BR>}</P>
<P>static TCGv_i64 gen_muls_i64_i32(TCGv_i32 a, TCGv_i32 b)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 lo = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 hi = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 ret;</P>
<P>&nbsp;&nbsp;&nbsp; tcg_gen_muls2_i32(lo, hi, a, b);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(a);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(b);</P>
<P>&nbsp;&nbsp;&nbsp; ret = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_concat_i32_i64(ret, lo, hi);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(lo);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(hi);</P>
<P>&nbsp;&nbsp;&nbsp; return ret;<BR>}</P>
<P>/* Swap low and high halfwords.&nbsp; */<BR>static void gen_swap_half(TCGv_i32 var)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_shri_i32(tmp, var, 16);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_shli_i32(var, var, 16);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(var, var, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>}</P>
<P>/* Dual 16-bit add.&nbsp; Result placed in t0 and t1 is marked as dead.<BR>&nbsp;&nbsp;&nbsp; tmp = (t0 ^ t1) &amp; 0x8000;<BR>&nbsp;&nbsp;&nbsp; t0 &amp;= ~0x8000;<BR>&nbsp;&nbsp;&nbsp; t1 &amp;= ~0x8000;<BR>&nbsp;&nbsp;&nbsp; t0 = (t0 + t1) ^ tmp;<BR>&nbsp;*/</P>
<P>static void gen_add16(TCGv_i32 t0, TCGv_i32 t1)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(tmp, t0, t1);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(tmp, tmp, 0x8000);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(t0, t0, ~0x8000);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(t1, t1, ~0x8000);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_add_i32(t0, t0, t1);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_xor_i32(t0, t0, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t1);<BR>}