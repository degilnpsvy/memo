# Linux-4.7: include/linux/kthread.h 
<P></P>
<P>#ifndef _LINUX_KTHREAD_H<BR>#define _LINUX_KTHREAD_H<BR>/* Simple interface for creating and stopping kernel threads without mess. */<BR>#include &lt;linux/err.h&gt;<BR>#include &lt;linux/sched.h&gt;</P>
<P></P>
<P>__printf(4, 5)<BR>struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int node,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char namefmt[], ...);</P>
<P>#define kthread_create(threadfn, data, namefmt, arg...) \<BR>&nbsp;kthread_create_on_node(threadfn, data, NUMA_NO_NODE, namefmt, ##arg)</P>
<P><BR>struct task_struct *kthread_create_on_cpu(int (*threadfn)(void *data),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int cpu,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *namefmt);</P>
<P><FONT class=extract>/**<BR>&nbsp;* kthread_run - create and wake a thread.<BR>&nbsp;* @threadfn: the function to run until signal_pending(current).<BR>&nbsp;* @data: data ptr for @threadfn.<BR>&nbsp;* @namefmt: printf-style name for the thread.<BR>&nbsp;*<BR>&nbsp;* Description: Convenient wrapper for kthread_create() followed by<BR>&nbsp;* wake_up_process().&nbsp; Returns the kthread or ERR_PTR(-ENOMEM).<BR>&nbsp;*/<BR>#define kthread_run(threadfn, data, namefmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;struct task_struct *__k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;= kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \<BR>&nbsp;if (!IS_ERR(__k))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;wake_up_process(__k);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;__k;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>})</FONT></P>
<P>void kthread_bind(struct task_struct *k, unsigned int cpu);<BR>void kthread_bind_mask(struct task_struct *k, const struct cpumask *mask);<BR>int kthread_stop(struct task_struct *k);<BR>bool kthread_should_stop(void);<BR>bool kthread_should_park(void);<BR>bool kthread_freezable_should_stop(bool *was_frozen);<BR>void *kthread_data(struct task_struct *k);<BR>void *probe_kthread_data(struct task_struct *k);<BR>int kthread_park(struct task_struct *k);<BR>void kthread_unpark(struct task_struct *k);<BR>void kthread_parkme(void);</P>
<P>int kthreadd(void *unused);<BR>extern struct task_struct *kthreadd_task;<BR>extern int tsk_fork_get_node(struct task_struct *tsk);</P>
<P><FONT class=extract>/*<BR>&nbsp;* Simple work processor based on kthread.<BR>&nbsp;*<BR>&nbsp;* This provides easier way to make use of kthreads.&nbsp; A kthread_work<BR>&nbsp;* can be queued and flushed using queue/flush_kthread_work()<BR>&nbsp;* respectively.&nbsp; Queued kthread_works are processed by a kthread<BR>&nbsp;* running kthread_worker_fn().<BR>&nbsp;*/<BR>struct kthread_work;<BR>typedef void (*kthread_work_func_t)(struct kthread_work *work);</FONT></P>
<P><FONT class=extract>struct kthread_worker {<BR>&nbsp;spinlock_t&nbsp;&nbsp;lock;<BR>&nbsp;struct list_head&nbsp;work_list;<BR>&nbsp;struct task_struct&nbsp;*task;<BR>&nbsp;struct kthread_work&nbsp;*current_work;<BR>};</FONT></P>
<P><FONT class=extract>struct kthread_work {<BR>&nbsp;struct list_head&nbsp;node;<BR>&nbsp;kthread_work_func_t&nbsp;func;<BR>&nbsp;struct kthread_worker&nbsp;*worker;<BR>};</FONT></P>
<P><FONT class=extract>#define KTHREAD_WORKER_INIT(worker)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.lock = __SPIN_LOCK_UNLOCKED((worker).lock),&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.work_list = LIST_HEAD_INIT((worker).work_list),&nbsp;&nbsp;\<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>#define KTHREAD_WORK_INIT(work, fn)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.node = LIST_HEAD_INIT((work).node),&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.func = (fn),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>#define DEFINE_KTHREAD_WORKER(worker)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;struct kthread_worker worker = KTHREAD_WORKER_INIT(worker)</FONT></P>
<P><FONT class=extract>#define DEFINE_KTHREAD_WORK(work, fn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;struct kthread_work work = KTHREAD_WORK_INIT(work, fn)</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* kthread_worker.lock needs its own lockdep class key when defined on<BR>&nbsp;* stack with lockdep enabled.&nbsp; Use the following macros in such cases.<BR>&nbsp;*/<BR>#ifdef CONFIG_LOCKDEP<BR># define KTHREAD_WORKER_INIT_ONSTACK(worker)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;({ init_kthread_worker(&amp;worker); worker; })<BR># define DEFINE_KTHREAD_WORKER_ONSTACK(worker)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;struct kthread_worker worker = KTHREAD_WORKER_INIT_ONSTACK(worker)<BR>#else<BR># define DEFINE_KTHREAD_WORKER_ONSTACK(worker) DEFINE_KTHREAD_WORKER(worker)<BR>#endif</FONT></P>
<P><FONT class=extract>extern void __init_kthread_worker(struct kthread_worker *worker,<BR>&nbsp;&nbsp;&nbsp;const char *name, struct lock_class_key *key);</FONT></P>
<P><FONT class=extract>#define init_kthread_worker(worker)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;static struct lock_class_key __key;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__init_kthread_worker((worker), "("#worker")-&gt;lock", &amp;__key); \<BR>&nbsp;} while (0)</FONT></P>
<P><FONT class=extract>#define init_kthread_work(work, fn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;memset((work), 0, sizeof(struct kthread_work));&nbsp;&nbsp;\<BR>&nbsp;&nbsp;INIT_LIST_HEAD(&amp;(work)-&gt;node);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;(work)-&gt;func = (fn);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;} while (0)</FONT></P>
<P><FONT class=extract>int kthread_worker_fn(void *worker_ptr);</FONT></P>
<P><FONT class=extract>bool queue_kthread_work(struct kthread_worker *worker,<BR>&nbsp;&nbsp;&nbsp;struct kthread_work *work);<BR>void flush_kthread_work(struct kthread_work *work);<BR>void flush_kthread_worker(struct kthread_worker *worker);</FONT></P>
<P>#endif /* _LINUX_KTHREAD_H */