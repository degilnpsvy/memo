/*<BR>&nbsp;* Simple work processor based on kthread.<BR>&nbsp;*<BR>&nbsp;* This provides easier way to make use of kthreads.&nbsp; A kthread_work<BR>&nbsp;* can be queued and flushed using queue/flush_kthread_work()<BR>&nbsp;* respectively.&nbsp; Queued kthread_works are processed by a kthread<BR>&nbsp;* running kthread_worker_fn().<BR>&nbsp;*/<BR>struct kthread_work;<BR>typedef void (*kthread_work_func_t)(struct kthread_work *work);</P>
<P>struct kthread_worker {<BR>&nbsp;spinlock_t&nbsp;&nbsp;lock;<BR>&nbsp;struct list_head&nbsp;work_list;<BR>&nbsp;struct task_struct&nbsp;*task;<BR>&nbsp;struct kthread_work&nbsp;*current_work;<BR>};</P>
<P>struct kthread_work {<BR>&nbsp;struct list_head&nbsp;node;<BR>&nbsp;kthread_work_func_t&nbsp;func;<BR>&nbsp;struct kthread_worker&nbsp;*worker;<BR>};</P>
<P>#define KTHREAD_WORKER_INIT(worker)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.lock = __SPIN_LOCK_UNLOCKED((worker).lock),&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.work_list = LIST_HEAD_INIT((worker).work_list),&nbsp;&nbsp;\<BR>&nbsp;}</P>
<P>#define KTHREAD_WORK_INIT(work, fn)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.node = LIST_HEAD_INIT((work).node),&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.func = (fn),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;}</P>
<P>#define DEFINE_KTHREAD_WORKER(worker)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;struct kthread_worker worker = KTHREAD_WORKER_INIT(worker)</P>
<P>#define DEFINE_KTHREAD_WORK(work, fn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;struct kthread_work work = KTHREAD_WORK_INIT(work, fn)</P>
<P>/*<BR>&nbsp;* kthread_worker.lock needs its own lockdep class key when defined on<BR>&nbsp;* stack with lockdep enabled.&nbsp; Use the following macros in such cases.<BR>&nbsp;*/<BR>#ifdef CONFIG_LOCKDEP<BR># define KTHREAD_WORKER_INIT_ONSTACK(worker)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;({ init_kthread_worker(&amp;worker); worker; })<BR># define DEFINE_KTHREAD_WORKER_ONSTACK(worker)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;struct kthread_worker worker = KTHREAD_WORKER_INIT_ONSTACK(worker)<BR>#else<BR># define DEFINE_KTHREAD_WORKER_ONSTACK(worker) DEFINE_KTHREAD_WORKER(worker)<BR>#endif</P>
<P>extern void __init_kthread_worker(struct kthread_worker *worker,<BR>&nbsp;&nbsp;&nbsp;const char *name, struct lock_class_key *key);</P>
<P>#define init_kthread_worker(worker)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;static struct lock_class_key __key;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__init_kthread_worker((worker), "("#worker")-&gt;lock", &amp;__key); \<BR>&nbsp;} while (0)</P>
<P>#define init_kthread_work(work, fn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;memset((work), 0, sizeof(struct kthread_work));&nbsp;&nbsp;\<BR>&nbsp;&nbsp;INIT_LIST_HEAD(&amp;(work)-&gt;node);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;(work)-&gt;func = (fn);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;} while (0)</P>
<P>int kthread_worker_fn(void *worker_ptr);</P>
<P>bool queue_kthread_work(struct kthread_worker *worker,<BR>&nbsp;&nbsp;&nbsp;struct kthread_work *work);<BR>void flush_kthread_work(struct kthread_work *work);<BR>void flush_kthread_worker(struct kthread_worker *worker);