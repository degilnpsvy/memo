# target-arm/machine.c</P>
<P>#include "qemu/osdep.h"<BR>#include "qemu-common.h"<BR>#include "cpu.h"<BR>#include "hw/hw.h"<BR>#include "hw/boards.h"<BR>#include "qemu/error-report.h"<BR>#include "sysemu/kvm.h"<BR>#include "kvm_arm.h"<BR>#include "internals.h"<BR>#include "migration/cpu.h"</P>
<P></P>
<P>static bool vfp_needed(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; return arm_feature(env, ARM_FEATURE_VFP);<BR>}</P>
<P>static int get_fpscr(QEMUFile *f, void *opaque, size_t size)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; uint32_t val = qemu_get_be32(f);</P>
<P>&nbsp;&nbsp;&nbsp; vfp_set_fpscr(env, val);<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>static void put_fpscr(QEMUFile *f, void *opaque, size_t size)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; qemu_put_be32(f, vfp_get_fpscr(env));<BR>}</P>
<P>static const VMStateInfo vmstate_fpscr = {<BR>&nbsp;&nbsp;&nbsp; .name = "fpscr",<BR>&nbsp;&nbsp;&nbsp; .get = get_fpscr,<BR>&nbsp;&nbsp;&nbsp; .put = put_fpscr,<BR>};</P>
<P>static const VMStateDescription vmstate_vfp = {<BR>&nbsp;&nbsp;&nbsp; .name = "cpu/vfp",<BR>&nbsp;&nbsp;&nbsp; .version_id = 3,<BR>&nbsp;&nbsp;&nbsp; .minimum_version_id = 3,<BR>&nbsp;&nbsp;&nbsp; .needed = vfp_needed,<BR>&nbsp;&nbsp;&nbsp; .fields = (VMStateField[]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_FLOAT64_ARRAY(env.vfp.regs, ARMCPU, 64),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The xregs array is a little awkward because element 1 (FPSCR)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * requires a specific accessor, so we have to split it up in<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the vmstate:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32(env.vfp.xregs[0], ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32_SUB_ARRAY(env.vfp.xregs, ARMCPU, 2, 14),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "fpscr",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .version_id = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .size = sizeof(uint32_t),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .info = &amp;vmstate_fpscr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .flags = VMS_SINGLE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .offset = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_END_OF_LIST()<BR>&nbsp;&nbsp;&nbsp; }<BR>};</P>
<P>static bool iwmmxt_needed(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; return arm_feature(env, ARM_FEATURE_IWMMXT);<BR>}</P>
<P>static const VMStateDescription vmstate_iwmmxt = {<BR>&nbsp;&nbsp;&nbsp; .name = "cpu/iwmmxt",<BR>&nbsp;&nbsp;&nbsp; .version_id = 1,<BR>&nbsp;&nbsp;&nbsp; .minimum_version_id = 1,<BR>&nbsp;&nbsp;&nbsp; .needed = iwmmxt_needed,<BR>&nbsp;&nbsp;&nbsp; .fields = (VMStateField[]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT64_ARRAY(env.iwmmxt.regs, ARMCPU, 16),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32_ARRAY(env.iwmmxt.cregs, ARMCPU, 16),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_END_OF_LIST()<BR>&nbsp;&nbsp;&nbsp; }<BR>};</P>
<P>static bool m_needed(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; return arm_feature(env, ARM_FEATURE_M);<BR>}</P>
<P>static const VMStateDescription vmstate_m = {<BR>&nbsp;&nbsp;&nbsp; .name = "cpu/m",<BR>&nbsp;&nbsp;&nbsp; .version_id = 1,<BR>&nbsp;&nbsp;&nbsp; .minimum_version_id = 1,<BR>&nbsp;&nbsp;&nbsp; .needed = m_needed,<BR>&nbsp;&nbsp;&nbsp; .fields = (VMStateField[]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32(env.v7m.other_sp, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32(env.v7m.vecbase, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32(env.v7m.basepri, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32(env.v7m.control, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_INT32(env.v7m.current_sp, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_INT32(env.v7m.exception, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_END_OF_LIST()<BR>&nbsp;&nbsp;&nbsp; }<BR>};</P>
<P>static bool thumb2ee_needed(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; return arm_feature(env, ARM_FEATURE_THUMB2EE);<BR>}</P>
<P>static const VMStateDescription vmstate_thumb2ee = {<BR>&nbsp;&nbsp;&nbsp; .name = "cpu/thumb2ee",<BR>&nbsp;&nbsp;&nbsp; .version_id = 1,<BR>&nbsp;&nbsp;&nbsp; .minimum_version_id = 1,<BR>&nbsp;&nbsp;&nbsp; .needed = thumb2ee_needed,<BR>&nbsp;&nbsp;&nbsp; .fields = (VMStateField[]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32(env.teecr, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32(env.teehbr, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_END_OF_LIST()<BR>&nbsp;&nbsp;&nbsp; }<BR>};</P>
<P>static bool pmsav7_needed(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; return arm_feature(env, ARM_FEATURE_MPU) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_feature(env, ARM_FEATURE_V7);<BR>}</P>
<P>static bool pmsav7_rgnr_vmstate_validate(void *opaque, int version_id)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;</P>
<P>&nbsp;&nbsp;&nbsp; return cpu-&gt;env.cp15.c6_rgnr &lt; cpu-&gt;pmsav7_dregion;<BR>}</P>
<P>static const VMStateDescription vmstate_pmsav7 = {<BR>&nbsp;&nbsp;&nbsp; .name = "cpu/pmsav7",<BR>&nbsp;&nbsp;&nbsp; .version_id = 1,<BR>&nbsp;&nbsp;&nbsp; .minimum_version_id = 1,<BR>&nbsp;&nbsp;&nbsp; .needed = pmsav7_needed,<BR>&nbsp;&nbsp;&nbsp; .fields = (VMStateField[]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_VARRAY_UINT32(env.pmsav7.drbar, ARMCPU, pmsav7_dregion, 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vmstate_info_uint32, uint32_t),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_VARRAY_UINT32(env.pmsav7.drsr, ARMCPU, pmsav7_dregion, 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vmstate_info_uint32, uint32_t),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_VARRAY_UINT32(env.pmsav7.dracr, ARMCPU, pmsav7_dregion, 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vmstate_info_uint32, uint32_t),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_VALIDATE("rgnr is valid", pmsav7_rgnr_vmstate_validate),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_END_OF_LIST()<BR>&nbsp;&nbsp;&nbsp; }<BR>};</P>
<P>static int get_cpsr(QEMUFile *f, void *opaque, size_t size)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; uint32_t val = qemu_get_be32(f);</P>
<P>&nbsp;&nbsp;&nbsp; env-&gt;aarch64 = ((val &amp; PSTATE_nRW) == 0);</P>
<P>&nbsp;&nbsp;&nbsp; if (is_a64(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstate_write(env, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>static void put_cpsr(QEMUFile *f, void *opaque, size_t size)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; uint32_t val;</P>
<P>&nbsp;&nbsp;&nbsp; if (is_a64(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = pstate_read(env);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = cpsr_read(env);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; qemu_put_be32(f, val);<BR>}</P>
<P>static const VMStateInfo vmstate_cpsr = {<BR>&nbsp;&nbsp;&nbsp; .name = "cpsr",<BR>&nbsp;&nbsp;&nbsp; .get = get_cpsr,<BR>&nbsp;&nbsp;&nbsp; .put = put_cpsr,<BR>};</P>
<P>static void cpu_pre_save(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;</P>
<P>&nbsp;&nbsp;&nbsp; if (kvm_enabled()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!write_kvmstate_to_list(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* This should never fail */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!write_cpustate_to_list(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* This should never fail. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_vmstate_array_len = cpu-&gt;cpreg_array_len;<BR>&nbsp;&nbsp;&nbsp; memcpy(cpu-&gt;cpreg_vmstate_indexes, cpu-&gt;cpreg_indexes,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_array_len * sizeof(uint64_t));<BR>&nbsp;&nbsp;&nbsp; memcpy(cpu-&gt;cpreg_vmstate_values, cpu-&gt;cpreg_values,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_array_len * sizeof(uint64_t));<BR>}</P>
<P>static int cpu_post_load(void *opaque, int version_id)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; int i, v;</P>
<P>&nbsp;&nbsp;&nbsp; /* Update the values list from the incoming migration data.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Anything in the incoming data which we don't know about is<BR>&nbsp;&nbsp;&nbsp;&nbsp; * a migration failure; anything we know about but the incoming<BR>&nbsp;&nbsp;&nbsp;&nbsp; * data doesn't specify retains its current (reset) value.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * The indexes list remains untouched -- we only inspect the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * incoming migration index list so we can match the values array<BR>&nbsp;&nbsp;&nbsp;&nbsp; * entries with the right slots in our own values array.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp; for (i = 0, v = 0; i &lt; cpu-&gt;cpreg_array_len<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; v &lt; cpu-&gt;cpreg_vmstate_array_len; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cpu-&gt;cpreg_vmstate_indexes[v] &gt; cpu-&gt;cpreg_indexes[i]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* register in our list but not incoming : skip it */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cpu-&gt;cpreg_vmstate_indexes[v] &lt; cpu-&gt;cpreg_indexes[i]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* register in their list but not ours: fail migration */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* matching register, copy the value over */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_values[i] = cpu-&gt;cpreg_vmstate_values[v];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v++;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (kvm_enabled()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!write_list_to_kvmstate(cpu, KVM_PUT_FULL_STATE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note that it's OK for the TCG side not to know about<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * every register in the list; KVM is authoritative if<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * we're using it.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_list_to_cpustate(cpu);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!write_list_to_cpustate(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; hw_breakpoint_update_all(cpu);<BR>&nbsp;&nbsp;&nbsp; hw_watchpoint_update_all(cpu);</P>
<P>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>const VMStateDescription vmstate_arm_cpu = {<BR>&nbsp;&nbsp;&nbsp; .name = "cpu",<BR>&nbsp;&nbsp;&nbsp; .version_id = 22,<BR>&nbsp;&nbsp;&nbsp; .minimum_version_id = 22,<BR>&nbsp;&nbsp;&nbsp; .pre_save = cpu_pre_save,<BR>&nbsp;&nbsp;&nbsp; .post_load = cpu_post_load,<BR>&nbsp;&nbsp;&nbsp; .fields = (VMStateField[]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32_ARRAY(env.regs, ARMCPU, 16),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT64_ARRAY(env.xregs, ARMCPU, 32),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT64(env.pc, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "cpsr",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .version_id = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .size = sizeof(uint32_t),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .info = &amp;vmstate_cpsr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .flags = VMS_SINGLE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .offset = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32(env.spsr, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT64_ARRAY(env.banked_spsr, ARMCPU, 8),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32_ARRAY(env.banked_r13, ARMCPU, 8),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32_ARRAY(env.banked_r14, ARMCPU, 8),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32_ARRAY(env.usr_regs, ARMCPU, 5),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32_ARRAY(env.fiq_regs, ARMCPU, 5),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT64_ARRAY(env.elr_el, ARMCPU, 4),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT64_ARRAY(env.sp_el, ARMCPU, 4),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The length-check must come before the arrays to avoid<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * incoming data possibly overflowing the array.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_INT32_POSITIVE_LE(cpreg_vmstate_array_len, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_VARRAY_INT32(cpreg_vmstate_indexes, ARMCPU,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpreg_vmstate_array_len,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, vmstate_info_uint64, uint64_t),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_VARRAY_INT32(cpreg_vmstate_values, ARMCPU,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpreg_vmstate_array_len,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, vmstate_info_uint64, uint64_t),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT64(env.exclusive_addr, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT64(env.exclusive_val, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT64(env.exclusive_high, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT64(env.features, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32(env.exception.syndrome, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT32(env.exception.fsr, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_UINT64(env.exception.vaddress, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_TIMER_PTR(gt_timer[GTIMER_PHYS], ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_TIMER_PTR(gt_timer[GTIMER_VIRT], ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_BOOL(powered_off, ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMSTATE_END_OF_LIST()<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; .subsections = (const VMStateDescription*[]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;vmstate_vfp,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;vmstate_iwmmxt,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;vmstate_m,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;vmstate_thumb2ee,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;vmstate_pmsav7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL<BR>&nbsp;&nbsp;&nbsp; }<BR>};</P>
<P>const char *gicv3_class_name(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (kvm_irqchip_in_kernel()) {<BR>#ifdef TARGET_AARCH64<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "kvm-arm-gicv3";<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_report("KVM GICv3 acceleration is not supported on this "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "platform");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>#endif<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "arm-gicv3";<BR>&nbsp;&nbsp;&nbsp; }<BR>}