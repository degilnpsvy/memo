void tcg_context_init(TCGContext *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; int op, total_args, n, i;<BR>&nbsp;&nbsp;&nbsp; TCGOpDef *def;<BR>&nbsp;&nbsp;&nbsp; TCGArgConstraint *args_ct;<BR>&nbsp;&nbsp;&nbsp; int *sorted_args;<BR>&nbsp;&nbsp;&nbsp; GHashTable *helper_table;</P>
<P>&nbsp;&nbsp;&nbsp; memset(s, 0, sizeof(*s));<BR>&nbsp;&nbsp;&nbsp; s-&gt;nb_globals = 0;</P>
<P>&nbsp;&nbsp;&nbsp; /* Count total number of arguments and allocate the corresponding<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; space */<BR>&nbsp;&nbsp;&nbsp; total_args = 0;<BR>&nbsp;&nbsp;&nbsp; for(op = 0; op &lt; NB_OPS; op++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def = &amp;tcg_op_defs[op];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = def-&gt;nb_iargs + def-&gt;nb_oargs;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total_args += n;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; args_ct = g_malloc(sizeof(TCGArgConstraint) * total_args);<BR>&nbsp;&nbsp;&nbsp; sorted_args = g_malloc(sizeof(int) * total_args);</P>
<P>&nbsp;&nbsp;&nbsp; for(op = 0; op &lt; NB_OPS; op++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def = &amp;tcg_op_defs[op];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def-&gt;args_ct = args_ct;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def-&gt;sorted_args = sorted_args;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = def-&gt;nb_iargs + def-&gt;nb_oargs;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sorted_args += n;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args_ct += n;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Register helpers.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; /* Use g_direct_hash/equal for direct pointer comparisons on func.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; s-&gt;helpers = helper_table = g_hash_table_new(NULL, NULL);</P>
<P>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; ARRAY_SIZE(all_helpers); ++i) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_hash_table_insert(helper_table, (gpointer)all_helpers[i].func,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gpointer)&amp;all_helpers[i]);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; tcg_target_init(s);</P>
<P>&nbsp;&nbsp;&nbsp; /* Reverse the order of the saved registers, assuming they're all at<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the start of tcg_target_reg_alloc_order.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; for (n = 0; n &lt; ARRAY_SIZE(tcg_target_reg_alloc_order); ++n) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int r = tcg_target_reg_alloc_order[n];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tcg_regset_test_reg(tcg_target_call_clobber_regs, r)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; n; ++i) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indirect_reg_alloc_order[i] = tcg_target_reg_alloc_order[n - 1 - i];<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; for (; i &lt; ARRAY_SIZE(tcg_target_reg_alloc_order); ++i) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indirect_reg_alloc_order[i] = tcg_target_reg_alloc_order[i];<BR>&nbsp;&nbsp;&nbsp; }<BR>}