static void gen_ss_advance(DisasContext *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* If the singlestep state is Active-not-pending, advance to<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Active-pending.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (s-&gt;ss_active) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;pstate_ss = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_clear_pstate_ss(cpu_env);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void gen_step_complete_exception(DisasContext *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* We just completed step of an insn. Move from Active-not-pending<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to Active-pending, and then also take the swstep exception.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This corresponds to making the (IMPDEF) choice to prioritize<BR>&nbsp;&nbsp;&nbsp;&nbsp; * swstep exceptions over asynchronous exceptions taken to an exception<BR>&nbsp;&nbsp;&nbsp;&nbsp; * level where debug is disabled. This choice has the advantage that<BR>&nbsp;&nbsp;&nbsp;&nbsp; * we do not need to maintain internal state corresponding to the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * ISV/EX syndrome bits between completion of the step and generation<BR>&nbsp;&nbsp;&nbsp;&nbsp; * of the exception, and our syndrome information is always correct.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; gen_ss_advance(s);<BR>&nbsp;&nbsp;&nbsp; gen_exception(EXCP_UDEF, syn_swstep(s-&gt;ss_same_el, 1, s-&gt;is_ldex),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default_exception_el(s));<BR>&nbsp;&nbsp;&nbsp; s-&gt;is_jmp = DISAS_EXC;<BR>}