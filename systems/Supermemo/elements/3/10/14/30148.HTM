/**<BR>&nbsp;* get_alignment_bits<BR>&nbsp;* @memop: TCGMemOp value<BR>&nbsp;*<BR>&nbsp;* Extract the alignment size from the memop.<BR>&nbsp;*<BR>&nbsp;* Returns: 0 in case of byte access (which is always aligned);<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; positive value - number of alignment bits;<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; negative value if unaligned access enabled<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and this is not a byte access.<BR>&nbsp;*/<BR>static inline int get_alignment_bits(TCGMemOp memop)<BR>{<BR>&nbsp;&nbsp;&nbsp; int a = memop &amp; MO_AMASK;<BR>&nbsp;&nbsp;&nbsp; int s = memop &amp; MO_SIZE;<BR>&nbsp;&nbsp;&nbsp; int r;</P>
<P>&nbsp;&nbsp;&nbsp; if (a == MO_UNALN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Negative value if unaligned access enabled,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * or zero value in case of byte access.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -s;<BR>&nbsp;&nbsp;&nbsp; } else if (a == MO_ALIGN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* A natural alignment: return a number of access size bits */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = s;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Specific alignment size. It must be equal or greater<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * than the access size.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = a &gt;&gt; MO_ASHIFT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_debug_assert(r &gt;= s);<BR>&nbsp;&nbsp;&nbsp; }<BR>#if defined(CONFIG_SOFTMMU)<BR>&nbsp;&nbsp;&nbsp; /* The requested alignment cannot overlap the TLB flags.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert((TLB_FLAGS_MASK &amp; ((1 &lt;&lt; r) - 1)) == 0);<BR>#endif<BR>&nbsp;&nbsp;&nbsp; return r;<BR>}