static inline ARMMMUIdx get_a32_user_mem_index(DisasContext *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Return the mmu_idx to use for A32/T32 "unprivileged load/store"<BR>&nbsp;&nbsp;&nbsp;&nbsp; * insns:<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; if PL2, UNPREDICTABLE (we choose to implement as if PL0)<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; otherwise, access as if at PL0.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; switch (s-&gt;mmu_idx) {<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1E2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* this one is UNPREDICTABLE */<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S12NSE0:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S12NSE1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ARMMMUIdx_S12NSE0;<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1E3:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1SE0:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1SE1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ARMMMUIdx_S1SE0;<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S2NS:<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }<BR>}