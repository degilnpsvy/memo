/* Store a 64-bit value to a register pair.&nbsp; Clobbers val.&nbsp; */<BR>static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp;<BR>&nbsp;&nbsp;&nbsp; tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_extrl_i64_i32(tmp, val);<BR>&nbsp;&nbsp;&nbsp; store_reg(s, rlow, tmp);<BR>&nbsp;&nbsp;&nbsp; tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_shri_i64(val, val, 32);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_extrl_i64_i32(tmp, val);<BR>&nbsp;&nbsp;&nbsp; store_reg(s, rhigh, tmp);<BR>}</P>
<P>/* load a 32-bit value from a register and perform a 64-bit accumulate.&nbsp; */<BR>static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 tmp;<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp2;</P>
<P>&nbsp;&nbsp;&nbsp; /* Load value and extend to 64 bits.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tmp = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp; tmp2 = load_reg(s, rlow);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(tmp, tmp2);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp2);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_add_i64(val, val, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(tmp);<BR>}</P>
<P>/* load and add a 64-bit value from a register pair.&nbsp; */<BR>static void gen_addq(DisasContext *s, TCGv_i64 val, int rlow, int rhigh)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 tmp;<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmpl;<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmph;</P>
<P>&nbsp;&nbsp;&nbsp; /* Load 64-bit value rd:rn.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tmpl = load_reg(s, rlow);<BR>&nbsp;&nbsp;&nbsp; tmph = load_reg(s, rhigh);<BR>&nbsp;&nbsp;&nbsp; tmp = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_concat_i32_i64(tmp, tmpl, tmph);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmpl);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmph);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_add_i64(val, val, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(tmp);<BR>}</P>
<P>/* Set N and Z flags from hi|lo.&nbsp; */<BR>static void gen_logicq_cc(TCGv_i32 lo, TCGv_i32 hi)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_mov_i32(cpu_NF, hi);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(cpu_ZF, lo, hi);<BR>}</P>
<P>/* Load/Store exclusive instructions are implemented by remembering<BR>&nbsp;&nbsp; the value/address loaded, and seeing if these are the same<BR>&nbsp;&nbsp; when the store is performed. This should be sufficient to implement<BR>&nbsp;&nbsp; the architecturally mandated semantics, and avoids having to monitor<BR>&nbsp;&nbsp; regular stores.</P>
<P>&nbsp;&nbsp; In system emulation mode only one CPU will be running at once, so<BR>&nbsp;&nbsp; this sequence is effectively atomic.&nbsp; In user emulation mode we<BR>&nbsp;&nbsp; throw an exception and handle the atomic operation elsewhere.&nbsp; */<BR>static void gen_load_exclusive(DisasContext *s, int rt, int rt2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 addr, int size)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp = tcg_temp_new_i32();</P>
<P>&nbsp;&nbsp;&nbsp; s-&gt;is_ldex = true;</P>
<P>&nbsp;&nbsp;&nbsp; switch (size) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_aa32_ld8u(s, tmp, addr, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_aa32_ld16ua(s, tmp, addr, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_aa32_ld32ua(s, tmp, addr, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (size == 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 tmp2 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 tmp3 = tcg_temp_new_i32();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_addi_i32(tmp2, addr, 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_aa32_ld32u(s, tmp3, tmp2, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_concat_i32_i64(cpu_exclusive_val, tmp, tmp3);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; store_reg(s, rt2, tmp3);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(cpu_exclusive_val, tmp);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; store_reg(s, rt, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(cpu_exclusive_addr, addr);<BR>}</P>
<P>static void gen_clrex(DisasContext *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i64(cpu_exclusive_addr, -1);<BR>}</P>
<P>#ifdef CONFIG_USER_ONLY<BR>static void gen_store_exclusive(DisasContext *s, int rd, int rt, int rt2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 addr, int size)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(cpu_exclusive_test, addr);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(cpu_exclusive_info,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size | (rd &lt;&lt; 4) | (rt &lt;&lt; 8) | (rt2 &lt;&lt; 12));<BR>&nbsp;&nbsp;&nbsp; gen_exception_internal_insn(s, 4, EXCP_STREX);<BR>}<BR>#else<BR>static void gen_store_exclusive(DisasContext *s, int rd, int rt, int rt2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 addr, int size)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp;<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 val64, extaddr;<BR>&nbsp;&nbsp;&nbsp; TCGLabel *done_label;<BR>&nbsp;&nbsp;&nbsp; TCGLabel *fail_label;</P>
<P>&nbsp;&nbsp;&nbsp; /* if (env-&gt;exclusive_addr == addr &amp;&amp; env-&gt;exclusive_val == [addr]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [addr] = {Rt};<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {Rd} = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {Rd} = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } */<BR>&nbsp;&nbsp;&nbsp; fail_label = gen_new_label();<BR>&nbsp;&nbsp;&nbsp; done_label = gen_new_label();<BR>&nbsp;&nbsp;&nbsp; extaddr = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(extaddr, addr);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_brcond_i64(TCG_COND_NE, extaddr, cpu_exclusive_addr, fail_label);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(extaddr);</P>
<P>&nbsp;&nbsp;&nbsp; tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; switch (size) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_aa32_ld8u(s, tmp, addr, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_aa32_ld16u(s, tmp, addr, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; val64 = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp; if (size == 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 tmp2 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 tmp3 = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_addi_i32(tmp2, addr, 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_aa32_ld32u(s, tmp3, tmp2, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_concat_i32_i64(val64, tmp, tmp3);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp3);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extu_i32_i64(val64, tmp);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);</P>
<P>&nbsp;&nbsp;&nbsp; tcg_gen_brcond_i64(TCG_COND_NE, val64, cpu_exclusive_val, fail_label);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(val64);</P>
<P>&nbsp;&nbsp;&nbsp; tmp = load_reg(s, rt);<BR>&nbsp;&nbsp;&nbsp; switch (size) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_aa32_st8(s, tmp, addr, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_aa32_st16(s, tmp, addr, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_aa32_st32(s, tmp, addr, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>&nbsp;&nbsp;&nbsp; if (size == 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_addi_i32(addr, addr, 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = load_reg(s, rt2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_aa32_st32(s, tmp, addr, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(cpu_R[rd], 0);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_br(done_label);<BR>&nbsp;&nbsp;&nbsp; gen_set_label(fail_label);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(cpu_R[rd], 1);<BR>&nbsp;&nbsp;&nbsp; gen_set_label(done_label);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i64(cpu_exclusive_addr, -1);<BR>}<BR>#endif</P>
<P>/* gen_srs:<BR>&nbsp;* @env: CPUARMState<BR>&nbsp;* @s: DisasContext<BR>&nbsp;* @mode: mode field from insn (which stack to store to)<BR>&nbsp;* @amode: addressing mode (DA/IA/DB/IB), encoded as per P,U bits in ARM insn<BR>&nbsp;* @writeback: true if writeback bit set<BR>&nbsp;*<BR>&nbsp;* Generate code for the SRS (Store Return State) insn.<BR>&nbsp;*/<BR>static void gen_srs(DisasContext *s,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t mode, uint32_t amode, bool writeback)<BR>{<BR>&nbsp;&nbsp;&nbsp; int32_t offset;<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 addr, tmp;<BR>&nbsp;&nbsp;&nbsp; bool undef = false;</P>
<P>&nbsp;&nbsp;&nbsp; /* SRS is:<BR>&nbsp;&nbsp;&nbsp;&nbsp; * - trapped to EL3 if EL3 is AArch64 and we are at Secure EL1<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; and specified mode is monitor mode<BR>&nbsp;&nbsp;&nbsp;&nbsp; * - UNDEFINED in Hyp mode<BR>&nbsp;&nbsp;&nbsp;&nbsp; * - UNPREDICTABLE in User or System mode<BR>&nbsp;&nbsp;&nbsp;&nbsp; * - UNPREDICTABLE if the specified mode is:<BR>&nbsp;&nbsp;&nbsp;&nbsp; * -- not implemented<BR>&nbsp;&nbsp;&nbsp;&nbsp; * -- not a valid mode number<BR>&nbsp;&nbsp;&nbsp;&nbsp; * -- a mode that's at a higher exception level<BR>&nbsp;&nbsp;&nbsp;&nbsp; * -- Monitor, if we are Non-secure<BR>&nbsp;&nbsp;&nbsp;&nbsp; * For the UNPREDICTABLE cases we choose to UNDEF.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (s-&gt;current_el == 1 &amp;&amp; !s-&gt;ns &amp;&amp; mode == ARM_CPU_MODE_MON) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_exception_insn(s, 4, EXCP_UDEF, syn_uncategorized(), 3);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (s-&gt;current_el == 0 || s-&gt;current_el == 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; undef = true;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch (mode) {<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_USR:<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_FIQ:<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_IRQ:<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_SVC:<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_ABT:<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_UND:<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_SYS:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_HYP:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s-&gt;current_el == 1 || !arm_dc_feature(s, ARM_FEATURE_EL2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; undef = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_MON:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* No need to check specifically for "are we non-secure" because<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * we've already made EL0 UNDEF and handled the trap for S-EL1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * so if this isn't EL3 then we must be non-secure.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s-&gt;current_el != 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; undef = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; undef = true;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (undef) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_exception_insn(s, 4, EXCP_UDEF, syn_uncategorized(),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default_exception_el(s));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; addr = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; tmp = tcg_const_i32(mode);<BR>&nbsp;&nbsp;&nbsp; /* get_r13_banked() will raise an exception if called from System mode */<BR>&nbsp;&nbsp;&nbsp; gen_set_condexec(s);<BR>&nbsp;&nbsp;&nbsp; gen_set_pc_im(s, s-&gt;pc - 4);<BR>&nbsp;&nbsp;&nbsp; gen_helper_get_r13_banked(addr, cpu_env, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>&nbsp;&nbsp;&nbsp; switch (amode) {<BR>&nbsp;&nbsp;&nbsp; case 0: /* DA */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = -4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 1: /* IA */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2: /* DB */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = -8;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 3: /* IB */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_gen_addi_i32(addr, addr, offset);<BR>&nbsp;&nbsp;&nbsp; tmp = load_reg(s, 14);<BR>&nbsp;&nbsp;&nbsp; gen_aa32_st32(s, tmp, addr, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>&nbsp;&nbsp;&nbsp; tmp = load_cpu_field(spsr);<BR>&nbsp;&nbsp;&nbsp; tcg_gen_addi_i32(addr, addr, 4);<BR>&nbsp;&nbsp;&nbsp; gen_aa32_st32(s, tmp, addr, get_mem_index(s));<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>&nbsp;&nbsp;&nbsp; if (writeback) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (amode) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = -8;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = -4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_addi_i32(addr, addr, offset);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = tcg_const_i32(mode);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_set_r13_banked(cpu_env, tmp, addr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tmp);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(addr);<BR>&nbsp;&nbsp;&nbsp; s-&gt;is_jmp = DISAS_UPDATE;<BR>}