static int handle_vrint(uint32_t insn, uint32_t rd, uint32_t rm, uint32_t dp,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int rounding)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_ptr fpst = get_fpstatus_ptr(0);<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tcg_rmode;</P>
<P>&nbsp;&nbsp;&nbsp; tcg_rmode = tcg_const_i32(arm_rmode_to_sf(rounding));<BR>&nbsp;&nbsp;&nbsp; gen_helper_set_rmode(tcg_rmode, tcg_rmode, cpu_env);</P>
<P>&nbsp;&nbsp;&nbsp; if (dp) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 tcg_op;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 tcg_res;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_op = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_res = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ld_f64(tcg_op, cpu_env, vfp_reg_offset(dp, rm));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_rintd(tcg_res, tcg_op, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_st_f64(tcg_res, cpu_env, vfp_reg_offset(dp, rd));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(tcg_op);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(tcg_res);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 tcg_op;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 tcg_res;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_op = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_res = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ld_f32(tcg_op, cpu_env, vfp_reg_offset(dp, rm));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_rints(tcg_res, tcg_op, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_st_f32(tcg_res, cpu_env, vfp_reg_offset(dp, rd));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tcg_op);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tcg_res);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; gen_helper_set_rmode(tcg_rmode, tcg_rmode, cpu_env);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tcg_rmode);</P>
<P>&nbsp;&nbsp;&nbsp; tcg_temp_free_ptr(fpst);<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>static int handle_vcvt(uint32_t insn, uint32_t rd, uint32_t rm, uint32_t dp,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int rounding)<BR>{<BR>&nbsp;&nbsp;&nbsp; bool is_signed = extract32(insn, 7, 1);<BR>&nbsp;&nbsp;&nbsp; TCGv_ptr fpst = get_fpstatus_ptr(0);<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tcg_rmode, tcg_shift;</P>
<P>&nbsp;&nbsp;&nbsp; tcg_shift = tcg_const_i32(0);</P>
<P>&nbsp;&nbsp;&nbsp; tcg_rmode = tcg_const_i32(arm_rmode_to_sf(rounding));<BR>&nbsp;&nbsp;&nbsp; gen_helper_set_rmode(tcg_rmode, tcg_rmode, cpu_env);</P>
<P>&nbsp;&nbsp;&nbsp; if (dp) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 tcg_double, tcg_res;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 tcg_tmp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Rd is encoded as a single precision register even when the source<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * is double precision.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rd = ((rd &lt;&lt; 1) &amp; 0x1e) | ((rd &gt;&gt; 4) &amp; 0x1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_double = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_res = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ld_f64(tcg_double, cpu_env, vfp_reg_offset(1, rm));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_signed) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_vfp_tosld(tcg_res, tcg_double, tcg_shift, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_vfp_tould(tcg_res, tcg_double, tcg_shift, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extrl_i64_i32(tcg_tmp, tcg_res);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_st_f32(tcg_tmp, cpu_env, vfp_reg_offset(0, rd));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tcg_tmp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(tcg_res);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(tcg_double);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 tcg_single, tcg_res;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_single = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_res = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ld_f32(tcg_single, cpu_env, vfp_reg_offset(0, rm));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_signed) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_vfp_tosls(tcg_res, tcg_single, tcg_shift, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_helper_vfp_touls(tcg_res, tcg_single, tcg_shift, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_st_f32(tcg_res, cpu_env, vfp_reg_offset(0, rd));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tcg_res);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tcg_single);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; gen_helper_set_rmode(tcg_rmode, tcg_rmode, cpu_env);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tcg_rmode);</P>
<P>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tcg_shift);</P>
<P>&nbsp;&nbsp;&nbsp; tcg_temp_free_ptr(fpst);</P>
<P>&nbsp;&nbsp;&nbsp; return 0;<BR>}