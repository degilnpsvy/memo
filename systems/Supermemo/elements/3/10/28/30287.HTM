/* Return the mask of PSR bits set by a MSR instruction.&nbsp; */<BR>static uint32_t msr_mask(DisasContext *s, int flags, int spsr)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t mask;</P>
<P>&nbsp;&nbsp;&nbsp; mask = 0;<BR>&nbsp;&nbsp;&nbsp; if (flags &amp; (1 &lt;&lt; 0))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= 0xff;<BR>&nbsp;&nbsp;&nbsp; if (flags &amp; (1 &lt;&lt; 1))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= 0xff00;<BR>&nbsp;&nbsp;&nbsp; if (flags &amp; (1 &lt;&lt; 2))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= 0xff0000;<BR>&nbsp;&nbsp;&nbsp; if (flags &amp; (1 &lt;&lt; 3))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= 0xff000000;</P>
<P>&nbsp;&nbsp;&nbsp; /* Mask out undefined bits.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; mask &amp;= ~CPSR_RESERVED;<BR>&nbsp;&nbsp;&nbsp; if (!arm_dc_feature(s, ARM_FEATURE_V4T)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask &amp;= ~CPSR_T;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (!arm_dc_feature(s, ARM_FEATURE_V5)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask &amp;= ~CPSR_Q; /* V5TE in reality*/<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (!arm_dc_feature(s, ARM_FEATURE_V6)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask &amp;= ~(CPSR_E | CPSR_GE);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (!arm_dc_feature(s, ARM_FEATURE_THUMB2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask &amp;= ~CPSR_IT;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* Mask out execution state and reserved bits.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!spsr) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask &amp;= ~(CPSR_EXEC | CPSR_RESERVED);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* Mask out privileged bits.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (IS_USER(s))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask &amp;= CPSR_USER;<BR>&nbsp;&nbsp;&nbsp; return mask;<BR>}</P>
<P>/* Returns nonzero if access to the PSR is not permitted. Marks t0 as dead. */<BR>static int gen_set_psr(DisasContext *s, uint32_t mask, int spsr, TCGv_i32 t0)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp;<BR>&nbsp;&nbsp;&nbsp; if (spsr) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ??? This is also undefined in system mode.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (IS_USER(s))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = load_cpu_field(spsr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(tmp, tmp, ~mask);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_andi_i32(t0, t0, mask);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_or_i32(tmp, tmp, t0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; store_cpu_field(tmp, spsr);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gen_set_cpsr(t0, mask);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(t0);<BR>&nbsp;&nbsp;&nbsp; gen_lookup_tb(s);<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>/* Returns nonzero if access to the PSR is not permitted.&nbsp; */<BR>static int gen_set_psr_im(DisasContext *s, uint32_t mask, int spsr, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tmp;<BR>&nbsp;&nbsp;&nbsp; tmp = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; tcg_gen_movi_i32(tmp, val);<BR>&nbsp;&nbsp;&nbsp; return gen_set_psr(s, mask, spsr, tmp);<BR>}</P>
<P>static bool msr_banked_access_decode(DisasContext *s, int r, int sysm, int rn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *tgtmode, int *regno)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Decode the r and sysm fields of MSR/MRS banked accesses into<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the target mode and register number, and identify the various<BR>&nbsp;&nbsp;&nbsp;&nbsp; * unpredictable cases.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * MSR (banked) and MRS (banked) are CONSTRAINED UNPREDICTABLE if:<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; + executed in user mode<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; + using R15 as the src/dest register<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; + accessing an unimplemented register<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; + accessing a register that's inaccessible at current PL/security state*<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; + accessing a register that you could access with a different insn<BR>&nbsp;&nbsp;&nbsp;&nbsp; * We choose to UNDEF in all these cases.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Since we don't know which of the various AArch32 modes we are in<BR>&nbsp;&nbsp;&nbsp;&nbsp; * we have to defer some checks to runtime.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Accesses to Monitor mode registers from Secure EL1 (which implies<BR>&nbsp;&nbsp;&nbsp;&nbsp; * that EL3 is AArch64) must trap to EL3.<BR>&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp; * If the access checks fail this function will emit code to take<BR>&nbsp;&nbsp;&nbsp;&nbsp; * an exception and return false. Otherwise it will return true,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and set *tgtmode and *regno appropriately.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int exc_target = default_exception_el(s);</P>
<P>&nbsp;&nbsp;&nbsp; /* These instructions are present only in ARMv8, or in ARMv7 with the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Virtualization Extensions.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!arm_dc_feature(s, ARM_FEATURE_V8) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_dc_feature(s, ARM_FEATURE_EL2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto undef;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (IS_USER(s) || rn == 15) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto undef;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* The table in the v8 ARM ARM section F5.2.3 describes the encoding<BR>&nbsp;&nbsp;&nbsp;&nbsp; * of registers into (r, sysm).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (r) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* SPSRs for other modes */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (sysm) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0xe: /* SPSR_fiq */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_FIQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x10: /* SPSR_irq */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_IRQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x12: /* SPSR_svc */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_SVC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x14: /* SPSR_abt */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_ABT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x16: /* SPSR_und */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_UND;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x1c: /* SPSR_mon */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_MON;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x1e: /* SPSR_hyp */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_HYP;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: /* unallocated */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto undef;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We arbitrarily assign SPSR a register number of 16. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *regno = 16;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* general purpose registers for other modes */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (sysm) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x0 ... 0x6:&nbsp;&nbsp; /* 0b00xxx : r8_usr ... r14_usr */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_USR;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *regno = sysm + 8;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x8 ... 0xe:&nbsp;&nbsp; /* 0b01xxx : r8_fiq ... r14_fiq */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_FIQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *regno = sysm;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x10 ... 0x11: /* 0b1000x : r14_irq, r13_irq */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_IRQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *regno = sysm &amp; 1 ? 13 : 14;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x12 ... 0x13: /* 0b1001x : r14_svc, r13_svc */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_SVC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *regno = sysm &amp; 1 ? 13 : 14;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x14 ... 0x15: /* 0b1010x : r14_abt, r13_abt */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_ABT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *regno = sysm &amp; 1 ? 13 : 14;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x16 ... 0x17: /* 0b1011x : r14_und, r13_und */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_UND;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *regno = sysm &amp; 1 ? 13 : 14;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x1c ... 0x1d: /* 0b1110x : r14_mon, r13_mon */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_MON;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *regno = sysm &amp; 1 ? 13 : 14;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0x1e ... 0x1f: /* 0b1111x : elr_hyp, r13_hyp */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *tgtmode = ARM_CPU_MODE_HYP;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Arbitrarily pick 17 for ELR_Hyp (which is not a banked LR!) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *regno = sysm &amp; 1 ? 13 : 17;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default: /* unallocated */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto undef;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Catch the 'accessing inaccessible register' cases we can detect<BR>&nbsp;&nbsp;&nbsp;&nbsp; * at translate time.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; switch (*tgtmode) {<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_MON:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_dc_feature(s, ARM_FEATURE_EL3) || s-&gt;ns) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto undef;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s-&gt;current_el == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If we're in Secure EL1 (which implies that EL3 is AArch64)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * then accesses to Mon registers trap to EL3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exc_target = 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto undef;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_HYP:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note that we can forbid accesses from EL2 here because they<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * must be from Hyp mode itself<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_dc_feature(s, ARM_FEATURE_EL2) || s-&gt;current_el &lt; 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto undef;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return true;</P>
<P>undef:<BR>&nbsp;&nbsp;&nbsp; /* If we get here then some access check did not pass */<BR>&nbsp;&nbsp;&nbsp; gen_exception_insn(s, 4, EXCP_UDEF, syn_uncategorized(), exc_target);<BR>&nbsp;&nbsp;&nbsp; return false;<BR>}</P>
<P>static void gen_msr_banked(DisasContext *s, int r, int sysm, int rn)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tcg_reg, tcg_tgtmode, tcg_regno;<BR>&nbsp;&nbsp;&nbsp; int tgtmode = 0, regno = 0;</P>
<P>&nbsp;&nbsp;&nbsp; if (!msr_banked_access_decode(s, r, sysm, rn, &amp;tgtmode, &amp;regno)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Sync state because msr_banked() can raise exceptions */<BR>&nbsp;&nbsp;&nbsp; gen_set_condexec(s);<BR>&nbsp;&nbsp;&nbsp; gen_set_pc_im(s, s-&gt;pc - 4);<BR>&nbsp;&nbsp;&nbsp; tcg_reg = load_reg(s, rn);<BR>&nbsp;&nbsp;&nbsp; tcg_tgtmode = tcg_const_i32(tgtmode);<BR>&nbsp;&nbsp;&nbsp; tcg_regno = tcg_const_i32(regno);<BR>&nbsp;&nbsp;&nbsp; gen_helper_msr_banked(cpu_env, tcg_reg, tcg_tgtmode, tcg_regno);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tcg_tgtmode);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tcg_regno);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tcg_reg);<BR>&nbsp;&nbsp;&nbsp; s-&gt;is_jmp = DISAS_UPDATE;<BR>}</P>
<P>static void gen_mrs_banked(DisasContext *s, int r, int sysm, int rn)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGv_i32 tcg_reg, tcg_tgtmode, tcg_regno;<BR>&nbsp;&nbsp;&nbsp; int tgtmode = 0, regno = 0;</P>
<P>&nbsp;&nbsp;&nbsp; if (!msr_banked_access_decode(s, r, sysm, rn, &amp;tgtmode, &amp;regno)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Sync state because mrs_banked() can raise exceptions */<BR>&nbsp;&nbsp;&nbsp; gen_set_condexec(s);<BR>&nbsp;&nbsp;&nbsp; gen_set_pc_im(s, s-&gt;pc - 4);<BR>&nbsp;&nbsp;&nbsp; tcg_reg = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp; tcg_tgtmode = tcg_const_i32(tgtmode);<BR>&nbsp;&nbsp;&nbsp; tcg_regno = tcg_const_i32(regno);<BR>&nbsp;&nbsp;&nbsp; gen_helper_mrs_banked(tcg_reg, cpu_env, tcg_tgtmode, tcg_regno);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tcg_tgtmode);<BR>&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(tcg_regno);<BR>&nbsp;&nbsp;&nbsp; store_reg(s, rn, tcg_reg);<BR>&nbsp;&nbsp;&nbsp; s-&gt;is_jmp = DISAS_UPDATE;<BR>}