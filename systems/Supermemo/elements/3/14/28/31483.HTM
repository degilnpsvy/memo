D2.2.38 <FONT class=extract>DHCSR, Debug Halting Control and Status Register</FONT> 
<P></P>
<P><FONT class=extract>The DHCSR characteristics are:<BR>Purpose: Controls halting debug.<BR>Usage constraints: Privileged access permitted only. Unprivileged accesses generate a BusFault.<BR>&nbsp; This register is word accessible only. Halfword and byte accesses are UNPREDICTABLE.<BR>&nbsp; If the Main Extension is not implemented then it is IMPLEMENTATION DEFINED whether this register is accessible only to the debugger and RES0 for software.<BR>Configurations: Present only if halting debug is implemented.<BR>&nbsp; This register is RES0 if halting debug is not implemented.<BR>Attributes: 32-bit read/write register located at 0xE000EDF0.<BR>&nbsp; Secure software can access the Non-secure view of this register via DHCSR_NS located at 0xE002EDF0. The location 0xE002EDF0 is RES0 to software executing in Non-secure state and the debugger.<BR>&nbsp; This register is not banked between Security states.</FONT></P>
<P><FONT class=extract>DBGKEY, bits [31:16], on a write<BR>Debug key. A debugger must write 0xA05F to this field to enable write access to the remaining bits, otherwise the PE ignores the write access.<BR>The possible values of this field are:<BR>0xA05F Writes accompanied by this value update bits[15:0].<BR>Not 0xA05F Write ignored.</FONT></P>
<P>Bits [31:27], on a read<BR>Reserved, RES0.</P>
<P>S_RESTART_ST, bit [26], on a read<BR>Restart sticky status. Indicates the PE has processed a request to clear DHCSR.C_HALT to 0. That is, either a write to DHCSR that clears DHCSR.C_HALT from 1 to 0, or an External Restart Request.<BR>The possible values of this bit are:<BR>0 PE has not left Debug state since the last read of DHCSR.<BR>1 PE has left Debug state since the last read of DHCSR.<BR>If the PE is not halted when C_HALT is cleared to zero, it is UNPREDICTABLE whether this bit is set to 1. If DHCSR.C_DEBUGEN == 0 this bit reads as an UNKNOWN value.<BR>This bit clears to zero when read.<BR>Note<BR>If the request to clear C_HALT is made simultaneously with a request to set C_HALT, for example a restart request and external debug request occur together, then the PE notionally leaves Debug state and immediately halts again and S_RESTART_ST is set to 1.</P>
<P>S_RESET_ST, bit [25], on a read<BR>Reset sticky status. Indicates whether the PE has been reset since the last read of the DHCSR.<BR>The possible values of this bit are:<BR>0 No reset since last DHCSR read.<BR>1 At least one reset since last DHCSR read.<BR>This bit clears to zero when read.<BR>This bit resets to one on a Warm reset.</P>
<P>S_RETIRE_ST, bit [24], on a read<BR>Retire sticky status. Set to 1 every time the PE retires one of more instructions.<BR>The possible values of this bit are:<BR>0 No instruction retired since last DHCSR read.<BR>1 At least one instruction retired since last DHCSR read.<BR>This bit clears to zero when read.<BR>This bit resets to an UNKNOWN value on a Warm reset.</P>
<P>Bits [23:21], on a read<BR>Reserved, RES0.</P>
<P>S_SDE, bit [20], on a read<BR>Secure debug enabled. Indicates whether Secure invasive debug is allowed.<BR>The possible values of this bit are:<BR>0 Secure invasive debug prohibited.<BR>1 Secure invasive debug allowed.<BR>If the PE is in Non-debug state, this bit reflects the value of SecureHaltingDebugAllowed().<BR>If the PE is in Debug state then this bit is 1 if the PE entered Debug state from either Non-secure state with SecureHaltingDebugAllowed() == TRUE or from Secure state, and 0 otherwise. The value of this bit does not change whilst the PE remains in Debug state.<BR>If the Security Extension is not implemented, this bit is RES0.</P>
<P><FONT class=extract>S_LOCKUP, bit [19], on a read<BR>Lockup status. Indicates whether the PE is in Lockup state.<BR>The possible values of this bit are:<BR>0 Not locked up.<BR>1 Locked up.<BR>This bit can only be read as 1 by a remote debugger, using the DAP. The value of 1 indicates that the PE is running but locked up. The bit clears to 0 when the PE enters Debug state.</FONT></P>
<P><FONT class=extract>S_SLEEP, bit [18], on a read<BR>Sleeping status. Indicates whether the PE is sleeping.<BR>The possible values of this bit are:<BR>0 Not sleeping.<BR>1 Sleeping.<BR>The debugger must set the C_HALT bit to 1 to gain control, or wait for an interrupt or other wakeup event to wakeup the system.</FONT></P>
<P><FONT class=extract>S_HALT, bit [17], on a read<BR>Halted status. Indicates whether the PE is in Debug state.<BR>The possible values of this bit are:<BR>0 In Non-debug state.<BR>1 In Debug state.</FONT></P>
<P>S_REGRDY, bit [16], on a read<BR>Register ready status. Handshake flag to transfers through the DCRDR.<BR>The possible values of this bit are:<BR>0 Write to DCRSR performed, but transfer not yet complete.<BR>1 Transfer complete, or no outstanding transfer.<BR>This bit is valid only when the PE is in Debug state, otherwise this bit is UNKNOWN.<BR>This bit resets to an UNKNOWN value on a Warm reset.</P>
<P>Bits [15:6]<BR>Reserved, RES0.</P>
<P>C_SNAPSTALL, bit [5]<BR>Snap stall control. Allow imprecise entry to Debug state.<BR>The possible values of this bit are:<BR>0 No action.<BR>1 Allow imprecise entry to Debug state, for example by forcing any stalled load or store instruction to be abandoned.<BR>Setting this bit to 1 allows a debugger to request imprecise entry to Debug state. Writing 1 to this bit makes the state of the memory system UNPREDICTABLE. Therefore if a debugger writes 1 to this bit it must reset the system before leaving Debug state.<BR>The effect of setting this bit to 1 is UNPREDICTABLE unless the DHCSR write also sets C_DEBUGEN and C_HALT to 1. This means that if the PE is not already in Debug state, it enters Debug state when the stalled instruction completes.<BR>If the Security Extension is implemented, then writes to this bit are ignored when DHCSR.S_SDE == 0.<BR>If DHCSR.C_DEBUGEN == 0 or HaltingDebugAllowed() == FALSE, the PE ignores this bit and behaves as if it is set to 0.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>Note<BR>A debugger can write to the DHCSR to clear this bit to 0, However, this does not remove the UNPREDICTABLE state of the memory system caused by setting C_SNAPSTALL to 1. The architecture does not guarantee that setting this bit to 1 will force entry to Debug State. ARM strongly recommends that a value of 1 is never written to C_SNAPSTALL when the PE is in Debug state.</P>
<P>Bit [4]<BR>Reserved, RES0.</P>
<P>C_MASKINTS, bit [3]<BR>Mask interrupts control. When debug is enabled, the debugger can write to this bit to mask PendSV, SysTick and external configurable interrupts.<BR>The possible values of this bit are:<BR>0 Do not mask.<BR>1 Mask PendSV, SysTick and external configurable interrupts.<BR>The effect of any single write to DHCSR that changes the value of this bit is UNPREDICTABLE unless one of:<BR>&#8226; Before the write, DHCSR.C_HALT == 1 and the write also writes 1 to DHCSR.C_HALT.<BR>&#8226; Before the write, DHCSR.C_DEBUGEN == 0 or HaltingDebugAllowed() == FALSE and the write writes 0 to this bit.<BR>This means that a single write to DHCSR must not clear DHCSR.C_HALT to 0 and change the value of the C_MASKINTS bit.<BR>If the Security Extension is implemented and DHCSR.S_SDE == 0, this bit does not affect interrupts targeting Secure state.<BR>If DHCSR.C_DEBUGEN == 0 or HaltingDebugAllowed() == FALSE, the PE ignores this bit and behaves as if it is set to 0.<BR>If DHCSR.C_DEBUGEN == 0 this bit reads as an UNKNOWN value.<BR>This bit resets to an UNKNOWN value on a Cold reset.<BR>Note<BR>This bit does not affect NMI.</P>
<P>C_STEP, bit [2]<BR>Step control. Enable single instruction step.<BR>The possible values of this bit are:<BR>0 No effect.<BR>1 Single step enabled.<BR>The PE ignores this bit and behaves as if it set to 0 if any of:<BR>&#8226; DHCSR.C_DEBUGEN == 0 or HaltingDebugAllowed() == FALSE.<BR>&#8226; The Security Extension is implemented, DHCSR.S_SDE == 0 and the PE is in Secure state.<BR>If DHCSR.C_DEBUGEN == 0 this bit reads as an UNKNOWN value.<BR>This bit resets to an UNKNOWN value on a Cold reset.</P>
<P>C_HALT, bit [1]<BR>Halt control. PE enter Debug state halt request.<BR>The possible values of this bit are:<BR>0 Causes the PE to leave Debug state, if in Debug state.<BR>1 Halt the PE.<BR>The PE sets C_HALT to 1 when a debug event pends an entry to Debug state.<BR>The PE ignores this bit and behaves as if it is set to 0 if any of:<BR>&#8226; DHCSR.C_DEBUGEN == 0 or HaltingDebugAllowed() == FALSE.<BR>&#8226; The Security Extension is implemented, DHCSR.S_SDE == 0 and the PE is in Secure state.<BR>If DHCSR.C_DEBUGEN == 0 this bit reads as an UNKNOWN value.<BR>This bit resets to zero on a Warm reset.</P>
<P>C_DEBUGEN, bit [0]<BR>Debug enable control. Enable Halting debug.<BR>The possible values of this bit are:<BR>0 Disabled.<BR>1 Enabled.<BR>If a debugger writes to DHCSR to change the value of this bit from 0 to 1, it must also write 0 to the C_MASKINTS bit, otherwise behavior is UNPREDICTABLE.<BR>If this bit is set to 0:<BR>&#8226; The PE behaves as if DHCSR.{C_MASKINTS, C_STEP, C_HALT} are all set to 0.<BR>&#8226; DHCSR.{S_RESTART_ST, C_MASKINTS, C_STEP, C_HALT} are UNKNOWN on reads of DHCSR.<BR>This bit is read/write to the debugger. Writes from software are ignored.<BR>This bit resets to zero on a Cold reset.