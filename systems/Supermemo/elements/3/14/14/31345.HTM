<H1>exec, wait and exit</H1>
<DIV class=sect1><A id=_producer_consumer class=anchor></A>
<H2>Producer-Consumer</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<DIV class=title><STRONG>Problem description</STRONG>:</DIV>
<UL>
<LI>
<P>Producer and consumer share a fixed-size buffer.</P>
<LI>
<P>Producer can add items to the buffer <STRONG>if it is not full</STRONG>.</P>
<LI>
<P>Consumer can withdraw items from the buffer <STRONG>if it is not empty</STRONG>.</P></LI></UL></DIV>
<DIV class=ulist>
<DIV class=title>What do we want to ensure?</DIV>
<UL>
<LI>
<P>Producer <STRONG>must wait</STRONG> if the buffer is full.</P>
<LI>
<P>Consumer <STRONG>must wait</STRONG> if the buffer is empty.</P>
<LI>
<P>Producers should not be sleeping if there is room in the buffer.</P>
<LI>
<P>Consumers should not be sleeping if there are items in the buffer.</P></LI></UL></DIV>
<TABLE class="tableblock frame-all grid-all spread">
<COLGROUP>
<COL style="WIDTH: 50%">
<COL style="WIDTH: 50%"></COLGROUP>
<TBODY>
<TR>
<TD class="tableblock halign-left valign-top">
<DIV>
<DIV class=listingblock>
<DIV class=content><PRE class=highlight><CODE class="language-c lang-c" data-lang="c"><SPAN class=hljs-keyword>int</SPAN> count = <SPAN class=hljs-number>0</SPAN>;
<SPAN class=hljs-function><SPAN class=hljs-keyword>void</SPAN> <SPAN class=hljs-title>produce</SPAN><SPAN class=hljs-params>(item)</SPAN> </SPAN>{
  <SPAN class=hljs-keyword>while</SPAN> (count == FULL) {
    <SPAN class=hljs-comment>// do something</SPAN>
  }
  put(buffer, item);
  count++;
}

<SPAN class=hljs-function>item <SPAN class=hljs-title>consume</SPAN><SPAN class=hljs-params>()</SPAN> </SPAN>{
  <SPAN class=hljs-keyword>while</SPAN> (count == <SPAN class=hljs-number>0</SPAN>) {
    <SPAN class=hljs-comment>// do something</SPAN>
  }
  item = get(buffer, item);
  count--;
  <SPAN class=hljs-keyword>return</SPAN> item;
}</CODE></PRE></DIV></DIV></DIV></TD>
<TD class="tableblock halign-left valign-top">
<DIV>
<DIV class=ulist>
<DIV class=title>What synchronization primitive is a good fit for this problem?</DIV>
<UL>
<LI>
<P><STRONG>Condition variables</STRONG>: I have a variable (<CODE>count</CODE>) and conditions that require waiting (full, empty).</P></LI></UL></DIV></DIV></TD></TR></TBODY></TABLE>
<TABLE class="tableblock frame-all grid-all spread">
<COLGROUP>
<COL style="WIDTH: 50%">
<COL style="WIDTH: 50%"></COLGROUP>
<TBODY>
<TR>
<TD class="tableblock halign-left valign-top">
<DIV>
<DIV class=listingblock>
<DIV class=content><PRE class=highlight><CODE class="language-c lang-c" data-lang="c"><SPAN class=hljs-keyword>int</SPAN> count = <SPAN class=hljs-number>0</SPAN>;
<SPAN class=hljs-keyword>struct</SPAN> * cv countCV;
<SPAN class=hljs-keyword>struct</SPAN> * lock countLock;
<SPAN class=hljs-function><SPAN class=hljs-keyword>void</SPAN> <SPAN class=hljs-title>produce</SPAN><SPAN class=hljs-params>(item)</SPAN> </SPAN>{
  lock_acquire(countLock);
  <SPAN class=hljs-keyword>while</SPAN> (count == FULL) {
    cv_wait(countCV, countLock);
  }
  put(buffer, item);
  count++;
  lock_release(countLock);
}

<SPAN class=hljs-function>item <SPAN class=hljs-title>consume</SPAN><SPAN class=hljs-params>()</SPAN> </SPAN>{
  lock_acquire(countLock);
  <SPAN class=hljs-keyword>while</SPAN> (count == <SPAN class=hljs-number>0</SPAN>) {
    cv_wait(countCV, countLock);
  }
  item = get(buffer, item);
  count--;
  lock_release(countLock);
  <SPAN class=hljs-keyword>return</SPAN> item;
}</CODE></PRE></DIV></DIV></DIV></TD>
<TD class="tableblock halign-left valign-top">
<DIV>
<DIV class=openblock>
<DIV class=content>
<DIV class=paragraph>
<P>Looks good, right?</P></DIV></DIV></DIV>
<DIV class=ulist>
<DIV class=title>Any time you call <CODE>cv_wait</CODE> <STRONG>you must</STRONG> call <CODE>cv_signal</CODE> or <CODE>cv_broadcast</CODE>!</DIV>
<UL>
<LI>
<P><STRONG>But where?</STRONG> Where does the condition change?</P></LI></UL></DIV></DIV></TD></TR></TBODY></TABLE>
<TABLE class="tableblock frame-all grid-all spread">
<COLGROUP>
<COL style="WIDTH: 50%">
<COL style="WIDTH: 50%"></COLGROUP>
<TBODY>
<TR>
<TD class="tableblock halign-left valign-top">
<DIV>
<DIV class=listingblock>
<DIV class=content><PRE class=highlight><CODE class="language-c lang-c" data-lang="c"><SPAN class=hljs-keyword>int</SPAN> count = <SPAN class=hljs-number>0</SPAN>;
<SPAN class=hljs-keyword>struct</SPAN> * cv countCV;
<SPAN class=hljs-keyword>struct</SPAN> * lock countLock;
<SPAN class=hljs-function><SPAN class=hljs-keyword>void</SPAN> <SPAN class=hljs-title>produce</SPAN><SPAN class=hljs-params>(item)</SPAN> </SPAN>{
  lock_acquire(countLock);
  <SPAN class=hljs-keyword>while</SPAN> (count == FULL) {
    cv_wait(countCV, countLock);
  }
  put(buffer, item);
  count++;
  cv_broadcast(countCV, countLock);
  lock_release(countLock);
}

<SPAN class=hljs-function>item <SPAN class=hljs-title>consume</SPAN><SPAN class=hljs-params>()</SPAN> </SPAN>{
  lock_acquire(countLock);
  <SPAN class=hljs-keyword>while</SPAN> (count == <SPAN class=hljs-number>0</SPAN>) {
    cv_wait(countCV, countLock);
  }
  item = get(buffer, item);
  count--;
  cv_broadcast(countCV, countLock);
  lock_release(countLock);
  <SPAN class=hljs-keyword>return</SPAN> item;
}</CODE></PRE></DIV></DIV></DIV></TD>
<TD class="tableblock halign-left valign-top">
<DIV>
<DIV class=openblock>
<DIV class=content>
<DIV class=paragraph>
<P>This works. But does it work well?</P></DIV></DIV></DIV></DIV></TD></TR></TBODY></TABLE>
<TABLE class="tableblock frame-all grid-all spread">
<COLGROUP>
<COL style="WIDTH: 50%">
<COL style="WIDTH: 50%"></COLGROUP>
<TBODY>
<TR>
<TD class="tableblock halign-left valign-top">
<DIV>
<DIV class="listingblock smallest">
<DIV class=content><PRE class=highlight><CODE class="language-c lang-c" data-lang="c"><SPAN class=hljs-keyword>int</SPAN> count = <SPAN class=hljs-number>0</SPAN>;
<SPAN class=hljs-keyword>struct</SPAN> * cv countCV;
<SPAN class=hljs-keyword>struct</SPAN> * lock countLock;
<SPAN class=hljs-function><SPAN class=hljs-keyword>void</SPAN> <SPAN class=hljs-title>produce</SPAN><SPAN class=hljs-params>(item)</SPAN> </SPAN>{
  lock_acquire(countLock);
  <SPAN class=hljs-keyword>while</SPAN> (count == FULL) {
    cv_wait(countCV, countLock);
  }
  put(buffer, item);
  count++;
  <SPAN class=hljs-keyword>if</SPAN> (count == <SPAN class=hljs-number>1</SPAN>) {
    cv_broadcast(countCV, countLock);
  }
  lock_release(countLock);
}

<SPAN class=hljs-function>item <SPAN class=hljs-title>consume</SPAN><SPAN class=hljs-params>()</SPAN> </SPAN>{
  lock_acquire(countLock);
  <SPAN class=hljs-keyword>while</SPAN> (count == <SPAN class=hljs-number>0</SPAN>) {
    cv_wait(countCV, countLock);
  }
  item = get(buffer, item);
  count--;
  <SPAN class=hljs-keyword>if</SPAN> (count == FULL - <SPAN class=hljs-number>1</SPAN>) {
    cv_broadcast(countCV, countLock);
  }
  lock_release(countLock);
  <SPAN class=hljs-keyword>return</SPAN> item;
}</CODE></PRE></DIV></DIV></DIV></TD>
<TD class="tableblock halign-left valign-top">
<DIV>
<DIV class=openblock>
<DIV class=content>
<DIV class=paragraph>
<P>Approaching full victory. But why not use <CODE>cv_signal</CODE>?</P></DIV></DIV></DIV></DIV></TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=sect1><A id=_using_the_right_tool class=anchor></A>
<H2>Using the Right Tool</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>Most problems can be solved with a <STRONG>variety</STRONG> of synchronization primitives.</P>
<LI>
<P>However, there is usually <STRONG>one primitive</STRONG> that is more appropriate than the others.</P>
<LI>
<P>You will have a chance to practice picking synchronization primitives for ASST1, and throughout the class.</P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_approaching_synchronization_problems class=anchor></A>
<H2>Approaching Synchronization Problems</H2>
<DIV class=sectionbody>
<DIV class="olist arabic">
<OL class=arabic>
<LI>
<P>Identify the constraints.</P>
<LI>
<P>Identify shared state.</P>
<LI>
<P>Choose a primitive.</P>
<LI>
<P>Pair waking and sleeping.</P>
<LI>
<P>Look out for multiple resource allocations: can lead to deadlock.</P>
<LI>
<P>Walk through simple examples and corner cases <STRONG>before</STRONG> beginning to code.</P></LI></OL></DIV></DIV></DIV>
<DIV class=sect1><A id=__wait_1_process_lifecycle class=anchor></A>
<H2>$ wait %1 # Process lifecycle</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P><STRONG>Change:</STRONG> <CODE>exec()</CODE></P>
<LI>
<P><STRONG>Death:</STRONG> <CODE>exit()</CODE></P>
<LI>
<P><STRONG>The Afterlife:</STRONG> <CODE>wait()</CODE></P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_groundhog_day class=anchor></A>
<H2>Groundhog Day</H2>
<DIV class=sectionbody>
<DIV class=paragraph>
<P>Is <CODE>fork()</CODE> enough?</P></DIV>
<DIV class="openblock slide replace">
<DIV class=content>
<DIV class=imageblock>
<DIV class=content><IMG style="WIDTH: 100%" alt="initfork 1" src="https://www.ops-class.org/img/slides/figures/initfork-1.svg" data-pagespeed-url-hash="2785547479"></DIV></DIV></DIV></DIV>
<DIV class="openblock slide replace">
<DIV class=content>
<DIV class=imageblock>
<DIV class=content><IMG style="WIDTH: 100%" alt="initfork 2" src="https://www.ops-class.org/img/slides/figures/initfork-2.svg" data-pagespeed-url-hash="3080047400"></DIV></DIV></DIV></DIV>
<DIV class="openblock slide replace">
<DIV class=content>
<DIV class=imageblock>
<DIV class=content><IMG style="WIDTH: 100%" alt="initfork 3" src="https://www.ops-class.org/img/slides/figures/initfork-3.svg" data-pagespeed-url-hash="3374547321"></DIV></DIV></DIV></DIV>
<DIV class="openblock slide replace">
<DIV class=content>
<DIV class=imageblock>
<DIV class=content><IMG style="WIDTH: 100%" alt="initfork 4" src="https://www.ops-class.org/img/slides/figures/initfork-4.svg" data-pagespeed-url-hash="3669047242"></DIV></DIV></DIV></DIV></DIV></DIV>
<DIV class=sect1><A id=_change_code_exec_code class=anchor></A>
<H2>Change: <CODE>exec()</CODE></H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>The <CODE>exec()</CODE> family of system calls replaces the calling process with a new process loaded from a file.</P>
<LI>
<P>The executable file must contain a complete <STRONG>blueprint</STRONG> indicating how the address space should look when <CODE>exec()</CODE> completes.</P>
<DIV class=ulist>
<UL>
<LI>
<P>What should the contents of memory be?</P>
<LI>
<P>Where should the first thread start executing?</P></LI></UL></DIV>
<LI>
<P>Linux and other UNIX-like systems use <STRONG>ELF</STRONG> (Executable and Linkable Format) as the standard describing the information in the executable file is structured.</P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=__span_class_spelling_exception_readelf_display_elf_information_span class=anchor></A>
<H2><SPAN>$ readelf # display ELF information</SPAN></H2>
<DIV class=sectionbody>
<DIV class=imageblock>
<DIV class=content><IMG style="WIDTH: 100%" alt=readelf src="https://www.ops-class.org/img/slides/figures/readelf.svg" data-pagespeed-url-hash="2165681032"></DIV></DIV></DIV></DIV>
<DIV class=sect1><A id=__span_class_spelling_exception_lib_ld_linux_so_2_span class=anchor></A>
<H2><SPAN>$ /lib/ld-linux.so.2</SPAN></H2>
<DIV class=sectionbody>
<DIV class=imageblock>
<DIV class=content><IMG style="WIDTH: 100%" alt=ldlinux src="https://www.ops-class.org/img/slides/figures/ldlinux.svg" data-pagespeed-url-hash="451099055"></DIV></DIV></DIV></DIV>
<DIV class=sect1><A id=__code_exec_code_argument_passing class=anchor></A>
<H2><CODE>exec()</CODE> Argument Passing</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>The process calling <CODE>exec()</CODE> passes arguments to the process that will replace it <STRONG>through the kernel.</STRONG></P>
<DIV class=ulist>
<UL>
<LI>
<P>The kernel retrieves the arguments from the process after the call to <CODE>exec()</CODE> is made.</P>
<LI>
<P>It then pushes them in to the memory of the process where the replacement process can find them when it starts executing.</P>
<LI>
<P>This is where main gets <CODE>argc</CODE> and <CODE>argv</CODE>!</P></LI></UL></DIV>
<LI>
<P><CODE>exec()</CODE> also has an interesting return, almost the dual of <CODE>fork()</CODE>: <CODE>exec()</CODE> <STRONG>never</STRONG> returns!</P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=__code_exec_code class=anchor></A>
<H2>$ <CODE>exec()</CODE></H2>
<DIV class=sectionbody>
<DIV class="openblock slide replace">
<DIV class=content>
<DIV class="imageblock vcenter">
<DIV class=content><IMG style="WIDTH: 100%" alt="exec 1" src="https://www.ops-class.org/img/slides/figures/exec-1.svg" data-pagespeed-url-hash="2119023862"></DIV></DIV></DIV></DIV>
<DIV class="openblock slide replace">
<DIV class=content>
<DIV class="imageblock vcenter">
<DIV class=content><IMG style="WIDTH: 100%" alt="exec 2" src="https://www.ops-class.org/img/slides/figures/exec-2.svg" data-pagespeed-url-hash="2413523783"></DIV></DIV></DIV></DIV>
<DIV class="openblock slide replace">
<DIV class=content>
<DIV class="imageblock vcenter">
<DIV class=content><IMG style="WIDTH: 100%" alt="exec 3" src="https://www.ops-class.org/img/slides/figures/exec-3.svg" data-pagespeed-url-hash="2708023704"></DIV></DIV></DIV></DIV>
<DIV class="openblock slide replace">
<DIV class=content>
<DIV class="imageblock vcenter">
<DIV class=content><IMG style="WIDTH: 100%" alt="exec 4" src="https://www.ops-class.org/img/slides/figures/exec-4.svg" data-pagespeed-url-hash="3002523625"></DIV></DIV></DIV></DIV>
<DIV class="openblock slide replace">
<DIV class=content>
<DIV class="imageblock vcenter">
<DIV class=content><IMG style="WIDTH: 100%" alt="exec 5" src="https://www.ops-class.org/img/slides/figures/exec-5.svg" data-pagespeed-url-hash="3297023546"></DIV></DIV></DIV></DIV>
<DIV class="openblock slide replace">
<DIV class=content>
<DIV class="imageblock vcenter">
<DIV class=content><IMG style="WIDTH: 100%" alt="exec 6" src="https://www.ops-class.org/img/slides/figures/exec-6.svg" data-pagespeed-url-hash="3591523467"></DIV></DIV></DIV></DIV>
<DIV class="openblock slide replace">
<DIV class=content>
<DIV class="imageblock vcenter">
<DIV class=content><IMG style="WIDTH: 100%" alt="exec 7" src="https://www.ops-class.org/img/slides/figures/exec-7.svg" data-pagespeed-url-hash="3886023388"></DIV></DIV></DIV></DIV></DIV></DIV>
<DIV class=sect1><A id=__code_exec_code_file_handle_semantics class=anchor></A>
<H2><CODE>exec()</CODE> File Handle Semantics</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>By convention exec does <STRONG>not</STRONG> modify the file table of the calling process! Why not?</P>
<LI>
<P>Remember <STRONG>pipes</STRONG>?</P>
<DIV class=ulist>
<UL>
<LI>
<P>Don&#8217;t undo all the hard work that <CODE>fork()</CODE> put in to duplicating the file table!</P></LI></UL></DIV></LI></UL></DIV>
<DIV class=imageblock>
<DIV class=content><IMG style="WIDTH: 100%" alt="pipes example 3" src="https://www.ops-class.org/img/slides/figures/pipes-example-3.svg" data-pagespeed-url-hash="1576970783"></DIV></DIV></DIV></DIV>
<DIV class=sect1><A id=_our_simple_shell class=anchor></A>
<H2>Our Simple Shell</H2>
<DIV class=sectionbody>
<DIV class=paragraph>
<P>Disclaimer: this is C-like pseudo-code. It will not compile or run! (But it&#8217;s not far off.)</P></DIV>
<DIV class=listingblock>
<DIV class=content><PRE class=highlight><CODE class="language-c lang-c" data-lang="c"><SPAN class=hljs-keyword>while</SPAN> (<SPAN class=hljs-number>1</SPAN>) {
  input = readLine();
  returnCode = fork();
  <SPAN class=hljs-keyword>if</SPAN> (returnCode == <SPAN class=hljs-number>0</SPAN>) {
    exec(input);
  }
}</CODE></PRE></DIV></DIV></DIV></DIV>
<DIV class=sect1><A id=__code_exec_code_challenges class=anchor></A>
<H2><CODE>exec()</CODE> Challenges</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>The most challenging part of <CODE>exec()</CODE> is making sure that, on failure, <CODE>exec()</CODE> can return to the calling process!</P>
<DIV class=ulist>
<UL>
<LI>
<P>Can&#8217;t make destructive changes to the parent&#8217;s address space until we are <EM>sure</EM> that things will success.</P>
<LI>
<P>Of course, the process is just an abstraction anyway and that provides a lot of flexibility: can prepare a separate address space and just swap it in when we&#8217;re done.</P></LI></UL></DIV></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=__code_exit_code_end_of_life_issues class=anchor></A>
<H2><CODE>exit()</CODE> # End of Life Issues</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>What&#8217;s missing here? <STRONG>Death!</STRONG></P>
<LI>
<P>Processes choose the moment of their own end by calling <CODE>exit()</CODE>.</P>
<LI>
<P>As we discussed earlier a processes passes an <STRONG>exit code</STRONG> to the <CODE>exit()</CODE> function.</P>
<LI>
<P>What happens to this exit code?</P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=__code_wait_code_the_afterlife class=anchor></A>
<H2><CODE>wait()</CODE> # The Afterlife</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>When a process calls <CODE>exit()</CODE> the kernel holds the <STRONG>exit code</STRONG>, which can be retrieved by the exiting child&#8217;s <STRONG>parent</STRONG>.</P>
<LI>
<P>The parent retrieves this exit code by calling <CODE>wait()</CODE>, the last of the primary process-related system calls.</P>
<DIV class=ulist>
<UL>
<LI>
<P>And the one that stubbornly refuses to fit into my lifecycle metaphor.</P></LI></UL></DIV></LI></UL></DIV></DIV></DIV>