<H1>Interrupt and Exception Handling</H1>
<DIV class=sect1><A id=__code_wait_code_code_exit_code class=anchor></A>
<H2><CODE>wait()</CODE>/<CODE>exit()</CODE></H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>We often consider <CODE>wait()</CODE> and <CODE>exit()</CODE> together, since they combine to remove any trace of a process from the system.</P>
<LI>
<P>Until a process <EM>both</EM> calls <CODE>exit()</CODE> and has its exit code collected via <CODE>wait()</CODE> traces of it remain on the system:</P>
<DIV class=ulist>
<UL>
<LI>
<P>Its return code is retained by the kernel.</P>
<LI>
<P>Its process ID (or PID) is also retained. Why?</P></LI></UL></DIV>
<LI>
<P>Processes that have <CODE>exit()</CODE>ed but not had their exit code collected are called <STRONG>zombies</STRONG>. (Ooh, scary!)</P></LI></UL></DIV>
<DIV class=ulist>
<UL>
<LI>
<P><CODE>wait()</CODE>/<CODE>exit()</CODE> also present an interesting synchronization problem you will solve for ASST2.</P>
<DIV class=ulist>
<UL>
<LI>
<P>Calls to <CODE>wait()</CODE> (by the parent) and <CODE>exit()</CODE> (by the child) may interleave in the kernel.</P>
<LI>
<P>You must guarantee that the parent can retrieve the exit code successfully.</P></LI></UL></DIV></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=__code_wait_code_code_exit_code_issues class=anchor></A>
<H2><CODE>wait()</CODE>/<CODE>exit()</CODE> Issues</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>What happens if a process&#8217;s parent exits before it does?</P>
<DIV class=ulist>
<UL>
<LI>
<P>The "orphaned" process is assigned the <CODE>init</CODE> process as a parent, which will collect its exit code when it exits. Referred to as <SPAN>reparenting</SPAN>.</P></LI></UL></DIV>
<LI>
<P>How do we prevent zombies from taking over the machine?</P>
<DIV class=ulist>
<UL>
<LI>
<P>A processes parent receives the SIGCHLD signal when a child calls <CODE>exit()</CODE>, alerting it to the chance to retrieve the child&#8217;s exit status.</P>
<LI>
<P>On some systems a process can choose to have its children automatically reaped by ignoring this signal.</P>
<LI>
<P>On bash the relevant command is the appropriately-named disown. This allows children to continue running as daemons even after bash exits.</P></LI></UL></DIV></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_what_if_i_don_t_want_to_code_wait_code class=anchor></A>
<H2>What If I Don&#8217;t Want to <CODE>wait()</CODE>?</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>Parent may want to peek at the exit status of its child, just to check on it. (Are you dead yet? Are you dead yet?)</P>
<LI>
<P>Systems support a non-blocking <CODE>wait()</CODE> for this purpose:</P>
<DIV class=ulist>
<UL>
<LI>
<P><STRONG>Blocking <CODE>wait()</CODE></STRONG> will block until the child exits, unless it has already exited in which case it returns immediately.</P>
<LI>
<P><STRONG>Non-Blocking <CODE>wait()</CODE></STRONG> will not block. Instead, its return status indicates if the child has exited and, if so, what the exit code was.</P></LI></UL></DIV></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_our_simple_shell class=anchor></A>
<H2>Our Simple Shell</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>Disclaimer: this is C-like pseudo-code. It will not compile or run! (But it&#8217;s not far off.)</P></LI></UL></DIV>
<DIV class=listingblock>
<DIV class=content><PRE class=highlight><CODE class="language-c lang-c" data-lang="c"><SPAN class=hljs-keyword>while</SPAN> (<SPAN class=hljs-number>1</SPAN>) {
  input = readLine();
  returnCode = fork();
  <SPAN class=hljs-keyword>if</SPAN> (returnCode == <SPAN class=hljs-number>0</SPAN>) {
    exec(input);
  } <SPAN class=hljs-keyword>else</SPAN> {
    wait(returnCode);
  }
}</CODE></PRE></DIV></DIV></DIV></DIV>
<DIV class=sect1><A id=_aside_code_errno_code class=anchor></A>
<H2>Aside: <CODE>errno</CODE></H2>
<DIV class=sectionbody>
<DIV class=ulist>
<DIV class=title>Where&#8217;s <CODE>exit()</CODE>?</DIV>
<UL>
<LI>
<P>There is potential confusion between kernel system calls and wrappers implemented by <CODE>libc</CODE>:</P>
<DIV class=ulist>
<UL>
<LI>
<P><CODE>_exit()</CODE> (system call) v. <CODE>exit()</CODE> (C library function call).</P></LI></UL></DIV>
<LI>
<P>The C library wraps system calls and changes their return codes.</P>
<LI>
<P>The C library is what sets <CODE>errno</CODE>, not the kernel.</P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=__span_class_small_multiplexing_and_abstracting_the_cpu_span class=anchor></A>
<H2><SPAN>Multiplexing and Abstracting the CPU</SPAN></H2>
<DIV class=sectionbody>
<DIV class=paragraph>
<P>For the next several weeks we&#8217;ll be looking at how the operating system manages the processor:</P></DIV>
<DIV class=ulist>
<UL>
<LI>
<P>What are the <STRONG>limitations or problems</STRONG> with the hardware resource that the operating system is trying to address? <EM>There is only one (or at least, no that many) processor(s)!</EM></P>
<LI>
<P>What are the <STRONG>mechanisms</STRONG> necessary to allow the processor to be shared? <EM>Interrupts and context switching.</EM></P>
<LI>
<P><SPAN class=line-through>What are the <STRONG>consequences</STRONG> for programmers of processor multiplexing? <EM>Concurrency and synchronization.</EM></SPAN></P>
<LI>
<P>How do we design good <STRONG>policies</STRONG> ensuring that processor sharing meets the needs of the user? <EM>Processor scheduling.</EM></P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_today_operating_system_privilege class=anchor></A>
<H2>Today: Operating System Privilege</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>Earlier we alluded to the fact that the operating system is <EM>like</EM> a normal program with some special privileges.</P>
<LI>
<P>In fact, implementing most of the process-related system calls we discussed last week <STRONG>does not require these special privileges!</STRONG></P>
<DIV class=ulist>
<UL>
<LI>
<P>If you don&#8217;t believe me, look at user-space threading libraries. They provide functionality very similar to the <CODE>fork()</CODE>, <CODE>exec()</CODE>, <CODE>exit()</CODE> and <CODE>wait()</CODE> system calls we discussed.</P></LI></UL></DIV>
<LI>
<P>So <STRONG>why does the operating system need special privileges?</STRONG></P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_multiplexing_requires_privilege class=anchor></A>
<H2>Multiplexing Requires Privilege</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>In many cases implementing abstractions does not require special privileges.</P>
<LI>
<P>However, the operating systems other task&#8212;multiplexing resources&#8212;<STRONG>does.</STRONG></P></LI></UL></DIV>
<DIV class=ulist>
<UL>
<LI>
<P>In order to divide resources between processes the system needs a trusted and privileged entity that can:</P>
<DIV class=ulist>
<UL>
<LI>
<P><STRONG>divide</STRONG> the resources, and</P>
<LI>
<P><STRONG>enforce</STRONG> the division.</P></LI></UL></DIV></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=__span_class_spelling_exception_no_trusto_processo_span class=anchor></A>
<H2><SPAN>No Trusto Processo</SPAN></H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>Why can&#8217;t processes share resources without a privileged arbiter?</P>
<LI>
<P>Some processes are:</P>
<DIV class=ulist>
<UL>
<LI>
<P>malicious&#8212;"Hey, I&#8217;d like some more memory, so I&#8217;ll use yours!"</P>
<LI>
<P>buggy&#8212;"Um, is this my memory or your memory? I&#8217;m not sure but I&#8217;ll just use it and hope things turn out OK&#8230;&#8203;"</P></LI></UL></DIV></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_privileged_execution class=anchor></A>
<H2>Privileged Execution</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>CPUs implement a mechanism allowing the operating system to manage resources: <STRONG>kernel</STRONG> (or privileged) <STRONG>mode.</STRONG></P>
<LI>
<P>Being in kernel mode may mean that the executing code</P>
<DIV class=ulist>
<UL>
<LI>
<P>has access to <STRONG>special instructions</STRONG>, and</P>
<LI>
<P>has a different <STRONG>view of memory</STRONG>.</P></LI></UL></DIV></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_special_instructions class=anchor></A>
<H2>Special Instructions</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>When the CPU is in <STRONG>kernel mode</STRONG> there are special instructions that can be executed.</P>
<DIV class=ulist>
<UL>
<LI>
<P>These instructions usually modify important global state controlling how resources are shared.</P></LI></UL></DIV>
<LI>
<P>When the CPU is not in kernel mode it does not allow these instructions to be executed.</P>
<DIV class=ulist>
<UL>
<LI>
<P>We will see what happens when an unprivileged process tries to execute a privileged instruction in a minute.</P></LI></UL></DIV></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_protection_boundaries class=anchor></A>
<H2>Protection Boundaries</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>The goal:</P>
<DIV class=ulist>
<UL>
<LI>
<P><STRONG>only trusted kernel code</STRONG> runs in kernel mode;</P>
<LI>
<P>untrusted user code <STRONG>always runs in user mode</STRONG>.</P></LI></UL></DIV>
<LI>
<P>The CPU implements mechanisms to transition between user and kernel mode which we will discuss during the rest of today&#8217;s class.</P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_aside_fine_grained_protection class=anchor></A>
<H2>Aside: Fine-Grained Protection</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>Many modern CPUs implement <STRONG>more than two</STRONG> protection modes.</P>
<LI>
<P>x86 processors actually have four protection "rings" from Ring 0 (most privileged) to Ring 3 (least privileged).</P>
<LI>
<P>For many years operating systems running on x86 architectures only used Ring 0 (kernel mode) and Ring 3 (user mode).</P>
<LI>
<P>Recently this has become more interesting because of operating system virtualization, so we will return to this.</P>
<DIV class=ulist>
<UL>
<LI>
<P>But for now, you can think of processors as having two privilege modes: kernel mode and user mode.</P></LI></UL></DIV></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_terminology class=anchor></A>
<H2>Terminology</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>When we say <EM>"application"</EM> we refer to code running without privileges or in unprivileged or "user" mode.</P>
<LI>
<P>When we say <EM>"kernel"</EM> we mean code running in privileged or kernel mode.</P>
<LI>
<P>What makes the kernel special? <STRONG>It is the one application allowed to executed code in kernel mode!</STRONG></P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_bootstrapping_privilege class=anchor></A>
<H2>Bootstrapping Privilege</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<DIV class=title>Why is the operating system allowed to run in kernel mode?</DIV>
<UL>
<LI>
<P><STRONG>You installed your machine that way!</STRONG> This is what it means to install an operating system: choose a particular application to grant special privileges to.</P></LI></UL></DIV>
<DIV class=ulist>
<UL>
<LI>
<P>On boot the CPU starts out executing the kernel code in privileged mode, which is how <STRONG>privilege is bootstrapped</STRONG>.</P>
<LI>
<P>The kernel is responsible for lowering the privilege level before executing user code.</P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_more_terminology_traps class=anchor></A>
<H2>More Terminology: Traps</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>When a normal application does something that causes the system to enter <STRONG>kernel mode</STRONG> we sometimes refer to this as <EM>trapping</EM> into the kernel.</P>
<LI>
<P>I frequently think about the thread that trapped into the kernel as <STRONG>running in the kernel</STRONG> after the trap occurs.</P>
<DIV class=ulist>
<UL>
<LI>
<P>On some level this is accurate: it is the same stream of instructions.</P>
<LI>
<P>On some level this is not accurate: the kernel thread has its own stack and has saved the state of the trapping user thread, so in a way the user thread has been paused while the kernel performs some task on its behalf.</P></LI></UL></DIV>
<LI>
<P><STRONG>Decide the way to think about this that is the most effective for you.</STRONG></P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_privilege_transitions class=anchor></A>
<H2>Privilege Transitions</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>The transition into the kernel or into privileged mode typically occurs for one of three reasons:</P>
<DIV class=ulist>
<UL>
<LI>
<P>a hardware device requests attention&#8212;<STRONG>hardware interrupt</STRONG></P>
<LI>
<P>software requests attention&#8212;<STRONG>software interrupt</STRONG> or system call</P>
<LI>
<P>software needs attention&#8212;<STRONG>software exception</STRONG></P></LI></UL></DIV>
<LI>
<P>What is the difference between <EM>requesting</EM> and <EM>needing</EM> attention?</P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_hardware_interrupts class=anchor></A>
<H2>Hardware Interrupts</H2>
<DIV class=sectionbody>
<DIV class=ulist>
<UL>
<LI>
<P>Hardware interrupts are used to signal that a particular device needs attention:</P>
<DIV class=ulist>
<UL>
<LI>
<P>a disk read completed, or</P>
<LI>
<P>a network packet was received, or</P>
<LI>
<P>a timer fired.</P></LI></UL></DIV>
<LI>
<P>Processors implement multiple <STRONG>interrupt lines</STRONG>, input wires on which a logic transition (or level) will trigger an interrupt.</P></LI></UL></DIV></DIV></DIV>
<DIV class=sect1><A id=_interrupt_handling class=anchor></A>
<H2>Interrupt Handling</H2>
<DIV class=sectionbody>
<DIV class="olist arabic">
<DIV class=title>When an interrupt is triggered (interrupt request, or IRQ), the processor:</DIV>
<OL class=arabic>
<LI>
<P><STRONG>enters privileged mode</STRONG>,</P>
<LI>
<P><STRONG>records state</STRONG> necessary to process the interrupt,</P>
<LI>
<P><STRONG>jumps to a pre-determined memory location</STRONG> and begins executing instructions.</P></LI></OL></DIV>
<DIV class="openblock slide">
<DIV class=content>
<DIV class=paragraph>
<P>The instructions that the processor executes when an interrupt fires are called the <STRONG>interrupt service routine</STRONG> (ISR).</P></DIV></DIV></DIV></DIV></DIV>