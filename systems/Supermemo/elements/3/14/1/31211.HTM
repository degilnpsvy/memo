In a PE with the Floating-Point Extension, on exception entry:<BR>1. EXC_RETURN.FType is saved as the inverse of CONTROL.FPCA.<BR>2. CONTROL.FPCA is then cleared to 0 if it was 1, or remains unchanged if it was 0.<BR>On exception return, the inverse of EXC_RETURN[4] is written to CONTROL.FPCA.<BR>RCGML In a PE with the Floating-point Extension, when the following conditions are met on exception return, the PE hardware sets S0-S15 and the FPSCR to zero:<BR>&#8226; CONTROL.FPCA is 1.<BR>&#8226; FPCCR.CLRONRET is 1.<BR>&#8226; FPCCR.LSPACT is 0.<BR>If all of these fields are 1 on exception return, the PE generates an LSERR SecureFault instead.<BR>RXNNG In a PE with the Floating-point Extension, when the following conditions are met on exception return, the PE generates an LSERR SecureFault:<BR>&#8226; EXC_RETURN[4] is 0.<BR>&#8226; The stack contains Secure FP context, that would be unstacked on the return. That is, FPCCR_S.LSPACT is 1.<BR>&#8226; The return is to Non-secure state.<BR>RHCXX In a PE with the Floating-point Extension, if the PE abandons unstacking of the floating-point registers to tail-chain into another exception:<BR>&#8226; If the Security Extension is implemented, the PE must clear to zero any floating-point registers that would have been unstacked.<BR>&#8226; If the Security Extension is not implemented, the floating-point registers that would have been unstacked become UNKNOWN.