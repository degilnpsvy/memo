<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title>Background</H2></DIV></DIV></DIV>
<DIV class=toc>
<DL class=toc>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/chapter-intro.html#id-1.3.2.5">Data types and programming</A></SPAN> 
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/ch01s02.html">Exporting a C API</A></SPAN></DT></DL></DIV>
<P>GObject, and its lower-level type system, GType, are used by GTK+ and most GNOME libraries to provide: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>object-oriented C-based APIs and</P>
<LI class=listitem>
<P>automatic transparent API bindings to other compiled or interpreted languages.</P></LI></UL></DIV>
<P></P>
<P>A lot of programmers are used to working with compiled-only or dynamically interpreted-only languages and do not understand the challenges associated with cross-language interoperability. This introduction tries to provide an insight into these challenges and briefly describes the solution chosen by GLib. </P>
<P>The following chapters go into greater detail into how GType and GObject work and how you can use them as a C programmer. It is useful to keep in mind that allowing access to C objects from other interpreted languages was one of the major design goals: this can often explain the sometimes rather convoluted APIs and features present in this library. </P>
<DIV class=sect1>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=id-1.3.2.5></A>Data types and programming</H2></DIV></DIV></DIV>
<P>One could say that a programming language is merely a way to create data types and manipulate them. Most languages provide a number of language-native types and a few primitives to create more complex types based on these primitive types. </P>
<P>In C, the language provides types such as <SPAN class=emphasis><EM>char</EM></SPAN>, <SPAN class=emphasis><EM>long</EM></SPAN>, <SPAN class=emphasis><EM>pointer</EM></SPAN>. During compilation of C code, the compiler maps these language types to the compiler's target architecture machine types. If you are using a C interpreter (assuming one exists), the interpreter (the program which interprets the source code and executes it) maps the language types to the machine types of the target machine at runtime, during the program execution (or just before execution if it uses a Just In Time compiler engine). </P>
<P>Perl and Python are interpreted languages which do not really provide type definitions similar to those used by C. Perl and Python programmers manipulate variables and the type of the variables is decided only upon the first assignment or upon the first use which forces a type on the variable. The interpreter also often provides a lot of automatic conversions from one type to the other. For example, in Perl, a variable which holds an integer can be automatically converted to a string given the required context: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>my $tmp <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=number>10</SPAN><SPAN class="gtkdoc opt">;</SPAN>
print <SPAN class=string>"this is an integer converted to a string:"</SPAN> <SPAN class="gtkdoc opt">.</SPAN> $tmp <SPAN class="gtkdoc opt">.</SPAN> <SPAN class=string>"</SPAN><SPAN class="gtkdoc esc">\n</SPAN><SPAN class=string>"</SPAN><SPAN class="gtkdoc opt">;</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>Of course, it is also often possible to explicitly specify conversions when the default conversions provided by the language are not intuitive. </P></DIV>