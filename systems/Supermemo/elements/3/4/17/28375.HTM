<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both">Signals</H2></DIV></DIV></DIV>
<P>GObject's signals have nothing to do with standard UNIX signals: they connect arbitrary application-specific events with any number of listeners. For example, in GTK+, every user event (keystroke or mouse move) is received from the windowing system and generates a GTK+ event in the form of a signal emission on the widget object instance. </P>
<P>Each signal is registered in the type system together with the type on which it can be emitted: users of the type are said to <SPAN class=emphasis><EM>connect</EM></SPAN> to the signal on a given type instance when they register a closure to be invoked upon the signal emission. Users can also emit the signal by themselves or stop the emission of the signal from within one of the closures connected to the signal. </P>
<P>When a signal is emitted on a given type instance, all the closures connected to this signal on this type instance will be invoked. All the closures connected to such a signal represent callbacks whose signature looks like: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>return_type <SPAN class=function>function_callback</SPAN> <SPAN class="gtkdoc opt">(</SPAN>gpointer instance<SPAN class="gtkdoc opt">,</SPAN> &#8230;<SPAN class="gtkdoc opt">,</SPAN> gpointer user_data<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=signal-registration></A>Signal registration</H3></DIV></DIV></DIV>
<P>To register a new signal on an existing type, we can use any of <CODE class=function><A title=g_signal_newv&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-newv">g_signal_newv</A></CODE>, <CODE class=function><A title=g_signal_new_valist&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-new-valist">g_signal_new_valist</A></CODE> or <CODE class=function><A title=g_signal_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-new">g_signal_new</A></CODE> functions: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>guint <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-newv">g_signal_newv</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">const</SPAN> gchar        <SPAN class="gtkdoc opt">*</SPAN>signal_name<SPAN class="gtkdoc opt">,</SPAN>
                     GType               itype<SPAN class="gtkdoc opt">,</SPAN>
                     GSignalFlags        signal_flags<SPAN class="gtkdoc opt">,</SPAN>
                     GClosure           <SPAN class="gtkdoc opt">*</SPAN>class_closure<SPAN class="gtkdoc opt">,</SPAN>
                     GSignalAccumulator  accumulator<SPAN class="gtkdoc opt">,</SPAN>
                     gpointer            accu_data<SPAN class="gtkdoc opt">,</SPAN>
                     GSignalCMarshaller  c_marshaller<SPAN class="gtkdoc opt">,</SPAN>
                     GType               return_type<SPAN class="gtkdoc opt">,</SPAN>
                     guint               n_params<SPAN class="gtkdoc opt">,</SPAN>
                     GType              <SPAN class="gtkdoc opt">*</SPAN>param_types<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P>The number of parameters to these functions is a bit intimidating but they are relatively simple: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P><EM class=parameter><CODE>signal_name</CODE></EM>: is a string which can be used to uniquely identify a given signal. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>itype</CODE></EM>: is the instance type on which this signal can be emitted. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>signal_flags</CODE></EM>: partly defines the order in which closures which were connected to the signal are invoked. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>class_closure</CODE></EM>: this is the default closure for the signal: if it is not NULL upon the signal emission, it will be invoked upon this emission of the signal. The moment where this closure is invoked compared to other closures connected to that signal depends partly on the signal_flags. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>accumulator</CODE></EM>: this is a function pointer which is invoked after each closure has been invoked. If it returns FALSE, signal emission is stopped. If it returns TRUE, signal emission proceeds normally. It is also used to compute the return value of the signal based on the return value of all the invoked closures. For example, an accumulator could ignore <CODE class=literal>NULL</CODE> returns from closures; or it could build a list of the values returned by the closures. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>accumulator_data</CODE></EM>: this pointer will be passed down to each invocation of the accumulator during emission. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>c_marshaller</CODE></EM>: this is the default C marshaller for any closure which is connected to this signal. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>return_type</CODE></EM>: this is the type of the return value of the signal. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>n_params</CODE></EM>: this is the number of parameters this signal takes. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>param_types</CODE></EM>: this is an array of GTypes which indicate the type of each parameter of the signal. The length of this array is indicated by n_params. </P></LI></UL></DIV>
<P></P>
<P>As you can see from the above definition, a signal is basically a description of the closures which can be connected to this signal and a description of the order in which the closures connected to this signal will be invoked. </P></DIV>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=signal-connection></A>Signal connection</H3></DIV></DIV></DIV>
<P>If you want to connect to a signal with a closure, you have three possibilities: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>You can register a class closure at signal registration: this is a system-wide operation. i.e.: the class closure will be invoked during each emission of a given signal on <SPAN class=emphasis><EM>any</EM></SPAN> of the instances of the type which supports that signal. </P></LI>
<LI class=listitem>
<P>You can use <CODE class=function><A title=g_signal_override_class_closure&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-override-class-closure">g_signal_override_class_closure</A></CODE> which overrides the class closure of a given type. It is possible to call this function only on a derived type of the type on which the signal was registered. This function is of use only to language bindings. </P></LI>
<LI class=listitem>
<P>You can register a closure with the <CODE class=function><A title=g_signal_connect() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect">g_signal_connect</A></CODE> family of functions. This is an instance-specific operation: the closure will be invoked only during emission of a given signal on a given instance. </P></LI></UL></DIV>
<P>It is also possible to connect a different kind of callback on a given signal: emission hooks are invoked whenever a given signal is emitted whatever the instance on which it is emitted. Emission hooks are used for example to get all mouse_clicked emissions in an application to be able to emit the small mouse click sound. Emission hooks are connected with <CODE class=function><A title=g_signal_add_emission_hook&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-add-emission-hook">g_signal_add_emission_hook</A></CODE> and removed with <CODE class=function><A title=g_signal_remove_emission_hook&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-remove-emission-hook">g_signal_remove_emission_hook</A></CODE>. </P></DIV>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=signal-emission></A>Signal emission</H3></DIV></DIV></DIV>
<P>Signal emission is done through the use of the <CODE class=function><A title=g_signal_emit&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-emit">g_signal_emit</A></CODE> family of functions. </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class="gtkdoc kwb">void</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-emitv">g_signal_emitv</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN><SPAN class="gtkdoc kwb">const</SPAN> GValue <SPAN class="gtkdoc opt">*</SPAN>instance_and_params<SPAN class="gtkdoc opt">,</SPAN>
                     guint         signal_id<SPAN class="gtkdoc opt">,</SPAN>
                     GQuark        detail<SPAN class="gtkdoc opt">,</SPAN>
                     GValue       <SPAN class="gtkdoc opt">*</SPAN>return_value<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>The <EM class=parameter><CODE>instance_and_params</CODE></EM> array of GValues contains the list of input parameters to the signal. The first element of the array is the instance pointer on which to invoke the signal. The following elements of the array contain the list of parameters to the signal. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>signal_id</CODE></EM> identifies the signal to invoke. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>detail</CODE></EM> identifies the specific detail of the signal to invoke. A detail is a kind of magic token/argument which is passed around during signal emission and which is used by closures connected to the signal to filter out unwanted signal emissions. In most cases, you can safely set this value to zero. See <A title="The detail argument" class=xref href="https://developer.gnome.org/gobject/stable/signal.html#signal-detail">the section called &#8220;The <SPAN class=emphasis><EM>detail</EM></SPAN> argument&#8221;</A> for more details about this parameter. </P></LI>
<LI class=listitem>
<P><EM class=parameter><CODE>return_value</CODE></EM> holds the return value of the last closure invoked during emission if no accumulator was specified. If an accumulator was specified during signal creation, this accumulator is used to calculate the return value as a function of the return values of all the closures invoked during emission. If no closure is invoked during emission, the <EM class=parameter><CODE>return_value</CODE></EM> is nonetheless initialized to zero/null. </P></LI></UL></DIV>
<P></P>
<P>Signal emission can be decomposed in 5 steps: </P>
<DIV class=orderedlist>
<OL class=orderedlist type=1>
<LI class=listitem>
<P><CODE class=literal>RUN_FIRST</CODE>: if the <A class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#G-SIGNAL-RUN-FIRST:CAPS"><CODE class=literal>G_SIGNAL_RUN_FIRST</CODE></A> flag was used during signal registration and if there exists a class closure for this signal, the class closure is invoked. </P></LI>
<LI class=listitem>
<P><CODE class=literal>EMISSION_HOOK</CODE>: if any emission hook was added to the signal, they are invoked from first to last added. Accumulate return values. </P></LI>
<LI class=listitem>
<P><CODE class=literal>HANDLER_RUN_FIRST</CODE>: if any closure were connected with the <CODE class=function><A title=g_signal_connect() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect">g_signal_connect</A></CODE> family of functions, and if they are not blocked (with the <CODE class=function><A title=g_signal_handler_block&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-handler-block">g_signal_handler_block</A></CODE> family of functions) they are run here, from first to last connected. </P></LI>
<LI class=listitem>
<P><CODE class=literal>RUN_LAST</CODE>: if the <CODE class=literal>G_SIGNAL_RUN_LAST</CODE> flag was set during registration and if a class closure was set, it is invoked here. </P></LI>
<LI class=listitem>
<P><CODE class=literal>HANDLER_RUN_LAST</CODE>: if any closure were connected with the <CODE class=function>g_signal_connect_after</CODE> family of functions, if they were not invoked during <CODE class=literal>HANDLER_RUN_FIRST</CODE> and if they are not blocked, they are run here, from first to last connected. </P></LI>
<LI class=listitem>
<P><CODE class=literal>RUN_CLEANUP</CODE>: if the <CODE class=literal>G_SIGNAL_RUN_CLEANUP</CODE> flag was set during registration and if a class closure was set, it is invoked here. Signal emission is completed here. </P></LI></OL></DIV>
<P></P>
<P>If, at any point during emission (except in <CODE class=literal>RUN_CLEANUP</CODE> state), one of the closures or emission hook stops the signal emission with <CODE class=function><A title=g_signal_stop_emission&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-stop-emission">g_signal_stop_emission</A></CODE>, emission jumps to <CODE class=literal>RUN_CLEANUP</CODE> state. </P>
<P>If, at any point during emission, one of the closures or emission hook emits the same signal on the same instance, emission is restarted from the <CODE class=literal>RUN_FIRST</CODE> state. </P>
<P>The accumulator function is invoked in all states, after invocation of each closure (except in <CODE class=literal>RUN_EMISSION_HOOK</CODE> and <CODE class=literal>RUN_CLEANUP</CODE>). It accumulates the closure return value into the signal return value and returns TRUE or FALSE. If, at any point, it does not return TRUE, emission jumps to <CODE class=literal>RUN_CLEANUP</CODE> state. </P>
<P>If no accumulator function was provided, the value returned by the last handler run will be returned by <CODE class=function><A title=g_signal_emit&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-emit">g_signal_emit</A></CODE>. </P></DIV>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=signal-detail></A>The <SPAN class=emphasis><EM>detail</EM></SPAN> argument</H3></DIV></DIV></DIV>
<P>All the functions related to signal emission or signal connection have a parameter named the <SPAN class=emphasis><EM>detail</EM></SPAN>. Sometimes, this parameter is hidden by the API but it is always there, in one form or another. </P>
<P>Of the three main connection functions, only one has an explicit detail parameter as a <A href="https://developer.gnome.org/gobject/glib-Quarks.html#GQuark"><SPAN class=type>GQuark</SPAN></A>: <A title=g_signal_connect_closure_by_id&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect-closure-by-id"><CODE class=function>g_signal_connect_closure_by_id</CODE></A>. <A class=footnote href="https://developer.gnome.org/gobject/stable/signal.html#ftn.id-1.3.5.3.8.3.3" name=id-1.3.5.3.8.3.3><SUP class=footnote>[6]</SUP></A> </P>
<P>The two other functions, <A title=g_signal_connect_closure&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect-closure"><CODE class=function>g_signal_connect_closure</CODE></A> and <A title=g_signal_connect_data&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect-data"><CODE class=function>g_signal_connect_data</CODE></A> hide the detail parameter in the signal name identification. Their <EM class=parameter><CODE>detailed_signal</CODE></EM> parameter is a string which identifies the name of the signal to connect to. The format of this string should match <SPAN class=emphasis><EM>signal_name::detail_name</EM></SPAN>. For example, connecting to the signal named <SPAN class=emphasis><EM>notify::cursor_position</EM></SPAN> will actually connect to the signal named <SPAN class=emphasis><EM>notify</EM></SPAN> with the <SPAN class=emphasis><EM>cursor_position</EM></SPAN> detail. Internally, the detail string is transformed to a GQuark if it is present. </P>
<P>Of the four main signal emission functions, one hides it in its signal name parameter: <A title=g_signal_connect() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect"><CODE class=function>g_signal_connect</CODE></A>. The other three have an explicit detail parameter as a <A href="https://developer.gnome.org/gobject/glib-Quarks.html#GQuark"><SPAN class=type>GQuark</SPAN></A> again: <A title=g_signal_emit&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-emit"><CODE class=function>g_signal_emit</CODE></A>, <A title=g_signal_emitv&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-emitv"><CODE class=function>g_signal_emitv</CODE></A> and <A title=g_signal_emit_valist&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-emit-valist"><CODE class=function>g_signal_emit_valist</CODE></A>. </P>
<P>If a detail is provided by the user to the emission function, it is used during emission to match against the closures which also provide a detail. If a closure's detail does not match the detail provided by the user, it will not be invoked (even though it is connected to a signal which is being emitted). </P>
<P>This completely optional filtering mechanism is mainly used as an optimization for signals which are often emitted for many different reasons: the clients can filter out which events they are interested in before the closure's marshalling code runs. For example, this is used extensively by the <A title="The &#8220;notify&#8221; signal" class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#GObject-notify"><EM class=structfield><CODE>notify</CODE></EM></A> signal of GObject: whenever a property is modified on a GObject, instead of just emitting the <SPAN class=emphasis><EM>notify</EM></SPAN> signal, GObject associates as a detail to this signal emission the name of the property modified. This allows clients who wish to be notified of changes to only one property to filter most events before receiving them. </P>
<P>As a simple rule, users can and should set the detail parameter to zero: this will disable completely this optional filtering for that signal. </P></DIV>
<DIV class=footnotes><BR>
<HR style="WIDTH: 100px; TEXT-ALIGN: left; MARGIN-LEFT: 0px">

<DIV id=ftn.id-1.3.5.3.8.3.3 class=footnote>
<P><A class=para href="https://developer.gnome.org/gobject/stable/signal.html#id-1.3.5.3.8.3.3"><SUP class=para>[6] </SUP></A>A GQuark is an integer which uniquely represents a string. It is possible to transform back and forth between the integer and string representations with the functions <CODE class=function><A href="https://developer.gnome.org/gobject/glib-Quarks.html#g-quark-from-string">g_quark_from_string</A></CODE> and <CODE class=function><A href="https://developer.gnome.org/gobject/glib-Quarks.html#g-quark-to-string">g_quark_to_string</A></CODE>. </P></DIV></DIV>