<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both">Object memory management</H2></DIV></DIV></DIV>
<P>The memory-management API for GObjects is a bit complicated but the idea behind it is pretty simple: the goal is to provide a flexible model based on reference counting which can be integrated in applications which use or require different memory management models (such as garbage collection). The methods which are used to manipulate this reference count are described below. </P>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=gobject-memory-refcount></A>Reference count</H3></DIV></DIV></DIV>
<P>The functions <CODE class=function><A title=g_object_ref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-ref">g_object_ref</A></CODE>/<CODE class=function><A title=g_object_unref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref">g_object_unref</A></CODE> respectively increase and decrease the reference count. These functions are thread-safe. <CODE class=function><A title=g_clear_object&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-clear-object">g_clear_object</A></CODE> is a convenience wrapper around <CODE class=function>g_object_unref</CODE> which also clears the pointer passed to it. </P>
<P>The reference count is initialized to one by <CODE class=function><A title=g_object_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new">g_object_new</A></CODE> which means that the caller is currently the sole owner of the newly-created reference. When the reference count reaches zero, that is, when <CODE class=function><A title=g_object_unref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref">g_object_unref</A></CODE> is called by the last client holding a reference to the object, the <SPAN class=emphasis><EM>dispose</EM></SPAN> and the <SPAN class=emphasis><EM>finalize</EM></SPAN> class methods are invoked. </P>
<P>Finally, after <SPAN class=emphasis><EM>finalize</EM></SPAN> is invoked, <CODE class=function><A title=g_type_free_instance&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Type-Information.html#g-type-free-instance">g_type_free_instance</A></CODE> is called to free the object instance. Depending on the memory allocation policy decided when the type was registered (through one of the <CODE class=function>g_type_register_*</CODE> functions), the object's instance memory will be freed or returned to the object pool for this type. Once the object has been freed, if it was the last instance of the type, the type's class will be destroyed as described in <A title="Instantiable classed types: objects" class=xref href="https://developer.gnome.org/gobject/stable/gtype-instantiable-classed.html">the section called &#8220;Instantiable classed types: objects&#8221;</A> and <A title="Non-instantiable classed types: interfaces" class=xref href="https://developer.gnome.org/gobject/stable/gtype-non-instantiable-classed.html">the section called &#8220;Non-instantiable classed types: interfaces&#8221;</A>. </P>
<P>The table below summarizes the destruction process of a GObject: </P>
<DIV class=table><A name=gobject-destruction-table></A>
<P class=title><B>Table&nbsp;5.&nbsp;<CODE class=function><A title=g_object_unref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref">g_object_unref</A></CODE></B></P>
<DIV class=table-contents>
<TABLE class=table summary=g_object_unref border=1>
<COLGROUP>
<COL align=left>
<COL align=left>
<COL align=left></COLGROUP>
<THEAD>
<TR>
<TH align=left>Invocation time</TH>
<TH align=left>Function invoked</TH>
<TH align=left>Function's parameters</TH>
<TH>Remark</TH></TR></THEAD>
<TBODY>
<TR>
<TD rowSpan=2 align=left>Last call to <CODE class=function><A title=g_object_unref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref">g_object_unref</A></CODE> for an instance of target type </TD>
<TD align=left>target type's dispose class function</TD>
<TD align=left>GObject instance</TD>
<TD>When dispose ends, the object should not hold any reference to any other member object. The object is also expected to be able to answer client method invocations (with possibly an error code but no memory violation) until finalize is executed. dispose can be executed more than once. dispose should chain up to its parent implementation just before returning to the caller. </TD></TR>
<TR>
<TD align=left>target type's finalize class function</TD>
<TD align=left>GObject instance</TD>
<TD>Finalize is expected to complete the destruction process initiated by dispose. It should complete the object's destruction. finalize will be executed only once. finalize should chain up to its parent implementation just before returning to the caller. The reason why the destruction process is split is two different phases is explained in <A title="Reference counts and cycles" class=xref href="https://developer.gnome.org/gobject/stable/gobject-memory.html#gobject-memory-cycles">the section called &#8220;Reference counts and cycles&#8221;</A>. </TD></TR>
<TR>
<TD rowSpan=4 align=left>Last call to <CODE class=function><A title=g_object_unref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref">g_object_unref</A></CODE> for the last instance of target type </TD>
<TD align=left>interface's <CODE class=function>interface_finalize</CODE> function</TD>
<TD align=left>On interface's vtable</TD>
<TD>Never used in practice. Unlikely you will need it.</TD></TR>
<TR>
<TD align=left>interface's <CODE class=function>base_finalize</CODE> function</TD>
<TD align=left>On interface's vtable</TD>
<TD>Never used in practice. Unlikely you will need it.</TD></TR>
<TR>
<TD align=left>target type's <CODE class=function>class_finalize</CODE> function</TD>
<TD align=left>On target type's class structure</TD>
<TD>Never used in practice. Unlikely you will need it.</TD></TR>
<TR>
<TD align=left>type's <CODE class=function>base_finalize</CODE> function</TD>
<TD align=left>On the inheritance tree of classes from fundamental type to target type. <CODE class=function>base_init</CODE> is invoked once for each class structure.</TD>
<TD>Never used in practice. Unlikely you will need it.</TD></TR></TBODY></TABLE></DIV></DIV>
<P><BR class=table-break></P></DIV>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=gobject-memory-weakref></A>Weak References</H3></DIV></DIV></DIV>
<P>Weak references are used to monitor object finalization: <CODE class=function><A title=g_object_weak_ref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-weak-ref">g_object_weak_ref</A></CODE> adds a monitoring callback which does not hold a reference to the object but which is invoked when the object runs its dispose method. As such, each weak ref can be invoked more than once upon object finalization (since dispose can run more than once during object finalization). </P>
<P><CODE class=function><A title=g_object_weak_unref&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-weak-unref">g_object_weak_unref</A></CODE> can be used to remove a monitoring callback from the object. </P>
<P>Weak references are also used to implement <CODE class=function><A title=g_object_add_weak_pointer&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-add-weak-pointer">g_object_add_weak_pointer</A></CODE> and <CODE class=function><A title=g_object_remove_weak_pointer&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-remove-weak-pointer">g_object_remove_weak_pointer</A></CODE>. These functions add a weak reference to the object they are applied to which makes sure to nullify the pointer given by the user when object is finalized. </P>
<P>Similarly, <A title=GWeakRef class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#GWeakRef"><SPAN class=type>GWeakRef</SPAN></A> can be used to implement weak references if thread safety is required. </P></DIV>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=gobject-memory-cycles></A>Reference counts and cycles</H3></DIV></DIV></DIV>
<P>GObject's memory management model was designed to be easily integrated in existing code using garbage collection. This is why the destruction process is split in two phases: the first phase, executed in the dispose handler is supposed to release all references to other member objects. The second phase, executed by the finalize handler is supposed to complete the object's destruction process. Object methods should be able to run without program error in-between the two phases. </P>
<P>This two-step destruction process is very useful to break reference counting cycles. While the detection of the cycles is up to the external code, once the cycles have been detected, the external code can invoke <CODE class=function><A title=g_object_run_dispose&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-run-dispose">g_object_run_dispose</A></CODE> which will indeed break any existing cycles since it will run the dispose handler associated to the object and thus release all references to other objects. </P>
<P>This explains one of the rules about the dispose handler stated earlier: the dispose handler can be invoked multiple times. Let's say we have a reference count cycle: object A references B which itself references object A. Let's say we have detected the cycle and we want to destroy the two objects. One way to do this would be to invoke <CODE class=function><A title=g_object_run_dispose&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-run-dispose">g_object_run_dispose</A></CODE> on one of the objects. </P>
<P>If object A releases all its references to all objects, this means it releases its reference to object B. If object B was not owned by anyone else, this is its last reference count which means this last unref runs B's dispose handler which, in turn, releases B's reference on object A. If this is A's last reference count, this last unref runs A's dispose handler which is running for the second time before A's finalize handler is invoked ! </P>
<P>The above example, which might seem a bit contrived, can really happen if GObjects are being handled by language bindings &#8212; hence the rules for object destruction should be closely followed. </P></DIV>