D1.2.81 FPCCR, Floating-Point Context Control Register</P>
<P>The FPCCR characteristics are:<BR>Purpose: Holds control data for the Floating-point extension.<BR>Usage constraints: Privileged access permitted only. Unprivileged accesses generate a BusFault.<BR>&nbsp; This register is word accessible only. Halfword and byte accesses are UNPREDICTABLE.<BR>Configurations: Present only if the Floating-point Extension is implemented.<BR>&nbsp; This register is RES0 if the Floating-point Extension is not implemented.<BR>Attributes: 32-bit read/write register located at 0xE000EF34.<BR>&nbsp; Secure software can access the Non-secure view of this register via FPCCR_NS located at 0xE002EF34. The location 0xE002EF34 is RES0 to software executing in Non-secure state and the debugger.<BR>&nbsp; This register is banked between Security states on a bit by bit basis.</P>
<P>The FPCCR bit assignments are:</P>
<P>ASPEN, bit [31]<BR>Automatic state preservation enable. When this bit is set to 1, execution of a floating-point instruction sets the CONTROL.FPCA bit to 1.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 Executing a floating-point instruction has no effect on CONTROL.FPCA.<BR>1 Executing a floating-point instruction sets CONTROL.FPCA to 1.<BR>This bit resets to one on a Warm reset.<BR>Note<BR>Setting this bit to 1 means the hardware automatically preserves floating-point context on exception entry and restores it on exception return.</P>
<P>LSPEN, bit [30]<BR>Lazy state preservation enable. Enables lazy context save of floating-point state.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 Disable automatic lazy context save.<BR>1 Enable automatic lazy context save.<BR>Writes to this bit from Non-secure state are ignored if LSPENS is set to one.<BR>This bit resets to one on a Warm reset.</P>
<P>LSPENS, bit [29]<BR>Lazy state preservation enable Secure only. This bit controls whether the LSPEN bit is writeable from the Non-secure state.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 LSPEN is readable and writeable from both Security states.<BR>1 LSPEN is readable from both Security states, but writes to LSPEN are ignored from the<BR>Non-secure state.<BR>This bit is RAZ/WI from Non-secure state.<BR>This bit resets to zero on a Warm reset.</P>
<P>CLRONRET, bit [28]<BR>Clear on return. Clear floating-point caller saved registers on exception return.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 Disabled.<BR>1 Enabled.<BR>When set to 1 the caller saved floating-point registers S0 to S15, and FPSCR are cleared on exception return (including tail chaining) if CONTROL.FPCA is set to 1 and FPCCR_S.LSPACT is set to 0.<BR>This bit resets to zero on a Warm reset.</P>
<P>CLRONRETS, bit [27]<BR>Clear on return Secure only. This bit controls whether the CLRONRET bit is writeable from the Non-secure state.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 The CLRONRET field is accessibly from both Security states.<BR>1 The Non-secure view of the CLRONRET field is read-only.<BR>This bit is RAZ/WI from Non-secure state.<BR>This bit resets to zero on a Warm reset.</P>
<P>TS, bit [26]<BR>Treat as Secure. Treat floating-point registers as Secure enable.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 Disabled.<BR>1 Enabled.<BR>When set to 0 the floating-point registers are treated as Non-secure even when the PE is in the Secure state and, therefore, the callee saved registers are never pushed to the stack. If the floating-point registers never contain data that needs to be protected, clearing this flag can reduce interrupt latency. This field behaves as RAZ/WI from the Non-secure state.<BR>This bit is RAZ/WI from Non-secure state.<BR>This bit resets to zero on a Warm reset.</P>
<P>Bits [25:11]<BR>Reserved, RES0.</P>
<P>UFRDY, bit [10]<BR>UsageFault ready. Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the UsageFault exception to pending.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 Not able to set the UsageFault exception to pending.<BR>1 Able to set the UsageFault exception to pending.<BR>This bit resets to an UNKNOWN value on a Warm reset.</P>
<P>SPLIMVIOL, bit [9]<BR>Stack pointer limit violation. This bit is banked between the Security states and indicates whether the floating-point context violates the stack pointer limit that was active when lazy state preservation was activated. SPLIMVIOL modifies the lazy floating-point state preservation behavior.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 The existing behavior is retained.<BR>1 The memory accesses associated with the floating-point state preservation are not performed. However if the floating-point state is secure and FPCCR.TS is set to 1 the registers are still zeroed and the floating-point state is lost.<BR>This bit resets to an UNKNOWN value on a Warm reset.</P>
<P>MONRDY, bit [8]<BR>DebugMonitor ready. Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the DebugMonitor exception to pending.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 Not able to set the DebugMonitor exception to pending.<BR>1 Able to set the DebugMonitor exception to pending.<BR>If DEMCR.SDME is one this bit is RAZ/WI from Non-secure state<BR>This bit resets to an UNKNOWN value on a Warm reset.</P>
<P>SFRDY, bit [7]<BR>SecureFault ready. Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the SecureFault exception to pending. This bit is only present in the Secure version of the register, and behaves as RAZ/WI when accessed from the Non-secure state.<BR>This bit is not banked between Security states.<BR>This bit is RAZ/WI from Non-secure state.<BR>This bit resets to an UNKNOWN value on a Warm reset.</P>
<P>BFRDY, bit [6]<BR>BusFault ready. Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the BusFault exception to pending.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 Not able to set the BusFault exception to pending.<BR>1 Able to set the BusFault exception to pending.<BR>If AIRCR.BFHFNMINS is zero this bit is RAZ/WI from Non-secure state.<BR>This bit resets to an UNKNOWN value on a Warm reset.</P>
<P>MMRDY, bit [5]<BR>MemManage ready. Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the MemManage exception to pending.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 Not able to set the MemManage exception to pending.<BR>1 Able to set the MemManage exception to pending.<BR>This bit resets to an UNKNOWN value on a Warm reset.</P>
<P>HFRDY, bit [4]<BR>HardFault ready. Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the HardFault exception to pending.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 Not able to set the HardFault exception to pending.<BR>1 Able to set the HardFault exception to pending.<BR>If AIRCR.BFHFNMINS is zero this bit is RAZ/WI from Non-secure state.<BR>This bit resets to an UNKNOWN value on a Warm reset.</P>
<P>THREAD, bit [3]<BR>Thread mode. Indicates the PE mode when it allocated the floating-point stack frame.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 Handler mode.<BR>1 Thread mode.<BR>This bit is for fault handler information only and does not interact with the exception model.<BR>This bit resets to an UNKNOWN value on a Warm reset.</P>
<P>S, bit [2]<BR>Security. Security status of the floating-point context. This bit is only present in the Secure version of the register, and behaves as RAZ/WI when accessed from the Non-secure state. This bit is updated whenever lazy state preservation is activated, or when a floating-point instruction is executed.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 Indicates the floating-point context belongs to the Non-secure state.<BR>1 Indicates the floating-point context belongs to the Secure state.<BR>This bit is RAZ/WI from Non-secure state.<BR>This bit resets to one on a Warm reset.</P>
<P>USER, bit [1]<BR>User privilege. Indicates the privilege level of the software executing when the PE allocated the floating-point stack frame.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 Privileged.<BR>1 Unprivileged.<BR>This bit resets to an UNKNOWN value on a Warm reset.</P>
<P>LSPACT, bit [0]<BR>Lazy state preservation active. Indicates whether lazy preservation of the floating-point state is active.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 Lazy state preservation is not active.<BR>1 Lazy state preservation is active.<BR>This bit resets to zero on a Warm reset.