# qemu:memory_ldst.inc.c
<P></P>
<P>/*<BR>&nbsp;*&nbsp; Physical memory access templates<BR>&nbsp;*<BR>&nbsp;*&nbsp; Copyright (c) 2003 Fabrice Bellard<BR>&nbsp;*&nbsp; Copyright (c) 2015 Linaro, Inc.<BR>&nbsp;*&nbsp; Copyright (c) 2016 Red Hat, Inc.<BR>&nbsp;*<BR>&nbsp;* This library is free software; you can redistribute it and/or<BR>&nbsp;* modify it under the terms of the GNU Lesser General Public<BR>&nbsp;* License as published by the Free Software Foundation; either<BR>&nbsp;* version 2 of the License, or (at your option) any later version.<BR>&nbsp;*<BR>&nbsp;* This library is distributed in the hope that it will be useful,<BR>&nbsp;* but WITHOUT ANY WARRANTY; without even the implied warranty of<BR>&nbsp;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp; See the GNU<BR>&nbsp;* Lesser General Public License for more details.<BR>&nbsp;*<BR>&nbsp;* You should have received a copy of the GNU Lesser General Public<BR>&nbsp;* License along with this library; if not, see &lt;<A href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.<BR>&nbsp;*/</P>
<P></P>
<P>/* warning: addr must be aligned */<BR>static inline uint32_t glue(address_space_ldl_internal, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs attrs, MemTxResult *result,<BR>&nbsp;&nbsp;&nbsp; enum device_endian endian)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t *ptr;<BR>&nbsp;&nbsp;&nbsp; uint64_t val;<BR>&nbsp;&nbsp;&nbsp; MemoryRegion *mr;<BR>&nbsp;&nbsp;&nbsp; hwaddr l = 4;<BR>&nbsp;&nbsp;&nbsp; hwaddr addr1;<BR>&nbsp;&nbsp;&nbsp; MemTxResult r;<BR>&nbsp;&nbsp;&nbsp; bool release_lock = false;</P>
<P>&nbsp;&nbsp;&nbsp; RCU_READ_LOCK();<BR>&nbsp;&nbsp;&nbsp; mr = TRANSLATE(addr, &amp;addr1, &amp;l, false);<BR>&nbsp;&nbsp;&nbsp; if (l &lt; 4 || !IS_DIRECT(mr, false)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release_lock |= prepare_mmio_access(mr);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* I/O case */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = memory_region_dispatch_read(mr, addr1, &amp;val, 4, attrs);<BR>#if defined(TARGET_WORDS_BIGENDIAN)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (endian == DEVICE_LITTLE_ENDIAN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = bswap32(val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (endian == DEVICE_BIG_ENDIAN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = bswap32(val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* RAM case */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = MAP_RAM(mr, addr1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (endian) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DEVICE_LITTLE_ENDIAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = ldl_le_p(ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DEVICE_BIG_ENDIAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = ldl_be_p(ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = ldl_p(ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = MEMTX_OK;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (result) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = r;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (release_lock) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_unlock_iothread();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; RCU_READ_UNLOCK();<BR>&nbsp;&nbsp;&nbsp; return val;<BR>}</P>
<P>uint32_t glue(address_space_ldl, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_ldl_internal, SUFFIX)(ARG1, addr, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_NATIVE_ENDIAN);<BR>}</P>
<P>uint32_t glue(address_space_ldl_le, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_ldl_internal, SUFFIX)(ARG1, addr, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_LITTLE_ENDIAN);<BR>}</P>
<P>uint32_t glue(address_space_ldl_be, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_ldl_internal, SUFFIX)(ARG1, addr, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_BIG_ENDIAN);<BR>}</P>
<P>uint32_t glue(ldl_phys, SUFFIX)(ARG1_DECL, hwaddr addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_ldl, SUFFIX)(ARG1, addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>uint32_t glue(ldl_le_phys, SUFFIX)(ARG1_DECL, hwaddr addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_ldl_le, SUFFIX)(ARG1, addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>uint32_t glue(ldl_be_phys, SUFFIX)(ARG1_DECL, hwaddr addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_ldl_be, SUFFIX)(ARG1, addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>/* warning: addr must be aligned */<BR>static inline uint64_t glue(address_space_ldq_internal, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs attrs, MemTxResult *result,<BR>&nbsp;&nbsp;&nbsp; enum device_endian endian)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t *ptr;<BR>&nbsp;&nbsp;&nbsp; uint64_t val;<BR>&nbsp;&nbsp;&nbsp; MemoryRegion *mr;<BR>&nbsp;&nbsp;&nbsp; hwaddr l = 8;<BR>&nbsp;&nbsp;&nbsp; hwaddr addr1;<BR>&nbsp;&nbsp;&nbsp; MemTxResult r;<BR>&nbsp;&nbsp;&nbsp; bool release_lock = false;</P>
<P>&nbsp;&nbsp;&nbsp; RCU_READ_LOCK();<BR>&nbsp;&nbsp;&nbsp; mr = TRANSLATE(addr, &amp;addr1, &amp;l, false);<BR>&nbsp;&nbsp;&nbsp; if (l &lt; 8 || !IS_DIRECT(mr, false)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release_lock |= prepare_mmio_access(mr);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* I/O case */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = memory_region_dispatch_read(mr, addr1, &amp;val, 8, attrs);<BR>#if defined(TARGET_WORDS_BIGENDIAN)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (endian == DEVICE_LITTLE_ENDIAN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = bswap64(val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (endian == DEVICE_BIG_ENDIAN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = bswap64(val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* RAM case */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = MAP_RAM(mr, addr1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (endian) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DEVICE_LITTLE_ENDIAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = ldq_le_p(ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DEVICE_BIG_ENDIAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = ldq_be_p(ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = ldq_p(ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = MEMTX_OK;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (result) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = r;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (release_lock) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_unlock_iothread();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; RCU_READ_UNLOCK();<BR>&nbsp;&nbsp;&nbsp; return val;<BR>}</P>
<P>uint64_t glue(address_space_ldq, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_ldq_internal, SUFFIX)(ARG1, addr, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_NATIVE_ENDIAN);<BR>}</P>
<P>uint64_t glue(address_space_ldq_le, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_ldq_internal, SUFFIX)(ARG1, addr, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_LITTLE_ENDIAN);<BR>}</P>
<P>uint64_t glue(address_space_ldq_be, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_ldq_internal, SUFFIX)(ARG1, addr, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_BIG_ENDIAN);<BR>}</P>
<P>uint64_t glue(ldq_phys, SUFFIX)(ARG1_DECL, hwaddr addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_ldq, SUFFIX)(ARG1, addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>uint64_t glue(ldq_le_phys, SUFFIX)(ARG1_DECL, hwaddr addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_ldq_le, SUFFIX)(ARG1, addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>uint64_t glue(ldq_be_phys, SUFFIX)(ARG1_DECL, hwaddr addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_ldq_be, SUFFIX)(ARG1, addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>uint32_t glue(address_space_ldub, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t *ptr;<BR>&nbsp;&nbsp;&nbsp; uint64_t val;<BR>&nbsp;&nbsp;&nbsp; MemoryRegion *mr;<BR>&nbsp;&nbsp;&nbsp; hwaddr l = 1;<BR>&nbsp;&nbsp;&nbsp; hwaddr addr1;<BR>&nbsp;&nbsp;&nbsp; MemTxResult r;<BR>&nbsp;&nbsp;&nbsp; bool release_lock = false;</P>
<P>&nbsp;&nbsp;&nbsp; RCU_READ_LOCK();<BR>&nbsp;&nbsp;&nbsp; mr = TRANSLATE(addr, &amp;addr1, &amp;l, false);<BR>&nbsp;&nbsp;&nbsp; if (!IS_DIRECT(mr, false)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release_lock |= prepare_mmio_access(mr);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* I/O case */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = memory_region_dispatch_read(mr, addr1, &amp;val, 1, attrs);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* RAM case */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = MAP_RAM(mr, addr1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = ldub_p(ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = MEMTX_OK;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (result) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = r;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (release_lock) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_unlock_iothread();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; RCU_READ_UNLOCK();<BR>&nbsp;&nbsp;&nbsp; return val;<BR>}</P>
<P>uint32_t glue(ldub_phys, SUFFIX)(ARG1_DECL, hwaddr addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_ldub, SUFFIX)(ARG1, addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>/* warning: addr must be aligned */<BR>static inline uint32_t glue(address_space_lduw_internal, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs attrs, MemTxResult *result,<BR>&nbsp;&nbsp;&nbsp; enum device_endian endian)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t *ptr;<BR>&nbsp;&nbsp;&nbsp; uint64_t val;<BR>&nbsp;&nbsp;&nbsp; MemoryRegion *mr;<BR>&nbsp;&nbsp;&nbsp; hwaddr l = 2;<BR>&nbsp;&nbsp;&nbsp; hwaddr addr1;<BR>&nbsp;&nbsp;&nbsp; MemTxResult r;<BR>&nbsp;&nbsp;&nbsp; bool release_lock = false;</P>
<P>&nbsp;&nbsp;&nbsp; RCU_READ_LOCK();<BR>&nbsp;&nbsp;&nbsp; mr = TRANSLATE(addr, &amp;addr1, &amp;l, false);<BR>&nbsp;&nbsp;&nbsp; if (l &lt; 2 || !IS_DIRECT(mr, false)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release_lock |= prepare_mmio_access(mr);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* I/O case */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = memory_region_dispatch_read(mr, addr1, &amp;val, 2, attrs);<BR>#if defined(TARGET_WORDS_BIGENDIAN)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (endian == DEVICE_LITTLE_ENDIAN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = bswap16(val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (endian == DEVICE_BIG_ENDIAN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = bswap16(val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* RAM case */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = MAP_RAM(mr, addr1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (endian) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DEVICE_LITTLE_ENDIAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = lduw_le_p(ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DEVICE_BIG_ENDIAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = lduw_be_p(ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = lduw_p(ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = MEMTX_OK;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (result) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = r;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (release_lock) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_unlock_iothread();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; RCU_READ_UNLOCK();<BR>&nbsp;&nbsp;&nbsp; return val;<BR>}</P>
<P>uint32_t glue(address_space_lduw, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_lduw_internal, SUFFIX)(ARG1, addr, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_NATIVE_ENDIAN);<BR>}</P>
<P>uint32_t glue(address_space_lduw_le, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_lduw_internal, SUFFIX)(ARG1, addr, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_LITTLE_ENDIAN);<BR>}</P>
<P>uint32_t glue(address_space_lduw_be, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_lduw_internal, SUFFIX)(ARG1, addr, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_BIG_ENDIAN);<BR>}</P>
<P>uint32_t glue(lduw_phys, SUFFIX)(ARG1_DECL, hwaddr addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_lduw, SUFFIX)(ARG1, addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>uint32_t glue(lduw_le_phys, SUFFIX)(ARG1_DECL, hwaddr addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_lduw_le, SUFFIX)(ARG1, addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>uint32_t glue(lduw_be_phys, SUFFIX)(ARG1_DECL, hwaddr addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return glue(address_space_lduw_be, SUFFIX)(ARG1, addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>/* warning: addr must be aligned. The ram page is not masked as dirty<BR>&nbsp;&nbsp; and the code inside is not invalidated. It is useful if the dirty<BR>&nbsp;&nbsp; bits are used to track modified PTEs */<BR>void glue(address_space_stl_notdirty, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t *ptr;<BR>&nbsp;&nbsp;&nbsp; MemoryRegion *mr;<BR>&nbsp;&nbsp;&nbsp; hwaddr l = 4;<BR>&nbsp;&nbsp;&nbsp; hwaddr addr1;<BR>&nbsp;&nbsp;&nbsp; MemTxResult r;<BR>&nbsp;&nbsp;&nbsp; uint8_t dirty_log_mask;<BR>&nbsp;&nbsp;&nbsp; bool release_lock = false;</P>
<P>&nbsp;&nbsp;&nbsp; RCU_READ_LOCK();<BR>&nbsp;&nbsp;&nbsp; mr = TRANSLATE(addr, &amp;addr1, &amp;l, true);<BR>&nbsp;&nbsp;&nbsp; if (l &lt; 4 || !IS_DIRECT(mr, true)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release_lock |= prepare_mmio_access(mr);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = memory_region_dispatch_write(mr, addr1, val, 4, attrs);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = MAP_RAM(mr, addr1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stl_p(ptr, val);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dirty_log_mask = memory_region_get_dirty_log_mask(mr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dirty_log_mask &amp;= ~(1 &lt;&lt; DIRTY_MEMORY_CODE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_physical_memory_set_dirty_range(memory_region_get_ram_addr(mr) + addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4, dirty_log_mask);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = MEMTX_OK;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (result) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = r;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (release_lock) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_unlock_iothread();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; RCU_READ_UNLOCK();<BR>}</P>
<P>void glue(stl_phys_notdirty, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stl_notdirty, SUFFIX)(ARG1, addr, val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>/* warning: addr must be aligned */<BR>static inline void glue(address_space_stl_internal, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint32_t val, MemTxAttrs attrs,<BR>&nbsp;&nbsp;&nbsp; MemTxResult *result, enum device_endian endian)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t *ptr;<BR>&nbsp;&nbsp;&nbsp; MemoryRegion *mr;<BR>&nbsp;&nbsp;&nbsp; hwaddr l = 4;<BR>&nbsp;&nbsp;&nbsp; hwaddr addr1;<BR>&nbsp;&nbsp;&nbsp; MemTxResult r;<BR>&nbsp;&nbsp;&nbsp; bool release_lock = false;</P>
<P>&nbsp;&nbsp;&nbsp; RCU_READ_LOCK();<BR>&nbsp;&nbsp;&nbsp; mr = TRANSLATE(addr, &amp;addr1, &amp;l, true);<BR>&nbsp;&nbsp;&nbsp; if (l &lt; 4 || !IS_DIRECT(mr, true)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release_lock |= prepare_mmio_access(mr);</P>
<P>#if defined(TARGET_WORDS_BIGENDIAN)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (endian == DEVICE_LITTLE_ENDIAN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = bswap32(val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (endian == DEVICE_BIG_ENDIAN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = bswap32(val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = memory_region_dispatch_write(mr, addr1, val, 4, attrs);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* RAM case */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = MAP_RAM(mr, addr1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (endian) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DEVICE_LITTLE_ENDIAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stl_le_p(ptr, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DEVICE_BIG_ENDIAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stl_be_p(ptr, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stl_p(ptr, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INVALIDATE(mr, addr1, 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = MEMTX_OK;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (result) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = r;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (release_lock) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_unlock_iothread();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; RCU_READ_UNLOCK();<BR>}</P>
<P>void glue(address_space_stl, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stl_internal, SUFFIX)(ARG1, addr, val, attrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result, DEVICE_NATIVE_ENDIAN);<BR>}</P>
<P>void glue(address_space_stl_le, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stl_internal, SUFFIX)(ARG1, addr, val, attrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result, DEVICE_LITTLE_ENDIAN);<BR>}</P>
<P>void glue(address_space_stl_be, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stl_internal, SUFFIX)(ARG1, addr, val, attrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result, DEVICE_BIG_ENDIAN);<BR>}</P>
<P>void glue(stl_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stl, SUFFIX)(ARG1, addr, val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>void glue(stl_le_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stl_le, SUFFIX)(ARG1, addr, val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>void glue(stl_be_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stl_be, SUFFIX)(ARG1, addr, val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>void glue(address_space_stb, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t *ptr;<BR>&nbsp;&nbsp;&nbsp; MemoryRegion *mr;<BR>&nbsp;&nbsp;&nbsp; hwaddr l = 1;<BR>&nbsp;&nbsp;&nbsp; hwaddr addr1;<BR>&nbsp;&nbsp;&nbsp; MemTxResult r;<BR>&nbsp;&nbsp;&nbsp; bool release_lock = false;</P>
<P>&nbsp;&nbsp;&nbsp; RCU_READ_LOCK();<BR>&nbsp;&nbsp;&nbsp; mr = TRANSLATE(addr, &amp;addr1, &amp;l, true);<BR>&nbsp;&nbsp;&nbsp; if (!IS_DIRECT(mr, true)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release_lock |= prepare_mmio_access(mr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = memory_region_dispatch_write(mr, addr1, val, 1, attrs);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* RAM case */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = MAP_RAM(mr, addr1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stb_p(ptr, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INVALIDATE(mr, addr1, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = MEMTX_OK;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (result) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = r;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (release_lock) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_unlock_iothread();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; RCU_READ_UNLOCK();<BR>}</P>
<P>void glue(stb_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stb, SUFFIX)(ARG1, addr, val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>/* warning: addr must be aligned */<BR>static inline void glue(address_space_stw_internal, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint32_t val, MemTxAttrs attrs,<BR>&nbsp;&nbsp;&nbsp; MemTxResult *result, enum device_endian endian)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t *ptr;<BR>&nbsp;&nbsp;&nbsp; MemoryRegion *mr;<BR>&nbsp;&nbsp;&nbsp; hwaddr l = 2;<BR>&nbsp;&nbsp;&nbsp; hwaddr addr1;<BR>&nbsp;&nbsp;&nbsp; MemTxResult r;<BR>&nbsp;&nbsp;&nbsp; bool release_lock = false;</P>
<P>&nbsp;&nbsp;&nbsp; RCU_READ_LOCK();<BR>&nbsp;&nbsp;&nbsp; mr = TRANSLATE(addr, &amp;addr1, &amp;l, true);<BR>&nbsp;&nbsp;&nbsp; if (l &lt; 2 || !IS_DIRECT(mr, true)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release_lock |= prepare_mmio_access(mr);</P>
<P>#if defined(TARGET_WORDS_BIGENDIAN)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (endian == DEVICE_LITTLE_ENDIAN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = bswap16(val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (endian == DEVICE_BIG_ENDIAN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = bswap16(val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = memory_region_dispatch_write(mr, addr1, val, 2, attrs);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* RAM case */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = MAP_RAM(mr, addr1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (endian) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DEVICE_LITTLE_ENDIAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stw_le_p(ptr, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DEVICE_BIG_ENDIAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stw_be_p(ptr, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stw_p(ptr, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INVALIDATE(mr, addr1, 2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = MEMTX_OK;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (result) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = r;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (release_lock) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_unlock_iothread();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; RCU_READ_UNLOCK();<BR>}</P>
<P>void glue(address_space_stw, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stw_internal, SUFFIX)(ARG1, addr, val, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_NATIVE_ENDIAN);<BR>}</P>
<P>void glue(address_space_stw_le, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stw_internal, SUFFIX)(ARG1, addr, val, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_LITTLE_ENDIAN);<BR>}</P>
<P>void glue(address_space_stw_be, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stw_internal, SUFFIX)(ARG1, addr, val, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_BIG_ENDIAN);<BR>}</P>
<P>void glue(stw_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stw, SUFFIX)(ARG1, addr, val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>void glue(stw_le_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stw_le, SUFFIX)(ARG1, addr, val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>void glue(stw_be_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stw_be, SUFFIX)(ARG1, addr, val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>static void glue(address_space_stq_internal, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint64_t val, MemTxAttrs attrs,<BR>&nbsp;&nbsp;&nbsp; MemTxResult *result, enum device_endian endian)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t *ptr;<BR>&nbsp;&nbsp;&nbsp; MemoryRegion *mr;<BR>&nbsp;&nbsp;&nbsp; hwaddr l = 8;<BR>&nbsp;&nbsp;&nbsp; hwaddr addr1;<BR>&nbsp;&nbsp;&nbsp; MemTxResult r;<BR>&nbsp;&nbsp;&nbsp; bool release_lock = false;</P>
<P>&nbsp;&nbsp;&nbsp; RCU_READ_LOCK();<BR>&nbsp;&nbsp;&nbsp; mr = TRANSLATE(addr, &amp;addr1, &amp;l, true);<BR>&nbsp;&nbsp;&nbsp; if (l &lt; 8 || !IS_DIRECT(mr, true)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release_lock |= prepare_mmio_access(mr);</P>
<P>#if defined(TARGET_WORDS_BIGENDIAN)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (endian == DEVICE_LITTLE_ENDIAN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = bswap64(val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (endian == DEVICE_BIG_ENDIAN) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = bswap64(val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = memory_region_dispatch_write(mr, addr1, val, 8, attrs);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* RAM case */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptr = MAP_RAM(mr, addr1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (endian) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DEVICE_LITTLE_ENDIAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stq_le_p(ptr, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DEVICE_BIG_ENDIAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stq_be_p(ptr, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stq_p(ptr, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INVALIDATE(mr, addr1, 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = MEMTX_OK;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (result) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *result = r;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (release_lock) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_mutex_unlock_iothread();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; RCU_READ_UNLOCK();<BR>}</P>
<P>void glue(address_space_stq, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint64_t val, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stq_internal, SUFFIX)(ARG1, addr, val, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_NATIVE_ENDIAN);<BR>}</P>
<P>void glue(address_space_stq_le, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint64_t val, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stq_internal, SUFFIX)(ARG1, addr, val, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_LITTLE_ENDIAN);<BR>}</P>
<P>void glue(address_space_stq_be, SUFFIX)(ARG1_DECL,<BR>&nbsp;&nbsp;&nbsp; hwaddr addr, uint64_t val, MemTxAttrs attrs, MemTxResult *result)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stq_internal, SUFFIX)(ARG1, addr, val, attrs, result,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_BIG_ENDIAN);<BR>}</P>
<P>void glue(stq_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint64_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stq, SUFFIX)(ARG1, addr, val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>void glue(stq_le_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint64_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stq_le, SUFFIX)(ARG1, addr, val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>void glue(stq_be_phys, SUFFIX)(ARG1_DECL, hwaddr addr, uint64_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; glue(address_space_stq_be, SUFFIX)(ARG1, addr, val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MEMTXATTRS_UNSPECIFIED, NULL);<BR>}</P>
<P>#undef ARG1_DECL<BR>#undef ARG1<BR>#undef SUFFIX<BR>#undef TRANSLATE<BR>#undef IS_DIRECT<BR>#undef MAP_RAM<BR>#undef INVALIDATE<BR>#undef RCU_READ_LOCK<BR>#undef RCU_READ_UNLOCK