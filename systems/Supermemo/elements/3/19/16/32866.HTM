<HEAD></HEAD>
<BODY><SPAN lang=EN-US>It turns out GLib has a built-in mechanism for trapping memory allocations of a specific size, enabled when the library is built with debugging features enabled (so you may need to&nbsp;<A href="http://ftp.gnome.org/pub/GNOME/sources/glib/">download the GLib source</A>&nbsp;then build and install your own local copy of the library). From&nbsp;<A href="https://git.gnome.org/browse/glib/tree/docs/debugging.txt">docs/debugging.txt</A>&nbsp;within the GLib distribution:<?xml:namespace prefix = "o" ns = "urn:schemas-microsoft-com:office:office" /><o:p></o:p></SPAN> 
<P></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US>Some code portions contain trap variables that can be set during </SPAN><SPAN lang=EN-US>debugging time if G_ENABLE_DEBUG has been defined upon compilation </SPAN><SPAN lang=EN-US>(use the --enable-debug=yes option to configure for this, macros.txt </SPAN><SPAN lang=EN-US>covers more details).<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US>Such traps lead to immediate code halts to examine the current </SPAN><SPAN lang=EN-US>program state and backtrace.<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US>Currently, the following trap variables exist:<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US>...<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US>static volatile gulong g_trap_malloc_size;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>If set to a size &gt; 0, g_free(), g_realloc() and g_malloc()<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>respectively, will be intercepted if the size matches the<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>size of the corresponding memory block to free/reallocate/allocate.<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>This will only work with g_mem_set_vtable (glib_mem_profiler_table)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>upon startup though, because memory profiling is required to match<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>on the memory block sizes.<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN: 0cm 0cm 0pt"><SPAN lang=EN-US>The&nbsp;static volatile&nbsp;declaration and breakpoint-triggering behaviour of the implementation makes me think you're meant to load your app inside a debugger, then stuff a value into this variable and let the program run. When an allocation of the specified size is made the library will trap back into the debugger, allowing you to examine the backtrace and see where the allocation was made within your code.<o:p></o:p></SPAN></P>
<P>&nbsp; </P></BODY>