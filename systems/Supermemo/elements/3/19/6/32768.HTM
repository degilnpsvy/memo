These functions provide support for allocating and freeing memory.</P>
<P>If any call to allocate memory fails, the application is terminated. This also means that there is no need to check if the call succeeded.</P>
<P>It's important to match <A title=g_malloc&nbsp;() class=link href="https://developer.gnome.org/glib/stable/glib-Memory-Allocation.html#g-malloc"><CODE class=function>g_malloc()</CODE></A> (and wrappers such as <A title=g_new() class=link href="https://developer.gnome.org/glib/stable/glib-Memory-Allocation.html#g-new"><CODE class=function>g_new()</CODE></A>) with <A title=g_free&nbsp;() class=link href="https://developer.gnome.org/glib/stable/glib-Memory-Allocation.html#g-free"><CODE class=function>g_free()</CODE></A>, <A title=g_slice_alloc&nbsp;() class=link href="https://developer.gnome.org/glib/stable/glib-Memory-Slices.html#g-slice-alloc"><CODE class=function>g_slice_alloc()</CODE></A> and wrappers such as <A title=g_slice_new() class=link href="https://developer.gnome.org/glib/stable/glib-Memory-Slices.html#g-slice-new"><CODE class=function>g_slice_new()</CODE></A>) with <A title=g_slice_free() class=link href="https://developer.gnome.org/glib/stable/glib-Memory-Slices.html#g-slice-free"><CODE class=function>g_slice_free()</CODE></A>, plain <CODE class=function>malloc()</CODE> with <CODE class=function>free()</CODE>, and (if you're using C++) new with delete and new[] with delete[]. Otherwise bad things can happen, since these allocators may use different memory pools (and new/delete call constructors and destructors). See also <A title=g_mem_set_vtable&nbsp;() class=link href="https://developer.gnome.org/glib/stable/glib-Memory-Allocation.html#g-mem-set-vtable"><CODE class=function>g_mem_set_vtable()</CODE></A>.