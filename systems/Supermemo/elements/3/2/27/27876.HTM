A3.2.1 Alignment behavior</P>
<P>Address alignment affects data accesses and updates to the PC.</P>
<P>Alignment and data access</P>
<P>The following data accesses always generate an alignment fault:<BR>&#8226; Non halfword-aligned LDREXH and STREXH<BR>&#8226; Non word-aligned LDREX and STREX<BR>&#8226; Non word-aligned LDRD, LDMIA, LDMDB, POP, LDC, VLDR, VLDM, and VPOP<BR>&#8226; Non word-aligned STRD, STMIA, STMDB, PUSH, STC, VSTR, VSTM, and VPUSH.</P>
<P>The following data accesses support unaligned addressing, and only generate alignment faults when the CCR.UNALIGN_TRP bit is set to 1, see Configuration and Control Register, CCR on page B3-720:<BR>&#8226; Non halfword-aligned LDR{S}H{T} and STRH{T}<BR>&#8226; Non halfword-aligned TBH<BR>&#8226; Non word-aligned LDR{T} and STR{T}</P>
<P>Note<BR>&#8226; LDREXD and STREXD are not supported in ARMv7-M.<BR>&#8226; Accesses to Strongly Ordered and Device memory types must always be naturally aligned, see Memory access restrictions on page A3-107.</P>
<P>The ARMv7-M alignment behavior is described in the following pseudocode:<BR>For register definitions see Appendix H Register Index.<BR>For ExceptionTaken() see Exception entry behavior on page B1-643.<BR>The other functions are local and descriptive only. For the actual memory access functionality, see MemU[] and MemA[] that are used in the instruction definitions (see Chapter A7 Instruction Details), and defined in Pseudocode details of general memory system operations on page B2-693.</P>
<P>if IsUnaligned(Address) then // the data access is to an unaligned address<BR>&nbsp;&nbsp; if AlignedAccessInstr() then // the instruction does not support unaligned accesses<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.UNALIGNED = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault);<BR>&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if CCR.UNALIGN_TRP then // trap on all unaligned accesses<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.UNALIGNED = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UnalignedAccess(Address); // perform an unaligned access<BR>else<BR>&nbsp;&nbsp; AlignedAccess(Address); // perform an aligned access</P>
<P>Alignment and updates to the PC</P>
<P>All instruction fetches must be halfword-aligned. Any exception return irregularities are captured as an INVSTATE or INVPC UsageFault by the exception return mechanism. See Fault behavior on page B1-669.</P>
<P>For exception entry and return:<BR>&#8226; exception entry using a vector with bit [0] clear causes an INVSTATE UsageFault<BR>&#8226; a reserved EXC_RETURN value causes an INVPC UsageFault<BR>&#8226; loading an unaligned value from the stack into the PC on an exception return is UNPREDICTABLE.</P>
<P>For all other cases where the PC is updated:<BR>&#8226; Bit [0] of the value is ignored when loading the PC using an ADD or MOV instruction.</P>
<P>Note<BR>This applies only to the 16-bit form of the ADD (register) and MOV (register) instructions otherwise loading the PC is UNPREDICTABLE.</P>
<P>&#8226; The following instructions cause an INVSTATE UsageFault if bit [0] of the value loaded to the PC is zero:<BR>&nbsp; &#8213; a BLX or BX<BR>&nbsp; &#8213; an LDR to the PC<BR>&nbsp; &#8213; a POP or LDM that includes the PC<BR>&#8226; Loading the PC with a value from a memory location whose address is not word aligned is UNPREDICTABLE.