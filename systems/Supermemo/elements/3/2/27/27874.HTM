A3.1 Address space 
<P></P>
<P>ARMv7-M is a memory-mapped architecture. The system address map on page B3-704 describes the ARMv7-M address map.</P>
<P>The ARMv7-M architecture uses a single, flat address space of 2^32 8-bit bytes. Byte addresses are treated as unsigned numbers, running from 0 to 2^32 - 1.</P>
<P>This address space is regarded as consisting of 2^30 32-bit words, each of whose addresses is word-aligned, meaning that the address is divisible by 4. The word whose word-aligned address is A consists of the four bytes with addresses A, A+1, A+2 and A+3. The address space can also be considered as consisting of 2^31 16-bit halfwords, each of whose addresses is halfword-aligned, meaning that the address is divisible by 2. The halfword whose halfword-aligned address is A consists of the two bytes with addresses A and A+1.</P>
<P><FONT class=extract>While instruction fetches are always halfword-aligned, some load and store instructions support unaligned addresses. This affects the access address A, such that A[1:0] in the case of a word access and A[0] in the case of a halfword access can have non-zero values.</FONT></P>
<P>Address calculations are normally performed using ordinary integer instructions. This means that they normally wrap around if they overflow or underflow the address space. Another way of describing this is that any address calculation is reduced modulo 2^32.</P>
<P><FONT class=extract>Normal sequential execution of instructions effectively calculates:<BR>(address_of_current_instruction) + (2 or 4) /*16- and 32-bit instr mix*/<BR>after each instruction to determine which instruction to execute next. If this calculation overflows the top of the address space, the result is UNPREDICTABLE. In ARMv7-M this condition cannot occur because the top of memory is defined to always have the Execute Never (XN) memory attribute associated with it. See The system address map on page B3-704 for more details. An access violation will be reported if this scenario occurs.</FONT></P>
<P>The above only applies to instructions that are executed, including those that fail their condition code check. Most ARM implementations prefetch instructions ahead of the currently-executing instruction.</P>
<P><FONT class=extract>LDC, LDM, LDRD, POP, PUSH, STC, STRD, STM, VLDM, VPOP, VPUSH, VSTM, VLDR.64, and VSTR.64 instructions access a sequence of words at increasing memory addresses, effectively incrementing a memory address by 4 for each register load or store. If this calculation overflows the top of the address space, the result is UNPREDICTABLE.</FONT></P>
<P><FONT class=extract>Any unaligned load or store whose calculated address is such that it would access the byte at 0xFFFFFFFF and the byte at address 0x00000000 as part of the instruction is UNPREDICTABLE.</FONT></P>
<P><FONT class=extract>All memory addresses used in ARMv7-M are physical addresses (PAs). ARMv7-M has no concept of virtual addresses (VAs).</FONT>