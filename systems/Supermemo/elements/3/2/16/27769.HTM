2 INTRODUCTION 
<P></P>
<P>Many microcontrollers have code protection features that allow access to the debug and programming interfaces to be restricted so that the code in the device can't be downloaded, or reverse engineered. Whilst this simple solution can be effective in situations with a single software vendor, it offers limited protection in situations with several mutually distrusting vendors. For example, vendor A sells a SUB protocol stack to vendor B, who adds their own high level firmware and programs the image into microcontrollers that are part of a product shipped to end users. Vendor A has no way of knowing if vendor B has purchased the correct number of licences for the USB stack, or if code in the end product was protected to prevent it being cloned by a third party. Protecting such systems is significantly more complex as the low level access required by vendor A. The solution is to support incremental lock down of the system. This would allow vendor A to program their software into the device (probably as a static library) before locking it down prior to reselling the microcontroller to vendor B. This would allow vendor B to call vendor A's code, but not be able to read it out, or reverse engineer it. Although this chain of custody approach ensures protection of the various software stacks, it does increase overheads by complicating the supply chain and inventory management. The scheme could be optimised if all vendors supplied firmware to a trusted party who is responsible for programming the devices and ensuring licence fees are paid, thus eliminating multiple programming steps. Since some microcontroller manufacturers already offer a programming service they are the logical choice for this role.</P>
<P>Although not prohibited by this specification, it is not anticipated that the code will be linked as a single executable that is downloaded to the device in one go. In the above example this approach would require vendor A to distribute the code in an unprotected form the vendor B, thus exposing the code to the same risks before link/programming that the security extensions aim to protect against after programming.</P>
<P>In addition to more complex protection scenarios, the need for a more secure platform is increasing and is being driven by many factors including:<BR>* increased complexity of attack and reverse engineering techniques<BR>* Isolation in systems where multiple software stacks from different vendors run on the same CPU, eg:<BR>** Smart metering systems where billing and metering firmware must be kept separate.<BR>** Bluetooth headsets where the aplication layer software must not be allowed to interfere with the qualified Bluetooth firmware stack.<BR>** Bug isolation - Bugs in one software stack should not be allowed to manifest symptoms in another stack, as this can cause increased support effort for firmware vendors.<BR>* Tighter Digital Rights Management (DRM) control