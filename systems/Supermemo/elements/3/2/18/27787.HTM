<H3 style="MARGIN: 13pt 0cm"><SPAN lang=EN-US style="FONT-SIZE: 22pt; LINE-HEIGHT: 173%; mso-bidi-font-size: 16.0pt"><FONT face=Calibri>4.8.1 CONTROL</FONT></SPAN></H3>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>The existing control register is modified as follows:</FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>nPRIV (Bit[0]) This bit is banked between the non-secure and secure states. This allows more flexible mapping of different use cases onto the security architecture.</FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>SPSEL (Bit[1]) This bit is banked between the non-secure state and secure states. Due to the way the banking of this bit interacts with the exception model this field can now be 1 when in handler mode, and is also read/writable from handler mode. However processor ignores the state of this bit when in handler mode and always uses the main stack pointer.</FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>FPCA (Bit[2]) This bit is read only from the non-secure state if NSACR.CP10 is set to 0.</FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>SFPA (Bit[3]) Secure FP active. When set to 1 this bit indicates that the FP registers contain active state that belongs to the secure state. This bit is accessible from both the privileged and unprivileged states using the MRS/MSR instructions, however it behaves as RAZ/WI when accessed from non-secure state. This bit is only present when the FP extensions are implemented and resets to 0. The hardware automatically sets/clears this bit as follows:</FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; FONT-FAMILY: Wingdings; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Wingdings; mso-bidi-font-family: Wingdings"><SPAN style="mso-list: Ignore">l<SPAN style='FONT: 7pt "Times New Roman"'> </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>An SG instruction fetched from secure memory and executed in the non-secure state (I.E. a NS-&gt;S function call) clears this bit</FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; FONT-FAMILY: Wingdings; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Wingdings; mso-bidi-font-family: Wingdings"><SPAN style="mso-list: Ignore">l<SPAN style='FONT: 7pt "Times New Roman"'> </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>A BXNS instruction that causes a transition to the non-secure state clears the bit</FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; FONT-FAMILY: Wingdings; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Wingdings; mso-bidi-font-family: Wingdings"><SPAN style="mso-list: Ignore">l<SPAN style='FONT: 7pt "Times New Roman"'> </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>A BLXNS instruction that causes a transition to the non-secure state preserves SFPA in the FNC_RETURN stack frame and then clears SFPA</FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; FONT-FAMILY: Wingdings; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Wingdings; mso-bidi-font-family: Wingdings"><SPAN style="mso-list: Ignore">l<SPAN style='FONT: 7pt "Times New Roman"'> </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Popping a FNC_RETURN stack frame sets SFPA to the value retrieved from the stack frame</FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; FONT-FAMILY: Wingdings; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Wingdings; mso-bidi-font-family: Wingdings"><SPAN style="mso-list: Ignore">l<SPAN style='FONT: 7pt "Times New Roman"'> </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>SFPA is saved and restored on exception entry/return in the xPSR value in the stack frame</FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; FONT-FAMILY: Wingdings; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Wingdings; mso-bidi-font-family: Wingdings"><SPAN style="mso-list: Ignore">l<SPAN style='FONT: 7pt "Times New Roman"'> </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Exception entry, including tail chaining clears SFPA</FONT></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; FONT-FAMILY: Wingdings; mso-bidi-font-size: 11.0pt; mso-fareast-font-family: Wingdings; mso-bidi-font-family: Wingdings"><SPAN style="mso-list: Ignore">l<SPAN style='FONT: 7pt "Times New Roman"'> </SPAN></SPAN></SPAN><SPAN lang=EN-US style="FONT-SIZE: 16.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>If FPCCR.ASPEN is set then any FP instruction (excluding VLSTM and VLLDM, see section 7.3) executed in the secure state sets SFPA. NOTE: If FPCCR.ASPEN is set and SPFA is clear when a FP instruction is executed in the secure state the FPSCR register will also to be initialized from FPDSCR.</FONT></SPAN>