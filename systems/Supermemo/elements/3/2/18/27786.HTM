5.1 Overview
<P></P>
<P>The security state an instruction should be executed in is inferred from the security status of the location the instruction was fetched from. As a result it is not possible to execute secure code in the non-secure state, or non-secure code in the secure state. However, in order to prevent attacks (e.g. return orientated programming) entry to a security state is strictly controlled by the following mechanisms:<BR>* All instruction fetches are performed with NS-Attr set such that no AUVIOL SecureFault&#8217;s will be generated by the memory accesses, regardless of the state of the processor (see section 4.5.2).<BR>* One of the following actions will occur if the security state of the location an instruction was fetched from indicates the PC has moved from secure code to non-secure code:<BR>** If the branch was marked as being a domain crossing the core transitions to the non-secure state (see section 5.2).<BR>** Otherwise a INVTRAN SecureFault is raised (see section 6.13). This situation can occur if the secure code crashes, raising the fault can prevent any secure register state being exposed to the non-secure domain.<BR>* Transitioning to the secure state is done by branching to a secure address that fulfils the following criteria:<BR>** The whole of the instruction at that address is in memory flagged as non-secure callable.<BR>** The secure address has been marked as a valid entry point by the presence of SG guard instruction.<BR>&nbsp; Branches to from the non-secure state to secure memory that don&#8217;t fulfil these criteria result in a INVEP SecureFault being raised. A branch to a SG in non-secure memory does not cause a transition to the secure state. The behavior of a sequential instruction fetches that cross from non-secure to secure memory and fulfil the secure entry criteria listed above is CONSTRAINED UNPREDICTABLE as follows:<BR>** Either an INVEP SecureFault is raised.<BR>** Or the transition to the secure state occurs normally</P>
<P>The guard instruction prevents non-secure code being able to jump to arbitrary locations in the secure code base. The presence of this guard instructions is checked for by the following pseudo code, which fetches an instruction to be executed, the details of which are described in the following sections, which the exception specific details described in section 6.2:</P>
<P>// FetchInstr()<BR>// ===========<BR>(bits (32), boolean) FetchInstr (bits(32) addr)<BR>&nbsp; // NOTE: It is CONSTRAINED UNPREDICTABLE whether otherwise valid sequential instruction fetches that cross from non-secure to secure memory generate a INVEP SecureFault, or transition normally.<BR>&nbsp; sgOpcode=0xE97FE97F&lt;31:0&gt;;</P>
<P>&nbsp; // Fetch the a T16 instruction, or the first half of a T32.<BR>&nbsp; hw1Instr=MemI[addr];<BR>&nbsp; hw1Attr=SecurityCheck(addr, TRUE, IsSecure());</P>
<P>&nbsp; // If the T bit is clear then the instruction can&#8217;t be decoded<BR>&nbsp; if EPSR.T==&#8217;0&#8216; then<BR>&nbsp;&nbsp;&nbsp; // Attempted NS-&gt;S domain crossings with the T bit clear raise an INVEP SecureFault<BR>&nbsp;&nbsp;&nbsp; if !IsSecure() &amp;&amp; !hw1Attr.ns then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SFSR.INVEP = '1';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; excInfo = CreateException(SecureFault, TRUE, TRUE);<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.INVSTATE = '1';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; excInfo = CreateException(UsageFault, FALSE, FALSE);<BR>&nbsp;&nbsp;&nbsp; HandleException(excInfo);</P>
<P>&nbsp; // Implementations are permitted to terminate the fetch process early if a domain crossing is being attempted and the first 16bits of the opcode isn't the first part of the SG instruction.<BR>&nbsp; if boolean IMPLEMENTATION_DEFINED "Early SG check" then<BR>&nbsp;&nbsp;&nbsp; if !IsSecure() &amp;&amp; !hw1Attr.ns &amp;&amp; (hw1Instr != sgOpcode&lt;31:16&gt;) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SFSR.INVEP = '1';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; excInfo = CreateException(SecureFault, TURE, TRUE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HandleException(excInfo);</P>
<P>&nbsp; // NOTE: Implementations are also permitted to terminate the fetch process at this point with an UNDEFINSTR UsageFault if the first 16bit is an undefined T32 prefix.</P>
<P>&nbsp; // If the data fetched is the top half of a T32 instruction fetch the bottom 16 bits<BR>&nbsp; isT16 = UInt(hw1Instr&lt;15:11&gt;) &lt; UInt('11101');<BR>&nbsp; if isT16 then<BR>&nbsp;&nbsp;&nbsp; instr = Zeros(16):hw1Instr;<BR>&nbsp; else<BR>&nbsp;&nbsp;&nbsp; instr = hw1Instr:MemI[addr+2];<BR>&nbsp;&nbsp;&nbsp; hw2Attr = SecurityCheck(addr+2, TRUE, IsSecure());</P>
<P>&nbsp;&nbsp;&nbsp; // The following test covers 2 possible fault conditions:<BR>&nbsp;&nbsp;&nbsp; // 1) NS code branching to a T32 instruction where the first half is in NS memory, and the second half is in S memory.<BR>&nbsp;&nbsp;&nbsp; // 2) NS code branching to a T32 instruction in S &amp; NSC memory, but where the second half of the instruction is in NS memory.<BR>&nbsp;&nbsp;&nbsp; if !IsSecure() &amp;&amp; (hw1Attr.ns != hw2Attr.ns) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SFSR.INVEP = '1';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; excInfo = CreateException(SecureFault, TRUE, TRUE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HandleException(excInfo);</P>
<P>&nbsp; // Raise a fault if an otherwise valid NS-&gt;S transition that doesn't land on an SG intruction.<BR>&nbsp; if !IsSecure() &amp;&amp; !hw1Attr.ns &amp;&amp; (instr != sgOpcode) then<BR>&nbsp;&nbsp;&nbsp; SFSR.INVEP = '1';<BR>&nbsp;&nbsp;&nbsp; excInfo = CreateException(SecureFault, TRUE, TRUE);<BR>&nbsp;&nbsp;&nbsp; HandleException(excInfo);<BR>&nbsp; return (instr, isT16);</P>
<P>This approach allows fast/efficient calling between domains, and permits an arbitrary number of entry points to the secure code. Conceptually the security extensions provide protection features between the secure/non-secure states similar to those already present between the priviliged/unprivileged state, with the following differences (the details of which are outlined in subsequent sections):<BR>* Entry is gated by the sG instruction rather than the SVC exception.<BR>** No change in execution priority - doesn't need to be factored into interrupt priority planning<BR>** Not restricted to a single entry point - No routing/proxying overhead<BR>** Arguments can be passed via the registers (not possible with SVC due to the possibility of exceptions occuring between the SVC instruction and the SVC exception handler)<BR>** When required (eg when there's more than 4 arguments) passing arguments via the stack can be done quickly, without the need for multiple conditional MRS intrustions to obtain the stack pointer<BR>* Each entry point can be called from both the non-secure and secure state</P>
<P>Although this approach requires some special handling of secure external API functions the majority of code in the secure domain, and all the code in the non-secure domain does not need any modification. In addition to increasing backwards compatibility this also enables legacy libraries, or compilers that have not yet been updated to suport these extensions (eg GCC) to be used for entire of the non-secure code base. It is worth noting that the secure boundary functions that do require special handling could be implemented as simple assembly wrapper functions. This allows the security extensions to be used without specific computer support. More information on the software and tool implications can be found is the "Software interface" appendix (see section 11.1).