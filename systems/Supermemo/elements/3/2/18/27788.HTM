4.8.2 CCR</P>
<P>The existing CCR register is banked between the non-secure and secure states in addition to being modified as follows:</P>
<P>STKOFHFNMIGN (Bit[10]) Determines the effect of a stack limit register being exceeded on handlers running at a negative requested execution priority for the security domain the stack limit register is associated with (see section 6.12.2):<BR>&nbsp;&nbsp;&nbsp; 0 = The stack limit fault is not ignored for handlers with a requested priority less than 0. NOTE: A practical consequence is that violation of the stack limit when the requested execution priority is negative may causes a lockup at the current priority level.<BR>&nbsp;&nbsp;&nbsp; 1 = The stack limit fault is ignored if the requested priority is negative. NOTE: This allows the fault to be handled by a HardFault handler.<BR>&nbsp; The bit is banked between the security states. The secure version dictates the behaviour if either of the secure stack pointer limits are exceeded, and vice versa for the non-secure version of the bit.</P>
<P>STKALIGN (Bit[9]) This bit is redefined to always be RAO/WI for all v8-M implementations. Since this is one of the existing IMPLEMENTATION DEFINED options no adverse effects on backwards compatibility are expected.</P>
<P>BFHFNMIGN (Bit[8]) This bit is not banked and is read only from the non-secure state if AIRCR.BFHFNMINS is set to 0.</P>
<P>NONBASETHRDENA (Bit[0]) This bit is redefined to be RAO/WI.