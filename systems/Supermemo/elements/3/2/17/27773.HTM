4.4.3 Security attribution<BR><FONT class=extract>The security extension define 3 levels of memory security attribution, in ascending order of security they are:<BR>1) Non-secure<BR>2) Secure and non-secure callable<BR>3) Secure and not non-secure callable</FONT> 
<P></P>
<P><FONT class=extract>All boundaries between address ranges with different security attributes must be aligned to 32 byte boundaries. The attribution information can be provided by two different units:<BR>* A security attribution unit (SAU) inside the processor.<BR>* An IMPLEMENTATION DEFIENED attribution unit (IDAU) external to the processor. Whether this unit is present is IMPLEMENTATION DEFINED<FONT class=extract>.</FONT></FONT></P>
<P><FONT class=extract>The attribution information from the SAU is used unless the IDAU specifies attributes with a higher security, in which case the IDAU attributes override the SAU attributes. The following address ranges are exempt from memory attribution by both the SAU and IDAU and have fixed behavior:<BR>* 0xF0000000 -&gt; 0xFFFFFFFF: If the processor implements the security extensions this memory range is always marked as secure and not non-secure callable for instruction fetches. If the security extensions are not present this range is marked as non-secure.<BR>* The address ranges listed below are marked with the security state indicated by NS-Req (I.E. the current state of the processor for non-debug accesses). This effectively makes them exempt from security violation checking, and sets NS-Attr to NS-Req:<BR>&nbsp;&nbsp;&nbsp; oxE0000000 -&gt; 0xE0002FFF: ITM, DWT, FPB<BR>&nbsp;&nbsp;&nbsp; 0xE000E000 -&gt; 0xE000EFFF: SCS range<BR>&nbsp;&nbsp;&nbsp; 0xE002E000 -&gt; 0xE002EFFF: SCS NS alias range<BR>&nbsp;&nbsp;&nbsp; 0xE0040000 -&gt; 0xE0041FFF: TPIU, ETM<BR>&nbsp;&nbsp;&nbsp; 0xE00FF000 -&gt; 0xE00FFFFF: ROM table<BR>&nbsp;&nbsp;&nbsp; 0xE0000000 -&gt; 0xEFFFFFFF: for instruction fetch only<BR>&nbsp;&nbsp;&nbsp; Additional address ranges specified by the IDAU</FONT></P>
<P><FONT class=extract>A SecureFault is generated if a security violation is detected (e.g. an access to secure memory with NS-Req set to non-secure). Requests that cause a SecureFault to be generated do not result in a memory access being performed, similarly such accesses do not result in a MemManage fault being generated, regardless of the MPU configuration (NOTE: it is not usually possible for instruction fetches to generate a SecureFault). Syndrome information associated with the SecureFault is reported in SFSR and SFAR. This fault is distinct from the MemManage fault as it indicates an attempt to breach the security of the secure state, and therefore needs to be handled differently, as such the firmware vendors might want to assign different priorities to these two faults. The full process of checking both the security attribution and the MPU is depicted in Figure 2.</FONT>