A3.5.7 Memory access restrictions 
<P></P>
<P>The following restrictions apply to memory accesses:<BR>&#8226; For any access X, the bytes accessed by X must all have the same memory type attribute, otherwise the behavior of the access is UNPREDICTABLE. That is, an unaligned access that spans a boundary between different memory types is UNPREDICTABLE.<BR>&#8226; For any two memory accesses X and Y that are generated by the same instruction, the bytes accessed by X and Y must all have the same memory type attribute, otherwise the results are UNPREDICTABLE. For example, an LDC, LDM, LDRD, STC, STM, STRD, VSTM, VLDM, VPUSH, VPOP, VLDR, or VSTR that spans a boundary between Normal and Device memory is UNPREDICTABLE.<BR>&#8226; An instruction that generates an unaligned memory access to Device or Strongly-ordered memory is UNPREDICTABLE.<BR>&#8226; For instructions that generate accesses to Device or Strongly-ordered memory, implementations must not change the sequence of accesses specified by the pseudocode of the instruction. This includes not changing:<BR>&nbsp; &#8213; how many accesses there are<BR>&nbsp; &#8213; the time order of the accesses at any particular memory-mapped peripheral<BR>&nbsp; &#8213; the data sizes and other properties of each access.<BR>&nbsp; In addition, processor implementations expect any attached memory system to be able to identify the memory type of an accesses, and to obey similar restrictions with regard to the number, time order, data sizes and other properties of the accesses.<BR>&nbsp; Exceptions to this rule are:<BR>&nbsp; &#8213; A processor implementation can break this rule, provided that the information it supplies to the memory system enables the original number, time order, and other details of the accesses to be reconstructed. In addition, the implementation must place a requirement on attached memory systems to do this reconstruction when the accesses are to Device or Strongly-ordered memory.<BR>&nbsp;&nbsp;&nbsp; For example, an implementation with a 64-bit bus might pair the word loads generated by an LDM into 64-bit accesses. This is because the instruction semantics ensure that the 64-bit access is always a word load from the lower address followed by a word load from the higher address. However the implementation must permit the memory systems to unpack the two word loads when the access is to Device or Strongly-ordered memory.<BR>&nbsp; &#8213; Any implementation technique that produces results that cannot be observed to be different from those described above is legitimate.<BR>&#8226; LDM, STM, PUSH, POP, VLDM and VSTM instructions that are used with the IT instruction are restartable if interrupted during execution. Restarting a load or store instruction is incompatible with the Device and Strongly Ordered memory access rules. For details of the architecture constraints associated with these instructions in the exception model see Exceptions in Load Multiple and Store Multiple operations on page B1-658.<BR>&#8226; Any multi-access instruction that loads or stores the PC must access only Normal memory. If the instruction accesses Device or Strongly-ordered memory the result is UNPREDICTABLE.<BR>&#8226; Any instruction fetch must access only Normal memory. If it accesses Device or Strongly-ordered memory, the result is UNPREDICTABLE. For example, instruction fetches must not be performed to an area of memory that contains read-sensitive devices, because there is no ordering requirement between instruction fetches and explicit accesses.</P>
<P>To ensure correctness, read-sensitive locations must be marked as non-executable (see Privilege level access controls for instruction accesses on page A3-109).