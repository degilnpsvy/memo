5.6.2 BLS(register)</P>
<P>The existing instruction is modified as follows:<BR>BLX{NS} &lt;c&gt; &lt;Rm&gt;</P>
<P>m = UInt(Rm); allowNonSecure= NS == '1';<BR>if !IsSecure() &amp;&amp; allowNonSecure then UNDEFINED;<BR>if m == 15 then UNPREDICTABLE;<BR>if InITBlock() &amp;&amp; !LastInITBlock() then UNPREDICTABLE;</P>
<P>Operation:<BR>if ConditionPassed() then<BR>&nbsp; EncodingSpecificOperations();</P>
<P>&nbsp; target = R[m];<BR>&nbsp; nextInstrAddr = PC - 2;<BR>&nbsp; nextInstrAddr = nextInstrAddr&lt;31:1&gt;:'1';</P>
<P>&nbsp; if allowNonSecure &amp;&amp; (target&lt;0&gt; == '0') then<BR>&nbsp;&nbsp;&nbsp; if !IsAligned(SP,8) then UNPREDICTABLE;<BR>&nbsp;&nbsp;&nbsp; address = SP-8;<BR>&nbsp;&nbsp;&nbsp; XPSR_Type savedXPSR = Zeros();<BR>&nbsp;&nbsp;&nbsp; savedXPSR.Exception = IPSR.Exception;<BR>&nbsp;&nbsp;&nbsp; savedXPSR.SFPA = CONTROL.SFPA;<BR>&nbsp;&nbsp;&nbsp; // Only the stack locations, not the store order, are architected<BR>&nbsp;&nbsp;&nbsp; spName = LookUpSP();<BR>&nbsp;&nbsp;&nbsp; mode = CurrentMode();<BR>&nbsp;&nbsp;&nbsp; exc = Stack(address, 0, spName, mode, nextInstrAddr);<BR>&nbsp;&nbsp;&nbsp; if exc.fault == NoFault then exc = Stack(address, 4, spName, mode, savedXPSR);<BR>&nbsp;&nbsp;&nbsp; HandleException(exc);<BR>&nbsp;&nbsp;&nbsp; // Stack pointer update will raise a fault if limit violated<BR>&nbsp;&nbsp;&nbsp; SP = address;<BR>&nbsp;&nbsp;&nbsp; LR = 0xFEFFFFFF&lt;31:0&gt;;<BR>&nbsp;&nbsp;&nbsp; // If in handler mode IPSR must be non-zero. To prevent it details of which secure handler is calling non-secure code IPSR is set to an invalid but non-zero value (ie the reset exception number).<BR>&nbsp;&nbsp;&nbsp; if mode == Mode_Handler then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPSR = 0x1&lt;31:0&gt;;<BR>&nbsp; else<BR>&nbsp;&nbsp;&nbsp; LR = nextInstrAddr;</P>
<P>&nbsp; BLXWritePC(target, allowNonSecure);</P>
<P>If set to 1 the new NS field specifies that the branch is allowed to cause a transition from the secure to non-secure domain. This variant of the instruction should only be used where the additional steps required to make such a transition safe have been taken (See section 5.4.1). BLX instructions that have NS set to 0 retain the ARMv7-M behaviour with respect to the LSB of the target address (i.e. an INVSTATE UsageFault is raised if the LSB is 0). BLX instructions that cause a transition from secure to non-secure and have NS set to 0 and the LSB of the target address set to 1 (i.e. BLX instructions that don't raise an INVSTATE UsageFault) will result in a INVTRAN SecureFault (see section 5.2). The NS variant of the instruction is UNDEFINED from the non-secure state.