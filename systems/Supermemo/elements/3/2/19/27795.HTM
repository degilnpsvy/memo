5.6.1 SG</P>
<P>Secure gateway. This guard instruction is used to indicate that an address is a valid branch taget for branches from non-secure code. NOTE: This instruction fits into the UNPREDICTABLE space in the T1 encoding of LDRD (literal). See ARM ARMv7-M issue D section A7.7.50. This encoding has been deliberately picked because both the upper and lower 16 bit words have the same value, and just the top 16 bits mark the instruction as UNPREDICTABLE in the current ISA. This makes very unlikely that this bit pattern will be found in normal code, even if a branch is performed to the middle of a 32 bit instruction.</P>
<P>Operation:</P>
<P>EncodingSpecificOperations();</P>
<P>if HaveSecurityExt() then<BR>&nbsp; sAttributes = SecurityCheck(ThisInstrAddr(), TRUE, IsSecure());<BR>&nbsp; if !sAttributes.ns then<BR>&nbsp;&nbsp;&nbsp; if !IsSecure() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LR&lt;0&gt; = '0';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if HaveFPExt() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTROL.SFPA = '0';<BR>&nbsp;&nbsp;&nbsp; CurrentState = SecurityState_Secure;<BR>&nbsp;&nbsp;&nbsp; // IT/ICI bits cleared to prevent non-secure code interfering with secure execution<BR>&nbsp;&nbsp;&nbsp; if HaveMainLineProfile() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ITSTATE.IT = Zeros(8);</P>
<P>This instruction behaves as a NOP if fetched rom non-secure memory. When fetched from secure memory it updates the processor state to secure, and if the processor wasn't already in the secure state it clears LR[0]. To prevent the ITSTATE from the previous function (which may be non-secure) interfering with the operation of secure code the SG also clears the IT bits.</P>
<P>NOTE: Software must ensure there are no inadvertent SG instructions in memory regions that are marked as callable from the non-secure state (see section 4.4.3.1). In addition to checking literal pools in non-secure callable regions miss aligned opcodes directly before a SG instruction must also be checked, see section 11.3.2 for details.