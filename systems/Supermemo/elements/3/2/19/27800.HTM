6.13.1 SFSR 
<P></P>
<P>Secure Fault Status Register, address 0xE000EDE4, Resets to 0.</P>
<P>Usage constraints:<BR><FONT class=extract>* Write a one to a register bit to clear the corresponding fault.<BR>* The fault bits are additive; that is, if more than one fault occurs, all associated bits are set to 1.<BR>* Only accessible from the secure privileged state, unprivileged accesses generate a BusFault and accesses from the privileged non-secure state behave as RAZ/WI (see section 11.3.4 for rational).</FONT></P>
<P><FONT class=extract>INVEP (bit[0]) Invalid entry point. This exception is raised if an invalid entry to the secure state is attempted (E.G. a function call from the non-secure state targets a non-SG instruction in secure memory, the vector for a secure exception targets non-secure memory, etc).</FONT></P>
<P><FONT class=extract>INVMS (bit[1]) Invalid magic signature. This bit is set if the magic signature in an exception stack frame is found to be invalid during the unstacking operation.</FONT></P>
<P><FONT class=extract>INVER (bit[2]) Invalid exception return. This can be caused by:<BR>&nbsp; * EXC_RETURN.DCRS being set to 0 when returning from an exception in the non-secure state.<BR>&nbsp; * EXC_RETURN.ES being set to 1 when returning from an exception in the non-secure state.</FONT></P>
<P><FONT class=extract>AUVIOL (bit[3]) Attribution unit violation. Indicates that an attempt was made to access parts of the address space that are marked as secure with NS-Req for the transaction set to non-secure. This bit is not set if the violation occurred during:<BR>&nbsp; * Lazy state preservation (see LSPERR below)<BR>&nbsp; * Vector fetches (see section 6.11.4)</FONT></P>
<P><FONT class=extract>INVTRAN (bit[4]) Invalid transition. This exception is raised when an invalid exit from the secure state is detected (E.G. a branch that is not flagged as being a domain crossing causes a transition from secure to non-secure memory, linear instruction fetch that crosses from secure to non-secure memory, the exception return address targets non-secure memory when returning to the secure state, etc).</FONT></P>
<P><FONT class=extract>LSPERR (bit[5]) Lazy state preservation error. Indicates that a SAU/IDAU violation occurred during the lazy preservation of FP state</FONT></P>
<P><FONT class=extract>SFARVALID (bit[6]) Secure fault address valid. This bit is set when the SFAR register contains a valid value. Like similar fields (eg BFSR.BFARVALID, and MMFSR.MMARVALID) this bit may be cleared by other exceptions (eg BusFault). NOTE: This field is not set for SAU/IDAU faults caused by vector fetches.</FONT></P>
<P><FONT class=extract>LSERR (bit[7]) Lazy state error. Indicates an error occurred during lazy state activation or deactivation. See section 7.1 for details.</FONT>