/**<BR>&nbsp;* <SPAN class=cloze>[...]</SPAN> - delete device from system.<BR>&nbsp;* @dev: device.<BR>&nbsp;*<BR>&nbsp;* This is the first part of the device unregistration<BR>&nbsp;* sequence. This removes the device from the lists we control<BR>&nbsp;* from here, has it removed from the other driver model<BR>&nbsp;* subsystems it was added to in device_add(), and removes it<BR>&nbsp;* from the kobject hierarchy.<BR>&nbsp;*<BR>&nbsp;* NOTE: this should be called manually _iff_ device_add() was<BR>&nbsp;* also called manually.<BR>&nbsp;*/<BR>void <SPAN class=cloze><FONT color=#000000>[...]</FONT></SPAN>(struct device *dev)<BR>{<BR>&nbsp;struct device *parent = dev-&gt;parent;<BR>&nbsp;struct class_interface *class_intf; 
<P></P>
<P>&nbsp;/* Notify clients of device removal.&nbsp; This call must come<BR>&nbsp; * before dpm_sysfs_remove().<BR>&nbsp; */<BR>&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_DEL_DEVICE, dev);<BR>&nbsp;dpm_sysfs_remove(dev);<BR>&nbsp;if (parent)<BR>&nbsp;&nbsp;klist_del(&amp;dev-&gt;p-&gt;knode_parent);<BR>&nbsp;if (MAJOR(dev-&gt;devt)) {<BR>&nbsp;&nbsp;devtmpfs_delete_node(dev);<BR>&nbsp;&nbsp;device_remove_sys_dev_entry(dev);<BR>&nbsp;&nbsp;device_remove_file(dev, &amp;dev_attr_dev);<BR>&nbsp;}<BR>&nbsp;if (dev-&gt;class) {<BR>&nbsp;&nbsp;device_remove_class_symlinks(dev);</P>
<P>&nbsp;&nbsp;mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);<BR>&nbsp;&nbsp;/* notify any interfaces that the device is now gone */<BR>&nbsp;&nbsp;list_for_each_entry(class_intf,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)<BR>&nbsp;&nbsp;&nbsp;if (class_intf-&gt;remove_dev)<BR>&nbsp;&nbsp;&nbsp;&nbsp;class_intf-&gt;remove_dev(dev, class_intf);<BR>&nbsp;&nbsp;/* remove the device from the class list */<BR>&nbsp;&nbsp;klist_del(&amp;dev-&gt;knode_class);<BR>&nbsp;&nbsp;mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);<BR>&nbsp;}<BR>&nbsp;device_remove_file(dev, &amp;dev_attr_uevent);<BR>&nbsp;device_remove_attrs(dev);<BR>&nbsp;bus_remove_device(dev);<BR>&nbsp;device_pm_remove(dev);<BR>&nbsp;driver_deferred_probe_del(dev);</P>
<P>&nbsp;/* Notify the platform of the removal, in case they<BR>&nbsp; * need to do anything...<BR>&nbsp; */<BR>&nbsp;if (platform_notify_remove)<BR>&nbsp;&nbsp;platform_notify_remove(dev);<BR>&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_REMOVED_DEVICE, dev);<BR>&nbsp;kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);<BR>&nbsp;cleanup_device_parent(dev);<BR>&nbsp;kobject_del(&amp;dev-&gt;kobj);<BR>&nbsp;put_device(parent);<BR>}<BR>EXPORT_SYMBOL_GPL(<SPAN class=cloze><FONT color=#000000>[...]</FONT></SPAN>);