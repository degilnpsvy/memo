static struct device_driver *next_driver(struct klist_iter *i)<BR>{<BR>&nbsp;struct klist_node *n = klist_next(i);<BR>&nbsp;struct driver_private *drv_priv; 
<P></P>
<P>&nbsp;if (n) {<BR>&nbsp;&nbsp;drv_priv = container_of(n, struct driver_private, knode_bus);<BR>&nbsp;&nbsp;return drv_priv-&gt;driver;<BR>&nbsp;}<BR>&nbsp;return NULL;<BR>}</P>
<P>/**<BR>&nbsp;* <SPAN class=cloze>[...]</SPAN> - driver iterator<BR>&nbsp;* @bus: bus we're dealing with.<BR>&nbsp;* @start: driver to start iterating on.<BR>&nbsp;* @data: data to pass to the callback.<BR>&nbsp;* @fn: function to call for each driver.<BR>&nbsp;*<BR>&nbsp;* This is nearly identical to the device iterator above.<BR>&nbsp;* We iterate over each driver that belongs to @bus, and call<BR>&nbsp;* @fn for each. If @fn returns anything but 0, we break out<BR>&nbsp;* and return it. If @start is not NULL, we use it as the head<BR>&nbsp;* of the list.<BR>&nbsp;*<BR>&nbsp;* NOTE: we don't return the driver that returns a non-zero<BR>&nbsp;* value, nor do we leave the reference count incremented for that<BR>&nbsp;* driver. If the caller needs to know that info, it must set it<BR>&nbsp;* in the callback. It must also be sure to increment the refcount<BR>&nbsp;* so it doesn't disappear before returning to the caller.<BR>&nbsp;*/<BR>int <SPAN class=cloze><FONT color=#000000>[...]</FONT></SPAN>(struct bus_type *bus, struct device_driver *start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data, int (*fn)(struct device_driver *, void *))<BR>{<BR>&nbsp;struct klist_iter i;<BR>&nbsp;struct device_driver *drv;<BR>&nbsp;int error = 0;</P>
<P>&nbsp;if (!bus)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_drivers, &amp;i,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start ? &amp;start-&gt;p-&gt;knode_bus : NULL);<BR>&nbsp;while ((drv = next_driver(&amp;i)) &amp;&amp; !error)<BR>&nbsp;&nbsp;error = fn(drv, data);<BR>&nbsp;klist_iter_exit(&amp;i);<BR>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(<SPAN class=cloze><FONT color=#000000>[...]</FONT></SPAN>);