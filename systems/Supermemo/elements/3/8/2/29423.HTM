/**<BR>&nbsp;* device_is_bound() - Check if device is bound to a driver<BR>&nbsp;* @dev: device to check<BR>&nbsp;*<BR>&nbsp;* Returns true if passed device has already finished probing successfully<BR>&nbsp;* against a driver.<BR>&nbsp;*<BR>&nbsp;* This function must be called with the device lock held.<BR>&nbsp;*/<BR>bool device_is_bound(struct device *dev)<BR>{<BR>&nbsp;return dev-&gt;p &amp;&amp; klist_node_attached(&amp;dev-&gt;p-&gt;knode_driver);<BR>}</P>
<P>static void driver_bound(struct device *dev)<BR>{<BR>&nbsp;if (device_is_bound(dev)) {<BR>&nbsp;&nbsp;printk(KERN_WARNING "%s: device %s already bound\n",<BR>&nbsp;&nbsp;&nbsp;__func__, kobject_name(&amp;dev-&gt;kobj));<BR>&nbsp;&nbsp;return;<BR>&nbsp;}</P>
<P>&nbsp;pr_debug("driver: '%s': %s: bound to device '%s'\n", dev-&gt;driver-&gt;name,<BR>&nbsp;&nbsp; __func__, dev_name(dev));</P>
<P>&nbsp;klist_add_tail(&amp;dev-&gt;p-&gt;knode_driver, &amp;dev-&gt;driver-&gt;p-&gt;klist_devices);</P>
<P>&nbsp;device_pm_check_callbacks(dev);</P>
<P>&nbsp;/*<BR>&nbsp; * Make sure the device is no longer in one of the deferred lists and<BR>&nbsp; * kick off retrying all pending devices<BR>&nbsp; */<BR>&nbsp;driver_deferred_probe_del(dev);<BR>&nbsp;driver_deferred_probe_trigger();</P>
<P>&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_BOUND_DRIVER, dev);<BR>}</P>
<P>static int driver_sysfs_add(struct device *dev)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_BIND_DRIVER, dev);</P>
<P>&nbsp;ret = sysfs_create_link(&amp;dev-&gt;driver-&gt;p-&gt;kobj, &amp;dev-&gt;kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp; kobject_name(&amp;dev-&gt;kobj));<BR>&nbsp;if (ret == 0) {<BR>&nbsp;&nbsp;ret = sysfs_create_link(&amp;dev-&gt;kobj, &amp;dev-&gt;driver-&gt;p-&gt;kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"driver");<BR>&nbsp;&nbsp;if (ret)<BR>&nbsp;&nbsp;&nbsp;sysfs_remove_link(&amp;dev-&gt;driver-&gt;p-&gt;kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kobject_name(&amp;dev-&gt;kobj));<BR>&nbsp;}<BR>&nbsp;return ret;<BR>}</P>
<P>static void driver_sysfs_remove(struct device *dev)<BR>{<BR>&nbsp;struct device_driver *drv = dev-&gt;driver;</P>
<P>&nbsp;if (drv) {<BR>&nbsp;&nbsp;sysfs_remove_link(&amp;drv-&gt;p-&gt;kobj, kobject_name(&amp;dev-&gt;kobj));<BR>&nbsp;&nbsp;sysfs_remove_link(&amp;dev-&gt;kobj, "driver");<BR>&nbsp;}<BR>}</P>
<P>/**<BR>&nbsp;* device_bind_driver - bind a driver to one device.<BR>&nbsp;* @dev: device.<BR>&nbsp;*<BR>&nbsp;* Allow manual attachment of a driver to a device.<BR>&nbsp;* Caller must have already set @dev-&gt;driver.<BR>&nbsp;*<BR>&nbsp;* Note that this does not modify the bus reference count<BR>&nbsp;* nor take the bus's rwsem. Please verify those are accounted<BR>&nbsp;* for before calling this. (It is ok to call with no other effort<BR>&nbsp;* from a driver's probe() method.)<BR>&nbsp;*<BR>&nbsp;* This function must be called with the device lock held.<BR>&nbsp;*/<BR>int device_bind_driver(struct device *dev)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;ret = driver_sysfs_add(dev);<BR>&nbsp;if (!ret)<BR>&nbsp;&nbsp;driver_bound(dev);<BR>&nbsp;else if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_DRIVER_NOT_BOUND, dev);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(device_bind_driver);