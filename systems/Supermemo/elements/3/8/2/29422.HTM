/**<BR>&nbsp;* device_block_probing() - Block/defere device's probes<BR>&nbsp;*<BR>&nbsp;*&nbsp;It will disable probing of devices and defer their probes instead.<BR>&nbsp;*/<BR>void device_block_probing(void)<BR>{<BR>&nbsp;defer_all_probes = true;<BR>&nbsp;/* sync with probes to avoid races. */<BR>&nbsp;wait_for_device_probe();<BR>}</P>
<P>/**<BR>&nbsp;* device_unblock_probing() - Unblock/enable device's probes<BR>&nbsp;*<BR>&nbsp;*&nbsp;It will restore normal behavior and trigger re-probing of deferred<BR>&nbsp;* devices.<BR>&nbsp;*/<BR>void device_unblock_probing(void)<BR>{<BR>&nbsp;defer_all_probes = false;<BR>&nbsp;driver_deferred_probe_trigger();<BR>}</P>
<P>/**<BR>&nbsp;* deferred_probe_initcall() - Enable probing of deferred devices<BR>&nbsp;*<BR>&nbsp;* We don't want to get in the way when the bulk of drivers are getting probed.<BR>&nbsp;* Instead, this initcall makes sure that deferred probing is delayed until<BR>&nbsp;* late_initcall time.<BR>&nbsp;*/<BR>static int deferred_probe_initcall(void)<BR>{<BR>&nbsp;deferred_wq = create_singlethread_workqueue("deferwq");<BR>&nbsp;if (WARN_ON(!deferred_wq))<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;driver_deferred_probe_enable = true;<BR>&nbsp;driver_deferred_probe_trigger();<BR>&nbsp;/* Sort as many dependencies as possible before exiting initcalls */<BR>&nbsp;flush_workqueue(deferred_wq);<BR>&nbsp;return 0;<BR>}<BR>late_initcall(deferred_probe_initcall);