struct device_attach_data {<BR>&nbsp;struct device *dev;</P>
<P>&nbsp;/*<BR>&nbsp; * Indicates whether we are are considering asynchronous probing or<BR>&nbsp; * not. Only initial binding after device or driver registration<BR>&nbsp; * (including deferral processing) may be done asynchronously, the<BR>&nbsp; * rest is always synchronous, as we expect it is being done by<BR>&nbsp; * request from userspace.<BR>&nbsp; */<BR>&nbsp;bool check_async;</P>
<P>&nbsp;/*<BR>&nbsp; * Indicates if we are binding synchronous or asynchronous drivers.<BR>&nbsp; * When asynchronous probing is enabled we'll execute 2 passes<BR>&nbsp; * over drivers: first pass doing synchronous probing and second<BR>&nbsp; * doing asynchronous probing (if synchronous did not succeed -<BR>&nbsp; * most likely because there was no driver requiring synchronous<BR>&nbsp; * probing - and we found asynchronous driver during first pass).<BR>&nbsp; * The 2 passes are done because we can't shoot asynchronous<BR>&nbsp; * probe for given device and driver from bus_for_each_drv() since<BR>&nbsp; * driver pointer is not guaranteed to stay valid once<BR>&nbsp; * bus_for_each_drv() iterates to the next driver on the bus.<BR>&nbsp; */<BR>&nbsp;bool want_async;</P>
<P>&nbsp;/*<BR>&nbsp; * We'll set have_async to 'true' if, while scanning for matching<BR>&nbsp; * driver, we'll encounter one that requests asynchronous probing.<BR>&nbsp; */<BR>&nbsp;bool have_async;<BR>};