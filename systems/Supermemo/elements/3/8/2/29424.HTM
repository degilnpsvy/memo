static int really_probe(struct device *dev, struct device_driver *drv)<BR>{<BR>&nbsp;int ret = -EPROBE_DEFER;<BR>&nbsp;int local_trigger_count = atomic_read(&amp;deferred_trigger_count);</P>
<P>&nbsp;if (defer_all_probes) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Value of defer_all_probes can be set only by<BR>&nbsp;&nbsp; * device_defer_all_probes_enable() which, in turn, will call<BR>&nbsp;&nbsp; * wait_for_device_probe() right after that to avoid any races.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;dev_dbg(dev, "Driver %s force probe deferral\n", drv-&gt;name);<BR>&nbsp;&nbsp;driver_deferred_probe_add(dev);<BR>&nbsp;&nbsp;return ret;<BR>&nbsp;}</P>
<P>&nbsp;atomic_inc(&amp;probe_count);<BR>&nbsp;pr_debug("bus: '%s': %s: probing driver %s with device %s\n",<BR>&nbsp;&nbsp; drv-&gt;bus-&gt;name, __func__, drv-&gt;name, dev_name(dev));<BR>&nbsp;WARN_ON(!list_empty(&amp;dev-&gt;devres_head));</P>
<P>&nbsp;dev-&gt;driver = drv;</P>
<P>&nbsp;/* If using pinctrl, bind pins now before probing */<BR>&nbsp;ret = pinctrl_bind_pins(dev);<BR>&nbsp;if (ret)<BR>&nbsp;&nbsp;goto pinctrl_bind_failed;</P>
<P>&nbsp;if (driver_sysfs_add(dev)) {<BR>&nbsp;&nbsp;printk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",<BR>&nbsp;&nbsp;&nbsp;__func__, dev_name(dev));<BR>&nbsp;&nbsp;goto probe_failed;<BR>&nbsp;}</P>
<P>&nbsp;if (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;activate) {<BR>&nbsp;&nbsp;ret = dev-&gt;pm_domain-&gt;activate(dev);<BR>&nbsp;&nbsp;if (ret)<BR>&nbsp;&nbsp;&nbsp;goto probe_failed;<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * Ensure devices are listed in devices_kset in correct order<BR>&nbsp; * It's important to move Dev to the end of devices_kset before<BR>&nbsp; * calling .probe, because it could be recursive and parent Dev<BR>&nbsp; * should always go first<BR>&nbsp; */<BR>&nbsp;devices_kset_move_last(dev);</P>
<P>&nbsp;if (dev-&gt;bus-&gt;probe) {<BR>&nbsp;&nbsp;ret = dev-&gt;bus-&gt;probe(dev);<BR>&nbsp;&nbsp;if (ret)<BR>&nbsp;&nbsp;&nbsp;goto probe_failed;<BR>&nbsp;} else if (drv-&gt;probe) {<BR>&nbsp;&nbsp;ret = drv-&gt;probe(dev);<BR>&nbsp;&nbsp;if (ret)<BR>&nbsp;&nbsp;&nbsp;goto probe_failed;<BR>&nbsp;}</P>
<P>&nbsp;pinctrl_init_done(dev);</P>
<P>&nbsp;if (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;sync)<BR>&nbsp;&nbsp;dev-&gt;pm_domain-&gt;sync(dev);</P>
<P>&nbsp;driver_bound(dev);<BR>&nbsp;ret = 1;<BR>&nbsp;pr_debug("bus: '%s': %s: bound device %s to driver %s\n",<BR>&nbsp;&nbsp; drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);<BR>&nbsp;goto done;</P>
<P>probe_failed:<BR>&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_DRIVER_NOT_BOUND, dev);<BR>pinctrl_bind_failed:<BR>&nbsp;devres_release_all(dev);<BR>&nbsp;driver_sysfs_remove(dev);<BR>&nbsp;dev-&gt;driver = NULL;<BR>&nbsp;dev_set_drvdata(dev, NULL);<BR>&nbsp;if (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)<BR>&nbsp;&nbsp;dev-&gt;pm_domain-&gt;dismiss(dev);<BR>&nbsp;pm_runtime_reinit(dev);</P>
<P>&nbsp;switch (ret) {<BR>&nbsp;case -EPROBE_DEFER:<BR>&nbsp;&nbsp;/* Driver requested deferred probing */<BR>&nbsp;&nbsp;dev_dbg(dev, "Driver %s requests probe deferral\n", drv-&gt;name);<BR>&nbsp;&nbsp;driver_deferred_probe_add(dev);<BR>&nbsp;&nbsp;/* Did a trigger occur while probing? Need to re-trigger if yes */<BR>&nbsp;&nbsp;if (local_trigger_count != atomic_read(&amp;deferred_trigger_count))<BR>&nbsp;&nbsp;&nbsp;driver_deferred_probe_trigger();<BR>&nbsp;&nbsp;break;<BR>&nbsp;case -ENODEV:<BR>&nbsp;case -ENXIO:<BR>&nbsp;&nbsp;pr_debug("%s: probe of %s rejects match %d\n",<BR>&nbsp;&nbsp;&nbsp; drv-&gt;name, dev_name(dev), ret);<BR>&nbsp;&nbsp;break;<BR>&nbsp;default:<BR>&nbsp;&nbsp;/* driver matched but the probe failed */<BR>&nbsp;&nbsp;printk(KERN_WARNING<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%s: probe of %s failed with error %d\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drv-&gt;name, dev_name(dev), ret);<BR>&nbsp;}<BR>&nbsp;/*<BR>&nbsp; * Ignore errors returned by -&gt;probe so that the next driver can try<BR>&nbsp; * its luck.<BR>&nbsp; */<BR>&nbsp;ret = 0;<BR>done:<BR>&nbsp;atomic_dec(&amp;probe_count);<BR>&nbsp;wake_up(&amp;probe_waitqueue);<BR>&nbsp;return ret;<BR>}