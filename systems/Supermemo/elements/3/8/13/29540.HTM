/*<BR>&nbsp;* deferred_probe_work_func() - Retry probing devices in the active list.<BR>&nbsp;*/<BR>static void deferred_probe_work_func(struct work_struct *work)<BR>{<BR>&nbsp;struct device *dev;<BR>&nbsp;struct device_private *private;<BR>&nbsp;/*<BR>&nbsp; * This block processes every device in the deferred 'active' list.<BR>&nbsp; * Each device is removed from the active list and passed to<BR>&nbsp; * bus_probe_device() to re-attempt the probe.&nbsp; The loop continues<BR>&nbsp; * until every device in the active list is removed and retried.<BR>&nbsp; *<BR>&nbsp; * Note: Once the device is removed from the list and the mutex is<BR>&nbsp; * released, it is possible for the device get freed by another thread<BR>&nbsp; * and cause a illegal pointer dereference.&nbsp; This code uses<BR>&nbsp; * get/put_device() to ensure the device structure cannot disappear<BR>&nbsp; * from under our feet.<BR>&nbsp; */<BR>&nbsp;mutex_lock(&amp;deferred_probe_mutex);<BR><FONT class=clozed>&nbsp;while (!list_empty(&amp;deferred_probe_active_list)) {<BR>&nbsp;&nbsp;private = list_first_entry(&amp;deferred_probe_active_list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeof(*dev-&gt;p), deferred_probe);<BR>&nbsp;&nbsp;dev = private-&gt;device;<BR>&nbsp;&nbsp;list_del_init(&amp;private-&gt;deferred_probe); </FONT>
<P></P>
<P><FONT class=clozed>&nbsp;&nbsp;get_device(dev);</FONT></P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Drop the mutex while probing each device; the probe path may<BR>&nbsp;&nbsp; * manipulate the deferred list<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;mutex_unlock(&amp;deferred_probe_mutex);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Force the device to the end of the dpm_list since<BR>&nbsp;&nbsp; * the PM code assumes that the order we add things to<BR>&nbsp;&nbsp; * the list is a good order for suspend but deferred<BR>&nbsp;&nbsp; * probe makes that very unsafe.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;device_pm_lock();<BR>&nbsp;&nbsp;device_pm_move_last(dev);<BR>&nbsp;&nbsp;device_pm_unlock();</P>
<P>&nbsp;&nbsp;dev_dbg(dev, "Retrying from deferred list\n");<BR>&nbsp;&nbsp;<SPAN class=cloze>[...]</SPAN>;</P>
<P>&nbsp;&nbsp;mutex_lock(&amp;deferred_probe_mutex);</P>
<P>&nbsp;&nbsp;put_device(dev);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;deferred_probe_mutex);<BR>}