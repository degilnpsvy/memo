/*<BR>&nbsp;* deferred_probe_work_func() - Retry probing devices in the active list.<BR>&nbsp;*/<BR>static void deferred_probe_work_func(struct work_struct *work)<BR>{<BR>&nbsp;struct device *dev;<BR>&nbsp;struct device_private *private;<BR>&nbsp;/*<BR>&nbsp; * This block processes every device in the deferred 'active' list.<BR>&nbsp; * Each device is removed from the active list and passed to<BR>&nbsp; * bus_probe_device() to re-attempt the probe.&nbsp; The loop continues<BR>&nbsp; * until every device in the active list is removed and retried.<BR>&nbsp; *<BR>&nbsp; * Note: Once the device is removed from the list and the mutex is<BR>&nbsp; * released, it is possible for the device get freed by another thread<BR>&nbsp; * and cause a illegal pointer dereference.&nbsp; This code uses<BR>&nbsp; * get/put_device() to ensure the device structure cannot disappear<BR>&nbsp; * from under our feet.<BR>&nbsp; */<BR>&nbsp;mutex_lock(&amp;deferred_probe_mutex);<BR><SPAN class=cloze>[...]get dev in deferred_probe_active_list</SPAN> 
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Drop the mutex while probing each device; the probe path may<BR>&nbsp;&nbsp; * manipulate the deferred list<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;mutex_unlock(&amp;deferred_probe_mutex);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Force the device to the end of the dpm_list since<BR>&nbsp;&nbsp; * the PM code assumes that the order we add things to<BR>&nbsp;&nbsp; * the list is a good order for suspend but deferred<BR>&nbsp;&nbsp; * probe makes that very unsafe.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;device_pm_lock();<BR>&nbsp;&nbsp;device_pm_move_last(dev);<BR>&nbsp;&nbsp;device_pm_unlock();</P>
<P>&nbsp;&nbsp;dev_dbg(dev, "Retrying from deferred list\n");<BR>&nbsp;&nbsp;bus_probe_device(dev);</P>
<P>&nbsp;&nbsp;mutex_lock(&amp;deferred_probe_mutex);</P>
<P>&nbsp;&nbsp;put_device(dev);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;deferred_probe_mutex);<BR>}