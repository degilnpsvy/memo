/**<BR>&nbsp;* klist_next - Ante up next node in list.<BR>&nbsp;* @i: Iterator structure.<BR>&nbsp;*<BR>&nbsp;* First grab list lock. Decrement the reference count of the previous<BR>&nbsp;* node, if there was one. Grab the next node, increment its reference<BR>&nbsp;* count, drop the lock, and return that next node.<BR>&nbsp;*/<BR>struct klist_node *klist_next(struct klist_iter *i)<BR>{<BR>&nbsp;void (*put)(struct klist_node *) = i-&gt;i_klist-&gt;put;<BR>&nbsp;struct klist_node *last = i-&gt;i_cur;<BR>&nbsp;struct klist_node *next;
<P></P>
<P>&nbsp;spin_lock(&amp;i-&gt;i_klist-&gt;k_lock);</P>
<P>&nbsp;if (last) {<BR>&nbsp;&nbsp;next = to_klist_node(last-&gt;n_node.next);<BR>&nbsp;&nbsp;if (!klist_dec_and_del(last))<BR>&nbsp;&nbsp;&nbsp;put = NULL;<BR>&nbsp;} else<BR>&nbsp;&nbsp;next = to_klist_node(i-&gt;i_klist-&gt;k_list.next);</P>
<P>&nbsp;i-&gt;i_cur = NULL;<BR>&nbsp;while (next != to_klist_node(&amp;i-&gt;i_klist-&gt;k_list)) {<BR>&nbsp;&nbsp;if (likely(!knode_dead(next))) {<BR>&nbsp;&nbsp;&nbsp;kref_get(&amp;next-&gt;n_ref);<BR>&nbsp;&nbsp;&nbsp;i-&gt;i_cur = next;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;next = to_klist_node(next-&gt;n_node.next);<BR>&nbsp;}</P>
<P>&nbsp;spin_unlock(&amp;i-&gt;i_klist-&gt;k_lock);</P>
<P>&nbsp;if (put &amp;&amp; last)<BR>&nbsp;&nbsp;put(last);<BR>&nbsp;return i-&gt;i_cur;<BR>}<BR>EXPORT_SYMBOL_GPL(klist_next);