Kick off re-probing deferred devices<BR>&nbsp;*<BR>&nbsp;* This functions moves all devices from the pending list to the active<BR>&nbsp;* list and schedules the deferred probe workqueue to process them.&nbsp; It<BR>&nbsp;* should be called anytime a driver is successfully bound to a device.<BR>&nbsp;*<BR>&nbsp;* Note, there is a race condition in multi-threaded probe. In the case where<BR>&nbsp;* more than one device is probing at the same time, it is possible for one<BR>&nbsp;* probe to complete successfully while another is about to defer. If the second<BR>&nbsp;* depends on the first, then it will get put on the pending list after the<BR>&nbsp;* trigger event has already occurred and will be stuck there.<BR>&nbsp;*<BR>&nbsp;* The atomic 'deferred_trigger_count' is used to determine if a successful<BR>&nbsp;* trigger has occurred in the midst of probing a driver. If the trigger count<BR>&nbsp;* changes in the midst of a probe, then deferred processing should be triggered<BR>&nbsp;* again.</P>
<P>static void driver_deferred_probe_trigger(void)<BR>{<BR>&nbsp;if (!driver_deferred_probe_enable)<BR>&nbsp;&nbsp;return; </P>
<P></P>
<P>&nbsp;/*<BR>&nbsp; * A successful probe means that all the devices in the pending list<BR>&nbsp; * should be triggered to be reprobed.&nbsp; Move all the deferred devices<BR>&nbsp; * into the active list so they can be retried by the workqueue<BR>&nbsp; */<BR>&nbsp;mutex_lock(&amp;deferred_probe_mutex);<BR>&nbsp;atomic_inc(&amp;deferred_trigger_count);<BR>&nbsp;list_splice_tail_init(&amp;deferred_probe_pending_list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;deferred_probe_active_list);<BR>&nbsp;mutex_unlock(&amp;deferred_probe_mutex);</P>
<P>&nbsp;/*<BR>&nbsp; * Kick the re-probe thread.&nbsp; It may already be scheduled, but it is<BR>&nbsp; * safe to kick it again.<BR>&nbsp; */<BR>&nbsp;queue_work(deferred_wq, &amp;deferred_probe_work);<BR>}