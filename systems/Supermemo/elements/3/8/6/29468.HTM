/*<BR>&nbsp;* klist.c - Routines for manipulating klists.<BR>&nbsp;*<BR>&nbsp;* Copyright (C) 2005 Patrick Mochel<BR>&nbsp;*<BR>&nbsp;* This file is released under the GPL v2.<BR>&nbsp;*<BR>&nbsp;* This klist interface provides a couple of structures that wrap around<BR>&nbsp;* struct list_head to provide explicit list "head" (struct klist) and list<BR>&nbsp;* "node" (struct klist_node) objects. <FONT class=extract>For struct klist, a spinlock is<BR>&nbsp;* included that protects access to the actual list itself.</FONT> <FONT class=extract>struct<BR>&nbsp;* klist_node provides a pointer to the klist that owns it and a kref<BR>&nbsp;* reference count that indicates the number of current users of that node<BR>&nbsp;* in the list.</FONT><BR>&nbsp;*<BR><FONT class=extract>&nbsp;* The entire point is to provide an interface for iterating over a list<BR>&nbsp;* that is safe and allows for modification of the list during the<BR>&nbsp;* iteration (e.g. insertion and removal), including modification of the<BR>&nbsp;* current node on the list.<BR>&nbsp;*<BR>&nbsp;* It works using a 3rd object type - struct klist_iter - that is declared<BR>&nbsp;* and initialized before an iteration. klist_next() is used to acquire the<BR>&nbsp;* next element in the list. It returns NULL if there are no more items.<BR>&nbsp;* Internally, that routine takes the klist's lock, decrements the<BR>&nbsp;* reference count of the previous klist_node and increments the count of<BR>&nbsp;* the next klist_node. It then drops the lock and returns.</FONT><BR>&nbsp;*<BR><FONT class=extract>&nbsp;* There are primitives for adding and removing nodes to/from a klist.<BR>&nbsp;* When deleting, klist_del() will simply decrement the reference count.<BR>&nbsp;* Only when the count goes to 0 is the node removed from the list.<BR>&nbsp;* klist_remove() will try to delete the node from the list and block until<BR>&nbsp;* it is actually removed. This is useful for objects (like devices) that<BR>&nbsp;* have been removed from the system and must be freed (but must wait until<BR>&nbsp;* all accessors have finished).</FONT><BR>&nbsp;*/