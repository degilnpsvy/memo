static DEFINE_SPINLOCK(klist_remove_lock);<BR>static LIST_HEAD(klist_remove_waiters);
<P></P>
<P>static void klist_release(struct kref *kref)<BR>{<BR>&nbsp;struct klist_waiter *waiter, *tmp;<BR>&nbsp;struct klist_node *n = container_of(kref, struct klist_node, n_ref);</P>
<P>&nbsp;WARN_ON(!knode_dead(n));<BR>&nbsp;list_del(&amp;n-&gt;n_node);<BR>&nbsp;spin_lock(&amp;klist_remove_lock);<BR>&nbsp;list_for_each_entry_safe(waiter, tmp, &amp;klist_remove_waiters, list) {<BR>&nbsp;&nbsp;if (waiter-&gt;node != n)<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;list_del(&amp;waiter-&gt;list);<BR>&nbsp;&nbsp;waiter-&gt;woken = 1;<BR>&nbsp;&nbsp;mb();<BR>&nbsp;&nbsp;wake_up_process(waiter-&gt;process);<BR>&nbsp;}<BR>&nbsp;spin_unlock(&amp;klist_remove_lock);<BR>&nbsp;knode_set_klist(n, NULL);<BR>}