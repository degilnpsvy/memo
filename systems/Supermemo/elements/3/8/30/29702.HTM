Linux v4.6 kernel/locking/semaphore.c 
<P></P>
<P>/*<BR>&nbsp;* Copyright (c) 2008 Intel Corporation<BR>&nbsp;* Author: Matthew Wilcox &lt;<A href="mailto:willy@linux.intel.com">willy@linux.intel.com</A>&gt;<BR>&nbsp;*<BR>&nbsp;* Distributed under the terms of the GNU GPL, version 2<BR>&nbsp;*<BR>&nbsp;* This file implements counting semaphores.<BR>&nbsp;* A counting semaphore may be acquired 'n' times before sleeping.<BR>&nbsp;* See mutex.c for single-acquisition sleeping locks which enforce<BR>&nbsp;* rules which allow code to be debugged more easily.<BR>&nbsp;*/</P>
<P></P>
<P>/*<BR>&nbsp;* Some notes on the implementation:<BR>&nbsp;*<BR><FONT class=extract>&nbsp;* The spinlock controls access to the other members of the semaphore.<BR>&nbsp;* down_trylock() and up() can be called from interrupt context, so we<BR>&nbsp;* have to disable interrupts when taking the lock.&nbsp; It turns out various<BR>&nbsp;* parts of the kernel expect to be able to use down() on a semaphore in<BR>&nbsp;* interrupt context when they know it will succeed, so we have to use<BR>&nbsp;* irqsave variants for down(), down_interruptible() and down_killable()<BR>&nbsp;* too.</FONT><BR>&nbsp;*<BR><FONT class=extract>&nbsp;* The -&gt;count variable represents how many more tasks can acquire this<BR>&nbsp;* semaphore.&nbsp; If it's zero, there may be tasks waiting on the wait_list.</FONT><BR>&nbsp;*/</P>
<P>#include &lt;linux/compiler.h&gt;<BR>#include &lt;linux/kernel.h&gt;<BR>#include &lt;linux/export.h&gt;<BR>#include &lt;linux/sched.h&gt;<BR>#include &lt;linux/semaphore.h&gt;<BR>#include &lt;linux/spinlock.h&gt;<BR>#include &lt;linux/ftrace.h&gt;</P>
<P><FONT class=extract>static noinline void __down(struct semaphore *sem);<BR>static noinline int __down_interruptible(struct semaphore *sem);<BR>static noinline int __down_killable(struct semaphore *sem);<BR>static noinline int __down_timeout(struct semaphore *sem, long timeout);<BR>static noinline void __up(struct semaphore *sem);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* down - acquire the semaphore<BR>&nbsp;* @sem: the semaphore to be acquired<BR>&nbsp;*<BR>&nbsp;* Acquires the semaphore.&nbsp; If no more tasks are allowed to acquire the<BR>&nbsp;* semaphore, calling this function will put the task to sleep until the<BR>&nbsp;* semaphore is released.<BR>&nbsp;*<BR>&nbsp;* Use of this function is deprecated, please use down_interruptible() or<BR>&nbsp;* down_killable() instead.<BR>&nbsp;*/<BR>void down(struct semaphore *sem)<BR>{<BR>&nbsp;unsigned long flags;</FONT></P>
<P><FONT class=extract>&nbsp;raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);<BR>&nbsp;if (likely(sem-&gt;count &gt; 0))<BR>&nbsp;&nbsp;sem-&gt;count--;<BR>&nbsp;else<BR>&nbsp;&nbsp;__down(sem);<BR>&nbsp;raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);<BR>}<BR>EXPORT_SYMBOL(down);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* down_interruptible - acquire the semaphore unless interrupted<BR>&nbsp;* @sem: the semaphore to be acquired<BR>&nbsp;*<BR>&nbsp;* Attempts to acquire the semaphore.&nbsp; If no more tasks are allowed to<BR>&nbsp;* acquire the semaphore, calling this function will put the task to sleep.<BR>&nbsp;* If the sleep is interrupted by a signal, this function will return -EINTR.<BR>&nbsp;* If the semaphore is successfully acquired, this function returns 0.<BR>&nbsp;*/<BR>int down_interruptible(struct semaphore *sem)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;int result = 0;</FONT></P>
<P><FONT class=extract>&nbsp;raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);<BR>&nbsp;if (likely(sem-&gt;count &gt; 0))<BR>&nbsp;&nbsp;sem-&gt;count--;<BR>&nbsp;else<BR>&nbsp;&nbsp;result = __down_interruptible(sem);<BR>&nbsp;raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</FONT></P>
<P><FONT class=extract>&nbsp;return result;<BR>}<BR>EXPORT_SYMBOL(down_interruptible);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* down_killable - acquire the semaphore unless killed<BR>&nbsp;* @sem: the semaphore to be acquired<BR>&nbsp;*<BR>&nbsp;* Attempts to acquire the semaphore.&nbsp; If no more tasks are allowed to<BR>&nbsp;* acquire the semaphore, calling this function will put the task to sleep.<BR>&nbsp;* If the sleep is interrupted by a fatal signal, this function will return<BR>&nbsp;* -EINTR.&nbsp; If the semaphore is successfully acquired, this function returns<BR>&nbsp;* 0.<BR>&nbsp;*/<BR>int down_killable(struct semaphore *sem)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;int result = 0;</FONT></P>
<P><FONT class=extract>&nbsp;raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);<BR>&nbsp;if (likely(sem-&gt;count &gt; 0))<BR>&nbsp;&nbsp;sem-&gt;count--;<BR>&nbsp;else<BR>&nbsp;&nbsp;result = __down_killable(sem);<BR>&nbsp;raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</FONT></P>
<P><FONT class=extract>&nbsp;return result;<BR>}<BR>EXPORT_SYMBOL(down_killable);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* down_trylock - try to acquire the semaphore, without waiting<BR>&nbsp;* @sem: the semaphore to be acquired<BR>&nbsp;*<BR>&nbsp;* Try to acquire the semaphore atomically.&nbsp; Returns 0 if the semaphore has<BR>&nbsp;* been acquired successfully or 1 if it it cannot be acquired.<BR>&nbsp;*<BR>&nbsp;* NOTE: This return value is inverted from both spin_trylock and<BR>&nbsp;* mutex_trylock!&nbsp; Be careful about this when converting code.<BR>&nbsp;*<BR>&nbsp;* Unlike mutex_trylock, this function can be used from interrupt context,<BR>&nbsp;* and the semaphore can be released by any task or interrupt.<BR>&nbsp;*/<BR>int down_trylock(struct semaphore *sem)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;int count;</FONT></P>
<P><FONT class=extract>&nbsp;raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);<BR>&nbsp;count = sem-&gt;count - 1;<BR>&nbsp;if (likely(count &gt;= 0))<BR>&nbsp;&nbsp;sem-&gt;count = count;<BR>&nbsp;raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</FONT></P>
<P><FONT class=extract>&nbsp;return (count &lt; 0);<BR>}<BR>EXPORT_SYMBOL(down_trylock);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* down_timeout - acquire the semaphore within a specified time<BR>&nbsp;* @sem: the semaphore to be acquired<BR>&nbsp;* @timeout: how long to wait before failing<BR>&nbsp;*<BR>&nbsp;* Attempts to acquire the semaphore.&nbsp; If no more tasks are allowed to<BR>&nbsp;* acquire the semaphore, calling this function will put the task to sleep.<BR>&nbsp;* If the semaphore is not released within the specified number of jiffies,<BR>&nbsp;* this function returns -ETIME.&nbsp; It returns 0 if the semaphore was acquired.<BR>&nbsp;*/<BR>int down_timeout(struct semaphore *sem, long timeout)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;int result = 0;</FONT></P>
<P><FONT class=extract>&nbsp;raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);<BR>&nbsp;if (likely(sem-&gt;count &gt; 0))<BR>&nbsp;&nbsp;sem-&gt;count--;<BR>&nbsp;else<BR>&nbsp;&nbsp;result = __down_timeout(sem, timeout);<BR>&nbsp;raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</FONT></P>
<P><FONT class=extract>&nbsp;return result;<BR>}<BR>EXPORT_SYMBOL(down_timeout);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* up - release the semaphore<BR>&nbsp;* @sem: the semaphore to release<BR>&nbsp;*<BR>&nbsp;* Release the semaphore.&nbsp; Unlike mutexes, up() may be called from any<BR>&nbsp;* context and even by tasks which have never called down().<BR>&nbsp;*/<BR>void up(struct semaphore *sem)<BR>{<BR>&nbsp;unsigned long flags;</FONT></P>
<P><FONT class=extract>&nbsp;raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);<BR>&nbsp;if (likely(list_empty(&amp;sem-&gt;wait_list)))<BR>&nbsp;&nbsp;sem-&gt;count++;<BR>&nbsp;else<BR>&nbsp;&nbsp;__up(sem);<BR>&nbsp;raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);<BR>}<BR>EXPORT_SYMBOL(up);</FONT></P>
<P>/* Functions for the contended case */</P>
<P><FONT class=extract>struct semaphore_waiter {<BR>&nbsp;struct list_head list;<BR>&nbsp;struct task_struct *task;<BR>&nbsp;bool up;<BR>};</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Because this function is inlined, the 'state' parameter will be<BR>&nbsp;* constant, and thus optimised away by the compiler.&nbsp; Likewise the<BR>&nbsp;* 'timeout' parameter for the cases without timeouts.<BR>&nbsp;*/<BR>static inline int __sched __down_common(struct semaphore *sem, long state,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long timeout)<BR>{<BR>&nbsp;struct task_struct *task = current;<BR>&nbsp;struct semaphore_waiter waiter;</FONT></P>
<P><FONT class=extract>&nbsp;list_add_tail(&amp;waiter.list, &amp;sem-&gt;wait_list);<BR>&nbsp;waiter.task = task;<BR>&nbsp;waiter.up = false;</FONT></P>
<P><FONT class=extract>&nbsp;for (;;) {<BR>&nbsp;&nbsp;if (signal_pending_state(state, task))<BR>&nbsp;&nbsp;&nbsp;goto interrupted;<BR>&nbsp;&nbsp;if (unlikely(timeout &lt;= 0))<BR>&nbsp;&nbsp;&nbsp;goto timed_out;<BR>&nbsp;&nbsp;__set_task_state(task, state);<BR>&nbsp;&nbsp;raw_spin_unlock_irq(&amp;sem-&gt;lock);<BR>&nbsp;&nbsp;timeout = schedule_timeout(timeout);<BR>&nbsp;&nbsp;raw_spin_lock_irq(&amp;sem-&gt;lock);<BR>&nbsp;&nbsp;if (waiter.up)<BR>&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;timed_out:<BR>&nbsp;list_del(&amp;waiter.list);<BR>&nbsp;return -ETIME;</FONT></P>
<P><FONT class=extract>&nbsp;interrupted:<BR>&nbsp;list_del(&amp;waiter.list);<BR>&nbsp;return -EINTR;<BR>}</FONT></P>
<P><FONT class=extract>static noinline void __sched __down(struct semaphore *sem)<BR>{<BR>&nbsp;__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);<BR>}</FONT></P>
<P><FONT class=extract>static noinline int __sched __down_interruptible(struct semaphore *sem)<BR>{<BR>&nbsp;return __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);<BR>}</FONT></P>
<P><FONT class=extract>static noinline int __sched __down_killable(struct semaphore *sem)<BR>{<BR>&nbsp;return __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);<BR>}</FONT></P>
<P><FONT class=extract>static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)<BR>{<BR>&nbsp;return __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);<BR>}</FONT></P>
<P><FONT class=extract>static noinline void __sched __up(struct semaphore *sem)<BR>{<BR>&nbsp;struct semaphore_waiter *waiter = list_first_entry(&amp;sem-&gt;wait_list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct semaphore_waiter, list);<BR>&nbsp;list_del(&amp;waiter-&gt;list);<BR>&nbsp;waiter-&gt;up = true;<BR>&nbsp;wake_up_process(waiter-&gt;task);<BR>}</FONT>