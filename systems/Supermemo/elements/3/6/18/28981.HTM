/**<BR>&nbsp;* schedule_timeout - sleep until timeout<BR>&nbsp;* @timeout: timeout value in jiffies<BR>&nbsp;*<BR>&nbsp;* Make the current task sleep until @timeout jiffies have<BR>&nbsp;* elapsed. The routine will return immediately unless<BR>&nbsp;* the current task state has been set (see set_current_state()).<BR>&nbsp;*<BR>&nbsp;* You can set the task state as follows -<BR>&nbsp;*<BR>&nbsp;* %TASK_UNINTERRUPTIBLE - at least @timeout jiffies are guaranteed to<BR>&nbsp;* pass before the routine returns. The routine will return 0<BR>&nbsp;*<BR>&nbsp;* %TASK_INTERRUPTIBLE - the routine may return early if a signal is<BR>&nbsp;* delivered to the current task. In this case the remaining time<BR>&nbsp;* in jiffies will be returned, or 0 if the timer expired in time<BR>&nbsp;*<BR>&nbsp;* The current task state is guaranteed to be TASK_RUNNING when this<BR>&nbsp;* routine returns.<BR>&nbsp;*<BR>&nbsp;* Specifying a @timeout value of %MAX_SCHEDULE_TIMEOUT will schedule<BR>&nbsp;* the CPU away without a bound on the timeout. In this case the return<BR>&nbsp;* value will be %MAX_SCHEDULE_TIMEOUT.<BR>&nbsp;*<BR>&nbsp;* In all cases the return value is guaranteed to be non-negative.<BR>&nbsp;*/<BR>signed long __sched schedule_timeout(signed long timeout)<BR>{<BR>&nbsp;struct timer_list timer;<BR>&nbsp;unsigned long expire; 
<P></P>
<P>&nbsp;switch (timeout)<BR>&nbsp;{<BR>&nbsp;case MAX_SCHEDULE_TIMEOUT:<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * These two special cases are useful to be comfortable<BR>&nbsp;&nbsp; * in the caller. Nothing more. We could take<BR>&nbsp;&nbsp; * MAX_SCHEDULE_TIMEOUT from one of the negative value<BR>&nbsp;&nbsp; * but I' d like to return a valid offset (&gt;=0) to allow<BR>&nbsp;&nbsp; * the caller to do everything it want with the retval.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;schedule();<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;default:<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Another bit of PARANOID. Note that the retval will be<BR>&nbsp;&nbsp; * 0 since no piece of kernel is supposed to do a check<BR>&nbsp;&nbsp; * for a negative retval of schedule_timeout() (since it<BR>&nbsp;&nbsp; * should never happens anyway). You just have the printk()<BR>&nbsp;&nbsp; * that will tell you if something is gone wrong and where.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (timeout &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;printk(KERN_ERR "schedule_timeout: wrong timeout "<BR>&nbsp;&nbsp;&nbsp;&nbsp;"value %lx\n", timeout);<BR>&nbsp;&nbsp;&nbsp;dump_stack();<BR>&nbsp;&nbsp;&nbsp;current-&gt;state = TASK_RUNNING;<BR>&nbsp;&nbsp;&nbsp;goto out;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;expire = timeout + jiffies;</P>
<P><SPAN class=cloze>[...]</SPAN>;<BR>&nbsp;__mod_timer(&amp;timer, expire, false, TIMER_NOT_PINNED);<BR>&nbsp;schedule();<BR>&nbsp;del_singleshot_timer_sync(&amp;timer);</P>
<P>&nbsp;/* Remove the timer from the object tracker */<BR>&nbsp;destroy_timer_on_stack(&amp;timer);</P>
<P>&nbsp;timeout = expire - jiffies;</P>
<P>&nbsp;out:<BR>&nbsp;return timeout &lt; 0 ? 0 : timeout;<BR>}<BR>EXPORT_SYMBOL(schedule_timeout);