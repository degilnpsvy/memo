/**<BR>&nbsp;* mod_timer - modify a timer's timeout<BR>&nbsp;* @timer: the timer to be modified<BR>&nbsp;* @expires: new timeout in jiffies<BR>&nbsp;*<BR>&nbsp;* mod_timer() is a more efficient way to update the expire field of an<BR>&nbsp;* active timer (if the timer is inactive it will be activated)<BR>&nbsp;*<BR>&nbsp;* mod_timer(timer, expires) is equivalent to:<BR>&nbsp;*<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; <SPAN class=cloze>[...]</SPAN><BR>&nbsp;*<BR>&nbsp;* Note that if there are multiple unserialized concurrent users of the<BR>&nbsp;* same timer, then mod_timer() is the only safe way to modify the timeout,<BR>&nbsp;* since add_timer() cannot modify an already running timer.<BR>&nbsp;*<BR>&nbsp;* The function returns whether it has modified a pending timer or not.<BR>&nbsp;* (ie. mod_timer() of an inactive timer returns 0, mod_timer() of an<BR>&nbsp;* active timer returns 1.)<BR>&nbsp;*/<BR>int mod_timer(struct timer_list *timer, unsigned long expires)<BR>{<BR>&nbsp;expires = apply_slack(timer, expires); 
<P></P>
<P>&nbsp;/*<BR>&nbsp; * This is a common optimization triggered by the<BR>&nbsp; * networking code - if the timer is re-modified<BR>&nbsp; * to be the same thing then just return:<BR>&nbsp; */<BR>&nbsp;if (timer_pending(timer) &amp;&amp; timer-&gt;expires == expires)<BR>&nbsp;&nbsp;return 1;</P>
<P>&nbsp;return __mod_timer(timer, expires, false, TIMER_NOT_PINNED);<BR>}<BR>EXPORT_SYMBOL(mod_timer);