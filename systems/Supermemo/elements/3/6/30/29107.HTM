<DIV class=titlepage>
<DIV>
<DIV>
<H1 class=title>Nested Execution of Exception and Interrupt Handlers</H1></DIV></DIV></DIV>
<P><A id=IXT-4-477 class=indexterm></A><A id=IXT-4-478 class=indexterm></A>When handling an interrupt or an exception, the kernel begins a new <SPAN class=emphasis><EM>kernel control path</EM></SPAN> <A id=IXT-4-479 class=indexterm></A>, or separate sequence of instructions. When a process issues a system call request, for instance, the first instructions of the corresponding kernel control path are those that save the content of the registers in the Kernel Mode stack, while the last instructions are those that restore the content of the registers and put the CPU back into User Mode. </P>
<P>Linux design does not allow process switching while the CPU is executing a kernel control path associated with an interrupt. However, such kernel control paths may be arbitrarily nested; an interrupt handler may be interrupted by another interrupt handler, thus giving raise to a nested execution of kernel threads. We emphasize that the current process doesn&#8217;t change while the kernel is handling a nested set of kernel control paths. </P>
<P>Assuming that the kernel is bug free, most exceptions can occur only while the CPU is in <A id=IXT-4-480 class=indexterm></A>User Mode. Indeed, they are either caused by programming errors or triggered by debuggers. However, the <A id=IXT-4-481 class=indexterm></A>Page Fault exception may occur in <A id=IXT-4-482 class=indexterm></A>Kernel Mode. This happens when the process attempts to address a page that belongs to its address space but is not currently in RAM. While handling such an exception, the kernel may suspend the current process and replace it with another one until the requested page is available. The kernel control path that handles the Page fault exception resumes execution as soon as the process gets the processor again. </P>
<P>Since the Page Fault exception handler never gives rise to further exceptions, at most two kernel control paths associated with exceptions (the first one caused by a system call invocation, the second one caused by a Page Fault) may be stacked, one on top of the other. </P>
<P>In contrast to exceptions, interrupts issued by I/O devices do not refer to data structures specific to the current process, although the kernel control paths that handle them run on behalf of that process. As a matter of fact, it is impossible to predict which process will be running when a given interrupt occurs. </P>
<P>An interrupt handler may preempt both other <A id=IXT-4-483 class=indexterm></A>interrupt handlers and exception handlers. Conversely, an exception handler never preempts an interrupt handler. The only exception that can be triggered in Kernel Mode is Page Fault, which we just described. But interrupt handlers never perform operations that can induce Page Faults, and thus, potentially, process switch. </P>
<P><A id=IXT-4-484 class=indexterm></A><A id=IXT-4-485 class=indexterm></A>Linux interleaves kernel control paths for two major reasons: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist>
<LI class=listitem>
<P>To improve the throughput of programmable interrupt controllers and device controllers. Assume that a device controller issues a signal on an IRQ line: the PIC transforms it into an external interrupt, and then both the PIC and the device controller remain blocked until the PIC receives an acknowledgment from the CPU. Thanks to kernel control path interleaving, the kernel is able to send the acknowledgment even when it is handling a previous interrupt. </P>
<LI class=listitem>
<P>To implement an interrupt model without priority levels. Since each interrupt handler may be deferred by another one, there is no need to establish predefined priorities among hardware devices. This simplifies the kernel code and improves its portability. </P></LI></UL></DIV>
<P>On multiprocessor systems, several kernel control paths may execute concurrently. Moreover, a kernel control path associated with an exception may start executing on a CPU and, due to a process switch, migrate on another CPU.