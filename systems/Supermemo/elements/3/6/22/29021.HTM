lib/list_sort.c 
<P></P>
<P>#define pr_fmt(fmt) "list_sort_test: " fmt</P>
<P></P>
<P>#include &lt;linux/kernel.h&gt;<BR>#include &lt;linux/bug.h&gt;<BR>#include &lt;linux/compiler.h&gt;<BR>#include &lt;linux/export.h&gt;<BR>#include &lt;linux/string.h&gt;<BR>#include &lt;linux/list_sort.h&gt;<BR>#include &lt;linux/list.h&gt;</P>
<P>#define MAX_LIST_LENGTH_BITS 20</P>
<P>/*<BR>&nbsp;* Returns a list organized in an intermediate format suited<BR>&nbsp;* to chaining of merge() calls: null-terminated, no reserved or<BR>&nbsp;* sentinel head node, "prev" links not maintained.<BR>&nbsp;*/<BR>static struct list_head *merge(void *priv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;int (*cmp)(void *priv, struct list_head *a,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list_head *b),<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct list_head *a, struct list_head *b)<BR>{<BR>&nbsp;struct list_head head, *tail = &amp;head;</P>
<P>&nbsp;while (a &amp;&amp; b) {<BR>&nbsp;&nbsp;/* if equal, take 'a' -- important for sort stability */<BR>&nbsp;&nbsp;if ((*cmp)(priv, a, b) &lt;= 0) {<BR>&nbsp;&nbsp;&nbsp;tail-&gt;next = a;<BR>&nbsp;&nbsp;&nbsp;a = a-&gt;next;<BR>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;tail-&gt;next = b;<BR>&nbsp;&nbsp;&nbsp;b = b-&gt;next;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;tail = tail-&gt;next;<BR>&nbsp;}<BR>&nbsp;tail-&gt;next = a?:b;<BR>&nbsp;return head.next;<BR>}</P>
<P>/*<BR>&nbsp;* Combine final list merge with restoration of standard doubly-linked<BR>&nbsp;* list structure.&nbsp; This approach duplicates code from merge(), but<BR>&nbsp;* runs faster than the tidier alternatives of either a separate final<BR>&nbsp;* prev-link restoration pass, or maintaining the prev links<BR>&nbsp;* throughout.<BR>&nbsp;*/<BR>static void merge_and_restore_back_links(void *priv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;int (*cmp)(void *priv, struct list_head *a,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct list_head *b),<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct list_head *head,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct list_head *a, struct list_head *b)<BR>{<BR>&nbsp;struct list_head *tail = head;<BR>&nbsp;u8 count = 0;</P>
<P>&nbsp;while (a &amp;&amp; b) {<BR>&nbsp;&nbsp;/* if equal, take 'a' -- important for sort stability */<BR>&nbsp;&nbsp;if ((*cmp)(priv, a, b) &lt;= 0) {<BR>&nbsp;&nbsp;&nbsp;tail-&gt;next = a;<BR>&nbsp;&nbsp;&nbsp;a-&gt;prev = tail;<BR>&nbsp;&nbsp;&nbsp;a = a-&gt;next;<BR>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;tail-&gt;next = b;<BR>&nbsp;&nbsp;&nbsp;b-&gt;prev = tail;<BR>&nbsp;&nbsp;&nbsp;b = b-&gt;next;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;tail = tail-&gt;next;<BR>&nbsp;}<BR>&nbsp;tail-&gt;next = a ? : b;</P>
<P>&nbsp;do {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * In worst cases this loop may run many iterations.<BR>&nbsp;&nbsp; * Continue callbacks to the client even though no<BR>&nbsp;&nbsp; * element comparison is needed, so the client's cmp()<BR>&nbsp;&nbsp; * routine can invoke cond_resched() periodically.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (unlikely(!(++count)))<BR>&nbsp;&nbsp;&nbsp;(*cmp)(priv, tail-&gt;next, tail-&gt;next);</P>
<P>&nbsp;&nbsp;tail-&gt;next-&gt;prev = tail;<BR>&nbsp;&nbsp;tail = tail-&gt;next;<BR>&nbsp;} while (tail-&gt;next);</P>
<P>&nbsp;tail-&gt;next = head;<BR>&nbsp;head-&gt;prev = tail;<BR>}</P>
<P>/**<BR>&nbsp;* list_sort - sort a list<BR>&nbsp;* @priv: private data, opaque to list_sort(), passed to @cmp<BR>&nbsp;* @head: the list to sort<BR>&nbsp;* @cmp: the elements comparison function<BR>&nbsp;*<BR>&nbsp;* This function implements "merge sort", which has O(nlog(n))<BR>&nbsp;* complexity.<BR>&nbsp;*<BR>&nbsp;* The comparison function @cmp must return a negative value if @a<BR>&nbsp;* should sort before @b, and a positive value if @a should sort after<BR>&nbsp;* @b. If @a and @b are equivalent, and their original relative<BR>&nbsp;* ordering is to be preserved, @cmp must return 0.<BR>&nbsp;*/<BR>void list_sort(void *priv, struct list_head *head,<BR>&nbsp;&nbsp;int (*cmp)(void *priv, struct list_head *a,<BR>&nbsp;&nbsp;&nbsp;struct list_head *b))<BR>{<BR>&nbsp;struct list_head *part[MAX_LIST_LENGTH_BITS+1]; /* sorted partial lists<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- last slot is a sentinel */<BR>&nbsp;int lev;&nbsp; /* index into part[] */<BR>&nbsp;int max_lev = 0;<BR>&nbsp;struct list_head *list;</P>
<P>&nbsp;if (list_empty(head))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;memset(part, 0, sizeof(part));</P>
<P>&nbsp;head-&gt;prev-&gt;next = NULL;<BR>&nbsp;list = head-&gt;next;</P>
<P>&nbsp;while (list) {<BR>&nbsp;&nbsp;struct list_head *cur = list;<BR>&nbsp;&nbsp;list = list-&gt;next;<BR>&nbsp;&nbsp;cur-&gt;next = NULL;</P>
<P>&nbsp;&nbsp;for (lev = 0; part[lev]; lev++) {<BR>&nbsp;&nbsp;&nbsp;cur = merge(priv, cmp, part[lev], cur);<BR>&nbsp;&nbsp;&nbsp;part[lev] = NULL;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;if (lev &gt; max_lev) {<BR>&nbsp;&nbsp;&nbsp;if (unlikely(lev &gt;= ARRAY_SIZE(part)-1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;printk_once(KERN_DEBUG "list too long for efficiency\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;lev--;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;max_lev = lev;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;part[lev] = cur;<BR>&nbsp;}</P>
<P>&nbsp;for (lev = 0; lev &lt; max_lev; lev++)<BR>&nbsp;&nbsp;if (part[lev])<BR>&nbsp;&nbsp;&nbsp;list = merge(priv, cmp, part[lev], list);</P>
<P>&nbsp;merge_and_restore_back_links(priv, cmp, head, part[max_lev], list);<BR>}<BR>EXPORT_SYMBOL(list_sort);</P>
<P>#ifdef CONFIG_TEST_LIST_SORT</P>
<P>#include &lt;linux/slab.h&gt;<BR>#include &lt;linux/random.h&gt;</P>
<P>/*<BR>&nbsp;* The pattern of set bits in the list length determines which cases<BR>&nbsp;* are hit in list_sort().<BR>&nbsp;*/<BR>#define TEST_LIST_LEN (512+128+2) /* not including head */</P>
<P>#define TEST_POISON1 0xDEADBEEF<BR>#define TEST_POISON2 0xA324354C</P>
<P>struct debug_el {<BR>&nbsp;unsigned int poison1;<BR>&nbsp;struct list_head list;<BR>&nbsp;unsigned int poison2;<BR>&nbsp;int value;<BR>&nbsp;unsigned serial;<BR>};</P>
<P>/* Array, containing pointers to all elements in the test list */<BR>static struct debug_el **elts __initdata;</P>
<P>static int __init check(struct debug_el *ela, struct debug_el *elb)<BR>{<BR>&nbsp;if (ela-&gt;serial &gt;= TEST_LIST_LEN) {<BR>&nbsp;&nbsp;pr_err("error: incorrect serial %d\n", ela-&gt;serial);<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;}<BR>&nbsp;if (elb-&gt;serial &gt;= TEST_LIST_LEN) {<BR>&nbsp;&nbsp;pr_err("error: incorrect serial %d\n", elb-&gt;serial);<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;}<BR>&nbsp;if (elts[ela-&gt;serial] != ela || elts[elb-&gt;serial] != elb) {<BR>&nbsp;&nbsp;pr_err("error: phantom element\n");<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;}<BR>&nbsp;if (ela-&gt;poison1 != TEST_POISON1 || ela-&gt;poison2 != TEST_POISON2) {<BR>&nbsp;&nbsp;pr_err("error: bad poison: %#x/%#x\n",<BR>&nbsp;&nbsp;&nbsp;ela-&gt;poison1, ela-&gt;poison2);<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;}<BR>&nbsp;if (elb-&gt;poison1 != TEST_POISON1 || elb-&gt;poison2 != TEST_POISON2) {<BR>&nbsp;&nbsp;pr_err("error: bad poison: %#x/%#x\n",<BR>&nbsp;&nbsp;&nbsp;elb-&gt;poison1, elb-&gt;poison2);<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;}<BR>&nbsp;return 0;<BR>}</P>
<P>static int __init cmp(void *priv, struct list_head *a, struct list_head *b)<BR>{<BR>&nbsp;struct debug_el *ela, *elb;</P>
<P>&nbsp;ela = container_of(a, struct debug_el, list);<BR>&nbsp;elb = container_of(b, struct debug_el, list);</P>
<P>&nbsp;check(ela, elb);<BR>&nbsp;return ela-&gt;value - elb-&gt;value;<BR>}</P>
<P>static int __init list_sort_test(void)<BR>{<BR>&nbsp;int i, count = 1, err = -ENOMEM;<BR>&nbsp;struct debug_el *el;<BR>&nbsp;struct list_head *cur;<BR>&nbsp;LIST_HEAD(head);</P>
<P>&nbsp;pr_debug("start testing list_sort()\n");</P>
<P>&nbsp;elts = kcalloc(TEST_LIST_LEN, sizeof(*elts), GFP_KERNEL);<BR>&nbsp;if (!elts) {<BR>&nbsp;&nbsp;pr_err("error: cannot allocate memory\n");<BR>&nbsp;&nbsp;return err;<BR>&nbsp;}</P>
<P>&nbsp;for (i = 0; i &lt; TEST_LIST_LEN; i++) {<BR>&nbsp;&nbsp;el = kmalloc(sizeof(*el), GFP_KERNEL);<BR>&nbsp;&nbsp;if (!el) {<BR>&nbsp;&nbsp;&nbsp;pr_err("error: cannot allocate memory\n");<BR>&nbsp;&nbsp;&nbsp;goto exit;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp; /* force some equivalencies */<BR>&nbsp;&nbsp;el-&gt;value = prandom_u32() % (TEST_LIST_LEN / 3);<BR>&nbsp;&nbsp;el-&gt;serial = i;<BR>&nbsp;&nbsp;el-&gt;poison1 = TEST_POISON1;<BR>&nbsp;&nbsp;el-&gt;poison2 = TEST_POISON2;<BR>&nbsp;&nbsp;elts[i] = el;<BR>&nbsp;&nbsp;list_add_tail(&amp;el-&gt;list, &amp;head);<BR>&nbsp;}</P>
<P>&nbsp;list_sort(NULL, &amp;head, cmp);</P>
<P>&nbsp;err = -EINVAL;<BR>&nbsp;for (cur = head.next; cur-&gt;next != &amp;head; cur = cur-&gt;next) {<BR>&nbsp;&nbsp;struct debug_el *el1;<BR>&nbsp;&nbsp;int cmp_result;</P>
<P>&nbsp;&nbsp;if (cur-&gt;next-&gt;prev != cur) {<BR>&nbsp;&nbsp;&nbsp;pr_err("error: list is corrupted\n");<BR>&nbsp;&nbsp;&nbsp;goto exit;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;cmp_result = cmp(NULL, cur, cur-&gt;next);<BR>&nbsp;&nbsp;if (cmp_result &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;pr_err("error: list is not sorted\n");<BR>&nbsp;&nbsp;&nbsp;goto exit;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;el = container_of(cur, struct debug_el, list);<BR>&nbsp;&nbsp;el1 = container_of(cur-&gt;next, struct debug_el, list);<BR>&nbsp;&nbsp;if (cmp_result == 0 &amp;&amp; el-&gt;serial &gt;= el1-&gt;serial) {<BR>&nbsp;&nbsp;&nbsp;pr_err("error: order of equivalent elements not "<BR>&nbsp;&nbsp;&nbsp;&nbsp;"preserved\n");<BR>&nbsp;&nbsp;&nbsp;goto exit;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;if (check(el, el1)) {<BR>&nbsp;&nbsp;&nbsp;pr_err("error: element check failed\n");<BR>&nbsp;&nbsp;&nbsp;goto exit;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;count++;<BR>&nbsp;}<BR>&nbsp;if (head.prev != cur) {<BR>&nbsp;&nbsp;pr_err("error: list is corrupted\n");<BR>&nbsp;&nbsp;goto exit;<BR>&nbsp;}</P>
<P><BR>&nbsp;if (count != TEST_LIST_LEN) {<BR>&nbsp;&nbsp;pr_err("error: bad list length %d", count);<BR>&nbsp;&nbsp;goto exit;<BR>&nbsp;}</P>
<P>&nbsp;err = 0;<BR>exit:<BR>&nbsp;for (i = 0; i &lt; TEST_LIST_LEN; i++)<BR>&nbsp;&nbsp;kfree(elts[i]);<BR>&nbsp;kfree(elts);<BR>&nbsp;return err;<BR>}<BR>late_initcall(list_sort_test);<BR>#endif /* CONFIG_TEST_LIST_SORT */