void __init trap_init(void)<BR>{<BR>&nbsp;int i;
<P></P>
<P>#ifdef CONFIG_EISA<BR>&nbsp;void __iomem *p = early_ioremap(0x0FFFD9, 4);</P>
<P>&nbsp;if (readl(p) == 'E' + ('I'&lt;&lt;8) + ('S'&lt;&lt;16) + ('A'&lt;&lt;24))<BR>&nbsp;&nbsp;EISA_bus = 1;<BR>&nbsp;early_iounmap(p, 4);<BR>#endif</P>
<P>&nbsp;set_intr_gate(X86_TRAP_DE, divide_error);<BR>&nbsp;set_intr_gate_ist(X86_TRAP_NMI, &amp;nmi, NMI_STACK);<BR>&nbsp;/* int4 can be called from all */<BR>&nbsp;set_system_intr_gate(X86_TRAP_OF, &amp;overflow);<BR>&nbsp;set_intr_gate(X86_TRAP_BR, bounds);<BR>&nbsp;set_intr_gate(X86_TRAP_UD, invalid_op);<BR>&nbsp;set_intr_gate(X86_TRAP_NM, device_not_available);<BR>#ifdef CONFIG_X86_32<BR>&nbsp;set_task_gate(X86_TRAP_DF, GDT_ENTRY_DOUBLEFAULT_TSS);<BR>#else<BR>&nbsp;set_intr_gate_ist(X86_TRAP_DF, &amp;double_fault, DOUBLEFAULT_STACK);<BR>#endif<BR>&nbsp;set_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);<BR>&nbsp;set_intr_gate(X86_TRAP_TS, invalid_TSS);<BR>&nbsp;set_intr_gate(X86_TRAP_NP, segment_not_present);<BR>&nbsp;set_intr_gate(X86_TRAP_SS, stack_segment);<BR>&nbsp;set_intr_gate(X86_TRAP_GP, general_protection);<BR>&nbsp;set_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);<BR>&nbsp;set_intr_gate(X86_TRAP_MF, coprocessor_error);<BR>&nbsp;set_intr_gate(X86_TRAP_AC, alignment_check);<BR>#ifdef CONFIG_X86_MCE<BR>&nbsp;set_intr_gate_ist(X86_TRAP_MC, &amp;machine_check, MCE_STACK);<BR>#endif<BR>&nbsp;set_intr_gate(X86_TRAP_XF, simd_coprocessor_error);</P>
<P>&nbsp;/* Reserve all the builtin and the syscall vector: */<BR>&nbsp;for (i = 0; i &lt; FIRST_EXTERNAL_VECTOR; i++)<BR>&nbsp;&nbsp;set_bit(i, used_vectors);</P>
<P>#ifdef CONFIG_IA32_EMULATION<BR>&nbsp;set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_compat);<BR>&nbsp;set_bit(IA32_SYSCALL_VECTOR, used_vectors);<BR>#endif</P>
<P>#ifdef CONFIG_X86_32<BR>&nbsp;set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32);<BR>&nbsp;set_bit(IA32_SYSCALL_VECTOR, used_vectors);<BR>#endif</P>
<P>&nbsp;/*<BR>&nbsp; * Set the IDT descriptor to a fixed read-only location, so that the<BR>&nbsp; * "sidt" instruction will not leak the location of the kernel, and<BR>&nbsp; * to defend the IDT against arbitrary memory write vulnerabilities.<BR>&nbsp; * It will be reloaded in cpu_init() */<BR>&nbsp;__set_fixmap(FIX_RO_IDT, __pa_symbol(idt_table), PAGE_KERNEL_RO);<BR>&nbsp;idt_descr.address = fix_to_virt(FIX_RO_IDT);</P>
<P>&nbsp;/*<BR>&nbsp; * Should be a barrier for any external CPU state:<BR>&nbsp; */<BR>&nbsp;cpu_init();</P>
<P>&nbsp;/*<BR>&nbsp; * X86_TRAP_DB and X86_TRAP_BP have been set<BR>&nbsp; * in early_trap_init(). However, ITS works only after<BR>&nbsp; * cpu_init() loads TSS. See comments in early_trap_init().<BR>&nbsp; */<BR>&nbsp;set_intr_gate_ist(X86_TRAP_DB, &amp;debug, DEBUG_STACK);<BR>&nbsp;/* int3 can be called from all */<BR>&nbsp;set_system_intr_gate_ist(X86_TRAP_BP, &amp;int3, DEBUG_STACK);</P>
<P>&nbsp;x86_init.irqs.trap_init();</P>
<P>#ifdef CONFIG_X86_64<BR>&nbsp;memcpy(&amp;debug_idt_table, &amp;idt_table, IDT_ENTRIES * 16);<BR>&nbsp;set_nmi_gate(X86_TRAP_DB, &amp;debug);<BR>&nbsp;set_nmi_gate(X86_TRAP_BP, &amp;int3);<BR>#endif<BR>}