/*<BR>&nbsp;* Deferred Probe infrastructure.<BR>&nbsp;*<BR>&nbsp;* Sometimes driver probe order matters, but the kernel doesn't always have<BR>&nbsp;* dependency information which means some drivers will get probed before a<BR>&nbsp;* resource it depends on is available.&nbsp; For example, an SDHCI driver may<BR>&nbsp;* first need a GPIO line from an i2c GPIO controller before it can be<BR>&nbsp;* initialized.&nbsp; If a required resource is not available yet, a driver can<BR>&nbsp;* request probing to be deferred by returning -EPROBE_DEFER from its probe hook<BR>&nbsp;*<BR>&nbsp;* Deferred probe maintains two lists of devices, a pending list and an active<BR>&nbsp;* list.&nbsp; A driver returning -EPROBE_DEFER causes the device to be added to the<BR>&nbsp;* pending list.&nbsp; A successful driver probe will trigger moving all devices<BR>&nbsp;* from the pending to the active list so that the workqueue will eventually<BR>&nbsp;* retry them.<BR>&nbsp;*<BR>&nbsp;* The deferred_probe_mutex must be held any time the deferred_probe_*_list<BR>&nbsp;* of the (struct device*)-&gt;p-&gt;deferred_probe pointers are manipulated<BR>&nbsp;*/<BR>static DEFINE_MUTEX(deferred_probe_mutex);<BR>static LIST_HEAD(deferred_probe_pending_list);<BR>static LIST_HEAD(deferred_probe_active_list);<BR>static struct workqueue_struct *deferred_wq;<BR>static atomic_t deferred_trigger_count = ATOMIC_INIT(0); 
<P></P>
<P>/*<BR>&nbsp;* In some cases, like suspend to RAM or hibernation, It might be reasonable<BR>&nbsp;* to prohibit probing of devices as it could be unsafe.<BR>&nbsp;* Once defer_all_probes is true all drivers probes will be forcibly deferred.<BR>&nbsp;*/<BR>static bool defer_all_probes;</P>
<P>/*<BR>&nbsp;* deferred_probe_work_func() - Retry probing devices in the active list.<BR>&nbsp;*/<BR>static void deferred_probe_work_func(struct work_struct *work)<BR>{<BR>&nbsp;struct device *dev;<BR>&nbsp;struct device_private *private;<BR>&nbsp;/*<BR>&nbsp; * This block processes every device in the deferred 'active' list.<BR>&nbsp; * Each device is removed from the active list and passed to<BR>&nbsp; * bus_probe_device() to re-attempt the probe.&nbsp; The loop continues<BR>&nbsp; * until every device in the active list is removed and retried.<BR>&nbsp; *<BR>&nbsp; * Note: Once the device is removed from the list and the mutex is<BR>&nbsp; * released, it is possible for the device get freed by another thread<BR>&nbsp; * and cause a illegal pointer dereference.&nbsp; This code uses<BR>&nbsp; * get/put_device() to ensure the device structure cannot disappear<BR>&nbsp; * from under our feet.<BR>&nbsp; */<BR>&nbsp;mutex_lock(&amp;deferred_probe_mutex);<BR>&nbsp;while (!list_empty(&amp;deferred_probe_active_list)) {<BR>&nbsp;&nbsp;private = list_first_entry(&amp;deferred_probe_active_list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeof(*dev-&gt;p), deferred_probe);<BR>&nbsp;&nbsp;dev = private-&gt;device;<BR>&nbsp;&nbsp;list_del_init(&amp;private-&gt;deferred_probe);</P>
<P>&nbsp;&nbsp;get_device(dev);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Drop the mutex while probing each device; the probe path may<BR>&nbsp;&nbsp; * manipulate the deferred list<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;mutex_unlock(&amp;deferred_probe_mutex);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Force the device to the end of the dpm_list since<BR>&nbsp;&nbsp; * the PM code assumes that the order we add things to<BR>&nbsp;&nbsp; * the list is a good order for suspend but deferred<BR>&nbsp;&nbsp; * probe makes that very unsafe.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;device_pm_lock();<BR>&nbsp;&nbsp;device_pm_move_last(dev);<BR>&nbsp;&nbsp;device_pm_unlock();</P>
<P>&nbsp;&nbsp;dev_dbg(dev, "Retrying from deferred list\n");<BR>&nbsp;&nbsp;bus_probe_device(dev);</P>
<P>&nbsp;&nbsp;mutex_lock(&amp;deferred_probe_mutex);</P>
<P>&nbsp;&nbsp;put_device(dev);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;deferred_probe_mutex);<BR>}<BR>static DECLARE_WORK(deferred_probe_work, deferred_probe_work_func);</P>
<P>static void driver_deferred_probe_add(struct device *dev)<BR>{<BR>&nbsp;mutex_lock(&amp;deferred_probe_mutex);<BR>&nbsp;if (list_empty(&amp;dev-&gt;p-&gt;deferred_probe)) {<BR>&nbsp;&nbsp;dev_dbg(dev, "Added to deferred list\n");<BR>&nbsp;&nbsp;list_add_tail(&amp;dev-&gt;p-&gt;deferred_probe, &amp;deferred_probe_pending_list);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;deferred_probe_mutex);<BR>}</P>
<P>void driver_deferred_probe_del(struct device *dev)<BR>{<BR>&nbsp;mutex_lock(&amp;deferred_probe_mutex);<BR>&nbsp;if (!list_empty(&amp;dev-&gt;p-&gt;deferred_probe)) {<BR>&nbsp;&nbsp;dev_dbg(dev, "Removed from deferred list\n");<BR>&nbsp;&nbsp;list_del_init(&amp;dev-&gt;p-&gt;deferred_probe);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;deferred_probe_mutex);<BR>}</P>
<P>static bool driver_deferred_probe_enable = false;<BR>/**<BR>&nbsp;* driver_deferred_probe_trigger() - Kick off re-probing deferred devices<BR>&nbsp;*<BR>&nbsp;* This functions moves all devices from the pending list to the active<BR>&nbsp;* list and schedules the deferred probe workqueue to process them.&nbsp; It<BR>&nbsp;* should be called anytime a driver is successfully bound to a device.<BR>&nbsp;*<BR>&nbsp;* Note, there is a race condition in multi-threaded probe. In the case where<BR>&nbsp;* more than one device is probing at the same time, it is possible for one<BR>&nbsp;* probe to complete successfully while another is about to defer. If the second<BR>&nbsp;* depends on the first, then it will get put on the pending list after the<BR>&nbsp;* trigger event has already occurred and will be stuck there.<BR>&nbsp;*<BR>&nbsp;* The atomic 'deferred_trigger_count' is used to determine if a successful<BR>&nbsp;* trigger has occurred in the midst of probing a driver. If the trigger count<BR>&nbsp;* changes in the midst of a probe, then deferred processing should be triggered<BR>&nbsp;* again.<BR>&nbsp;*/<BR>static void driver_deferred_probe_trigger(void)<BR>{<BR>&nbsp;if (!driver_deferred_probe_enable)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/*<BR>&nbsp; * A successful probe means that all the devices in the pending list<BR>&nbsp; * should be triggered to be reprobed.&nbsp; Move all the deferred devices<BR>&nbsp; * into the active list so they can be retried by the workqueue<BR>&nbsp; */<BR>&nbsp;mutex_lock(&amp;deferred_probe_mutex);<BR>&nbsp;atomic_inc(&amp;deferred_trigger_count);<BR>&nbsp;list_splice_tail_init(&amp;deferred_probe_pending_list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;deferred_probe_active_list);<BR>&nbsp;mutex_unlock(&amp;deferred_probe_mutex);</P>
<P>&nbsp;/*<BR>&nbsp; * Kick the re-probe thread.&nbsp; It may already be scheduled, but it is<BR>&nbsp; * safe to kick it again.<BR>&nbsp; */<BR>&nbsp;queue_work(deferred_wq, &amp;deferred_probe_work);<BR>}