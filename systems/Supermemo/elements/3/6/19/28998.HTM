/*<BR><FONT class=extract>&nbsp;* drivers/base/dd.c - The core device/driver interactions.<BR>&nbsp;*<BR>&nbsp;* This file contains the (sometimes tricky) code that controls the<BR>&nbsp;* interactions between devices and drivers, which primarily includes<BR>&nbsp;* driver binding and unbinding.<BR>&nbsp;*<BR>&nbsp;* All of this code used to exist in drivers/base/bus.c, but was<BR>&nbsp;* relocated to here in the name of compartmentalization (since it wasn't<BR>&nbsp;* strictly code just for the 'struct bus_type'.</FONT><BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2002-5 Patrick Mochel<BR>&nbsp;* Copyright (c) 2002-3 Open Source Development Labs<BR>&nbsp;* Copyright (c) 2007-2009 Greg Kroah-Hartman &lt;<A href="mailto:gregkh@suse.de">gregkh@suse.de</A>&gt;<BR>&nbsp;* Copyright (c) 2007-2009 Novell Inc.<BR>&nbsp;*<BR>&nbsp;* This file is released under the GPLv2<BR>&nbsp;*/ 
<P></P>
<P>#include &lt;linux/device.h&gt;<BR>#include &lt;linux/delay.h&gt;<BR>#include &lt;linux/module.h&gt;<BR>#include &lt;linux/kthread.h&gt;<BR>#include &lt;linux/wait.h&gt;<BR>#include &lt;linux/async.h&gt;<BR>#include &lt;linux/pm_runtime.h&gt;<BR>#include &lt;linux/pinctrl/devinfo.h&gt;</P>
<P>#include "base.h"<BR>#include "power/power.h"</P>
<P><FONT class=extract>/*<BR>&nbsp;* Deferred Probe infrastructure.<BR>&nbsp;*<BR>&nbsp;* Sometimes driver probe order matters, but the kernel doesn't always have<BR>&nbsp;* dependency information which means some drivers will get probed before a<BR>&nbsp;* resource it depends on is available.&nbsp; For example, an SDHCI driver may<BR>&nbsp;* first need a GPIO line from an i2c GPIO controller before it can be<BR>&nbsp;* initialized.&nbsp; If a required resource is not available yet, a driver can<BR>&nbsp;* request probing to be deferred by returning -EPROBE_DEFER from its probe hook<BR>&nbsp;*<BR>&nbsp;* Deferred probe maintains two lists of devices, a pending list and an active<BR>&nbsp;* list.&nbsp; A driver returning -EPROBE_DEFER causes the device to be added to the<BR>&nbsp;* pending list.&nbsp; A successful driver probe will trigger moving all devices<BR>&nbsp;* from the pending to the active list so that the workqueue will eventually<BR>&nbsp;* retry them.<BR>&nbsp;*<BR>&nbsp;* The deferred_probe_mutex must be held any time the deferred_probe_*_list<BR>&nbsp;* of the (struct device*)-&gt;p-&gt;deferred_probe pointers are manipulated<BR>&nbsp;*/<BR>static DEFINE_MUTEX(deferred_probe_mutex);<BR>static LIST_HEAD(deferred_probe_pending_list);<BR>static LIST_HEAD(deferred_probe_active_list);<BR>static struct workqueue_struct *deferred_wq;<BR>static atomic_t deferred_trigger_count = ATOMIC_INIT(0);</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* In some cases, like suspend to RAM or hibernation, It might be reasonable<BR>&nbsp;* to prohibit probing of devices as it could be unsafe.<BR>&nbsp;* Once defer_all_probes is true all drivers probes will be forcibly deferred.<BR>&nbsp;*/<BR>static bool defer_all_probes;</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* deferred_probe_work_func() - Retry probing devices in the active list.<BR>&nbsp;*/<BR>static void deferred_probe_work_func(struct work_struct *work)<BR>{<BR>&nbsp;struct device *dev;<BR>&nbsp;struct device_private *private;<BR>&nbsp;/*<BR>&nbsp; * This block processes every device in the deferred 'active' list.<BR>&nbsp; * Each device is removed from the active list and passed to<BR>&nbsp; * bus_probe_device() to re-attempt the probe.&nbsp; The loop continues<BR>&nbsp; * until every device in the active list is removed and retried.<BR>&nbsp; *<BR>&nbsp; * Note: Once the device is removed from the list and the mutex is<BR>&nbsp; * released, it is possible for the device get freed by another thread<BR>&nbsp; * and cause a illegal pointer dereference.&nbsp; This code uses<BR>&nbsp; * get/put_device() to ensure the device structure cannot disappear<BR>&nbsp; * from under our feet.<BR>&nbsp; */<BR>&nbsp;mutex_lock(&amp;deferred_probe_mutex);<BR>&nbsp;while (!list_empty(&amp;deferred_probe_active_list)) {<BR>&nbsp;&nbsp;private = list_first_entry(&amp;deferred_probe_active_list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeof(*dev-&gt;p), deferred_probe);<BR>&nbsp;&nbsp;dev = private-&gt;device;<BR>&nbsp;&nbsp;list_del_init(&amp;private-&gt;deferred_probe);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;get_device(dev);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Drop the mutex while probing each device; the probe path may<BR>&nbsp;&nbsp; * manipulate the deferred list<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;mutex_unlock(&amp;deferred_probe_mutex);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Force the device to the end of the dpm_list since<BR>&nbsp;&nbsp; * the PM code assumes that the order we add things to<BR>&nbsp;&nbsp; * the list is a good order for suspend but deferred<BR>&nbsp;&nbsp; * probe makes that very unsafe.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;device_pm_lock();<BR>&nbsp;&nbsp;device_pm_move_last(dev);<BR>&nbsp;&nbsp;device_pm_unlock();</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;dev_dbg(dev, "Retrying from deferred list\n");<BR>&nbsp;&nbsp;bus_probe_device(dev);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;mutex_lock(&amp;deferred_probe_mutex);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;put_device(dev);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;deferred_probe_mutex);<BR>}<BR>static DECLARE_WORK(deferred_probe_work, deferred_probe_work_func);</FONT></P>
<P><FONT class=extract>static void driver_deferred_probe_add(struct device *dev)<BR>{<BR>&nbsp;mutex_lock(&amp;deferred_probe_mutex);<BR>&nbsp;if (list_empty(&amp;dev-&gt;p-&gt;deferred_probe)) {<BR>&nbsp;&nbsp;dev_dbg(dev, "Added to deferred list\n");<BR>&nbsp;&nbsp;list_add_tail(&amp;dev-&gt;p-&gt;deferred_probe, &amp;deferred_probe_pending_list);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;deferred_probe_mutex);<BR>}</FONT></P>
<P><FONT class=extract>void driver_deferred_probe_del(struct device *dev)<BR>{<BR>&nbsp;mutex_lock(&amp;deferred_probe_mutex);<BR>&nbsp;if (!list_empty(&amp;dev-&gt;p-&gt;deferred_probe)) {<BR>&nbsp;&nbsp;dev_dbg(dev, "Removed from deferred list\n");<BR>&nbsp;&nbsp;list_del_init(&amp;dev-&gt;p-&gt;deferred_probe);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;deferred_probe_mutex);<BR>}</FONT></P>
<P><FONT class=extract>static bool driver_deferred_probe_enable = false;<BR>/**<BR>&nbsp;* driver_deferred_probe_trigger() - Kick off re-probing deferred devices<BR>&nbsp;*<BR>&nbsp;* This functions moves all devices from the pending list to the active<BR>&nbsp;* list and schedules the deferred probe workqueue to process them.&nbsp; It<BR>&nbsp;* should be called anytime a driver is successfully bound to a device.<BR>&nbsp;*<BR>&nbsp;* Note, there is a race condition in multi-threaded probe. In the case where<BR>&nbsp;* more than one device is probing at the same time, it is possible for one<BR>&nbsp;* probe to complete successfully while another is about to defer. If the second<BR>&nbsp;* depends on the first, then it will get put on the pending list after the<BR>&nbsp;* trigger event has already occurred and will be stuck there.<BR>&nbsp;*<BR>&nbsp;* The atomic 'deferred_trigger_count' is used to determine if a successful<BR>&nbsp;* trigger has occurred in the midst of probing a driver. If the trigger count<BR>&nbsp;* changes in the midst of a probe, then deferred processing should be triggered<BR>&nbsp;* again.<BR>&nbsp;*/<BR>static void driver_deferred_probe_trigger(void)<BR>{<BR>&nbsp;if (!driver_deferred_probe_enable)<BR>&nbsp;&nbsp;return;</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * A successful probe means that all the devices in the pending list<BR>&nbsp; * should be triggered to be reprobed.&nbsp; Move all the deferred devices<BR>&nbsp; * into the active list so they can be retried by the workqueue<BR>&nbsp; */<BR>&nbsp;mutex_lock(&amp;deferred_probe_mutex);<BR>&nbsp;atomic_inc(&amp;deferred_trigger_count);<BR>&nbsp;list_splice_tail_init(&amp;deferred_probe_pending_list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;deferred_probe_active_list);<BR>&nbsp;mutex_unlock(&amp;deferred_probe_mutex);</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * Kick the re-probe thread.&nbsp; It may already be scheduled, but it is<BR>&nbsp; * safe to kick it again.<BR>&nbsp; */<BR>&nbsp;queue_work(deferred_wq, &amp;deferred_probe_work);<BR>}</FONT></P>
<P>/**<BR>&nbsp;* device_block_probing() - Block/defere device's probes<BR>&nbsp;*<BR>&nbsp;*&nbsp;It will disable probing of devices and defer their probes instead.<BR>&nbsp;*/<BR>void device_block_probing(void)<BR>{<BR>&nbsp;defer_all_probes = true;<BR>&nbsp;/* sync with probes to avoid races. */<BR>&nbsp;wait_for_device_probe();<BR>}</P>
<P>/**<BR>&nbsp;* device_unblock_probing() - Unblock/enable device's probes<BR>&nbsp;*<BR>&nbsp;*&nbsp;It will restore normal behavior and trigger re-probing of deferred<BR>&nbsp;* devices.<BR>&nbsp;*/<BR>void device_unblock_probing(void)<BR>{<BR>&nbsp;defer_all_probes = false;<BR>&nbsp;driver_deferred_probe_trigger();<BR>}</P>
<P>/**<BR>&nbsp;* deferred_probe_initcall() - Enable probing of deferred devices<BR>&nbsp;*<BR>&nbsp;* We don't want to get in the way when the bulk of drivers are getting probed.<BR>&nbsp;* Instead, this initcall makes sure that deferred probing is delayed until<BR>&nbsp;* late_initcall time.<BR>&nbsp;*/<BR>static int deferred_probe_initcall(void)<BR>{<BR>&nbsp;deferred_wq = create_singlethread_workqueue("deferwq");<BR>&nbsp;if (WARN_ON(!deferred_wq))<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;driver_deferred_probe_enable = true;<BR>&nbsp;driver_deferred_probe_trigger();<BR>&nbsp;/* Sort as many dependencies as possible before exiting initcalls */<BR>&nbsp;flush_workqueue(deferred_wq);<BR>&nbsp;return 0;<BR>}<BR>late_initcall(deferred_probe_initcall);</P>
<P>/**<BR>&nbsp;* device_is_bound() - Check if device is bound to a driver<BR>&nbsp;* @dev: device to check<BR>&nbsp;*<BR>&nbsp;* Returns true if passed device has already finished probing successfully<BR>&nbsp;* against a driver.<BR>&nbsp;*<BR>&nbsp;* This function must be called with the device lock held.<BR>&nbsp;*/<BR>bool device_is_bound(struct device *dev)<BR>{<BR>&nbsp;return dev-&gt;p &amp;&amp; klist_node_attached(&amp;dev-&gt;p-&gt;knode_driver);<BR>}</P>
<P>static void driver_bound(struct device *dev)<BR>{<BR>&nbsp;if (device_is_bound(dev)) {<BR>&nbsp;&nbsp;printk(KERN_WARNING "%s: device %s already bound\n",<BR>&nbsp;&nbsp;&nbsp;__func__, kobject_name(&amp;dev-&gt;kobj));<BR>&nbsp;&nbsp;return;<BR>&nbsp;}</P>
<P>&nbsp;pr_debug("driver: '%s': %s: bound to device '%s'\n", dev-&gt;driver-&gt;name,<BR>&nbsp;&nbsp; __func__, dev_name(dev));</P>
<P>&nbsp;klist_add_tail(&amp;dev-&gt;p-&gt;knode_driver, &amp;dev-&gt;driver-&gt;p-&gt;klist_devices);</P>
<P>&nbsp;device_pm_check_callbacks(dev);</P>
<P>&nbsp;/*<BR>&nbsp; * Make sure the device is no longer in one of the deferred lists and<BR>&nbsp; * kick off retrying all pending devices<BR>&nbsp; */<BR>&nbsp;driver_deferred_probe_del(dev);<BR>&nbsp;driver_deferred_probe_trigger();</P>
<P>&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_BOUND_DRIVER, dev);<BR>}</P>
<P>static int driver_sysfs_add(struct device *dev)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_BIND_DRIVER, dev);</P>
<P>&nbsp;ret = sysfs_create_link(&amp;dev-&gt;driver-&gt;p-&gt;kobj, &amp;dev-&gt;kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp; kobject_name(&amp;dev-&gt;kobj));<BR>&nbsp;if (ret == 0) {<BR>&nbsp;&nbsp;ret = sysfs_create_link(&amp;dev-&gt;kobj, &amp;dev-&gt;driver-&gt;p-&gt;kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"driver");<BR>&nbsp;&nbsp;if (ret)<BR>&nbsp;&nbsp;&nbsp;sysfs_remove_link(&amp;dev-&gt;driver-&gt;p-&gt;kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kobject_name(&amp;dev-&gt;kobj));<BR>&nbsp;}<BR>&nbsp;return ret;<BR>}</P>
<P>static void driver_sysfs_remove(struct device *dev)<BR>{<BR>&nbsp;struct device_driver *drv = dev-&gt;driver;</P>
<P>&nbsp;if (drv) {<BR>&nbsp;&nbsp;sysfs_remove_link(&amp;drv-&gt;p-&gt;kobj, kobject_name(&amp;dev-&gt;kobj));<BR>&nbsp;&nbsp;sysfs_remove_link(&amp;dev-&gt;kobj, "driver");<BR>&nbsp;}<BR>}</P>
<P>/**<BR>&nbsp;* device_bind_driver - bind a driver to one device.<BR>&nbsp;* @dev: device.<BR>&nbsp;*<BR>&nbsp;* Allow manual attachment of a driver to a device.<BR>&nbsp;* Caller must have already set @dev-&gt;driver.<BR>&nbsp;*<BR>&nbsp;* Note that this does not modify the bus reference count<BR>&nbsp;* nor take the bus's rwsem. Please verify those are accounted<BR>&nbsp;* for before calling this. (It is ok to call with no other effort<BR>&nbsp;* from a driver's probe() method.)<BR>&nbsp;*<BR>&nbsp;* This function must be called with the device lock held.<BR>&nbsp;*/<BR>int device_bind_driver(struct device *dev)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;ret = driver_sysfs_add(dev);<BR>&nbsp;if (!ret)<BR>&nbsp;&nbsp;driver_bound(dev);<BR>&nbsp;else if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_DRIVER_NOT_BOUND, dev);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(device_bind_driver);</P>
<P>static atomic_t probe_count = ATOMIC_INIT(0);<BR>static DECLARE_WAIT_QUEUE_HEAD(probe_waitqueue);</P>
<P>static int really_probe(struct device *dev, struct device_driver *drv)<BR>{<BR>&nbsp;int ret = -EPROBE_DEFER;<BR>&nbsp;int local_trigger_count = atomic_read(&amp;deferred_trigger_count);</P>
<P>&nbsp;if (defer_all_probes) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Value of defer_all_probes can be set only by<BR>&nbsp;&nbsp; * device_defer_all_probes_enable() which, in turn, will call<BR>&nbsp;&nbsp; * wait_for_device_probe() right after that to avoid any races.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;dev_dbg(dev, "Driver %s force probe deferral\n", drv-&gt;name);<BR>&nbsp;&nbsp;driver_deferred_probe_add(dev);<BR>&nbsp;&nbsp;return ret;<BR>&nbsp;}</P>
<P>&nbsp;atomic_inc(&amp;probe_count);<BR>&nbsp;pr_debug("bus: '%s': %s: probing driver %s with device %s\n",<BR>&nbsp;&nbsp; drv-&gt;bus-&gt;name, __func__, drv-&gt;name, dev_name(dev));<BR>&nbsp;WARN_ON(!list_empty(&amp;dev-&gt;devres_head));</P>
<P>&nbsp;dev-&gt;driver = drv;</P>
<P>&nbsp;/* If using pinctrl, bind pins now before probing */<BR>&nbsp;ret = pinctrl_bind_pins(dev);<BR>&nbsp;if (ret)<BR>&nbsp;&nbsp;goto pinctrl_bind_failed;</P>
<P>&nbsp;if (driver_sysfs_add(dev)) {<BR>&nbsp;&nbsp;printk(KERN_ERR "%s: driver_sysfs_add(%s) failed\n",<BR>&nbsp;&nbsp;&nbsp;__func__, dev_name(dev));<BR>&nbsp;&nbsp;goto probe_failed;<BR>&nbsp;}</P>
<P>&nbsp;if (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;activate) {<BR>&nbsp;&nbsp;ret = dev-&gt;pm_domain-&gt;activate(dev);<BR>&nbsp;&nbsp;if (ret)<BR>&nbsp;&nbsp;&nbsp;goto probe_failed;<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * Ensure devices are listed in devices_kset in correct order<BR>&nbsp; * It's important to move Dev to the end of devices_kset before<BR>&nbsp; * calling .probe, because it could be recursive and parent Dev<BR>&nbsp; * should always go first<BR>&nbsp; */<BR>&nbsp;devices_kset_move_last(dev);</P>
<P>&nbsp;if (dev-&gt;bus-&gt;probe) {<BR>&nbsp;&nbsp;ret = dev-&gt;bus-&gt;probe(dev);<BR>&nbsp;&nbsp;if (ret)<BR>&nbsp;&nbsp;&nbsp;goto probe_failed;<BR>&nbsp;} else if (drv-&gt;probe) {<BR>&nbsp;&nbsp;ret = drv-&gt;probe(dev);<BR>&nbsp;&nbsp;if (ret)<BR>&nbsp;&nbsp;&nbsp;goto probe_failed;<BR>&nbsp;}</P>
<P>&nbsp;pinctrl_init_done(dev);</P>
<P>&nbsp;if (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;sync)<BR>&nbsp;&nbsp;dev-&gt;pm_domain-&gt;sync(dev);</P>
<P>&nbsp;driver_bound(dev);<BR>&nbsp;ret = 1;<BR>&nbsp;pr_debug("bus: '%s': %s: bound device %s to driver %s\n",<BR>&nbsp;&nbsp; drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);<BR>&nbsp;goto done;</P>
<P>probe_failed:<BR>&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_DRIVER_NOT_BOUND, dev);<BR>pinctrl_bind_failed:<BR>&nbsp;devres_release_all(dev);<BR>&nbsp;driver_sysfs_remove(dev);<BR>&nbsp;dev-&gt;driver = NULL;<BR>&nbsp;dev_set_drvdata(dev, NULL);<BR>&nbsp;if (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)<BR>&nbsp;&nbsp;dev-&gt;pm_domain-&gt;dismiss(dev);<BR>&nbsp;pm_runtime_reinit(dev);</P>
<P>&nbsp;switch (ret) {<BR>&nbsp;case -EPROBE_DEFER:<BR>&nbsp;&nbsp;/* Driver requested deferred probing */<BR>&nbsp;&nbsp;dev_dbg(dev, "Driver %s requests probe deferral\n", drv-&gt;name);<BR>&nbsp;&nbsp;driver_deferred_probe_add(dev);<BR>&nbsp;&nbsp;/* Did a trigger occur while probing? Need to re-trigger if yes */<BR>&nbsp;&nbsp;if (local_trigger_count != atomic_read(&amp;deferred_trigger_count))<BR>&nbsp;&nbsp;&nbsp;driver_deferred_probe_trigger();<BR>&nbsp;&nbsp;break;<BR>&nbsp;case -ENODEV:<BR>&nbsp;case -ENXIO:<BR>&nbsp;&nbsp;pr_debug("%s: probe of %s rejects match %d\n",<BR>&nbsp;&nbsp;&nbsp; drv-&gt;name, dev_name(dev), ret);<BR>&nbsp;&nbsp;break;<BR>&nbsp;default:<BR>&nbsp;&nbsp;/* driver matched but the probe failed */<BR>&nbsp;&nbsp;printk(KERN_WARNING<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%s: probe of %s failed with error %d\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drv-&gt;name, dev_name(dev), ret);<BR>&nbsp;}<BR>&nbsp;/*<BR>&nbsp; * Ignore errors returned by -&gt;probe so that the next driver can try<BR>&nbsp; * its luck.<BR>&nbsp; */<BR>&nbsp;ret = 0;<BR>done:<BR>&nbsp;atomic_dec(&amp;probe_count);<BR>&nbsp;wake_up(&amp;probe_waitqueue);<BR>&nbsp;return ret;<BR>}</P>
<P>/**<BR>&nbsp;* driver_probe_done<BR>&nbsp;* Determine if the probe sequence is finished or not.<BR>&nbsp;*<BR>&nbsp;* Should somehow figure out how to use a semaphore, not an atomic variable...<BR>&nbsp;*/<BR>int driver_probe_done(void)<BR>{<BR>&nbsp;pr_debug("%s: probe_count = %d\n", __func__,<BR>&nbsp;&nbsp; atomic_read(&amp;probe_count));<BR>&nbsp;if (atomic_read(&amp;probe_count))<BR>&nbsp;&nbsp;return -EBUSY;<BR>&nbsp;return 0;<BR>}</P>
<P>/**<BR>&nbsp;* wait_for_device_probe<BR>&nbsp;* Wait for device probing to be completed.<BR>&nbsp;*/<BR>void wait_for_device_probe(void)<BR>{<BR>&nbsp;/* wait for the deferred probe workqueue to finish */<BR>&nbsp;if (driver_deferred_probe_enable)<BR>&nbsp;&nbsp;flush_workqueue(deferred_wq);</P>
<P>&nbsp;/* wait for the known devices to complete their probing */<BR>&nbsp;wait_event(probe_waitqueue, atomic_read(&amp;probe_count) == 0);<BR>&nbsp;async_synchronize_full();<BR>}<BR>EXPORT_SYMBOL_GPL(wait_for_device_probe);</P>
<P>/**<BR>&nbsp;* driver_probe_device - attempt to bind device &amp; driver together<BR>&nbsp;* @drv: driver to bind a device to<BR>&nbsp;* @dev: device to try to bind to the driver<BR>&nbsp;*<BR>&nbsp;* This function returns -ENODEV if the device is not registered,<BR>&nbsp;* 1 if the device is bound successfully and 0 otherwise.<BR>&nbsp;*<BR>&nbsp;* This function must be called with @dev lock held.&nbsp; When called for a<BR>&nbsp;* USB interface, @dev-&gt;parent lock must be held as well.<BR>&nbsp;*<BR>&nbsp;* If the device has a parent, runtime-resume the parent before driver probing.<BR>&nbsp;*/<BR>int driver_probe_device(struct device_driver *drv, struct device *dev)<BR>{<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;if (!device_is_registered(dev))<BR>&nbsp;&nbsp;return -ENODEV;</P>
<P>&nbsp;pr_debug("bus: '%s': %s: matched device %s with driver %s\n",<BR>&nbsp;&nbsp; drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</P>
<P>&nbsp;if (dev-&gt;parent)<BR>&nbsp;&nbsp;pm_runtime_get_sync(dev-&gt;parent);</P>
<P>&nbsp;pm_runtime_barrier(dev);<BR>&nbsp;ret = really_probe(dev, drv);<BR>&nbsp;pm_request_idle(dev);</P>
<P>&nbsp;if (dev-&gt;parent)<BR>&nbsp;&nbsp;pm_runtime_put(dev-&gt;parent);</P>
<P>&nbsp;return ret;<BR>}</P>
<P>bool driver_allows_async_probing(struct device_driver *drv)<BR>{<BR>&nbsp;switch (drv-&gt;probe_type) {<BR>&nbsp;case PROBE_PREFER_ASYNCHRONOUS:<BR>&nbsp;&nbsp;return true;</P>
<P>&nbsp;case PROBE_FORCE_SYNCHRONOUS:<BR>&nbsp;&nbsp;return false;</P>
<P>&nbsp;default:<BR>&nbsp;&nbsp;if (module_requested_async_probing(drv-&gt;owner))<BR>&nbsp;&nbsp;&nbsp;return true;</P>
<P>&nbsp;&nbsp;return false;<BR>&nbsp;}<BR>}</P>
<P>struct device_attach_data {<BR>&nbsp;struct device *dev;</P>
<P>&nbsp;/*<BR>&nbsp; * Indicates whether we are are considering asynchronous probing or<BR>&nbsp; * not. Only initial binding after device or driver registration<BR>&nbsp; * (including deferral processing) may be done asynchronously, the<BR>&nbsp; * rest is always synchronous, as we expect it is being done by<BR>&nbsp; * request from userspace.<BR>&nbsp; */<BR>&nbsp;bool check_async;</P>
<P>&nbsp;/*<BR>&nbsp; * Indicates if we are binding synchronous or asynchronous drivers.<BR>&nbsp; * When asynchronous probing is enabled we'll execute 2 passes<BR>&nbsp; * over drivers: first pass doing synchronous probing and second<BR>&nbsp; * doing asynchronous probing (if synchronous did not succeed -<BR>&nbsp; * most likely because there was no driver requiring synchronous<BR>&nbsp; * probing - and we found asynchronous driver during first pass).<BR>&nbsp; * The 2 passes are done because we can't shoot asynchronous<BR>&nbsp; * probe for given device and driver from bus_for_each_drv() since<BR>&nbsp; * driver pointer is not guaranteed to stay valid once<BR>&nbsp; * bus_for_each_drv() iterates to the next driver on the bus.<BR>&nbsp; */<BR>&nbsp;bool want_async;</P>
<P>&nbsp;/*<BR>&nbsp; * We'll set have_async to 'true' if, while scanning for matching<BR>&nbsp; * driver, we'll encounter one that requests asynchronous probing.<BR>&nbsp; */<BR>&nbsp;bool have_async;<BR>};</P>
<P>static int __device_attach_driver(struct device_driver *drv, void *_data)<BR>{<BR>&nbsp;struct device_attach_data *data = _data;<BR>&nbsp;struct device *dev = data-&gt;dev;<BR>&nbsp;bool async_allowed;<BR>&nbsp;int ret;</P>
<P>&nbsp;/*<BR>&nbsp; * Check if device has already been claimed. This may<BR>&nbsp; * happen with driver loading, device discovery/registration,<BR>&nbsp; * and deferred probe processing happens all at once with<BR>&nbsp; * multiple threads.<BR>&nbsp; */<BR>&nbsp;if (dev-&gt;driver)<BR>&nbsp;&nbsp;return -EBUSY;</P>
<P>&nbsp;ret = driver_match_device(drv, dev);<BR>&nbsp;if (ret == 0) {<BR>&nbsp;&nbsp;/* no match */<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;} else if (ret == -EPROBE_DEFER) {<BR>&nbsp;&nbsp;dev_dbg(dev, "Device match requests probe deferral\n");<BR>&nbsp;&nbsp;driver_deferred_probe_add(dev);<BR>&nbsp;} else if (ret &lt; 0) {<BR>&nbsp;&nbsp;dev_dbg(dev, "Bus failed to match device: %d", ret);<BR>&nbsp;&nbsp;return ret;<BR>&nbsp;} /* ret &gt; 0 means positive match */</P>
<P>&nbsp;async_allowed = driver_allows_async_probing(drv);</P>
<P>&nbsp;if (async_allowed)<BR>&nbsp;&nbsp;data-&gt;have_async = true;</P>
<P>&nbsp;if (data-&gt;check_async &amp;&amp; async_allowed != data-&gt;want_async)<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;return driver_probe_device(drv, dev);<BR>}</P>
<P>static void __device_attach_async_helper(void *_dev, async_cookie_t cookie)<BR>{<BR>&nbsp;struct device *dev = _dev;<BR>&nbsp;struct device_attach_data data = {<BR>&nbsp;&nbsp;.dev&nbsp;&nbsp;= dev,<BR>&nbsp;&nbsp;.check_async&nbsp;= true,<BR>&nbsp;&nbsp;.want_async&nbsp;= true,<BR>&nbsp;};</P>
<P>&nbsp;device_lock(dev);</P>
<P>&nbsp;if (dev-&gt;parent)<BR>&nbsp;&nbsp;pm_runtime_get_sync(dev-&gt;parent);</P>
<P>&nbsp;bus_for_each_drv(dev-&gt;bus, NULL, &amp;data, __device_attach_driver);<BR>&nbsp;dev_dbg(dev, "async probe completed\n");</P>
<P>&nbsp;pm_request_idle(dev);</P>
<P>&nbsp;if (dev-&gt;parent)<BR>&nbsp;&nbsp;pm_runtime_put(dev-&gt;parent);</P>
<P>&nbsp;device_unlock(dev);</P>
<P>&nbsp;put_device(dev);<BR>}</P>
<P>static int __device_attach(struct device *dev, bool allow_async)<BR>{<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;device_lock(dev);<BR>&nbsp;if (dev-&gt;driver) {<BR>&nbsp;&nbsp;if (device_is_bound(dev)) {<BR>&nbsp;&nbsp;&nbsp;ret = 1;<BR>&nbsp;&nbsp;&nbsp;goto out_unlock;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;ret = device_bind_driver(dev);<BR>&nbsp;&nbsp;if (ret == 0)<BR>&nbsp;&nbsp;&nbsp;ret = 1;<BR>&nbsp;&nbsp;else {<BR>&nbsp;&nbsp;&nbsp;dev-&gt;driver = NULL;<BR>&nbsp;&nbsp;&nbsp;ret = 0;<BR>&nbsp;&nbsp;}<BR>&nbsp;} else {<BR>&nbsp;&nbsp;struct device_attach_data data = {<BR>&nbsp;&nbsp;&nbsp;.dev = dev,<BR>&nbsp;&nbsp;&nbsp;.check_async = allow_async,<BR>&nbsp;&nbsp;&nbsp;.want_async = false,<BR>&nbsp;&nbsp;};</P>
<P>&nbsp;&nbsp;if (dev-&gt;parent)<BR>&nbsp;&nbsp;&nbsp;pm_runtime_get_sync(dev-&gt;parent);</P>
<P>&nbsp;&nbsp;ret = bus_for_each_drv(dev-&gt;bus, NULL, &amp;data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__device_attach_driver);<BR>&nbsp;&nbsp;if (!ret &amp;&amp; allow_async &amp;&amp; data.have_async) {<BR>&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp; * If we could not find appropriate driver<BR>&nbsp;&nbsp;&nbsp; * synchronously and we are allowed to do<BR>&nbsp;&nbsp;&nbsp; * async probes and there are drivers that<BR>&nbsp;&nbsp;&nbsp; * want to probe asynchronously, we'll<BR>&nbsp;&nbsp;&nbsp; * try them.<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;dev_dbg(dev, "scheduling asynchronous probe\n");<BR>&nbsp;&nbsp;&nbsp;get_device(dev);<BR>&nbsp;&nbsp;&nbsp;async_schedule(__device_attach_async_helper, dev);<BR>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;pm_request_idle(dev);<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;if (dev-&gt;parent)<BR>&nbsp;&nbsp;&nbsp;pm_runtime_put(dev-&gt;parent);<BR>&nbsp;}<BR>out_unlock:<BR>&nbsp;device_unlock(dev);<BR>&nbsp;return ret;<BR>}</P>
<P>/**<BR>&nbsp;* device_attach - try to attach device to a driver.<BR>&nbsp;* @dev: device.<BR>&nbsp;*<BR>&nbsp;* Walk the list of drivers that the bus has and call<BR>&nbsp;* driver_probe_device() for each pair. If a compatible<BR>&nbsp;* pair is found, break out and return.<BR>&nbsp;*<BR>&nbsp;* Returns 1 if the device was bound to a driver;<BR>&nbsp;* 0 if no matching driver was found;<BR>&nbsp;* -ENODEV if the device is not registered.<BR>&nbsp;*<BR>&nbsp;* When called for a USB interface, @dev-&gt;parent lock must be held.<BR>&nbsp;*/<BR>int device_attach(struct device *dev)<BR>{<BR>&nbsp;return __device_attach(dev, false);<BR>}<BR>EXPORT_SYMBOL_GPL(device_attach);</P>
<P>void device_initial_probe(struct device *dev)<BR>{<BR>&nbsp;__device_attach(dev, true);<BR>}</P>
<P>static int __driver_attach(struct device *dev, void *data)<BR>{<BR>&nbsp;struct device_driver *drv = data;<BR>&nbsp;int ret;</P>
<P>&nbsp;/*<BR>&nbsp; * Lock device and try to bind to it. We drop the error<BR>&nbsp; * here and always return 0, because we need to keep trying<BR>&nbsp; * to bind to devices and some drivers will return an error<BR>&nbsp; * simply if it didn't support the device.<BR>&nbsp; *<BR>&nbsp; * driver_probe_device() will spit a warning if there<BR>&nbsp; * is an error.<BR>&nbsp; */</P>
<P>&nbsp;ret = driver_match_device(drv, dev);<BR>&nbsp;if (ret == 0) {<BR>&nbsp;&nbsp;/* no match */<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;} else if (ret == -EPROBE_DEFER) {<BR>&nbsp;&nbsp;dev_dbg(dev, "Device match requests probe deferral\n");<BR>&nbsp;&nbsp;driver_deferred_probe_add(dev);<BR>&nbsp;} else if (ret &lt; 0) {<BR>&nbsp;&nbsp;dev_dbg(dev, "Bus failed to match device: %d", ret);<BR>&nbsp;&nbsp;return ret;<BR>&nbsp;} /* ret &gt; 0 means positive match */</P>
<P>&nbsp;if (dev-&gt;parent)&nbsp;/* Needed for USB */<BR>&nbsp;&nbsp;device_lock(dev-&gt;parent);<BR>&nbsp;device_lock(dev);<BR>&nbsp;if (!dev-&gt;driver)<BR>&nbsp;&nbsp;driver_probe_device(drv, dev);<BR>&nbsp;device_unlock(dev);<BR>&nbsp;if (dev-&gt;parent)<BR>&nbsp;&nbsp;device_unlock(dev-&gt;parent);</P>
<P>&nbsp;return 0;<BR>}</P>
<P>/**<BR>&nbsp;* driver_attach - try to bind driver to devices.<BR>&nbsp;* @drv: driver.<BR>&nbsp;*<BR>&nbsp;* Walk the list of devices that the bus has on it and try to<BR>&nbsp;* match the driver with each one.&nbsp; If driver_probe_device()<BR>&nbsp;* returns 0 and the @dev-&gt;driver is set, we've found a<BR>&nbsp;* compatible pair.<BR>&nbsp;*/<BR>int driver_attach(struct device_driver *drv)<BR>{<BR>&nbsp;return bus_for_each_dev(drv-&gt;bus, NULL, drv, __driver_attach);<BR>}<BR>EXPORT_SYMBOL_GPL(driver_attach);</P>
<P>/*<BR>&nbsp;* __device_release_driver() must be called with @dev lock held.<BR>&nbsp;* When called for a USB interface, @dev-&gt;parent lock must be held as well.<BR>&nbsp;*/<BR>static void __device_release_driver(struct device *dev)<BR>{<BR>&nbsp;struct device_driver *drv;</P>
<P>&nbsp;drv = dev-&gt;driver;<BR>&nbsp;if (drv) {<BR>&nbsp;&nbsp;if (driver_allows_async_probing(drv))<BR>&nbsp;&nbsp;&nbsp;async_synchronize_full();</P>
<P>&nbsp;&nbsp;pm_runtime_get_sync(dev);</P>
<P>&nbsp;&nbsp;driver_sysfs_remove(dev);</P>
<P>&nbsp;&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_UNBIND_DRIVER,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev);</P>
<P>&nbsp;&nbsp;pm_runtime_put_sync(dev);</P>
<P>&nbsp;&nbsp;if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;remove)<BR>&nbsp;&nbsp;&nbsp;dev-&gt;bus-&gt;remove(dev);<BR>&nbsp;&nbsp;else if (drv-&gt;remove)<BR>&nbsp;&nbsp;&nbsp;drv-&gt;remove(dev);<BR>&nbsp;&nbsp;devres_release_all(dev);<BR>&nbsp;&nbsp;dev-&gt;driver = NULL;<BR>&nbsp;&nbsp;dev_set_drvdata(dev, NULL);<BR>&nbsp;&nbsp;if (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)<BR>&nbsp;&nbsp;&nbsp;dev-&gt;pm_domain-&gt;dismiss(dev);<BR>&nbsp;&nbsp;pm_runtime_reinit(dev);</P>
<P>&nbsp;&nbsp;klist_remove(&amp;dev-&gt;p-&gt;knode_driver);<BR>&nbsp;&nbsp;device_pm_check_callbacks(dev);<BR>&nbsp;&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_UNBOUND_DRIVER,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev);<BR>&nbsp;}<BR>}</P>
<P>/**<BR>&nbsp;* device_release_driver - manually detach device from driver.<BR>&nbsp;* @dev: device.<BR>&nbsp;*<BR>&nbsp;* Manually detach device from driver.<BR>&nbsp;* When called for a USB interface, @dev-&gt;parent lock must be held.<BR>&nbsp;*/<BR>void device_release_driver(struct device *dev)<BR>{<BR>&nbsp;/*<BR>&nbsp; * If anyone calls device_release_driver() recursively from<BR>&nbsp; * within their -&gt;remove callback for the same device, they<BR>&nbsp; * will deadlock right here.<BR>&nbsp; */<BR>&nbsp;device_lock(dev);<BR>&nbsp;__device_release_driver(dev);<BR>&nbsp;device_unlock(dev);<BR>}<BR>EXPORT_SYMBOL_GPL(device_release_driver);</P>
<P>/**<BR>&nbsp;* driver_detach - detach driver from all devices it controls.<BR>&nbsp;* @drv: driver.<BR>&nbsp;*/<BR>void driver_detach(struct device_driver *drv)<BR>{<BR>&nbsp;struct device_private *dev_prv;<BR>&nbsp;struct device *dev;</P>
<P>&nbsp;for (;;) {<BR>&nbsp;&nbsp;spin_lock(&amp;drv-&gt;p-&gt;klist_devices.k_lock);<BR>&nbsp;&nbsp;if (list_empty(&amp;drv-&gt;p-&gt;klist_devices.k_list)) {<BR>&nbsp;&nbsp;&nbsp;spin_unlock(&amp;drv-&gt;p-&gt;klist_devices.k_lock);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;dev_prv = list_entry(drv-&gt;p-&gt;klist_devices.k_list.prev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device_private,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; knode_driver.n_node);<BR>&nbsp;&nbsp;dev = dev_prv-&gt;device;<BR>&nbsp;&nbsp;get_device(dev);<BR>&nbsp;&nbsp;spin_unlock(&amp;drv-&gt;p-&gt;klist_devices.k_lock);</P>
<P>&nbsp;&nbsp;if (dev-&gt;parent)&nbsp;/* Needed for USB */<BR>&nbsp;&nbsp;&nbsp;device_lock(dev-&gt;parent);<BR>&nbsp;&nbsp;device_lock(dev);<BR>&nbsp;&nbsp;if (dev-&gt;driver == drv)<BR>&nbsp;&nbsp;&nbsp;__device_release_driver(dev);<BR>&nbsp;&nbsp;device_unlock(dev);<BR>&nbsp;&nbsp;if (dev-&gt;parent)<BR>&nbsp;&nbsp;&nbsp;device_unlock(dev-&gt;parent);<BR>&nbsp;&nbsp;put_device(dev);<BR>&nbsp;}<BR>}