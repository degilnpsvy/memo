# qemu:include/qemu/log.h 
<P></P>
<P>#ifndef QEMU_LOG_H<BR>#define QEMU_LOG_H</P>
<P></P>
<P><BR>/* Private global variables, don't use */<BR>extern FILE *qemu_logfile;<BR>extern int qemu_loglevel;</P>
<P>/* <BR>&nbsp;* The new API:<BR>&nbsp;*<BR>&nbsp;*/</P>
<P>/* Log settings checking macros: */</P>
<P>/* Returns true if qemu_log() will really write somewhere<BR>&nbsp;*/<BR>static inline bool qemu_log_enabled(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; return qemu_logfile != NULL;<BR>}</P>
<P>/* Returns true if qemu_log() will write somewhere else than stderr<BR>&nbsp;*/<BR>static inline bool qemu_log_separate(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; return qemu_logfile != NULL &amp;&amp; qemu_logfile != stderr;<BR>}</P>
<P>#define CPU_LOG_TB_OUT_ASM (1 &lt;&lt; 0)<BR>#define CPU_LOG_TB_IN_ASM&nbsp; (1 &lt;&lt; 1)<BR>#define CPU_LOG_TB_OP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; 2)<BR>#define CPU_LOG_TB_OP_OPT&nbsp; (1 &lt;&lt; 3)<BR>#define CPU_LOG_INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; 4)<BR>#define CPU_LOG_EXEC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; 5)<BR>#define CPU_LOG_PCALL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; 6)<BR>#define CPU_LOG_TB_CPU&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; 8)<BR>#define CPU_LOG_RESET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; 9)<BR>#define LOG_UNIMP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; 10)<BR>#define LOG_GUEST_ERROR&nbsp;&nbsp;&nbsp; (1 &lt;&lt; 11)<BR>#define CPU_LOG_MMU&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; 12)<BR>#define CPU_LOG_TB_NOCHAIN (1 &lt;&lt; 13)<BR>#define CPU_LOG_PAGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; 14)<BR>#define LOG_TRACE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; 15)<BR>#define CPU_LOG_TB_OP_IND&nbsp; (1 &lt;&lt; 16)</P>
<P>/* Returns true if a bit is set in the current loglevel mask<BR>&nbsp;*/<BR>static inline bool qemu_loglevel_mask(int mask)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (qemu_loglevel &amp; mask) != 0;<BR>}</P>
<P>/* Lock output for a series of related logs.&nbsp; Since this is not needed<BR>&nbsp;* for a single qemu_log / qemu_log_mask / qemu_log_mask_and_addr, we<BR>&nbsp;* assume that qemu_loglevel_mask has already been tested, and that<BR>&nbsp;* qemu_loglevel is never set when qemu_logfile is unset.<BR>&nbsp;*/</P>
<P>static inline void qemu_log_lock(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; qemu_flockfile(qemu_logfile);<BR>}</P>
<P>static inline void qemu_log_unlock(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; qemu_funlockfile(qemu_logfile);<BR>}</P>
<P>/* Logging functions: */</P>
<P>/* main logging function<BR>&nbsp;*/<BR>int GCC_FMT_ATTR(1, 2) qemu_log(const char *fmt, ...);</P>
<P>/* vfprintf-like logging function<BR>&nbsp;*/<BR>static inline void GCC_FMT_ATTR(1, 0)<BR>qemu_log_vprintf(const char *fmt, va_list va)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (qemu_logfile) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vfprintf(qemu_logfile, fmt, va);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* log only if a bit is set on the current loglevel mask:<BR>&nbsp;* @mask: bit to check in the mask<BR>&nbsp;* @fmt: printf-style format string<BR>&nbsp;* @args: optional arguments for format string<BR>&nbsp;*/<BR>#define qemu_log_mask(MASK, FMT, ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (unlikely(qemu_loglevel_mask(MASK))) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log(FMT, ## __VA_ARGS__);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; } while (0)</P>
<P>/* log only if a bit is set on the current loglevel mask<BR>&nbsp;* and we are in the address range we care about:<BR>&nbsp;* @mask: bit to check in the mask<BR>&nbsp;* @addr: address to check in dfilter<BR>&nbsp;* @fmt: printf-style format string<BR>&nbsp;* @args: optional arguments for format string<BR>&nbsp;*/<BR>#define qemu_log_mask_and_addr(MASK, ADDR, FMT, ...)&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (unlikely(qemu_loglevel_mask(MASK)) &amp;&amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_in_addr_range(ADDR)) {&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log(FMT, ## __VA_ARGS__);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; } while (0)</P>
<P>/* Maintenance: */</P>
<P><FONT class=extract>/* define log items */<BR>typedef struct QEMULogItem {<BR>&nbsp;&nbsp;&nbsp; int mask;<BR>&nbsp;&nbsp;&nbsp; const char *name;<BR>&nbsp;&nbsp;&nbsp; const char *help;<BR>} QEMULogItem;</FONT></P>
<P><FONT class=extract>extern const QEMULogItem qemu_log_items[];</FONT></P>
<P>void qemu_set_log(int log_flags);<BR>void qemu_log_needs_buffers(void);<BR>void qemu_set_log_filename(const char *filename, Error **errp);<BR>void qemu_set_dfilter_ranges(const char *ranges, Error **errp);<BR>bool qemu_log_in_addr_range(uint64_t addr);<BR>int qemu_str_to_log_mask(const char *str);</P>
<P>/* Print a usage message listing all the valid logging categories<BR>&nbsp;* to the specified FILE*.<BR>&nbsp;*/<BR>void qemu_print_log_usage(FILE *f);</P>
<P>/* fflush() the log file */<BR>void qemu_log_flush(void);<BR>/* Close the log file */<BR>void qemu_log_close(void);</P>
<P>#endif