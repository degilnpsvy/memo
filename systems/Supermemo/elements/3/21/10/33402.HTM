Manages vector catch behavior and DebugMonitor handling when debugging.<BR>Usage constraints: Privileged access permitted only. Unprivileged accesses generate a BusFault.<BR>&nbsp; This register is word accessible only. Halfword and byte accesses are UNPREDICTABLE.<BR>&nbsp; If the Main Extension is not implemented then it is IMPLEMENTATION DEFINED whether this register is accessible only to the debugger and RES0 for software. Otherwise the register is accessible to the debugger and software.<BR>Configurations: Present only if Halting debug or the Main Extension is implemented.<BR>&nbsp; This register is RES0 if both Halting debug and Main Extension are not implemented.<BR>Attributes: 32-bit read/write register located at 0xE000EDFC.<BR>&nbsp; Secure software can access the Non-secure view of this register via DEMCR_NS located at 0xE002EDFC. The location 0xE002EDFC is RES0 to software executing in Non-secure state and the debugger.<BR>&nbsp; This register is not banked between Security states.</P>
<P>The DEMCR bit assignments are:</P>
<P>Bits [31:25]<BR>Reserved, RES0.<BR>TRCENA, bit [24]<BR>Trace enable. Global enable for all DWT and ITM features.<BR>The possible values of this bit are:<BR>0 DWT and ITM features disabled.<BR>1 DWT and ITM features enabled.<BR>If the DWT and ITM units are not implemented, this bit is RES0. See the descriptions of DWT and ITM for details of which features this bit controls.<BR>Setting this bit to 0 might not stop all events. To ensure that all events are stopped, software must set all DWT and ITM feature enable bits to 0, and that all trace generated by the DWT and ITM has been flushed, before setting this bit to 0.<BR>The effect of this bit on the TPIU, ETM, and other system trace components is IMPLEMENTATION DEFINED.<BR>This bit resets to zero on a Cold reset.</P>
<P>Bits [23:21]<BR>Reserved, RES0.</P>
<P>SDME, bit [20]<BR>Secure DebugMonitor enable. Indicates whether the DebugMonitor targets the Secure or the Non-secure state and whether debug events are allowed in Secure state.<BR>The possible values of this bit are:<BR>0 Debug events prohibited in Secure state and the DebugMonitor exception targets Non-secure state.<BR>1 Debug events allowed in Secure state and the DebugMonitor exception targets Secure state.<BR>When DebugMonitor is not pending or active, this bit reflects the value of<BR>SecureDebugMonitorAllowed(), otherwise, the previous value is retained.<BR>This bit is read-only.<BR>If the Security Extension is not implemented, this bit is RES0.<BR>If the Main Extension is not implemented, this bit is RES0.</P>
<P>MON_REQ, bit [19]<BR>Monitor request. DebugMonitor semaphore bit.<BR>The PE does not use this bit. The monitor software defines the meaning and use of this bit.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</P>
<P>MON_STEP, bit [18]<BR>Monitor step. Enable DebugMonitor stepping.<BR>The possible values of this bit are:<BR>0 Stepping disabled.<BR>1 Stepping enabled.<BR>The effect of changing this bit at an execution priority that is lower than the priority of the DebugMonitor exception is UNPREDICTABLE.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</P>
<P>MON_PEND, bit [17]<BR>Monitor pend. Sets or clears the pending state of the DebugMonitor exception.<BR>The possible values of this bit are:<BR>0 Clear the status of the DebugMonitor exception to not pending.<BR>1 Set the status of the DebugMonitor exception to pending.<BR>When the DebugMonitor exception is pending it becomes active subject to the exception priority rules. The effect of setting this bit to 1 is not affected by the value of the MON_EN bit. This means that software or a debugger can set MON_PEND to 1 and pend a DebugMonitor exception, even when MON_EN is set to 0.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</P>
<P>MON_EN, bit [16]<BR>Monitor enable. Enable the DebugMonitor exception.<BR>The possible values of this bit are:<BR>0 DebugMonitor exception disabled.<BR>1 DebugMonitor exception enabled.<BR>If a debug event halts the PE, the PE ignores the value of this bit.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.<BR>Bits [15:12]<BR>Reserved, RES0.</P>
<P>VC_SFERR, bit [11]<BR>Vector Catch SecureFault. SecureFault exception Halting debug vector catch enable.<BR>The possible values of this bit are:<BR>0 Halting debug trap on SecureFault disabled.<BR>1 Halting debug trap on SecureFault enabled.<BR>The PE ignores the value of this bit if DHCSR.C_DEBUGEN == 0, HaltingDebugAllowed() == FALSE, or DHCSR.S_SDE == 0.<BR>If the Security Extension is not implemented, this bit is RES0.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>If Halting debug is not implemented, this bit is RES0.<BR>This bit resets to zero on a Cold reset.</P>
<P>VC_HARDERR, bit [10]<BR>Vector Catch HardFault errors. HardFault exception Halting debug vector catch enable.<BR>The possible values of this bit are:<BR>0 Halting debug trap on HardFault disabled.<BR>1 Halting debug trap on HardFault enabled.<BR>The PE ignores the value of this bit if DHCSR.C_DEBUGEN == 0, HaltingDebugAllowed() == FALSE, or the Security Extension is implemented, DHCSR.S_SDE == 0 and the exception targets Secure state.<BR>If Halting debug is not implemented, this bit is RES0.<BR>This bit resets to zero on a Cold reset.</P>
<P>VC_INTERR, bit [9]<BR>Vector Catch interrupt errors. Enable Halting debug vector catch for faults during exception entry and return.<BR>The possible values of this bit are:<BR>0 Halting debug trap on faults during exception entry and return disabled.<BR>1 Halting debug trap on faults during exception entry and return enabled.<BR>The PE ignores the value of this bit if DHCSR.C_DEBUGEN == 0, HaltingDebugAllowed() == FALSE, or the Security Extension is implemented, DHCSR.S_SDE == 0 and the exception targets Secure state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>If Halting debug is not implemented, this bit is RES0.<BR>This bit resets to zero on a Cold reset.</P>
<P>VC_BUSERR, bit [8]<BR>Vector Catch BusFault errors. BusFault exception Halting debug vector catch enable.<BR>The possible values of this bit are:<BR>0 Halting debug trap on BusFault disabled.<BR>1 Halting debug trap on BusFault enabled.<BR>The PE ignores the value of this bit if DHCSR.C_DEBUGEN == 0, HaltingDebugAllowed() == FALSE, or the Security Extension is implemented, DHCSR.S_SDE == 0 and the exception targets Secure state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>If Halting debug is not implemented, this bit is RES0.<BR>This bit resets to zero on a Cold reset.</P>
<P>VC_STATERR, bit [7]<BR>Vector Catch state errors. Enable Halting debug trap on a UsageFault exception caused by a state information error, for example an Undefined Instruction exception.<BR>The possible values of this bit are:<BR>0 Halting debug trap on UsageFault caused by state information error disabled.<BR>1 Halting debug trap on UsageFault caused by state information error enabled.<BR>The PE ignores the value of this bit if DHCSR.C_DEBUGEN == 0, HaltingDebugAllowed() == FALSE, or the Security Extension is implemented, DHCSR.S_SDE == 0 and the exception targets Secure state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>If Halting debug is not implemented, this bit is RES0.<BR>This bit resets to zero on a Cold reset.</P>
<P>VC_CHKERR, bit [6]<BR>Vector Catch check errors. Enable Halting debug trap on a UsageFault exception caused by a checking error, for example an alignment check error.<BR>The possible values of this bit are:<BR>0 Halting debug trap on UsageFault caused by checking error disabled.<BR>1 Halting debug trap on UsageFault caused by checking error enabled.<BR>The PE ignores the value of this bit if DHCSR.C_DEBUGEN == 0, HaltingDebugAllowed() == FALSE, or the Security Extension is implemented, DHCSR.S_SDE == 0 and the exception targets Secure state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>If Halting debug is not implemented, this bit is RES0.<BR>This bit resets to zero on a Cold reset.</P>
<P>VC_NOCPERR, bit [5]<BR>Vector Catch NOCP errors. Enable Halting debug trap on a UsageFault caused by an access to a coprocessor.<BR>The possible values of this bit are:<BR>0 Halting debug trap on UsageFault caused by access to a coprocessor disabled.<BR>1 Halting debug trap on UsageFault caused by access to a coprocessor enabled.<BR>The PE ignores the value of this bit if DHCSR.C_DEBUGEN == 0, HaltingDebugAllowed() == FALSE, or the Security Extension is implemented, DHCSR.S_SDE == 0 and the exception targets Secure state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>If Halting debug is not implemented, this bit is RES0.<BR>This bit resets to zero on a Cold reset.</P>
<P>VC_MMERR, bit [4]<BR>Vector Catch MemManage errors. Enable Halting debug trap on a MemManage exception.<BR>The possible values of this bit are:<BR>0 Halting debug trap on MemManage disabled.<BR>1 Halting debug trap on MemManage enabled.<BR>The PE ignores the value of this bit if DHCSR.C_DEBUGEN == 0, HaltingDebugAllowed() == FALSE, or the Security Extension is implemented, DHCSR.S_SDE == 0 and the exception targets Secure state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>If Halting debug is not implemented, this bit is RES0.<BR>This bit resets to zero on a Cold reset.</P>
<P>Bits [3:1]<BR>Reserved, RES0.<BR>VC_CORERESET, bit [0]<BR>Vector Catch core reset. Enable Reset Vector Catch. This causes a Warm reset to halt a running system.<BR>The possible values of this bit are:<BR>0 Halting debug trap on reset disabled.<BR>1 Halting debug trap on reset enabled.<BR>If DHCSR.C_DEBUGEN == 0 or HaltingDebugAllowed() == FALSE, the PE ignores the value of this bit. Otherwise, when this bit is set to 1 a Warm reset will pend a Vector Catch debug event. The debug event is pended even the PE resets into Secure state and DHCSR.S_SDE == 0.<BR>If Halting debug is not implemented, this bit is RES0.<BR>This bit resets to zero on a Cold reset.