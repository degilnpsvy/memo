Provides access to the active and pending status of system exceptions.<BR>Usage constraints: Privileged access permitted only. Unprivileged accesses generate a BusFault.<BR>&nbsp;&nbsp;&nbsp; This register is word accessible only. Halfword and byte accesses are UNPREDICTABLE.<BR>Configurations: This register is always implemented.<BR>Attributes: 32-bit read/write register located at 0xE000ED24.<BR>&nbsp;&nbsp;&nbsp; Secure software can access the Non-secure view of this register via SHCSR_NS located at 0xE002ED24. The location 0xE002ED24 is RES0 to software executing in Non-secure state and the debugger.<BR>&nbsp;&nbsp;&nbsp; This register is banked between Security states on a bit by bit basis.<BR>Preface: <FONT class=extract>Exception processing automatically updates the SHCSR fields. However, software can write to the register to add or remove the pending or active state of an exception. When updating the SHCSR, ARM recommends using a read-modify-write sequence, to avoid unintended effects on the state of the exception handlers.</FONT><BR>&nbsp;&nbsp;&nbsp; <FONT class=extract>Removing the active state of an exception can change the current execution priority, and affect the exception return consistency checks. If software removes the active state, causing a change in current execution priority, this can defeat the architectural behavior that prevents an exception from preempting its own handler.</FONT><BR><FONT class=extract>&nbsp;&nbsp;&nbsp; Pending state bits are set to one when an exception occurs and are cleared to zero when the exception becomes active.<BR>&nbsp;&nbsp;&nbsp; Active state bits are set to one when the associated exception becomes active.</FONT><BR>&nbsp;&nbsp;&nbsp; <BR>Bits [31:22]<BR>Reserved, RES0.
<P><FONT class=extract>HARDFAULTPENDED, bit [21]<BR>HardFault exception pended state. This bit indicates and allows modification of the pending state of the HardFault exception corresponding to the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 HardFault exception not pending for the selected Security state.<BR>1 HardFault exception pending for the selected Security state.<BR>This bit resets to zero on a Warm reset.<BR>Note<BR>The Non-secure HardFault exception will not preempt if AIRCR.BFHFNMINS is set to zero.</FONT></P>
<P><FONT class=extract>SECUREFAULTPENDED, bit [20]<BR>SecureFault exception pended state. This bit indicates and allows modification of the pending state of the SecureFault exception.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 SecureFault exception not pending.<BR>1 SecureFault exception pending.<BR>This bit is RAZ/WI from Non-secure.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>SECUREFAULTENA, bit [19]<BR>SecureFault exception enable. The value of this bit defines whether the SecureFault exception is enabled.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 SecureFault exception disabled.<BR>1 SecureFault exception enabled.<BR>When disabled, exceptions that target SecureFault escalate to Secure state HardFault.<BR>This bit is RAZ/WI from Non-secure.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>USGFAULTENA, bit [18]<BR>UsageFault exception enable. The value of this bit defines whether the UsageFault exception is enabled for the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 UsageFault exception disabled for the selected Security state.<BR>1 UsageFault exception enabled for the selected Security state.<BR>When the UsageFault exception is disabled, exceptions targeting UsageFault escalate to HardFault.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>BUSFAULTENA, bit [17]<BR>BusFault exception enable. The value of this bit defines whether the BusFault exception is enabled.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 BusFault exception disabled.<BR>1 BusFault exception enabled.<BR>The BusFault exception is not banked between Security states. When the BusFault exception is disabled, exceptions targeting BusFault escalate to HardFault.<BR>If AIRCR.BFHFNMINS is zero this bit is RAZ/WI from Non-secure state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>MEMFAULTENA, bit [16]<BR>MemManage exception enable. The value of this bit defines whether the MemManage exception is enabled for the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 MemManage exception disabled for the selected Security state.<BR>1 MemManage exception enabled for the selected Security state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.<BR>Note<BR>When the MemManage exception is disabled, exceptions targeting MemManage escalate to HardFault.</FONT></P>
<P><FONT class=extract>SVCALLPENDED, bit [15]<BR>SVCall exception pended state. This bit indicates and allows modification of the pending state of<BR>the SVCall exception for the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 SVCall exception not pending for the selected Security state.<BR>1 SVCall exception pending for the selected Security state.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>BUSFAULTPENDED, bit [14]<BR>BusFault exception pended state. This bit indicates and allows modification of the pending state of the BusFault exception.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 BusFault exception not pending.<BR>1 BusFault exception pending.<BR>The BusFault exception is not banked between Security states.<BR>If AIRCR.BFHFNMINS is zero this bit is RAZ/WI from Non-secure state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>MEMFAULTPENDED, bit [13]<BR>MemManage exception pended state. This bit indicates and allows modification of the pending state of the MemManage exception for the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 MemManage exception not pending for the selected Security state.<BR>1 MemManage exception pending for the selected Security state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>USGFAULTPENDED, bit [12]<BR>UsageFault exception pended state. The UsageFault exception is banked between Security states, this bit indicates and allows modification of the pending state of the UsageFault exception for the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 UsageFault exception not pending for the selected Security state.<BR>1 UsageFault exception pending for the selected Security state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>SYSTICKACT, bit [11]<BR>SysTick exception active state. This bit indicates and allows modification of the active state of the SysTick exception for the selected Security state.<BR>If two SysTick timers are implemented this bit is banked between Security states.<BR>If less than two SysTick timers are implemented this bit is not banked between Security states, and is RAZ/WI if AIRCR.STTNS is zero.<BR>The possible values of this bit are:<BR>0 SysTick exception not active for the selected Security state.<BR>1 SysTick exception active for the selected Security state.<BR>If two timers are implemented, then SYSTICKACT is banked between Security states. If one timer is implemented this bit corresponds to the Secure state if AIRCR.STTNS is zero, or the Non-secure state3 if AIRCR.STTNS is one.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>PENDSVACT, bit [10]<BR>PendSV exception active state. This bit indicates and allows modification of the active state of the PendSV exception for the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 PendSV exception not active for the selected Security state.<BR>1 PendSV exception active for the selected Security state.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P>Bit [9]<BR>Reserved, RES0.</P>
<P><FONT class=extract>MONITORACT, bit [8]<BR>DebugMonitor exception active state. This bit indicates and allows modification of the active state of the DebugMonitor exception.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 DebugMonitor exception not active.<BR>1 DebugMonitor exception active.<BR>If DEMCR.SDME is one this bit is RAZ/WI from Non-secure state<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>SVCALLACT, bit [7]<BR>SVCall exception active state. This bit indicates and allows modification of the active state of the SVCall exception for the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 SVCall exception not active for the selected Security state.<BR>1 SVCall exception active for the selected Security state.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P>Bit [6]<BR>Reserved, RES0.</P>
<P><FONT class=extract>NMIACT, bit [5]<BR>NMI exception active state. This bit indicates and allows modification of the active state of the NMI exception.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 NMI exception not active.<BR>1 NMI exception active.<BR>The NMI exception is not banked between Security states. When AIRCR.BFHFNMINS is zero, the Non-secure view of this bit is RAZ/WI. This field ignores writes if either the value being written is one, AIRCR.BFHFNMINS is zero, the access is from Non-secure state, the access is not via the NS alias, or the access is from a debugger when DHCSR.S_SDE is zero.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>SECUREFAULTACT, bit [4]<BR>SecureFault exception active state. This bit indicates and allows modification of the active state of the SecureFault exception.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 SecureFault exception not active.<BR>1 SecureFault exception active.<BR>This bit is RAZ/WI from Non-secure.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>USGFAULTACT, bit [3]<BR>UsageFault exception active state for the selected Security state. This bit indicates and allows modification of the active state of the UsageFault exception for the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 UsageFault exception not active for the selected Security state.<BR>1 UsageFault exception active for the selected Security state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>HARDFAULTACT, bit [2]<BR>HardFault exception active state. Indicates and allows limited modification of the active state of the HardFault exception for the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 HardFault exception not active for the selected Security state.<BR>1 HardFault exception active for the selected Security state.<BR>This field ignores writes if either the value being written is one, the write targets the Secure HardFault active bit, the access is from Non-secure state, or the access is from a debugger when DHCSR.S_SDE is zero.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>BUSFAULTACT, bit [1]<BR>BusFault exception active state. This bit indicates and allows modification of the active state of the BusFault exception.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 BusFault exception not active.<BR>1 BusFault exception active.<BR>The BusFault exception is not banked between Security states.<BR>If AIRCR.BFHFNMINS is zero this bit is RAZ/WI from Non-secure state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>MEMFAULTACT, bit [0]<BR>MemManage exception active state for the selected Security state. This bit indicates and allows modification of the active state of the MemManage exception for the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 MemManage exception not active for the selected Security state.<BR>1 MemManage exception active for the selected Security state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT>