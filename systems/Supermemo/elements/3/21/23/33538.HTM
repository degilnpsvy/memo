# qemu:util/log.c 
<P></P>
<P>/*<BR>&nbsp;* Logging support<BR>&nbsp;*<BR>&nbsp;*&nbsp; Copyright (c) 2003 Fabrice Bellard<BR>&nbsp;*<BR>&nbsp;* This library is free software; you can redistribute it and/or<BR>&nbsp;* modify it under the terms of the GNU Lesser General Public<BR>&nbsp;* License as published by the Free Software Foundation; either<BR>&nbsp;* version 2 of the License, or (at your option) any later version.<BR>&nbsp;*<BR>&nbsp;* This library is distributed in the hope that it will be useful,<BR>&nbsp;* but WITHOUT ANY WARRANTY; without even the implied warranty of<BR>&nbsp;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp; See the GNU<BR>&nbsp;* Lesser General Public License for more details.<BR>&nbsp;*<BR>&nbsp;* You should have received a copy of the GNU Lesser General Public<BR>&nbsp;* License along with this library; if not, see &lt;<A href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.<BR>&nbsp;*/</P>
<P></P>
<P>#include "qemu/osdep.h"<BR>#include "qemu-common.h"<BR>#include "qemu/log.h"<BR>#include "qemu/range.h"<BR>#include "qemu/error-report.h"<BR>#include "qapi/error.h"<BR>#include "qemu/cutils.h"<BR>#include "trace/control.h"</P>
<P>static char *logfilename;<BR>FILE *qemu_logfile;<BR>int qemu_loglevel;<BR>static int log_append = 0;<BR>static GArray *debug_regions;</P>
<P><FONT class=extract>/* Return the number of characters emitted.&nbsp; */<BR>int qemu_log(const char *fmt, ...)<BR>{<BR>&nbsp;&nbsp;&nbsp; int ret = 0;<BR>&nbsp;&nbsp;&nbsp; if (qemu_logfile) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list ap;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start(ap, fmt);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = vfprintf(qemu_logfile, fmt, ap);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end(ap);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Don't pass back error results.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ret &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return ret;<BR>}</FONT></P>
<P>static bool log_uses_own_buffers;</P>
<P>/* enable or disable low levels log */<BR>void qemu_set_log(int log_flags)<BR>{<BR>&nbsp;&nbsp;&nbsp; qemu_loglevel = log_flags;<BR>#ifdef CONFIG_TRACE_LOG<BR>&nbsp;&nbsp;&nbsp; qemu_loglevel |= LOG_TRACE;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; if (!qemu_logfile &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (is_daemonized() ? logfilename != NULL : qemu_loglevel)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (logfilename) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_logfile = fopen(logfilename, log_append ? "a" : "w");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!qemu_logfile) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror(logfilename);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _exit(1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* In case we are a daemon redirect stderr to logfile */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_daemonized()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup2(fileno(qemu_logfile), STDERR_FILENO);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(qemu_logfile);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* This will skip closing logfile in qemu_log_close() */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_logfile = stderr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Default to stderr if no log file specified */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(!is_daemonized());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_logfile = stderr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* must avoid mmap() usage of glibc by setting a buffer "by hand" */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (log_uses_own_buffers) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static char logfile_buf[4096];</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setvbuf(qemu_logfile, logfile_buf, _IOLBF, sizeof(logfile_buf));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>#if defined(_WIN32)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Win32 doesn't support line-buffering, so use unbuffered output. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setvbuf(qemu_logfile, NULL, _IONBF, 0);<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setvbuf(qemu_logfile, NULL, _IOLBF, 0);<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log_append = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (qemu_logfile &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (is_daemonized() ? logfilename == NULL : !qemu_loglevel)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_close();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void qemu_log_needs_buffers(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; log_uses_own_buffers = true;<BR>}</P>
<P>/*<BR>&nbsp;* Allow the user to include %d in their logfile which will be<BR>&nbsp;* substituted with the current PID. This is useful for debugging many<BR>&nbsp;* nested linux-user tasks but will result in lots of logs.<BR>&nbsp;*/<BR>void qemu_set_log_filename(const char *filename, Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; char *pidstr;<BR>&nbsp;&nbsp;&nbsp; g_free(logfilename);</P>
<P>&nbsp;&nbsp;&nbsp; pidstr = strstr(filename, "%");<BR>&nbsp;&nbsp;&nbsp; if (pidstr) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We only accept one %d, no other format strings */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pidstr[1] != 'd' || strchr(pidstr + 2, '%')) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "Bad logfile format: %s", filename);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logfilename = g_strdup_printf(filename, getpid());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logfilename = g_strdup(filename);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; qemu_log_close();<BR>&nbsp;&nbsp;&nbsp; qemu_set_log(qemu_loglevel);<BR>}</P>
<P>/* Returns true if addr is in our debug filter or no filter defined<BR>&nbsp;*/<BR>bool qemu_log_in_addr_range(uint64_t addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (debug_regions) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; debug_regions-&gt;len; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Range *range = &amp;g_array_index(debug_regions, Range, i);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (range_contains(range, addr)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P><BR>void qemu_set_dfilter_ranges(const char *filter_spec, Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; gchar **ranges = g_strsplit(filter_spec, ",", 0);<BR>&nbsp;&nbsp;&nbsp; int i;</P>
<P>&nbsp;&nbsp;&nbsp; if (debug_regions) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_array_unref(debug_regions);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; debug_regions = NULL;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; debug_regions = g_array_sized_new(FALSE, FALSE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(Range), g_strv_length(ranges));<BR>&nbsp;&nbsp;&nbsp; for (i = 0; ranges[i]; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *r = ranges[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *range_op, *r2, *e;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t r1val, r2val, lob, upb;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct Range range;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range_op = strstr(r, "-");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2 = range_op ? range_op + 1 : NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!range_op) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range_op = strstr(r, "+");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2 = range_op ? range_op + 1 : NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!range_op) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range_op = strstr(r, "..");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2 = range_op ? range_op + 2 : NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!range_op) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "Bad range specifier");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (qemu_strtoull(r, &amp;e, 0, &amp;r1val)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || e != range_op) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "Invalid number to the left of %.*s",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)(r2 - range_op), range_op);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (qemu_strtoull(r2, NULL, 0, &amp;r2val)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "Invalid number to the right of %.*s",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int)(r2 - range_op), range_op);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (*range_op) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case '+':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lob = r1val;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; upb = r1val + r2val - 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case '-':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; upb = r1val;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lob = r1val - (r2val - 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case '.':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lob = r1val;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; upb = r2val;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lob &gt; upb) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "Invalid range");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range_set_bounds(&amp;range, lob, upb);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_array_append_val(debug_regions, range);<BR>&nbsp;&nbsp;&nbsp; }<BR>out:<BR>&nbsp;&nbsp;&nbsp; g_strfreev(ranges);<BR>}</P>
<P>/* fflush() the log file */<BR>void qemu_log_flush(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; fflush(qemu_logfile);<BR>}</P>
<P>/* Close the log file */<BR>void qemu_log_close(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (qemu_logfile) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (qemu_logfile != stderr) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(qemu_logfile);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_logfile = NULL;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P><FONT class=extract>const QEMULogItem qemu_log_items[] = {<BR>&nbsp;&nbsp;&nbsp; { CPU_LOG_TB_OUT_ASM, "out_asm",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "show generated host assembly code for each compiled TB" },<BR>&nbsp;&nbsp;&nbsp; { CPU_LOG_TB_IN_ASM, "in_asm",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "show target assembly code for each compiled TB" },<BR>&nbsp;&nbsp;&nbsp; { CPU_LOG_TB_OP, "op",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "show micro ops for each compiled TB" },<BR>&nbsp;&nbsp;&nbsp; { CPU_LOG_TB_OP_OPT, "op_opt",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "show micro ops after optimization" },<BR>&nbsp;&nbsp;&nbsp; { CPU_LOG_TB_OP_IND, "op_ind",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "show micro ops before indirect lowering" },<BR>&nbsp;&nbsp;&nbsp; { CPU_LOG_INT, "int",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "show interrupts/exceptions in short format" },<BR>&nbsp;&nbsp;&nbsp; { CPU_LOG_EXEC, "exec",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "show trace before each executed TB (lots of logs)" },<BR>&nbsp;&nbsp;&nbsp; { CPU_LOG_TB_CPU, "cpu",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "show CPU registers before entering a TB (lots of logs)" },<BR>&nbsp;&nbsp;&nbsp; { CPU_LOG_MMU, "mmu",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "log MMU-related activities" },<BR>&nbsp;&nbsp;&nbsp; { CPU_LOG_PCALL, "pcall",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "x86 only: show protected mode far calls/returns/exceptions" },<BR>&nbsp;&nbsp;&nbsp; { CPU_LOG_RESET, "cpu_reset",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "show CPU state before CPU resets" },<BR>&nbsp;&nbsp;&nbsp; { LOG_UNIMP, "unimp",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "log unimplemented functionality" },<BR>&nbsp;&nbsp;&nbsp; { LOG_GUEST_ERROR, "guest_errors",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "log when the guest OS does something invalid (eg accessing a\n"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "non-existent register)" },<BR>&nbsp;&nbsp;&nbsp; { CPU_LOG_PAGE, "page",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "dump pages at beginning of user mode emulation" },<BR>&nbsp;&nbsp;&nbsp; { CPU_LOG_TB_NOCHAIN, "nochain",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "do not chain compiled TBs so that \"exec\" and \"cpu\" show\n"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "complete traces" },<BR>&nbsp;&nbsp;&nbsp; { 0, NULL, NULL },<BR>};</FONT></P>
<P>/* takes a comma separated list of log masks. Return 0 if error. */<BR>int qemu_str_to_log_mask(const char *str)<BR>{<BR>&nbsp;&nbsp;&nbsp; const QEMULogItem *item;<BR>&nbsp;&nbsp;&nbsp; int mask = 0;<BR>&nbsp;&nbsp;&nbsp; char **parts = g_strsplit(str, ",", 0);<BR>&nbsp;&nbsp;&nbsp; char **tmp;</P>
<P>&nbsp;&nbsp;&nbsp; for (tmp = parts; tmp &amp;&amp; *tmp; tmp++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (g_str_equal(*tmp, "all")) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (item = qemu_log_items; item-&gt;mask != 0; item++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= item-&gt;mask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#ifdef CONFIG_TRACE_LOG<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (g_str_has_prefix(*tmp, "trace:") &amp;&amp; (*tmp)[6] != '\0') {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trace_enable_events((*tmp) + 6);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= LOG_TRACE;<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (item = qemu_log_items; item-&gt;mask != 0; item++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (g_str_equal(*tmp, item-&gt;name)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto found;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto error;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= item-&gt;mask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; g_strfreev(parts);<BR>&nbsp;&nbsp;&nbsp; return mask;</P>
<P>&nbsp;error:<BR>&nbsp;&nbsp;&nbsp; g_strfreev(parts);<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>void qemu_print_log_usage(FILE *f)<BR>{<BR>&nbsp;&nbsp;&nbsp; const QEMULogItem *item;<BR>&nbsp;&nbsp;&nbsp; fprintf(f, "Log items (comma separated):\n");<BR>&nbsp;&nbsp;&nbsp; for (item = qemu_log_items; item-&gt;mask != 0; item++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(f, "%-15s %s\n", item-&gt;name, item-&gt;help);<BR>&nbsp;&nbsp;&nbsp; }<BR>#ifdef CONFIG_TRACE_LOG<BR>&nbsp;&nbsp;&nbsp; fprintf(f, "trace:PATTERN&nbsp;&nbsp; enable trace events\n");<BR>&nbsp;&nbsp;&nbsp; fprintf(f, "\nUse \"-d trace:help\" to get a list of trace events.\n\n");<BR>#endif<BR>}