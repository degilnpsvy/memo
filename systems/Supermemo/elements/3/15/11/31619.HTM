# qemu:include/exec/helper-head.h 
<P></P>
<P><FONT class=extract>/* Helper file for declaring TCG helper functions.<BR>&nbsp;&nbsp; Used by other helper files.</FONT></P>
<P><FONT class=extract></FONT></P>
<P><FONT class=extract>&nbsp;&nbsp; Targets should use DEF_HELPER_N and DEF_HELPER_FLAGS_N to declare helper<BR>&nbsp;&nbsp; functions.&nbsp; Names should be specified without the helper_ prefix, and<BR>&nbsp;&nbsp; the return and argument types specified.&nbsp; 3 basic types are understood<BR>&nbsp;&nbsp; (i32, i64 and ptr).&nbsp; Additional aliases are provided for convenience and<BR>&nbsp;&nbsp; to match the types used by the C helper implementation.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp; The target helper.h should be included in all files that use/define<BR>&nbsp;&nbsp; helper functions.&nbsp; THis will ensure that function prototypes are<BR>&nbsp;&nbsp; consistent.&nbsp; In addition it should be included an extra two times for<BR>&nbsp;&nbsp; helper.c, defining:<BR>&nbsp;&nbsp;&nbsp; GEN_HELPER 1 to produce op generation functions (gen_helper_*)<BR>&nbsp;&nbsp;&nbsp; GEN_HELPER 2 to do runtime registration helper functions.<BR>&nbsp;*/</FONT></P>
<P>#ifndef EXEC_HELPER_HEAD_H<BR>#define EXEC_HELPER_HEAD_H</P>
<P>#define HELPER(name) glue(helper_, name)</P>
<P>#define GET_TCGV_i32 GET_TCGV_I32<BR>#define GET_TCGV_i64 GET_TCGV_I64<BR>#define GET_TCGV_ptr GET_TCGV_PTR</P>
<P>/* Some types that make sense in C, but not for TCG.&nbsp; */<BR>#define dh_alias_i32 i32<BR>#define dh_alias_s32 i32<BR>#define dh_alias_int i32<BR>#define dh_alias_i64 i64<BR>#define dh_alias_s64 i64<BR>#define dh_alias_f32 i32<BR>#define dh_alias_f64 i64<BR>#define dh_alias_ptr ptr<BR>#define dh_alias_void void<BR>#define dh_alias_noreturn noreturn<BR>#define dh_alias(t) glue(dh_alias_, t)</P>
<P>#define dh_ctype_i32 uint32_t<BR>#define dh_ctype_s32 int32_t<BR>#define dh_ctype_int int<BR>#define dh_ctype_i64 uint64_t<BR>#define dh_ctype_s64 int64_t<BR>#define dh_ctype_f32 float32<BR>#define dh_ctype_f64 float64<BR>#define dh_ctype_ptr void *<BR>#define dh_ctype_void void<BR>#define dh_ctype_noreturn void QEMU_NORETURN<BR>#define dh_ctype(t) dh_ctype_##t</P>
<P>#ifdef NEED_CPU_H<BR># ifdef TARGET_LONG_BITS<BR>#&nbsp; if TARGET_LONG_BITS == 32<BR>#&nbsp;&nbsp; define dh_alias_tl i32<BR>#&nbsp; else<BR>#&nbsp;&nbsp; define dh_alias_tl i64<BR>#&nbsp; endif<BR># endif<BR># define dh_alias_env ptr<BR># define dh_ctype_tl target_ulong<BR># define dh_ctype_env CPUArchState *<BR>#endif</P>
<P>/* We can't use glue() here because it falls foul of C preprocessor<BR>&nbsp;&nbsp; recursive expansion rules.&nbsp; */<BR>#define dh_retvar_decl0_void void<BR>#define dh_retvar_decl0_noreturn void<BR>#define dh_retvar_decl0_i32 TCGv_i32 retval<BR>#define dh_retvar_decl0_i64 TCGv_i64 retval<BR>#define dh_retvar_decl0_ptr TCGv_ptr retval<BR>#define dh_retvar_decl0(t) glue(dh_retvar_decl0_, dh_alias(t))</P>
<P>#define dh_retvar_decl_void<BR>#define dh_retvar_decl_noreturn<BR>#define dh_retvar_decl_i32 TCGv_i32 retval,<BR>#define dh_retvar_decl_i64 TCGv_i64 retval,<BR>#define dh_retvar_decl_ptr TCGv_ptr retval,<BR>#define dh_retvar_decl(t) glue(dh_retvar_decl_, dh_alias(t))</P>
<P>#define dh_retvar_void TCG_CALL_DUMMY_ARG<BR>#define dh_retvar_noreturn TCG_CALL_DUMMY_ARG<BR>#define dh_retvar_i32 GET_TCGV_i32(retval)<BR>#define dh_retvar_i64 GET_TCGV_i64(retval)<BR>#define dh_retvar_ptr GET_TCGV_ptr(retval)<BR>#define dh_retvar(t) glue(dh_retvar_, dh_alias(t))</P>
<P>#define dh_is_64bit_void 0<BR>#define dh_is_64bit_noreturn 0<BR>#define dh_is_64bit_i32 0<BR>#define dh_is_64bit_i64 1<BR>#define dh_is_64bit_ptr (sizeof(void *) == 8)<BR>#define dh_is_64bit(t) glue(dh_is_64bit_, dh_alias(t))</P>
<P>#define dh_is_signed_void 0<BR>#define dh_is_signed_noreturn 0<BR>#define dh_is_signed_i32 0<BR>#define dh_is_signed_s32 1<BR>#define dh_is_signed_i64 0<BR>#define dh_is_signed_s64 1<BR>#define dh_is_signed_f32 0<BR>#define dh_is_signed_f64 0<BR>#define dh_is_signed_tl&nbsp; 0<BR>#define dh_is_signed_int 1<BR>/* ??? This is highly specific to the host cpu.&nbsp; There are even special<BR>&nbsp;&nbsp; extension instructions that may be required, e.g. ia64's addp4.&nbsp; But<BR>&nbsp;&nbsp; for now we don't support any 64-bit targets with 32-bit pointers.&nbsp; */<BR>#define dh_is_signed_ptr 0<BR>#define dh_is_signed_env dh_is_signed_ptr<BR>#define dh_is_signed(t) dh_is_signed_##t</P>
<P>#define dh_sizemask(t, n) \<BR>&nbsp; ((dh_is_64bit(t) &lt;&lt; (n*2)) | (dh_is_signed(t) &lt;&lt; (n*2+1)))</P>
<P>#define dh_arg(t, n) \<BR>&nbsp; glue(GET_TCGV_, dh_alias(t))(glue(arg, n))</P>
<P>#define dh_arg_decl(t, n) glue(TCGv_, dh_alias(t)) glue(arg, n)</P>
<P>#define DEF_HELPER_0(name, ret) \<BR>&nbsp;&nbsp;&nbsp; DEF_HELPER_FLAGS_0(name, 0, ret)<BR>#define DEF_HELPER_1(name, ret, t1) \<BR>&nbsp;&nbsp;&nbsp; DEF_HELPER_FLAGS_1(name, 0, ret, t1)<BR>#define DEF_HELPER_2(name, ret, t1, t2) \<BR>&nbsp;&nbsp;&nbsp; DEF_HELPER_FLAGS_2(name, 0, ret, t1, t2)<BR>#define DEF_HELPER_3(name, ret, t1, t2, t3) \<BR>&nbsp;&nbsp;&nbsp; DEF_HELPER_FLAGS_3(name, 0, ret, t1, t2, t3)<BR>#define DEF_HELPER_4(name, ret, t1, t2, t3, t4) \<BR>&nbsp;&nbsp;&nbsp; DEF_HELPER_FLAGS_4(name, 0, ret, t1, t2, t3, t4)<BR>#define DEF_HELPER_5(name, ret, t1, t2, t3, t4, t5) \<BR>&nbsp;&nbsp;&nbsp; DEF_HELPER_FLAGS_5(name, 0, ret, t1, t2, t3, t4, t5)</P>
<P>/* MAX_OPC_PARAM_IARGS must be set to n if last entry is DEF_HELPER_FLAGS_n. */</P>
<P>#endif /* EXEC_HELPER_HEAD_H */