/* main execution loop */</P>
<P>int cpu_exec(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUClass *cc = CPU_GET_CLASS(cpu);<BR>&nbsp;&nbsp;&nbsp; int ret;<BR>&nbsp;&nbsp;&nbsp; SyncClocks sc;</P>
<P>&nbsp;&nbsp;&nbsp; /* replay_interrupt may need current_cpu */<BR>&nbsp;&nbsp;&nbsp; current_cpu = cpu;</P>
<P>&nbsp;&nbsp;&nbsp; if (cpu_handle_halt(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return EXCP_HALTED;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; atomic_mb_set(&amp;tcg_current_cpu, cpu);<BR>&nbsp;&nbsp;&nbsp; rcu_read_lock();</P>
<P>&nbsp;&nbsp;&nbsp; if (unlikely(atomic_mb_read(&amp;exit_request))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;exit_request = 1;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cc-&gt;cpu_exec_enter(cpu);</P>
<P>&nbsp;&nbsp;&nbsp; /* Calculate difference between guest clock and host clock.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This delay includes the delay of the last cycle, so<BR>&nbsp;&nbsp;&nbsp;&nbsp; * what we have to do is sleep until it is 0. As for the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * advance/delay we gain here, we try to fix it next time.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; init_delay_params(&amp;sc, cpu);</P>
<P>&nbsp;&nbsp;&nbsp; for(;;) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* prepare setjmp context for exception handling */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sigsetjmp(cpu-&gt;jmp_env, 0) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslationBlock *tb, *last_tb = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tb_exit = 0;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* if an exception is pending, we execute it here */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cpu_handle_exception(cpu, &amp;ret)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;tb_flushed = false; /* reset before first TB lookup */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_handle_interrupt(cpu, &amp;last_tb);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb = tb_find_fast(cpu, &amp;last_tb, tb_exit);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_loop_exec_tb(cpu, tb, &amp;last_tb, &amp;tb_exit, &amp;sc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Try to align the host and virtual clocks<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if the guest is in advance */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; align_clocks(&amp;sc, cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } /* for(;;) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Some compilers wrongly smash all local variables after<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * siglongjmp. There were bug reports for gcc 4.5.0 and clang.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Reload essential local variables here for those compilers.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Newer versions of gcc would complain about this code (-Wclobbered). */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu = current_cpu;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc = CPU_GET_CLASS(cpu);<BR>#else /* buggy compiler */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Assert that the compiler does not smash local variables. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert(cpu == current_cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert(cc == CPU_GET_CLASS(cpu));<BR>#endif /* buggy compiler */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;can_do_io = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb_lock_reset();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } /* for(;;) */</P>
<P>&nbsp;&nbsp;&nbsp; cc-&gt;cpu_exec_exit(cpu);<BR>&nbsp;&nbsp;&nbsp; rcu_read_unlock();</P>
<P>&nbsp;&nbsp;&nbsp; /* fail safe : never use current_cpu outside cpu_exec() */<BR>&nbsp;&nbsp;&nbsp; current_cpu = NULL;</P>
<P>&nbsp;&nbsp;&nbsp; /* Does not need atomic_mb_set because a spurious wakeup is okay.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; atomic_set(&amp;tcg_current_cpu, NULL);<BR>&nbsp;&nbsp;&nbsp; return ret;<BR>}