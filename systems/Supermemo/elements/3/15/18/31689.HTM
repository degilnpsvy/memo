B6.5 Load-Exclusive and Store-Exclusive instruction constraints</P>
<P>IRTHW The Load-Exclusive and Store-Exclusive instructions are intended to work together as a pair, for example a LDREX/STREX pair or a LDREXB/STREXB pair.</P>
<P>RBHPN The architecture does not require an address or size check as part of the IsExclusiveLocal() function.</P>
<P>RLHLG If two StoreExcl instructions are executed without an intervening LoadExcl instruction the second StoreExcl instruction returns a status value of 1.</P>
<P>RDVRQ The architecture does not require every LoadExcl instruction to have a subsequent StoreExcl instruction.</P>
<P>RJXXS If the transaction size of a StoreExcl instruction is different from the preceding LoadExcl instruction in the same thread of execution, behavior is a CONSTRAINED UNPREDICTABLE choice of:<BR>&#8226; The StoreExcl either passes or fails, and the status value returned by the StoreExcl is UNKNOWN.<BR>&#8226; The block of data of the size of the larger of the transaction sizes used by the LoadExcl/StoreExcl pair at the address accessed by the LoadExcl/StoreExcl pair, is UNKNOWN.</P>
<P>RGVWN The hardware only ensures that a LoadExcl/StoreExcl pair succeeds if the LoadExcl and the StoreExcl have the same transaction size.</P>
<P>RXLSK Forward progress can only be made using LoadExcl/StoreExcl loops if, for any LoadExcl/StoreExcl loop within a single thread of execution if both of the following are true:<BR>&#8226; There are no explicit memory accesses, pre-loads, direct or indirect register writes, cache maintenance instructions, SVC instructions, or exception returns between the Load-Exclusive and the Store-Exclusive.<BR>&#8226; The following conditions apply between the Store-Exclusive having returned a fail result and the retry of the Load-Exclusive:<BR>&nbsp; &#8213; There are no stores to any location within the same Exclusives reservation granule that the Store-Exclusive is accessing.<BR>&nbsp; &#8213; There are no direct or indirect register writes, other than changes to the flag fields in APSR or FPSCR, caused by data processing or comparison instructions.<BR>&nbsp; &#8213; There are no direct or indirect cache maintenance instructions, SVC instructions, or exception returns.<BR>&nbsp; The exclusive monitor can be cleared at any time without an application-related cause, provided that such clearing is not systematically repeated so as to prevent the forward progress in finite time of at least one of the threads that is accessing the exclusive monitor.<BR>&nbsp; <BR>IRFXR Keeping the LoadExcl and the StoreExcl operations close together in a single thread of execution minimizes the chance of the exclusive monitor state being cleared between the LoadExcl instruction and the StoreExcl instruction. Therefore, for best performance, ARM strongly recommends a limit of 128 bytes between LoadExcl and StoreExcl instructions in a single thread of execution.</P>
<P>RPKQF The architecture sets an upper limit of 2048 bytes on the Exclusives reservation granule that can be marked as exclusive.</P>
<P>IPGGN For performance reasons, ARM recommends that objects that are accessed by exclusive accesses are separated by the size of the exclusive reservations granule.</P>
<P>RXPDN After taking a BusFault or a MemManage fault, the state of the exclusive monitors is UNKNOWN.</P>
<P>RFCRN For the memory location accessed by a LoadExcl/StoreExcl pair, if the memory attributes for a StoreExcl instruction are different from the memory attributes for the preceding LoadExcl instruction in the same thread of execution, behavior is CONSTRAINED UNPREDICTABLE.</P>
<P>RDMJW The effect of a data or unified cache invalidate, clean, or clean and invalidate instruction on a local exclusive monitor or a global exclusive monitor that is in the Exclusive Access state is CONSTRAINED UNPREDICTABLE, and the instruction might clear the monitor, or it might leave it in the Exclusive Access state. For address-based maintenance instructions, this also applies to the monitors of other PEs in the same Shareability domain as the PE executing the cache maintenance instruction, as determined by the Shareability domain of the address being maintained.</P>
<P>IMDHL ARM strongly recommends that implementations ensure that the use of such maintenance instructions by a PE in the Non-secure state cannot cause a denial of service on a PE in the Secure state.</P>
<P>RRRTJ In the event of repeatedly-contending LoadExcl/StoreExcl instruction sequences from multiple PEs, an implementation must ensure that forward progress is made by at least one PE.</P>
<P>See also:<BR>&#8226; Load-Exclusive/Store-Exclusive pairs on page G1-1336.