DataAddressMatch() DWT comparator data address matching Comparator behavior for data address matching on page C1-861<BR>The following pseudocode shows the comparator behavior for data address matching:</P>
<P>enumeration sizeofaccess (byte, halfword, word);<BR>boolean validDaddr; // conditions for selecting Daddr from<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...configuraton of the relevant DWT_FUNCTIONx register<BR>if validDaddr then<BR>&nbsp;&nbsp;&nbsp; match = DataAddressMatch(N, Daddr, Dsize);<BR>&nbsp;&nbsp;&nbsp; return match;</P>
<P>// DataAddressMatch()<BR>// ==================</P>
<P>boolean DataAddressMatch(integer N, bits(32) address, sizeofaccess size)</P>
<P>&nbsp;&nbsp;&nbsp; // UNPREDICTABLE if the base compare address is not properly aligned<BR>&nbsp;&nbsp;&nbsp; mask = ZeroExtend(Ones(UInt(DWT_MASK[N]&lt;4:0&gt;)), 32);<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // compute start and end addresses of compared region<BR>&nbsp;&nbsp;&nbsp; comp_start = DWT_COMP[N]&lt;31:0&gt;;<BR>&nbsp;&nbsp;&nbsp; if !IsZero(comp_start AND mask) then UNPREDICTABLE;<BR>&nbsp;&nbsp;&nbsp; comp_end = comp_start + mask;<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // compute start and end addresses of access<BR>&nbsp;&nbsp;&nbsp; access_start = address;<BR>&nbsp;&nbsp;&nbsp; case size of<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when word<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_end = access_start + 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when halfword<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_end = access_start + 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when byte<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_end = access_start;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // Implementations can terminate matching on a word aligned address boundary &gt; access_start<BR>&nbsp;&nbsp;&nbsp; if (IMPLEMENTATION DEFINED condition) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = ((access_end + 1) &amp; ~3) - 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (temp &gt; access_start) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_end = temp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; match = (access_start &gt;= comp_start &amp;&amp; access_start &lt;= comp_end) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (access_end &gt;= comp_start &amp;&amp; access_end &lt;= comp_end) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (access_start &lt;= comp_start &amp;&amp; access_end &gt;= comp_end);<BR>&nbsp;&nbsp;&nbsp; return match;