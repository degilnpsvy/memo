PreserveFPState() Saves FP state to the stack Saving FP state on page B1-687</P>
<P>// PreserveFPState()<BR>// ==================</P>
<P>PreserveFPState()<BR>&nbsp;&nbsp;&nbsp; // Preserve FP state using address, privilege and relative<BR>&nbsp;&nbsp;&nbsp; // priorities recorded during original stacking. Derived<BR>&nbsp;&nbsp;&nbsp; // exceptions are handled by TakePreserveFPException().<BR>&nbsp;&nbsp;&nbsp; // The checks usually performed for stacking using ValidateAddress()<BR>&nbsp;&nbsp;&nbsp; // are performed, with the value of ExecutionPriority()<BR>&nbsp;&nbsp;&nbsp; // overridden by -1 if FPCCR.HFRDY == &#8216;0&#8217;.<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; ispriv = FPCCR.USER == &#8216;0&#8217;;<BR>&nbsp;&nbsp;&nbsp; for i = 0 to 15<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidateAddress(FPCAR+(4*i),ispriv,TRUE,FALSE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemA[FPCAR+(4*i),4] = S[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; ValidateAddress(FPCAR+0x40,ispriv,TRUE,FALSE);<BR>&nbsp;&nbsp;&nbsp; MemA[FPCAR+0x40,4] = FPSCR;<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // Whether these stores are interruptible is<BR>&nbsp;&nbsp;&nbsp; // IMPLEMENTATION DEFINED. The processor can clear FPCCR.LSPACT<BR>&nbsp;&nbsp;&nbsp; // to zero and make the FP register contents UNKNOWN only if all<BR>&nbsp;&nbsp;&nbsp; // stores complete successfully, or if the stores are abandoned<BR>&nbsp;&nbsp;&nbsp; // in response to a bus or memory protection fault.<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; FPCCR.LSPACT = &#8216;0&#8217;;<BR>&nbsp;&nbsp;&nbsp; S[0..15] = bits(31) UNKNOWN;<BR>&nbsp;&nbsp;&nbsp; FPSCR = bits(32) UNKNOWN;<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; return;