MemU_with_priv[] Memory access without alignment requirement, at specified privilege level 
<P></P>
<P>// MemU_with_priv[]<BR>// ================<BR>//<BR>// Due to single-copy atomicity constraints, the aligned accesses are distinguished from<BR>// the unaligned accesses:<BR>// * aligned accesses are performed at their size<BR>// * unaligned accesses are expressed as a set of bytes.<BR>// Non-assignment form</P>
<P>bits(8*size) MemU_with_priv[bits(32) address, integer size, boolean privileged]</P>
<P>&nbsp;&nbsp;&nbsp; bits(8*size) value;<BR>&nbsp;&nbsp;&nbsp; // Do aligned access, take alignment fault, or do sequence of bytes<BR>&nbsp;&nbsp;&nbsp; if address == Align(address, size) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = MemA_with_priv[address, size, privileged];<BR>&nbsp;&nbsp;&nbsp; elsif CCR.UNALIGN_TRP == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.UNALIGNED = &#8217;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault);<BR>&nbsp;&nbsp;&nbsp; else // if unaligned access<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i = 0 to size-1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value&lt;8*i+7:8*i&gt; = MemA_with_priv[address+i, 1, privileged];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if AIRCR.ENDIANNESS == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = BigEndianReverse(value, size);<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; return value;</P>
<P>// Assignment form</P>
<P>MemU_with_priv[bits(32) address, integer size, boolean privileged] = bits(8*size) value</P>
<P>&nbsp;&nbsp;&nbsp; // Do aligned access, take alignment fault, or do sequence of bytes<BR>&nbsp;&nbsp;&nbsp; if address == Align(address, size) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemA_with_priv[address, value, privileged] = value;<BR>&nbsp;&nbsp;&nbsp; elsif CCR.UNALIGN_TRP == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.UNALIGNED = &#8217;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault);<BR>&nbsp;&nbsp;&nbsp; else // if unaligned access<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if AIRCR.ENDIANNESS == &#8217;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = BigEndianReverse(value, size);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i = 0 to size-1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemA_with_priv[address+i, 1, privileged] = value&lt;8*i+7:8*i&gt;;<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; return;