PopStack() Stack restore sequence on an exception return </P>
<P>Exception return behavior on page B1-652</P>
<P>&nbsp;</P>
<P></P>
<P>// PopStack()<BR>// ==========</P>
<P>PopStack(bits(32) frameptr) /* only stack locations, not the load order, are architected */</P>
<P>&nbsp;&nbsp;&nbsp; if HaveFPExt() &amp;&amp; EXC_RETURN&lt;4&gt; == &#8216;0&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; framesize = 0x68;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forcealign = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; framesize = 0x20;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forcealign = CCR.STKALIGN;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; R[0] = MemA[frameptr,4];<BR>&nbsp;&nbsp;&nbsp; R[1] = MemA[frameptr+0x4,4];<BR>&nbsp;&nbsp;&nbsp; R[2] = MemA[frameptr+0x8,4];<BR>&nbsp;&nbsp;&nbsp; R[3] = MemA[frameptr+0xC,4];<BR>&nbsp;&nbsp;&nbsp; R[12] = MemA[frameptr+0x10,4];<BR>&nbsp;&nbsp;&nbsp; LR = MemA[frameptr+0x14,4];<BR>&nbsp;&nbsp;&nbsp; PC = MemA[frameptr+0x18,4]; // UNPREDICTABLE if the new PC not halfword aligned<BR>&nbsp;&nbsp;&nbsp; psr = MemA[frameptr+0x1C,4];<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; if HaveFPExt() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if EXC_RETURN&lt;4&gt; == &#8216;0&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if FPCCR.LSPACT == &#8216;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.LSPACT = &#8216;0&#8217;; // state in FP is still valid<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CheckVFPEnabled();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i = 0 to 15<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S[i] = MemA[frameptr+0x20+(4*i),4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPSCR = MemA[frameptr+0x60,4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTROL.FPCA = NOT(EXC_RETURN&lt;4&gt;);</P>
<P>&nbsp;&nbsp;&nbsp; spmask = Zeros(29)((psr&lt;9&gt; AND forcealign):&#8217;00&#8217;;</P>
<P>&nbsp;&nbsp;&nbsp; case EXC_RETURN&lt;3:0&gt; of<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when &#8216;0001&#8217; // returning to Handler<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SP_main = (SP_main + framesize) OR spmask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when &#8216;1001&#8217; // returning to Thread using Main stack<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SP_main = (SP_main + framesize) OR spmask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when &#8216;1101&#8217; // returning to Thread using Process stack<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SP_process = (SP_process + framesize) OR spmask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; APSR&lt;31:27&gt; = psr&lt;31:27&gt;; // valid APSR bits loaded from memory<BR>&nbsp;&nbsp;&nbsp; if HaveDSPExt() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; APSR&lt;19:16&gt; = psr&lt;19:16&gt;;<BR>&nbsp;&nbsp;&nbsp; IPSR&lt;8:0&gt; = psr&lt;8:0&gt;; // valid IPSR bits loaded from memory<BR>&nbsp;&nbsp;&nbsp; EPSR&lt;26:24,15:10&gt; = psr&lt;26:24,15:10&gt;; // valid EPSR bits loaded from memory<BR>&nbsp;&nbsp;&nbsp; return;