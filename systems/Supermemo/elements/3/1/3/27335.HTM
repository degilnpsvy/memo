AddWithCarry() 
<P></P>
<P>Addition of bitstrings, with carry input and carry/overflow outputs </P>
<P>Pseudocode details of addition and subtraction on page A2-43</P>
<P><BR>In pseudocode the AddWithCarry() function provides an addition with a carry input and carry and overflow outputs:<BR>// AddWithCarry()<BR>// ==============</P>
<P></P>
<P>(bits(N), bit, bit) AddWithCarry(bits(N) x, bits(N) y, bit carry_in)<BR>&nbsp;&nbsp;&nbsp; unsigned_sum = UInt(x) + UInt(y) + UInt(carry_in);<BR>&nbsp;&nbsp;&nbsp; signed_sum = SInt(x) + SInt(y) + UInt(carry_in);<BR>&nbsp;&nbsp;&nbsp; result = unsigned_sum&lt;N-1:0&gt;; // same value as signed_sum&lt;N-1:0&gt;<BR>&nbsp;&nbsp;&nbsp; carry_out = if UInt(result) == unsigned_sum then &#8216;0&#8217; else &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp; overflow = if SInt(result) == signed_sum then &#8216;0&#8217; else &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp; return (result, carry_out, overflow);<BR>&nbsp;&nbsp;&nbsp; <BR>An important property of the AddWithCarry() function is that if:</P>
<P>(result, carry_out, overflow) = AddWithCarry(x, NOT(y), carry_in) then:</P>
<P>&#8226; If carry_in == '1', then result == x-y with overflow == '1' if signed overflow occurred during the subtraction and carry_out == '1' if unsigned borrow did not occur during the subtraction (that is, if x &gt;= y).<BR>&#8226; If carry_in == '0', then result == x-y-1 with overflow == '1' if signed overflow occurred during the subtraction and carry_out == '1' if unsigned borrow did not occur during the subtraction (that is, if x &gt; y).<BR>Together, these mean that the carry_in and carry_out bits in AddWithCarry() calls can act as NOT borrow flags for subtractions as well as carry flags for additions.