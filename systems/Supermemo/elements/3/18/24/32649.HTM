# qemu:include/qemu-common.h
<P></P>
<P>&nbsp;</P>
<P>/* Common header file that is included by all of QEMU.<BR>&nbsp;*<BR>&nbsp;* This file is supposed to be included only by .c files. No header file should<BR>&nbsp;* depend on qemu-common.h, as this would easily lead to circular header<BR>&nbsp;* dependencies.<BR>&nbsp;*<BR>&nbsp;* If a header file uses a definition from qemu-common.h, that definition<BR>&nbsp;* must be moved to a separate header file, and the header that uses it<BR>&nbsp;* must include that header.<BR>&nbsp;*/<BR>#ifndef QEMU_COMMON_H<BR>#define QEMU_COMMON_H</P>
<P></P>
<P>#include "qemu/fprintf-fn.h"</P>
<P>#define TFR(expr) do { if ((expr) != -1) break; } while (errno == EINTR)</P>
<P>#include "qemu/option.h"</P>
<P>/* Copyright string for -version arguments, About dialogs, etc */<BR>#define QEMU_COPYRIGHT "Copyright (c) 2003-2016 " \<BR>&nbsp;&nbsp;&nbsp; "Fabrice Bellard and the QEMU Project developers"</P>
<P>/* main function, renamed */<BR>#if defined(CONFIG_COCOA)<BR>int qemu_main(int argc, char **argv, char **envp);<BR>#endif</P>
<P>void qemu_get_timedate(struct tm *tm, int offset);<BR>int qemu_timedate_diff(struct tm *tm);</P>
<P>#define qemu_isalnum(c)&nbsp;&nbsp;isalnum((unsigned char)(c))<BR>#define qemu_isalpha(c)&nbsp;&nbsp;isalpha((unsigned char)(c))<BR>#define qemu_iscntrl(c)&nbsp;&nbsp;iscntrl((unsigned char)(c))<BR>#define qemu_isdigit(c)&nbsp;&nbsp;isdigit((unsigned char)(c))<BR>#define qemu_isgraph(c)&nbsp;&nbsp;isgraph((unsigned char)(c))<BR>#define qemu_islower(c)&nbsp;&nbsp;islower((unsigned char)(c))<BR>#define qemu_isprint(c)&nbsp;&nbsp;isprint((unsigned char)(c))<BR>#define qemu_ispunct(c)&nbsp;&nbsp;ispunct((unsigned char)(c))<BR>#define qemu_isspace(c)&nbsp;&nbsp;isspace((unsigned char)(c))<BR>#define qemu_isupper(c)&nbsp;&nbsp;isupper((unsigned char)(c))<BR>#define qemu_isxdigit(c)&nbsp;isxdigit((unsigned char)(c))<BR>#define qemu_tolower(c)&nbsp;&nbsp;tolower((unsigned char)(c))<BR>#define qemu_toupper(c)&nbsp;&nbsp;toupper((unsigned char)(c))<BR>#define qemu_isascii(c)&nbsp;&nbsp;isascii((unsigned char)(c))<BR>#define qemu_toascii(c)&nbsp;&nbsp;toascii((unsigned char)(c))</P>
<P>void *qemu_oom_check(void *ptr);</P>
<P>ssize_t qemu_write_full(int fd, const void *buf, size_t count)<BR>&nbsp;&nbsp;&nbsp; QEMU_WARN_UNUSED_RESULT;</P>
<P>#ifndef _WIN32<BR>int qemu_pipe(int pipefd[2]);<BR>/* like openpty() but also makes it raw; return master fd */<BR>int qemu_openpty_raw(int *aslave, char *pty_name);<BR>#endif</P>
<P>#ifdef _WIN32<BR>/* MinGW needs type casts for the 'buf' and 'optval' arguments. */<BR>#define qemu_getsockopt(sockfd, level, optname, optval, optlen) \<BR>&nbsp;&nbsp;&nbsp; getsockopt(sockfd, level, optname, (void *)optval, optlen)<BR>#define qemu_setsockopt(sockfd, level, optname, optval, optlen) \<BR>&nbsp;&nbsp;&nbsp; setsockopt(sockfd, level, optname, (const void *)optval, optlen)<BR>#define qemu_recv(sockfd, buf, len, flags) recv(sockfd, (void *)buf, len, flags)<BR>#define qemu_sendto(sockfd, buf, len, flags, destaddr, addrlen) \<BR>&nbsp;&nbsp;&nbsp; sendto(sockfd, (const void *)buf, len, flags, destaddr, addrlen)<BR>#else<BR>#define qemu_getsockopt(sockfd, level, optname, optval, optlen) \<BR>&nbsp;&nbsp;&nbsp; getsockopt(sockfd, level, optname, optval, optlen)<BR>#define qemu_setsockopt(sockfd, level, optname, optval, optlen) \<BR>&nbsp;&nbsp;&nbsp; setsockopt(sockfd, level, optname, optval, optlen)<BR>#define qemu_recv(sockfd, buf, len, flags) recv(sockfd, buf, len, flags)<BR>#define qemu_sendto(sockfd, buf, len, flags, destaddr, addrlen) \<BR>&nbsp;&nbsp;&nbsp; sendto(sockfd, buf, len, flags, destaddr, addrlen)<BR>#endif</P>
<P>void tcg_exec_init(unsigned long tb_size);<BR>bool tcg_enabled(void);</P>
<P>void cpu_exec_init_all(void);<BR>void cpu_exec_step_atomic(CPUState *cpu);</P>
<P>/**<BR>&nbsp;* set_preferred_target_page_bits:<BR>&nbsp;* @bits: number of bits needed to represent an address within the page<BR>&nbsp;*<BR>&nbsp;* Set the preferred target page size (the actual target page<BR>&nbsp;* size may be smaller than any given CPU's preference).<BR>&nbsp;* Returns true on success, false on failure (which can only happen<BR>&nbsp;* if this is called after the system has already finalized its<BR>&nbsp;* choice of page size and the requested page size is smaller than that).<BR>&nbsp;*/<BR>bool set_preferred_target_page_bits(int bits);</P>
<P>/**<BR>&nbsp;* Sends a (part of) iovec down a socket, yielding when the socket is full, or<BR>&nbsp;* Receives data into a (part of) iovec from a socket,<BR>&nbsp;* yielding when there is no data in the socket.<BR>&nbsp;* The same interface as qemu_sendv_recvv(), with added yielding.<BR>&nbsp;* XXX should mark these as coroutine_fn<BR>&nbsp;*/<BR>ssize_t qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t offset, size_t bytes, bool do_send);<BR>#define qemu_co_recvv(sockfd, iov, iov_cnt, offset, bytes) \<BR>&nbsp; qemu_co_sendv_recvv(sockfd, iov, iov_cnt, offset, bytes, false)<BR>#define qemu_co_sendv(sockfd, iov, iov_cnt, offset, bytes) \<BR>&nbsp; qemu_co_sendv_recvv(sockfd, iov, iov_cnt, offset, bytes, true)</P>
<P>/**<BR>&nbsp;* The same as above, but with just a single buffer<BR>&nbsp;*/<BR>ssize_t qemu_co_send_recv(int sockfd, void *buf, size_t bytes, bool do_send);<BR>#define qemu_co_recv(sockfd, buf, bytes) \<BR>&nbsp; qemu_co_send_recv(sockfd, buf, bytes, false)<BR>#define qemu_co_send(sockfd, buf, bytes) \<BR>&nbsp; qemu_co_send_recv(sockfd, buf, bytes, true)</P>
<P>void qemu_progress_init(int enabled, float min_skip);<BR>void qemu_progress_end(void);<BR>void qemu_progress_print(float delta, int max);<BR>const char *qemu_get_vm_name(void);</P>
<P>#define QEMU_FILE_TYPE_BIOS&nbsp;&nbsp; 0<BR>#define QEMU_FILE_TYPE_KEYMAP 1<BR>char *qemu_find_file(int type, const char *name);</P>
<P>/* OS specific functions */<BR>void os_setup_early_signal_handling(void);<BR>char *os_find_datadir(void);<BR>void os_parse_cmd_args(int index, const char *optarg);</P>
<P>#include "qemu/module.h"</P>
<P>/*<BR>&nbsp;* Hexdump a buffer to a file. An optional string prefix is added to every line<BR>&nbsp;*/</P>
<P>void qemu_hexdump(const char *buf, FILE *fp, const char *prefix, size_t size);</P>
<P>/*<BR>&nbsp;* helper to parse debug environment variables<BR>&nbsp;*/<BR>int parse_debug_env(const char *name, int max, int initial);</P>
<P>const char *qemu_ether_ntoa(const MACAddr *mac);<BR>void page_size_init(void);</P>
<P>/* returns non-zero if dump is in progress, otherwise zero is<BR>&nbsp;* returned. */<BR>bool dump_in_progress(void);</P>
<P>#endif