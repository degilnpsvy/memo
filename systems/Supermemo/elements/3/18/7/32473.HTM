The following is a collection of compiler macros to provide atomic access to integer and pointer-sized values.</P>
<P>The macros that have 'int' in the name will operate on pointers to <A title=gint class=link href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gint"><SPAN class=type>gint</SPAN></A> and <A title=guint class=link href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#guint"><SPAN class=type>guint</SPAN></A>. The macros with 'pointer' in the name will operate on pointers to any pointer-sized value, including <A title=gsize class=link href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gsize"><SPAN class=type>gsize</SPAN></A>. There is no support for 64bit operations on platforms with 32bit pointers because it is not generally possible to perform these operations atomically.</P>
<P>The get, set and exchange operations for integers and pointers nominally operate on <A title=gint class=link href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gint"><SPAN class=type>gint</SPAN></A> and <A title=gpointer class=link href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gpointer"><SPAN class=type>gpointer</SPAN></A>, respectively. Of the arithmetic operations, the 'add' operation operates on (and returns) signed integer values (<A title=gint class=link href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gint"><SPAN class=type>gint</SPAN></A> and <A title=gssize class=link href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gssize"><SPAN class=type>gssize</SPAN></A>) and the 'and', 'or', and 'xor' operations operate on (and return) unsigned integer values (<A title=guint class=link href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#guint"><SPAN class=type>guint</SPAN></A> and <A title=gsize class=link href="https://developer.gnome.org/glib/stable/glib-Basic-Types.html#gsize"><SPAN class=type>gsize</SPAN></A>).</P>
<P>All of the operations act as a full compiler and (where appropriate) hardware memory barrier. Acquire and release or producer and consumer barrier semantics are not available through this API.</P>
<P>It is very important that all accesses to a particular integer or pointer be performed using only this API and that different sizes of operation are not mixed or used on overlapping memory regions. Never read or assign directly from or to a value -- always use this API.</P>
<P>For simple reference counting purposes you should use <A title=g_atomic_int_inc&nbsp;() class=link href="https://developer.gnome.org/glib/stable/glib-Atomic-Operations.html#g-atomic-int-inc"><CODE class=function>g_atomic_int_inc()</CODE></A> and <A title=g_atomic_int_dec_and_test&nbsp;() class=link href="https://developer.gnome.org/glib/stable/glib-Atomic-Operations.html#g-atomic-int-dec-and-test"><CODE class=function>g_atomic_int_dec_and_test()</CODE></A>. Other uses that fall outside of simple reference counting patterns are prone to subtle bugs and occasionally undefined behaviour. It is also worth noting that since all of these operations require global synchronisation of the entire machine, they can be quite slow. In * the case of performing multiple atomic operations it can often be faster to simply acquire a mutex lock around the critical area, perform the operations normally and then release the lock.