# qemu:include/qemu/bitops.h
<P></P>
<P>&nbsp;</P>
<P>/*<BR>&nbsp;* Bitops Module<BR>&nbsp;*<BR>&nbsp;* Copyright (C) 2010 Corentin Chary &lt;<A href="mailto:corentin.chary@gmail.com">corentin.chary@gmail.com</A>&gt;<BR>&nbsp;*<BR>&nbsp;* Mostly inspired by (stolen from) linux/bitmap.h and linux/bitops.h<BR>&nbsp;*<BR>&nbsp;* This work is licensed under the terms of the GNU LGPL, version 2.1 or later.<BR>&nbsp;* See the COPYING.LIB file in the top-level directory.<BR>&nbsp;*/</P>
<P></P>
<P>#ifndef BITOPS_H<BR>#define BITOPS_H</P>
<P><BR>#include "host-utils.h"<BR>#include "atomic.h"</P>
<P>#define BITS_PER_BYTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHAR_BIT<BR>#define BITS_PER_LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (sizeof (unsigned long) * BITS_PER_BYTE)</P>
<P>#define BIT(nr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1UL &lt;&lt; (nr))<BR>#define BIT_MASK(nr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1UL &lt;&lt; ((nr) % BITS_PER_LONG))<BR>#define BIT_WORD(nr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((nr) / BITS_PER_LONG)<BR>#define BITS_TO_LONGS(nr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))</P>
<P>#define MAKE_64BIT_MASK(shift, length) \<BR>&nbsp;&nbsp;&nbsp; (((~0ULL) &gt;&gt; (64 - (length))) &lt;&lt; (shift))</P>
<P>/**<BR>&nbsp;* set_bit - Set a bit in memory<BR>&nbsp;* @nr: the bit to set<BR>&nbsp;* @addr: the address to start counting from<BR>&nbsp;*/<BR>static inline void set_bit(long nr, unsigned long *addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned long mask = BIT_MASK(nr);<BR>&nbsp;&nbsp;&nbsp; unsigned long *p = addr + BIT_WORD(nr);</P>
<P>&nbsp;&nbsp;&nbsp; *p&nbsp; |= mask;<BR>}</P>
<P>/**<BR>&nbsp;* set_bit_atomic - Set a bit in memory atomically<BR>&nbsp;* @nr: the bit to set<BR>&nbsp;* @addr: the address to start counting from<BR>&nbsp;*/<BR>static inline void set_bit_atomic(long nr, unsigned long *addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned long mask = BIT_MASK(nr);<BR>&nbsp;&nbsp;&nbsp; unsigned long *p = addr + BIT_WORD(nr);</P>
<P>&nbsp;&nbsp;&nbsp; atomic_or(p, mask);<BR>}</P>
<P>/**<BR>&nbsp;* clear_bit - Clears a bit in memory<BR>&nbsp;* @nr: Bit to clear<BR>&nbsp;* @addr: Address to start counting from<BR>&nbsp;*/<BR>static inline void clear_bit(long nr, unsigned long *addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned long mask = BIT_MASK(nr);<BR>&nbsp;&nbsp;&nbsp; unsigned long *p = addr + BIT_WORD(nr);</P>
<P>&nbsp;&nbsp;&nbsp; *p &amp;= ~mask;<BR>}</P>
<P>/**<BR>&nbsp;* change_bit - Toggle a bit in memory<BR>&nbsp;* @nr: Bit to change<BR>&nbsp;* @addr: Address to start counting from<BR>&nbsp;*/<BR>static inline void change_bit(long nr, unsigned long *addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned long mask = BIT_MASK(nr);<BR>&nbsp;&nbsp;&nbsp; unsigned long *p = addr + BIT_WORD(nr);</P>
<P>&nbsp;&nbsp;&nbsp; *p ^= mask;<BR>}</P>
<P>/**<BR>&nbsp;* test_and_set_bit - Set a bit and return its old value<BR>&nbsp;* @nr: Bit to set<BR>&nbsp;* @addr: Address to count from<BR>&nbsp;*/<BR>static inline int test_and_set_bit(long nr, unsigned long *addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned long mask = BIT_MASK(nr);<BR>&nbsp;&nbsp;&nbsp; unsigned long *p = addr + BIT_WORD(nr);<BR>&nbsp;&nbsp;&nbsp; unsigned long old = *p;</P>
<P>&nbsp;&nbsp;&nbsp; *p = old | mask;<BR>&nbsp;&nbsp;&nbsp; return (old &amp; mask) != 0;<BR>}</P>
<P>/**<BR>&nbsp;* test_and_clear_bit - Clear a bit and return its old value<BR>&nbsp;* @nr: Bit to clear<BR>&nbsp;* @addr: Address to count from<BR>&nbsp;*/<BR>static inline int test_and_clear_bit(long nr, unsigned long *addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned long mask = BIT_MASK(nr);<BR>&nbsp;&nbsp;&nbsp; unsigned long *p = addr + BIT_WORD(nr);<BR>&nbsp;&nbsp;&nbsp; unsigned long old = *p;</P>
<P>&nbsp;&nbsp;&nbsp; *p = old &amp; ~mask;<BR>&nbsp;&nbsp;&nbsp; return (old &amp; mask) != 0;<BR>}</P>
<P>/**<BR>&nbsp;* test_and_change_bit - Change a bit and return its old value<BR>&nbsp;* @nr: Bit to change<BR>&nbsp;* @addr: Address to count from<BR>&nbsp;*/<BR>static inline int test_and_change_bit(long nr, unsigned long *addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned long mask = BIT_MASK(nr);<BR>&nbsp;&nbsp;&nbsp; unsigned long *p = addr + BIT_WORD(nr);<BR>&nbsp;&nbsp;&nbsp; unsigned long old = *p;</P>
<P>&nbsp;&nbsp;&nbsp; *p = old ^ mask;<BR>&nbsp;&nbsp;&nbsp; return (old &amp; mask) != 0;<BR>}</P>
<P>/**<BR>&nbsp;* test_bit - Determine whether a bit is set<BR>&nbsp;* @nr: bit number to test<BR>&nbsp;* @addr: Address to start counting from<BR>&nbsp;*/<BR>static inline int test_bit(long nr, const unsigned long *addr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return 1UL &amp; (addr[BIT_WORD(nr)] &gt;&gt; (nr &amp; (BITS_PER_LONG-1)));<BR>}</P>
<P>/**<BR>&nbsp;* find_last_bit - find the last set bit in a memory region<BR>&nbsp;* @addr: The address to start the search at<BR>&nbsp;* @size: The maximum size to search<BR>&nbsp;*<BR>&nbsp;* Returns the bit number of the first set bit, or size.<BR>&nbsp;*/<BR>unsigned long find_last_bit(const unsigned long *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long size);</P>
<P>/**<BR>&nbsp;* find_next_bit - find the next set bit in a memory region<BR>&nbsp;* @addr: The address to base the search on<BR>&nbsp;* @offset: The bitnumber to start searching at<BR>&nbsp;* @size: The bitmap size in bits<BR>&nbsp;*/<BR>unsigned long find_next_bit(const unsigned long *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long offset);</P>
<P>/**<BR>&nbsp;* find_next_zero_bit - find the next cleared bit in a memory region<BR>&nbsp;* @addr: The address to base the search on<BR>&nbsp;* @offset: The bitnumber to start searching at<BR>&nbsp;* @size: The bitmap size in bits<BR>&nbsp;*/</P>
<P>unsigned long find_next_zero_bit(const unsigned long *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long offset);</P>
<P>/**<BR>&nbsp;* find_first_bit - find the first set bit in a memory region<BR>&nbsp;* @addr: The address to start the search at<BR>&nbsp;* @size: The maximum size to search<BR>&nbsp;*<BR>&nbsp;* Returns the bit number of the first set bit.<BR>&nbsp;*/<BR>static inline unsigned long find_first_bit(const unsigned long *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long size)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned long result, tmp;</P>
<P>&nbsp;&nbsp;&nbsp; for (result = 0; result &lt; size; result += BITS_PER_LONG) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = *addr++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tmp) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result += ctzl(tmp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result &lt; size ? result : size;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* Not found */<BR>&nbsp;&nbsp;&nbsp; return size;<BR>}</P>
<P>/**<BR>&nbsp;* find_first_zero_bit - find the first cleared bit in a memory region<BR>&nbsp;* @addr: The address to start the search at<BR>&nbsp;* @size: The maximum size to search<BR>&nbsp;*<BR>&nbsp;* Returns the bit number of the first cleared bit.<BR>&nbsp;*/<BR>static inline unsigned long find_first_zero_bit(const unsigned long *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long size)<BR>{<BR>&nbsp;&nbsp;&nbsp; return find_next_zero_bit(addr, size, 0);<BR>}</P>
<P>static inline unsigned long hweight_long(unsigned long w)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned long count;</P>
<P>&nbsp;&nbsp;&nbsp; for (count = 0; w; w &gt;&gt;= 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += w &amp; 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return count;<BR>}</P>
<P>/**<BR>&nbsp;* rol8 - rotate an 8-bit value left<BR>&nbsp;* @word: value to rotate<BR>&nbsp;* @shift: bits to roll<BR>&nbsp;*/<BR>static inline uint8_t rol8(uint8_t word, unsigned int shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (word &lt;&lt; shift) | (word &gt;&gt; ((8 - shift) &amp; 7));<BR>}</P>
<P>/**<BR>&nbsp;* ror8 - rotate an 8-bit value right<BR>&nbsp;* @word: value to rotate<BR>&nbsp;* @shift: bits to roll<BR>&nbsp;*/<BR>static inline uint8_t ror8(uint8_t word, unsigned int shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (word &gt;&gt; shift) | (word &lt;&lt; ((8 - shift) &amp; 7));<BR>}</P>
<P>/**<BR>&nbsp;* rol16 - rotate a 16-bit value left<BR>&nbsp;* @word: value to rotate<BR>&nbsp;* @shift: bits to roll<BR>&nbsp;*/<BR>static inline uint16_t rol16(uint16_t word, unsigned int shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (word &lt;&lt; shift) | (word &gt;&gt; ((16 - shift) &amp; 15));<BR>}</P>
<P>/**<BR>&nbsp;* ror16 - rotate a 16-bit value right<BR>&nbsp;* @word: value to rotate<BR>&nbsp;* @shift: bits to roll<BR>&nbsp;*/<BR>static inline uint16_t ror16(uint16_t word, unsigned int shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (word &gt;&gt; shift) | (word &lt;&lt; ((16 - shift) &amp; 15));<BR>}</P>
<P>/**<BR>&nbsp;* rol32 - rotate a 32-bit value left<BR>&nbsp;* @word: value to rotate<BR>&nbsp;* @shift: bits to roll<BR>&nbsp;*/<BR>static inline uint32_t rol32(uint32_t word, unsigned int shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (word &lt;&lt; shift) | (word &gt;&gt; ((32 - shift) &amp; 31));<BR>}</P>
<P>/**<BR>&nbsp;* ror32 - rotate a 32-bit value right<BR>&nbsp;* @word: value to rotate<BR>&nbsp;* @shift: bits to roll<BR>&nbsp;*/<BR>static inline uint32_t ror32(uint32_t word, unsigned int shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (word &gt;&gt; shift) | (word &lt;&lt; ((32 - shift) &amp; 31));<BR>}</P>
<P>/**<BR>&nbsp;* rol64 - rotate a 64-bit value left<BR>&nbsp;* @word: value to rotate<BR>&nbsp;* @shift: bits to roll<BR>&nbsp;*/<BR>static inline uint64_t rol64(uint64_t word, unsigned int shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (word &lt;&lt; shift) | (word &gt;&gt; ((64 - shift) &amp; 63));<BR>}</P>
<P>/**<BR>&nbsp;* ror64 - rotate a 64-bit value right<BR>&nbsp;* @word: value to rotate<BR>&nbsp;* @shift: bits to roll<BR>&nbsp;*/<BR>static inline uint64_t ror64(uint64_t word, unsigned int shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (word &gt;&gt; shift) | (word &lt;&lt; ((64 - shift) &amp; 63));<BR>}</P>
<P>/**<BR>&nbsp;* extract32:<BR>&nbsp;* @value: the value to extract the bit field from<BR>&nbsp;* @start: the lowest bit in the bit field (numbered from 0)<BR>&nbsp;* @length: the length of the bit field<BR>&nbsp;*<BR>&nbsp;* Extract from the 32 bit input @value the bit field specified by the<BR>&nbsp;* @start and @length parameters, and return it. The bit field must<BR>&nbsp;* lie entirely within the 32 bit word. It is valid to request that<BR>&nbsp;* all 32 bits are returned (ie @length 32 and @start 0).<BR>&nbsp;*<BR>&nbsp;* Returns: the value of the bit field extracted from the input value.<BR>&nbsp;*/<BR>static inline uint32_t extract32(uint32_t value, int start, int length)<BR>{<BR>&nbsp;&nbsp;&nbsp; assert(start &gt;= 0 &amp;&amp; length &gt; 0 &amp;&amp; length &lt;= 32 - start);<BR>&nbsp;&nbsp;&nbsp; return (value &gt;&gt; start) &amp; (~0U &gt;&gt; (32 - length));<BR>}</P>
<P>/**<BR>&nbsp;* extract64:<BR>&nbsp;* @value: the value to extract the bit field from<BR>&nbsp;* @start: the lowest bit in the bit field (numbered from 0)<BR>&nbsp;* @length: the length of the bit field<BR>&nbsp;*<BR>&nbsp;* Extract from the 64 bit input @value the bit field specified by the<BR>&nbsp;* @start and @length parameters, and return it. The bit field must<BR>&nbsp;* lie entirely within the 64 bit word. It is valid to request that<BR>&nbsp;* all 64 bits are returned (ie @length 64 and @start 0).<BR>&nbsp;*<BR>&nbsp;* Returns: the value of the bit field extracted from the input value.<BR>&nbsp;*/<BR>static inline uint64_t extract64(uint64_t value, int start, int length)<BR>{<BR>&nbsp;&nbsp;&nbsp; assert(start &gt;= 0 &amp;&amp; length &gt; 0 &amp;&amp; length &lt;= 64 - start);<BR>&nbsp;&nbsp;&nbsp; return (value &gt;&gt; start) &amp; (~0ULL &gt;&gt; (64 - length));<BR>}</P>
<P>/**<BR>&nbsp;* sextract32:<BR>&nbsp;* @value: the value to extract the bit field from<BR>&nbsp;* @start: the lowest bit in the bit field (numbered from 0)<BR>&nbsp;* @length: the length of the bit field<BR>&nbsp;*<BR>&nbsp;* Extract from the 32 bit input @value the bit field specified by the<BR>&nbsp;* @start and @length parameters, and return it, sign extended to<BR>&nbsp;* an int32_t (ie with the most significant bit of the field propagated<BR>&nbsp;* to all the upper bits of the return value). The bit field must lie<BR>&nbsp;* entirely within the 32 bit word. It is valid to request that<BR>&nbsp;* all 32 bits are returned (ie @length 32 and @start 0).<BR>&nbsp;*<BR>&nbsp;* Returns: the sign extended value of the bit field extracted from the<BR>&nbsp;* input value.<BR>&nbsp;*/<BR>static inline int32_t sextract32(uint32_t value, int start, int length)<BR>{<BR>&nbsp;&nbsp;&nbsp; assert(start &gt;= 0 &amp;&amp; length &gt; 0 &amp;&amp; length &lt;= 32 - start);<BR>&nbsp;&nbsp;&nbsp; /* Note that this implementation relies on right shift of signed<BR>&nbsp;&nbsp;&nbsp;&nbsp; * integers being an arithmetic shift.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; return ((int32_t)(value &lt;&lt; (32 - length - start))) &gt;&gt; (32 - length);<BR>}</P>
<P>/**<BR>&nbsp;* sextract64:<BR>&nbsp;* @value: the value to extract the bit field from<BR>&nbsp;* @start: the lowest bit in the bit field (numbered from 0)<BR>&nbsp;* @length: the length of the bit field<BR>&nbsp;*<BR>&nbsp;* Extract from the 64 bit input @value the bit field specified by the<BR>&nbsp;* @start and @length parameters, and return it, sign extended to<BR>&nbsp;* an int64_t (ie with the most significant bit of the field propagated<BR>&nbsp;* to all the upper bits of the return value). The bit field must lie<BR>&nbsp;* entirely within the 64 bit word. It is valid to request that<BR>&nbsp;* all 64 bits are returned (ie @length 64 and @start 0).<BR>&nbsp;*<BR>&nbsp;* Returns: the sign extended value of the bit field extracted from the<BR>&nbsp;* input value.<BR>&nbsp;*/<BR>static inline int64_t sextract64(uint64_t value, int start, int length)<BR>{<BR>&nbsp;&nbsp;&nbsp; assert(start &gt;= 0 &amp;&amp; length &gt; 0 &amp;&amp; length &lt;= 64 - start);<BR>&nbsp;&nbsp;&nbsp; /* Note that this implementation relies on right shift of signed<BR>&nbsp;&nbsp;&nbsp;&nbsp; * integers being an arithmetic shift.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; return ((int64_t)(value &lt;&lt; (64 - length - start))) &gt;&gt; (64 - length);<BR>}</P>
<P>/**<BR>&nbsp;* deposit32:<BR>&nbsp;* @value: initial value to insert bit field into<BR>&nbsp;* @start: the lowest bit in the bit field (numbered from 0)<BR>&nbsp;* @length: the length of the bit field<BR>&nbsp;* @fieldval: the value to insert into the bit field<BR>&nbsp;*<BR>&nbsp;* Deposit @fieldval into the 32 bit @value at the bit field specified<BR>&nbsp;* by the @start and @length parameters, and return the modified<BR>&nbsp;* @value. Bits of @value outside the bit field are not modified.<BR>&nbsp;* Bits of @fieldval above the least significant @length bits are<BR>&nbsp;* ignored. The bit field must lie entirely within the 32 bit word.<BR>&nbsp;* It is valid to request that all 32 bits are modified (ie @length<BR>&nbsp;* 32 and @start 0).<BR>&nbsp;*<BR>&nbsp;* Returns: the modified @value.<BR>&nbsp;*/<BR>static inline uint32_t deposit32(uint32_t value, int start, int length,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t fieldval)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t mask;<BR>&nbsp;&nbsp;&nbsp; assert(start &gt;= 0 &amp;&amp; length &gt; 0 &amp;&amp; length &lt;= 32 - start);<BR>&nbsp;&nbsp;&nbsp; mask = (~0U &gt;&gt; (32 - length)) &lt;&lt; start;<BR>&nbsp;&nbsp;&nbsp; return (value &amp; ~mask) | ((fieldval &lt;&lt; start) &amp; mask);<BR>}</P>
<P>/**<BR>&nbsp;* deposit64:<BR>&nbsp;* @value: initial value to insert bit field into<BR>&nbsp;* @start: the lowest bit in the bit field (numbered from 0)<BR>&nbsp;* @length: the length of the bit field<BR>&nbsp;* @fieldval: the value to insert into the bit field<BR>&nbsp;*<BR>&nbsp;* Deposit @fieldval into the 64 bit @value at the bit field specified<BR>&nbsp;* by the @start and @length parameters, and return the modified<BR>&nbsp;* @value. Bits of @value outside the bit field are not modified.<BR>&nbsp;* Bits of @fieldval above the least significant @length bits are<BR>&nbsp;* ignored. The bit field must lie entirely within the 64 bit word.<BR>&nbsp;* It is valid to request that all 64 bits are modified (ie @length<BR>&nbsp;* 64 and @start 0).<BR>&nbsp;*<BR>&nbsp;* Returns: the modified @value.<BR>&nbsp;*/<BR>static inline uint64_t deposit64(uint64_t value, int start, int length,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t fieldval)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t mask;<BR>&nbsp;&nbsp;&nbsp; assert(start &gt;= 0 &amp;&amp; length &gt; 0 &amp;&amp; length &lt;= 64 - start);<BR>&nbsp;&nbsp;&nbsp; mask = (~0ULL &gt;&gt; (64 - length)) &lt;&lt; start;<BR>&nbsp;&nbsp;&nbsp; return (value &amp; ~mask) | ((fieldval &lt;&lt; start) &amp; mask);<BR>}</P>
<P>/**<BR>&nbsp;* half_shuffle32:<BR>&nbsp;* @value: 32-bit value (of which only the bottom 16 bits are of interest)<BR>&nbsp;*<BR>&nbsp;* Given an input value:<BR>&nbsp;*&nbsp; xxxx xxxx xxxx xxxx ABCD EFGH IJKL MNOP<BR>&nbsp;* return the value where the bottom 16 bits are spread out into<BR>&nbsp;* the odd bits in the word, and the even bits are zeroed:<BR>&nbsp;*&nbsp; 0A0B 0C0D 0E0F 0G0H 0I0J 0K0L 0M0N 0O0P<BR>&nbsp;*<BR>&nbsp;* Any bits set in the top half of the input are ignored.<BR>&nbsp;*<BR>&nbsp;* Returns: the shuffled bits.<BR>&nbsp;*/<BR>static inline uint32_t half_shuffle32(uint32_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* This algorithm is from _Hacker's Delight_ section 7-2 "Shuffling Bits".<BR>&nbsp;&nbsp;&nbsp;&nbsp; * It ignores any bits set in the top half of the input.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; x = ((x &amp; 0xFF00) &lt;&lt; 8) | (x &amp; 0x00FF);<BR>&nbsp;&nbsp;&nbsp; x = ((x &lt;&lt; 4) | x) &amp; 0x0F0F0F0F;<BR>&nbsp;&nbsp;&nbsp; x = ((x &lt;&lt; 2) | x) &amp; 0x33333333;<BR>&nbsp;&nbsp;&nbsp; x = ((x &lt;&lt; 1) | x) &amp; 0x55555555;<BR>&nbsp;&nbsp;&nbsp; return x;<BR>}</P>
<P>/**<BR>&nbsp;* half_shuffle64:<BR>&nbsp;* @value: 64-bit value (of which only the bottom 32 bits are of interest)<BR>&nbsp;*<BR>&nbsp;* Given an input value:<BR>&nbsp;*&nbsp; xxxx xxxx xxxx .... xxxx xxxx ABCD EFGH IJKL MNOP QRST UVWX YZab cdef<BR>&nbsp;* return the value where the bottom 32 bits are spread out into<BR>&nbsp;* the odd bits in the word, and the even bits are zeroed:<BR>&nbsp;*&nbsp; 0A0B 0C0D 0E0F 0G0H 0I0J 0K0L 0M0N .... 0U0V 0W0X 0Y0Z 0a0b 0c0d 0e0f<BR>&nbsp;*<BR>&nbsp;* Any bits set in the top half of the input are ignored.<BR>&nbsp;*<BR>&nbsp;* Returns: the shuffled bits.<BR>&nbsp;*/<BR>static inline uint64_t half_shuffle64(uint64_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* This algorithm is from _Hacker's Delight_ section 7-2 "Shuffling Bits".<BR>&nbsp;&nbsp;&nbsp;&nbsp; * It ignores any bits set in the top half of the input.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; x = ((x &amp; 0xFFFF0000ULL) &lt;&lt; 16) | (x &amp; 0xFFFF);<BR>&nbsp;&nbsp;&nbsp; x = ((x &lt;&lt; 8) | x) &amp; 0x00FF00FF00FF00FFULL;<BR>&nbsp;&nbsp;&nbsp; x = ((x &lt;&lt; 4) | x) &amp; 0x0F0F0F0F0F0F0F0FULL;<BR>&nbsp;&nbsp;&nbsp; x = ((x &lt;&lt; 2) | x) &amp; 0x3333333333333333ULL;<BR>&nbsp;&nbsp;&nbsp; x = ((x &lt;&lt; 1) | x) &amp; 0x5555555555555555ULL;<BR>&nbsp;&nbsp;&nbsp; return x;<BR>}</P>
<P>/**<BR>&nbsp;* half_unshuffle32:<BR>&nbsp;* @value: 32-bit value (of which only the odd bits are of interest)<BR>&nbsp;*<BR>&nbsp;* Given an input value:<BR>&nbsp;*&nbsp; xAxB xCxD xExF xGxH xIxJ xKxL xMxN xOxP<BR>&nbsp;* return the value where all the odd bits are compressed down<BR>&nbsp;* into the low half of the word, and the high half is zeroed:<BR>&nbsp;*&nbsp; 0000 0000 0000 0000 ABCD EFGH IJKL MNOP<BR>&nbsp;*<BR>&nbsp;* Any even bits set in the input are ignored.<BR>&nbsp;*<BR>&nbsp;* Returns: the unshuffled bits.<BR>&nbsp;*/<BR>static inline uint32_t half_unshuffle32(uint32_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* This algorithm is from _Hacker's Delight_ section 7-2 "Shuffling Bits".<BR>&nbsp;&nbsp;&nbsp;&nbsp; * where it is called an inverse half shuffle.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; x &amp;= 0x55555555;<BR>&nbsp;&nbsp;&nbsp; x = ((x &gt;&gt; 1) | x) &amp; 0x33333333;<BR>&nbsp;&nbsp;&nbsp; x = ((x &gt;&gt; 2) | x) &amp; 0x0F0F0F0F;<BR>&nbsp;&nbsp;&nbsp; x = ((x &gt;&gt; 4) | x) &amp; 0x00FF00FF;<BR>&nbsp;&nbsp;&nbsp; x = ((x &gt;&gt; 8) | x) &amp; 0x0000FFFF;<BR>&nbsp;&nbsp;&nbsp; return x;<BR>}</P>
<P>/**<BR>&nbsp;* half_unshuffle64:<BR>&nbsp;* @value: 64-bit value (of which only the odd bits are of interest)<BR>&nbsp;*<BR>&nbsp;* Given an input value:<BR>&nbsp;*&nbsp; xAxB xCxD xExF xGxH xIxJ xKxL xMxN .... xUxV xWxX xYxZ xaxb xcxd xexf<BR>&nbsp;* return the value where all the odd bits are compressed down<BR>&nbsp;* into the low half of the word, and the high half is zeroed:<BR>&nbsp;*&nbsp; 0000 0000 0000 .... 0000 0000 ABCD EFGH IJKL MNOP QRST UVWX YZab cdef<BR>&nbsp;*<BR>&nbsp;* Any even bits set in the input are ignored.<BR>&nbsp;*<BR>&nbsp;* Returns: the unshuffled bits.<BR>&nbsp;*/<BR>static inline uint64_t half_unshuffle64(uint64_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* This algorithm is from _Hacker's Delight_ section 7-2 "Shuffling Bits".<BR>&nbsp;&nbsp;&nbsp;&nbsp; * where it is called an inverse half shuffle.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; x &amp;= 0x5555555555555555ULL;<BR>&nbsp;&nbsp;&nbsp; x = ((x &gt;&gt; 1) | x) &amp; 0x3333333333333333ULL;<BR>&nbsp;&nbsp;&nbsp; x = ((x &gt;&gt; 2) | x) &amp; 0x0F0F0F0F0F0F0F0FULL;<BR>&nbsp;&nbsp;&nbsp; x = ((x &gt;&gt; 4) | x) &amp; 0x00FF00FF00FF00FFULL;<BR>&nbsp;&nbsp;&nbsp; x = ((x &gt;&gt; 8) | x) &amp; 0x0000FFFF0000FFFFULL;<BR>&nbsp;&nbsp;&nbsp; x = ((x &gt;&gt; 16) | x) &amp; 0x00000000FFFFFFFFULL;<BR>&nbsp;&nbsp;&nbsp; return x;<BR>}</P>
<P>#endif