B1.5.7 Stack alignment on exception entry
<P></P>
<P>The ARMv7-M architecture guarantees that stack pointer values are at least 4-byte aligned. However, some software standards require the stack pointer to be 8-byte aligned, and the architecture can enforce this alignment. The CCR.STKALIGN bit indicates whether, as part of an exception entry, the processor aligns the SP to 4 bytes, or to 8 bytes. It is IMPLEMENTATION DEFINED whether this bit is:<BR>&#8226; RW, in which case its reset value is IMPLEMENTATION DEFINED<BR>&#8226; RO, in which case it is RAO, indicating 8-byte SP alignment.</P>
<P>For more information see Configuration and Control Register, CCR on page B3-720.</P>
<P>ARM deprecates implementation or use of 4-byte SP alignment.</P>
<P>Note<BR>On an implementation that includes the FP extension, if software enables automatic FP state preservation on exception entry, that state preservation enforces 8-byte stack alignment, ignoring the CCR.STKALIGN bit value. For more information see Context state stacking on exception entry with the FP extension on page B1-650.</P>
<P>The remainder of this section gives more information about SP alignment.</P>
<P>Because an exception can occur on any instruction boundary, the current stack pointer might not be 8-byte aligned when the processor takes an exception. ARM recommends that exception handlers are written as AAPCS conforming functions, and the AAPCS requires 8-byte stack pointer alignment on entry to a conforming function. This means the system must ensure 8-byte alignment of the stack for all arguments<BR>passed.</P>
<P>Note<BR>A function that conforms to the AAPCS must preserve the natural alignment of primitive data of size 1, 2, 4, or 8 bytes. Conforming code can rely on this alignment. Normally, to support unqualified reliance the stack pointer must be 8-byte aligned on entry to a conforming function. If a function is entered directly from an underlying execution environment, that environment must accept the stack alignment requirement to guarantee unconditionally that conforming code executes correctly in all circumstances.</P>
<P>In an implementation where the CCR.STKALIGN bit is RW:<BR>&#8226; Software must ensure that the handler for any exception that the processor might take while CCR.STKALIGN is set to 0 does not require 8-byte alignment. An example is an NMI exception entered from reset, where the implementation resets to 4-byte alignment.<BR>&#8226; If software clears the CCR.STKALIGN bit to 0 between entry to an exception handler and the return from that exception, and the stack was not 8-byte aligned on entry to the exception, the exception return can cause system corruption.</P>
<P>Operation of 8-byte stack alignment</P>
<P>On an exception entry when CCR.STKALIGN is set to 1, the exception entry sequence ensures that the stack pointer in use before the exception entry has 8-byte alignment, by adjusting its alignment if necessary. When the processor pushes the PSR value to the stack it uses bit[9] of the stacked PSR value to indicate whether it realigned the stack.</P>
<P>Note<BR>In normal operation, PSR[9] is reserved.</P>
<P>Figure B1-3 shows the frame of information pushed onto the stack on exception entry, and how the processor reserves an additional word on the stack, if necessary, to obtain 8-byte stack alignment.</P>
<P>&nbsp;</P>
<P>Figure B1-3 Alignment options when stacking the basic frame</P>
<P>When a processor implements the FP extension, on an exception entry it can push a 26-word frame onto the stack, to include FP state information, see Context state stacking on exception entry with the FP extension on page B1-650. Therefore:<BR>&#8226; an 8-word context state frame pushed onto the stack on exception entry on a processor that does not include the FP extension is called a Basic frame<BR>&#8226; a 26-word context state frame that can be pushed onto the stack on exception entry on a processor that includes the FP extension is called an Extended frame.</P>
<P>On an exception return when CCR.STKALIGN is set to 1, the processor uses the value of bit [9] of the PSR value popped from the stack to determine whether it must adjust the stack pointer alignment. This reverses any forced stack alignment performed on the exception entry.</P>
<P>The pseudocode in Exception entry behavior on page B1-643 and Exception return behavior on page B1-652 describes the effect of the CCR.STKALIGN bit value on exception entry and exception return.</P>
<P>Note<BR>&#8226; On exception return, the processor adjusts the SP by adding the frame size to the SP and ORing the result with (4*xPSR[9]), where xPSR[9] is the bit value from the stacked xPSR value. This restores the original SP alignment. If the exception exit sequence started with a stack pointer that is 4 byte aligned, then this adjustment has no effect.<BR>&#8226; If the exception exit causes a derived exception, the processor enters the derived exception with the stack alignment that was in use before it started the exception exit sequence. For more information see Derived exceptions on exception return on page B1-665.<BR>&#8226; When CCR.STKALIGN is set to 1, the amount of stack used on exception entry is a function of the alignment of the stack at the time the processor enters the exception. If the SP is 4-byte aligned at this time, the processor realigns the SP to 8-byte alignment, using an extra four bytes of stack. This means the average and worst case stack usage increases. In the worst case, the increase is 4 bytes per exception entry.<BR>&#8226; Using a reserved bit in the PSR to indicate whether the processor realigned the stack on exception entry makes the feature transparent to context switch code, but requires all software to respect the reserved status of unused bits in the PSR.</P>
<P>Retrieving arguments from the stack</P>
<P>Any exception-handling code that must retrieve arguments from the stack, that were pushed to the stack before the exception was taken, must use the stacked value of xPSR [9] to determine whether the previous top-of-stack was at offset 0x20 or 0x24.</P>
<P>If the implementation includes the FP extension, such code must use the stacked value of xPSR [9] together with the value of EXC_RETURN bit [4] to determine whether the previous top-of-stack was at offset 0x20, 0x24, 0x68, or 0x6C, see Context state stacking on exception entry with the FP extension on page B1-650.</P>
<P>Saving context on process switch</P>
<P>When switching between different processes, software must save all context for the old process, including its associated EXC_RETURN value, before switching to the new process, and restore that context before returning to the old process.</P>
<P>Note<BR>The 8-byte stack alignment mechanism used when CCR.STKALIGN is set to 1 does not affect the EXC_RETURN value.</P>
<P>Context state stacking on exception entry with the FP extension</P>
<P>When an ARMv7-M processor implements the FP extension, it has three possible modes for stacking FP context information on taking an exception:<BR>&#8226; Do not stack any FP context. The processor stacks only a Basic frame, as described in Operation of 8-byte stack alignment on page B1-648.<BR>&#8226; Stack an Extended frame, containing the Basic frame and the FP state information, as shown in Figure B1-4 on page B1-651. This preserves the floating-point state required by the AAPCS.<BR>&#8226; Reserve space on the stack for an Extended frame, but write only the Basic frame information. This is similar to the operation shown in Figure B1-4 on page B1-651, except that no data is pushed into the stack locations reserved for S0-S15 and the FPSCR value. This is an FP lazy context save, see Lazy context save of FP state on page B1-652.</P>
<P>The FPCCR.ASPEN and FPCCR.LSPEN bits determine which action is taken, see Floating-Point Context Control Register, FPCCR on page B3-737.</P>
<P>Figure B1-4 Alignment options when stacking the Extended frame</P>
<P>For more information see Saving FP state on page B1-687 and Exceptions while saving FP state on page B1-688.</P>
<P>Immediately after FP state preservation:<BR>&#8226; the values of the following are UNKNOWN:<BR>&nbsp; &#8213; the FPSCR, see Floating-point Status and Control Register, FPSCR on page A2-56<BR>&nbsp; &#8213; the FPCAR, see Floating-Point Context Address Register, FPCAR on page B3-739<BR>&nbsp; &#8213; the FP extension registers S0-S15, see The FP extension registers on page A2-53<BR>&#8226; the values of the FP extension registers S16-S31 are unchanged<BR>&#8226; the CONTROL.FPCA bit is set to 0.</P>
<P>Lazy context save of FP state</P>
<P>Software sets the FPCCR.LSPEN bit to 1 to enable lazy FP context save on exception entry, see Floating-Point Context Control Register, FPCCR on page B3-737, When this is done, the processor reserves space on the stack for the FP state, but does not save that state information to the stack. The stacking it performs is as shown in Figure B1-4 on page B1-651, except that no data is transferred to the stack locations reserved for S0-S15 and the FPSCR, The processor also:<BR>&#8226; Sets the FPCAR to point to the reserved area on the stack, see Floating-Point Context Address Register, FPCAR on page B3-739. The FPCAR points to the reserved S0 stack location.<BR>&#8226; Sets the FPCCR.LSPACT bit to 1, to indicate that lazy state preservation is active, see Floating-Point Context Control Register, FPCCR on page B3-737.</P>
<P>Lazy state preservation reduces the exception latency.</P>
<P>While lazy context save is active, the processor must not change the FP context. This means that, if software attempts to execute a floating point instruction while lazy context save is active, the processor first:<BR>&#8226; saves the required FP state, S0-S15 and the FPSCR, to the reserved area on the stack, as identified by the FPCAR<BR>&#8226; sets the FPCCR.LSPACT bit to 0, to indicate that lazy state preservation is no longer active.<BR>It then processes the instruction.