B1.5.6 Exception entry behavior</P>
<P>On preemption of the instruction stream, the hardware saves context state onto a stack pointed to by one of the SP registers, see The SP registers on page B1-623. The stack used depends on the mode of the processor at the time of the exception.</P>
<P>The stacked context supports the ARM Architecture Procedure Calling Standard (AAPCS). This means the exception handler can be an AAPCS-compliant procedure.</P>
<P>The ARMv7-M architecture uses a full-descending stack, where:</P>
<P>&#8226; when pushing context, the hardware decrements the stack pointer to the end of the new stack frame before it stores data onto the stack<BR>&#8226; when popping context, the hardware reads the data from the stack frame and then increments the stack pointer.</P>
<P>When pushing context to the stack, the hardware saves eight 32-bit words, comprising xPSR, ReturnAddress, LR (R14), R12, R3, R2, R1, and R0.</P>
<P>If the processor implements the Floating-point extension, in addition to this eight word stack frame it can also either push FP state onto the stack, or reserve space on the stack for this state. For more information see Stack alignment on exception entry on page B1-647.</P>
<P>The ExceptionEntry() pseudocode function describes the exception entry behavior:</P>
<P>// ExceptionEntry()<BR>// ================<BR>// NOTE: PushStack() can abandon memory accesses if a fault occurs during the stacking<BR>// sequence.<BR>// Exception entry is modified according to the behavior of a derived exception,<BR>// see DerivedLateArrival() and associated text.<BR>PushStack();<BR>ExceptionTaken(ExceptionType); // ExceptionType is encoded as its exception number</P>
<P>For global declarations see Register-related definitions for pseudocode on page B1-629.</P>
<P>For the definition of ExceptionActive[*] see Reset behavior on page B1-641.</P>
<P>For helper functions and procedures see Miscellaneous helper procedures and functions on page AppxF-978.</P>
<P>The definitions of the PushStack() and ExceptionTaken() pseudocode functions are:</P>
<P>// PushStack()<BR>// ===========</P>
<P>PushStack()</P>
<P>&nbsp;&nbsp;&nbsp; if HaveFPExt() &amp;&amp; CONTROL.FPCA == &#8216;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; framesize = 0x68;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forcealign = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; framesize = 0x20;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forcealign = CCR.STKALIGN;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; spmask = NOT(ZeroExtend(forcealign:&#8217;00&#8217;,32));<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; if CONTROL.SPSEL == &#8216;1&#8217; AND CurrentMode == Mode_Thread then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameptralign = SP_process&lt;2&gt; AND forcealign;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SP_process = (SP_process - framesize) AND spmask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameptr = SP_process;<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameptralign = SP_main&lt;2&gt; AND forcealign;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SP_main = (SP_main - framesize) AND spmask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameptr = SP_main;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* only the stack locations, not the store order, are architected */<BR>&nbsp;&nbsp;&nbsp; MemA[frameptr,4] = R[0];<BR>&nbsp;&nbsp;&nbsp; MemA[frameptr+0x4,4] = R[1];<BR>&nbsp;&nbsp;&nbsp; MemA[frameptr+0x8,4] = R[2];<BR>&nbsp;&nbsp;&nbsp; MemA[frameptr+0xC,4] = R[3];<BR>&nbsp;&nbsp;&nbsp; MemA[frameptr+0x10,4] = R[12];<BR>&nbsp;&nbsp;&nbsp; MemA[frameptr+0x14,4] = LR;<BR>&nbsp;&nbsp;&nbsp; MemA[frameptr+0x18,4] = ReturnAddress();<BR>&nbsp;&nbsp;&nbsp; MemA[frameptr+0x1C,4] = (xPSR&lt;31:10&gt;:frameptralign:xPSR&lt;8:0&gt;);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // see ReturnAddress() in-line note for information on xPSR.IT bits<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; if HaveFPExt() &amp;&amp; CONTROL.FPCA == &#8216;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if FPCCR.LSPEN == &#8216;0&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CheckVFPEnabled();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i = 0 to 15<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemA[frameptr+0x20+(4*i),4] = S[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemA[frameptr+0x60,4] = FPSCR;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S[0..15] = bits(31) UNKNOWN;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPSCR = bits(31) UNKNOWN;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateFPCCR(frameptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; if HaveFPExt() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if Mode==Handler then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LR = Ones(27):NOT(CONTROL.FPCA):&#8217;0001&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LR = Ones(27):NOT(CONTROL.FPCA):&#8217;1&#8217;:CONTROL.SPSEL:&#8217;01&#8217;;<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if Mode==Handler then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LR = Ones(28):&#8217;0001&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LR = Ones(29):CONTROL.SPSEL:&#8217;01&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; return;</P>
<P>ExceptionTaken() Part of ExceptionEntry() behavior Exception entry behavior on page B1-643</P>
<P>// ExceptionTaken()<BR>// ================</P>
<P>ExceptionTaken(bits(9) ExceptionNumber)</P>
<P>&nbsp;&nbsp;&nbsp; bit tbit;<BR>&nbsp;&nbsp;&nbsp; bits(32) tmp;<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; R[0..3] = bits(32) UNKNOWN;<BR>&nbsp;&nbsp;&nbsp; R[12] = bits(32) UNKNOWN;<BR>&nbsp;&nbsp;&nbsp; tmp = MemA[VectorTable+4*ExceptionNumber,4];<BR>&nbsp;&nbsp;&nbsp; PC = tmp AND 0xFFFFFFFE;<BR>&nbsp;&nbsp;&nbsp; tbit = tmp&lt;0&gt;;<BR>&nbsp;&nbsp;&nbsp; CurrentMode = Mode_Handler;<BR>&nbsp;&nbsp;&nbsp; APSR = bits(32) UNKNOWN; // Flags UNPREDICTABLE due to other activations<BR>&nbsp;&nbsp;&nbsp; IPSR&lt;8:0&gt; = ExceptionNumber // ExceptionNumber set in IPSR<BR>&nbsp;&nbsp;&nbsp; EPSR.T = tbit; // T-bit set from vector<BR>&nbsp;&nbsp;&nbsp; EPSR.IT&lt;7:0&gt; = 0x0; // IT/ICI bits cleared<BR>&nbsp;&nbsp;&nbsp; //* PRIMASK, FAULTMASK, BASEPRI unchanged on exception entry*//<BR>&nbsp;&nbsp;&nbsp; if HaveFPExt() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTROL.FPCA = &#8216;1&#8217;; // Floating-point extension only<BR>&nbsp;&nbsp;&nbsp; CONTROL.SPSEL = &#8216;0&#8217;; // current Stack is Main, CONTROL.nPRIV unchanged<BR>&nbsp;&nbsp;&nbsp; //* CONTROL.nPRIV unchanged *//<BR>&nbsp;&nbsp;&nbsp; ExceptionActive[ExceptionNumber]= &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp; SCS_UpdateStatusRegs(); // update SCS registers as appropriate<BR>&nbsp;&nbsp;&nbsp; ClearExclusiveLocal();<BR>&nbsp;&nbsp;&nbsp; SetEventRegister(); // see WFE instruction for more details<BR>&nbsp;&nbsp;&nbsp; InstructionSynchronizationBarrier();</P>
<P>For more information about the registers with UNKNOWN values, see Exceptions on exception entry on page B1-662.</P>
<P>For updates to system status registers, see System Control Space (SCS) on page B3-708.</P>
<P>The value of ReturnAddress() is the address to which execution returns after the processor has handled the exception:</P>
<P>ReturnAddress() Return address stacked on exception entry Exception entry behavior on page B1-643</P>
<P>// ReturnAddress()<BR>// ===============</P>
<P>Bits(32) ReturnAddress() returns the following values based on the exception cause<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // NOTE: ReturnAddress() is always halfword aligned - bit&lt;0&gt; is always zero<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // xPSR.IT bits saved to the stack are consistent with ReturnAddress()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>// Exception Type Address returned<BR>// ============== ================</P>
<P>// NMI: Address of Next Instruction to be executed<BR>// HardFault (synchronous): Address of the Instruction causing fault<BR>// HardFault (asynchronous): Address of Next Instruction to be executed<BR>// MemManage: Address of the Instruction causing fault<BR>// BusFault (synchronous): Address of the Instruction causing fault<BR>// BusFault (asynchronous): Address of Next Instruction to be executed<BR>// UsageFault: Address of the Instruction causing fault<BR>// SVCall: Address of the Next Instruction after the SVC<BR>// DebugMonitor (synchronous): Address of the Instruction causing fault<BR>// DebugMonitor (asynchronous): Address of Next Instruction to be executed<BR>// Interrupts(all): Address of Next Instruction to be executed after an interrupt</P>
<P>Note<BR>&#8226; A fault that is escalated to the priority of a HardFault retains the ReturnAddress() value of the original fault. For a description of priority escalation see Priority escalation on page B1-640.<BR>&#8226; The described IRQ behavior also applies to the SysTick and PendSV interrupts.</P>
<P>If the processor implements the Floating-point extension, when the processor pushes the FP state to the stack, the UpdateFPCCR() function updates the FPCCR:</P>
<P>// UpdateFPCCR():<BR>// =========================</P>
<P>UpdateFPCCR(bits(32) frameptr)</P>
<P>// FPCAR and FPCCR remain unmodified if CONTROL.FPCA and<BR>// FPCCR.LSPEN are not both set to 1</P>
<P>&nbsp;&nbsp;&nbsp; if (CONTROL.FPCA == &#8216;1&#8217; &amp;&amp; FPCCR.LSPEN == &#8216;1&#8217;) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCAR.ADDRESS = (frameptr + 0x20)&lt;31:3&gt;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.LSPACT = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if CurrentModeIsPrivileged() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.USER = &#8216;0&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.USER = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if Mode == Thread then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.THREAD = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.THREAD = &#8216;0&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ExecutionPriority() &gt; -1 then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.HFRDY = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.HFRDY = &#8216;0&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if SHCSR.BUSFAULTENA &amp;&amp; ExecutionPriority() &gt; SHPR1.PRI_5 then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.BFRDY = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.BFRDY = &#8216;0&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if SHCSR.MEMFAULTENA &amp;&amp; ExecutionPriority() &gt; SHPR1.PRI_4 then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.MMRDY = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.MMRDY = &#8216;0&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if DEMCR.MON_EN &amp;&amp; ExecutionPriority() &gt; SHPR3.PRI_12 then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.MONRDY = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.MONRDY = &#8216;0&#8217;;<BR>&nbsp;&nbsp;&nbsp; return;</P>
<P>For more information about the information held in the FPCCR see Floating-Point Context Control Register, FPCCR on page B3-737.