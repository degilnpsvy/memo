B1.5.1 Overview of the exceptions supported 
<P></P>
<P>The ARMv7-M profile supports the following exceptions:</P>
<P>Reset<BR>The ARMv7-M profile supports two levels of reset. The reset level determines which register bit fields are forced to their reset values on the deassertion of reset.<BR>&#8226; A Power-on reset resets the processor, System Control Space and debug logic.<BR>&#8226; A Local reset resets the processor and System Control Space, except for some fault and debug-related resources. For more details, see Debug and reset on page C1-822.<BR>The Reset exception is permanently enabled with a fixed priority of -3.</P>
<P>NMI<BR>NMI (Non Maskable Interrupt) is the highest priority exception other than reset. It is permanently enabled with a fixed priority of -2.<BR>Hardware can generate an NMI, or software can set the NMI exception to the Pending state, see Interrupt Control and State Register, ICSR on page B3-713.</P>
<P>HardFault<BR>HardFault is the generic fault that exists for all classes of fault that cannot be handled by any of the other exception mechanisms. Typically, HardFault is used for unrecoverable system failures, although this is not required and some uses of HardFault might be recoverable. HardFault is permanently enabled with a fixed priority of -1.<BR>HardFault is used for fault escalation, see Priority escalation on page B1-640.</P>
<P>MemManage<BR>The MemManage fault handles memory protection faults that are determined by the Memory Protection Unit or by fixed memory protection constraints, for both instruction and data memory transactions. Software can disable this fault. If it does, a MemManage fault escalates to HardFault. MemManage has a configurable priority.</P>
<P>BusFault<BR>The BusFault fault handles memory-related faults, other than those handled by the MemManage fault, for both instruction and data memory transactions. Typically these faults arise from errors detected on the system buses. The architecture permits an implementation to report synchronous or asynchronous BusFaults according to the circumstances that trigger the exceptions. Software can disable this fault. If it does, a BusFault escalates to HardFault. BusFault has a configurable priority.</P>
<P>UsageFault<BR>The UsageFault fault handles non-memory related faults caused by instruction execution. A number of different situations cause usage faults, including:<BR>&#8226; Undefined Instruction<BR>&#8226; invalid state on instruction execution<BR>&#8226; error on exception return<BR>&#8226; attempting to access a disabled or unavailable coprocessor.<BR>The following can cause usage faults when the processor is configured to report them:<BR>&#8226; a word or halfword memory accesses to an unaligned address<BR>&#8226; division by zero.<BR>Software can disable this fault. If it does, a UsageFault escalates to HardFault. UsageFault has a configurable priority.</P>
<P>Debug Monitor<BR>In general, a DebugMonitor exception is a synchronous exception and classified as a fault. Debug monitor exceptions occur when halting debug is disabled, and debug monitor support is enabled. The DebugMonitor exception has a configurable priority. See Priority escalation on page B1-640 and Debug event behavior on page C1-823 for more information.<BR>Note<BR>A debug watchpoint is asynchronous and behaves as an interrupt.</P>
<P>SVCall<BR>This supervisor call handles the exception caused by the SVC instruction. SVCall is permanently enabled and has a configurable priority.</P>
<P>Interrupts<BR>The ARMv7-M profile supports two system-level interrupts, and up to 496 external interrupts. Each interrupt has a configurable priority. The system-level interrupts are:<BR>&nbsp;&nbsp;&nbsp; PendSV<BR>&nbsp;&nbsp;&nbsp; Used for software-generated system calls. An application uses a Supervisor call, if it requires servicing by the underlying operating system. The Supervisor call associated with PendSV executes when the processor takes the PendSV interrupt.</P>
<P>&nbsp;&nbsp;&nbsp; Note<BR>&nbsp;&nbsp;&nbsp; For a Supervisor call that executes synchronously with program execution, software must use the SVC instruction. This generates an SVCall exception.</P>
<P>&nbsp;&nbsp;&nbsp; PendSV is permanently enabled, and is controlled using the ICSR.PENDSVSET and ICSR.PENDSVCLR bits,.</P>
<P>&nbsp;&nbsp;&nbsp; SysTick<BR>&nbsp;&nbsp;&nbsp; Generated by the SysTick timer that is an integral component of an ARMv7-M processor. SysTick is permanently enabled, and is controlled using the ICSR.PENDSTSET and ICSR.PENDSTCLR bits.</P>
<P>&nbsp;&nbsp;&nbsp; Note<BR>&nbsp;&nbsp;&nbsp; Software can suppress hardware generation of the SysTick event, but ICSR.PENDSTSET and ICSR.PENDSTCLR are always available to software.<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; For more information about the control of the system-level interrupts see Interrupt Control and State Register, ICSR on page B3-713.<BR>&nbsp;&nbsp;&nbsp; Software can disable all external interrupts, and can set or clear the pending state of any interrupt. Interrupts other than PendSV can be set to the Pending state by hardware.<BR>&nbsp;&nbsp;&nbsp; <BR>See Fault behavior on page B1-669 for a description of all the possible causes of faults, the types of fault reported, and the fault status registers used to identify the faults.