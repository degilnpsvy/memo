B1.5.10 Exceptions in Load Multiple and Store Multiple operations</P>
<P>To improve interrupt response and increase processing throughput, the processor can take an interrupt during the execution of a Load Multiple or Store Multiple instruction, and continue execution of the instruction after returning from the interrupt. During the interrupt processing, the EPSR.ICI bits hold the continuation state of the Load Multiple or Store Multiple instruction, see The EPSR on page B1-625. It is IMPLEMENTATION DEFINED when interrupts are recognized, so the use of the ICI bits is IMPLEMENTATION DEFINED. Instructions that can be interrupted and restarted in this way are described as exception-continuable instructions.</P>
<P>In the base ARMv7-M architecture the exception-continuable instructions are LDM, LDMDB, STM, STMDB, POP, and PUSH. If a processor implements the FP extension the exception-continuable floating-point instructions are VLDM, VSTM, VPOP, and VPUSH.</P>
<P>Alternatively, the processor can abandon the execution of a Load Multiple or Store Multiple instruction on taking an exception, and restart the instruction processing, from the start of the instruction, on returning from the exception. This case does not require support for the ICI bits, but means software must not use Load Multiple or Store Multiple instructions with volatile memory,</P>
<P>To support instruction replay, the LDM, STM, PUSH and POP instructions must restore the base register if the instruction is abandoned.</P>
<P>Note<BR>On an implementation that supports interruptible Load Multiple and Store Multiple instructions, only Load Multiple and Store Multiple instructions that are not in an IT block are compatible with the single-copy atomicity rules for Device and Strongly Ordered memory described in Memory access restrictions on page A3-107.</P>
<P>For the instructions that are part of the base ARMv7-M architecture, the ICI bits store the number of the first register in the register list that must be loaded or stored on return to the instruction.</P>
<P>For the floating-point instructions, the ICI bits encode the number of the lowest-numbered doubleword floating-point extension register that was not completely loaded or stored before taking the exception. This means there might be multiple reads or writes of some registers.</P>
<P>Note<BR>This means that vector Load Multiple and Store Multiple instructions are never compatible with the single-copy atomicity rules for Device and Strongly Ordered memory described in Memory access restrictions on page A3-107.</P>
<P>When the processor returns to executing the Load Multiple or Store Multiple instruction, it loads or stores all registers in the instruction register list with a number that is equal to or greater than the value held in the ICI field. See The EPSR on page B1-625 for the encoding of the ICI bits.</P>
<P>If the ICI bits are all zero, the EPSR does not hold a continuation state. This zero value indicates normal operation with neither IT nor interrupt continuation active. In this situation, an abandoned Load Multiple or Store Multiple instruction restarts from the beginning.</P>
<P>The result is UNPREDICTABLE if the register number held in the ICI bits is non-zero and is either:<BR>&#8226; not a register in the register list of the Load Multiple or Store Multiple instruction<BR>&#8226; the first register in the register list of the Load Multiple or Store Multiple instruction.</P>
<P>If the ICI bit field is non-zero, and the instruction executed on an exception return is not a Load Multiple or Store Multiple instruction, or in an IT block, the processor generates an INVSTATE UsageFault, see Fault behavior on page B1-669.</P>
<P>If a BusFault or MemManage fault occurs on any Load Multiple or Store Multiple instruction, the processor abandons the instruction, and restarts the instruction from the beginning on return from the exception. If the instruction is not in an IT block, the fault clears the ICI bits to zero.</P>
<P>Note<BR>If software uses an exception-continuable instruction in an IT construct, the IT feature takes precedence over the ICI feature. In this situation, the processor treats the Load Multiple and Store Multiple instruction as restartable, meaning the instruction must not be used with Device or Strongly Ordered memory.</P>
<P>The following sections describe restrictions that apply to taking an exception during a Load Multiple or Store Multiple instruction.</P>
<P><BR>LDM and PC in load list</P>
<P>For the ARM architecture in general, the case of LDM with PC in the register list is defined as unordered, meaning the registers can be loaded in a different order to that implied by the register list. The usual use is to load the PC first, described as loading the PC early.</P>
<P>For ARMv7-M, however, a LDM operation with the PC in the register list can be interrupted during execution, with the continuation state held in the ICI bits. On returning from the exception to executing the LDM instruction, the ICI bits indicate the next register to load, to continue correctly. This can result in an LDM with the PC in the register list accessing the same memory location twice.</P>
<P>If the processor loads the PC early, before taking an exception it must restore the PC, so that the return address from the exception is to the LDM instruction address. The processor then loads the new PC value again when it continues execution of the LDM instruction.</P>
<P><BR>Load Multiple and Store Multiple base register updates and the ICI bits</P>
<P>The base register can be changed as a result of a load or store multiple in the following situations:</P>
<P>Base register write-back</P>
<P>For more information see the descriptions of updating the base register in:<BR>&#8226; LDM, LDMIA, LDMFD on page A7-283<BR>&#8226; LDMDB, LDMEA on page A7-285<BR>&#8226; STM, STMIA, STMEA on page A7-469<BR>&#8226; STMDB, STMFD on page A7-471.</P>
<P>Note<BR>POP is a special case of the LDM instruction, and PUSH is a special case of the STM instruction, see POP on page A7-387 and PUSH on page A7-389. Therefore, POP and PUSH can both perform base register write-back.</P>
<P>Base register load<BR>&nbsp;&nbsp;&nbsp; This occurs if the base register is in the register list of an LDM.<BR>&nbsp;&nbsp;&nbsp; <BR>If an exception occurs during execution of the Load Multiple or Store Multiple instruction, the value left in the base register is as follows:</P>
<P>Fault condition:<BR>The fault condition can be a BusFault or a MemManage fault. This case applies to all forms of LDM and STM, including PUSH and POP:<BR>&#8226; The base register is restored to the original value.<BR>&#8226; If the instruction is not in an IT block, the ICI bits are cleared to zero.<BR>&#8226; If the instruction is in an IT block, the ICI bits are not used to hold the continuation state, because the IT bits indicate the position in the IT block.<BR>&#8226; In all cases, the return from the fault handler restarts the instruction from the beginning.</P>
<P>Base register write-back:<BR>The behavior depends on the context of the interrupt:</P>
<P>Interrupt of an LDM or STM in an IT block<BR>&#8226; The base register contains the initial value, whether an IA or DB LDM/STM instruction.<BR>&#8226; The ICI bits are not used to hold the continuation state, as the IT bits indicate the position in the IT block.</P>
<P>Interrupt of an LDM or STM, not in an IT block, using SP as the base register<BR>&#8226; The SP that is presented to the exception entry sequence is lower than any element pushed by an STM, or not yet popped by an LDM.<BR>&nbsp; For instructions decrementing before (DB), the SP is set to the final value. This is the lowest value in the list.<BR>&nbsp; For instructions incrementing after (IA), the SP is set to the initial value. This is the lowest value in the list.<BR>&#8226; In all cases, the ICI bits hold the continuation state.</P>
<P>Interrupt of LDM or STM not in an IT block, not using SP as the base register<BR>&#8226; The base register contains the final value, whether the LDM or STM instruction is DB or IA.<BR>&#8226; The ICI bits hold the continuation state.</P>
<P><BR>Base register load</P>
<P>In all cases, the processor restores the original base address when it abandons the instruction. Other aspects of the behavior depend on the context of the interrupt:</P>
<P>Interrupt of an LDM in an IT block<BR>If the instruction is in an IT block, the ICI bits cannot be used to hold the continuation state, because the IT bits indicate the position of the instruction in the IT block. It is IMPLEMENTATION DEFINED whether the instruction executes to completion or restarts.</P>
<P>Interrupt of an LDM not in an IT block<BR>&#8226; If the processor takes the interrupt before it has loaded the base register, an implementation can use the ICI bits to hold the continuation state.<BR>&#8226; If the processor takes the interrupt after it has loaded the base register, the implementation must restore the base register to its original value. The ICI bits can be set to an IMPLEMENTATION DEFINED value that will load at least the base register and subsequent locations again on return.</P>
<P>Software must not use an LDM to access a volatile location if any of the following applies to that LDM:<BR>&#8226; it executes inside an IT block<BR>&#8226; it loads the base register<BR>&#8226; it loads the PC.</P>
<P>As a base register load example, if the instruction LDM R2, {R0-R4} is interrupted, and the instruction is not in an IT block:<BR>&#8226; If continuation is supported and the interrupt occurs after R0 or R1 has been loaded, the continuation bits indicate a restart on:<BR>&#8213; R1, if R0 has been loaded<BR>&#8213; R2, if R1 has been loaded.<BR>&#8226; If continuation is supported and the interrupt occurs at any point after R2 has been loaded, the processor abandons execution, and restarts execution, with the ICI bits cleared to zero, after it has handled the exception. This means that, in this case, the processor handles the instruction as if it does not support continuation.<BR>&#8226; If continuation is not supported and the instruction is abandoned before loading R4, after the processor handles the interrupt it restarts execution of the instruction, with the ICI bits cleared to zero.