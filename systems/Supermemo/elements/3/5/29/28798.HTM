B1.5.8 Exception return behavior
<P></P>
<P>An exception return occurs when the processor is in Handler mode and one of the following instructions loads a value of 0xFXXXXXXX into the PC:<BR>&#8226; POP/LDM that includes loading the PC.<BR>&#8226; LDR with PC as a destination.<BR>&#8226; BX with any register.</P>
<P>When used in this way, the processor intercepts the value written to the PC. This value is the EXC_RETURN value. In this value:</P>
<P>Bits [31:28] 0xF. This value identifies the value in a PC load as an EXC_RETURN value.<BR>Bits [27:5] Reserved, SBOP. The effect of writing a value other than 1 to any bit in this field is UNPREDICTABLE.<BR>Bit [4], if the processor does not implement the FP extension<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Reserved, SBOP. The effect of writing a value other than 1 to any bit in this field is UNPREDICTABLE.<BR>Bit [4], if the processor implements the FP extension<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Defines whether the stack frame for this exception has space allocated for FP state information. Bit [4] is 0 if stack space is allocated. On exception entry, the bit [4] value is saved in the EXC_RETURN value as the inverse of the CONTROL.FPCA bit value when the exception was generated, see The special-purpose CONTROL register on page B1-628.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; On exception return, the processor sets CONTROL.FPCA to the inverse of the EXC_RETURN[4] value.<BR>Bits [3:0] Define the required exception return behavior, as shown in:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; Table B1-8, for an implementation without the FP extension<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; Table B1-9, for an implementation with the FP extension.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In both tables:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; EXC_RETURN values not listed are reserved, for that implementation.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; The entry in the Return stack column is the stack that holds the information that the processor must restore as part of the exception return sequence. This is also the stack the processor will use after returning from the exception.</P>
<P><BR>Table B1-8 EXC_RETURN definition of exception return behavior, no FP extension<BR>EXC_RETURN&nbsp;&nbsp; Return to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return stack<BR>0xFFFFFFF1&nbsp;&nbsp; Handler mode&nbsp;&nbsp; Main<BR>0xFFFFFFF9&nbsp;&nbsp; Thread mode&nbsp;&nbsp;&nbsp; Main<BR>0xFFFFFFFD&nbsp;&nbsp; Thread mode&nbsp;&nbsp;&nbsp; Process</P>
<P>Table B1-9 EXC_RETURN definition of exception return behavior, with FP extension<BR>EXC_RETURN&nbsp;&nbsp; Return to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return stack&nbsp;&nbsp; Frame type<BR>0xFFFFFFE1&nbsp;&nbsp;&nbsp; Handler mode.&nbsp;&nbsp; Main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Extended<BR>0xFFFFFFE9&nbsp;&nbsp;&nbsp; Thread mode&nbsp;&nbsp;&nbsp;&nbsp; Main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Extended<BR>0xFFFFFFED&nbsp;&nbsp;&nbsp; Thread mode&nbsp;&nbsp;&nbsp;&nbsp; Process&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Extended<BR>0xFFFFFFF1&nbsp;&nbsp;&nbsp; Handler mode.&nbsp;&nbsp; Main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Basic<BR>0xFFFFFFF9&nbsp;&nbsp;&nbsp; Thread mode&nbsp;&nbsp;&nbsp;&nbsp; Main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Basic<BR>0xFFFFFFFD&nbsp;&nbsp;&nbsp; Thread mode&nbsp;&nbsp;&nbsp;&nbsp; Process&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Basic</P>
<P>Using a reserved EXC_RETURN value causes a chained UsageFault exception.</P>
<P>If an EXC_RETURN value is loaded into the PC when in Thread mode, or from the vector table, or by any other instruction, the value is treated as an address, not as a special value. The 0xFXXXXXXX address range, that includes all possible EXC_RETURN values, has Execute Never (XN) permissions, and loading this value causes a MemManage exception, or an INVSTATE UsageFault exception, or escalation of the exception to a HardFault.</P>
<P>Note<BR>When an EXC_RETURN value is treated as a branch address, and bit [0] of the value is 0, it is IMPLEMENTATION DEFINED whether a MemManage or an INVSTATE UsageFault exception occurs</P>
<P>In a processor that supports sleep-on-exit functionality, if software has enabled this feature, when the processor returns from the only active exception, the exception return leaves the processor in a power-saving mode. For more information see Power management on page B1-680.</P>
<P>Integrity checks on exception return</P>
<P>The ARMv7-M architecture provides a number of integrity checks on an exception return. These provide a guard against errors in the system software. Incorrect exception return information might be inconsistent with the state of execution that the processor holds in hardware or, or inconsistent with other state stored by the exception mechanisms.</P>
<P>The hardware-related integrity checks ensure that the tracking of active exceptions in the NVIC and SCB hardware is consistent with the exception return.</P>
<P>The integrity checks test the following on an exception return:<BR>&#8226; The Exception number being returned from, as held in the IPSR at the start of the return, is listed in the SCB as being active.<BR>&#8226; Normally, if at least one exception other than the returning exception is active, the return must be to Handler mode. This checks for a mismatch of the number of exception returns. Software can use the CCR.NONBASETHRDENA to disable this check, see Configuration and Control Register, CCR on page B3-720.<BR>&#8226; On a return to Thread mode, the value restored to the IPSR Exception number field must be 0.<BR>&#8226; On a return to Handler mode, the value restored to the IPSR Exception number field must not be 0.<BR>&#8226; EXC_RETURN[3:0] must not be a reserved value, see Table B1-8 on page B1-653.</P>
<P>Any failed check causes an INVPC UsageFault, with the EXC_RETURN value in the LR.</P>
<P>Exception return operation</P>
<P>The ExceptionReturn() pseudocode function describes the exception return operation:<BR>// ExceptionReturn()<BR>// =================</P>
<P>ExceptionReturn(bits(28) EXC_RETURN)<BR>&nbsp;&nbsp;&nbsp; assert CurrentMode == Mode_Handler;<BR>&nbsp;&nbsp;&nbsp; if HaveFPExt() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if !IsOnes(EXC_RETURN&lt;27:5&gt;) then UNPREDICTABLE;<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if !IsOnes(EXC_RETURN&lt;27:4&gt;) then UNPREDICTABLE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; integer ReturningExceptionNumber = UInt(IPSR&lt;8:0&gt;);<BR>&nbsp;&nbsp;&nbsp; integer NestedActivation; // used for Handler =&gt; Thread check when value == 1<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; NestedActivation = ExceptionActiveBitCount(); // Number of active exceptions<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; if ExceptionActive[ReturningExceptionNumber] == &#8216;0&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeActivate(ReturningExceptionNumber);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.INVPC = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LR = 0xF0000000 + EXC_RETURN;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault); // returning from an inactive handler<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case EXC_RETURN&lt;3:0&gt; of<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when &#8216;0001&#8217; // return to Handler<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameptr = SP_main;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CurrentMode = Mode_Handler;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTROL.SPSEL = &#8216;0&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when &#8216;1001&#8217; // returning to Thread using Main stack<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if NestedActivation != 1 &amp;&amp; CCR.NONBASETHRDENA == &#8216;0&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeActivate(ReturningExceptionNumber);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.INVPC = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LR = 0xF0000000 + EXC_RETURN;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault); // return to Thread exception mismatch<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameptr = SP_main;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CurrentMode = Mode_Thread;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTROL.SPSEL = &#8216;0&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when &#8216;1101&#8217; // returning to Thread using Process stack<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if NestedActivation != 1 &amp;&amp; CCR.NONBASETHRDENA == &#8216;0&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeActivate(ReturningExceptionNumber);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.INVPC = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LR = 0xF0000000 + EXC_RETURN;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault); // return to Thread exception mismatch<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frameptr = SP_process;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CurrentMode = Mode_Thread;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTROL.SPSEL = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; otherwise<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeActivate(ReturningExceptionNumber);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.INVPC = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LR = 0xF0000000 + EXC_RETURN;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault); // illegal EXC_RETURN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeActivate(ReturningExceptionNumber);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PopStack(frameptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if CurrentMode==Mode_Handler AND IPSR&lt;8:0&gt; == &#8216;000000000&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.INVPC = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PushStack(); // to negate PopStack()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LR = 0xF0000000 + EXC_RETURN;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault); // return IPSR is inconsistent<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if CurrentMode==Mode_Thread AND IPSR&lt;8:0&gt; != &#8216;000000000&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR.INVPC = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PushStack(); // to negate PopStack()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LR = 0xF0000000 + EXC_RETURN;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTaken(UsageFault); // return IPSR is inconsistent<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClearExclusiveLocal();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetEventRegister() // see WFE instruction for more details<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InstructionSynchronizationBarrier();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if CurrentMode==Mode_Thread AND NestedActivation == 0 AND SCR.SLEEPONEXIT == &#8216;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SleepOnExit(); // IMPLEMENTATION DEFINED</P>
<P>ExceptionActiveBitCount() is a pseudocode function that returns the number of bits that are set to 1 in the ExceptionActive[*] array:</P>
<P>integer ExceptionActiveBitCount()</P>
<P>SleepOnExit() is an IMPLEMENTATION DEFINED pseudocode function that, if the exception from which the processor is returning is the only active exception, and the sleep-on-exit functionality is supported and enabled, puts the processor into a power-saving state on return from the exception. For more information see Power management on page B1-680.</P>
<P>For global declarations see Register-related definitions for pseudocode on page B1-629.</P>
<P>For the definition of ExceptionTaken() see Exception entry behavior on page B1-643.</P>
<P>For the definition of ExceptionActive[*] see Reset behavior on page B1-641.</P>
<P>For helper functions and procedures see Miscellaneous helper procedures and functions on page AppxF-978.</P>
<P>The definitions of the DeActivate() and PopStack() pseudocode functions are:</P>
<P>// DeActivate()<BR>// ============</P>
<P>DeActivate(integer ReturningExceptionNumber)<BR>&nbsp;&nbsp;&nbsp; ExceptionActive[ReturningExceptionNumber] = &#8216;0&#8217;;<BR>&nbsp;&nbsp;&nbsp; /* PRIMASK and BASEPRI unchanged on exception exit */<BR>&nbsp;&nbsp;&nbsp; if IPSR&lt;8:0&gt; != &#8216;000000010&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FAULTMASK&lt;0&gt; = &#8216;0&#8217;; // clear FAULTMASK on any return except NMI<BR>&nbsp;&nbsp;&nbsp; return;</P>
<P>// PopStack()<BR>// ==========</P>
<P>PopStack(bits(32) frameptr) /* only stack locations, not the load order, are architected */</P>
<P>&nbsp;&nbsp;&nbsp; if HaveFPExt() &amp;&amp; EXC_RETURN&lt;4&gt; == &#8216;0&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; framesize = 0x68;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forcealign = &#8216;1&#8217;;<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; framesize = 0x20;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forcealign = CCR.STKALIGN;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; R[0] = MemA[frameptr,4];<BR>&nbsp;&nbsp;&nbsp; R[1] = MemA[frameptr+0x4,4];<BR>&nbsp;&nbsp;&nbsp; R[2] = MemA[frameptr+0x8,4];<BR>&nbsp;&nbsp;&nbsp; R[3] = MemA[frameptr+0xC,4];<BR>&nbsp;&nbsp;&nbsp; R[12] = MemA[frameptr+0x10,4];<BR>&nbsp;&nbsp;&nbsp; LR = MemA[frameptr+0x14,4];<BR>&nbsp;&nbsp;&nbsp; PC = MemA[frameptr+0x18,4]; // UNPREDICTABLE if the new PC not halfword aligned<BR>&nbsp;&nbsp;&nbsp; psr = MemA[frameptr+0x1C,4];<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; if HaveFPExt() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if EXC_RETURN&lt;4&gt; == &#8216;0&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if FPCCR.LSPACT == &#8216;1&#8217; then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPCCR.LSPACT = &#8216;0&#8217;; // state in FP is still valid<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CheckVFPEnabled();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i = 0 to 15<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S[i] = MemA[frameptr+0x20+(4*i),4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FPSCR = MemA[frameptr+0x60,4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTROL.FPCA = NOT(EXC_RETURN&lt;4&gt;);</P>
<P>&nbsp;&nbsp;&nbsp; spmask = Zeros(29)((psr&lt;9&gt; AND forcealign):&#8217;00&#8217;;</P>
<P>&nbsp;&nbsp;&nbsp; case EXC_RETURN&lt;3:0&gt; of<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when &#8216;0001&#8217; // returning to Handler<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SP_main = (SP_main + framesize) OR spmask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when &#8216;1001&#8217; // returning to Thread using Main stack<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SP_main = (SP_main + framesize) OR spmask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when &#8216;1101&#8217; // returning to Thread using Process stack<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SP_process = (SP_process + framesize) OR spmask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; APSR&lt;31:27&gt; = psr&lt;31:27&gt;; // valid APSR bits loaded from memory<BR>&nbsp;&nbsp;&nbsp; if HaveDSPExt() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; APSR&lt;19:16&gt; = psr&lt;19:16&gt;;<BR>&nbsp;&nbsp;&nbsp; IPSR&lt;8:0&gt; = psr&lt;8:0&gt;; // valid IPSR bits loaded from memory<BR>&nbsp;&nbsp;&nbsp; EPSR&lt;26:24,15:10&gt; = psr&lt;26:24,15:10&gt;; // valid EPSR bits loaded from memory<BR>&nbsp;&nbsp;&nbsp; return;