B1.5.14 Fault behavior
<P></P>
<P>Under the ARMv7-M exception priority scheme, a processor handles a precise fault in one of the following ways:<BR>&#8226; execute the corresponding exception handler<BR>&#8226; take a HardFault exception<BR>&#8226; if a fault occurs when executing at priority -1 or higher, as described in Unrecoverable exception cases on page B1-674.</P>
<P>The following pseudocode summarizes fault handling by a dedicated handler or HardFault handler:</P>
<P>// Fault handling<BR>// ==============<BR>// FaultType is a subset of ExceptionNumber and can be one of the following values:</P>
<P>bits(9) HardFault = 3;<BR>bits(9) MemManage = 4;<BR>bits(9) BusFault = 5;<BR>bits(9) UsageFault = 6;</P>
<P>ExceptionTaken(FaultType);</P>
<P>In all fault handling cases, the processor sets the corresponding fault status register bit to 1, and the fault handler returns according to the rules defined in the ReturnAddress() pseudocode function.</P>
<P>For the definitions of ExceptionTaken() and ReturnAddress() see Exception entry behavior on page B1-643.</P>
<P>List of ARMv7-M faults</P>
<P>An ARMv7-M implementation recognizes the following faults, excluding faults relating to debug. As shown, each fault has an associated status bit and an associated vector catch bit, used by the debug implementation to catch the fault.</P>
<P>HardFault on vector read error<BR>Status bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HFSR.VECTTBL<BR>Vector catch bit&nbsp;&nbsp; DEMCR.VC_INTERR<BR>Bus error returned when reading the vector table entry.</P>
<P>Note<BR>Exception vector reads use the default address map, see Protected Memory System Architecture, PMSAv7 on page B3-761.</P>
<P>HardFault on fault escalation<BR>Status bit HFSR.FORCED<BR>Vector catch bit DEMCR.VC_HARDERR<BR>Fault or supervisor call occurred, and the handler priority is lower than or equal to the execution priority. The exception escalates to a HardFault. The processor updates the fault address and status registers, as appropriate.</P>
<P>HardFault on breakpoint (BKPT) escalation<BR>Status bit HFSR.DEBUGEVT<BR>Vector catch bit DEMCR.VC_HARDERR<BR>Occurs when halting debug and the DebugMonitor are disabled, and an exception associated with BKPT is escalated.</P>
<P>BusFault on exception entry stack memory operations<BR>Status bit BFSR.STKERR<BR>Vector catch bit DEMCR.VC_INTERR<BR>Failure on a hardware save of context. The fault returns a bus error, but the processor does not update the BusFault Address Register.</P>
<P>MemManage fault on exception entry stack memory operations<BR>Status bit MMFSR.MSTKERR<BR>Vector catch bit DEMCR.VC_INTERR<BR>Failure on a hardware save of context, because of an MPU access violation. The processor does not update the MemManage Address Register.</P>
<P>BusFault on exception return stack memory operations<BR>Status bit BFSR.UNSTKERR<BR>Vector catch bit DEMCR.VC_INTERR<BR>Failure on a hardware restore of context. The fault returns a bus error, but the processor does not update the Bus Fault Address Register.</P>
<P>MemManage fault on exception return stack memory operations<BR>Status bit MMFSR.MUNSTKERR<BR>Vector catch bit DEMCR.VC_INTERR<BR>Failure on a hardware restore of context, because of an MPU access violation. The processor does not update the MemManage Address Register.</P>
<P>MemManage fault on data access<BR>Status bit MMFSR.DACCVIOL<BR>Vector catch bit DEMCR.VC_MMERR<BR>MPU violation or fault caused by an explicit memory access. The processor writes the data address of the load or store to the MemManage Address Register.</P>
<P>MemManage fault on instruction access<BR>Status bit MMFSR.IACCVIOL<BR>Vector catch bit DEMCR.VC_MMERR<BR>MPU violation or fault caused by an instruction fetch, or an instruction fetch from XN memory when there is no MPU. The fault occurs only if the processor attempts to execute the instruction. The processor does not update the MemManage Address Register.</P>
<P>BusFault on instruction fetch, precise<BR>Status bit BFSR.IBUSERR<BR>Vector catch bit DEMCR.VC_BUSERR<BR>Bus error on an instruction fetch. The fault occurs only if the processor attempts to execute the instruction. The processor does not update the Bus Fault Address Register.</P>
<P>BusFault on data access, precise<BR>Status bit BFSR.PRECISERR<BR>Vector catch bit DEMCR.VC_BUSERR<BR>Precise bus error caused by an explicit memory access. The processor writes the data address of the load or store to the Bus Fault Address Register.</P>
<P>BusFault, bus error on data bus, imprecise<BR>Status bit BFSR.IMPRECISERR<BR>Vector catch bit DEMCR.VC_BUSERR<BR>Imprecise bus error caused by an explicit memory access. The processor does not update the Bus Fault Address Register.</P>
<P>UsageFault, No coprocessor<BR>Status bit UFSR.NOCP<BR>Vector catch bit DEMCR.VC_NOCPERR<BR>Occurs on an attempt to access a coprocessor that does not exist, or to which access is denied, see Coprocessor Access Control Register, CPACR on page B3-735.</P>
<P>UsageFault, Undefined Instruction<BR>Status bit UFSR.UNDEFINSTR<BR>Vector catch bit DEMCR.VC_STATERR<BR>Occurs if the processor attempts to execute an unknown instruction, including any unknown instruction associated with an enabled coprocessor.</P>
<P>UsageFault, attempt to execute an instruction when EPSR.T==0<BR>Status bit UFSR.INVSTATE<BR>Vector catch bit DEMCR.VC_STATERR<BR>Occurs if the processor attempts to execute in an invalid EPSR state, for example after a BX instruction branches to an unsupported state. This fault includes any state change after entry to or return from an exception, as well as from an inter-working instruction.</P>
<P>UsageFault, exception return integrity check failures<BR>Status bit UFSR.INVPC<BR>Vector catch bit DEMCR.VC_STATERR<BR>Indicates any failure of the integrity checks for exception returns described in Integrity checks on exception return on page B1-654.</P>
<P>UsageFault, illegal unaligned load or store<BR>Status bit UFSR.UNALIGNED<BR>Vector catch bit DEMCR.VC_CHKERR<BR>Occurs when a load-store multiple instruction attempts to access a non-word aligned location. If the CCR.UNALIGN_TRP bit is set to 1 it occurs, also, for any load or store that is not naturally aligned.</P>
<P>UsageFault, divide by 0<BR>Status bit UFSR.DIVBYZERO<BR>Vector catch bit DEMCR.VC_CHKERR<BR>If the CCR.DIV_0_TRP bit is set to 1, this occurs when the processor attempts to execute SDIV or UDIV with a divisor of 0.</P>
<P>For more information about:<BR>&#8226; the fault status bits, see Configurable Fault Status Register, CFSR on page B3-727 and HardFault Status Register, HFSR on page B3-732<BR>&#8226; the vector catch bits, see Debug Exception and Monitor Control Register, DEMCR on page C1-838 and Vector catch support on page C1-842.<BR>&#8226; the CCR trap bits, see Configuration and Control Register, CCR on page B3-720<BR>&#8226; faults related to debug see Chapter C1 ARMv7-M Debug.</P>
<P><BR>Fault status and address information</P>
<P>The System Control Space includes the following fault status and fault address registers:<BR>&#8226; configurable fault status registers for UsageFault, BusFault and MemManage faults, see Configurable Fault Status Register, CFSR on page B3-727<BR>&#8226; a HardFault status register, see HardFault Status Register, HFSR on page B3-732<BR>&#8226; a Debug fault status register, see Debug Fault Status Register, DFSR on page C1-828 for more information<BR>&#8226; BusFault and MemManage fault address registers, see BusFault Address Register, BFAR on page B3-734 and MemManage Fault Address Register, MMFAR on page B3-733. It is IMPLEMENTATION DEFINED whether these fault address registers are unique registers, or are a shared resource accessible from two locations in the System Control Space.</P>
<P>The HFSR provides three fault handling status flags, that indicate the reason for taking a HardFault exception. These bits are write-one-to-clear.</P>
<P>The 32-bit CFSR, see Configurable Fault Status Register, CFSR on page B3-727, concatenates fault status registers for UsageFault, BusFault, and MemManage fault. These are called configurable faults because they support dynamic priority setting by software. Fault status register bits are additive, meaning each new fault sets a bit to 1. These bits are write-one-to-clear.</P>
<P>The BusFault and MemManage registers each include a valid bit that is set to 1 when the associated fault address register is updated with the faulting address:<BR>&#8226; the MemManage Address register is updated only for data access violations<BR>&#8226; the BusFault Address register is updated only for precise data errors.</P>
<P>Software can determine the address of the faulting instruction for UsageFault, MemManage and precise BusFaults from the stacked ReturnAddress() value, as defined in Exception entry behavior on page B1-643.</P>
<P>Note<BR>&#8226; Escalation of a BusFault or MemManage exception to HardFault can cause the associated fault address register to be overwritten by a derived exception, see Exceptions on exception entry on page B1-662 and Exceptions on exception return, and tail-chaining exceptions on page B1-664. Therefore, ARM strongly recommends that handlers managing these types of fault clear to zero the VALID bit corresponding to the fault address, before performing their exception return.<BR>&#8226; There are cases where the fault address register is not valid. Handlers must check address validity by ensuring the associated VALID bit is set to 1. An invalid address can occur because of the preemption of a fault.</P>
<P>The CCR, see Configuration and Control Register, CCR on page B3-720, includes control bits for features related to faults:<BR>&#8226; The BFHFNMIGN bit prevents data access bus faults when the processor is executing at priority -1 or -2.<BR>An example use of the bit is in autoconfiguration of a bridge or other device, where probing a disabled<BR>or non-existent element might cause a bus fault. Before using this bit, software developers must<BR>ensure that the code and data spaces of the handler that executes at priority -1 or -2 are valid for<BR>correct operation.<BR>&#8226; Trap enable bits:<BR>&nbsp;&nbsp; &#8213; the DIV_0_TRP bit enables the divide-by-0 trap<BR>&nbsp;&nbsp; &#8213; the UNALIGN_TRP bit enables the trap on unaligned word and halfword accesses.