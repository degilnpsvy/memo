B1.5.15 Unrecoverable exception cases
<P></P>
<P>The ARMv7-M architecture generally assumes that, when the processor is running at priority -1 or higher, any fault or supervisor call that occurs is entirely unexpected and fatal.</P>
<P>The standard exception entry mechanism does not apply where a fault or supervisor call occurs at a priority of -1 or above. ARMv7-M requires the processor to handle most of these cases using a lockup mechanism. Other cases become pending or are ignored. Lockup means the processor suspends normal instruction execution and enters Lockup state. When in Lockup state:<BR>&#8226; The processor repeatedly fetches the same instruction, from a fixed address, the Lockup address, determined by the nature of the fault, as Possible faults when executing at a priority of less than 0 on page B1-675 describes.<BR>&#8226; After each fetch, the processor executes the instruction, if it is valid. If the lockup is caused by a precise memory error on a load or store that has base write-back, the fault restores the base register.<BR>&#8226; If the IT bits are non-zero when the lockup occurs, the IT bits do not advance.<BR>&#8226; The processor sets the S_LOCKUP bit in the Debug Halting Control and Status Register to 1.<BR>&#8226; The processor sets the Fault Status Register bits consistent with the fault causing the lockup to 1.</P>
<P>ARM strongly recommends that implementations provide an external signal that indicates that the processor is in Lockup state, so that an external mechanism can react.</P>
<P>A processor can exit Lockup state in the following ways:<BR>&#8226; If the lockup is in a HardFault handler and an NMI exception occurs, the NMI becomes active. The NMI return link is the address used for the Lockup state instruction fetch.<BR>&#8226; A system reset occurs. This causes exit from Lockup state, and resets the system as normal.<BR>&#8226; The processor receives a halt command from a halting-mode debug agent. The processor enters Debug state with the PC set to the same value as is used for return context, as Possible faults when executing at a priority of less than 0 on page B1-675 describes.<BR>&#8226; If the lockup was caused by a memory error and that error is resolved, either by specific action by the system, or over time. For example, the memory error might be caused by a resource that requires time to configure, and therefore clears when that configuration is complete.</P>
<P>In most cases, once the processor enters Lockup state, it remains in that state until a reset, such as from a watchdog. However, the following mechanisms can be used to examine and correct the reason for the Lockup state, possibly avoiding the requirement for a reset:<BR>&#8226; A debugger stops the processor by issuing a Halt, causing Debug state entry. It then fixes one or more of the xPSR, instruction, FAULTMASK and PC, and exits Debug state.<BR>&#8226; If the processor locks up because of a fetch error caused by a BusFault on the read, an external master can correct the problem or a transitory problem can self-correct.<BR>&#8226; If the processor locks up because of an undefined instruction, an external master can modify the memory location from which the processor is fetching the instruction.<BR>&#8226; If NMI preempts Lockup state in a HardFault exception, the NMI handler can fix the problem before returning. For example, it might do one or more of change the return PC value, change the value in the FAULTMASK register, and fix the state bits in the saved xPSR.</P>
<P>In these cases, the processor exits Lockup state and continues executing from the lockup or modified PC address, as described in this section.</P>
<P>Note<BR>Although the architecture permits these methods of recovering from lockup, ARM does not suggest that these methods are suitable for use by an application. ARM regards lockup as terminating execution, requiring a reset.</P>
<P>Possible faults when executing at a priority of less than 0</P>
<P>This section describes the behavior of all faults or supervisor calls that can occur when the processor is executing at priority -1 or higher. This means faults that might occur during the execution of the HardFault, NMI, or Reset handler, or when FAULTMASK is set to 1. The faults that might occur are as follows:</P>
<P>Vector read error at reset, when reading initial PC or SP value<BR>Behavior Lockup at priority -1.<BR>Lockup address 0xFFFFFFFE.</P>
<P>Vector read error on NMI entry, processor cannot read NMI vector<BR>Behavior Lockup at priority -2.<BR>Lockup address 0xFFFFFFFE.<BR>The lockup occurs at priority -2 regardless of the priority of the code executing when the processor took the NMI exception.</P>
<P>Vector read error on HardFault entry, processor cannot read HardFault vector<BR>Behavior Lockup at priority -1.<BR>Lockup address 0xFFFFFFFE.<BR>The lockup occurs at priority -1 regardless of the priority of the code executing when the processor took the HardFault exception.</P>
<P>BusFault on instruction fetch<BR>Behavior Lockup at current execution priority. For example, lockup at<BR>priority -1 if executing HardFault handler.<BR>Lockup address Address accessed by the instruction fetch.<BR>This fault can autocorrect if the bus fault is transitory.</P>
<P>BusFault on imprecise data access<BR>Behavior Processor sets state of the BusFault exception to pending.<BR>This fault does not cause a lockup.</P>
<P>BusFault on precise data access<BR>Behavior Configurable, depending on CCR.BFHFNMIGN value. Either:<BR>&nbsp;&nbsp; &#8226; lockup at the current execution priority, for example, lockup at priority -1 if executing HardFault handler.<BR>&nbsp;&nbsp; &#8226; ignored.<BR>Lockup address Address of the instruction making the access.<BR>The behavior depends on the value of CCR.BFHFNMIGN, see Configuration and Control Register, CCR on page B3-720 for more information:<BR>BFHFNMIGN == 0<BR>&nbsp;&nbsp; Lockup at current execution priority. For example, lockup at priority -1 if executing HardFault handler.<BR>&nbsp;&nbsp; This fault can autocorrect if the bus fault is transitory.<BR>BFHFNMIGN ==1<BR>&nbsp;&nbsp; The processor sets the BFSR bits, see Status registers for configurable-priority faults on page B3-727, but otherwise ignores the bus fault.<BR>&nbsp;&nbsp; <BR>BusFault on memory operation when stacking state on exception entry<BR>Behavior Lockup. Whether this is at priority -1 or priority -2 is<BR>IMPLEMENTATION DEFINED.<BR>Lockup address 0xFFFFFFFE.<BR>This case can occur only when the processor attempts to take an NMI exception that occurs when the execution priority is -1.</P>
<P>BusFault on memory operation when unstacking state on exception return<BR>Returning to software executing at priority -1.<BR>Behavior Lockup at priority -1.<BR>Lockup address 0xFFFFFFFE.<BR>This case can occur only on returning from the NMI exception handler to an execution priority of -1.</P>
<P>MemManage fault on instruction fetch<BR>Behavior Configurable, depending on MPU_CTRL.HFNMIENA value and the address accessed. Either:<BR>&nbsp;&nbsp;&nbsp; &#8226; lockup at the current execution priority, for example, lockup at priority -1 if executing HardFault handler.<BR>&nbsp;&nbsp;&nbsp; &#8226; ignored.<BR>&nbsp;&nbsp;&nbsp; If the address accessed is XN the lockup occurs regardless of the value of MPU_CTRL.HFNMIENA.<BR>Lockup address Address accessed by the instruction fetch.<BR>The MPU_CTRL.HFNMIENA bit and the attributes of the addressed memory determine when this fault can occur:<BR>HFNMIENA == 0<BR>&nbsp;&nbsp;&nbsp; Lockup occurs only on an attempt to execute from an XN region of the default memory map.<BR>HFNMIENA == 1<BR>&nbsp;&nbsp;&nbsp; Lockup occurs when a fetch causes an MPU access violation, an XN region violation, or missing region fault.<BR>See MPU Control Register, MPU_CTRL on page B3-767 for more information.</P>
<P>MemManage fault on data access<BR>Behavior Configurable, depending on MPU_CTRL.HFNMIENA value. Either:<BR>&nbsp;&nbsp;&nbsp; &#8226; lockup at the current execution priority, for example, lockup at priority -1 if executing HardFault handler.<BR>&nbsp;&nbsp;&nbsp; &#8226; ignored.<BR>Lockup address Address of the instruction making the access.<BR>The MPU_CTRL.HFNMIENA bit controls whether this fault can occur:<BR>HFNMIENA == 0<BR>&nbsp;&nbsp;&nbsp; Lockup cannot occur.<BR>HFNMIENA == 1<BR>&nbsp;&nbsp;&nbsp; Lockup can occur from an MPU access or privilege violation.<BR>See MPU Control Register, MPU_CTRL on page B3-767 for more information.</P>
<P>MemManage fault on memory operation when stacking state on exception entry<BR>Behavior Lockup. Whether this is at priority -1 or priority -2 is IMPLEMENTATION DEFINED.<BR>Lockup address 0xFFFFFFFE.</P>
<P>This case can occur only when the processor attempts to take an NMI exception that occurs when the execution priority is -1. In addition, the MPU_CTRL.HFNMIENA bit controls whether this fault can occur, see the description of MemManage fault on data access.</P>
<P>MemManage fault on memory operation when unstacking state on exception return<BR>Behavior Lockup at priority -1.<BR>Lockup address 0xFFFFFFFE.<BR>This case can occur only on returning from the NMI exception handler to an execution priority of -1. In addition, the MPU_CTRL.HFNMIENA bit controls whether this fault can occur, see the description of MemManage fault on data access.</P>
<P>Execution of SVC instruction<BR>Behavior Lockup at current execution priority. For example, lockup at priority -1 if executing HardFault handler.<BR>Lockup address Address of the SVC instruction.<BR>The processor treats the SVC instruction as UNDEFINED.</P>
<P>INVPC UsageFault on exception return<BR>Behavior Lockup at priority -2.<BR>Lockup address 0xFFFFFFFE.<BR>This fault can occur only on returning from the NMI handler to an execution priority of -1.<BR>Note<BR>If an INVPC UsageFault occurs on returning to an execution priority of 0, or of lower priority, then the UsageFault tailchains to the HardFault handler, and does not cause lockup.</P>
<P>UsageFault other than INVPC<BR>Behavior Lockup at current execution priority. For example, lockup at priority -1 if executing HardFault handler.<BR>Lockup address Address of the faulting instruction.</P>
<P>Breakpoint triggered<BR>Behavior Lockup at current execution priority. For example, lockup at priority -1 if executing HardFault handler.<BR>Lockup address Address of the breakpointed instruction.<BR>This fault can be caused by a BKPT instruction or by a breakpoint defined in the FPB, see Flash Patch and Breakpoint unit on page C1-904.</P>
<P>Note<BR>&#8226; Lockup addresses shown as 0xFFFFFFFE are sometimes described as lockups at address 0xFFFFFFFF. This is because any instruction fetch is halfword aligned. and therefore addresses 0xFFFFFFFE and 0xFFFFFFFF are equivalent.<BR>&#8226; Lockup does not affect the value of the EPSR.T bit, that for correct operation must be set to 1 to indicate that the processor executes Thumb instructions. In particular, if lockup occurred because the T bit was set to 0 the T bit remains as 0. Regardless of the T bit value, the visible lockup address is always 0xFFFFFFFE.<BR>If a fault or supervisor call during the execution of the HardFault or NMI handler causes the system to lockup at a priority of -1, it is IMPLEMENTATION DEFINED whether either or both:<BR>&#8226; the IPSR indicates Hardfault<BR>&#8226; the FAULTMASK bit is set to 1.