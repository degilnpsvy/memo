<SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Signed Multiply Accumulate Dual performs two signed 16 x 16-bit multiplications. It adds the products to a 32-bit accumulate operand.</FONT></SPAN>
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Optionally, you can exchange the halfwords of the second operand before performing the arithmetic. This produces top &#215; bottom and bottom &#215; top multiplication.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>This instruction sets the Q flag if the accumulate operation overflows. Overflow cannot occur during the multiplications.</FONT></SPAN>
<P><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt">if ConditionPassed() then<BR>EncodingSpecificOperations();<BR>operand2 = if m_swap then ROR(R[m],16) else R[m];<BR>product1 = SInt(R[n]&lt;15:0&gt;) * SInt(operand2&lt;15:0&gt;);<BR>product2 = SInt(R[n]&lt;31:16&gt;) * SInt(operand2&lt;31:16&gt;);<BR>result = product1 + product2 + SInt(R[a]);<BR>R[d] = result&lt;31:0&gt;;<BR>if result != SInt(result&lt;31:0&gt;) then // Signed overflow<BR>APSR.Q = &#8216;1&#8217;;</SPAN>