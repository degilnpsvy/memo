<SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Signed Multiply Accumulate Long Dual performs two signed 16 &#215; 16-bit multiplications. It adds the products to a 64-bit accumulate operand.</FONT></SPAN>
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Optionally, you can exchange the halfwords of the second operand before performing the arithmetic. This produces top &#215; bottom and bottom &#215; top multiplication.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Overflow is possible during this instruction, but only as a result of the 64-bit addition. This overflow is not detected if it occurs. Instead, the result wraps around modulo 264.</FONT></SPAN>
<P><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt">if ConditionPassed() then<BR>EncodingSpecificOperations();<BR>operand2 = if m_swap then ROR(R[m],16) else R[m];<BR>product1 = SInt(R[n]&lt;15:0&gt;) * SInt(operand2&lt;15:0&gt;);<BR>product2 = SInt(R[n]&lt;31:16&gt;) * SInt(operand2&lt;31:16&gt;);<BR>result = product1 + product2 + SInt(R[dHi]:R[dLo]);<BR>R[dHi] = result&lt;63:32&gt;;<BR>R[dLo] = result&lt;31:0&gt;;</SPAN>