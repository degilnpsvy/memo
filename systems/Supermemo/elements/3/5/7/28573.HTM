<SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Signed Dual Multiply Add performs two signed 16 &#215; 16-bit multiplications. It adds the products together, and writes the result to the destination register.</FONT></SPAN>
<P></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>Optionally, you can exchange the halfwords of the second operand before performing the arithmetic. This produces top &#215; bottom and bottom &#215; top multiplication.</FONT></SPAN></P>
<P><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt"><FONT face=Calibri>This instruction sets the Q flag if the addition overflows. The multiplications cannot overflow.</FONT></SPAN>
<P><SPAN lang=EN-US style="FONT-SIZE: 15.5pt; mso-bidi-font-size: 11.0pt">if ConditionPassed() then<BR>EncodingSpecificOperations();<BR>operand2 = if m_swap then ROR(R[m],16) else R[m];<BR>product1 = SInt(R[n]&lt;15:0&gt;) * SInt(operand2&lt;15:0&gt;);<BR>product2 = SInt(R[n]&lt;31:16&gt;) * SInt(operand2&lt;31:16&gt;);<BR>result = product1 + product2;<BR>R[d] = result&lt;31:0&gt;;<BR>if result != SInt(result&lt;31:0&gt;) then // Signed overflow<BR>APSR.Q = &#8216;1&#8217;;</SPAN>