static const ARMCPRegInfo v7_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* the old v6 WFI, UNPREDICTABLE in v7 but we choose to NOP */<BR>&nbsp;&nbsp;&nbsp; { .name = "NOP", .cp = 15, .crn = 7, .crm = 0, .opc1 = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; /* Performance monitors are implementation defined in v7,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * but with an ARM recommended set of registers, which we<BR>&nbsp;&nbsp;&nbsp;&nbsp; * follow (although we don't actually implement any counters)<BR>&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Performance registers fall into three categories:<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; (a) always UNDEF in PL0, RW in PL1 (PMINTENSET, PMINTENCLR)<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; (b) RO in PL0 (ie UNDEF on write), RW in PL1 (PMUSERENR)<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; (c) UNDEF in PL0 if PMUSERENR.EN==0, otherwise accessible (all others)<BR>&nbsp;&nbsp;&nbsp;&nbsp; * For the cases controlled by PMUSERENR we must set .access to PL0_RW<BR>&nbsp;&nbsp;&nbsp;&nbsp; * or PL0_RO as appropriate and then check PMUSERENR in the helper fn.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCNTENSET", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState, cp15.c9_pmcnten),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmcntenset_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCNTENSET_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 12, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pmcnten), .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmcntenset_write, .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCNTENCLR", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState, cp15.c9_pmcnten),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmcntenclr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCNTENCLR_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 12, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pmcnten),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmcntenclr_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMOVSR", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .fieldoffset = offsetof(CPUARMState, cp15.c9_pmovsr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmovsr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMOVSCLR_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 12, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pmovsr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmovsr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; /* Unimplemented so WI. */<BR>&nbsp;&nbsp;&nbsp; { .name = "PMSWINC", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_W, .accessfn = pmreg_access, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; /* Since we don't implement any events, writing to PMSELR is UNPREDICTABLE.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * We choose to RAZ/WI.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "PMSELR", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .type = ARM_CP_CONST, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access },<BR>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCCNTR", .cp = 15, .crn = 9, .crm = 13, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .resetvalue = 0, .type = ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = pmccntr_read, .writefn = pmccntr_write32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCCNTR_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 13, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = pmccntr_read, .writefn = pmccntr_write, },<BR>#endif<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCCFILTR_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 15, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmccfiltr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.pmccfiltr_el0),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMXEVTYPER", .cp = 15, .crn = 9, .crm = 13, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pmxevtyper),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access, .writefn = pmxevtyper_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; /* Unimplemented, RAZ/WI. */<BR>&nbsp;&nbsp;&nbsp; { .name = "PMXEVCNTR", .cp = 15, .crn = 9, .crm = 13, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .type = ARM_CP_CONST, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMUSERENR", .cp = 15, .crn = 9, .crm = 14, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R | PL1_RW, .accessfn = access_tpm,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pmuserenr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmuserenr_write, .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMUSERENR_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 14, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R | PL1_RW, .accessfn = access_tpm, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pmuserenr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmuserenr_write, .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMINTENSET", .cp = 15, .crn = 9, .crm = 14, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tpm,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pminten),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmintenset_write, .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMINTENCLR", .cp = 15, .crn = 9, .crm = 14, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tpm, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pminten),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmintenclr_write, },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMINTENCLR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 9, .crm = 14, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tpm, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pminten),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmintenclr_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "VBAR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .crn = 12, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .writefn = vbar_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.vbar_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.vbar_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "CCSIDR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .crn = 0, .crm = 0, .opc1 = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .readfn = ccsidr_read, .type = ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; { .name = "CSSELR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .crn = 0, .crm = 0, .opc1 = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .writefn = csselr_write, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.csselr_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.csselr_ns) } },<BR>&nbsp;&nbsp;&nbsp; /* Auxiliary ID register: this actually has an IMPDEF value but for now<BR>&nbsp;&nbsp;&nbsp;&nbsp; * just RAZ for all cores:<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "AIDR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 1, .crn = 0, .crm = 0, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* Auxiliary fault status registers: these also are IMPDEF, and we<BR>&nbsp;&nbsp;&nbsp;&nbsp; * choose to RAZ/WI for all cores.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "AFSR0_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 5, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AFSR1_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 5, .crm = 1, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* MAIR can just read-as-written because we don't implement caches<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and so don't need to care about memory attributes.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "MAIR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 10, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.mair_el[1]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "MAIR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 10, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .fieldoffset = offsetof(CPUARMState, cp15.mair_el[3]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* For non-long-descriptor page tables these are PRRR and NMRR;<BR>&nbsp;&nbsp;&nbsp;&nbsp; * regardless they still act as reads-as-written for QEMU.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp; /* MAIR0/1 are defined separately from their 64-bit counterpart which<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * allows them to assign the correct fieldoffset based on the endianness<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * handled in the field definitions.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "MAIR0", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 10, .crm = 2, .opc2 = 0, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.mair0_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.mair0_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetfn = arm_cp_reset_ignore },<BR>&nbsp;&nbsp;&nbsp; { .name = "MAIR1", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 10, .crm = 2, .opc2 = 1, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.mair1_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.mair1_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetfn = arm_cp_reset_ignore },<BR>&nbsp;&nbsp;&nbsp; { .name = "ISR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 12, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_R, .readfn = isr_read },<BR>&nbsp;&nbsp;&nbsp; /* 32 bit ITLB invalidates */<BR>&nbsp;&nbsp;&nbsp; { .name = "ITLBIALL", .cp = 15, .opc1 = 0, .crn = 8, .crm = 5, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbiall_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "ITLBIMVA", .cp = 15, .opc1 = 0, .crn = 8, .crm = 5, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbimva_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "ITLBIASID", .cp = 15, .opc1 = 0, .crn = 8, .crm = 5, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbiasid_write },<BR>&nbsp;&nbsp;&nbsp; /* 32 bit DTLB invalidates */<BR>&nbsp;&nbsp;&nbsp; { .name = "DTLBIALL", .cp = 15, .opc1 = 0, .crn = 8, .crm = 6, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbiall_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "DTLBIMVA", .cp = 15, .opc1 = 0, .crn = 8, .crm = 6, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbimva_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "DTLBIASID", .cp = 15, .opc1 = 0, .crn = 8, .crm = 6, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbiasid_write },<BR>&nbsp;&nbsp;&nbsp; /* 32 bit TLB invalidates */<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIALL", .cp = 15, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbiall_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVA", .cp = 15, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbimva_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIASID", .cp = 15, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbiasid_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVAA", .cp = 15, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbimvaa_write },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};