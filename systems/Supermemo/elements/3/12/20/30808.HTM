static uint64_t ccsidr_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; /* Acquire the CSSELR index from the bank corresponding to the CCSIDR<BR>&nbsp;&nbsp;&nbsp;&nbsp; * bank<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t index = A32_BANKED_REG_GET(env, csselr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ri-&gt;secure &amp; ARM_CP_SECSTATE_S);</P>
<P>&nbsp;&nbsp;&nbsp; return cpu-&gt;ccsidr[index];<BR>}</P>
<P>static void csselr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value &amp; 0xf);<BR>}</P>
<P>static uint64_t isr_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = ENV_GET_CPU(env);<BR>&nbsp;&nbsp;&nbsp; uint64_t ret = 0;</P>
<P>&nbsp;&nbsp;&nbsp; if (cs-&gt;interrupt_request &amp; CPU_INTERRUPT_HARD) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret |= CPSR_I;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (cs-&gt;interrupt_request &amp; CPU_INTERRUPT_FIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret |= CPSR_F;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* External aborts are not possible in QEMU so A bit is always clear */<BR>&nbsp;&nbsp;&nbsp; return ret;<BR>}