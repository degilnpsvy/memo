static const ARMCPRegInfo not_v7_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* Standard v6 WFI (also used in some pre-v6 cores); not in v7 (which<BR>&nbsp;&nbsp;&nbsp;&nbsp; * is UNPREDICTABLE; we choose to NOP as most implementations do).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "WFI_v6", .cp = 15, .crn = 7, .crm = 0, .opc1 = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_WFI },<BR>&nbsp;&nbsp;&nbsp; /* L1 cache lockdown. Not architectural in v6 and earlier but in practice<BR>&nbsp;&nbsp;&nbsp;&nbsp; * implemented in 926, 946, 1026, 1136, 1176 and 11MPCore. StrongARM and<BR>&nbsp;&nbsp;&nbsp;&nbsp; * OMAPCP will override this space.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "DLOCKDOWN", .cp = 15, .crn = 9, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.c9_data),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "ILOCKDOWN", .cp = 15, .crn = 9, .crm = 0, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.c9_insn),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* v6 doesn't have the cache ID registers but Linux reads them anyway */<BR>&nbsp;&nbsp;&nbsp; { .name = "DUMMY", .cp = 15, .crn = 0, .crm = 0, .opc1 = 1, .opc2 = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST | ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* We don't implement pre-v7 debug but most CPUs had at least a DBGDIDR;<BR>&nbsp;&nbsp;&nbsp;&nbsp; * implementing it as RAZ means the "debug architecture version" bits<BR>&nbsp;&nbsp;&nbsp;&nbsp; * will read as a reserved value, which should cause Linux to not try<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to use the debug hardware.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "DBGDIDR", .cp = 14, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* MMU TLB control. Note that the wildcarding means we cover not just<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the unified TLB ops but also the dside/iside/inner-shareable variants.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIALL", .cp = 15, .crn = 8, .crm = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = 0, .access = PL1_W, .writefn = tlbiall_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVA", .cp = 15, .crn = 8, .crm = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = 1, .access = PL1_W, .writefn = tlbimva_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIASID", .cp = 15, .crn = 8, .crm = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = 2, .access = PL1_W, .writefn = tlbiasid_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVAA", .cp = 15, .crn = 8, .crm = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = 3, .access = PL1_W, .writefn = tlbimvaa_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; { .name = "PRRR", .cp = 15, .crn = 10, .crm = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = 0, .opc2 = 0, .access = PL1_RW, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "NMRR", .cp = 15, .crn = 10, .crm = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = 0, .opc2 = 1, .access = PL1_RW, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};