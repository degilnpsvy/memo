static void pmccfiltr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; pmccntr_sync(env);<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.pmccfiltr_el0 = value &amp; 0x7E000000;<BR>&nbsp;&nbsp;&nbsp; pmccntr_sync(env);<BR>}</P>
<P>static void pmcntenset_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; value &amp;= (1 &lt;&lt; 31);<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pmcnten |= value;<BR>}</P>
<P>static void pmcntenclr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; value &amp;= (1 &lt;&lt; 31);<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pmcnten &amp;= ~value;<BR>}</P>
<P>static void pmovsr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pmovsr &amp;= ~value;<BR>}</P>
<P>static void pmxevtyper_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pmxevtyper = value &amp; 0xff;<BR>}</P>
<P>static void pmuserenr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pmuserenr = value &amp; 1;<BR>}</P>
<P>static void pmintenset_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* We have no event counters so only the C bit can be changed */<BR>&nbsp;&nbsp;&nbsp; value &amp;= (1 &lt;&lt; 31);<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pminten |= value;<BR>}</P>
<P>static void pmintenclr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; value &amp;= (1 &lt;&lt; 31);<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pminten &amp;= ~value;<BR>}</P>
<P>static void vbar_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Note that even though the AArch64 view of this register has bits<BR>&nbsp;&nbsp;&nbsp;&nbsp; * [10:0] all RES0 we can only mask the bottom 5, to comply with the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * architectural requirements for bits which are RES0 only in some<BR>&nbsp;&nbsp;&nbsp;&nbsp; * contexts. (ARMv8 would permit us to do no masking at all, but ARMv7<BR>&nbsp;&nbsp;&nbsp;&nbsp; * requires the bottom five bits to be RAZ/WI because they're UNK/SBZP.)<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value &amp; ~0x1FULL);<BR>}</P>
<P>static void scr_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* We only mask off bits that are RES0 both for AArch64 and AArch32.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * For bits that vary between AArch32/64, code needs to check the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * current execution mode before directly using the feature bit.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t valid_mask = SCR_AARCH64_MASK | SCR_AARCH32_MASK;</P>
<P>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_EL2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; valid_mask &amp;= ~SCR_HCE;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* On ARMv7, SMD (or SCD as it is called in v7) is only<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * supported if EL2 exists. The bit is UNK/SBZP when<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * EL2 is unavailable. In QEMU ARMv7, we force it to always zero<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * when EL2 is unavailable.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * On ARMv8, this bit is always available.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V7) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; valid_mask &amp;= ~SCR_SMD;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Clear all-context RES0 bits.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; value &amp;= valid_mask;<BR>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>}