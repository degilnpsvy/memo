#ifndef CONFIG_USER_ONLY</P>
<P>static CPAccessResult gt_cntfrq_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* CNTFRQ: not visible from PL0 if both PL0PCTEN and PL0VCTEN are zero.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Writable only at the highest implemented exception level.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int el = arm_current_el(env);</P>
<P>&nbsp;&nbsp;&nbsp; switch (el) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!extract32(env-&gt;cp15.c14_cntkctl, 0, 2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isread &amp;&amp; ri-&gt;state == ARM_CP_STATE_AA32 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Accesses from 32-bit Secure EL1 UNDEF (*not* trap to EL3!) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_UNCATEGORIZED;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (!isread &amp;&amp; el &lt; arm_highest_el(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_UNCATEGORIZED;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</P>
<P>static CPAccessResult gt_counter_access(CPUARMState *env, int timeridx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned int cur_el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; bool secure = arm_is_secure(env);</P>
<P>&nbsp;&nbsp;&nbsp; /* CNT[PV]CT: not visible from PL0 if ELO[PV]CTEN is zero */<BR>&nbsp;&nbsp;&nbsp; if (cur_el == 0 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !extract32(env-&gt;cp15.c14_cntkctl, timeridx, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL2) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timeridx == GTIMER_PHYS &amp;&amp; !secure &amp;&amp; cur_el &lt; 2 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !extract32(env-&gt;cp15.cnthctl_el2, 0, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</P>
<P>static CPAccessResult gt_timer_access(CPUARMState *env, int timeridx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned int cur_el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; bool secure = arm_is_secure(env);</P>
<P>&nbsp;&nbsp;&nbsp; /* CNT[PV]_CVAL, CNT[PV]_CTL, CNT[PV]_TVAL: not visible from PL0 if<BR>&nbsp;&nbsp;&nbsp;&nbsp; * EL0[PV]TEN is zero.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (cur_el == 0 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !extract32(env-&gt;cp15.c14_cntkctl, 9 - timeridx, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL2) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timeridx == GTIMER_PHYS &amp;&amp; !secure &amp;&amp; cur_el &lt; 2 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !extract32(env-&gt;cp15.cnthctl_el2, 1, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</P>
<P>static CPAccessResult gt_pct_access(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_counter_access(env, GTIMER_PHYS, isread);<BR>}</P>
<P>static CPAccessResult gt_vct_access(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_counter_access(env, GTIMER_VIRT, isread);<BR>}</P>
<P>static CPAccessResult gt_ptimer_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_timer_access(env, GTIMER_PHYS, isread);<BR>}</P>
<P>static CPAccessResult gt_vtimer_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_timer_access(env, GTIMER_VIRT, isread);<BR>}</P>
<P>static CPAccessResult gt_stimer_access(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* The AArch64 register view of the secure physical timer is<BR>&nbsp;&nbsp;&nbsp;&nbsp; * always accessible from EL3, and configurably accessible from<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Secure EL1.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; switch (arm_current_el(env)) {<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_is_secure(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(env-&gt;cp15.scr_el3 &amp; SCR_ST)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static uint64_t gt_get_countervalue(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / GTIMER_SCALE;<BR>}</P>
<P>static void gt_recalc_timer(ARMCPU *cpu, int timeridx)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMGenericTimer *gt = &amp;cpu-&gt;env.cp15.c14_timer[timeridx];</P>
<P>&nbsp;&nbsp;&nbsp; if (gt-&gt;ctl &amp; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Timer enabled: calculate and set current ISTATUS, irq, and<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * reset timer to when ISTATUS next has to change<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t offset = timeridx == GTIMER_VIRT ?<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;env.cp15.cntvoff_el2 : 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t count = gt_get_countervalue(&amp;cpu-&gt;env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note that this must be unsigned 64 bit arithmetic: */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int istatus = count - offset &gt;= gt-&gt;cval;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t nexttick;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gt-&gt;ctl = deposit32(gt-&gt;ctl, 2, 1, istatus);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_set_irq(cpu-&gt;gt_timer_outputs[timeridx],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (istatus &amp;&amp; !(gt-&gt;ctl &amp; 2)));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (istatus) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Next transition is when count rolls back over to zero */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nexttick = UINT64_MAX;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Next transition is when we hit cval */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nexttick = gt-&gt;cval + offset;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note that the desired next expiry time might be beyond the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * signed-64-bit range of a QEMUTimer -- in this case we just<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * set the timer for as far in the future as possible. When the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * timer expires we will reset the timer for any remaining period.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nexttick &gt; INT64_MAX / GTIMER_SCALE) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nexttick = INT64_MAX / GTIMER_SCALE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timer_mod(cpu-&gt;gt_timer[timeridx], nexttick);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Timer disabled: ISTATUS and timer output always clear */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gt-&gt;ctl &amp;= ~4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_set_irq(cpu-&gt;gt_timer_outputs[timeridx], 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timer_del(cpu-&gt;gt_timer[timeridx]);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void gt_timer_reset(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int timeridx)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; timer_del(cpu-&gt;gt_timer[timeridx]);<BR>}</P>
<P>static uint64_t gt_cnt_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_get_countervalue(env);<BR>}</P>
<P>static uint64_t gt_virt_cnt_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_get_countervalue(env) - env-&gt;cp15.cntvoff_el2;<BR>}</P>
<P>static void gt_cval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int timeridx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c14_timer[timeridx].cval = value;<BR>&nbsp;&nbsp;&nbsp; gt_recalc_timer(arm_env_get_cpu(env), timeridx);<BR>}</P>
<P>static uint64_t gt_tval_read(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int timeridx)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t offset = timeridx == GTIMER_VIRT ? env-&gt;cp15.cntvoff_el2 : 0;</P>
<P>&nbsp;&nbsp;&nbsp; return (uint32_t)(env-&gt;cp15.c14_timer[timeridx].cval -<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gt_get_countervalue(env) - offset));<BR>}</P>
<P>static void gt_tval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int timeridx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t offset = timeridx == GTIMER_VIRT ? env-&gt;cp15.cntvoff_el2 : 0;</P>
<P>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c14_timer[timeridx].cval = gt_get_countervalue(env) - offset +<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sextract64(value, 0, 32);<BR>&nbsp;&nbsp;&nbsp; gt_recalc_timer(arm_env_get_cpu(env), timeridx);<BR>}</P>
<P>static void gt_ctl_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int timeridx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; uint32_t oldval = env-&gt;cp15.c14_timer[timeridx].ctl;</P>
<P>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c14_timer[timeridx].ctl = deposit64(oldval, 0, 2, value);<BR>&nbsp;&nbsp;&nbsp; if ((oldval ^ value) &amp; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Enable toggled */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gt_recalc_timer(cpu, timeridx);<BR>&nbsp;&nbsp;&nbsp; } else if ((oldval ^ value) &amp; 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* IMASK toggled: don't need to recalculate,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * just set the interrupt line based on ISTATUS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_set_irq(cpu-&gt;gt_timer_outputs[timeridx],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (oldval &amp; 4) &amp;&amp; !(value &amp; 2));<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void gt_phys_timer_reset(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_timer_reset(env, ri, GTIMER_PHYS);<BR>}</P>
<P>static void gt_phys_cval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_cval_write(env, ri, GTIMER_PHYS, value);<BR>}</P>
<P>static uint64_t gt_phys_tval_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_tval_read(env, ri, GTIMER_PHYS);<BR>}</P>
<P>static void gt_phys_tval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_tval_write(env, ri, GTIMER_PHYS, value);<BR>}</P>
<P>static void gt_phys_ctl_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_ctl_write(env, ri, GTIMER_PHYS, value);<BR>}</P>
<P>static void gt_virt_timer_reset(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_timer_reset(env, ri, GTIMER_VIRT);<BR>}</P>
<P>static void gt_virt_cval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_cval_write(env, ri, GTIMER_VIRT, value);<BR>}</P>
<P>static uint64_t gt_virt_tval_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_tval_read(env, ri, GTIMER_VIRT);<BR>}</P>
<P>static void gt_virt_tval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_tval_write(env, ri, GTIMER_VIRT, value);<BR>}</P>
<P>static void gt_virt_ctl_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_ctl_write(env, ri, GTIMER_VIRT, value);<BR>}</P>
<P>static void gt_cntvoff_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; gt_recalc_timer(cpu, GTIMER_VIRT);<BR>}</P>
<P>static void gt_hyp_timer_reset(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_timer_reset(env, ri, GTIMER_HYP);<BR>}</P>
<P>static void gt_hyp_cval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_cval_write(env, ri, GTIMER_HYP, value);<BR>}</P>
<P>static uint64_t gt_hyp_tval_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_tval_read(env, ri, GTIMER_HYP);<BR>}</P>
<P>static void gt_hyp_tval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_tval_write(env, ri, GTIMER_HYP, value);<BR>}</P>
<P>static void gt_hyp_ctl_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_ctl_write(env, ri, GTIMER_HYP, value);<BR>}</P>
<P>static void gt_sec_timer_reset(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_timer_reset(env, ri, GTIMER_SEC);<BR>}</P>
<P>static void gt_sec_cval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_cval_write(env, ri, GTIMER_SEC, value);<BR>}</P>
<P>static uint64_t gt_sec_tval_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_tval_read(env, ri, GTIMER_SEC);<BR>}</P>
<P>static void gt_sec_tval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_tval_write(env, ri, GTIMER_SEC, value);<BR>}</P>
<P>static void gt_sec_ctl_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_ctl_write(env, ri, GTIMER_SEC, value);<BR>}</P>
<P>void arm_gt_ptimer_cb(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;</P>
<P>&nbsp;&nbsp;&nbsp; gt_recalc_timer(cpu, GTIMER_PHYS);<BR>}</P>
<P>void arm_gt_vtimer_cb(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;</P>
<P>&nbsp;&nbsp;&nbsp; gt_recalc_timer(cpu, GTIMER_VIRT);<BR>}</P>
<P>void arm_gt_htimer_cb(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;</P>
<P>&nbsp;&nbsp;&nbsp; gt_recalc_timer(cpu, GTIMER_HYP);<BR>}</P>
<P>void arm_gt_stimer_cb(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;</P>
<P>&nbsp;&nbsp;&nbsp; gt_recalc_timer(cpu, GTIMER_SEC);<BR>}</P>
<P>static const ARMCPRegInfo generic_timer_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* Note that CNTFRQ is purely reads-as-written for the benefit<BR>&nbsp;&nbsp;&nbsp;&nbsp; * of software; writing it doesn't actually change the timer frequency.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Our reset value matches the fixed frequency we implement the timer at.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTFRQ", .cp = 15, .crn = 14, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R, .accessfn = gt_cntfrq_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState, cp15.c14_cntfrq),<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTFRQ_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R, .accessfn = gt_cntfrq_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_cntfrq),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = (1000 * 1000 * 1000) / GTIMER_SCALE,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; /* overall control: mostly access permissions */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTKCTL", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 14, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_cntkctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; /* per-timer control */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_CTL", .cp = 15, .crn = 14, .crm = 2, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .secure = ARM_CP_SECSTATE_NS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO | ARM_CP_ALIAS, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cp15.c14_timer[GTIMER_PHYS].ctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_phys_ctl_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_CTL(S)",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 14, .crm = 2, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .secure = ARM_CP_SECSTATE_S,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO | ARM_CP_ALIAS, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cp15.c14_timer[GTIMER_SEC].ctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_sec_ctl_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_CTL_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 2, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_PHYS].ctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_phys_ctl_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTV_CTL", .cp = 15, .crn = 14, .crm = 3, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO | ARM_CP_ALIAS, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vtimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cp15.c14_timer[GTIMER_VIRT].ctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_virt_ctl_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTV_CTL_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 3, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vtimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_VIRT].ctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_virt_ctl_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; /* TimerValue views: a 32 bit downcounting view of the underlying state */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_TVAL", .cp = 15, .crn = 14, .crm = 2, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .secure = ARM_CP_SECSTATE_NS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW | ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_phys_tval_read, .writefn = gt_phys_tval_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_TVAL(S)",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 14, .crm = 2, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .secure = ARM_CP_SECSTATE_S,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW | ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_sec_tval_read, .writefn = gt_sec_tval_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_TVAL_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW | ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access, .resetfn = gt_phys_timer_reset,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_phys_tval_read, .writefn = gt_phys_tval_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTV_TVAL", .cp = 15, .crn = 14, .crm = 3, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW | ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vtimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_virt_tval_read, .writefn = gt_virt_tval_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTV_TVAL_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW | ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vtimer_access, .resetfn = gt_virt_timer_reset,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_virt_tval_read, .writefn = gt_virt_tval_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; /* The counter itself */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTPCT", .cp = 15, .crm = 14, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_64BIT | ARM_CP_NO_RAW | ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_pct_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_cnt_read, .resetfn = arm_cp_reset_ignore,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTPCT_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_NO_RAW | ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_pct_access, .readfn = gt_cnt_read,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTVCT", .cp = 15, .crm = 14, .opc1 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_64BIT | ARM_CP_NO_RAW | ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vct_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_virt_cnt_read, .resetfn = arm_cp_reset_ignore,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTVCT_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_NO_RAW | ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vct_access, .readfn = gt_virt_cnt_read,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; /* Comparison value, indicating when the timer goes off */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_CVAL", .cp = 15, .crm = 14, .opc1 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .secure = ARM_CP_SECSTATE_NS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_64BIT | ARM_CP_IO | ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_PHYS].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_phys_cval_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_CVAL(S)", .cp = 15, .crm = 14, .opc1 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .secure = ARM_CP_SECSTATE_S,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_64BIT | ARM_CP_IO | ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_SEC].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_sec_cval_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_CVAL_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 2, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_PHYS].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_phys_cval_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTV_CVAL", .cp = 15, .crm = 14, .opc1 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_64BIT | ARM_CP_IO | ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_VIRT].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vtimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_virt_cval_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTV_CVAL_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 3, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_VIRT].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, .accessfn = gt_vtimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_virt_cval_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; /* Secure timer -- this is actually restricted to only EL3<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and configurably Secure-EL1 via the accessfn.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTPS_TVAL_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 7, .crn = 14, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW | ARM_CP_IO, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_stimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_sec_tval_read,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_sec_tval_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetfn = gt_sec_timer_reset,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTPS_CTL_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 7, .crn = 14, .crm = 2, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_stimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_SEC].ctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_sec_ctl_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTPS_CVAL_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 7, .crn = 14, .crm = 2, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_stimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_SEC].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_sec_cval_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</P>
<P>#else<BR>/* In user-mode none of the generic timer registers are accessible,<BR>&nbsp;* and their implementation depends on QEMU_CLOCK_VIRTUAL and qdev gpio outputs,<BR>&nbsp;* so instead just don't register any of them.<BR>&nbsp;*/<BR>static const ARMCPRegInfo generic_timer_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</P>
<P>#endif