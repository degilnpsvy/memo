static bool raw_accessors_invalid(const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp; /* Return true if the regdef would cause an assertion if you called<BR>&nbsp;&nbsp;&nbsp; * read_raw_cp_reg() or write_raw_cp_reg() on it (ie if it is a<BR>&nbsp;&nbsp;&nbsp; * program bug for it not to have the NO_RAW flag).<BR>&nbsp;&nbsp;&nbsp; * NB that returning false here doesn't necessarily mean that calling<BR>&nbsp;&nbsp;&nbsp; * read/write_raw_cp_reg() is safe, because we can't distinguish "has<BR>&nbsp;&nbsp;&nbsp; * read/write access functions which are safe for raw use" from "has<BR>&nbsp;&nbsp;&nbsp; * read/write access functions which have side effects but has forgotten<BR>&nbsp;&nbsp;&nbsp; * to provide raw access functions".<BR>&nbsp;&nbsp;&nbsp; * The tests here line up with the conditions in read/write_raw_cp_reg()<BR>&nbsp;&nbsp;&nbsp; * and assertions in raw_read()/raw_write().<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if ((ri-&gt;type &amp; ARM_CP_CONST) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ri-&gt;fieldoffset ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((ri-&gt;raw_writefn || ri-&gt;writefn) &amp;&amp; (ri-&gt;raw_readfn || ri-&gt;readfn))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return true;<BR>}