static void vmsa_ttbcr_raw_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCR *tcr = raw_ptr(env, ri);<BR>&nbsp;&nbsp;&nbsp; int maskshift = extract32(value, 0, 3);</P>
<P>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_LPAE) &amp;&amp; (value &amp; TTBCR_EAE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Pre ARMv8 bits [21:19], [15:14] and [6:3] are UNK/SBZP when<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * using Long-desciptor translation table format */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value &amp;= ~((7 &lt;&lt; 19) | (3 &lt;&lt; 14) | (0xf &lt;&lt; 3));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* In an implementation that includes the Security Extensions<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * TTBCR has additional fields PD0 [4] and PD1 [5] for<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Short-descriptor translation table format.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value &amp;= TTBCR_PD1 | TTBCR_PD0 | TTBCR_N;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value &amp;= TTBCR_N;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Update the masks corresponding to the TCR bank being written<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Note that we always calculate mask and base_mask, but<BR>&nbsp;&nbsp;&nbsp;&nbsp; * they are only used for short-descriptor tables (ie if EAE is 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp; * for long-descriptor tables the TCR fields are used differently<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and the mask and base_mask values are meaningless.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;raw_tcr = value;<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;mask = ~(((uint32_t)0xffffffffu) &gt;&gt; maskshift);<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;base_mask = ~((uint32_t)0x3fffu &gt;&gt; maskshift);<BR>}</P>
<P>static void vmsa_ttbcr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_LPAE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* With LPAE the TTBCR could result in a change of ASID<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * via the TTBCR.A1 bit, so do a TLB flush.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; vmsa_ttbcr_raw_write(env, ri, value);<BR>}</P>
<P>static void vmsa_ttbcr_reset(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCR *tcr = raw_ptr(env, ri);</P>
<P>&nbsp;&nbsp;&nbsp; /* Reset both the TCR as well as the masks corresponding to the bank of<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the TCR being reset.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;raw_tcr = 0;<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;mask = 0;<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;base_mask = 0xffffc000u;<BR>}</P>
<P>static void vmsa_tcr_el1_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; TCR *tcr = raw_ptr(env, ri);</P>
<P>&nbsp;&nbsp;&nbsp; /* For AArch64 the A1 bit could result in a change of ASID, so TLB flush. */<BR>&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;raw_tcr = value;<BR>}</P>
<P>static void vmsa_ttbr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* 64 bit accesses to the TTBRs can change the ASID and so we<BR>&nbsp;&nbsp;&nbsp;&nbsp; * must flush the TLB.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (cpreg_field_is_64bit(ri)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>}</P>
<P>static void vttbr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);</P>
<P>&nbsp;&nbsp;&nbsp; /* Accesses to VTTBR may change the VMID so we must flush the TLB.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (raw_read(env, ri) != value) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(cs, ARMMMUIdx_S12NSE1, ARMMMUIdx_S12NSE0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S2NS, -1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; }<BR>}