int main(int argc, char **argv, char **envp)<BR>{<BR>&nbsp;&nbsp;&nbsp; struct target_pt_regs regs1, *regs = &amp;regs1;<BR>&nbsp;&nbsp;&nbsp; struct image_info info1, *info = &amp;info1;<BR>&nbsp;&nbsp;&nbsp; struct linux_binprm bprm;<BR>&nbsp;&nbsp;&nbsp; TaskState *ts;<BR>&nbsp;&nbsp;&nbsp; CPUArchState *env;<BR>&nbsp;&nbsp;&nbsp; CPUState *cpu;<BR>&nbsp;&nbsp;&nbsp; int optind;<BR>&nbsp;&nbsp;&nbsp; char **target_environ, **wrk;<BR>&nbsp;&nbsp;&nbsp; char **target_argv;<BR>&nbsp;&nbsp;&nbsp; int target_argc;<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; int ret;<BR>&nbsp;&nbsp;&nbsp; int execfd;</P>
<P>&nbsp;&nbsp;&nbsp; qemu_init_cpu_list();<BR>&nbsp;&nbsp;&nbsp; module_call_init(MODULE_INIT_QOM);</P>
<P>&nbsp;&nbsp;&nbsp; if ((envlist = envlist_create()) == NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void) fprintf(stderr, "Unable to allocate envlist\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* add current environment into the list */<BR>&nbsp;&nbsp;&nbsp; for (wrk = environ; *wrk != NULL; wrk++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void) envlist_setenv(envlist, *wrk);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Read the stack limit from the kernel.&nbsp; If it's "unlimited",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then we can do little else besides use the default.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct rlimit lim;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (getrlimit(RLIMIT_STACK, &amp;lim) == 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; lim.rlim_cur != RLIM_INFINITY<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; lim.rlim_cur == (target_long)lim.rlim_cur) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guest_stack_size = lim.rlim_cur;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cpu_model = NULL;</P>
<P>&nbsp;&nbsp;&nbsp; srand(time(NULL));</P>
<P>&nbsp;&nbsp;&nbsp; qemu_add_opts(&amp;qemu_trace_opts);</P>
<P>&nbsp;&nbsp;&nbsp; optind = parse_args(argc, argv);</P>
<P>&nbsp;&nbsp;&nbsp; if (!trace_init_backends()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; trace_init_file(trace_file);</P>
<P>&nbsp;&nbsp;&nbsp; /* Zero out regs */<BR>&nbsp;&nbsp;&nbsp; memset(regs, 0, sizeof(struct target_pt_regs));</P>
<P>&nbsp;&nbsp;&nbsp; /* Zero out image_info */<BR>&nbsp;&nbsp;&nbsp; memset(info, 0, sizeof(struct image_info));</P>
<P>&nbsp;&nbsp;&nbsp; memset(&amp;bprm, 0, sizeof (bprm));</P>
<P>&nbsp;&nbsp;&nbsp; /* Scan interp_prefix dir for replacement files. */<BR>&nbsp;&nbsp;&nbsp; init_paths(interp_prefix);</P>
<P>&nbsp;&nbsp;&nbsp; init_qemu_uname_release();</P>
<P>&nbsp;&nbsp;&nbsp; if (cpu_model == NULL) {<BR>#if defined(TARGET_I386)<BR>#ifdef TARGET_X86_64<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = "qemu64";<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = "qemu32";<BR>#endif<BR>#elif defined(TARGET_ARM)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = "any";<BR>#elif defined(TARGET_UNICORE32)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = "any";<BR>#elif defined(TARGET_M68K)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = "any";<BR>#elif defined(TARGET_SPARC)<BR>#ifdef TARGET_SPARC64<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = "TI UltraSparc II";<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = "Fujitsu MB86904";<BR>#endif<BR>#elif defined(TARGET_MIPS)<BR>#if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = "5KEf";<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = "24Kf";<BR>#endif<BR>#elif defined TARGET_OPENRISC<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = "or1200";<BR>#elif defined(TARGET_PPC)<BR># ifdef TARGET_PPC64<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = "POWER8";<BR># else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = "750";<BR># endif<BR>#elif defined TARGET_SH4<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = TYPE_SH7785_CPU;<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_model = "any";<BR>#endif<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_exec_init(0);<BR>&nbsp;&nbsp;&nbsp; /* NOTE: we need to init the CPU at this stage to get<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_host_page_size */<BR>&nbsp;&nbsp;&nbsp; cpu = cpu_init(cpu_model);<BR>&nbsp;&nbsp;&nbsp; if (!cpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Unable to find CPU definition\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; env = cpu-&gt;env_ptr;<BR>&nbsp;&nbsp;&nbsp; cpu_reset(cpu);</P>
<P>&nbsp;&nbsp;&nbsp; thread_cpu = cpu;</P>
<P>&nbsp;&nbsp;&nbsp; if (getenv("QEMU_STRACE")) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do_strace = 1;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (getenv("QEMU_RAND_SEED")) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle_arg_randseed(getenv("QEMU_RAND_SEED"));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; target_environ = envlist_to_environ(envlist, NULL);<BR>&nbsp;&nbsp;&nbsp; envlist_free(envlist);</P>
<P>&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Now that page sizes are configured in cpu_init() we can do<BR>&nbsp;&nbsp;&nbsp;&nbsp; * proper page alignment for guest_base.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; guest_base = HOST_PAGE_ALIGN(guest_base);</P>
<P>&nbsp;&nbsp;&nbsp; if (reserved_va || have_guest_base) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guest_base = init_guest_space(guest_base, reserved_va, 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; have_guest_base);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (guest_base == (unsigned long)-1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Unable to reserve 0x%lx bytes of virtual address "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "space for use as guest address space (check your virtual "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "memory ulimit setting or reserve less using -R option)\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reserved_va);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (reserved_va) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmap_next_start = reserved_va;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Read in mmap_min_addr kernel parameter.&nbsp; This value is used<BR>&nbsp;&nbsp;&nbsp;&nbsp; * When loading the ELF image to determine whether guest_base<BR>&nbsp;&nbsp;&nbsp;&nbsp; * is needed.&nbsp; It is also used in mmap_find_vma.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *fp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((fp = fopen("/proc/sys/vm/mmap_min_addr", "r")) != NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long tmp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fscanf(fp, "%lu", &amp;tmp) == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmap_min_addr = tmp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_PAGE, "host mmap_min_addr=0x%lx\n", mmap_min_addr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(fp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Prepare copy of argv vector for target.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; target_argc = argc - optind;<BR>&nbsp;&nbsp;&nbsp; target_argv = calloc(target_argc + 1, sizeof (char *));<BR>&nbsp;&nbsp;&nbsp; if (target_argv == NULL) {<BR>&nbsp;(void) fprintf(stderr, "Unable to allocate memory for target_argv\n");<BR>&nbsp;exit(EXIT_FAILURE);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp; * If argv0 is specified (using '-0' switch) we replace<BR>&nbsp;&nbsp;&nbsp;&nbsp; * argv[0] pointer with the given one.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; i = 0;<BR>&nbsp;&nbsp;&nbsp; if (argv0 != NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_argv[i++] = strdup(argv0);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; for (; i &lt; target_argc; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_argv[i] = strdup(argv[optind + i]);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; target_argv[target_argc] = NULL;</P>
<P>&nbsp;&nbsp;&nbsp; ts = g_new0(TaskState, 1);<BR>&nbsp;&nbsp;&nbsp; init_task_state(ts);<BR>&nbsp;&nbsp;&nbsp; /* build Task State */<BR>&nbsp;&nbsp;&nbsp; ts-&gt;info = info;<BR>&nbsp;&nbsp;&nbsp; ts-&gt;bprm = &amp;bprm;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;opaque = ts;<BR>&nbsp;&nbsp;&nbsp; task_settid(ts);</P>
<P>&nbsp;&nbsp;&nbsp; execfd = qemu_getauxval(AT_EXECFD);<BR>&nbsp;&nbsp;&nbsp; if (execfd == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execfd = open(filename, O_RDONLY);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (execfd &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error while loading %s: %s\n", filename, strerror(errno));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _exit(EXIT_FAILURE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; ret = loader_exec(execfd, filename, target_argv, target_environ, regs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info, &amp;bprm);<BR>&nbsp;&nbsp;&nbsp; if (ret != 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error while loading %s: %s\n", filename, strerror(-ret));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _exit(EXIT_FAILURE);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; for (wrk = target_environ; *wrk; wrk++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(*wrk);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; free(target_environ);</P>
<P>&nbsp;&nbsp;&nbsp; if (qemu_loglevel_mask(CPU_LOG_PAGE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log("guest_base&nbsp; 0x%lx\n", guest_base);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log_page_dump();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log("start_brk&nbsp;&nbsp; 0x" TARGET_ABI_FMT_lx "\n", info-&gt;start_brk);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log("end_code&nbsp;&nbsp;&nbsp; 0x" TARGET_ABI_FMT_lx "\n", info-&gt;end_code);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log("start_code&nbsp; 0x" TARGET_ABI_FMT_lx "\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;start_code);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log("start_data&nbsp; 0x" TARGET_ABI_FMT_lx "\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;start_data);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log("end_data&nbsp;&nbsp;&nbsp; 0x" TARGET_ABI_FMT_lx "\n", info-&gt;end_data);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log("start_stack 0x" TARGET_ABI_FMT_lx "\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;start_stack);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log("brk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x" TARGET_ABI_FMT_lx "\n", info-&gt;brk);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log("entry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x" TARGET_ABI_FMT_lx "\n", info-&gt;entry);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; target_set_brk(info-&gt;brk);<BR>&nbsp;&nbsp;&nbsp; syscall_init();<BR>&nbsp;&nbsp;&nbsp; signal_init();</P>
<P>&nbsp;&nbsp;&nbsp; /* Now that we've loaded the binary, GUEST_BASE is fixed.&nbsp; Delay<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; generating the prologue until now so that the prologue can take<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the real value of GUEST_BASE into account.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_prologue_init(&amp;tcg_ctx);</P>
<P>#if defined(TARGET_I386)<BR>&nbsp;&nbsp;&nbsp; env-&gt;cr[0] = CR0_PG_MASK | CR0_WP_MASK | CR0_PE_MASK;<BR>&nbsp;&nbsp;&nbsp; env-&gt;hflags |= HF_PE_MASK | HF_CPL_MASK;<BR>&nbsp;&nbsp;&nbsp; if (env-&gt;features[FEAT_1_EDX] &amp; CPUID_SSE) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cr[4] |= CR4_OSFXSR_MASK;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;hflags |= HF_OSFXSR_MASK;<BR>&nbsp;&nbsp;&nbsp; }<BR>#ifndef TARGET_ABI32<BR>&nbsp;&nbsp;&nbsp; /* enable 64 bit mode if possible */<BR>&nbsp;&nbsp;&nbsp; if (!(env-&gt;features[FEAT_8000_0001_EDX] &amp; CPUID_EXT2_LM)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "The selected x86 CPU does not support 64 bit mode\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; env-&gt;cr[4] |= CR4_PAE_MASK;<BR>&nbsp;&nbsp;&nbsp; env-&gt;efer |= MSR_EFER_LMA | MSR_EFER_LME;<BR>&nbsp;&nbsp;&nbsp; env-&gt;hflags |= HF_LMA_MASK;<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; /* flags setup : we activate the IRQs by default as in user mode */<BR>&nbsp;&nbsp;&nbsp; env-&gt;eflags |= IF_MASK;</P>
<P>&nbsp;&nbsp;&nbsp; /* linux register setup */<BR>#ifndef TARGET_ABI32<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_EAX] = regs-&gt;rax;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_EBX] = regs-&gt;rbx;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_ECX] = regs-&gt;rcx;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_EDX] = regs-&gt;rdx;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_ESI] = regs-&gt;rsi;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_EDI] = regs-&gt;rdi;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_EBP] = regs-&gt;rbp;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_ESP] = regs-&gt;rsp;<BR>&nbsp;&nbsp;&nbsp; env-&gt;eip = regs-&gt;rip;<BR>#else<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_EAX] = regs-&gt;eax;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_EBX] = regs-&gt;ebx;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_ECX] = regs-&gt;ecx;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_EDX] = regs-&gt;edx;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_ESI] = regs-&gt;esi;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_EDI] = regs-&gt;edi;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_EBP] = regs-&gt;ebp;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[R_ESP] = regs-&gt;esp;<BR>&nbsp;&nbsp;&nbsp; env-&gt;eip = regs-&gt;eip;<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; /* linux interrupt setup */<BR>#ifndef TARGET_ABI32<BR>&nbsp;&nbsp;&nbsp; env-&gt;idt.limit = 511;<BR>#else<BR>&nbsp;&nbsp;&nbsp; env-&gt;idt.limit = 255;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; env-&gt;idt.base = target_mmap(0, sizeof(uint64_t) * (env-&gt;idt.limit + 1),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROT_READ|PROT_WRITE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);<BR>&nbsp;&nbsp;&nbsp; idt_table = g2h(env-&gt;idt.base);<BR>&nbsp;&nbsp;&nbsp; set_idt(0, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(1, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(2, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(3, 3);<BR>&nbsp;&nbsp;&nbsp; set_idt(4, 3);<BR>&nbsp;&nbsp;&nbsp; set_idt(5, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(6, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(7, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(8, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(9, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(10, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(11, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(12, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(13, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(14, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(15, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(16, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(17, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(18, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(19, 0);<BR>&nbsp;&nbsp;&nbsp; set_idt(0x80, 3);</P>
<P>&nbsp;&nbsp;&nbsp; /* linux segment setup */<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t *gdt_table;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;gdt.base = target_mmap(0, sizeof(uint64_t) * TARGET_GDT_ENTRIES,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROT_READ|PROT_WRITE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;gdt.limit = sizeof(uint64_t) * TARGET_GDT_ENTRIES - 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gdt_table = g2h(env-&gt;gdt.base);<BR>#ifdef TARGET_ABI32<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_dt(&amp;gdt_table[__USER_CS &gt;&gt; 3], 0, 0xfffff,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DESC_G_MASK | DESC_B_MASK | DESC_P_MASK | DESC_S_MASK |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3 &lt;&lt; DESC_DPL_SHIFT) | (0xa &lt;&lt; DESC_TYPE_SHIFT));<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 64 bit code segment */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_dt(&amp;gdt_table[__USER_CS &gt;&gt; 3], 0, 0xfffff,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DESC_G_MASK | DESC_B_MASK | DESC_P_MASK | DESC_S_MASK |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DESC_L_MASK |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3 &lt;&lt; DESC_DPL_SHIFT) | (0xa &lt;&lt; DESC_TYPE_SHIFT));<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_dt(&amp;gdt_table[__USER_DS &gt;&gt; 3], 0, 0xfffff,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DESC_G_MASK | DESC_B_MASK | DESC_P_MASK | DESC_S_MASK |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3 &lt;&lt; DESC_DPL_SHIFT) | (0x2 &lt;&lt; DESC_TYPE_SHIFT));<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; cpu_x86_load_seg(env, R_CS, __USER_CS);<BR>&nbsp;&nbsp;&nbsp; cpu_x86_load_seg(env, R_SS, __USER_DS);<BR>#ifdef TARGET_ABI32<BR>&nbsp;&nbsp;&nbsp; cpu_x86_load_seg(env, R_DS, __USER_DS);<BR>&nbsp;&nbsp;&nbsp; cpu_x86_load_seg(env, R_ES, __USER_DS);<BR>&nbsp;&nbsp;&nbsp; cpu_x86_load_seg(env, R_FS, __USER_DS);<BR>&nbsp;&nbsp;&nbsp; cpu_x86_load_seg(env, R_GS, __USER_DS);<BR>&nbsp;&nbsp;&nbsp; /* This hack makes Wine work... */<BR>&nbsp;&nbsp;&nbsp; env-&gt;segs[R_FS].selector = 0;<BR>#else<BR>&nbsp;&nbsp;&nbsp; cpu_x86_load_seg(env, R_DS, 0);<BR>&nbsp;&nbsp;&nbsp; cpu_x86_load_seg(env, R_ES, 0);<BR>&nbsp;&nbsp;&nbsp; cpu_x86_load_seg(env, R_FS, 0);<BR>&nbsp;&nbsp;&nbsp; cpu_x86_load_seg(env, R_GS, 0);<BR>#endif<BR>#elif defined(TARGET_AARCH64)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(arm_feature(env, ARM_FEATURE_AARCH64))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "The selected ARM CPU does not support 64 bit mode\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 31; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[i] = regs-&gt;regs[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pc = regs-&gt;pc;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[31] = regs-&gt;sp;<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TARGET_ARM)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpsr_write(env, regs-&gt;uregs[16], CPSR_USER | CPSR_EXEC,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPSRWriteByInstr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; 16; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[i] = regs-&gt;uregs[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#ifdef TARGET_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Enable BE8.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (EF_ARM_EABI_VERSION(info-&gt;elf_flags) &gt;= EF_ARM_EABI_VER4<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (info-&gt;elf_flags &amp; EF_ARM_BE8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;uncached_cpsr |= CPSR_E;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.sctlr_el[1] |= SCTLR_E0E;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.sctlr_el[1] |= SCTLR_B;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TARGET_UNICORE32)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_asr_write(env, regs-&gt;uregs[32], 0xffffffff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 32; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[i] = regs-&gt;uregs[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TARGET_SPARC)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;env-&gt;pc = regs-&gt;pc;<BR>&nbsp;env-&gt;npc = regs-&gt;npc;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;y = regs-&gt;y;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; 8; i++)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;gregs[i] = regs-&gt;u_regs[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; 8; i++)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regwptr[i] = regs-&gt;u_regs[i + 8];<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TARGET_PPC)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</P>
<P>#if defined(TARGET_PPC64)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int flag = (env-&gt;insns_flags2 &amp; PPC2_BOOKE206) ? MSR_CM : MSR_SF;<BR>#if defined(TARGET_ABI32)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;msr &amp;= ~((target_ulong)1 &lt;&lt; flag);<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;msr |= (target_ulong)1 &lt;&lt; flag;<BR>#endif<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;nip = regs-&gt;nip;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; 32; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;gpr[i] = regs-&gt;gpr[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TARGET_M68K)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pc = regs-&gt;pc;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;dregs[0] = regs-&gt;d0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;dregs[1] = regs-&gt;d1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;dregs[2] = regs-&gt;d2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;dregs[3] = regs-&gt;d3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;dregs[4] = regs-&gt;d4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;dregs[5] = regs-&gt;d5;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;dregs[6] = regs-&gt;d6;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;dregs[7] = regs-&gt;d7;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;aregs[0] = regs-&gt;a0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;aregs[1] = regs-&gt;a1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;aregs[2] = regs-&gt;a2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;aregs[3] = regs-&gt;a3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;aregs[4] = regs-&gt;a4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;aregs[5] = regs-&gt;a5;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;aregs[6] = regs-&gt;a6;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;aregs[7] = regs-&gt;usp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;sr = regs-&gt;sr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ts-&gt;sim_syscalls = 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TARGET_MICROBLAZE)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[0] = regs-&gt;r0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[1] = regs-&gt;r1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[2] = regs-&gt;r2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[3] = regs-&gt;r3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[4] = regs-&gt;r4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[5] = regs-&gt;r5;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[6] = regs-&gt;r6;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[7] = regs-&gt;r7;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[8] = regs-&gt;r8;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[9] = regs-&gt;r9;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[10] = regs-&gt;r10;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[11] = regs-&gt;r11;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[12] = regs-&gt;r12;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = regs-&gt;r13;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[14] = regs-&gt;r14;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[15] = regs-&gt;r15;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[16] = regs-&gt;r16;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[17] = regs-&gt;r17;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[18] = regs-&gt;r18;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[19] = regs-&gt;r19;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[20] = regs-&gt;r20;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[21] = regs-&gt;r21;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[22] = regs-&gt;r22;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[23] = regs-&gt;r23;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[24] = regs-&gt;r24;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[25] = regs-&gt;r25;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[26] = regs-&gt;r26;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[27] = regs-&gt;r27;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[28] = regs-&gt;r28;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[29] = regs-&gt;r29;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[30] = regs-&gt;r30;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[31] = regs-&gt;r31;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;sregs[SR_PC] = regs-&gt;pc;<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TARGET_MIPS)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; 32; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;active_tc.gpr[i] = regs-&gt;regs[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;active_tc.PC = regs-&gt;cp0_epc &amp; ~(target_ulong)1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (regs-&gt;cp0_epc &amp; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;hflags |= MIPS_HFLAG_M16;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (((info-&gt;elf_flags &amp; EF_MIPS_NAN2008) != 0) !=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((env-&gt;active_fpu.fcr31 &amp; (1 &lt;&lt; FCR31_NAN2008)) != 0)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((env-&gt;active_fpu.fcr31_rw_bitmask &amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; FCR31_NAN2008)) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "ELF binary's NaN mode not supported by CPU\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((info-&gt;elf_flags &amp; EF_MIPS_NAN2008) != 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;active_fpu.fcr31 |= (1 &lt;&lt; FCR31_NAN2008);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;active_fpu.fcr31 &amp;= ~(1 &lt;&lt; FCR31_NAN2008);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; restore_snan_bit_mode(env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TARGET_OPENRISC)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 32; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;gpr[i] = regs-&gt;gpr[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;sr = regs-&gt;sr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pc = regs-&gt;pc;<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TARGET_SH4)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; 16; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;gregs[i] = regs-&gt;regs[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pc = regs-&gt;pc;<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TARGET_ALPHA)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; 28; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;ir[i] = ((abi_ulong *)regs)[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;ir[IR_SP] = regs-&gt;usp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pc = regs-&gt;pc;<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TARGET_CRIS)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[0] = regs-&gt;r0;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[1] = regs-&gt;r1;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[2] = regs-&gt;r2;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[3] = regs-&gt;r3;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[4] = regs-&gt;r4;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[5] = regs-&gt;r5;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[6] = regs-&gt;r6;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[7] = regs-&gt;r7;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[8] = regs-&gt;r8;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[9] = regs-&gt;r9;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[10] = regs-&gt;r10;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[11] = regs-&gt;r11;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[12] = regs-&gt;r12;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = regs-&gt;r13;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[14] = info-&gt;start_stack;<BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[15] = regs-&gt;acr;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pc = regs-&gt;erp;<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TARGET_S390X)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 16; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[i] = regs-&gt;gprs[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;psw.mask = regs-&gt;psw.mask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;psw.addr = regs-&gt;psw.addr;<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TARGET_TILEGX)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; TILEGX_R_COUNT; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[i] = regs-&gt;regs[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; TILEGX_SPR_COUNT; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;spregs[i] = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pc = regs-&gt;pc;<BR>&nbsp;&nbsp;&nbsp; }<BR>#else<BR>#error unsupported target CPU<BR>#endif</P>
<P>#if defined(TARGET_ARM) || defined(TARGET_M68K) || defined(TARGET_UNICORE32)<BR>&nbsp;&nbsp;&nbsp; ts-&gt;stack_base = info-&gt;start_stack;<BR>&nbsp;&nbsp;&nbsp; ts-&gt;heap_base = info-&gt;brk;<BR>&nbsp;&nbsp;&nbsp; /* This will be filled in on the first SYS_HEAPINFO call.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ts-&gt;heap_limit = 0;<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; if (gdbstub_port) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (gdbserver_start(gdbstub_port) &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "qemu: could not open gdbserver on port %d\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gdbstub_port);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(EXIT_FAILURE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gdb_handlesig(cpu, 0);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; cpu_loop(env);<BR>&nbsp;&nbsp;&nbsp; /* never exits */<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}