static void dacr_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1); /* Flush TLB as domain not tracked in TLB */<BR>}</P>
<P>static void fcse_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; if (raw_read(env, ri) != value) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Unlike real hardware the qemu TLB uses virtual addresses,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * not modified virtual addresses, so this causes a TLB flush.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void contextidr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; if (raw_read(env, ri) != value &amp;&amp; !arm_feature(env, ARM_FEATURE_MPU)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !extended_addresses_enabled(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* For VMSA (when not using the LPAE long descriptor page table<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * format) this register includes the ASID, so do a TLB flush.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * For PMSA it is purely a process ID and no action is needed.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>}</P>
<P>static void tlbiall_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate all (TLBIALL) */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>}</P>
<P>static void tlbimva_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate single TLB entry by MVA and ASID (TLBIMVA) */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; tlb_flush_page(CPU(cpu), value &amp; TARGET_PAGE_MASK);<BR>}</P>
<P>static void tlbiasid_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate by ASID (TLBIASID) */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), value == 0);<BR>}</P>
<P>static void tlbimvaa_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate single entry by MVA, all ASIDs (TLBIMVAA) */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; tlb_flush_page(CPU(cpu), value &amp; TARGET_PAGE_MASK);<BR>}</P>
<P>/* IS variants of TLB operations must affect all cores */<BR>static void tlbiall_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush(other_cs, 1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void tlbiasid_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush(other_cs, value == 0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void tlbimva_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page(other_cs, value &amp; TARGET_PAGE_MASK);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void tlbimvaa_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page(other_cs, value &amp; TARGET_PAGE_MASK);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void tlbiall_nsnh_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = ENV_GET_CPU(env);</P>
<P>&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(cs, ARMMMUIdx_S12NSE1, ARMMMUIdx_S12NSE0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S2NS, -1);<BR>}</P>
<P>static void tlbiall_nsnh_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(other_cs, ARMMMUIdx_S12NSE1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S12NSE0, ARMMMUIdx_S2NS, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void tlbiipas2_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate by IPA. This has to invalidate any structures that<BR>&nbsp;&nbsp;&nbsp;&nbsp; * contain only stage 2 translation information, but does not need<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to apply to structures that contain combined stage 1 and stage 2<BR>&nbsp;&nbsp;&nbsp;&nbsp; * translation information.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This must NOP if EL2 isn't implemented or SCR_EL3.NS is zero.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = ENV_GET_CPU(env);<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr;</P>
<P>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_EL2) || !(env-&gt;cp15.scr_el3 &amp; SCR_NS)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; pageaddr = sextract64(value &lt;&lt; 12, 0, 40);</P>
<P>&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(cs, pageaddr, ARMMMUIdx_S2NS, -1);<BR>}</P>
<P>static void tlbiipas2_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr;</P>
<P>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_EL2) || !(env-&gt;cp15.scr_el3 &amp; SCR_NS)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; pageaddr = sextract64(value &lt;&lt; 12, 0, 40);</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(other_cs, pageaddr, ARMMMUIdx_S2NS, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void tlbiall_hyp_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = ENV_GET_CPU(env);</P>
<P>&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(cs, ARMMMUIdx_S1E2, -1);<BR>}</P>
<P>static void tlbiall_hyp_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(other_cs, ARMMMUIdx_S1E2, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void tlbimva_hyp_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = ENV_GET_CPU(env);<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr = value &amp; ~MAKE_64BIT_MASK(0, 12);</P>
<P>&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(cs, pageaddr, ARMMMUIdx_S1E2, -1);<BR>}</P>
<P>static void tlbimva_hyp_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr = value &amp; ~MAKE_64BIT_MASK(0, 12);</P>
<P>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(other_cs, pageaddr, ARMMMUIdx_S1E2, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}