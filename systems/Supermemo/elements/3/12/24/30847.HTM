void hw_watchpoint_update(ARMCPU *cpu, int n)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; vaddr len = 0;<BR>&nbsp;&nbsp;&nbsp; vaddr wvr = env-&gt;cp15.dbgwvr[n];<BR>&nbsp;&nbsp;&nbsp; uint64_t wcr = env-&gt;cp15.dbgwcr[n];<BR>&nbsp;&nbsp;&nbsp; int mask;<BR>&nbsp;&nbsp;&nbsp; int flags = BP_CPU | BP_STOP_BEFORE_ACCESS;</P>
<P>&nbsp;&nbsp;&nbsp; if (env-&gt;cpu_watchpoint[n]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_watchpoint_remove_by_ref(CPU(cpu), env-&gt;cpu_watchpoint[n]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cpu_watchpoint[n] = NULL;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (!extract64(wcr, 0, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* E bit clear : watchpoint disabled */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch (extract64(wcr, 3, 2)) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* LSC 00 is reserved and must behave as if the wp is disabled */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags |= BP_MEM_READ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags |= BP_MEM_WRITE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags |= BP_MEM_ACCESS;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Attempts to use both MASK and BAS fields simultaneously are<BR>&nbsp;&nbsp;&nbsp;&nbsp; * CONSTRAINED UNPREDICTABLE; we opt to ignore BAS in this case,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * thus generating a watchpoint for every byte in the masked region.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; mask = extract64(wcr, 24, 4);<BR>&nbsp;&nbsp;&nbsp; if (mask == 1 || mask == 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Reserved values of MASK; we must act as if the mask value was<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * some non-reserved value, or as if the watchpoint were disabled.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * We choose the latter.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; } else if (mask) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Watchpoint covers an aligned area up to 2GB in size */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = 1ULL &lt;&lt; mask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If masked bits in WVR are not zero it's CONSTRAINED UNPREDICTABLE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * whether the watchpoint fires when the unmasked bits match; we opt<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * to generate the exceptions.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wvr &amp;= ~(len - 1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Watchpoint covers bytes defined by the byte address select bits */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bas = extract64(wcr, 5, 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int basstart;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bas == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* This must act as if the watchpoint is disabled */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extract64(wvr, 2, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Deprecated case of an only 4-aligned address. BAS[7:4] are<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * ignored, and BAS[3:0] define which bytes to watch.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bas &amp;= 0xf;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The BAS bits are supposed to be programmed to indicate a contiguous<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * range of bytes. Otherwise it is CONSTRAINED UNPREDICTABLE whether<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * we fire for each byte in the word/doubleword addressed by the WVR.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * We choose to ignore any non-zero bits after the first range of 1s.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; basstart = ctz32(bas);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = cto32(bas &gt;&gt; basstart);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wvr += basstart;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cpu_watchpoint_insert(CPU(cpu), wvr, len, flags,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;env-&gt;cpu_watchpoint[n]);<BR>}</P>
<P>void hw_watchpoint_update_all(ARMCPU *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; /* Completely clear out existing QEMU watchpoints and our array, to<BR>&nbsp;&nbsp;&nbsp;&nbsp; * avoid possible stale entries following migration load.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; cpu_watchpoint_remove_all(CPU(cpu), BP_CPU);<BR>&nbsp;&nbsp;&nbsp; memset(env-&gt;cpu_watchpoint, 0, sizeof(env-&gt;cpu_watchpoint));</P>
<P>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; ARRAY_SIZE(cpu-&gt;env.cpu_watchpoint); i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hw_watchpoint_update(cpu, i);<BR>&nbsp;&nbsp;&nbsp; }<BR>}