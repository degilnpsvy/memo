static const ARMCPRegInfo debug_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* DBGDRAR, DBGDSAR: always RAZ since we don't implement memory mapped<BR>&nbsp;&nbsp;&nbsp;&nbsp; * debug components. The AArch64 version of DBGDRAR is named MDRAR_EL1;<BR>&nbsp;&nbsp;&nbsp;&nbsp; * unlike DBGDRAR it is never accessible from EL0.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * DBGDSAR is deprecated and must RAZ from v8 anyway, so it has no AArch64<BR>&nbsp;&nbsp;&nbsp;&nbsp; * accessor.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "DBGDRAR", .cp = 14, .crn = 1, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .accessfn = access_tdra,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "MDRAR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 2, .opc1 = 0, .crn = 1, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .accessfn = access_tdra,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "DBGDSAR", .cp = 14, .crn = 2, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .accessfn = access_tdra,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* Monitor debug system control register; the 32-bit alias is DBGDSCRext. */<BR>&nbsp;&nbsp;&nbsp; { .name = "MDSCR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tda,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.mdscr_el1),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* MDCCSR_EL0, aka DBGDSCRint. This is a read-only mirror of MDSCR_EL1.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * We don't implement the configurable EL0 access.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "MDCCSR_EL0", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .accessfn = access_tda,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.mdscr_el1), },<BR>&nbsp;&nbsp;&nbsp; { .name = "OSLAR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 1, .crm = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = access_tdosa,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = oslar_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "OSLSR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 1, .crm = 1, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .resetvalue = 10,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = access_tdosa,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.oslsr_el1) },<BR>&nbsp;&nbsp;&nbsp; /* Dummy OSDLR_EL1: 32-bit Linux will read this */<BR>&nbsp;&nbsp;&nbsp; { .name = "OSDLR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 1, .crm = 3, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tdosa,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; /* Dummy DBGVCR: Linux wants to clear this on startup, but we don't<BR>&nbsp;&nbsp;&nbsp;&nbsp; * implement vector catch debug events yet.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "DBGVCR",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tda,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};