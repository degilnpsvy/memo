static CPAccessResult ctr_el0_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Only accessible in EL0 if SCTLR.UCT is set (and only in AArch64,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * but the AArch32 CTR has its own reginfo struct)<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == 0 &amp;&amp; !(env-&gt;cp15.sctlr_el[1] &amp; SCTLR_UCT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</P>
<P>static void oslar_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Writes to OSLAR_EL1 may update the OS lock status, which can be<BR>&nbsp;&nbsp;&nbsp;&nbsp; * read via a bit in OSLSR_EL1.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int oslock;</P>
<P>&nbsp;&nbsp;&nbsp; if (ri-&gt;state == ARM_CP_STATE_AA32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oslock = (value == 0xC5ACCE55);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oslock = value &amp; 1;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; env-&gt;cp15.oslsr_el1 = deposit32(env-&gt;cp15.oslsr_el1, 1, 1, oslock);<BR>}