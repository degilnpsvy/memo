# cpu-exec.c 
<P></P>
<P>/*<BR>&nbsp;*&nbsp; emulator main execution loop<BR>&nbsp;*<BR>&nbsp;*&nbsp; Copyright (c) 2003-2005 Fabrice Bellard<BR>&nbsp;*<BR>&nbsp;* This library is free software; you can redistribute it and/or<BR>&nbsp;* modify it under the terms of the GNU Lesser General Public<BR>&nbsp;* License as published by the Free Software Foundation; either<BR>&nbsp;* version 2 of the License, or (at your option) any later version.<BR>&nbsp;*<BR>&nbsp;* This library is distributed in the hope that it will be useful,<BR>&nbsp;* but WITHOUT ANY WARRANTY; without even the implied warranty of<BR>&nbsp;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp; See the GNU<BR>&nbsp;* Lesser General Public License for more details.<BR>&nbsp;*<BR>&nbsp;* You should have received a copy of the GNU Lesser General Public<BR>&nbsp;* License along with this library; if not, see &lt;<A href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.<BR>&nbsp;*/<BR>#include "qemu/osdep.h"<BR>#include "cpu.h"<BR>#include "trace.h"<BR>#include "disas/disas.h"<BR>#include "exec/exec-all.h"<BR>#include "tcg.h"<BR>#include "qemu/atomic.h"<BR>#include "sysemu/qtest.h"<BR>#include "qemu/timer.h"<BR>#include "exec/address-spaces.h"<BR>#include "qemu/rcu.h"<BR>#include "exec/tb-hash.h"<BR>#include "exec/log.h"<BR>#if defined(TARGET_I386) &amp;&amp; !defined(CONFIG_USER_ONLY)<BR>#include "hw/i386/apic.h"<BR>#endif<BR>#include "sysemu/replay.h"</P>
<P></P>
<P>/* -icount align implementation. */</P>
<P>typedef struct SyncClocks {<BR>&nbsp;&nbsp;&nbsp; int64_t diff_clk;<BR>&nbsp;&nbsp;&nbsp; int64_t last_cpu_icount;<BR>&nbsp;&nbsp;&nbsp; int64_t realtime_clock;<BR>} SyncClocks;</P>
<P>#if !defined(CONFIG_USER_ONLY)<BR>/* Allow the guest to have a max 3ms advance.<BR>&nbsp;* The difference between the 2 clocks could therefore<BR>&nbsp;* oscillate around 0.<BR>&nbsp;*/<BR>#define VM_CLOCK_ADVANCE 3000000<BR>#define THRESHOLD_REDUCE 1.5<BR>#define MAX_DELAY_PRINT_RATE 2000000000LL<BR>#define MAX_NB_PRINTS 100</P>
<P>static void align_clocks(SyncClocks *sc, const CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; int64_t cpu_icount;</P>
<P>&nbsp;&nbsp;&nbsp; if (!icount_align_option) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cpu_icount = cpu-&gt;icount_extra + cpu-&gt;icount_decr.u16.low;<BR>&nbsp;&nbsp;&nbsp; sc-&gt;diff_clk += cpu_icount_to_ns(sc-&gt;last_cpu_icount - cpu_icount);<BR>&nbsp;&nbsp;&nbsp; sc-&gt;last_cpu_icount = cpu_icount;</P>
<P>&nbsp;&nbsp;&nbsp; if (sc-&gt;diff_clk &gt; VM_CLOCK_ADVANCE) {<BR>#ifndef _WIN32<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct timespec sleep_delay, rem_delay;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sleep_delay.tv_sec = sc-&gt;diff_clk / 1000000000LL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sleep_delay.tv_nsec = sc-&gt;diff_clk % 1000000000LL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nanosleep(&amp;sleep_delay, &amp;rem_delay) &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sc-&gt;diff_clk = rem_delay.tv_sec * 1000000000LL + rem_delay.tv_nsec;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sc-&gt;diff_clk = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sleep(sc-&gt;diff_clk / SCALE_MS);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sc-&gt;diff_clk = 0;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void print_delay(const SyncClocks *sc)<BR>{<BR>&nbsp;&nbsp;&nbsp; static float threshold_delay;<BR>&nbsp;&nbsp;&nbsp; static int64_t last_realtime_clock;<BR>&nbsp;&nbsp;&nbsp; static int nb_prints;</P>
<P>&nbsp;&nbsp;&nbsp; if (icount_align_option &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sc-&gt;realtime_clock - last_realtime_clock &gt;= MAX_DELAY_PRINT_RATE &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nb_prints &lt; MAX_NB_PRINTS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((-sc-&gt;diff_clk / (float)1000000000LL &gt; threshold_delay) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (-sc-&gt;diff_clk / (float)1000000000LL &lt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (threshold_delay - THRESHOLD_REDUCE))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; threshold_delay = (-sc-&gt;diff_clk / 1000000000LL) + 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Warning: The guest is now late by %.1f to %.1f seconds\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; threshold_delay - 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; threshold_delay);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nb_prints++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last_realtime_clock = sc-&gt;realtime_clock;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void init_delay_params(SyncClocks *sc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (!icount_align_option) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; sc-&gt;realtime_clock = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_RT);<BR>&nbsp;&nbsp;&nbsp; sc-&gt;diff_clk = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) - sc-&gt;realtime_clock;<BR>&nbsp;&nbsp;&nbsp; sc-&gt;last_cpu_icount = cpu-&gt;icount_extra + cpu-&gt;icount_decr.u16.low;<BR>&nbsp;&nbsp;&nbsp; if (sc-&gt;diff_clk &lt; max_delay) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_delay = sc-&gt;diff_clk;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (sc-&gt;diff_clk &gt; max_advance) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_advance = sc-&gt;diff_clk;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Print every 2s max if the guest is late. We limit the number<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of printed messages to NB_PRINT_MAX(currently 100) */<BR>&nbsp;&nbsp;&nbsp; print_delay(sc);<BR>}<BR>#else<BR>static void align_clocks(SyncClocks *sc, const CPUState *cpu)<BR>{<BR>}</P>
<P>static void init_delay_params(SyncClocks *sc, const CPUState *cpu)<BR>{<BR>}<BR>#endif /* CONFIG USER ONLY */</P>
<P><FONT class=extract>/* Execute a TB, and fix up the CPU state afterwards if necessary */<BR>static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUArchState *env = cpu-&gt;env_ptr;<BR>&nbsp;&nbsp;&nbsp; uintptr_t ret;<BR>&nbsp;&nbsp;&nbsp; TranslationBlock *last_tb;<BR>&nbsp;&nbsp;&nbsp; int tb_exit;<BR>&nbsp;&nbsp;&nbsp; uint8_t *tb_ptr = itb-&gt;tc_ptr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; qemu_log_mask_and_addr(CPU_LOG_EXEC, itb-&gt;pc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Trace %p [" TARGET_FMT_lx "] %s\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itb-&gt;tc_ptr, itb-&gt;pc, lookup_symbol(itb-&gt;pc));</FONT></P>
<P><FONT class=extract>#if defined(DEBUG_DISAS)<BR>&nbsp;&nbsp;&nbsp; if (qemu_loglevel_mask(CPU_LOG_TB_CPU)) {<BR>#if defined(TARGET_I386)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log_cpu_state(cpu, CPU_DUMP_CCOP);<BR>#elif defined(TARGET_M68K)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ??? Should not modify env state for dumping.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_m68k_flush_flags(env, env-&gt;cc_op);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cc_op = CC_OP_FLAGS;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;sr = (env-&gt;sr &amp; 0xffe0) | env-&gt;cc_dest | (env-&gt;cc_x &lt;&lt; 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log_cpu_state(cpu, 0);<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log_cpu_state(cpu, 0);<BR>#endif<BR>&nbsp;&nbsp;&nbsp; }<BR>#endif /* DEBUG_DISAS */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; cpu-&gt;can_do_io = !use_icount;<BR>&nbsp;&nbsp;&nbsp; ret = tcg_qemu_tb_exec(env, tb_ptr);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;can_do_io = 1;<BR>&nbsp;&nbsp;&nbsp; last_tb = (TranslationBlock *)(ret &amp; ~TB_EXIT_MASK);<BR>&nbsp;&nbsp;&nbsp; tb_exit = ret &amp; TB_EXIT_MASK;<BR>&nbsp;&nbsp;&nbsp; trace_exec_tb_exit(last_tb, tb_exit);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (tb_exit &gt; TB_EXIT_IDX1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We didn't start executing this TB (eg because the instruction<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * counter hit zero); we must restore the guest PC to the address<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * of the start of the TB.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUClass *cc = CPU_GET_CLASS(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask_and_addr(CPU_LOG_EXEC, last_tb-&gt;pc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Stopped execution of TB chain before %p ["<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TARGET_FMT_lx "] %s\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last_tb-&gt;tc_ptr, last_tb-&gt;pc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lookup_symbol(last_tb-&gt;pc));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cc-&gt;synchronize_from_tb) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc-&gt;synchronize_from_tb(cpu, last_tb);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(cc-&gt;set_pc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc-&gt;set_pc(cpu, last_tb-&gt;pc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (tb_exit == TB_EXIT_REQUESTED) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We were asked to stop executing TBs (probably a pending<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * interrupt. We've now stopped, so clear the flag.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;tcg_exit_req = 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return ret;<BR>}</FONT></P>
<P><FONT class=extract>#ifndef CONFIG_USER_ONLY<BR>/* Execute the code without caching the generated code. An interpreter<BR>&nbsp;&nbsp; could be used if available. */<BR>static void cpu_exec_nocache(CPUState *cpu, int max_cycles,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslationBlock *orig_tb, bool ignore_icount)<BR>{<BR>&nbsp;&nbsp;&nbsp; TranslationBlock *tb;<BR>&nbsp;&nbsp;&nbsp; bool old_tb_flushed;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Should never happen.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We only end up here when an existing TB is too long.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (max_cycles &gt; CF_COUNT_MASK)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_cycles = CF_COUNT_MASK;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; old_tb_flushed = cpu-&gt;tb_flushed;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;tb_flushed = false;<BR>&nbsp;&nbsp;&nbsp; tb = tb_gen_code(cpu, orig_tb-&gt;pc, orig_tb-&gt;cs_base, orig_tb-&gt;flags,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_cycles | CF_NOCACHE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (ignore_icount ? CF_IGNORE_ICOUNT : 0));<BR>&nbsp;&nbsp;&nbsp; tb-&gt;orig_tb = cpu-&gt;tb_flushed ? NULL : orig_tb;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;tb_flushed |= old_tb_flushed;<BR>&nbsp;&nbsp;&nbsp; /* execute the generated code */<BR>&nbsp;&nbsp;&nbsp; trace_exec_tb_nocache(tb, tb-&gt;pc);<BR>&nbsp;&nbsp;&nbsp; cpu_tb_exec(cpu, tb);<BR>&nbsp;&nbsp;&nbsp; tb_phys_invalidate(tb, -1);<BR>&nbsp;&nbsp;&nbsp; tb_free(tb);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>struct tb_desc {<BR>&nbsp;&nbsp;&nbsp; target_ulong pc;<BR>&nbsp;&nbsp;&nbsp; target_ulong cs_base;<BR>&nbsp;&nbsp;&nbsp; CPUArchState *env;<BR>&nbsp;&nbsp;&nbsp; tb_page_addr_t phys_page1;<BR>&nbsp;&nbsp;&nbsp; uint32_t flags;<BR>};</FONT></P>
<P><FONT class=extract>static bool tb_cmp(const void *p, const void *d)<BR>{<BR>&nbsp;&nbsp;&nbsp; const TranslationBlock *tb = p;<BR>&nbsp;&nbsp;&nbsp; const struct tb_desc *desc = d;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (tb-&gt;pc == desc-&gt;pc &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb-&gt;page_addr[0] == desc-&gt;phys_page1 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb-&gt;cs_base == desc-&gt;cs_base &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb-&gt;flags == desc-&gt;flags) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* check next page if needed */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tb-&gt;page_addr[1] == -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb_page_addr_t phys_page2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong virt_page2;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virt_page2 = (desc-&gt;pc &amp; TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_page2 = get_page_addr_code(desc-&gt;env, virt_page2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tb-&gt;page_addr[1] == phys_page2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return false;<BR>}</FONT></P>
<P><FONT class=extract>static TranslationBlock *tb_find_physical(CPUState *cpu,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong pc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong cs_base,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t flags)<BR>{<BR>&nbsp;&nbsp;&nbsp; tb_page_addr_t phys_pc;<BR>&nbsp;&nbsp;&nbsp; struct tb_desc desc;<BR>&nbsp;&nbsp;&nbsp; uint32_t h;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; desc.env = (CPUArchState *)cpu-&gt;env_ptr;<BR>&nbsp;&nbsp;&nbsp; desc.cs_base = cs_base;<BR>&nbsp;&nbsp;&nbsp; desc.flags = flags;<BR>&nbsp;&nbsp;&nbsp; desc.pc = pc;<BR>&nbsp;&nbsp;&nbsp; phys_pc = get_page_addr_code(desc.env, pc);<BR>&nbsp;&nbsp;&nbsp; desc.phys_page1 = phys_pc &amp; TARGET_PAGE_MASK;<BR>&nbsp;&nbsp;&nbsp; h = tb_hash_func(phys_pc, pc, flags);<BR>&nbsp;&nbsp;&nbsp; return qht_lookup(&amp;tcg_ctx.tb_ctx.htable, tb_cmp, &amp;desc, h);<BR>}</FONT></P>
<P><FONT class=extract>static TranslationBlock *tb_find_slow(CPUState *cpu,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong pc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong cs_base,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t flags)<BR>{<BR>&nbsp;&nbsp;&nbsp; TranslationBlock *tb;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tb = tb_find_physical(cpu, pc, cs_base, flags);<BR>&nbsp;&nbsp;&nbsp; if (tb) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto found;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; /* mmap_lock is needed by tb_gen_code, and mmap_lock must be<BR>&nbsp;&nbsp;&nbsp;&nbsp; * taken outside tb_lock.&nbsp; Since we're momentarily dropping<BR>&nbsp;&nbsp;&nbsp;&nbsp; * tb_lock, there's a chance that our desired tb has been<BR>&nbsp;&nbsp;&nbsp;&nbsp; * translated.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tb_unlock();<BR>&nbsp;&nbsp;&nbsp; mmap_lock();<BR>&nbsp;&nbsp;&nbsp; tb_lock();<BR>&nbsp;&nbsp;&nbsp; tb = tb_find_physical(cpu, pc, cs_base, flags);<BR>&nbsp;&nbsp;&nbsp; if (tb) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmap_unlock();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto found;<BR>&nbsp;&nbsp;&nbsp; }<BR>#endif</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* if no translated code available, then translate it now */<BR>&nbsp;&nbsp;&nbsp; tb = tb_gen_code(cpu, pc, cs_base, flags, 0);</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; mmap_unlock();<BR>#endif</FONT></P>
<P><FONT class=extract>found:<BR>&nbsp;&nbsp;&nbsp; /* we add the TB in the virtual pc hash table */<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;tb_jmp_cache[tb_jmp_cache_hash_func(pc)] = tb;<BR>&nbsp;&nbsp;&nbsp; return tb;<BR>}</FONT></P>
<P><FONT class=extract>static inline TranslationBlock *tb_find_fast(CPUState *cpu,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslationBlock **last_tb,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tb_exit)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUArchState *env = (CPUArchState *)cpu-&gt;env_ptr;<BR>&nbsp;&nbsp;&nbsp; TranslationBlock *tb;<BR>&nbsp;&nbsp;&nbsp; target_ulong cs_base, pc;<BR>&nbsp;&nbsp;&nbsp; uint32_t flags;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* we record a subset of the CPU state. It will<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; always be the same before a given translated block<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is executed. */<BR>&nbsp;&nbsp;&nbsp; cpu_get_tb_cpu_state(env, &amp;pc, &amp;cs_base, &amp;flags);<BR>&nbsp;&nbsp;&nbsp; tb_lock();<BR>&nbsp;&nbsp;&nbsp; tb = cpu-&gt;tb_jmp_cache[tb_jmp_cache_hash_func(pc)];<BR>&nbsp;&nbsp;&nbsp; if (unlikely(!tb || tb-&gt;pc != pc || tb-&gt;cs_base != cs_base ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb-&gt;flags != flags)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb = tb_find_slow(cpu, pc, cs_base, flags);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (cpu-&gt;tb_flushed) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Ensure that no TB jump will be modified as the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * translation buffer has been flushed.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *last_tb = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;tb_flushed = false;<BR>&nbsp;&nbsp;&nbsp; }<BR>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; /* We don't take care of direct jumps when address mapping changes in<BR>&nbsp;&nbsp;&nbsp;&nbsp; * system emulation. So it's not safe to make a direct jump to a TB<BR>&nbsp;&nbsp;&nbsp;&nbsp; * spanning two pages because the mapping for the second page can change.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (tb-&gt;page_addr[1] != -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *last_tb = NULL;<BR>&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp; /* See if we can patch the calling TB. */<BR>&nbsp;&nbsp;&nbsp; if (*last_tb &amp;&amp; !qemu_loglevel_mask(CPU_LOG_TB_NOCHAIN)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb_add_jump(*last_tb, tb_exit, tb);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tb_unlock();<BR>&nbsp;&nbsp;&nbsp; return tb;<BR>}</FONT></P>
<P>static inline bool cpu_handle_halt(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (cpu-&gt;halted) {<BR>#if defined(TARGET_I386) &amp;&amp; !defined(CONFIG_USER_ONLY)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((cpu-&gt;interrupt_request &amp; CPU_INTERRUPT_POLL)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; replay_interrupt()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86CPU *x86_cpu = X86_CPU(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; apic_poll_irq(x86_cpu-&gt;apic_state);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_reset_interrupt(cpu, CPU_INTERRUPT_POLL);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!cpu_has_work(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current_cpu = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;halted = 0;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return false;<BR>}</P>
<P>static inline void cpu_handle_debug_exception(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUClass *cc = CPU_GET_CLASS(cpu);<BR>&nbsp;&nbsp;&nbsp; CPUWatchpoint *wp;</P>
<P>&nbsp;&nbsp;&nbsp; if (!cpu-&gt;watchpoint_hit) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QTAILQ_FOREACH(wp, &amp;cpu-&gt;watchpoints, entry) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wp-&gt;flags &amp;= ~BP_WATCHPOINT_HIT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cc-&gt;debug_excp_handler(cpu);<BR>}</P>
<P>static inline bool cpu_handle_exception(CPUState *cpu, int *ret)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (cpu-&gt;exception_index &gt;= 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cpu-&gt;exception_index &gt;= EXCP_INTERRUPT) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* exit request from the cpu execution loop */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ret = cpu-&gt;exception_index;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*ret == EXCP_DEBUG) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_handle_debug_exception(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;exception_index = -1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>#if defined(CONFIG_USER_ONLY)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* if user mode only, we simulate a fake exception<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; which will be handled outside the cpu execution<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop */<BR>#if defined(TARGET_I386)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUClass *cc = CPU_GET_CLASS(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc-&gt;do_interrupt(cpu);<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ret = cpu-&gt;exception_index;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;exception_index = -1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (replay_exception()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUClass *cc = CPU_GET_CLASS(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc-&gt;do_interrupt(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;exception_index = -1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (!replay_has_interrupt()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* give a chance to iothread in replay mode */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ret = EXCP_INTERRUPT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; } else if (replay_has_exception()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; cpu-&gt;icount_decr.u16.low + cpu-&gt;icount_extra == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* try to cause an exception pending in the log */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslationBlock *last_tb = NULL; /* Avoid chaining TBs */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_exec_nocache(cpu, 1, tb_find_fast(cpu, &amp;last_tb, 0), true);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *ret = -1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return false;<BR>}</P>
<P>static inline void cpu_handle_interrupt(CPUState *cpu,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslationBlock **last_tb)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUClass *cc = CPU_GET_CLASS(cpu);<BR>&nbsp;&nbsp;&nbsp; int interrupt_request = cpu-&gt;interrupt_request;</P>
<P>&nbsp;&nbsp;&nbsp; if (unlikely(interrupt_request)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (unlikely(cpu-&gt;singlestep_enabled &amp; SSTEP_NOIRQ)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Mask out external interrupts for this step. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interrupt_request &amp;= ~CPU_INTERRUPT_SSTEP_MASK;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (interrupt_request &amp; CPU_INTERRUPT_DEBUG) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;interrupt_request &amp;= ~CPU_INTERRUPT_DEBUG;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;exception_index = EXCP_DEBUG;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_loop_exit(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (replay_mode == REPLAY_MODE_PLAY &amp;&amp; !replay_has_interrupt()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Do nothing */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (interrupt_request &amp; CPU_INTERRUPT_HALT) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replay_interrupt();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;interrupt_request &amp;= ~CPU_INTERRUPT_HALT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;halted = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;exception_index = EXCP_HLT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_loop_exit(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#if defined(TARGET_I386)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (interrupt_request &amp; CPU_INTERRUPT_INIT) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X86CPU *x86_cpu = X86_CPU(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUArchState *env = &amp;x86_cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replay_interrupt();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_svm_check_intercept_param(env, SVM_EXIT_INIT, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do_cpu_init(x86_cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;exception_index = EXCP_HALTED;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_loop_exit(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (interrupt_request &amp; CPU_INTERRUPT_RESET) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replay_interrupt();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_reset(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_loop_exit(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The target hook has 3 exit conditions:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; False when the interrupt isn't processed,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; True when it is, and we should restart on a new TB,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and via longjmp via cpu_loop_exit.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; replay_interrupt();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cc-&gt;cpu_exec_interrupt(cpu, interrupt_request)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *last_tb = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The target hook may have updated the 'cpu-&gt;interrupt_request';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * reload the 'interrupt_request' value */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interrupt_request = cpu-&gt;interrupt_request;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (interrupt_request &amp; CPU_INTERRUPT_EXITTB) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;interrupt_request &amp;= ~CPU_INTERRUPT_EXITTB;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ensure that no TB jump will be modified as<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the program flow was changed */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *last_tb = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (unlikely(cpu-&gt;exit_request || replay_has_interrupt())) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;exit_request = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;exception_index = EXCP_INTERRUPT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_loop_exit(cpu);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslationBlock **last_tb, int *tb_exit,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SyncClocks *sc)<BR>{<BR>&nbsp;&nbsp;&nbsp; uintptr_t ret;</P>
<P>&nbsp;&nbsp;&nbsp; if (unlikely(cpu-&gt;exit_request)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; trace_exec_tb(tb, tb-&gt;pc);<BR>&nbsp;&nbsp;&nbsp; ret = cpu_tb_exec(cpu, tb);<BR>&nbsp;&nbsp;&nbsp; *last_tb = (TranslationBlock *)(ret &amp; ~TB_EXIT_MASK);<BR>&nbsp;&nbsp;&nbsp; *tb_exit = ret &amp; TB_EXIT_MASK;<BR>&nbsp;&nbsp;&nbsp; switch (*tb_exit) {<BR>&nbsp;&nbsp;&nbsp; case TB_EXIT_REQUESTED:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Something asked us to stop executing<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * chained TBs; just continue round the main<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * loop. Whatever requested the exit will also<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * have set something else (eg exit_request or<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * interrupt_request) which we will handle<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * next time around the loop.&nbsp; But we need to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * ensure the tcg_exit_req read in generated code<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * comes before the next read of cpu-&gt;exit_request<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * or cpu-&gt;interrupt_request.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; smp_rmb();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *last_tb = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case TB_EXIT_ICOUNT_EXPIRED:<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Instruction counter expired.&nbsp; */<BR>#ifdef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int insns_left = cpu-&gt;icount_decr.u32;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cpu-&gt;icount_extra &amp;&amp; insns_left &gt;= 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Refill decrementer and continue execution.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;icount_extra += insns_left;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insns_left = MIN(0xffff, cpu-&gt;icount_extra);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;icount_extra -= insns_left;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;icount_decr.u16.low = insns_left;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (insns_left &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Execute remaining instructions.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_exec_nocache(cpu, insns_left, *last_tb, false);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; align_clocks(sc, cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;exception_index = EXCP_INTERRUPT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *last_tb = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_loop_exit(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* main execution loop */</P>
<P>int cpu_exec(CPUState *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUClass *cc = CPU_GET_CLASS(cpu);<BR>&nbsp;&nbsp;&nbsp; int ret;<BR>&nbsp;&nbsp;&nbsp; SyncClocks sc;</P>
<P>&nbsp;&nbsp;&nbsp; /* replay_interrupt may need current_cpu */<BR>&nbsp;&nbsp;&nbsp; current_cpu = cpu;</P>
<P>&nbsp;&nbsp;&nbsp; if (cpu_handle_halt(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return EXCP_HALTED;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; atomic_mb_set(&amp;tcg_current_cpu, cpu);<BR>&nbsp;&nbsp;&nbsp; rcu_read_lock();</P>
<P>&nbsp;&nbsp;&nbsp; if (unlikely(atomic_mb_read(&amp;exit_request))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;exit_request = 1;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cc-&gt;cpu_exec_enter(cpu);</P>
<P>&nbsp;&nbsp;&nbsp; /* Calculate difference between guest clock and host clock.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This delay includes the delay of the last cycle, so<BR>&nbsp;&nbsp;&nbsp;&nbsp; * what we have to do is sleep until it is 0. As for the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * advance/delay we gain here, we try to fix it next time.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; init_delay_params(&amp;sc, cpu);</P>
<P>&nbsp;&nbsp;&nbsp; for(;;) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* prepare setjmp context for exception handling */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sigsetjmp(cpu-&gt;jmp_env, 0) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslationBlock *tb, *last_tb = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tb_exit = 0;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* if an exception is pending, we execute it here */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cpu_handle_exception(cpu, &amp;ret)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;tb_flushed = false; /* reset before first TB lookup */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_handle_interrupt(cpu, &amp;last_tb);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb = tb_find_fast(cpu, &amp;last_tb, tb_exit);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_loop_exec_tb(cpu, tb, &amp;last_tb, &amp;tb_exit, &amp;sc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Try to align the host and virtual clocks<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if the guest is in advance */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; align_clocks(&amp;sc, cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } /* for(;;) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Some compilers wrongly smash all local variables after<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * siglongjmp. There were bug reports for gcc 4.5.0 and clang.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Reload essential local variables here for those compilers.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Newer versions of gcc would complain about this code (-Wclobbered). */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu = current_cpu;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc = CPU_GET_CLASS(cpu);<BR>#else /* buggy compiler */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Assert that the compiler does not smash local variables. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert(cpu == current_cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert(cc == CPU_GET_CLASS(cpu));<BR>#endif /* buggy compiler */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;can_do_io = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb_lock_reset();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } /* for(;;) */</P>
<P>&nbsp;&nbsp;&nbsp; cc-&gt;cpu_exec_exit(cpu);<BR>&nbsp;&nbsp;&nbsp; rcu_read_unlock();</P>
<P>&nbsp;&nbsp;&nbsp; /* fail safe : never use current_cpu outside cpu_exec() */<BR>&nbsp;&nbsp;&nbsp; current_cpu = NULL;</P>
<P>&nbsp;&nbsp;&nbsp; /* Does not need atomic_mb_set because a spurious wakeup is okay.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; atomic_set(&amp;tcg_current_cpu, NULL);<BR>&nbsp;&nbsp;&nbsp; return ret;<BR>}