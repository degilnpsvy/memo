static inline TranslationBlock *tb_find_fast(CPUState *cpu,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslationBlock **last_tb,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tb_exit)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUArchState *env = (CPUArchState *)cpu-&gt;env_ptr;<BR>&nbsp;&nbsp;&nbsp; TranslationBlock *tb;<BR>&nbsp;&nbsp;&nbsp; target_ulong cs_base, pc;<BR>&nbsp;&nbsp;&nbsp; uint32_t flags;</P>
<P>&nbsp;&nbsp;&nbsp; /* we record a subset of the CPU state. It will<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; always be the same before a given translated block<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is executed. */<BR>&nbsp;&nbsp;&nbsp; cpu_get_tb_cpu_state(env, &amp;pc, &amp;cs_base, &amp;flags);<BR>&nbsp;&nbsp;&nbsp; tb_lock();<BR>&nbsp;&nbsp;&nbsp; tb = cpu-&gt;tb_jmp_cache[tb_jmp_cache_hash_func(pc)];<BR>&nbsp;&nbsp;&nbsp; if (unlikely(!tb || tb-&gt;pc != pc || tb-&gt;cs_base != cs_base ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb-&gt;flags != flags)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb = tb_find_slow(cpu, pc, cs_base, flags);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (cpu-&gt;tb_flushed) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Ensure that no TB jump will be modified as the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * translation buffer has been flushed.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *last_tb = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;tb_flushed = false;<BR>&nbsp;&nbsp;&nbsp; }<BR>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; /* We don't take care of direct jumps when address mapping changes in<BR>&nbsp;&nbsp;&nbsp;&nbsp; * system emulation. So it's not safe to make a direct jump to a TB<BR>&nbsp;&nbsp;&nbsp;&nbsp; * spanning two pages because the mapping for the second page can change.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (tb-&gt;page_addr[1] != -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *last_tb = NULL;<BR>&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp; /* See if we can patch the calling TB. */<BR>&nbsp;&nbsp;&nbsp; if (*last_tb &amp;&amp; !qemu_loglevel_mask(CPU_LOG_TB_NOCHAIN)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb_add_jump(*last_tb, tb_exit, tb);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tb_unlock();<BR>&nbsp;&nbsp;&nbsp; return tb;<BR>}