<DIV class=defun style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">&#8212; Built-in Function: void<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__builtin_prefetch</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>const void *addr, ...</VAR>)<VAR><A name=index-g_t_005f_005fbuiltin_005fprefetch-3631></A></VAR><BR>
<BLOCKQUOTE>
<P>This function is used to minimize cache-miss latency by moving data into a cache before it is accessed. You can insert calls to<CODE>__builtin_prefetch</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>into code for which you know addresses of data in memory that is likely to be accessed soon. If the target supports them, data prefetch instructions are generated. If the prefetch is done early enough before the access then the data will be in the cache by the time it is accessed.</P>
<P>The value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>addr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the address of the memory to prefetch. There are two optional arguments,<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>rw</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>locality</VAR>. The value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>rw</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a compile-time constant one or zero; one means that the prefetch is preparing for a write to the memory address and zero, the default, means that the prefetch is preparing for a read. The value<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>locality</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>must be a compile-time constant integer between zero and three. A value of zero means that the data has no temporal locality, so it need not be left in the cache after the access. A value of three means that the data has a high degree of temporal locality and should be left in all levels of cache possible. Values of one and two mean, respectively, a low or moderate degree of temporal locality. The default is three.</P><PRE class=smallexample style="FONT-SIZE: smaller">          for (i = 0; i &lt; n; i++)
            {
              a[i] = a[i] + b[i];
              __builtin_prefetch (&amp;a[i+j], 1, 1);
              __builtin_prefetch (&amp;b[i+j], 0, 1);
              /* <SPAN class=roman style="FONT-FAMILY: serif; FONT-WEIGHT: normal">...</SPAN> */
            }
</PRE>
<P>Data prefetch does not generate faults if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>addr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is invalid, but the address expression itself must be valid. For example, a prefetch of<CODE>p-&gt;next</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not fault if<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>p-&gt;next</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not a valid address, but evaluation faults if<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>p</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not a valid address.</P>
<P>If the target does not support data prefetch, the address expression is evaluated if it includes side effects but no other code is generated and GCC does not issue a warning.</P>
<P>&nbsp;</P>
<P>&nbsp;1#include &lt;stdio.h&gt;<BR>&nbsp;2const int a=1000;<BR>&nbsp;3const int b=512;<BR>&nbsp;4<BR>&nbsp;5int main()<BR>&nbsp;6{<BR>&nbsp;7&nbsp;&nbsp;&nbsp; int i,j;<BR>&nbsp;8&nbsp;&nbsp;&nbsp; int nums[a][b];<BR>&nbsp;9&nbsp;&nbsp;&nbsp; int l;<BR>10&nbsp;&nbsp;&nbsp; for (l=0;l&lt;1000;l++)<BR>11&nbsp;&nbsp;&nbsp; {<BR>12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j=0;j&lt;b;j++)<BR>13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* __builtin_prefetch(&amp;nums[0][j],1,1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0;i&lt;a;i++)<BR>16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* __builtin_prefetch(&amp;nums[i+1][j],1,1); */<BR>18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nums[i][j]=i+l;<BR>19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>21&nbsp;&nbsp;&nbsp; }<BR>22&nbsp;&nbsp;&nbsp; printf("%d\n",nums[a-1][b-1]);<BR>23}<BR>&#27880;&#37322;&#65306;real&nbsp;&nbsp;&nbsp; 0m5.642s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#21435;&#25481;&#27880;&#37322;&#65306;real&nbsp;&nbsp;&nbsp; 0m4.114s</P></BLOCKQUOTE></DIV>