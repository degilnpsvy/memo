A7.1 Format of instruction descriptions 
<P></P>
<P><FONT class=extract>The instruction descriptions in the alphabetical lists of instructions in Alphabetical list of ARMv7-M Thumb instructions on page A7-216 normally use the following format:<BR>&#8226; instruction section title<BR>&#8226; introduction to the instruction<BR>&#8226; instruction encoding(s) with architecture information<BR>&#8226; assembler syntax<BR>&#8226; pseudocode describing how the instruction operates<BR>&#8226; exception information<BR>&#8226; notes (where applicable).</FONT></P>
<P>Each of these items is described in more detail in the following subsections.</P>
<P>A few instruction descriptions describe alternative mnemonics for other instructions and use an abbreviated and modified version of this format.</P>
<P><BR>A7.1.1 Instruction section title</P>
<P><FONT class=extract>The instruction section title gives the base mnemonic for the instructions described in the section.</FONT> When one mnemonic has multiple forms described in separate instruction sections, this is followed by a short description of the form in parentheses. The most common use of this is to distinguish between forms of an instruction in which one of the operands is an immediate value and forms in which it is a register. Parenthesized text is also used to document the former mnemonic in some cases where a mnemonic has been replaced entirely by another mnemonic in the new assembler syntax.</P>
<P><BR>A7.1.2 Introduction to the instruction</P>
<P>The instruction section title is followed by text that briefly describes the main features of the instruction. This description is not necessarily complete and is not definitive. If there is any conflict between it and the more detailed information that follows, the latter takes priority.</P>
<P><BR><FONT class=extract>A7.1.3 Instruction encodings</FONT></P>
<P><FONT class=extract>The Encodings subsection contains a list of one or more instruction encodings. For reference purposes, each Thumb instruction encoding has a numbered label, T1, T2, and so on.</FONT></P>
<P><FONT class=extract>Each instruction encoding description consists of:<BR>&#8226; Information about which architecture variants include the particular encoding of the instruction. Thumb instructions present since ARMv4T are labelled as all versions of the Thumb instruction set, otherwise:<BR>&nbsp;&nbsp; &#8213; ARMv5T* means all variants of ARM Architecture version 5 that include Thumb instruction support.<BR>&nbsp;&nbsp; &#8213; ARMv6-M means a Thumb-only variant of the ARM architecture microcontroller profile that is compatible with ARMv6 Thumb support prior to the introduction of Thumb-2 technology.<BR>&nbsp;&nbsp; &#8213; ARMv7-M means a Thumb-only variant of the ARM architecture microcontroller profile that provides enhanced performance and functionality with respect to ARMv6-M through Thumb-2 technology and additional system features such as fault handling support.<BR>&nbsp;&nbsp; Note<BR>&nbsp;&nbsp; This manual does not provide architecture variant information about non-M profile variants of ARMv6 and ARMv7. For such information, see the ARM Architecture Reference Manual, ARMv7-A and ARMv7-R edition.<BR>&#8226; An assembly syntax that ensures that the assembler selects the encoding in preference to any other encoding. In some cases, multiple syntaxes are given. The correct one to use is sometimes indicated by annotations to the syntax, such as Inside IT block and Outside IT block. In other cases, the correct one to use can be determined by looking at the assembler syntax description and using it to determine which syntax corresponds to the instruction being disassembled.<BR>There is usually more than one syntax that ensures re-assembly to any particular encoding, and the exact set of syntaxes that do so usually depends on the register numbers, immediate constants and other operands to the instruction. For example, when assembling to the Thumb instruction set, the syntax AND R0,R0,R8 ensures selection of a 32-bit encoding but AND R0,R0,R1 selects a 16-bit encoding.<BR>The assembly syntax documented for the encoding is chosen to be the simplest one that ensures selection of that encoding for all operand combinations supported by that encoding. This often means that it includes elements that are only necessary for a small subset of operand combinations. For example, the assembler syntax documented for the 32-bit Thumb AND (register) encoding includes the .W qualifier to ensure that the 32-bit encoding is selected even for the small proportion of operand combinations for which the 16-bit encoding is also available.<BR>The assembly syntax given for an encoding is therefore a suitable one for a disassembler to disassemble that encoding to. However, disassemblers may wish to use simpler syntaxes when they are suitable for the operand combination, in order to produce more readable disassembled code.<BR>&#8226; An encoding diagram. This is half-width for 16-bit Thumb encodings and full-width for 32-bit Thumb encodings. Thumb encodings use the byte order of a sequence of two halfwords rather than of a word, as described in Instruction alignment and byte ordering on page A3-87.<BR>&#8226; Encoding-specific pseudocode. This is pseudocode that translates the encoding-specific instruction fields into inputs to the encoding-independent pseudocode in the later Operation subsection, and that picks out any special cases in the encoding. For a detailed description of the pseudocode used and of the relationship between the encoding diagram, the encoding-specific pseudocode and the encoding-independent pseudocode, see Appendix F Pseudocode Definition.</FONT></P>
<P><BR><FONT class=extract>A7.1.4 Assembler syntax</FONT></P>
<P><FONT class=extract>The Assembly syntax subsection describes the standard UAL syntax for the instruction.</FONT></P>
<P><FONT class=extract>Each syntax description consists of the following elements:<BR>&#8226; One or more syntax prototype lines written in a typewriter font, using the conventions described in Assembler syntax prototype line conventions on page A7-205. Each prototype line documents the mnemonic and (where appropriate) operand parts of a full line of assembler code. When there is more than one such line, each prototype line is annotated to indicate required results of the encoding-specific pseudocode. For each instruction encoding, this information can be used to determine whether any instructions matching that encoding are available when assembling that syntax, and if so, which ones.<BR>&#8226; The line where: followed by descriptions of all of the variable or optional fields of the prototype syntax line.<BR>Some syntax fields are standardized across all or most instructions. These fields are described in Standard assembler syntax fields on page A7-207.<BR>By default, syntax fields that specify registers (such as &lt;Rd&gt;, &lt;Rn&gt;, or &lt;Rt&gt;) are permitted to be any of R0-R12 or LR in Thumb instructions. These require that the encoding-specific pseudocode should set the corresponding integer variable (such as d, n, or t) to the corresponding register number (0-12 for R0-R12, 14 for LR). This can normally be done by setting the corresponding bitfield in the instruction, for example, Rd, Rn, or Rt, to the binary encoding of that number. In the case of 16-bit Thumb encodings, this bitfield is normally of length 3 and so the encoding is only available when one of R0-R7 was specified in the assembler syntax. It is also common for such encodings to use a bitfield name such as Rdn. This indicates that the encoding is only available if &lt;Rd&gt; and &lt;Rn&gt; specify the same register, and that the register number of that register is encoded in the bitfield if they do.<BR>The description of a syntax field that specifies a register sometimes extends or restricts the permitted range of registers or document other differences from the default rules for such fields. Typical extensions are to allow the use of one or both of the SP and the PC, using register numbers 13 and 15 respectively.<BR>Note<BR>The pre-UAL Thumb assembler syntax is incompatible with UAL and is not documented in the instruction sections.</FONT></P>
<P><BR><FONT class=extract>Assembler syntax prototype line conventions</FONT></P>
<P><FONT class=extract>The following conventions are used in assembler syntax prototype lines and their subfields:<BR>&lt; &gt;<BR>Any item bracketed by &lt; and &gt; is a short description of a type of value to be supplied by the user in that position. A longer description of the item is normally supplied by subsequent text. Such items often correspond to a similarly named field in an encoding diagram for an instruction. When the correspondence simply requires the binary encoding of an integer value or register number to be substituted into the instruction encoding, it is not described explicitly. For example, if the assembler syntax for a Thumb instruction contains an item &lt;Rn&gt; and the instruction encoding diagram contains a 4-bit field named Rn, the number of the register specified in the assembler syntax is encoded in binary in the instruction field.<BR>If the correspondence between the assembler syntax item and the instruction encoding is more complex than simple binary encoding of an integer or register number, the item description indicates how it is encoded. This is often done by specifying a required output from the encoding-specific pseudocode, such as add = TRUE. The assembler must only use encodings that produce that output.<BR>{ }<BR>Any item bracketed by { and } is optional. A description of the item and of how its presence or absence is encoded in the instruction is normally supplied by subsequent text.<BR>Many instructions have an optional destination register. Unless otherwise stated, if such a destination register is omitted, it is the same as the immediately following source register in the instruction syntax.<BR>spaces<BR>Single spaces are used for clarity, to separate items. When a space is obligatory in the assembler syntax, two or more consecutive spaces are used.<BR>+/-<BR>This indicates an optional + or - sign. If neither is coded, + is assumed.</FONT></P>
<P><FONT class=extract>All other characters must be encoded precisely as they appear in the assembler syntax. Apart from { and }, the special characters described above do not appear in the basic forms of assembler instructions documented in this manual. The { and } characters need to be encoded in a few places as part of a variable item. When this happens, the description of the variable item indicates how they must be used.</FONT></P>
<P><BR>A7.1.5 Pseudocode describing how the instruction operates</P>
<P>The Operation subsection contains encoding-independent pseudocode that describes the main operation of the instruction. For a detailed description of the pseudocode used and of the relationship between the encoding diagram, the encoding-specific pseudocode and the encoding-independent pseudocode, see Appendix F Pseudocode Definition.</P>
<P><BR><FONT class=extract>A7.1.6 Exception information</FONT></P>
<P><FONT class=extract>The Exceptions subsection contains a list of the exceptional conditions that can be caused by execution of the instruction.<BR>Processor exceptions are listed as follows:<BR>&#8226; Resets and interrupts, including NMI, PendSV and SysTick, are not listed. They can occur before or after the execution of any instruction, and in some cases during the execution of an instruction, but they are not in general caused by the instruction concerned.<BR>&#8226; MemManage and BusFault exceptions are listed for all instructions that perform explicit data memory accesses.<BR>&nbsp;&nbsp; All instruction fetches can cause MemManage and BusFault exceptions. These are not caused by execution of the instruction and so are not listed.<BR>&#8226; UsageFault exceptions can occur for a variety of reasons and are listed against instructions as appropriate.<BR>&nbsp;&nbsp; UsageFault exceptions also occur when pseudocode indicates that the instruction is UNDEFINED. These UsageFaults are not listed.<BR>&#8226; The SVCall exception is listed for the SVC instruction.<BR>&#8226; The DebugMonitor exception is listed for the BKPT instruction.<BR>&#8226; HardFault exceptions can arise from escalation of faults listed against an instruction, but are not themselves listed.<BR>Note<BR>For a summary of the different types of MemManage, BusFault and UsageFault exceptions see Fault behavior on page B1-669.</FONT></P>
<P><BR>A7.1.7 Notes</P>
<P>Where appropriate, additional notes about the instruction appear under further subheadings.