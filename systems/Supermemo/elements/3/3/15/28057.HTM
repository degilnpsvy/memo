5.2 Target state bit</P>
<P>In several situations it simplifies the architecture if the processor knows which state it is transitioning to before it has fetched the first instruction from the new domain. The ARMv7-M architecture doesn't contain the ARM instruction set (and is very unlikely to require it in the future), as such bit zero of the branch target address (which is used as the ARM/Thumb interworking bit in the ARMv7-AR architecture) is currently unused. The security extensions reuse this bit to signal the target state of a branch in secure state as follows:<BR>* target_addr[0] = 1, The target state of the branch is secure. Previously used to designate the Thumb instruction set.<BR>* target_addr[0] = 0, The target state of the branch is non-secure. Previously reserved to designate the ARM instruction set.</P>
<P>Since the processor boots into the secure state (see section 8), and only the Thumb instruction set is supported, the architecture is backwards compatible with legacy code that branches to addresses with the LSB set to 1. When executing in the non-secure state a branch to a location with target_addr[0] set to 0 results in INVSTATE UsageFault being raised, and branches with target_addr[0] = 1 behave as normal branches and do not cause a transition to the secure state, this approach has the following advantages:<BR>* Prevents non-secure code leveraging this bit as a possible attack vector.<BR>* Preserves the existing behaviour for legacy libraries or code compiled with legacy tools, that branch to addresses with the LSB set to 1.</P>
<P>In summary only secure functions that call non-secure code need to set the LSB of the call address to 0. The change in behaviour can be seen in the pseudo code for the BX and BLX helper functions, see sections 10.1 and 10.2 respectively.</P>
<P>Additional steps like clearing any registers that may contain secure data need to be taken when branching from secure to non-secure (see sections 5.3 and 5.4.1). Whether or not a branch targets the non-secure domain is known at compile/link time branch immediate operations. However for indirect branches this information is only available at compile time. As a result programmer knowledge of function pointers are passed through the system is required in order to determine whether the additional steps (eg clearing registers) are required. To prevent programmer error in these situations leading to security holes the BX and BLX (register) instructions are modified to include a new NS option (see sections 5.6.2 and 5.6.3). This option is specified by adding the NS suffix to the instruction (I.e. BXNS, BLXNS), and markes the branch as being able to transition from the secure to the non-secure state, any BX/BLX instruction that causes a transition to the non-secure state that doesn't have the NS option result in a fault being generated. By only using the NS variant of these instructions where the extra register clearing steps have been taken the programmer can ensure that accidental transitions to the non-secure state and the resulting data leakage can be prevented.