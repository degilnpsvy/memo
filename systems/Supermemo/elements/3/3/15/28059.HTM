5.4 Function calls from secure code
<P></P>
<P>In order to protect the secure code when calling a non-secure function it is necessary to hide and prevent modification of the return address, which is normally stored in the link register. To accomplish this the pseudo code for the BLX instructions (see sections 5.6.2) is modified to perform the following operations if the call is marked as a secure to non-secure branch:<BR>* The return address and IPSR values are pushed onto the secure stack (see section 5.4.3).<BR>* LR to the reserved value FNC_RETURN.<BR>* If the processor is in handler mode the IPSR value is set to 1 so the non-secure code can't determine which exception handler is executing. NOTE: the value 1 is chosen because it doesn't correspond to a valid exception handler, and is non-zero so is still consistent with the processor being in handler mode.</P>
<P>When one of the following actions loads the PC with the FNC_RETURN value the function return stack frame in unstacked (See section 5.4.4 the FunctionReturn() pseudo code for details):<BR>* POP/LDM that includes loading the PC.<BR>* LDR with PC as a destination.<BR>* BX with any register.</P>
<P>In addition to unstacking the contents of the function return stack frame, branching to FNC_RETURN also triggers the following operations:<BR>* The IT bits are cleared. This prevents the IT state from the returning non-secure function interfering with the operation of secure code.<BR>* A secure INVPC UsageFault is raised if the IPSR value before FNC_RETURN unstacking doesn't equal 0 or 1.<BR>* The IPSR value from the function return stack frame is cross checked against the current mode. If the processor isn't in the excepted mode a secure INVPC UsageFault is raised. NOTE: The existing ARMv7-M architecutre contains a similar integrity check on exception returns.</P>
<P>Any faults raised during the function return process are raised synchronously to the instruction that triggered the FNC_RETURN unstacking, IE the architectural state is as it would have been if the instruction hadn't executed.</P>
<P>The use of FNC_RETURN can be seen in Figure 4, where it results in the core transitioning to the secure state at the end of the BX lr instruction, thus avoiding the need for a SG instruction at the return address (which would open up the possibility of non-secure code calling into the middle of the secure function).</P>
<P>Non-secure memory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Secure memory<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SecureFunc:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PUSH {r4, lr}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (secure)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;other code&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (secure)<BR>NonSecureFunc:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LDR r4, =NonSecureFunc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (secure)<BR>&nbsp; &lt;other code&gt;&nbsp;&nbsp; &lt;-------|------- BLXNS r4&nbsp; #PC pushed to stack,&nbsp;&nbsp; (secure)<BR>&nbsp; #unstacks PC and&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #LR set to FNC_RETURN&nbsp; (secure)<BR>&nbsp; #transitions to secure |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (secure)<BR>&nbsp; BX lr&nbsp;&nbsp; ---------------|-----&gt;&nbsp; &lt;other code&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (secure)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; POP {r4, pc}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (secure)</P>
<P>If function arguments or return values need to be passed via the stack the SP_NS register (SYSm value 0x98, see sections 10.20 and 10.21) can be used to access the stack pointer associated with the non-secure callee function, regardless of whether the main or process stack pointers are being used. If the security domain of the callee function is not known at compile time (eg when calling a function pointer) the LSB of the function pointer can be examined to determine the target domain, and therefore which stack arguments should be placed on.