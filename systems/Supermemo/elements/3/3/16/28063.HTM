5.4.4 FunctionReturn()</P>
<P>The pseudo code that is executed when the PC is set to FNC_RETURN is shown below:</P>
<P>// FunctionReturn()<BR>// ================</P>
<P>ExcInfo FunctionReturn()<BR>&nbsp;&nbsp;&nbsp; exc = DefaultExcInfo();</P>
<P>&nbsp;&nbsp;&nbsp; // Pull the return address and IPSR off the secure stack<BR>&nbsp;&nbsp;&nbsp; mode = CurrentMode();<BR>&nbsp;&nbsp;&nbsp; spName = LookUpSP_with_security_mode(TRUE, mode);<BR>&nbsp;&nbsp;&nbsp; framePtr = _SP(spName);<BR>&nbsp;&nbsp;&nbsp; if !IsAligned(framePtr, 8) then UNPREDICTABLE;<BR>&nbsp;&nbsp;&nbsp; // Only stack locations, not the load order are architected<BR>&nbsp;&nbsp;&nbsp; XPSR_Type newXPSR;<BR>&nbsp;&nbsp;&nbsp; if exc.fault == NoFault then (exc, newXPSR) = Stack(framePtr, 4, spName, mode);<BR>&nbsp;&nbsp;&nbsp; if exc.fault == NoFault then (exc, newPC) = Stack(framePtr, 0, spName, mode);</P>
<P>&nbsp;&nbsp;&nbsp; // Check the IPSR value that's been unstacked is consistent with the current mode, and being originally called from the secure state.<BR>&nbsp;&nbsp;&nbsp; // NOTE: It is IMPLEMENTATION DEFINED whether this check is performed before or after the load of the return address above.<BR>&nbsp;&nbsp;&nbsp; if (exc.fault == NoFault) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !(((XPSR.Exception == 0&lt;8:0&gt;) &amp;&amp; (newXPSR.Exception == 0&lt;8:0&gt;)) |||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((XPSR.Exception == 1&lt;8:0&gt;) &amp;&amp; (newXPSR.Exception != 0&lt;8:0&gt;))) then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if HaveMainLineProfile() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UFSR_S.INVPC = '1';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Create the exception. NOTE: On baseline implementations the fault always escalates to a HardFault<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exc = CreateException(UsageFault, TRUE, TRUE);<BR>&nbsp;&nbsp;&nbsp; // The behaviour is UNPREDICTABLE if the IPSR values isn't supported by the PE<BR>&nbsp;&nbsp;&nbsp; validIPSR = newXPSR.Exception IN {0, 1, NMI, HardFault, SVCall, PendSV, SysTick};<BR>&nbsp;&nbsp;&nbsp; if !validIPSR &amp;&amp; HaveMainLineProfile() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validIPSR = newXPSR.Exception IN {MemManage, BusFault, UsageFault, SecureFault, DebugMonitor};<BR>&nbsp;&nbsp;&nbsp; if !validIPSR then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNPREDICTABLE;</P>
<P>&nbsp;&nbsp;&nbsp; // Only consume the function return stack frame and update the XPSR/PC if no faults occured.<BR>&nbsp;&nbsp;&nbsp; if exc.fault == NoFault then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Transition to the secure state<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CurrentState = SecurityState_Secure;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Update stack pointer. NOTE: Stack pointer limit not checked on function return as stack pointer guaranteed to be ascending not descending.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _R[spName] = framePtr + 8;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPSR.Exception = newXPSR.Exception;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTROL.SFPA = newXPSR.SFRA;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IT/ICI bits cleared to prevent non-secure code interfering with secure execution<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if HaveMainLineProfile() then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ITSTATE.IT = Zeros(8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // if EPSR.T == 0, a UsageFault('Invalid State') or a HardFault is taken on the next instruction depending of whether the main line profile or the base line profile is implemented.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EPSR.T = newPC&lt;0&gt;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BranchTo(newPC&lt;31:1&gt;:'0');<BR>&nbsp;&nbsp;&nbsp; return exc;