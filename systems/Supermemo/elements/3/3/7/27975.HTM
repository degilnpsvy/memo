********* QEMU specific operations 
<P></P>
<P><FONT class=extract>* exit_tb t0 </FONT></P>
<P><FONT class=extract>Exit the current TB and return the value t0 (word type).</FONT> </P>
<P>&nbsp;</P>
<P><FONT class=extract>* goto_tb index </FONT></P>
<P><FONT class=extract>Exit the current TB and jump to the TB index 'index' (constant) if the current TB was linked to this TB. Otherwise execute the next instructions. Only indices 0 and 1 are valid and tcg_gen_goto_tb may be issued at most once with each slot index per TB.</FONT> </P>
<P>&nbsp;</P>
<P><FONT class=extract>* qemu_ld_i32/i64 t0, t1, flags, memidx </FONT></P>
<P><FONT class=extract>* qemu_st_i32/i64 t0, t1, flags, memidx </FONT></P>
<P><FONT class=extract>Load data at the guest address t1 into t0, or store data in t0 at guest address t1. The _i32/_i64 size applies to the size of the input/output register t0 only. The address t1 is always sized according to the guest, and the width of the memory operation is controlled by flags. </FONT></P>
<P><FONT class=extract>Both t0 and t1 may be split into little-endian ordered pairs of registers if dealing with 64-bit quantities on a 32-bit host. </FONT></P>
<P><FONT class=extract>The memidx selects the qemu tlb index to use (e.g. user or kernel access). The flags are the TCGMemOp bits, selecting the sign, width, and endianness of the memory access. </FONT></P>
<P><FONT class=extract>For a 32-bit host, qemu_ld/st_i64 is guaranteed to only be used with a 64-bit memory access specified in flags.</FONT>