#ifdef CONFIG_BINARY_PRINTF<BR>/*<BR>&nbsp;* bprintf service:<BR>&nbsp;* vbin_printf() - VA arguments to binary data<BR>&nbsp;* bstr_printf() - Binary data to text string<BR>&nbsp;*/ 
<P></P>
<P>/**<BR>&nbsp;* vbin_printf - Parse a format string and place args' binary value in a buffer<BR>&nbsp;* @bin_buf: The buffer to place args' binary value<BR>&nbsp;* @size: The size of the buffer(by words(32bits), not characters)<BR>&nbsp;* @fmt: The format string to use<BR>&nbsp;* @args: Arguments for the format string<BR>&nbsp;*<BR>&nbsp;* The format follows C99 vsnprintf, except %n is ignored, and its argument<BR>&nbsp;* is skipped.<BR>&nbsp;*<BR>&nbsp;* The return value is the number of words(32bits) which would be generated for<BR>&nbsp;* the given input.<BR>&nbsp;*<BR>&nbsp;* NOTE:<BR>&nbsp;* If the return value is greater than @size, the resulting bin_buf is NOT<BR>&nbsp;* valid for bstr_printf().<BR>&nbsp;*/<BR>int vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args)<BR>{<BR>&nbsp;struct printf_spec spec = {0};<BR>&nbsp;char *str, *end;</P>
<P>&nbsp;str = (char *)bin_buf;<BR>&nbsp;end = (char *)(bin_buf + size);</P>
<P>#define save_arg(type)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (sizeof(type) == 8) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;unsigned long long value;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;str = PTR_ALIGN(str, sizeof(u32));&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;value = va_arg(args, unsigned long long);&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (str + sizeof(type) &lt;= end) {&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;*(u32 *)str = *(u32 *)&amp;value;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;*(u32 *)(str + 4) = *((u32 *)&amp;value + 1);&nbsp;\<BR>&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;} else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;unsigned long value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;str = PTR_ALIGN(str, sizeof(type));&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;value = va_arg(args, int);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (str + sizeof(type) &lt;= end)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;*(typeof(type) *)str = (type)value;&nbsp;&nbsp;\<BR>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;str += sizeof(type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>} while (0)</P>
<P>&nbsp;while (*fmt) {<BR>&nbsp;&nbsp;int read = format_decode(fmt, &amp;spec);</P>
<P>&nbsp;&nbsp;fmt += read;</P>
<P>&nbsp;&nbsp;switch (spec.type) {<BR>&nbsp;&nbsp;case FORMAT_TYPE_NONE:<BR>&nbsp;&nbsp;case FORMAT_TYPE_PERCENT_CHAR:<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case FORMAT_TYPE_INVALID:<BR>&nbsp;&nbsp;&nbsp;goto out;</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_WIDTH:<BR>&nbsp;&nbsp;case FORMAT_TYPE_PRECISION:<BR>&nbsp;&nbsp;&nbsp;save_arg(int);<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_CHAR:<BR>&nbsp;&nbsp;&nbsp;save_arg(char);<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_STR: {<BR>&nbsp;&nbsp;&nbsp;const char *save_str = va_arg(args, char *);<BR>&nbsp;&nbsp;&nbsp;size_t len;</P>
<P>&nbsp;&nbsp;&nbsp;if ((unsigned long)save_str &gt; (unsigned long)-PAGE_SIZE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| (unsigned long)save_str &lt; PAGE_SIZE)<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_str = "(null)";<BR>&nbsp;&nbsp;&nbsp;len = strlen(save_str) + 1;<BR>&nbsp;&nbsp;&nbsp;if (str + len &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;memcpy(str, save_str, len);<BR>&nbsp;&nbsp;&nbsp;str += len;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_PTR:<BR>&nbsp;&nbsp;&nbsp;save_arg(void *);<BR>&nbsp;&nbsp;&nbsp;/* skip all alphanumeric pointer suffixes */<BR>&nbsp;&nbsp;&nbsp;while (isalnum(*fmt))<BR>&nbsp;&nbsp;&nbsp;&nbsp;fmt++;<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;switch (spec.type) {</P>
<P>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_LONG_LONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(long long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_ULONG:<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_LONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(unsigned long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_SIZE_T:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(size_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_PTRDIFF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(ptrdiff_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_UBYTE:<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_BYTE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(char);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_USHORT:<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_SHORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(short);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;save_arg(int);<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>out:<BR>&nbsp;return (u32 *)(PTR_ALIGN(str, sizeof(u32))) - bin_buf;<BR>#undef save_arg<BR>}<BR>EXPORT_SYMBOL_GPL(vbin_printf);</P>
<P>/**<BR>&nbsp;* bstr_printf - Format a string from binary arguments and place it in a buffer<BR>&nbsp;* @buf: The buffer to place the result into<BR>&nbsp;* @size: The size of the buffer, including the trailing null space<BR>&nbsp;* @fmt: The format string to use<BR>&nbsp;* @bin_buf: Binary arguments for the format string<BR>&nbsp;*<BR>&nbsp;* This function like C99 vsnprintf, but the difference is that vsnprintf gets<BR>&nbsp;* arguments from stack, and bstr_printf gets arguments from @bin_buf which is<BR>&nbsp;* a binary buffer that generated by vbin_printf.<BR>&nbsp;*<BR>&nbsp;* The format follows C99 vsnprintf, but has some extensions:<BR>&nbsp;*&nbsp; see vsnprintf comment for details.<BR>&nbsp;*<BR>&nbsp;* The return value is the number of characters which would<BR>&nbsp;* be generated for the given input, excluding the trailing<BR>&nbsp;* '\0', as per ISO C99. If you want to have the exact<BR>&nbsp;* number of characters written into @buf as return value<BR>&nbsp;* (not including the trailing '\0'), use vscnprintf(). If the<BR>&nbsp;* return is greater than or equal to @size, the resulting<BR>&nbsp;* string is truncated.<BR>&nbsp;*/<BR>int bstr_printf(char *buf, size_t size, const char *fmt, const u32 *bin_buf)<BR>{<BR>&nbsp;struct printf_spec spec = {0};<BR>&nbsp;char *str, *end;<BR>&nbsp;const char *args = (const char *)bin_buf;</P>
<P>&nbsp;if (WARN_ON_ONCE(size &gt; INT_MAX))<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;str = buf;<BR>&nbsp;end = buf + size;</P>
<P>#define get_arg(type)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(type) value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (sizeof(type) == 8) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;args = PTR_ALIGN(args, sizeof(u32));&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;*(u32 *)&amp;value = *(u32 *)args;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;*((u32 *)&amp;value + 1) = *(u32 *)(args + 4);&nbsp;&nbsp;\<BR>&nbsp;} else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;args = PTR_ALIGN(args, sizeof(type));&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;value = *(typeof(type) *)args;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;args += sizeof(type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>&nbsp;/* Make sure end is always &gt;= buf */<BR>&nbsp;if (end &lt; buf) {<BR>&nbsp;&nbsp;end = ((void *)-1);<BR>&nbsp;&nbsp;size = end - buf;<BR>&nbsp;}</P>
<P>&nbsp;while (*fmt) {<BR>&nbsp;&nbsp;const char *old_fmt = fmt;<BR>&nbsp;&nbsp;int read = format_decode(fmt, &amp;spec);</P>
<P>&nbsp;&nbsp;fmt += read;</P>
<P>&nbsp;&nbsp;switch (spec.type) {<BR>&nbsp;&nbsp;case FORMAT_TYPE_NONE: {<BR>&nbsp;&nbsp;&nbsp;int copy = read;<BR>&nbsp;&nbsp;&nbsp;if (str &lt; end) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (copy &gt; end - str)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy = end - str;<BR>&nbsp;&nbsp;&nbsp;&nbsp;memcpy(str, old_fmt, copy);<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;str += read;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_WIDTH:<BR>&nbsp;&nbsp;&nbsp;set_field_width(&amp;spec, get_arg(int));<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_PRECISION:<BR>&nbsp;&nbsp;&nbsp;set_precision(&amp;spec, get_arg(int));<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_CHAR: {<BR>&nbsp;&nbsp;&nbsp;char c;</P>
<P>&nbsp;&nbsp;&nbsp;if (!(spec.flags &amp; LEFT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;while (--spec.field_width &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*str = ' ';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;c = (unsigned char) get_arg(char);<BR>&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*str = c;<BR>&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;while (--spec.field_width &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*str = ' ';<BR>&nbsp;&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_STR: {<BR>&nbsp;&nbsp;&nbsp;const char *str_arg = args;<BR>&nbsp;&nbsp;&nbsp;args += strlen(str_arg) + 1;<BR>&nbsp;&nbsp;&nbsp;str = string(str, end, (char *)str_arg, spec);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_PTR:<BR>&nbsp;&nbsp;&nbsp;str = pointer(fmt, str, end, get_arg(void *), spec);<BR>&nbsp;&nbsp;&nbsp;while (isalnum(*fmt))<BR>&nbsp;&nbsp;&nbsp;&nbsp;fmt++;<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_PERCENT_CHAR:<BR>&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*str = '%';<BR>&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_INVALID:<BR>&nbsp;&nbsp;&nbsp;goto out;</P>
<P>&nbsp;&nbsp;default: {<BR>&nbsp;&nbsp;&nbsp;unsigned long long num;</P>
<P>&nbsp;&nbsp;&nbsp;switch (spec.type) {</P>
<P>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_LONG_LONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(long long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_ULONG:<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_LONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(unsigned long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_SIZE_T:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(size_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_PTRDIFF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(ptrdiff_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_UBYTE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(unsigned char);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_BYTE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(signed char);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_USHORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(unsigned short);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_SHORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(short);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_UINT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(unsigned int);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = get_arg(int);<BR>&nbsp;&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;&nbsp;str = number(str, end, num, spec);<BR>&nbsp;&nbsp;} /* default: */<BR>&nbsp;&nbsp;} /* switch(spec.type) */<BR>&nbsp;} /* while(*fmt) */</P>
<P>out:<BR>&nbsp;if (size &gt; 0) {<BR>&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;*str = '\0';<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;end[-1] = '\0';<BR>&nbsp;}</P>
<P>#undef get_arg</P>
<P>&nbsp;/* the trailing null byte doesn't count towards the total */<BR>&nbsp;return str - buf;<BR>}<BR>EXPORT_SYMBOL_GPL(bstr_printf);</P>
<P>/**<BR>&nbsp;* bprintf - Parse a format string and place args' binary value in a buffer<BR>&nbsp;* @bin_buf: The buffer to place args' binary value<BR>&nbsp;* @size: The size of the buffer(by words(32bits), not characters)<BR>&nbsp;* @fmt: The format string to use<BR>&nbsp;* @...: Arguments for the format string<BR>&nbsp;*<BR>&nbsp;* The function returns the number of words(u32) written<BR>&nbsp;* into @bin_buf.<BR>&nbsp;*/<BR>int bprintf(u32 *bin_buf, size_t size, const char *fmt, ...)<BR>{<BR>&nbsp;va_list args;<BR>&nbsp;int ret;</P>
<P>&nbsp;va_start(args, fmt);<BR>&nbsp;ret = vbin_printf(bin_buf, size, fmt, args);<BR>&nbsp;va_end(args);</P>
<P>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(bprintf);</P>
<P>#endif /* CONFIG_BINARY_PRINTF */