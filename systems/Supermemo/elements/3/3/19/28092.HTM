/**<BR>&nbsp;* vsnprintf - Format a string and place it in a buffer<BR>&nbsp;* @buf: The buffer to place the result into<BR>&nbsp;* @size: The size of the buffer, including the trailing null space<BR>&nbsp;* @fmt: The format string to use<BR>&nbsp;* @args: Arguments for the format string<BR>&nbsp;*<BR>&nbsp;* This function generally follows C99 vsnprintf, but has some<BR>&nbsp;* extensions and a few limitations:<BR>&nbsp;*<BR>&nbsp;* %n is unsupported<BR>&nbsp;* %p* is handled by pointer()<BR>&nbsp;*<BR>&nbsp;* See pointer() or Documentation/printk-formats.txt for more<BR>&nbsp;* extensive description.<BR>&nbsp;*<BR>&nbsp;* ** Please update the documentation in both places when making changes **<BR>&nbsp;*<BR>&nbsp;* The return value is the number of characters which would<BR>&nbsp;* be generated for the given input, excluding the trailing<BR>&nbsp;* '\0', as per ISO C99. If you want to have the exact<BR>&nbsp;* number of characters written into @buf as return value<BR>&nbsp;* (not including the trailing '\0'), use vscnprintf(). If the<BR>&nbsp;* return is greater than or equal to @size, the resulting<BR>&nbsp;* string is truncated.<BR>&nbsp;*<BR>&nbsp;* If you're not already dealing with a va_list consider using snprintf().<BR>&nbsp;*/<BR>int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)<BR>{<BR>&nbsp;unsigned long long num;<BR>&nbsp;char *str, *end;<BR>&nbsp;struct printf_spec spec = {0}; 
<P></P>
<P>&nbsp;/* Reject out-of-range values early.&nbsp; Large positive sizes are<BR>&nbsp;&nbsp;&nbsp; used for unknown buffer sizes. */<BR>&nbsp;if (WARN_ON_ONCE(size &gt; INT_MAX))<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;str = buf;<BR>&nbsp;end = buf + size;</P>
<P>&nbsp;/* Make sure end is always &gt;= buf */<BR>&nbsp;if (end &lt; buf) {<BR>&nbsp;&nbsp;end = ((void *)-1);<BR>&nbsp;&nbsp;size = end - buf;<BR>&nbsp;}</P>
<P>&nbsp;while (*fmt) {<BR>&nbsp;&nbsp;const char *old_fmt = fmt;<BR>&nbsp;&nbsp;int read = format_decode(fmt, &amp;spec);</P>
<P>&nbsp;&nbsp;fmt += read;</P>
<P>&nbsp;&nbsp;switch (spec.type) {<BR>&nbsp;&nbsp;case FORMAT_TYPE_NONE: {<BR>&nbsp;&nbsp;&nbsp;int copy = read;<BR>&nbsp;&nbsp;&nbsp;if (str &lt; end) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (copy &gt; end - str)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy = end - str;<BR>&nbsp;&nbsp;&nbsp;&nbsp;memcpy(str, old_fmt, copy);<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;str += read;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_WIDTH:<BR>&nbsp;&nbsp;&nbsp;set_field_width(&amp;spec, va_arg(args, int));<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_PRECISION:<BR>&nbsp;&nbsp;&nbsp;set_precision(&amp;spec, va_arg(args, int));<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_CHAR: {<BR>&nbsp;&nbsp;&nbsp;char c;</P>
<P>&nbsp;&nbsp;&nbsp;if (!(spec.flags &amp; LEFT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;while (--spec.field_width &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*str = ' ';<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++str;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;c = (unsigned char) va_arg(args, int);<BR>&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*str = c;<BR>&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;while (--spec.field_width &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*str = ' ';<BR>&nbsp;&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_STR:<BR>&nbsp;&nbsp;&nbsp;str = string(str, end, va_arg(args, char *), spec);<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_PTR:<BR>&nbsp;&nbsp;&nbsp;str = pointer(fmt, str, end, va_arg(args, void *),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spec);<BR>&nbsp;&nbsp;&nbsp;while (isalnum(*fmt))<BR>&nbsp;&nbsp;&nbsp;&nbsp;fmt++;<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_PERCENT_CHAR:<BR>&nbsp;&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*str = '%';<BR>&nbsp;&nbsp;&nbsp;++str;<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;case FORMAT_TYPE_INVALID:<BR>&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp; * Presumably the arguments passed gcc's type<BR>&nbsp;&nbsp;&nbsp; * checking, but there is no safe or sane way<BR>&nbsp;&nbsp;&nbsp; * for us to continue parsing the format and<BR>&nbsp;&nbsp;&nbsp; * fetching from the va_list; the remaining<BR>&nbsp;&nbsp;&nbsp; * specifiers and arguments would be out of<BR>&nbsp;&nbsp;&nbsp; * sync.<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;goto out;</P>
<P>&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;switch (spec.type) {<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_LONG_LONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, long long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_ULONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, unsigned long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_LONG:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_SIZE_T:<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (spec.flags &amp; SIGN)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, ssize_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, size_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_PTRDIFF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, ptrdiff_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_UBYTE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = (unsigned char) va_arg(args, int);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_BYTE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = (signed char) va_arg(args, int);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_USHORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = (unsigned short) va_arg(args, int);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_SHORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = (short) va_arg(args, int);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;case FORMAT_TYPE_INT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = (int) va_arg(args, int);<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;num = va_arg(args, unsigned int);<BR>&nbsp;&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;&nbsp;str = number(str, end, num, spec);<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>out:<BR>&nbsp;if (size &gt; 0) {<BR>&nbsp;&nbsp;if (str &lt; end)<BR>&nbsp;&nbsp;&nbsp;*str = '\0';<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;end[-1] = '\0';<BR>&nbsp;}</P>
<P>&nbsp;/* the trailing null byte doesn't count towards the total */<BR>&nbsp;return str-buf;</P>
<P>}<BR>EXPORT_SYMBOL(vsnprintf);