<DIV class=defun style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__builtin_choose_expr</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>const_exp, exp1, exp2</VAR>)<VAR><A name=index-g_t_005f_005fbuiltin_005fchoose_005fexpr-3619></A></VAR><BR>
<BLOCKQUOTE>
<P>You can use the built-in function<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__builtin_choose_expr</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to evaluate code depending on the value of a constant expression. This built-in function returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>exp1</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>const_exp</VAR>, which is an integer constant expression, is nonzero. Otherwise it returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>exp2</VAR>.</P>
<P>This built-in function is analogous to the &#8216;<SAMP><SPAN class=samp>? :</SPAN></SAMP>&#8217; operator in C, except that the expression returned has its type unaltered by promotion rules. Also, the built-in function does not evaluate the expression that is not chosen. For example, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>const_exp</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>evaluates to true,<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>exp2</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not evaluated even if it has side-effects.</P>
<P>This built-in function can return an lvalue if the chosen argument is an lvalue.</P>
<P>If<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>exp1</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is returned, the return type is the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>exp1</VAR>'s type. Similarly, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>exp2</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is returned, its return type is the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>exp2</VAR>.</P>
<P>Example:</P><PRE class=smallexample style="FONT-SIZE: smaller">          #define foo(x)                                                    \
            __builtin_choose_expr (                                         \
              __builtin_types_compatible_p (typeof (x), double),            \
              foo_double (x),                                               \
              __builtin_choose_expr (                                       \
                __builtin_types_compatible_p (typeof (x), float),           \
                foo_float (x),                                              \
                /* <SPAN class=roman style="FONT-FAMILY: serif; FONT-WEIGHT: normal">The void expression results in a compile-time error</SPAN>  \
                   <SPAN class=roman style="FONT-FAMILY: serif; FONT-WEIGHT: normal">when assigning the result to something.</SPAN>  */          \
                (void)0))
</PRE>
<P><EM>Note:</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>This construct is only available for C. Furthermore, the unused expression (<VAR>exp1</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>exp2</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>depending on the value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>const_exp</VAR>) may still generate syntax errors. This may change in future revisions.</P></BLOCKQUOTE></DIV>