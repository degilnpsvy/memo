B4.12 Faults 
<P></P>
<P>INHTB There are the following Fault Status Registers:<BR>&#8226; <FONT class=extract>HardFault Status Register (HFSR)</FONT>. Present only if the Main Extension is implemented.<BR>&#8226; <FONT class=extract>MemManage Fault Status Register (MMFSR)</FONT>. Present only if the Main Extension is implemented.<BR>&#8226; <FONT class=extract>BusFault Status Register (BFSR)</FONT>. Present only if the Main Extension is implemented.<BR>&#8226; <FONT class=extract>UsageFault Status Register (UFSR)</FONT>. Present only if the Main Extension is implemented.<BR>&#8226; <FONT class=extract>SecureFault Status Register (SFSR)</FONT>. Present only if the Main Extension and Security Extension are implemented.<BR>&#8226; <FONT class=extract>Debug Fault Status Register (DFSR)</FONT>. Present only if halting debug or the Main Extension is implemented.<BR>&#8226; <FONT class=extract>Auxiliary Fault Status Register (AFSR)</FONT>. The contents of this register are IMPLEMENTATION DEFINED.<BR><FONT class=extract>In a PE with the Main Extension, the MMFSR, BFSR, and UFSR combine to form one register, called the Configurable Fault Status Register (CFSR).</FONT><BR>There are the following Fault Address Registers:<BR>&#8226; <FONT class=extract>MemManage Fault Address Register (MMFAR)</FONT>. Present only if the Main Extension is implemented.<BR>&#8226; <FONT class=extract>BusFault Address Register (BFAR)</FONT>. Present only if the Main Extension is implemented.<BR>&#8226; <FONT class=extract>SecureFault Address Register (SFAR)</FONT>. Present only if the Main Extension is implemented.<BR>RXMRH <FONT class=extract>MMFAR is updated only for a MemManage fault on a direct data access.</FONT><BR>RDDJJ <FONT class=extract>BFAR is updated only for a BusFault on a data access, precise.</FONT><BR>ITSDC <FONT class=extract>An imprecise exception is an exception that is generated as the result of a system error and that is reported at a time that is asynchronous to the instruction that caused it.</FONT><BR>RPDCH <FONT class=extract>In a PE with the Main Extension, the faults are:<BR>Exception number, Exception, Fault status bit, Fault<BR>3 HardFault:<BR>HFSR.VECTTBL HardFault on a vector table entry read error <BR>HFSR.FORCED&nbsp; HardFault on fault escalation<BR>HFSR.DEBUGEVT HardFault on BKPT escalation<BR>4 MemManage fault:<BR>MMFSR.IACCVIOL&nbsp; MemManage fault on an instruction fetch<BR>MMFSR.DACCVIOL&nbsp; MemManage fault on a direct data access<BR>MMFSR.MUNSTKERR MemManage fault on context unstacking by hardware, because of an MPU access violation<BR>MMFSR.MSTKERR&nbsp;&nbsp; MemManage fault on context stacking by hardware, because of an MPU access violation<BR>MMFSR.MLSPERR&nbsp;&nbsp; When lazy FP context preservation is active, a MemManage fault on saving FP context to the stack<BR>5 BusFault:<BR>BFSR.IBUSERR&nbsp;&nbsp;&nbsp;&nbsp; BusFault on an instruction fetch, precise <BR>BFSR.PRECISERR&nbsp;&nbsp; BusFault on a data access, precise <BR>BFSR.IMPRECISERR BusFault on a data access, imprecise <BR>BFSR.UNSTKERR&nbsp;&nbsp;&nbsp; BusFault on context unstacking by hardware <BR>BFSR.STKERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BusFault on context stacking by hardware <BR>SFSR.LSPERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When lazy FP context preservation is active, a BusFault on saving FP context to the stack<BR>6 UsageFault:<BR>UFSR.UNDEFINSTR UsageFault, undefined instruction <BR>UFSR.INVSTATE&nbsp;&nbsp; UsageFault, invalid Instruction set state because EPSR.T is 0<BR>UFSR.INVPC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UsageFault, failed integrity check on exception return<BR>UFSR.NOCP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UsageFault, no coprocessor <BR>UFSR.STKOF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UsageFault, stack overflow <BR>UFSR.UNALIGNED&nbsp; UsageFault, unaligned access when CCR.UNALIGN_TRP is 1<BR>UFSR.DIVBYZERO&nbsp; UsageFault, divide by zero when CCR.DIV_0_TRP is 1<BR>7 SecureFault:<BR>SFSR.INVEP&nbsp;&nbsp;&nbsp; SecureFault, invalid Secure state entry point <BR>SFSR.INVIS&nbsp;&nbsp;&nbsp; SecureFault, invalid integrity signature when unstacking<BR>SFSR.INVER&nbsp;&nbsp;&nbsp; SecureFault, invalid exception return <BR>SFSR.AUVIOL&nbsp;&nbsp; SecureFault, attribution unit violation <BR>SFSR.INVTRAN&nbsp; SecureFault, invalid transition from Secure state<BR>SFSR.LSPERR&nbsp;&nbsp; SecureFault, lazy FP context preservation error <BR>SFSR.LSERR&nbsp;&nbsp;&nbsp; SecureFault, lazy FP context error</FONT> </P>
<P>RNXRX <FONT class=extract>In a PE without the Main Extension, the faults remain the same as for a PE with the Main Extension, but the enable, pending, and active bits for the following faults are RAZ/WI in the SHCSR:<BR>&#8226; MemManage fault.<BR>&#8226; BusFault.<BR>&#8226; UsageFault.<BR>&#8226; SecureFault.<BR>In a PE without the Main Extension, the faults are:<BR>Exception number&nbsp;&nbsp; Exception<BR>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HardFault</FONT><BR>RFQJV <FONT class=extract>Fault conditions that would generate a SecureFault in a PE with the Main Extension instead generate a Secure Hardfault in a PE without the Main Extension.</FONT><BR>ICCXG For the exact circumstances under which each of the ARM v8-M faults is generated, see the appropriate Fault Status Register description.