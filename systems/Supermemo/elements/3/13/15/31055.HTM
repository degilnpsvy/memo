D2.2.180 <FONT class=extract>SFSR, Secure Fault Status Register</FONT> 
<P></P>
<P><FONT class=extract>The SFSR characteristics are:<BR>Purpose: Provides information about any security related faults.<BR>Usage constraints: Privileged access permitted only. Unprivileged accesses generate a BusFault.<BR>&nbsp; This register is word accessible only. Halfword and byte accesses are UNPREDICTABLE.<BR>Configurations: Present only if the Main Extension is implemented.<BR>&nbsp; This register is RES0 if the Main Extension is not implemented.<BR>Attributes: 32-bit read/write-one-to-clear register located at 0xE000EDE4.<BR>&nbsp; This register is RAZ/WI when accessed as Non-secure.<BR>&nbsp; This register is not banked between Security states.</FONT></P>
<P>The SFSR bit assignments are:</P>
<P>Bits [31:8]<BR>Reserved, RES0.</P>
<P><FONT class=extract>LSERR, bit [7]<BR>Lazy state error flag. Sticky flag indicating that an error occurred during lazy state activation or deactivation.<BR>The possible values of this bit are:<BR>0 Error has not occurred.<BR>1 Error has occurred.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>SFARVALID, bit [6]<BR>Secure fault address valid. This bit is set when the SFAR register contains a valid value. As with similar fields, such as BFSR.BFARVALID and MMFSR.MMARVALID, this bit can be cleared by other exceptions, such as BusFault.<BR>The possible values of this bit are:<BR>0 SFAR content not valid.<BR>1 SFAR content valid.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>LSPERR, bit [5]<BR>Lazy state preservation error flag. Stick flag indicating that an SAU or IDAU violation occurred during the lazy preservation of floating-point state.<BR>The possible values of this bit are:<BR>0 Error has not occurred.<BR>1 Error has occurred.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>INVTRAN, bit [4]<BR>Invalid transition flag. Sticky flag indicating that an exception was raised due to a branch that was not flagged as being domain crossing causing a transition from Secure to Non-secure memory.<BR>The possible values of this bit are:<BR>0 Error has not occurred.<BR>1 Error has occurred.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>AUVIOL, bit [3]<BR>Attribution unit violation flag. Sticky flag indicating that an attempt was made to access parts of the address space that are marked as Secure with NS-Req for the transaction set to Non-secure. This bit is not set if the violation occurred during lazy state preservation. See LSPERR.<BR>The possible values of this bit are:<BR>0 Error has not occurred.<BR>1 Error has occurred.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>INVER, bit [2]<BR>Invalid exception return flag. This can be caused by EXC_RETURN.DCRS being set to 0 when returning from an exception in the Non-secure state, or by EXC_RETURN.ES being set to 1 when returning from an exception in the Non-secure state.<BR>The possible values of this bit are:<BR>0 Error has not occurred.<BR>1 Error has occurred.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>INVIS, bit [1]<BR>Invalid integrity signature flag. This bit is set if the integrity signature in an exception stack frame is found to be invalid during the unstacking operation.<BR>The possible values of this bit are:<BR>0 Error has not occurred.<BR>1 Error has occurred.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>INVEP, bit [0]<BR>Invalid entry point. This bit is set if a function call from the Non-secure state or exception targets a non-SG instruction in the Secure state. This bit is also set if the target address is a SG instruction, but there is no matching SAU/IDAU region with the NSC flag set.<BR>The possible values of this bit are:<BR>0 Error has not occurred.<BR>1 Error has occurred.<BR>This bit resets to zero on a Warm reset.</FONT>