<DIV class=docText><B>1. </B></DIV></TD><TD>
<DIV class=docText>Create a work queue (or a <TT>workqueue_struct</TT>) with one or more associated kernel threads. To create a kernel thread to service a <TT>workqueue_struct</TT>, use <TT>create_singlethread_workqueue()</TT>. To create one worker thread per CPU in the system, use the <TT>create_workqueue()</TT> variant. The kernel also has default per-CPU worker threads (<SPAN class=docEmphasis>events/n</SPAN>, where <SPAN class=docEmphasis>n</SPAN> is the CPU number) that you can timeshare instead of requesting a separate worker thread. Depending on your application, you might incur a performance hit if you don't have a dedicated worker thread.<BR><BR></DIV></TD></TR><TR><TD vAlign="top" width="25">
<DIV class=docText><B>2. </B></DIV></TD><TD>
<DIV class=docText>Create a work element (or a <TT>work_struct</TT>). A <TT>work_struct</TT> is initialized using <SPAN class=cloze>[...]</SPAN><TT>()</TT>, which populates it with the address and argument of your work function.<BR><BR></DIV></TD></TR><TR><TD vAlign="top" width="25">
<DIV class=docText><B>3. </B></DIV></TD><TD>
<DIV class=docText>Submit the work element to the work queue. A <TT>work_struct</TT> can be submitted to a dedicated queue using <TT>queue_work()</TT>, or to the default kernel worker thread(events) using <TT>schedule_work()</TT>.<BR></DIV></TD></TR></TBODY>