B4.18 Function returns from Non-secure state 
<P></P>
<P>RHPFG <FONT class=extract>A function return from Non-secure state begins when one of the following instructions loads a FNC_RETURN value into the PC:<BR>&nbsp; &#8226; A POP or LDM that includes loading the PC.<BR>&nbsp; &#8226; An LDR with the PC as a destination.<BR>&nbsp; &#8226; A BX with any register.<BR>On detecting a FNC_RETURN value in the PC:<BR>&nbsp; &#8226; The stack is unstacked.<BR>&nbsp; &#8226; EPSR.IT is set to 0b00.<BR>&nbsp; &#8226; The following integrity checks on function return are performed:<BR>&nbsp;&nbsp;&nbsp; &#8213; A check that IPSR is zero or 1 before the value of it is restored.<BR>&nbsp;&nbsp;&nbsp; &#8213; A check that if the return is to Thread mode, the stacked IPSR value is zero.<BR>&nbsp;&nbsp;&nbsp; &#8213; A check that if the return is to Handler mode, the stacked IPSR value is nonzero.</FONT></P>
<P>RTFCK <FONT class=extract>If the stack pointer is not 8 byte aligned the behavior is UNPREDICTABLE.</FONT></P>
<P><BR>RDWTF <FONT class=extract>The FNC_RETURN value is:<BR>&nbsp; 1111 1110 1111 1111 1111 1111 1111 111S<BR>&nbsp; Bits[31:1] This is what identifies the value as a FNC_RETURN value.<BR>&nbsp; Bit[0], S The function call was from:<BR>&nbsp;&nbsp;&nbsp; 0 Secure state.<BR>&nbsp;&nbsp;&nbsp; 1 Non-secure state.</FONT><BR>RUKFL <FONT class=extract>Any failed integrity check on function return generates:<BR>&nbsp; In a PE with the Main Extension:<BR>&nbsp;&nbsp;&nbsp; An INVPC UsageFault that is synchronous to the instruction that loaded the FNC_RETURN value into the PC.<BR>&nbsp; Otherwise:<BR>&nbsp;&nbsp;&nbsp; A Secure HardFault that is synchronous to the instruction that loaded the FNC_RETURN value into the PC.</FONT><BR>RLDVW <FONT class=extract>When the stack is unstacked on detecting a FNC_RETURN value in the PC, if ReturnAddress[0] is 0, the PE generates an INVSTATE UsageFault.</FONT></P>
<P>RFGNB <FONT class=extract>If FNC_RETURN does not fail the integrity checks then the PE behaves as follows:<BR>&#8226; ReturnAddress bits [31:1] is written to the PC.<BR>&#8226; ReturnAddress bit [0] is written to EPSR.T.<BR>&#8226; The partial RETPSR is written to IPSR.Exception.</FONT><BR></P>
<P>RJPFX <FONT class=extract>If the IPSR contains a value that is not supported by the PE the value is UNKNOWN and either an INVPC UsageFault or HardFault is generated.</FONT></P>
<P><BR>IKBXQ <FONT class=extract>Any Secure INVPC UsageFault, Secure HardFault, or INVSTATE UsageFault generated on FNC_RETURN are subject to the rules in respect of escalation of faults and potentially lockup.</FONT>