/**<BR>&nbsp;* ARMCPU:<BR>&nbsp;* @env: #CPUARMState<BR>&nbsp;*<BR>&nbsp;* An ARM CPU core.<BR>&nbsp;*/<BR>struct ARMCPU {<BR>&nbsp;&nbsp;&nbsp; /*&lt; private &gt;*/<BR>&nbsp;&nbsp;&nbsp; <FONT class=clozed>CPUState parent_obj</FONT>;<BR>&nbsp;&nbsp;&nbsp; /*&lt; public &gt;*/ 
<P></P>
<P>&nbsp;&nbsp;&nbsp; <SPAN class=cloze>[...]</SPAN>;</P>
<P>&nbsp;&nbsp;&nbsp; /* Coprocessor information */<BR>&nbsp;&nbsp;&nbsp; GHashTable *cp_regs;<BR>&nbsp;&nbsp;&nbsp; /* For marshalling (mostly coprocessor) register state between the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * kernel and QEMU (for KVM) and between two QEMUs (for migration),<BR>&nbsp;&nbsp;&nbsp;&nbsp; * we use these arrays.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; /* List of register indexes managed via these arrays; (full KVM style<BR>&nbsp;&nbsp;&nbsp;&nbsp; * 64 bit indexes, not CPRegInfo 32 bit indexes)<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint64_t *cpreg_indexes;<BR>&nbsp;&nbsp;&nbsp; /* Values of the registers (cpreg_indexes[i]'s value is cpreg_values[i]) */<BR>&nbsp;&nbsp;&nbsp; uint64_t *cpreg_values;<BR>&nbsp;&nbsp;&nbsp; /* Length of the indexes, values, reset_values arrays */<BR>&nbsp;&nbsp;&nbsp; int32_t cpreg_array_len;<BR>&nbsp;&nbsp;&nbsp; /* These are used only for migration: incoming data arrives in<BR>&nbsp;&nbsp;&nbsp;&nbsp; * these fields and is sanity checked in post_load before copying<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to the working data structures above.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint64_t *cpreg_vmstate_indexes;<BR>&nbsp;&nbsp;&nbsp; uint64_t *cpreg_vmstate_values;<BR>&nbsp;&nbsp;&nbsp; int32_t cpreg_vmstate_array_len;</P>
<P>&nbsp;&nbsp;&nbsp; /* Timers used by the generic (architected) timer */<BR>&nbsp;&nbsp;&nbsp; QEMUTimer *gt_timer[NUM_GTIMERS];<BR>&nbsp;&nbsp;&nbsp; /* GPIO outputs for generic timer */<BR>&nbsp;&nbsp;&nbsp; qemu_irq gt_timer_outputs[NUM_GTIMERS];</P>
<P>&nbsp;&nbsp;&nbsp; /* MemoryRegion to use for secure physical accesses */<BR>&nbsp;&nbsp;&nbsp; MemoryRegion *secure_memory;</P>
<P>&nbsp;&nbsp;&nbsp; /* 'compatible' string for this CPU for Linux device trees */<BR>&nbsp;&nbsp;&nbsp; const char *dtb_compatible;</P>
<P>&nbsp;&nbsp;&nbsp; /* PSCI version for this CPU<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Bits[31:16] = Major Version<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Bits[15:0] = Minor Version<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t psci_version;</P>
<P>&nbsp;&nbsp;&nbsp; /* Should CPU start in PSCI powered-off state? */<BR>&nbsp;&nbsp;&nbsp; bool start_powered_off;<BR>&nbsp;&nbsp;&nbsp; /* CPU currently in PSCI powered-off state */<BR>&nbsp;&nbsp;&nbsp; bool powered_off;<BR>&nbsp;&nbsp;&nbsp; /* CPU has security extension */<BR>&nbsp;&nbsp;&nbsp; bool has_el3;<BR>&nbsp;&nbsp;&nbsp; /* CPU has PMU (Performance Monitor Unit) */<BR>&nbsp;&nbsp;&nbsp; bool has_pmu;</P>
<P>&nbsp;&nbsp;&nbsp; /* CPU has memory protection unit */<BR>&nbsp;&nbsp;&nbsp; bool has_mpu;<BR>&nbsp;&nbsp;&nbsp; /* PMSAv7 MPU number of supported regions */<BR>&nbsp;&nbsp;&nbsp; uint32_t pmsav7_dregion;</P>
<P>&nbsp;&nbsp;&nbsp; /* PSCI conduit used to invoke PSCI methods<BR>&nbsp;&nbsp;&nbsp;&nbsp; * 0 - disabled, 1 - smc, 2 - hvc<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t psci_conduit;</P>
<P>&nbsp;&nbsp;&nbsp; /* [QEMU_]KVM_ARM_TARGET_* constant for this CPU, or<BR>&nbsp;&nbsp;&nbsp;&nbsp; * QEMU_KVM_ARM_TARGET_NONE if the kernel doesn't support this CPU type.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t kvm_target;</P>
<P>&nbsp;&nbsp;&nbsp; /* KVM init features for this CPU */<BR>&nbsp;&nbsp;&nbsp; uint32_t kvm_init_features[7];</P>
<P>&nbsp;&nbsp;&nbsp; /* Uniprocessor system with MP extensions */<BR>&nbsp;&nbsp;&nbsp; bool mp_is_up;</P>
<P>&nbsp;&nbsp;&nbsp; /* The instance init functions for implementation-specific subclasses<BR>&nbsp;&nbsp;&nbsp;&nbsp; * set these fields to specify the implementation-dependent values of<BR>&nbsp;&nbsp;&nbsp;&nbsp; * various constant registers and reset values of non-constant<BR>&nbsp;&nbsp;&nbsp;&nbsp; * registers.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Some of these might become QOM properties eventually.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Field names match the official register names as defined in the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * ARMv7AR ARM Architecture Reference Manual. A reset_ prefix<BR>&nbsp;&nbsp;&nbsp;&nbsp; * is used for reset values of non-constant registers; no reset_<BR>&nbsp;&nbsp;&nbsp;&nbsp; * prefix means a constant register.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t midr;<BR>&nbsp;&nbsp;&nbsp; uint32_t revidr;<BR>&nbsp;&nbsp;&nbsp; uint32_t reset_fpsid;<BR>&nbsp;&nbsp;&nbsp; uint32_t mvfr0;<BR>&nbsp;&nbsp;&nbsp; uint32_t mvfr1;<BR>&nbsp;&nbsp;&nbsp; uint32_t mvfr2;<BR>&nbsp;&nbsp;&nbsp; uint32_t ctr;<BR>&nbsp;&nbsp;&nbsp; uint32_t reset_sctlr;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_pfr0;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_pfr1;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_dfr0;<BR>&nbsp;&nbsp;&nbsp; uint32_t pmceid0;<BR>&nbsp;&nbsp;&nbsp; uint32_t pmceid1;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_afr0;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_mmfr0;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_mmfr1;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_mmfr2;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_mmfr3;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_mmfr4;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_isar0;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_isar1;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_isar2;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_isar3;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_isar4;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_isar5;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64pfr0;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64pfr1;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64dfr0;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64dfr1;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64afr0;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64afr1;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64isar0;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64isar1;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64mmfr0;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64mmfr1;<BR>&nbsp;&nbsp;&nbsp; uint32_t dbgdidr;<BR>&nbsp;&nbsp;&nbsp; uint32_t clidr;<BR>&nbsp;&nbsp;&nbsp; uint64_t mp_affinity; /* MP ID without feature bits */<BR>&nbsp;&nbsp;&nbsp; /* The elements of this array are the CCSIDR values for each cache,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * in the order L1DCache, L1ICache, L2DCache, L2ICache, etc.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t ccsidr[16];<BR>&nbsp;&nbsp;&nbsp; uint64_t reset_cbar;<BR>&nbsp;&nbsp;&nbsp; uint32_t reset_auxcr;<BR>&nbsp;&nbsp;&nbsp; bool reset_hivecs;<BR>&nbsp;&nbsp;&nbsp; /* DCZ blocksize, in log_2(words), ie low 4 bits of DCZID_EL0 */<BR>&nbsp;&nbsp;&nbsp; uint32_t dcz_blocksize;<BR>&nbsp;&nbsp;&nbsp; uint64_t rvbar;</P>
<P>&nbsp;&nbsp;&nbsp; ARMELChangeHook *el_change_hook;<BR>&nbsp;&nbsp;&nbsp; void *el_change_hook_opaque;<BR>};