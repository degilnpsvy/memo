B4.32 Lockup 
<P></P>
<P>IRKJB <FONT class=extract>Lockup is a PE state where the PE stops executing instructions in response to an error for which escalation to an appropriate HardFault handler is not possible because of the current execution priority. An example is a synchronous exception that would escalate to a Secure HardFault, but that cannot escalate to a Secure HardFault because Secure HardFault is already active.</FONT><BR>IFSFR <FONT class=extract>ARM recommends that an implementation provides a LOCKUP signal that, when the PE is in lockup, signals to the external system that the PE is in lockup.</FONT><BR>RMBTM <FONT class=extract>When the PE is in lockup:<BR>&#8226; DHCSR.S_LOCKUP reads as 1.<BR>&#8226; The PC reads as 0xEFFFFFFE. This is an XN address.<BR>&#8226; The PE stops fetching and executing instructions.<BR>&#8226; If the implementation provides an external LOCKUP signal, LOCKUP is asserted HIGH.</FONT><BR>RJRJC <FONT class=extract>Exit from lockup is by any of the following:<BR>&#8226; A Cold reset.<BR>&#8226; A Warm reset.<BR>&#8226; Entry to Debug state.<BR>&#8226; Preemption by a higher priority exception.</FONT><BR>RHJNP <FONT class=extract>Exit from lockup causes both DHCSR.S_LOCKUP and, if implemented, the external LOCKUP signal, to be easserted.</FONT><BR>RSPPN <FONT class=extract>On an exit from lockup by entry to Debug state, or by preemption by a higher priority exception, the return address<BR>is 0xEFFFFFFE.</FONT><BR>ICRHJ <FONT class=extract>After exit from lockup by entry to Debug state, or by preemption by a higher priority exception, a subsequent return rom Debug state or that exception without modifying the return address attempts to execute from 0xEFFFFFFE. xecution from this address is guaranteed to generate an IACCVIOL MemManage fault, causing the PE to reenter ockup if the execution priority has not been modified. Modification of the return address would enable execution o be resumed, however ARM recommends treating entry to lockup as fatal and requiring the PE to be reset.</FONT></P>
<P>See also:<BR>&#8226; Instruction-related lockup behavior.<BR>&#8213; Instruction execution.<BR>&#8213; Floating-point lazy FP context preservation on page B4-88.<BR>&#8226; Exception-related lockup behavior on page B4-88.<BR>&#8213; Vector or stack pointer error on reset on page B4-88.<BR>&#8213; Errors on preemption and stacking for exception entry on page B4-89.<BR>&#8213; Vector read error on NMI or HardFault entry on page B4-89.<BR>&#8213; Integrity checks on exception return on page B4-90.<BR>&#8213; Errors when unstacking state on exception return on page B4-90.