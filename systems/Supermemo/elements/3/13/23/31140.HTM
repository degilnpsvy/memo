B4.32.2 Exception-related lockup behavior</P>
<P>Vector or stack pointer error on reset<BR>RBHVG On reset, if reading the vector table to obtain either the vector for the reset handler or the initialization value for the<BR>main stack pointer causes a bus error, the PE enters lockup in HardFault with the following behavior:<BR>&nbsp;&nbsp;&nbsp;&nbsp; &#8226; HFSR.VECTTBL is set to 1.<BR>&nbsp;&nbsp;&nbsp;&nbsp; &#8226; In a PE with the Security Extension, Secure Hardfault is made active. That is, SHCSR_S.HARDFAULTACT is set to 1.<BR>&nbsp;&nbsp;&nbsp;&nbsp; &#8226; In a PE without the Security Extension, HardFault is made active. That is, SHCSR.HARDFAULTACT is set to 1.<BR>&nbsp;&nbsp;&nbsp;&nbsp; &#8226; An UNKNOWN value is loaded into the main stack pointer.<BR>&nbsp;&nbsp;&nbsp;&nbsp; &#8226; The IPSR is set to 0.<BR>&nbsp;&nbsp;&nbsp;&nbsp; &#8226; EPSR.T is UNKNOWN.<BR>&nbsp;&nbsp;&nbsp;&nbsp; &#8226; EPSR.IT is set to zero.<BR>&nbsp;&nbsp;&nbsp;&nbsp; &#8226; The PC is set to 0xEFFFFFFE.<BR>&nbsp;&nbsp;&nbsp;&nbsp; &#8226; The LR is set to 0xFFFFFFFF.<BR>IXPNL Because the PE always resets into Secure state and the highest privilege, SAU and MPU violations are not possible on accesses to the reset vector.</P>
<P>Errors on preemption and stacking for exception entry<BR>RVKTX An SAU violation, MPU violation, NOCP UsageFault, STKOF UsageFault, LSERR SecureFault, or synchronous bus error during context stacking causes lockup when:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; The exception would escalate to a Secure HardFault and any of the following is true:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; Secure HardFault is already active.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; NMI is active and AIRCR.BFHFNMINS is 0.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; FAULTMASK_S.FM is 1.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; The exception would escalate to a Non-secure HardFault and any of the following is true:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; Non-secure HardFault or Secure HardFault is already active.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; NMI is active.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; FAULTMASK_NS.FM or FAULTMASK_S.FM is 1.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In these cases the point of PE lockup is when, after the exception to be taken has been chosen, the handler for that exception is entered. These cases do not in themselves cause any additional exception to become pending.<BR>RQSSB When an SAU violation, MPU violation, NOCP UsageFault, STKOF UsageFault, LSERR SecureFault, or synchronous bus error occurs during context stacking, it is IMPLEMENTATION DEFINED whether the PE continues to stack any of the remaining context.<BR>RGJJG At the point of encountering an SAU violation, MPU violation, NOCP UsageFault, STKOF UsageFault, LSERR SecureFault, or synchronous bus error during context stacking, the PE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; Updates any Fault Status Registers associated with the error.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; Does not set HFSR.FORCED to 1.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; At the point of lockup:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; All state, including the LR, IPSR, and active and pending bits, is modified as though the fault on context stacking had never occurred, other than the following:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; EPSR.T becomes UNKNOWN.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; EPSR.IT is set to zero.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; The PC is set to 0xEFFFFFFE.</P>
<P>Vector read error on NMI or HardFault entry<BR>RCTKP On entry to an NMI or HardFault, if reading the vector table to obtain the vector for the NMI or HardFault handler causes a bus error, the PE enters lockup with the following behavior:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; HFSR.VECTTBL is set to 1.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; The IPSR is updated to hold the exception number of the exception taken.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; The active bit of the exception taken is set to 1.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; The pending bit of the exception taken is cleared to 0.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; EPSR.T is UNKNOWN.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; EPSR.IT is set to zero.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; The LR is set to the EXC_RETURN value that would have been used had the fault not occurred.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; The PC is set to 0xEFFFFFFE.<BR>INMRW Because SAU violations on vector reads are required to be treated as late-arriving, they cannot cause lockup, instead resulting in a higher priority exception being taken. Vector reads always use the default memory map and cannot generate MPU violations.</P>
<P>Integrity checks on exception return<BR>RTRFJ A fault generated by a failed integrity check on exception return is generated after either the active bit for the returning exception, or the active bit for NMI or HardFault, has been cleared to 0, and if applicable, after FAULTMASK has also been cleared to 0. A fault generated by a failed integrity check on exception return causes lockup when:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; The exception would escalate to a Secure HardFault and any of the following is true:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; Secure HardFault is already active.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; NMI is active and AIRCR.BFHFNMINS is 0.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; FAULTMASK_S.FM is 1.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; Non-secure Hardfault is active and AIRCR.BFHFNMINS is 0.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8226; The exception would escalate to a Non-secure HardFault and any of the following is true:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; Non-secure HardFault or Secure HardFault is already active.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; NMI is active.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#8213; FAULTMASK_NS.FM or FAULTMASK_S.FM is 1.<BR>RWBVC The target Security state of an INVPC UsageFault generated because of a failed integrity check on exception return is the Security state that the exception return instruction was executed in.<BR>RDFKP When the PE enters lockup because of a fault generated by a failed integrity check, the PE:<BR>&#8226; Updates any Fault Status Registers associated with the error.<BR>&#8226; Sets IPSR to 0, if EXC_RETURN for the returning exception indicated a return to Thread mode.<BR>&#8226; Sets IPSR to 3, if EXC_RETURN for the returning exception indicated a return to Handler mode.<BR>&#8226; Sets the stack pointer used for unstacking to the value it would have had if the fault had not occurred.<BR>&nbsp; &#8213; If the XPSR load faults, the SP is 64-bit aligned.<BR>&#8226; Updates CONTROL.FPCA, based on EXC_RETURN.FType.<BR>&#8226; Sets the PC to 0xEFFFFFFE.<BR>In addition, the APSR, EPSR, FPSCR, R0-R12, LR, and S0-S31 are UNKNOWN.</P>
<P>Errors when unstacking state on exception return<BR>RWKSJ Context unstacking is performed after any clearing of exception active bits or FAULTMASK, that is required by the exception return, has been made visible. An SAU violation, MPU violation, or synchronous bus error during context unstacking causes lockup when:<BR>&#8226; The exception would escalate to a Secure HardFault and any of the following is true:<BR>&#8213; Secure HardFault is already active.<BR>&#8213; FAULTMASK_S.FM is 1.<BR>&#8213; Non-secure Hardfault is active and AIRCR.BFHFNMINS is 0.<BR>&#8226; The exception would escalate to a Non-secure HardFault and any of the following is true:<BR>&#8213; Non-secure HardFault or Secure HardFault is already active.<BR>&#8213; NMI is active.<BR>&#8213; FAULTMASK_NS.FM or FAULTMASK_S.FM is 1.<BR>RXFCQ When an SAU violation, MPU violation, or synchronous bus error during context unstacking causes lockup, the PE:<BR>&#8226; Updates any Fault Status Registers associated with the error.<BR>&#8226; Sets IPSR to 0, if EXC_RETURN for the returning exception indicated a return to Thread mode.<BR>&#8226; Sets IPSR to 3, if EXC_RETURN for the returning exception indicated a return to Handler mode.<BR>&#8226; Sets the stack pointer used for unstacking to the value it would have had if the fault had not occurred.<BR>&#8213; If the XPSR load faults, the SP is 64-bit aligned.<BR>&#8226; Updates CONTROL.FPCA, based on EXC_RETURN.FType.<BR>&#8226; Sets the PC to 0xEFFFFFFE.<BR>In addition, the APSR, EPSR, FPSCR, R0-R12, LR, and S0-S31 are UNKNOWN.