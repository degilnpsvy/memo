B4.22 Stack limit checks</P>
<P>IKDPG In a PE with the Main and Security Extensions, there are four stack limit registers:<BR>Security state, Stack,&nbsp;&nbsp;&nbsp; Stack limit register<BR>Secure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSPLIM_S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Process&nbsp;&nbsp; PSPLIM_S<BR>Non-secure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSPLIM_NS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Process&nbsp;&nbsp; PSPLIM_NS</P>
<P>In a PE with the Main Extension but without the Security Extension, there are two stack limit registers:<BR>Stack.&nbsp;&nbsp; Stack limit register<BR>Main&nbsp;&nbsp;&nbsp;&nbsp; MSPLIM<BR>Process&nbsp; PSPLIM</P>
<P>In a PE without the Main Extension but with the Security Extension, there are:<BR>&#8226; No stack limit registers in Non-secure state.<BR>&#8226; Two stack limit registers in Secure state.<BR>Security state, Stack,&nbsp;&nbsp; Stack limit register<BR>Secure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Main&nbsp;&nbsp;&nbsp;&nbsp; MSPLIM_S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Process&nbsp; PSPLIM_S</P>
<P>In a PE without the Main Extension and without the Security Extension MSPLIM_S and PSPLIM_S are invisible.<BR>These registers hold stack limit values.<BR>A stack can descend to its stack limit value. Any attempt to descend the stack further than its stack limit value is a violation of the stack limit.<BR>xSPLIM_x[2:0] are treated as RES0, so that all stack pointer limits are always guaranteed to be doubleword-aligned. Bits [31:3] of the xSPLIM_x registers are writeable.<BR>RDKSR Stack limit checks are performed during the creation of a stack frame for all of the following:<BR>&#8226; Exception entry.<BR>&#8226; Tail-chaining from a Secure to a Non-secure exception.<BR>&#8226; A function call from Secure code to Non-secure code.<BR>RZLZG On a violation of a stack limit during either exception entry or tail-chaining:<BR>&#8226; In a PE with the Main Extension, a synchronous STKOF UsageFault is generated. Otherwise, a HardFault is generated.<BR>&#8226; The stack pointer is set to the stack limit value.<BR>&#8226; Push operations to addresses below the stack limit value are not performed.<BR>&#8226; It is IMPLEMENTATION DEFINED whether push operations to addresses equal to or above the stack limit value are performed.<BR>RCCSC On a violation of a Secure stack limit during a function call:<BR>&#8226; In a PE with the Main Extension, a synchronous STKOF UsageFault is generated. Otherwise, a HardFault is generated.<BR>&#8226; Push operations to addresses below the stack limit value are not performed.<BR>&#8226; It is IMPLEMENTATION DEFINED whether push operations to addresses equal to or above the stack limit value are performed.<BR>RGGRH Unstacking operations are not subject to stack limit checking.<BR>RYVWT Updates to the stack pointer by the following instructions are subjected to stack limit checking:<BR>&#8226; ADD (SP plus immediate).<BR>&#8226; ADD (SP plus register).<BR>&#8226; SUB (SP minus immediate).<BR>&#8226; SUB (SP minus register).<BR>&#8226; BLX, BLXNS.<BR>&#8226; LDC, LDC2 (immediate).<BR>&#8226; LDMDB, LDMEA.<BR>&#8226; LDR (immediate).<BR>&#8226; LDR (literal).<BR>&#8226; LDR (register).<BR>&#8226; LDRB (immediate).<BR>&#8226; LDRD (immediate).<BR>&#8226; LDRH (immediate).<BR>&#8226; LDRSB (immediate).<BR>&#8226; LDRSH (immediate).<BR>&#8226; MOV (register).<BR>&#8226; POP.<BR>&#8226; PUSH.<BR>&#8226; VPOP.<BR>&#8226; VPUSH.<BR>&#8226; STC, STC2.<BR>&#8226; STM, STMIA, STMEA.<BR>&#8226; STR (immediate).<BR>&#8226; STRB (immediate).<BR>&#8226; STRD (immediate).<BR>&#8226; STRH (immediate).<BR>&#8226; VLDM.<BR>&#8226; VSTM.<BR>Updates to the stack pointer by the MSR instruction targeting SP_NS are subject to stack limit checking. Updates to the stack pointer and stack pointer limit by any other MSR instruction are not subject to stack limit checking.<BR>For all other instructions that can update the stack pointer and stack pointer limit, it is IMPLEMENTATION DEFINED whether stack limit checking is performed.<BR>IBJHX When an instruction updates the stack pointer, if it results in a violation of the stack limit, it is the modification of the stack pointer that generates the exception, rather than an access that uses the out-of-range stack pointer.<BR>RDBSG On a violation of a stack limit when an instruction updates the stack pointer:<BR>&#8226; It is IMPLEMENTATION DEFINED whether accesses to addresses equal to or above the stack limit value are performed.<BR>&#8226; It is IMPLEMENTATION DEFINED whether the destination register or registers of load instructions are updated as long as the base register, stack pointer and PC are not modified.<BR>&#8226; Accesses below the stack limit are not performed.<BR>IRRDX CCR.STKOFHFNMIGN controls whether stack limit violations are ignored while executing at a requested execution priority that is negative.<BR>RXCQL It is UNKNOWN whether a stack limit check is performed on any use of the SP that was UNPREDICTABLE in ARMv7-M and ARMv6-M.<BR>See also:<BR>&#8226; Stack pointer on page B4-45.<BR>&#8226; Tail-chaining on page B4-79.