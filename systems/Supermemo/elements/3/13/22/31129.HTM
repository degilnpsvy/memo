B4.23 Exception return</P>
<P>RKPSS The PE begins an exception return when both of the following are true:<BR>&#8226; The PE is in Handler mode.<BR>&#8226; One of the following instructions loads an EXC_RETURN value, 0xFFXXXXXX, into the PC:<BR>&nbsp; &#8213; A POP or LDM that includes loading the PC.<BR>&nbsp; &#8213; An LDR with the PC as a destination.<BR>&nbsp; &#8213; A BX with any register.<BR>When both of these are true, then on detecting an EXC_RETURN value in the PC, the PE unstacks the stack and resumes execution of the code that was preempted by the exception handler.<BR>If an EXC_RETURN value is loaded into the PC by an instruction other than those listed, or from the vector table, the value is treated as an address.<BR>If an EXC_RETURN value is loaded into the PC when the PE is in Thread mode, the value is treated as an address.<BR>RBLMQ In an EXC_RETURN value:</P>
<P>Bits[31:24] These are 0xFF. This is what identifies the value as an EXC_RETURN value.</P>
<P>Bits[23:7] RES1.</P>
<P>Bit [6], S In a PE with the Security Extension, the exception was taken from:<BR>0 Non-secure state. Restore registers from the Non-secure stack.<BR>1 Secure state. Restore registers from the Secure stack.<BR>In a PE without the Security Extension, RES0.</P>
<P>Bit [5], DCRS<BR>In a PE with the Security Extension:<BR>0 Stacking of the additional state context can be skipped.<BR>1 Do not skip any stacking.<BR>In a PE without the Security Extension, RES1.</P>
<P>Bit[4],FType<BR>In a PE with the Main and Floating-point Extensions:<BR>0 The PE allocated space on the stack for FP context.<BR>1 The PE did not allocate space on the stack for FP context.<BR>In a PE without the Main Extension, or with the Main Extension but without the Floating-point Extension, RES1.</P>
<P>Bit[3], Mode<BR>Return to:<BR>0 Handler mode.<BR>1 Thread mode.</P>
<P>Bit[2], SPSEL<BR>Restore registers from the:<BR>0 Main stack.<BR>1 Process stack.</P>
<P>Bit[1] RES0.</P>
<P>Bit[0], ES<BR>In a PE with the Security Extension, the exception was taken to:<BR>0 Non-secure state.<BR>1 Secure state.<BR>In a PE without the Security Extension, RES0.</P>
<P>RTXDW Behavior is UNPREDICTABLE if EXC_RETURN.FType is 0 and the Floating-point Extension is not implemented.<BR>RGBVH Behavior is UNPREDICTABLE if EXC_RETURN[23:7] are not all 1.<BR>RXLCP Behavior is UNPREDICTABLE if any of the following are true and the Security Extension is not implemented:<BR>&#8226; EXC_RETURN.S is 1.<BR>&#8226; EXC_RETURN.DCRS is 0.<BR>&#8226; EXC_RETURN.ES is 1.<BR>RSKSD In a PE without the Main Extension, behavior is UNPREDICTABLE if EXC_RETURN[1] is 1.<BR>RSMFL The following integrity checks on exception return are performed on every exception return:<BR>1. In a PE with the Security Extension, the integrity check that is called the EXC_RETURN.ES validation check, as follows:<BR>&nbsp;&nbsp; &#8226; If the PE was in Non-secure state when EXC_RETURN was loaded into the PC and either EXC_RETURN.DCRS is 0 or EXC_RETURN.ES is 1, an INVER SecureFault is generated and the PE sets EXC_RETURN.ES to 0.<BR>2. A check that the exception number being returned from, as held in the IPSR, is shown as active in the SHCSR or NVIC_IABR&lt;n&gt;. If this check fails:<BR>&nbsp;&nbsp; &#8226; In a PE with the Main Extension, an INVPC UsageFault is generated. If the PE includes the Security Extension, the INVPC UsageFault targets the Security state that the exception return instruction was executed in.<BR>&nbsp;&nbsp; &#8226; In a PE without the Main Extension, a HardFault is generated. If the PE includes the Security Extension, the HardFault targets the Security state that EXC_RETURN.S specifies.<BR>3. In a PE with the Main Extension, an INVPC UsageFault is generated if EXC_RETURN[1] is 1. If the PE includes the Security Extension, the INVPC UsageFault targets the Security state that the exception return instruction was executed in.<BR>4. A check that if the return is to Thread mode, the value restored to the IPSR from the RETPSR is zero, or that if the return is to Handler mode, the value restored to the IPSR from the RETPSR is non zero. If this check fails:<BR>&nbsp;&nbsp; &#8226; In a PE with the Main Extension, an INVPC UsageFault is generated. If the PE includes the Security Extension, the INVPC UsageFault targets the Background Security state.<BR>&nbsp;&nbsp; &#8226; In a PE without the Main Extension, a HardFault is generated. If the PE includes the Security Extension, the HardFault targets the Security state that EXC_RETURN.S specifies.<BR>RJMJC In a PE with the Security Extension, after the EXC_RETURN.ES validation check has been performed on an exception return:<BR>&#8226; If EXC_RETURN.ES is 1, EXC_RETURN.SPSEL is written to CONTROL_S.SPSEL.<BR>&#8226; If EXC_RETURN.ES is 0, EXC_RETURN.SPSEL is written to CONTROL_NS.SPSEL.<BR>RRPGL In a PE with the Security Extension, on an exception return that successfully returns to the Background Security state, with no tail-chaining or failed integrity checks, the Security state is set to EXC_RETURN.S.<BR>ICTWL In a PE with the Security Extension, after a successful exception return to the Background Security state, the PE is in the correct Security state before the next instruction from the background code is executed. This means that in the case where the Background Security state is Secure state, there is no need for an SG instruction at the exception return address.<BR>IRQVB In a PE with the Floating-Point Extension, on exception entry:<BR>1. EXC_RETURN.FType is saved as the inverse of CONTROL.FPCA.<BR>2. CONTROL.FPCA is then cleared to 0 if it was 1, or remains unchanged if it was 0.<BR>On exception return, the inverse of EXC_RETURN[4] is written to CONTROL.FPCA.<BR>RCGML In a PE with the Floating-point Extension, when the following conditions are met on exception return, the PE hardware sets S0-S15 and the FPSCR to zero:<BR>&#8226; CONTROL.FPCA is 1.<BR>&#8226; FPCCR.CLRONRET is 1.<BR>&#8226; FPCCR.LSPACT is 0.<BR>If all of these fields are 1 on exception return, the PE generates an LSERR SecureFault instead.<BR>RXNNG In a PE with the Floating-point Extension, when the following conditions are met on exception return, the PE generates an LSERR SecureFault:<BR>&#8226; EXC_RETURN[4] is 0.<BR>&#8226; The stack contains Secure FP context, that would be unstacked on the return. That is, FPCCR_S.LSPACT is 1.<BR>&#8226; The return is to Non-secure state.<BR>RHCXX In a PE with the Floating-point Extension, if the PE abandons unstacking of the floating-point registers to tail-chain into another exception:<BR>&#8226; If the Security Extension is implemented, the PE must clear to zero any floating-point registers that would have been unstacked.<BR>&#8226; If the Security Extension is not implemented, the floating-point registers that would have been unstacked become UNKNOWN.<BR>See also:<BR>&#8226; Exception handling on page B4-63.