7.4 Execution trace 
<P></P>
<P><BR><FONT class=extract>main(..){/vl.c} : The main function parses the command line arguments passed during start-up and sets up the virtual machine (VM) based on the parameters such as size of ram, size of hard disk, boot disk etc. Once the VM is setup, main() calls main_loop().</FONT> </P>
<P><BR><FONT class=extract>main_loop(...){/vl.c} : Function main_loop initially calls qemu_main_loop_start() and then does infinite looping of cpu_exec_all() and profile_getclock() within a do-while for which the condition is vm_can_run(). The infinite for-loop continues with checking some VM halting situations like qemu_shutdown_requested(), qemu_powerdown_requested(), qemu_vmstop_requested() etc. These halting conditions will not be investigated further.</FONT></P>
<P><BR>qemu_main_loop_start(...){/cpus.c} : Function qemu_main_loop_start sets the variable qemu_system_ready = 1 and calls qemu_cond_broadcast() which basically deals with restarting all thread waiting on a condition variable. This will not be further investigated here. Please. look in to /qemu-thread.c for more details. </P>
<P><BR><FONT class=extract>profile_getclock(...){/qemu-timer.c} : Function profile_getclock basically deals with timing (CLOCK_MONOTONIC) and is not further investigated here.</FONT> <BR></P>
<P>cpu_exec_all(...){/cpus.c} : Function cpu_exec_all basically round robins the available CPUs (cores) in the VM. QEMU can have up to 256 cores. But all these cores will be executed in round robin fashion and thus do not fully mimic a multi-core processor in which all cores run in parallel. Once the next CPU is chosen it&#8217;s state (CPUState *env) is found and the state is passed to qemu_cpu_exec() for continuation of execution of the chosen CPU from its current state, after checking a condition cpu_can_run(). </P>
<P><BR><FONT class=extract>struct CPUState{/target-xyz/cpu.h} : Structure CPUState is architecture specific and basically holds the CPU state like standard registers, segments, FPU state, exception/interrupt handling, processor feature and some emulator specific internal variables and flags.</FONT></P>
<P><BR>qemu_cpu_exec(...){/cpus.c}: Function qemu_cpu_exec basically calls cpu_exec(). </P>
<P><BR><FONT class=extract>cpu_exec(...){/cpu-exec.c}: Function cpu_exec is referred to as the &#8216;main execution loop&#8217;. Here for the first time a translation Block TB is initialized (TranslationBlock *tb) the code then basically continues with handling exceptions. Deep within two nested infinite for-loops one can find tb_find_fast() and tcg_qemu_tb_exec(). tb_find_fast() initiates the search for the next TB for the Guest and then generate the Host code. The generated Host code is then executed through tcg_qemu_tb_exec().</FONT> </P>
<P><BR><FONT class=extract>struct TranslationBlock {/exec-all.h}: Structure TranslationBlock contains the following; PC, CS_BASE, Flags corresponding to this TB, tc_ptr (a pointer to the translated code of this TB), tb_next_offset[2], tb_jmp_offset[2] (both to find the TBs chained to this TB. ie. the TB that follows this TB), *jmp_next[2], *jmp_first (points to the TBs that jump into this TB).</FONT> </P>
<P><BR><FONT class=extract>tb_find_fast(...){/cpu-exec.c} : Function tb_find_fast calls cpu_get_tb_cpu_state() which gets the program counter (PC) form CPUState (env) this PC value is passed to a hash function to get the index of the TB in tb_jmp_cache[] (a hash table). Using this index the next TB is found from tb_jmp_cache.<BR>: 200 <BR>tb = env-&gt;b_jmp_cache[tb_jmp_cache_hash_func(pc)] <BR>:<BR>Thus it can be found that once a TB (for a particular PC value) is found it is stored in tb_jmp_cache so that it can be later reused from tb_jmp_cache using its index found using the hash function (tb_jmp_cache_hash_func(pc)). The code then follows to check the validity of the found TB, if the TB found is invalid then a call is made to tb_find_slow().</FONT> </P>
<P><BR><FONT class=extract>cpu_get_tb_cpu_state(...){/target-xyz/cpu.h}: Function cpu_get_tb_cpu_state basically finds the PC, BP, Flags from the current CPUState (env).</FONT></P>
<P>&nbsp;<BR><FONT class=extract>tb_jmp_cache_hash_func(...){/exec-all.h}: This is a hash function to find offset of TB in tb_jmp_cache using the PC as key.</FONT> </P>
<P><BR>tb_find_slow(...){/cpu-exec.c}: Function tb_find_slow is used when tb_find_fast() fails. This time an attempt to find a TB is made using physical memory mapping. <BR>:142 <BR>phys_pc=get_page_addr_code (env, pc) <BR>:<BR>phys_pc should be the physical memory address of the Guest OS&#8217;s PC, and it is used to find the next TB through a hash function. <BR>:147<BR>h=tb_phys_hash_func(phys_pc) <BR>ptb1 = &amp;tb_phys_hash[h]; <BR>: <BR>The above ptb1 is supposed to be the next TB but its validity is checked in the code that follows. If no valid TB is found then new TB is generated through tb_gen_code() else if a valid TB was found then its quickly added to tb_jmp_cache at an index found by tb_jmp_cache_hash_func(). <BR>:181 <BR>env-&gt;tb_jmp_cache[tb_jmp_cache_hash_func(pc)] = tb; <BR>: <BR></P>
<P><FONT class=extract>tb_gen_code(...){/exec.c}: Function tb_gen_code starts with allocating <BR>( tb_alloc() ) a new TB, the PC for the TB is found from the PC of CPUState using get_page_addr_code() . <BR>:957 <BR>phys_pc = get_page_addr_code(env, pc); <BR>tb = tb_alloc(pc); <BR>:<BR>When this is done a call is made to cpu_gen_code() followed by a call to tb_link_page() which adds a new TB and links it to physical page tables.<BR></FONT></P>
<P>cpu_gen_code(...){translate-all.c}: function cpu_gen_code initiates the actual code generation. In which there is a chain of subsequent function calls given as below. <BR></P>
<P><FONT class=extract>gen_intermediate_code(){/target-xyz/translate.c}&#61664; gen_intermediate_code_internal(){/target-xyz/translate.c &#61664; disas_insn(){/target-xyz/translate.c} <BR>Function disas_ins does the actual conversion of Guest code into TCG ops through a long switch case of target(Guest) instruction and corresponding group of functions that end-up adding TCG ops to code_buff. After the TCG ops are generated a call to tcg_gen_code() is made.</FONT> <BR></P>
<P><FONT class=extract>tcg_gen_code(...){/tcg/tcg.c}: Function tcg_gen_code converts TCG ops to Host specific code. Check the previous section &#8216;TCG- Dynamic Translator&#8217; to find out more on the functioning of TCG.</FONT> <BR></P>
<P><FONT class=extract>#define tcg_qemu_tb_exec(...){/tcg/tcg.g}: Once the next TB is obtained, through all the processes as detailed above, the TB need to be executed. The TB is executed through tcg_qemu_tb_exec() in /exec-cpu.c. <BR>:644 <BR>next_tb = tcg_qemu_tb_exec(tc_ptr) <BR>:<BR>Infact tcg_qemu_tb_exec() is a macro function defined in /tcg/tcg.h<BR>:484 (in /tcg/tcg.h) <BR>extern uint8_t code_gen_prologue[]; <BR>:<BR>#define tcg_qemu_tb_exec(tb_ptr) ((long REGPARM(*)(void *)) code_gen_prologue)(tb_ptr) <BR>: <BR>To understand what happens in the above line of code, a good knowledge of function pointers is required. The following lines will elaborate on understanding this. <BR>It is well known that (int) var will explicitly convert a variable to type int. In the same sense ((long REGPARM (*)(void *)) is a type - pointer to a function that takes in void * parameter and returns a long. Here REGPARAM(*) is a GCC compiler-directive that causes parameter of a function to be passed through Registers instead of through the Stack.&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;... <BR>The intention of ((long REGPARM (*)(void *)) would have been clear if the functions name appeared in it as ((long REGPARM (*func_name)(void *)). However it was used here without a function name (but serves the purpose). When an array name is used, the array base address is obtained, and thus points (pointer) to the array. Therefore (function_pointer) array_name will cast the array pointer as function pointer.<BR>A function is called through its pointer as (*pointer_to_func)(args) therefore ((long REGPARM (*)(void *))code_gen_prologue)(tc_ptr) does a function call. <BR>It is seen that a &#8216;*' is missing in the above function call, but one can test to see that (*pointer_to_func)(args) and (pointer_to_func)(args) are equivalent. <BR>So the above explanation clarifies that code_gen_prologue, an array, is cast as function and executed. code_gen_prologue holds in it a function in binary form that takes in an argument tc_ptr and return a long which is the next TB. The function in code_gen_prologue is the Function Prologue (discussed in a previous section) that transfers control to the generated Host code pointed to by tc_ptr.</FONT></P>
<P></P>
<P>&nbsp;