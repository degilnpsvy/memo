D2.2.9 <FONT class=extract>CCR, Configuration and Control Register</FONT> 
<P></P>
<P><FONT class=extract>The CCR characteristics are:<BR>Purpose: Sets or returns configuration and control data.<BR>Usage constraints: Privileged access permitted only. Unprivileged accesses generate a BusFault.<BR>&nbsp; This register is word accessible only. Halfword and byte accesses are UNPREDICTABLE.<BR>Configurations: This register is always implemented.<BR>Attributes: 32-bit read/write register located at 0xE000ED14.<BR>&nbsp; Secure software can access the Non-secure view of this register via CCR_NS located at 0xE002ED14. The location 0xE002ED14 is RES0 to software executing in Non-secure state and the debugger.<BR>&nbsp; This register is banked between Security states on a bit by bit basis.</FONT></P>
<P>The CCR bit assignments are:</P>
<P>Bits [31:19]<BR>Reserved, RES0.</P>
<P><FONT class=extract>BP, bit [18]<BR>Branch prediction enable. Enables program flow prediction for the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 Program flow prediction disabled for the selected Security state.<BR>1 Program flow prediction enabled for the selected Security state.<BR>If program flow prediction cannot be disabled, this bit is RAO/WI. If the program flow prediction is not supported, this bit is RAZ/WI.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>IC, bit [17]<BR>Instruction cache enable. This is a global enable bit for instruction caches in the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 Instruction caches disabled for the selected Security state.<BR>1 Instruction caches enabled for the selected Security state.<BR>If the PE does not implement instruction caches, this bit is RAZ/WI.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>DC, bit [16]<BR>Data cache enable. Enables data caching of all data accesses to Normal memory for the selected Security state.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 Data caching disabled for the selected Security state.<BR>1 Data caching enabled for the selected Security state.<BR>If the PE does not implement data caches, this bit is RAZ/WI.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P>Bits [15:11]<BR>Reserved, RES0.</P>
<P><FONT class=extract>STKOFHFNMIGN, bit [10]<BR>Stack overflow in HardFault and NMI ignore. Controls the effect of a stack limit violation while executing at a requested priority less than 0.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 Stack limit faults not ignored.<BR>1 Stack limit faults at requested priorities of less than 0 ignored.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P>Bit [9]<BR>Reserved, RES1.</P>
<P><FONT class=extract>BFHFNMIGN, bit [8]<BR>BusFault in HardFault or NMI ignore. Determines the effect of precise BusFaults on handlers running at a requested priority less than 0.<BR>This bit is not banked between Security states.<BR>The possible values of this bit are:<BR>0 Precise BusFaults not ignored.<BR>1 Precise BusFaults at requested priorities of less than 0 ignored.<BR>If AIRCR.BFHFNMINS is 0, this bit is read only from Non-secure state.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P>Bits [7:5]<BR>Reserved, RES0.</P>
<P><FONT class=extract>DIV_0_TRP, bit [4]<BR>Divide by zero trap. Controls the generation of a DIVBYZERO UsageFault when attempting to perform integer division by zero.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 DIVBYZERO UsageFault generation disabled.<BR>1 DIVBYZERO UsageFault generation enabled.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P><FONT class=extract>UNALIGN_TRP, bit [3]<BR>Unaligned trap. Controls the trapping of unaligned word or halfword accesses.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 Unaligned accesses permitted from LDR, LDRH, STR, and STRH.<BR>1 Any unaligned transaction generates an UNALIGNED UsageFault.<BR>Unaligned load/store multiples and atomic/exclusive accesses always generate an UNALIGNED UsageFault.<BR>If the Main Extension is not implemented, this bit is RES1.<BR>This bit resets to zero on a Warm reset if the Main Extension is implemented.</FONT></P>
<P>Bit [2]<BR>Reserved, RES0.</P>
<P><FONT class=extract>USERSETMPEND, bit [1]<BR>User set main pending. Determines whether unprivileged accesses are permitted to pend interrupts via the STIR.<BR>This bit is banked between Security states.<BR>The possible values of this bit are:<BR>0 Unprivileged accesses to the STIR generate a fault.<BR>1 Unprivileged accesses to the STIR are permitted.<BR>If the Main Extension is not implemented, this bit is RES0.<BR>This bit resets to zero on a Warm reset.</FONT></P>
<P>Bit [0]<BR>Reserved, RES1.