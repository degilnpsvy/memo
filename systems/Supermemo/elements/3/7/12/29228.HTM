/**<BR>&nbsp;*&nbsp;__blocking_notifier_call_chain - Call functions in a blocking notifier chain<BR>&nbsp;*&nbsp;@nh: Pointer to head of the blocking notifier chain<BR>&nbsp;*&nbsp;@val: Value passed unmodified to notifier function<BR>&nbsp;*&nbsp;@v: Pointer passed unmodified to notifier function<BR>&nbsp;*&nbsp;@nr_to_call: See comment for notifier_call_chain.<BR>&nbsp;*&nbsp;@nr_calls: See comment for notifier_call_chain.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Calls each function in a notifier chain in turn.&nbsp; The functions<BR>&nbsp;*&nbsp;run in a process context, so they are allowed to block.<BR>&nbsp;*<BR>&nbsp;*&nbsp;If the return value of the notifier can be and'ed<BR>&nbsp;*&nbsp;with %NOTIFY_STOP_MASK then blocking_notifier_call_chain()<BR>&nbsp;*&nbsp;will return immediately, with the return value of<BR>&nbsp;*&nbsp;the notifier function which halted execution.<BR>&nbsp;*&nbsp;Otherwise the return value is the return value<BR>&nbsp;*&nbsp;of the last notifier function called.<BR>&nbsp;*/<BR>int __blocking_notifier_call_chain(struct blocking_notifier_head *nh,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long val, void *v,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nr_to_call, int *nr_calls)<BR>{<BR>&nbsp;int ret = NOTIFY_DONE;
<P></P>
<P>&nbsp;/*<BR>&nbsp; * We check the head outside the lock, but if this access is<BR>&nbsp; * racy then it does not matter what the result of the test<BR>&nbsp; * is, we re-check the list after having taken the lock anyway:<BR>&nbsp; */<BR>&nbsp;if (rcu_access_pointer(nh-&gt;head)) {<BR>&nbsp;&nbsp;down_read(&amp;nh-&gt;rwsem);<BR>&nbsp;&nbsp;ret = notifier_call_chain(&amp;nh-&gt;head, val, v, nr_to_call,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nr_calls);<BR>&nbsp;&nbsp;up_read(&amp;nh-&gt;rwsem);<BR>&nbsp;}<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(__blocking_notifier_call_chain);