/**<BR>&nbsp;* kref_sub - subtract a number of refcounts for object.<BR>&nbsp;* @kref: object.<BR>&nbsp;* @count: Number of recounts to subtract.<BR>&nbsp;* @release: pointer to the function that will clean up the object when the<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last reference to the object is released.<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This pointer is required, and it is not acceptable to pass kfree]<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in as this function.&nbsp; If the caller does pass kfree to this<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function, you will be publicly mocked mercilessly by the kref<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maintainer, and anyone else who happens to notice it.&nbsp; You have<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; been warned.<BR>&nbsp;*<BR>&nbsp;* Subtract @count from the refcount, and if 0, call release().<BR>&nbsp;* Return 1 if the object was removed, otherwise return 0.&nbsp; Beware, if this<BR>&nbsp;* function returns 0, you still can not count on the kref from remaining in<BR>&nbsp;* memory.&nbsp; Only use the return value if you want to see if the kref is now<BR>&nbsp;* gone, not present.<BR>&nbsp;*/<BR>static inline int kref_sub(struct kref *kref, unsigned int count,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*release)(struct kref *kref))<BR>{<BR>&nbsp;WARN_ON(release == NULL); 
<P></P>
<P>&nbsp;if (atomic_sub_and_test((int) count, &amp;kref-&gt;refcount)) {<BR>&nbsp;&nbsp;release(kref);<BR>&nbsp;&nbsp;return 1;<BR>&nbsp;}<BR>&nbsp;return 0;<BR>}