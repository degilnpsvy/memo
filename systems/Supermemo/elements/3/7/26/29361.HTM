<H1 lang=en id=firstHeading class=firstHeading>Read-copy-update</H1>
<DIV id=bodyContent class=mw-body-content>
<DIV id=siteSub>From Wikipedia, the free encyclopedia</DIV>
<DIV id=contentSub></DIV></DIV>
<TABLE role=presentation class="metadata plainlinks ambox ambox-content ambox-multiple_issues compact-ambox">
<TBODY>
<TR>
<TD class=mbox-image>
<DIV style="WIDTH: 52px"><IMG alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Ambox_important.svg/40px-Ambox_important.svg.png" width=40 height=40 data-file-height="40" data-file-width="40" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Ambox_important.svg/60px-Ambox_important.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Ambox_important.svg/80px-Ambox_important.svg.png 2x"></DIV></TD>
<TD class=mbox-text>
<DIV class=mw-collapsible style="WIDTH: 95%; MARGIN: 0.2em 0px"></DIV></TD></TR></TBODY></TABLE>
<TABLE role=presentation class="metadata plainlinks ambox ambox-content ambox-multiple_issues compact-ambox">
<TBODY>
<TR>
<TD class=mbox-text>
<DIV class=mw-collapsible style="WIDTH: 95%; MARGIN: 0.2em 0px"><SPAN class=mbox-text-span><B>This article has multiple issues.</B> Please help <B><A class="external text" href="https://en.wikipedia.org/w/index.php?title=Read-copy-update&amp;action=edit">improve it</A></B> or discuss these issues on the <B><A title=Talk:Read-copy-update href="https://en.wikipedia.org/wiki/Talk:Read-copy-update">talk page</A></B>. <SMALL><I>(<A title="Help:Maintenance template removal" href="https://en.wikipedia.org/wiki/Help:Maintenance_template_removal">Learn how and when to remove these template messages</A>)</I></SMALL></SPAN> 
<DIV class=mw-collapsible-content style="MARGIN-TOP: 0.3em">
<TABLE role=presentation class="metadata plainlinks ambox ambox-style ambox-overly_detailed">
<TBODY>
<TR>
<TD class=mbox-text><SPAN class=mbox-text-span>This article <B>may contain an excessive amount of <A title="Wikipedia:What Wikipedia is not" href="https://en.wikipedia.org/wiki/Wikipedia:What_Wikipedia_is_not#Wikipedia_is_not_an_indiscriminate_collection_of_information">intricate detail</A> that may only interest a specific audience</B>. <SMALL><I>(November 2015)</I></SMALL> </SPAN></TD></TR></TBODY></TABLE>
<TABLE role=presentation class="metadata plainlinks ambox ambox-content ambox-peacock">
<TBODY>
<TR>
<TD class=mbox-text><SPAN class=mbox-text-span>This article contains wording that <B><A title="Wikipedia:Manual of Style/Words to watch" href="https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style/Words_to_watch#Puffery">promotes the subject in a subjective manner</A> without imparting real information</B>. <SMALL><I>(November 2015)</I></SMALL> </SPAN></TD></TR></TBODY></TABLE>
<TABLE role=presentation class="metadata plainlinks ambox ambox-content ambox-COI">
<TBODY>
<TR>
<TD class=mbox-text><SPAN class=mbox-text-span><B>A major contributor to this article appears to have a <A title="Wikipedia:Conflict of interest" href="https://en.wikipedia.org/wiki/Wikipedia:Conflict_of_interest">close connection</A> with its subject.</B> <SMALL><I>(November 2015)</I></SMALL> </SPAN></TD></TR></TBODY></TABLE>
<TABLE role=presentation class="metadata plainlinks ambox ambox-style ambox-technical">
<TBODY>
<TR>
<TD class=mbox-text><SPAN class=mbox-text-span>This article <B>may be too <A title=wikt:technical class=extiw href="https://en.wiktionary.org/wiki/technical#Adjective">technical</A> for most readers to understand</B>. <SMALL><I>(November 2015)</I></SMALL> </SPAN></TD></TR></TBODY></TABLE></DIV></DIV></TD></TR></TBODY></TABLE>
<P>In computer <A title="Operating system" href="https://en.wikipedia.org/wiki/Operating_system">operating systems</A>, <B>read-copy-update</B> (<B>RCU</B>) is a <A title="Synchronization (computer science)" href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization</A> mechanism implementing a kind of <A title="Mutual exclusion" href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutual exclusion</A><SUP id=cite_ref-1 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-1">[note 1]</A></SUP> that can sometimes be used as an alternative to a <A title="Readers-writer lock" class=mw-redirect href="https://en.wikipedia.org/wiki/Readers-writer_lock">readers-writer lock</A>. It allows extremely low overhead, <A title="Non-blocking synchronization" class=mw-redirect href="https://en.wikipedia.org/wiki/Non-blocking_synchronization">wait-free</A> reads. However, RCU updates can be expensive, as they must leave the old versions of the data structure in place to accommodate pre-existing readers. These old versions are reclaimed after all pre-existing readers finish their accesses.</P>
<P></P>
<DIV id=toc class=toc>
<DIV id=toctitle>
<H2>Contents</H2></DIV></DIV>
<DIV id=toc class=toc>
<UL>
<LI class="toclevel-1 tocsection-1"><A href="https://en.wikipedia.org/wiki/Read-copy-update#Overview"><SPAN class=tocnumber>1</SPAN> <SPAN class=toctext>Overview</SPAN></A> 
<LI class="toclevel-1 tocsection-2"><A href="https://en.wikipedia.org/wiki/Read-copy-update#Uses"><SPAN class=tocnumber>2</SPAN> <SPAN class=toctext>Uses</SPAN></A> 
<LI class="toclevel-1 tocsection-3"><A href="https://en.wikipedia.org/wiki/Read-copy-update#Advantages_and_disadvantages"><SPAN class=tocnumber>3</SPAN> <SPAN class=toctext>Advantages and disadvantages</SPAN></A> 
<LI class="toclevel-1 tocsection-4"><A href="https://en.wikipedia.org/wiki/Read-copy-update#Patents"><SPAN class=tocnumber>4</SPAN> <SPAN class=toctext>Patents</SPAN></A> 
<LI class="toclevel-1 tocsection-5"><A href="https://en.wikipedia.org/wiki/Read-copy-update#Sample_RCU_interface"><SPAN class=tocnumber>5</SPAN> <SPAN class=toctext>Sample RCU interface</SPAN></A> 
<LI class="toclevel-1 tocsection-6"><A href="https://en.wikipedia.org/wiki/Read-copy-update#Simple_implementation"><SPAN class=tocnumber>6</SPAN> <SPAN class=toctext>Simple implementation</SPAN></A> 
<LI class="toclevel-1 tocsection-7"><A href="https://en.wikipedia.org/wiki/Read-copy-update#Analogy_with_reader-writer_locking"><SPAN class=tocnumber>7</SPAN> <SPAN class=toctext>Analogy with reader-writer locking</SPAN></A> 
<LI class="toclevel-1 tocsection-8"><A href="https://en.wikipedia.org/wiki/Read-copy-update#Name"><SPAN class=tocnumber>8</SPAN> <SPAN class=toctext>Name</SPAN></A> 
<LI class="toclevel-1 tocsection-9"><A href="https://en.wikipedia.org/wiki/Read-copy-update#History"><SPAN class=tocnumber>9</SPAN> <SPAN class=toctext>History</SPAN></A> 
<LI class="toclevel-1 tocsection-10"><A href="https://en.wikipedia.org/wiki/Read-copy-update#See_also"><SPAN class=tocnumber>10</SPAN> <SPAN class=toctext>See also</SPAN></A> 
<LI class="toclevel-1 tocsection-11"><A href="https://en.wikipedia.org/wiki/Read-copy-update#Notes"><SPAN class=tocnumber>11</SPAN> <SPAN class=toctext>Notes</SPAN></A> 
<LI class="toclevel-1 tocsection-12"><A href="https://en.wikipedia.org/wiki/Read-copy-update#References"><SPAN class=tocnumber>12</SPAN> <SPAN class=toctext>References</SPAN></A> 
<LI class="toclevel-1 tocsection-13"><A href="https://en.wikipedia.org/wiki/Read-copy-update#External_links"><SPAN class=tocnumber>13</SPAN> <SPAN class=toctext>External links</SPAN></A></LI></UL></DIV>
<P></P>
<H2><SPAN id=Overview class=mw-headline>Overview</SPAN></H2>
<DIV class=thumbinner style="WIDTH: 442px"><A class=image href="https://en.wikipedia.org/wiki/File:Read-Copy_Update_Insertion_Procedure.svg"><IMG class=thumbimage alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/ca/Read-Copy_Update_Insertion_Procedure.svg/440px-Read-Copy_Update_Insertion_Procedure.svg.png" width=440 height=324 data-file-height="449" data-file-width="610" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/c/ca/Read-Copy_Update_Insertion_Procedure.svg/660px-Read-Copy_Update_Insertion_Procedure.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/c/ca/Read-Copy_Update_Insertion_Procedure.svg/880px-Read-Copy_Update_Insertion_Procedure.svg.png 2x"></A> 
<DIV class=thumbcaption>
<DIV class=magnify></DIV></DIV></DIV>
<DIV class="thumb tright">
<DIV class=thumbinner style="WIDTH: 442px">
<DIV class=thumbcaption>Read-copy-update insertion procedure. A thread allocates a structure with three fields, then sets the global pointer <SPAN style="FONT-FAMILY: monospace, monospace">gptr</SPAN> to point to this structure.</DIV></DIV></DIV>
<P>A key property of RCU is that readers can access a data structure even when it is in the process of being updated: RCU updaters cannot block readers or force them to retry their accesses. This overview starts by showing how data can be safely inserted into and deleted from linked structures despite concurrent readers. The first diagram on the right depicts a four-state insertion procedure, with time advancing from left to right.</P>
<P>The first state shows a global pointer named <SPAN style="FONT-FAMILY: monospace, monospace">gptr</SPAN> that is initially <SPAN style="FONT-FAMILY: monospace, monospace">NULL</SPAN>, colored red to indicate that it might be accessed by a reader at any time, thus requiring updaters to take care. Allocating memory for a new structure transitions to the second state. This structure has indeterminate state (indicated by the question marks) but is inaccessible to readers (indicated by the green color). Because the structure is inaccessible to readers, the updater may carry out any desired operation without fear of disrupting concurrent readers. Initializing this new structure transitions to the third state, which shows the initialized values of the structure's fields. Assigning a reference to this new structure to <SPAN style="FONT-FAMILY: monospace, monospace">gptr</SPAN> transitions to the fourth and final state. In this state, the structure is accessible to readers, and is therefore colored red. The <SPAN style="FONT-FAMILY: monospace, monospace">rcu_assign_pointer</SPAN> primitive is used to carry out this assignment, and ensures that the assignment is atomic in the sense that concurrent readers will either see a <SPAN style="FONT-FAMILY: monospace, monospace">NULL</SPAN> pointer or a valid pointer to the new structure, but not some mash-up of the two values. Additional properties of <SPAN style="FONT-FAMILY: monospace, monospace">rcu_assign_pointer</SPAN> are described later in this article.</P>
<DIV class="thumb tright">
<DIV class=thumbinner style="WIDTH: 442px"><A class=image href="https://en.wikipedia.org/wiki/File:Read-Copy_Update_Deletion_Procedure.svg"><IMG class=thumbimage alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Read-Copy_Update_Deletion_Procedure.svg/440px-Read-Copy_Update_Deletion_Procedure.svg.png" width=440 height=342 data-file-height="256" data-file-width="329" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Read-Copy_Update_Deletion_Procedure.svg/660px-Read-Copy_Update_Deletion_Procedure.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Read-Copy_Update_Deletion_Procedure.svg/880px-Read-Copy_Update_Deletion_Procedure.svg.png 2x"></A> 
<DIV class=thumbcaption>
<DIV class=magnify></DIV></DIV></DIV></DIV>
<DIV class="thumb tright">
<DIV class=thumbinner style="WIDTH: 442px">
<DIV class=thumbcaption>Read-copy-update deletion procedure</DIV></DIV></DIV>
<P>This procedure demonstrates how new data may be inserted into a linked data structure even though readers are concurrently traversing the data structure before, during, and after the insertion. The second diagram on the right depicts a four-state deletion procedure, again with time advancing from left to right.</P>
<P>The first state shows a linked list containing elements <SPAN class="texhtml mvar" style="FONT-STYLE: italic">A</SPAN>, <SPAN class="texhtml mvar" style="FONT-STYLE: italic">B</SPAN>, and <SPAN class="texhtml mvar" style="FONT-STYLE: italic">C</SPAN>. All three elements are colored red to indicate that an RCU reader might reference any of them at any time. Using <SPAN style="FONT-FAMILY: monospace, monospace">list_del_rcu</SPAN> to remove element <SPAN class="texhtml mvar" style="FONT-STYLE: italic">B</SPAN> from this list transitions to the second state. Note that the link from element B to C is left intact in order to allow readers currently referencing element <SPAN class="texhtml mvar" style="FONT-STYLE: italic">B</SPAN> to traverse the remainder of the list. Readers accessing the link from element <SPAN class="texhtml mvar" style="FONT-STYLE: italic">A</SPAN> will either obtain a reference to element <SPAN class="texhtml mvar" style="FONT-STYLE: italic">B</SPAN> or element <SPAN class="texhtml mvar" style="FONT-STYLE: italic">C</SPAN>, but either way, each reader will see a valid and correctly formatted linked list. Element <SPAN class="texhtml mvar" style="FONT-STYLE: italic">B</SPAN> is now colored yellow to indicate that while pre-existing readers might still have a reference to element <SPAN class="texhtml mvar" style="FONT-STYLE: italic">B</SPAN>, new readers have no way to obtain a reference. A wait-for-readers operation transitions to the third state. Note that this wait-for-readers operation need only wait for pre-existing readers, but not new readers. Element <SPAN class="texhtml mvar" style="FONT-STYLE: italic">B</SPAN> is now colored green to indicate that readers can no longer be referencing it. Therefore, it is now safe for the updater to free element <SPAN class="texhtml mvar" style="FONT-STYLE: italic">B</SPAN>, thus transitioning to the fourth and final state.</P>
<P>It is important to reiterate that in the second state different readers can see two different versions of the list, either with or without element <SPAN class="texhtml mvar" style="FONT-STYLE: italic">B</SPAN>. In other words, <FONT class=extract>RCU provides coordination in space (different versions of the list) as well as in time (different states in the deletion procedures)<FONT class=extract>.</FONT></FONT> This is in stark contrast with more traditional synchronization primitives such as <A title="Locking (computer science)" class=mw-redirect href="https://en.wikipedia.org/wiki/Locking_%28computer_science%29">locking</A> or <A title="Atomic transaction" class=mw-redirect href="https://en.wikipedia.org/wiki/Atomic_transaction">transactions</A> that coordinate in time, but not in space.</P>
<P>This procedure demonstrates how old data may be removed from a linked data structure even though readers are concurrently traversing the data structure before, during, and after the deletion. Given insertion and deletion, a wide variety of data structures can be implemented using RCU.</P>
<P><FONT class=extract>RCU's readers execute within <I>read-side critical sections</I>, which are normally delimited by <SPAN style="FONT-FAMILY: monospace, monospace">rcu_read_lock</SPAN> and <SPAN style="FONT-FAMILY: monospace, monospace">rcu_read_unlock</SPAN>. Any statement that is not within an RCU read-side critical section is said to be in a <I>quiescent state</I>, and such statements are not permitted to hold references to RCU-protected data structures, nor is the wait-for-readers operation required to wait for threads in quiescent states. Any time period during which each thread resides at least once in a quiescent state is called a <I>grace period</I>. By definition, any RCU read-side critical section in existence at the beginning of a given grace period must complete before the end of that grace period, which constitutes the fundamental guarantee provided by RCU. In addition, the wait-for-readers operation must wait for at least one grace period to elapse. It turns out that this guarantee can be provided with extremely small read-side overheads, in fact, in the limiting case that is actually realized by server-class Linux-kernel builds, the read-side overhead is exactly zero.<SUP id=cite_ref-2 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-2">[1]</A></SUP></FONT></P>
<P><FONT class=extract>RCU's fundamental guarantee may be used by splitting updates into <I>removal</I> and <I>reclamation</I> phases. The removal phase removes references to data items within a data structure (possibly by replacing them with references to new versions of these data items), and can run concurrently with RCU read-side critical sections. The reason that it is safe to run the removal phase concurrently with RCU readers is the semantics of modern CPUs guarantee that readers will see either the old or the new version of the data structure rather than a partially updated reference. Once a grace period has elapsed, there can no longer be any readers referencing the old version, so it is then safe for the reclamation phase to free (<I>reclaim</I>) the data items that made up that old version.<SUP id=cite_ref-3 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-3">[2]</A></SUP></FONT></P>
<P><FONT class=extract>Splitting an update into removal and reclamation phases allows the updater to perform the removal phase immediately, and to defer the reclamation phase until all readers active during the removal phase have completed, in other words, until a grace period has elapsed.<SUP id=cite_ref-4 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-4">[note 2]</A></SUP></FONT></P>
<P><FONT class=extract>So the typical RCU update sequence goes something like the following:<SUP id=cite_ref-5 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-5">[3]</A></SUP></FONT></P>
<OL>
<LI><FONT class=extract>Ensure that all readers accessing RCU-protected data structures carry out their references from within an RCU read-side critical section. </FONT>
<LI><FONT class=extract>Remove pointers to a data structure, so that subsequent readers cannot gain a reference to it. </FONT>
<LI><FONT class=extract>Wait for a grace period to elapse, so that all previous readers (which might still have pointers to the data structure removed in the prior step) will have completed their RCU read-side critical sections. </FONT>
<LI><FONT class=extract>At this point, there cannot be any readers still holding references to the data structure, so it now may safely be reclaimed (e.g., freed).<SUP id=cite_ref-6 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-6">[note 3]</A></SUP></FONT></LI></OL>
<P><FONT class=extract>In the above procedure (which matches the earlier diagram), the updater is performing both the removal and the reclamation step, but it is often helpful for an entirely different thread to do the reclamation. Reference counting can be used to let the reader perform removal so, even if the same thread performs both the update step (step (2) above) and the reclamation step (step (4) above), it is often helpful to think of them separately.</FONT></P>
<H2><SPAN id=Uses class=mw-headline>Uses</SPAN></H2>
<P>As of early 2008, there were almost 2,000 uses of the RCU API within the Linux kernel<SUP id=cite_ref-7 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-7">[4]</A></SUP> including the networking protocol stacks<SUP id=cite_ref-8 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-8">[5]</A></SUP> and the memory-management system.<SUP id=cite_ref-9 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-9">[6]</A></SUP> As of March 2014, there were more than 9,000 uses.<SUP id=cite_ref-10 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-10">[7]</A></SUP> Since 2006, researchers have applied RCU and similar techniques to a number of problems, including management of metadata used in dynamic analysis,<SUP id=cite_ref-11 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-11">[8]</A></SUP> managing the lifetime of clustered objects,<SUP id=cite_ref-12 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-12">[9]</A></SUP> managing object lifetime in the <A title=K42 href="https://en.wikipedia.org/wiki/K42">K42</A> research operating system,<SUP id=cite_ref-13 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-13">[10]</A></SUP><SUP id=cite_ref-14 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-14">[11]</A></SUP> and optimizing <A title="Software transactional memory" href="https://en.wikipedia.org/wiki/Software_transactional_memory">software transactional memory</A> implementations.<SUP id=cite_ref-15 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-15">[12]</A></SUP><SUP id=cite_ref-16 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-16">[13]</A></SUP> <A title="Dragonfly BSD" class=mw-redirect href="https://en.wikipedia.org/wiki/Dragonfly_BSD">Dragonfly BSD</A> uses a technique similar to RCU that most closely resembles Linux's Sleepable RCU (SRCU) implementation.</P>
<H2><SPAN id=Advantages_and_disadvantages class=mw-headline><FONT class=extract>Advantages and disadvantages</FONT></SPAN></H2>
<P><FONT class=extract>The ability to wait until all readers are done allows RCU readers to use much lighter-weight synchronization&#8212;in some cases, absolutely no synchronization at all. In contrast, in more conventional lock-based schemes, readers must use heavy-weight synchronization in order to prevent an updater from deleting the data structure out from under them. This is because lock-based updaters typically update data items in place, and must therefore exclude readers. In contrast, RCU-based updaters typically take advantage of the fact that writes to single aligned pointers are atomic on modern CPUs, allowing atomic insertion, removal, and replacement of data items in a linked structure without disrupting readers. Concurrent RCU readers can then continue accessing the old versions, and can dispense with the atomic read-modify-write instructions, memory barriers, and cache misses that are so expensive on modern </FONT><A title="Symmetric multiprocessing" href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing"><FONT class=extract>SMP</FONT></A><FONT class=extract> computer systems, even in absence of lock contention.<SUP id=cite_ref-17 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-17">[14]</A></SUP><SUP id=cite_ref-18 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-18">[15]</A></SUP> The lightweight nature of RCU's read-side primitives provides additional advantages beyond excellent performance, scalability, and real-time response. For example, they provide immunity to most deadlock and livelock conditions.<SUP id=cite_ref-19 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-19">[note 4]</A></SUP></FONT></P>
<P><FONT class=extract>Of course, RCU also has disadvantages. For example, RCU is a specialized technique that works best in situations with mostly reads and few updates, but is often less applicable to update-only workloads. For another example, although the fact that RCU readers and updaters may execute concurrently is what enables the lightweight nature of RCU's read-side primitives, some algorithms may not be amenable to read/update concurrency.</FONT></P>
<P><FONT class=extract>Despite well over a decade of experience with RCU, the exact extent of its applicability is still a research topic.</FONT></P>
<H2><SPAN id=Patents class=mw-headline>Patents</SPAN></H2>
<P>The technique is covered by <A title="United States Patent and Trademark Office" href="https://en.wikipedia.org/wiki/United_States_Patent_and_Trademark_Office">U.S.</A> <A title="Software patent" href="https://en.wikipedia.org/wiki/Software_patent">software patent</A> 5,442,758, issued August 15, 1995 and assigned to <A title="Sequent Computer Systems" href="https://en.wikipedia.org/wiki/Sequent_Computer_Systems">Sequent Computer Systems</A>, as well as by 5,608,893, 5,727,209, 6,219,690, and 6,886,162. The now-expired US Patent 4,809,168 covers a closely related technique. RCU is also the topic of one claim in the <A title="SCO v. IBM" class=mw-redirect href="https://en.wikipedia.org/wiki/SCO_v._IBM#Increased_damages_claims.2C_and_read-copy-update_claims">SCO v. IBM</A> <A title=Lawsuit href="https://en.wikipedia.org/wiki/Lawsuit">lawsuit</A>.</P>
<H2><SPAN id=Sample_RCU_interface class=mw-headline>Sample RCU interface</SPAN></H2>
<P>RCU is available in a number of operating systems, and was added to the <A title="Linux kernel" href="https://en.wikipedia.org/wiki/Linux_kernel">Linux kernel</A> in October 2002. User-level implementations such as <A class="external text" href="http://lttng.org/urcu" rel=nofollow>liburcu</A> are also available.<SUP id=cite_ref-20 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-20">[16]</A></SUP></P>
<P>The implementation of RCU in version 2.6 of the Linux kernel is among the better-known RCU implementations, and will be used as an inspiration for the RCU API in the remainder of this article. The core API (<A title="Application Programming Interface" class=mw-redirect href="https://en.wikipedia.org/wiki/Application_Programming_Interface">Application Programming Interface</A>) is quite small:<SUP id=cite_ref-21 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-21">[17]</A></SUP></P>
<UL>
<LI>rcu_read_lock(): Marks an RCU-protected data structure so that it won't be reclaimed for the full duration of that critical section. 
<LI>rcu_read_unlock(): Used by a reader to inform the reclaimer that the reader is exiting an RCU read-side critical section. Note that RCU read-side critical sections may be nested and/or overlapping. 
<LI>synchronize_rcu(): It blocks until all pre-existing RCU read-side critical sections on all CPUs have completed. Note that <CODE>synchronize_rcu</CODE> will <I>not</I> necessarily wait for any subsequent RCU read-side critical sections to complete. For example, consider the following sequence of events:</LI></UL><PRE>                 CPU 0                  CPU 1                 CPU 2
             ----------------- ------------------------- ---------------
         1.  rcu_read_lock()
         2.                    enters synchronize_rcu()
         3.                                               rcu_read_lock()
         4.  rcu_read_unlock()
         5.                     exits synchronize_rcu()
         6.                                              rcu_read_unlock()
</PRE>
<DL>
<DD>Since <CODE>synchronize_rcu</CODE> is the API that must figure out when readers are done, its implementation is key to RCU. For RCU to be useful in all but the most read-intensive situations, <CODE>synchronize_rcu</CODE>'s overhead must also be quite small.</DD></DL>
<DL>
<DD>Alternatively, instead of blocking, synchronize_rcu may register a callback to be invoked after all ongoing RCU read-side critical sections have completed. This callback variant is called <CODE>call_rcu</CODE> in the Linux kernel.</DD></DL>
<UL>
<LI>rcu_assign_pointer(): The updater uses this function to assign a new value to an RCU-protected pointer, in order to safely communicate the change in value from the updater to the reader. This function returns the new value, and also executes any <A title="Memory barrier" href="https://en.wikipedia.org/wiki/Memory_barrier">memory barrier</A> instructions required for a given CPU architecture. Perhaps more importantly, it serves to document which pointers are protected by RCU. 
<LI>rcu_dereference(): The reader uses <CODE>rcu_dereference</CODE> to fetch an RCU-protected pointer, which returns a value that may then be safely dereferenced. It also executes any directives required by the compiler or the CPU, for example, a volatile cast for gcc, a memory_order_consume load for C/C++11 or the memory-barrier instruction required by the old DEC Alpha CPU. The value returned by <CODE>rcu_dereference</CODE> is valid only within the enclosing RCU read-side critical section. As with <CODE>rcu_assign_pointer</CODE>, an important function of <CODE>rcu_dereference</CODE> is to document which pointers are protected by RCU.</LI></UL>
<DIV class="thumb tright">
<DIV class=thumbinner style="WIDTH: 442px"><A class=image href="https://en.wikipedia.org/wiki/File:Rcu_api.jpg"><IMG class=thumbimage alt="" src="https://upload.wikimedia.org/wikipedia/en/thumb/6/6b/Rcu_api.jpg/440px-Rcu_api.jpg" width=440 height=181 data-file-height="400" data-file-width="972" srcset="//upload.wikimedia.org/wikipedia/en/thumb/6/6b/Rcu_api.jpg/660px-Rcu_api.jpg 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/6/6b/Rcu_api.jpg/880px-Rcu_api.jpg 2x"></A> 
<DIV class=thumbcaption>
<DIV class=magnify></DIV></DIV></DIV></DIV>
<DIV class="thumb tright">
<DIV class=thumbinner style="WIDTH: 442px">
<DIV class=thumbcaption>RCU API communications between the reader, updater, and reclaimer</DIV></DIV></DIV>
<P>The diagram on the right shows how each API communicates among the reader, updater, and reclaimer.</P>
<P>The RCU infrastructure observes the time sequence of <CODE>rcu_read_lock</CODE>, <CODE>rcu_read_unlock</CODE>, <CODE>synchronize_rcu</CODE>, and <CODE>call_rcu</CODE> invocations in order to determine when (1) <CODE>synchronize_rcu</CODE> invocations may return to their callers and (2) <CODE>call_rcu</CODE> callbacks may be invoked. Efficient implementations of the RCU infrastructure make heavy use of batching in order to amortize their overhead over many uses of the corresponding APIs.</P>
<H2><SPAN id=Simple_implementation class=mw-headline>Simple implementation</SPAN></H2>
<P>RCU has extremely simple "toy" implementations that can aid understanding of RCU. This section presents one such "toy" implementation that works in a <A title="Cooperative multitasking" href="https://en.wikipedia.org/wiki/Cooperative_multitasking">non-preemptive environment</A>.<SUP id=cite_ref-22 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-22">[18]</A></SUP></P>
<DIV class="mw-highlight mw-content-ltr" dir=ltr><PRE><SPAN class=kt>void</SPAN> <SPAN class=nf>rcu_read_lock</SPAN><SPAN class=p>(</SPAN><SPAN class=kt>void</SPAN><SPAN class=p>)</SPAN> <SPAN class=p>{</SPAN> <SPAN class=p>}</SPAN>

<SPAN class=kt>void</SPAN> <SPAN class=nf>rcu_read_unlock</SPAN><SPAN class=p>(</SPAN><SPAN class=kt>void</SPAN><SPAN class=p>)</SPAN> <SPAN class=p>{</SPAN> <SPAN class=p>}</SPAN>

<SPAN class=kt>void</SPAN> <SPAN class=nf>call_rcu</SPAN><SPAN class=p>(</SPAN><SPAN class=kt>void</SPAN> <SPAN class=p>(</SPAN><SPAN class=o>*</SPAN><SPAN class=n>callback</SPAN><SPAN class=p>)</SPAN> <SPAN class=p>(</SPAN><SPAN class=kt>void</SPAN> <SPAN class=o>*</SPAN><SPAN class=p>),</SPAN> <SPAN class=kt>void</SPAN> <SPAN class=o>*</SPAN><SPAN class=n>arg</SPAN><SPAN class=p>)</SPAN>
<SPAN class=p>{</SPAN>
	<SPAN class=c1>// add callback/arg pair to a list</SPAN>
<SPAN class=p>}</SPAN>

<SPAN class=kt>void</SPAN> <SPAN class=nf>synchronize_rcu</SPAN><SPAN class=p>(</SPAN><SPAN class=kt>void</SPAN><SPAN class=p>)</SPAN>
<SPAN class=p>{</SPAN>
	<SPAN class=kt>int</SPAN> <SPAN class=n>cpu</SPAN><SPAN class=p>,</SPAN> <SPAN class=n>ncpus</SPAN> <SPAN class=o>=</SPAN> <SPAN class=mi>0</SPAN><SPAN class=p>;</SPAN>

	<SPAN class=n>for_each_cpu</SPAN><SPAN class=p>(</SPAN><SPAN class=n>cpu</SPAN><SPAN class=p>)</SPAN>
                <SPAN class=n>schedule_current_task_to</SPAN><SPAN class=p>(</SPAN><SPAN class=n>cpu</SPAN><SPAN class=p>);</SPAN>

        <SPAN class=k>for</SPAN> <SPAN class=n>each</SPAN> <SPAN class=n>entry</SPAN> <SPAN class=n>in</SPAN> <SPAN class=n>the</SPAN> <SPAN class=n>call_rcu</SPAN> <SPAN class=n>list</SPAN>
                <SPAN class=n>entry</SPAN><SPAN class=o>-&gt;</SPAN><SPAN class=n>callback</SPAN> <SPAN class=p>(</SPAN><SPAN class=n>entry</SPAN><SPAN class=o>-&gt;</SPAN><SPAN class=n>arg</SPAN><SPAN class=p>);</SPAN>
<SPAN class=p>}</SPAN>
</PRE></DIV>
<P>In the code sample, <CODE>rcu_assign_pointer</CODE> and <CODE>rcu_dereference</CODE> can be ignored without missing much. However, they are provided below.<SUP class="noprint Inline-Template" style="WHITE-SPACE: nowrap; MARGIN-LEFT: 0.1em">[<I><A title="Wikipedia:Please clarify" href="https://en.wikipedia.org/wiki/Wikipedia:Please_clarify"><SPAN title="The text near this tag may need clarification or removal of jargon. (November 2015)">clarification needed</SPAN></A></I>]</SUP></P>
<DIV class="mw-highlight mw-content-ltr" dir=ltr><PRE><SPAN class=cp>#define rcu_assign_pointer(p, v)	({ \</SPAN>
<SPAN class=cp>						smp_wmb(); \</SPAN>
<SPAN class=cp>						ACCESS_ONCE(p) = (v); \</SPAN>
<SPAN class=cp>					})</SPAN>

<SPAN class=cp>#define rcu_dereference(p)		({ \</SPAN>
<SPAN class=cp>						typeof(p) _value = ACCESS_ONCE(p); \</SPAN>
<SPAN class=cp>						smp_read_barrier_depends(); </SPAN><SPAN class=cm>/* nop on most architectures */</SPAN><SPAN class=cp> \</SPAN>
<SPAN class=cp>						(_value); \</SPAN>
<SPAN class=cp>					})</SPAN>
</PRE></DIV>
<P>Note that <CODE>rcu_read_lock</CODE> and <CODE>rcu_read_unlock</CODE> do nothing. This is the great strength of classic RCU in a non-preemptive kernel: read-side overhead is precisely zero, as <CODE>smp_read_barrier_depends()</CODE> is an empty macro on all but <A title="DEC Alpha" href="https://en.wikipedia.org/wiki/DEC_Alpha">DEC Alpha</A> CPUs;<SUP id=cite_ref-23 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-23">[19]</A></SUP><SUP class="noprint Inline-Template" style="WHITE-SPACE: nowrap">[<I><A title=Wikipedia:Verifiability href="https://en.wikipedia.org/wiki/Wikipedia:Verifiability"><SPAN title="The source does not discuss the Linux smp_read_barrier_depends operation, and certainly doesn't comment on any other type of CPU. (November 2015)">not in citation given</SPAN></A></I>]</SUP> such memory barriers are not needed on modern CPUs. The <CODE>ACCESS_ONCE()</CODE> macro is a volatile cast that generates no additional code in most cases. And there is no way that <CODE>rcu_read_lock</CODE> can participate in a <A title=Deadlock href="https://en.wikipedia.org/wiki/Deadlock">deadlock</A> cycle, cause a realtime process to miss its scheduling deadline, precipitate <A title="Priority inversion" href="https://en.wikipedia.org/wiki/Priority_inversion">priority inversion</A>, or result in high <A title="Lock (computer science)" href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29">lock contention</A>. However, in this toy RCU implementation, blocking within an RCU read-side critical section is illegal, just as is blocking while holding a pure spinlock.</P>
<P>The implementation of <CODE>synchronize_rcu</CODE> moves the caller of synchronize_cpu to each CPU, thus blocking until all CPUs have been able to perform the context switch. Recall that this is a non-preemptive environment and that blocking within an RCU read-side critical section is illegal, which imply that there can be no preemption points within an RCU read-side critical section. Therefore, if a given CPU executes a context switch (to schedule another process), we know that this CPU must have completed all preceding RCU read-side critical sections. Once all CPUs have executed a context switch, then all preceding RCU read-side critical sections will have completed.</P>
<H2><SPAN id=Analogy_with_reader-writer_locking class=mw-headline>Analogy with reader-writer locking</SPAN></H2>
<P>Although RCU can be used in many different ways, a very common use of RCU is analogous to reader-writer locking. The following side-by-side code display shows how closely related reader-writer locking (on the left) and RCU (on the right) can be.<SUP id=cite_ref-24 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-24">[20]</A></SUP></P>
<DIV class="mw-highlight mw-content-ltr" dir=ltr><PRE> <SPAN class=mi>1</SPAN> <SPAN class=k>struct</SPAN> <SPAN class=n>el</SPAN> <SPAN class=p>{</SPAN>                           <SPAN class=mi>1</SPAN> <SPAN class=k>struct</SPAN> <SPAN class=n>el</SPAN> <SPAN class=p>{</SPAN>
 <SPAN class=mi>2</SPAN>   <SPAN class=k>struct</SPAN> <SPAN class=n>list_head</SPAN> <SPAN class=n>lp</SPAN><SPAN class=p>;</SPAN>                <SPAN class=mi>2</SPAN>   <SPAN class=k>struct</SPAN> <SPAN class=n>list_head</SPAN> <SPAN class=n>lp</SPAN><SPAN class=p>;</SPAN>
 <SPAN class=mi>3</SPAN>   <SPAN class=kt>long</SPAN> <SPAN class=n>key</SPAN><SPAN class=p>;</SPAN>                           <SPAN class=mi>3</SPAN>   <SPAN class=kt>long</SPAN> <SPAN class=n>key</SPAN><SPAN class=p>;</SPAN>
 <SPAN class=mi>4</SPAN>   <SPAN class=n>spinlock_t</SPAN> <SPAN class=n>mutex</SPAN><SPAN class=p>;</SPAN>                   <SPAN class=mi>4</SPAN>   <SPAN class=n>spinlock_t</SPAN> <SPAN class=n>mutex</SPAN><SPAN class=p>;</SPAN>
 <SPAN class=mi>5</SPAN>   <SPAN class=kt>int</SPAN> <SPAN class=n>data</SPAN><SPAN class=p>;</SPAN>                           <SPAN class=mi>5</SPAN>   <SPAN class=kt>int</SPAN> <SPAN class=n>data</SPAN><SPAN class=p>;</SPAN>
 <SPAN class=mi>6</SPAN>   <SPAN class=cm>/* Other data fields */</SPAN>             <SPAN class=mi>6</SPAN>   <SPAN class=cm>/* Other data fields */</SPAN>
 <SPAN class=mi>7</SPAN> <SPAN class=p>};</SPAN>                                    <SPAN class=mi>7</SPAN> <SPAN class=p>};</SPAN>
 <SPAN class=mi>8</SPAN> <SPAN class=nf>DEFINE_RWLOCK</SPAN><SPAN class=p>(</SPAN><SPAN class=n>listmutex</SPAN><SPAN class=p>);</SPAN>             <SPAN class=mi>8</SPAN> <SPAN class=nf>DEFINE_SPINLOCK</SPAN><SPAN class=p>(</SPAN><SPAN class=n>listmutex</SPAN><SPAN class=p>);</SPAN>
 <SPAN class=mi>9</SPAN> <SPAN class=nf>LIST_HEAD</SPAN><SPAN class=p>(</SPAN><SPAN class=n>head</SPAN><SPAN class=p>);</SPAN>                      <SPAN class=mi>9</SPAN> <SPAN class=nf>LIST_HEAD</SPAN><SPAN class=p>(</SPAN><SPAN class=n>head</SPAN><SPAN class=p>);</SPAN>
<SPAN class=hll>
</SPAN> <SPAN class=mi>1</SPAN> <SPAN class=kt>int</SPAN> <SPAN class=nf>search</SPAN><SPAN class=p>(</SPAN><SPAN class=kt>long</SPAN> <SPAN class=n>key</SPAN><SPAN class=p>,</SPAN> <SPAN class=kt>int</SPAN> <SPAN class=o>*</SPAN><SPAN class=n>result</SPAN><SPAN class=p>)</SPAN>     <SPAN class=mi>1</SPAN> <SPAN class=kt>int</SPAN> <SPAN class=n>search</SPAN><SPAN class=p>(</SPAN><SPAN class=kt>long</SPAN> <SPAN class=n>key</SPAN><SPAN class=p>,</SPAN> <SPAN class=kt>int</SPAN> <SPAN class=o>*</SPAN><SPAN class=n>result</SPAN><SPAN class=p>)</SPAN>
 <SPAN class=mi>2</SPAN> <SPAN class=p>{</SPAN>                                     <SPAN class=mi>2</SPAN> <SPAN class=p>{</SPAN>
 <SPAN class=mi>3</SPAN>   <SPAN class=k>struct</SPAN> <SPAN class=n>el</SPAN> <SPAN class=o>*</SPAN><SPAN class=n>p</SPAN><SPAN class=p>;</SPAN>                       <SPAN class=mi>3</SPAN>   <SPAN class=k>struct</SPAN> <SPAN class=n>el</SPAN> <SPAN class=o>*</SPAN><SPAN class=n>p</SPAN><SPAN class=p>;</SPAN>
 <SPAN class=mi>4</SPAN>                                       <SPAN class=mi>4</SPAN>
 <SPAN class=mi>5</SPAN>   <SPAN class=n>read_lock</SPAN><SPAN class=p>(</SPAN><SPAN class=o>&amp;</SPAN><SPAN class=n>listmutex</SPAN><SPAN class=p>);</SPAN>              <SPAN class=mi>5</SPAN>   <SPAN class=n>rcu_read_lock</SPAN><SPAN class=p>();</SPAN>
 <SPAN class=mi>6</SPAN>   <SPAN class=n>list_for_each_entry</SPAN><SPAN class=p>(</SPAN><SPAN class=n>p</SPAN><SPAN class=p>,</SPAN> <SPAN class=o>&amp;</SPAN><SPAN class=n>head</SPAN><SPAN class=p>,</SPAN> <SPAN class=n>lp</SPAN><SPAN class=p>)</SPAN> <SPAN class=p>{</SPAN> <SPAN class=mi>6</SPAN>   <SPAN class=n>list_for_each_entry_rcu</SPAN><SPAN class=p>(</SPAN><SPAN class=n>p</SPAN><SPAN class=p>,</SPAN> <SPAN class=o>&amp;</SPAN><SPAN class=n>head</SPAN><SPAN class=p>,</SPAN> <SPAN class=n>lp</SPAN><SPAN class=p>)</SPAN> <SPAN class=p>{</SPAN>
 <SPAN class=mi>7</SPAN>     <SPAN class=k>if</SPAN> <SPAN class=p>(</SPAN><SPAN class=n>p</SPAN><SPAN class=o>-&gt;</SPAN><SPAN class=n>key</SPAN> <SPAN class=o>==</SPAN> <SPAN class=n>key</SPAN><SPAN class=p>)</SPAN> <SPAN class=p>{</SPAN>              <SPAN class=mi>7</SPAN>     <SPAN class=k>if</SPAN> <SPAN class=p>(</SPAN><SPAN class=n>p</SPAN><SPAN class=o>-&gt;</SPAN><SPAN class=n>key</SPAN> <SPAN class=o>==</SPAN> <SPAN class=n>key</SPAN><SPAN class=p>)</SPAN> <SPAN class=p>{</SPAN>
 <SPAN class=mi>8</SPAN>       <SPAN class=o>*</SPAN><SPAN class=n>result</SPAN> <SPAN class=o>=</SPAN> <SPAN class=n>p</SPAN><SPAN class=o>-&gt;</SPAN><SPAN class=n>data</SPAN><SPAN class=p>;</SPAN>              <SPAN class=mi>8</SPAN>       <SPAN class=o>*</SPAN><SPAN class=n>result</SPAN> <SPAN class=o>=</SPAN> <SPAN class=n>p</SPAN><SPAN class=o>-&gt;</SPAN><SPAN class=n>data</SPAN><SPAN class=p>;</SPAN>
 <SPAN class=mi>9</SPAN>       <SPAN class=n>read_unlock</SPAN><SPAN class=p>(</SPAN><SPAN class=o>&amp;</SPAN><SPAN class=n>listmutex</SPAN><SPAN class=p>);</SPAN>        <SPAN class=mi>9</SPAN>       <SPAN class=n>rcu_read_unlock</SPAN><SPAN class=p>();</SPAN>
<SPAN class=mi>10</SPAN>       <SPAN class=k>return</SPAN> <SPAN class=mi>1</SPAN><SPAN class=p>;</SPAN>                      <SPAN class=mi>10</SPAN>       <SPAN class=k>return</SPAN> <SPAN class=mi>1</SPAN><SPAN class=p>;</SPAN>
<SPAN class=mi>11</SPAN>     <SPAN class=p>}</SPAN>                                <SPAN class=mi>11</SPAN>     <SPAN class=p>}</SPAN>
<SPAN class=mi>12</SPAN>   <SPAN class=p>}</SPAN>                                  <SPAN class=mi>12</SPAN>   <SPAN class=p>}</SPAN>
<SPAN class=mi>13</SPAN>   <SPAN class=n>read_unlock</SPAN><SPAN class=p>(</SPAN><SPAN class=o>&amp;</SPAN><SPAN class=n>listmutex</SPAN><SPAN class=p>);</SPAN>           <SPAN class=mi>13</SPAN>   <SPAN class=n>rcu_read_unlock</SPAN><SPAN class=p>();</SPAN>
<SPAN class=mi>14</SPAN>   <SPAN class=k>return</SPAN> <SPAN class=mi>0</SPAN><SPAN class=p>;</SPAN>                          <SPAN class=mi>14</SPAN>   <SPAN class=k>return</SPAN> <SPAN class=mi>0</SPAN><SPAN class=p>;</SPAN>
<SPAN class=mi>15</SPAN> <SPAN class=p>}</SPAN>                                    <SPAN class=mi>15</SPAN> <SPAN class=p>}</SPAN>
<SPAN class=hll>
</SPAN> <SPAN class=mi>1</SPAN> <SPAN class=kt>int</SPAN> <SPAN class=nf>delete</SPAN><SPAN class=p>(</SPAN><SPAN class=kt>long</SPAN> <SPAN class=n>key</SPAN><SPAN class=p>)</SPAN>                  <SPAN class=mi>1</SPAN> <SPAN class=kt>int</SPAN> <SPAN class=n>delete</SPAN><SPAN class=p>(</SPAN><SPAN class=kt>long</SPAN> <SPAN class=n>key</SPAN><SPAN class=p>)</SPAN>
 <SPAN class=mi>2</SPAN> <SPAN class=p>{</SPAN>                                     <SPAN class=mi>2</SPAN> <SPAN class=p>{</SPAN>
 <SPAN class=mi>3</SPAN>   <SPAN class=k>struct</SPAN> <SPAN class=n>el</SPAN> <SPAN class=o>*</SPAN><SPAN class=n>p</SPAN><SPAN class=p>;</SPAN>                       <SPAN class=mi>3</SPAN>   <SPAN class=k>struct</SPAN> <SPAN class=n>el</SPAN> <SPAN class=o>*</SPAN><SPAN class=n>p</SPAN><SPAN class=p>;</SPAN>
 <SPAN class=mi>4</SPAN>                                       <SPAN class=mi>4</SPAN>
 <SPAN class=mi>5</SPAN>   <SPAN class=n>write_lock</SPAN><SPAN class=p>(</SPAN><SPAN class=o>&amp;</SPAN><SPAN class=n>listmutex</SPAN><SPAN class=p>);</SPAN>             <SPAN class=mi>5</SPAN>   <SPAN class=n>spin_lock</SPAN><SPAN class=p>(</SPAN><SPAN class=o>&amp;</SPAN><SPAN class=n>listmutex</SPAN><SPAN class=p>);</SPAN>
 <SPAN class=mi>6</SPAN>   <SPAN class=n>list_for_each_entry</SPAN><SPAN class=p>(</SPAN><SPAN class=n>p</SPAN><SPAN class=p>,</SPAN> <SPAN class=o>&amp;</SPAN><SPAN class=n>head</SPAN><SPAN class=p>,</SPAN> <SPAN class=n>lp</SPAN><SPAN class=p>)</SPAN> <SPAN class=p>{</SPAN> <SPAN class=mi>6</SPAN>   <SPAN class=n>list_for_each_entry</SPAN><SPAN class=p>(</SPAN><SPAN class=n>p</SPAN><SPAN class=p>,</SPAN> <SPAN class=o>&amp;</SPAN><SPAN class=n>head</SPAN><SPAN class=p>,</SPAN> <SPAN class=n>lp</SPAN><SPAN class=p>)</SPAN> <SPAN class=p>{</SPAN>
 <SPAN class=mi>7</SPAN>     <SPAN class=k>if</SPAN> <SPAN class=p>(</SPAN><SPAN class=n>p</SPAN><SPAN class=o>-&gt;</SPAN><SPAN class=n>key</SPAN> <SPAN class=o>==</SPAN> <SPAN class=n>key</SPAN><SPAN class=p>)</SPAN> <SPAN class=p>{</SPAN>              <SPAN class=mi>7</SPAN>     <SPAN class=k>if</SPAN> <SPAN class=p>(</SPAN><SPAN class=n>p</SPAN><SPAN class=o>-&gt;</SPAN><SPAN class=n>key</SPAN> <SPAN class=o>==</SPAN> <SPAN class=n>key</SPAN><SPAN class=p>)</SPAN> <SPAN class=p>{</SPAN>
 <SPAN class=mi>8</SPAN>       <SPAN class=n>list_del</SPAN><SPAN class=p>(</SPAN><SPAN class=o>&amp;</SPAN><SPAN class=n>p</SPAN><SPAN class=o>-&gt;</SPAN><SPAN class=n>lp</SPAN><SPAN class=p>);</SPAN>               <SPAN class=mi>8</SPAN>       <SPAN class=n>list_del_rcu</SPAN><SPAN class=p>(</SPAN><SPAN class=o>&amp;</SPAN><SPAN class=n>p</SPAN><SPAN class=o>-&gt;</SPAN><SPAN class=n>lp</SPAN><SPAN class=p>);</SPAN>
 <SPAN class=mi>9</SPAN>       <SPAN class=n>write_unlock</SPAN><SPAN class=p>(</SPAN><SPAN class=o>&amp;</SPAN><SPAN class=n>listmutex</SPAN><SPAN class=p>);</SPAN>       <SPAN class=mi>9</SPAN>       <SPAN class=n>spin_unlock</SPAN><SPAN class=p>(</SPAN><SPAN class=o>&amp;</SPAN><SPAN class=n>listmutex</SPAN><SPAN class=p>);</SPAN>
                                        <SPAN class=mi>10</SPAN>       <SPAN class=n>synchronize_rcu</SPAN><SPAN class=p>();</SPAN>
<SPAN class=mi>10</SPAN>       <SPAN class=n>kfree</SPAN><SPAN class=p>(</SPAN><SPAN class=n>p</SPAN><SPAN class=p>);</SPAN>                      <SPAN class=mi>11</SPAN>       <SPAN class=n>kfree</SPAN><SPAN class=p>(</SPAN><SPAN class=n>p</SPAN><SPAN class=p>);</SPAN>
<SPAN class=mi>11</SPAN>       <SPAN class=k>return</SPAN> <SPAN class=mi>1</SPAN><SPAN class=p>;</SPAN>                      <SPAN class=mi>12</SPAN>       <SPAN class=k>return</SPAN> <SPAN class=mi>1</SPAN><SPAN class=p>;</SPAN>
<SPAN class=mi>12</SPAN>     <SPAN class=p>}</SPAN>                                <SPAN class=mi>13</SPAN>     <SPAN class=p>}</SPAN>
<SPAN class=mi>13</SPAN>   <SPAN class=p>}</SPAN>                                  <SPAN class=mi>14</SPAN>   <SPAN class=p>}</SPAN>
<SPAN class=mi>14</SPAN>   <SPAN class=n>write_unlock</SPAN><SPAN class=p>(</SPAN><SPAN class=o>&amp;</SPAN><SPAN class=n>listmutex</SPAN><SPAN class=p>);</SPAN>          <SPAN class=mi>15</SPAN>   <SPAN class=n>spin_unlock</SPAN><SPAN class=p>(</SPAN><SPAN class=o>&amp;</SPAN><SPAN class=n>listmutex</SPAN><SPAN class=p>);</SPAN>
<SPAN class=mi>15</SPAN>   <SPAN class=k>return</SPAN> <SPAN class=mi>0</SPAN><SPAN class=p>;</SPAN>                          <SPAN class=mi>16</SPAN>   <SPAN class=k>return</SPAN> <SPAN class=mi>0</SPAN><SPAN class=p>;</SPAN>
<SPAN class=mi>16</SPAN> <SPAN class=p>}</SPAN>                                    <SPAN class=mi>17</SPAN> <SPAN class=p>}</SPAN>
</PRE></DIV>
<P>The differences between the two approaches are quite small. Read-side locking moves to <CODE>rcu_read_lock</CODE> and <CODE>rcu_read_unlock</CODE>, update-side locking moves from a reader-writer lock to a simple spinlock, and a <CODE>synchronize_rcu</CODE> precedes the <CODE>kfree</CODE>.</P>
<P>However, there is one potential catch: the read-side and update-side critical sections can now run concurrently. In many cases, this will not be a problem, but it is necessary to check carefully regardless. For example, if multiple independent list updates must be seen as a single atomic update, converting to RCU will require special care.</P>
<P>Also, the presence of <CODE>synchronize_rcu</CODE> means that the RCU version of <CODE>delete</CODE> can now block. If this is a problem, <CODE>call_rcu</CODE> could be used like <CODE>call_rcu (kfree, p)</CODE> in place of <CODE>synchronize_rcu</CODE>. This is especially useful in combination with reference counting.</P>
<H2><SPAN id=Name class=mw-headline>Name</SPAN></H2>
<P>The name comes from the way that RCU is used to update a linked structure in place. A thread wishing to do this uses the following steps:</P>
<UL>
<LI>create a new structure, 
<LI>copy the data from the old structure into the new one, and save a <A title="Pointer (computer programming)" href="https://en.wikipedia.org/wiki/Pointer_%28computer_programming%29">pointer</A> to the old structure, 
<LI>modify the new, copied, structure 
<LI>update the global pointer to refer to the new structure, and then 
<LI>sleep until the operating system kernel determines that there are no readers left using the old structure, for example, in the Linux kernel, by using synchronize_rcu().</LI></UL>
<P>When the thread which made the copy is awakened by the kernel, it can safely deallocate the old structure.</P>
<P>So the structure is <I>read</I> concurrently with a thread <I>copying</I> in order to do an <I>update</I>, hence the name "read-copy update". The abbreviation "RCU" was one of many contributions by the Linux community. Other names for similar techniques include <I>passive serialization</I> and <I>MP defer</I> by <A title="VM (Operating system)" class=mw-redirect href="https://en.wikipedia.org/wiki/VM_%28Operating_system%29">VM/XA</A> programmers and <I>generations</I> by <A title=K42 href="https://en.wikipedia.org/wiki/K42">K42</A> and <A class="external text" href="https://web.archive.org/web/20140102191807/http://www.eecg.toronto.edu/~tornado/" rel=nofollow>Tornado</A> programmers.