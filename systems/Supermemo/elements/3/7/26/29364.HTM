Splitting an update into removal and reclamation phases allows the updater to perform the removal phase immediately, and to defer the reclamation phase until all readers active during the removal phase have completed, in other words, until a grace period has elapsed.<SUP id=cite_ref-4 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-4">[note 2]</A></SUP></P>
<P>So the typical RCU update sequence goes something like the following:<SUP id=cite_ref-5 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-5">[3]</A></SUP></P>
<OL>
<LI>Ensure that all readers accessing RCU-protected data structures carry out their references from within an RCU read-side critical section. 
<LI>Remove pointers to a data structure, so that subsequent readers cannot gain a reference to it. 
<LI>Wait for a grace period to elapse, so that all previous readers (which might still have pointers to the data structure removed in the prior step) will have completed their RCU read-side critical sections. 
<LI>At this point, there cannot be any readers still holding references to the data structure, so it now may safely be reclaimed (e.g., freed).<SUP id=cite_ref-6 class=reference><A href="https://en.wikipedia.org/wiki/Read-copy-update#cite_note-6">[note 3]</A></SUP></LI></OL>
<P>In the above procedure (which matches the earlier diagram), the updater is performing both the removal and the reclamation step, but it is often helpful for an entirely different thread to do the reclamation. Reference counting can be used to let the reader perform removal so, even if the same thread performs both the update step (step (2) above) and the reclamation step (step (4) above), it is often helpful to think of them separately.