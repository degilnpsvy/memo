B3.4.1 NVIC operation</P>
<P>ARMv7-M supports level-sensitive and pulse-sensitive interrupt behavior. This means that both level-sensitive and pulse-sensitive interrupts can be handled. Pulse interrupt sources must be held long enough to be sampled reliably by the processor clock to ensure they are latched and become pending. A subsequent pulse can add the pending state to an active interrupt, making the status of the interrupt active and pending. However, multiple pulses that occur during the active period only register as a single event for interrupt scheduling.</P>
<P>In summary:<BR>&#8226; Pulses held for a clock period act like edge-sensitive interrupts. These can become pending again while the interrupt is active.<BR>&nbsp; Note<BR>&nbsp; A pulse must be cleared before the assertion of AIRCR.VECTCLRACTIVE or the associated exception return, otherwise the interrupt signal behaves as a level-sensitive input and the pending bit is asserted again.<BR>&#8226; Level-based interrupts become pending, and then make the interrupt active. The Interrupt Service Routine (ISR) then accesses the peripheral, causing it to deassert the interrupt. If the interrupt is still asserted on return from the ISR, it becomes pending again.</P>
<P>All NVIC interrupts have a programmable priority value and an associated exception number as part of the ARMv7-M exception model and its prioritization policy.</P>
<P>The NVIC supports the following features:<BR>&#8226; NVIC interrupts can be enabled and disabled by writing to their corresponding Interrupt Set-Enable or Interrupt Clear-Enable register bit-field. The registers use a write-1-to-enable and write-1-to-clear policy, both registers reading back the current enabled state of the corresponding (32) interrupts.<BR>When an interrupt is disabled, interrupt assertion causes the interrupt to become pending, but the interrupt cannot become active. If an interrupt is active when it is disabled, it remains in the active state until this is cleared by a reset or an exception return. Clearing the enable bit prevents any new activation of the associated interrupt.<BR>An implementation can hard-wire interrupt enable bits to zero if the associated interrupt line does not exist, or hard-wired them to one if the associated interrupt line cannot be disabled.<BR>&#8226; Software can set or remove the pending state of NVIC interrupts using a complementary pair of registers, the Set-Pending Register and Clear-Pending Register. The registers use a write-one-to-enable and write-one-to-clear policy, and a read of either register returns the current pending state of the corresponding 32 interrupts. Writing 1 to a bit in the Clear-Pending Register has no effect on the execution status of an active interrupt.<BR>It is IMPLEMENTATION DEFINED for each interrupt line supported, whether an interrupt supports either or both setting and clearing of the associated pending state under software control.<BR>&#8226; Active bit status is provided to allow software to determine whether an interrupt is inactive, active, pending, or active and pending.<BR>&#8226; NVIC interrupts are prioritized by updating an 8-bit field within a 32-bit register (each register supporting four interrupts). Priorities are maintained according to the ARMv7-M prioritization scheme. See Exception priorities and preemption on page B1-635.</P>
<P>In addition to an external hardware event or software setting the appropriate bit in the Set-Pending registers, to 1, software can set an external interrupt to the pending state by writing its interrupt number to the STIR, see Software Triggered Interrupt Register, STIR on page B3-742.</P>
<P>Note<BR>The interrupt number of an external interrupt is its (ExceptionNumber - 16)</P>
<P>External interrupt input behavior</P>
<P>The following pseudocode describes the relationship between external interrupt inputs and the NVIC behavior:<BR>// DEFINITIONS<BR>NVIC[] is an array of active high external interrupt input signals;<BR>&nbsp;&nbsp;&nbsp; // the type of signal (level or pulse) and its assertion level/sense is IMPLEMENTATION DEFINED<BR>&nbsp;&nbsp;&nbsp; // and might not be the same for all inputs<BR>&nbsp;&nbsp;&nbsp; <BR>boolean Edge(integer INTNUM); // Returns true if on a clock edge NVIC[INTNUM]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // has changed from &#8216;0&#8217; to &#8216;1&#8217;<BR>boolean NVIC_Pending[INTNUM]; // an array of pending status bits for the external interrupts<BR>integer INTNUM;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the external interrupt number</P>
<P>&nbsp;&nbsp;&nbsp; // The WriteToRegField helper function returns TRUE on a write of &#8216;1&#8217; event<BR>&nbsp;&nbsp;&nbsp; // to the field FieldNumber of the RegName register.<BR>&nbsp;&nbsp;&nbsp; <BR>boolean WriteToRegField(register RegName, integer FieldNumber)</P>
<P>boolean ExceptionIN(integer INTNUM); // returns TRUE if exception entry in progress</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to activate INTNUM<BR>boolean ExceptionOUT(integer INTNUM); // returns TRUE if exception return in progress<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // from active INTNUM<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>// INTERRUPT INTERFACE</P>
<P>sampleInterruptHi = WriteToRegField(AIRCR, VECTCLRACTIVE) || ExceptionOUT(INTNUM);<BR>sampleInterruptLo = WriteToRegField(ICPR, INTNUM);</P>
<P>InterruptAssertion = Edge(INTNUM) || (NVIC[INTNUM] &amp;&amp; sampleInterruptHi);<BR>InterruptDeassertion = !NVIC[INTNUM] &amp;&amp; sampleInterruptLo;</P>
<P>// NVIC BEHAVIOR</P>
<P>clearPend = ExceptionIN(INTNUM) || InterruptDeassertion;<BR>setPend = InterruptAssertion || WriteToRegField(ISPR, INTNUM);</P>
<P>if clearPend &amp;&amp; setPend then<BR>&nbsp;&nbsp;&nbsp; IMPLEMENTATION DEFINED whether NVIC_Pending[INTNUM] is TRUE or FALSE;<BR>else<BR>&nbsp;&nbsp;&nbsp; NVIC_Pending[INTNUM] = setPend || (NVIC_Pending[INTNUM] &amp;&amp; !clearPend);