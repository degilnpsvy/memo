// Linux 4.6 
<P></P>
<P>/*<BR>&nbsp;* kref.h - library routines for handling generic reference counted objects<BR>&nbsp;*<BR>&nbsp;* Copyright (C) 2004 Greg Kroah-Hartman &lt;<A href="mailto:greg@kroah.com">greg@kroah.com</A>&gt;<BR>&nbsp;* Copyright (C) 2004 IBM Corp.<BR>&nbsp;*<BR>&nbsp;* based on kobject.h which was:<BR>&nbsp;* Copyright (C) 2002-2003 Patrick Mochel &lt;<A href="mailto:mochel@osdl.org">mochel@osdl.org</A>&gt;<BR>&nbsp;* Copyright (C) 2002-2003 Open Source Development Labs<BR>&nbsp;*<BR>&nbsp;* This file is released under the GPLv2.<BR>&nbsp;*<BR>&nbsp;*/</P>
<P></P>
<P>#ifndef _KREF_H_<BR>#define _KREF_H_</P>
<P>#include &lt;linux/bug.h&gt;<BR>#include &lt;linux/atomic.h&gt;<BR>#include &lt;linux/kernel.h&gt;<BR>#include &lt;linux/mutex.h&gt;</P>
<P><FONT class=extract>struct kref {<BR>&nbsp;atomic_t refcount;<BR>};</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kref_init - initialize object.<BR>&nbsp;* @kref: object in question.<BR>&nbsp;*/<BR>static inline void kref_init(struct kref *kref)<BR>{<BR>&nbsp;atomic_set(&amp;kref-&gt;refcount, 1);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kref_get - increment refcount for object.<BR>&nbsp;* @kref: object.<BR>&nbsp;*/<BR>static inline void kref_get(struct kref *kref)<BR>{<BR>&nbsp;/* If refcount was 0 before incrementing then we have a race<BR>&nbsp; * condition when this kref is freeing by some other thread right now.<BR>&nbsp; * In this case one should use kref_get_unless_zero()<BR>&nbsp; */<BR>&nbsp;WARN_ON_ONCE(atomic_inc_return(&amp;kref-&gt;refcount) &lt; 2);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kref_sub - subtract a number of refcounts for object.<BR>&nbsp;* @kref: object.<BR>&nbsp;* @count: Number of recounts to subtract.<BR>&nbsp;* @release: pointer to the function that will clean up the object when the<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last reference to the object is released.<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This pointer is required, and it is not acceptable to pass kfree]<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in as this function.&nbsp; If the caller does pass kfree to this<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function, you will be publicly mocked mercilessly by the kref<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maintainer, and anyone else who happens to notice it.&nbsp; You have<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; been warned.<BR>&nbsp;*<BR>&nbsp;* Subtract @count from the refcount, and if 0, call release().<BR>&nbsp;* Return 1 if the object was removed, otherwise return 0.&nbsp; Beware, if this<BR>&nbsp;* function returns 0, you still can not count on the kref from remaining in<BR>&nbsp;* memory.&nbsp; Only use the return value if you want to see if the kref is now<BR>&nbsp;* gone, not present.<BR>&nbsp;*/<BR>static inline int kref_sub(struct kref *kref, unsigned int count,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*release)(struct kref *kref))<BR>{<BR>&nbsp;WARN_ON(release == NULL);</FONT></P>
<P><FONT class=extract>&nbsp;if (atomic_sub_and_test((int) count, &amp;kref-&gt;refcount)) {<BR>&nbsp;&nbsp;release(kref);<BR>&nbsp;&nbsp;return 1;<BR>&nbsp;}<BR>&nbsp;return 0;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kref_put - decrement refcount for object.<BR>&nbsp;* @kref: object.<BR>&nbsp;* @release: pointer to the function that will clean up the object when the<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last reference to the object is released.<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This pointer is required, and it is not acceptable to pass kfree<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in as this function.&nbsp; If the caller does pass kfree to this<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function, you will be publicly mocked mercilessly by the kref<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maintainer, and anyone else who happens to notice it.&nbsp; You have<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; been warned.<BR>&nbsp;*<BR>&nbsp;* Decrement the refcount, and if 0, call release().<BR>&nbsp;* Return 1 if the object was removed, otherwise return 0.&nbsp; Beware, if this<BR>&nbsp;* function returns 0, you still can not count on the kref from remaining in<BR>&nbsp;* memory.&nbsp; Only use the return value if you want to see if the kref is now<BR>&nbsp;* gone, not present.<BR>&nbsp;*/<BR>static inline int kref_put(struct kref *kref, void (*release)(struct kref *kref))<BR>{<BR>&nbsp;return kref_sub(kref, 1, release);<BR>}</FONT></P>
<P><FONT class=extract>static inline int kref_put_mutex(struct kref *kref,<BR>&nbsp;&nbsp;&nbsp;&nbsp; void (*release)(struct kref *kref),<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct mutex *lock)<BR>{<BR>&nbsp;WARN_ON(release == NULL);<BR>&nbsp;if (unlikely(!atomic_add_unless(&amp;kref-&gt;refcount, -1, 1))) {<BR>&nbsp;&nbsp;mutex_lock(lock);<BR>&nbsp;&nbsp;if (unlikely(!atomic_dec_and_test(&amp;kref-&gt;refcount))) {<BR>&nbsp;&nbsp;&nbsp;mutex_unlock(lock);<BR>&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;release(kref);<BR>&nbsp;&nbsp;return 1;<BR>&nbsp;}<BR>&nbsp;return 0;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kref_get_unless_zero - Increment refcount for object unless it is zero.<BR>&nbsp;* @kref: object.<BR>&nbsp;*<BR>&nbsp;* Return non-zero if the increment succeeded. Otherwise return 0.<BR>&nbsp;*<BR>&nbsp;* This function is intended to simplify locking around refcounting for<BR>&nbsp;* objects that can be looked up from a lookup structure, and which are<BR>&nbsp;* removed from that lookup structure in the object destructor.<BR>&nbsp;* Operations on such objects require at least a read lock around<BR>&nbsp;* lookup + kref_get, and a write lock around kref_put + remove from lookup<BR>&nbsp;* structure. Furthermore, RCU implementations become extremely tricky.<BR>&nbsp;* With a lookup followed by a kref_get_unless_zero *with return value check*<BR>&nbsp;* locking in the kref_put path can be deferred to the actual removal from<BR>&nbsp;* the lookup structure and RCU lookups become trivial.<BR>&nbsp;*/<BR>static inline int __must_check kref_get_unless_zero(struct kref *kref)<BR>{<BR>&nbsp;return atomic_add_unless(&amp;kref-&gt;refcount, 1, 0);<BR>}</FONT><BR>#endif /* _KREF_H_ */