/*<BR>&nbsp;* Prevent the compiler from merging or refetching accesses.&nbsp; <FONT class=extract>The compiler<BR>&nbsp;* is also forbidden from reordering successive instances of ACCESS_ONCE(),<BR>&nbsp;* but only when the compiler is aware of some particular ordering.&nbsp; One way<BR>&nbsp;* to make the compiler aware of ordering is to put the two invocations of<BR>&nbsp;* ACCESS_ONCE() in different C statements.</FONT><BR>&nbsp;*<BR>&nbsp;* ACCESS_ONCE will only work on scalar types. For union types, ACCESS_ONCE<BR>&nbsp;* on a union member will work as long as the size of the member matches the<BR>&nbsp;* size of the union and the size is smaller than word size.<BR>&nbsp;*<BR>&nbsp;* The major use cases of ACCESS_ONCE used to be (1) Mediating communication<BR>&nbsp;* between process-level code and irq/NMI handlers, all running on the same CPU,<BR>&nbsp;* and (2) Ensuring that the compiler does not&nbsp; fold, spindle, or otherwise<BR>&nbsp;* mutilate accesses that either do not require ordering or that interact<BR>&nbsp;* with an explicit memory barrier or atomic instruction that provides the<BR>&nbsp;* required ordering.<BR>&nbsp;*<BR>&nbsp;* If possible use READ_ONCE()/WRITE_ONCE() instead.<BR>&nbsp;*/<BR>#define __ACCESS_ONCE(x) ({ \<BR>&nbsp; __maybe_unused typeof(x) __var = (__force typeof(x)) 0; \<BR>&nbsp;(volatile typeof(x) *)&amp;(x); })<BR>#define ACCESS_ONCE(x) (*__ACCESS_ONCE(x))