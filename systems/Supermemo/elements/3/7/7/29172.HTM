The function kref_get_unless_zero also makes it possible to use rcu<BR>locking for lookups in the above example:
<P></P>
<P>struct my_data<BR>{<BR>&nbsp;struct rcu_head rhead;<BR>&nbsp;.<BR>&nbsp;struct kref refcount;<BR>&nbsp;.<BR>&nbsp;.<BR>};</P>
<P>static struct my_data *get_entry_rcu()<BR>{<BR>&nbsp;struct my_data *entry = NULL;<BR>&nbsp;rcu_read_lock();<BR>&nbsp;if (!list_empty(&amp;q)) {<BR>&nbsp;&nbsp;entry = container_of(q.next, struct my_data, link);<BR>&nbsp;&nbsp;if (!kref_get_unless_zero(&amp;entry-&gt;refcount))<BR>&nbsp;&nbsp;&nbsp;entry = NULL;<BR>&nbsp;}<BR>&nbsp;rcu_read_unlock();<BR>&nbsp;return entry;<BR>}</P>
<P>static void release_entry_rcu(struct kref *ref)<BR>{<BR>&nbsp;struct my_data *entry = container_of(ref, struct my_data, refcount);</P>
<P>&nbsp;mutex_lock(&amp;mutex);<BR>&nbsp;list_del_rcu(&amp;entry-&gt;link);<BR>&nbsp;mutex_unlock(&amp;mutex);<BR>&nbsp;kfree_rcu(entry, rhead);<BR>}</P>
<P>static void put_entry(struct my_data *entry)<BR>{<BR>&nbsp;kref_put(&amp;entry-&gt;refcount, release_entry_rcu);<BR>}</P>
<P>But note that the struct kref member needs to remain in valid memory for a<BR>rcu grace period after release_entry_rcu was called. That can be accomplished<BR>by using kfree_rcu(entry, rhead) as done above, or by calling synchronize_rcu()<BR>before using kfree, but note that synchronize_rcu() may sleep for a<BR>substantial amount of time.