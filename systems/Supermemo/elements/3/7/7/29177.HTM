/*<BR>&nbsp;* Prevent the compiler from merging or refetching reads or writes. The<BR>&nbsp;* compiler is also forbidden from reordering successive instances of<BR>&nbsp;* READ_ONCE, WRITE_ONCE and ACCESS_ONCE (see below), but only when the<BR>&nbsp;* compiler is aware of some particular ordering.&nbsp; One way to make the<BR>&nbsp;* compiler aware of ordering is to put the two invocations of READ_ONCE,<BR>&nbsp;* WRITE_ONCE or ACCESS_ONCE() in different C statements.<BR>&nbsp;*<BR>&nbsp;* In contrast to ACCESS_ONCE these two macros will also work on aggregate<BR>&nbsp;* data types like structs or unions. If the size of the accessed data<BR>&nbsp;* type exceeds the word size of the machine (e.g., 32 bits or 64 bits)<BR>&nbsp;* READ_ONCE() and WRITE_ONCE() will fall back to memcpy(). There's at<BR>&nbsp;* least two memcpy()s: one for the __builtin_memcpy() and then one for<BR>&nbsp;* the macro doing the copy of variable - '__u' allocated on the stack.<BR>&nbsp;*<BR>&nbsp;* Their two major use cases are: (1) Mediating communication between<BR>&nbsp;* process-level code and irq/NMI handlers, all running on the same CPU,<BR>&nbsp;* and (2) Ensuring that the compiler does not&nbsp; fold, spindle, or otherwise<BR>&nbsp;* mutilate accesses that either do not require ordering or that interact<BR>&nbsp;* with an explicit memory barrier or atomic instruction that provides the<BR>&nbsp;* required ordering.<BR>&nbsp;*/
<P></P>
<P>#define __READ_ONCE(x, check)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;union { typeof(x) __val; char __c[1]; } __u;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (check)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__read_once_size(&amp;(x), __u.__c, sizeof(x));&nbsp;&nbsp;\<BR>&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__read_once_size_nocheck(&amp;(x), __u.__c, sizeof(x));&nbsp;\<BR>&nbsp;__u.__val;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})<BR>#define READ_ONCE(x) __READ_ONCE(x, 1)</P>
<P>/*<BR>&nbsp;* Use READ_ONCE_NOCHECK() instead of READ_ONCE() if you need<BR>&nbsp;* to hide memory access from KASAN.<BR>&nbsp;*/<BR>#define READ_ONCE_NOCHECK(x) __READ_ONCE(x, 0)</P>
<P>#define WRITE_ONCE(x, val) \<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;union { typeof(x) __val; char __c[1]; } __u =&nbsp;\<BR>&nbsp;&nbsp;{ .__val = (__force typeof(x)) (val) }; \<BR>&nbsp;__write_once_size(&amp;(x), __u.__c, sizeof(x));&nbsp;\<BR>&nbsp;__u.__val;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})