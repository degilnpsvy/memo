drivers/base/bus.c 
<P></P>
<P>/*<BR>&nbsp;* bus.c - bus driver management<BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2002-3 Patrick Mochel<BR>&nbsp;* Copyright (c) 2002-3 Open Source Development Labs<BR>&nbsp;* Copyright (c) 2007 Greg Kroah-Hartman &lt;<A href="mailto:gregkh@suse.de">gregkh@suse.de</A>&gt;<BR>&nbsp;* Copyright (c) 2007 Novell Inc.<BR>&nbsp;*<BR>&nbsp;* This file is released under the GPLv2<BR>&nbsp;*<BR>&nbsp;*/</P>
<P></P>
<P>#include &lt;linux/async.h&gt;<BR>#include &lt;linux/device.h&gt;<BR>#include &lt;linux/module.h&gt;<BR>#include &lt;linux/errno.h&gt;<BR>#include &lt;linux/slab.h&gt;<BR>#include &lt;linux/init.h&gt;<BR>#include &lt;linux/string.h&gt;<BR>#include &lt;linux/mutex.h&gt;<BR>#include &lt;linux/sysfs.h&gt;<BR>#include "base.h"<BR>#include "power/power.h"</P>
<P>/* /sys/devices/system */<BR>static struct kset *system_kset;</P>
<P><FONT class=extract>#define to_bus_attr(_attr) container_of(_attr, struct bus_attribute, attr)</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* sysfs bindings for drivers<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>#define to_drv_attr(_attr) container_of(_attr, struct driver_attribute, attr)</FONT></P>
<P><BR>static int __must_check bus_rescan_devices_helper(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *data);</P>
<P><FONT class=extract>static struct bus_type *bus_get(struct bus_type *bus)<BR>{<BR>&nbsp;if (bus) {<BR>&nbsp;&nbsp;kset_get(&amp;bus-&gt;p-&gt;subsys);<BR>&nbsp;&nbsp;return bus;<BR>&nbsp;}<BR>&nbsp;return NULL;<BR>}</FONT></P>
<P><FONT class=extract>static void bus_put(struct bus_type *bus)<BR>{<BR>&nbsp;if (bus)<BR>&nbsp;&nbsp;kset_put(&amp;bus-&gt;p-&gt;subsys);<BR>}</FONT></P>
<P><FONT class=extract>static ssize_t drv_attr_show(struct kobject *kobj, struct attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;struct driver_attribute *drv_attr = to_drv_attr(attr);<BR>&nbsp;struct driver_private *drv_priv = to_driver(kobj);<BR>&nbsp;ssize_t ret = -EIO;</FONT></P>
<P><FONT class=extract>&nbsp;if (drv_attr-&gt;show)<BR>&nbsp;&nbsp;ret = drv_attr-&gt;show(drv_priv-&gt;driver, buf);<BR>&nbsp;return ret;<BR>}</FONT></P>
<P><FONT class=extract>static ssize_t drv_attr_store(struct kobject *kobj, struct attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t count)<BR>{<BR>&nbsp;struct driver_attribute *drv_attr = to_drv_attr(attr);<BR>&nbsp;struct driver_private *drv_priv = to_driver(kobj);<BR>&nbsp;ssize_t ret = -EIO;</FONT></P>
<P><FONT class=extract>&nbsp;if (drv_attr-&gt;store)<BR>&nbsp;&nbsp;ret = drv_attr-&gt;store(drv_priv-&gt;driver, buf, count);<BR>&nbsp;return ret;<BR>}</FONT></P>
<P><FONT class=extract>static const struct sysfs_ops driver_sysfs_ops = {<BR>&nbsp;.show&nbsp;= drv_attr_show,<BR>&nbsp;.store&nbsp;= drv_attr_store,<BR>};</FONT></P>
<P><FONT class=extract>static void driver_release(struct kobject *kobj)<BR>{<BR>&nbsp;struct driver_private *drv_priv = to_driver(kobj);</FONT></P>
<P><FONT class=extract>&nbsp;pr_debug("driver: '%s': %s\n", kobject_name(kobj), __func__);<BR>&nbsp;kfree(drv_priv);<BR>}</FONT></P>
<P><FONT class=extract>static struct kobj_type driver_ktype = {<BR>&nbsp;.sysfs_ops&nbsp;= &amp;driver_sysfs_ops,<BR>&nbsp;.release&nbsp;= driver_release,<BR>};</FONT></P>
<P>/*<BR>&nbsp;* sysfs bindings for buses<BR>&nbsp;*/<BR>static ssize_t bus_attr_show(struct kobject *kobj, struct attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf)<BR>{<BR>&nbsp;struct bus_attribute *bus_attr = to_bus_attr(attr);<BR>&nbsp;struct subsys_private *subsys_priv = to_subsys_private(kobj);<BR>&nbsp;ssize_t ret = 0;</P>
<P>&nbsp;if (bus_attr-&gt;show)<BR>&nbsp;&nbsp;ret = bus_attr-&gt;show(subsys_priv-&gt;bus, buf);<BR>&nbsp;return ret;<BR>}</P>
<P>static ssize_t bus_attr_store(struct kobject *kobj, struct attribute *attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t count)<BR>{<BR>&nbsp;struct bus_attribute *bus_attr = to_bus_attr(attr);<BR>&nbsp;struct subsys_private *subsys_priv = to_subsys_private(kobj);<BR>&nbsp;ssize_t ret = 0;</P>
<P>&nbsp;if (bus_attr-&gt;store)<BR>&nbsp;&nbsp;ret = bus_attr-&gt;store(subsys_priv-&gt;bus, buf, count);<BR>&nbsp;return ret;<BR>}</P>
<P>static const struct sysfs_ops bus_sysfs_ops = {<BR>&nbsp;.show&nbsp;= bus_attr_show,<BR>&nbsp;.store&nbsp;= bus_attr_store,<BR>};</P>
<P>int bus_create_file(struct bus_type *bus, struct bus_attribute *attr)<BR>{<BR>&nbsp;int error;<BR>&nbsp;if (bus_get(bus)) {<BR>&nbsp;&nbsp;error = sysfs_create_file(&amp;bus-&gt;p-&gt;subsys.kobj, &amp;attr-&gt;attr);<BR>&nbsp;&nbsp;bus_put(bus);<BR>&nbsp;} else<BR>&nbsp;&nbsp;error = -EINVAL;<BR>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(bus_create_file);</P>
<P>void bus_remove_file(struct bus_type *bus, struct bus_attribute *attr)<BR>{<BR>&nbsp;if (bus_get(bus)) {<BR>&nbsp;&nbsp;sysfs_remove_file(&amp;bus-&gt;p-&gt;subsys.kobj, &amp;attr-&gt;attr);<BR>&nbsp;&nbsp;bus_put(bus);<BR>&nbsp;}<BR>}<BR>EXPORT_SYMBOL_GPL(bus_remove_file);</P>
<P>static void bus_release(struct kobject *kobj)<BR>{<BR>&nbsp;struct subsys_private *priv = to_subsys_private(kobj);<BR>&nbsp;struct bus_type *bus = priv-&gt;bus;</P>
<P>&nbsp;kfree(priv);<BR>&nbsp;bus-&gt;p = NULL;<BR>}</P>
<P>static struct kobj_type bus_ktype = {<BR>&nbsp;.sysfs_ops&nbsp;= &amp;bus_sysfs_ops,<BR>&nbsp;.release&nbsp;= bus_release,<BR>};</P>
<P>static int bus_uevent_filter(struct kset *kset, struct kobject *kobj)<BR>{<BR>&nbsp;struct kobj_type *ktype = get_ktype(kobj);</P>
<P>&nbsp;if (ktype == &amp;bus_ktype)<BR>&nbsp;&nbsp;return 1;<BR>&nbsp;return 0;<BR>}</P>
<P>static const struct kset_uevent_ops bus_uevent_ops = {<BR>&nbsp;.filter = bus_uevent_filter,<BR>};</P>
<P>static struct kset *bus_kset;</P>
<P>/* Manually detach a device from its associated driver. */<BR>static ssize_t unbind_store(struct device_driver *drv, const char *buf,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count)<BR>{<BR>&nbsp;struct bus_type *bus = bus_get(drv-&gt;bus);<BR>&nbsp;struct device *dev;<BR>&nbsp;int err = -ENODEV;</P>
<P>&nbsp;dev = bus_find_device_by_name(bus, NULL, buf);<BR>&nbsp;if (dev &amp;&amp; dev-&gt;driver == drv) {<BR>&nbsp;&nbsp;if (dev-&gt;parent)&nbsp;/* Needed for USB */<BR>&nbsp;&nbsp;&nbsp;device_lock(dev-&gt;parent);<BR>&nbsp;&nbsp;device_release_driver(dev);<BR>&nbsp;&nbsp;if (dev-&gt;parent)<BR>&nbsp;&nbsp;&nbsp;device_unlock(dev-&gt;parent);<BR>&nbsp;&nbsp;err = count;<BR>&nbsp;}<BR>&nbsp;put_device(dev);<BR>&nbsp;bus_put(bus);<BR>&nbsp;return err;<BR>}<BR>static DRIVER_ATTR_WO(unbind);</P>
<P>/*<BR>&nbsp;* Manually attach a device to a driver.<BR>&nbsp;* Note: the driver must want to bind to the device,<BR>&nbsp;* it is not possible to override the driver's id table.<BR>&nbsp;*/<BR>static ssize_t bind_store(struct device_driver *drv, const char *buf,<BR>&nbsp;&nbsp;&nbsp;&nbsp; size_t count)<BR>{<BR>&nbsp;struct bus_type *bus = bus_get(drv-&gt;bus);<BR>&nbsp;struct device *dev;<BR>&nbsp;int err = -ENODEV;</P>
<P>&nbsp;dev = bus_find_device_by_name(bus, NULL, buf);<BR>&nbsp;if (dev &amp;&amp; dev-&gt;driver == NULL &amp;&amp; driver_match_device(drv, dev)) {<BR>&nbsp;&nbsp;if (dev-&gt;parent)&nbsp;/* Needed for USB */<BR>&nbsp;&nbsp;&nbsp;device_lock(dev-&gt;parent);<BR>&nbsp;&nbsp;device_lock(dev);<BR>&nbsp;&nbsp;err = driver_probe_device(drv, dev);<BR>&nbsp;&nbsp;device_unlock(dev);<BR>&nbsp;&nbsp;if (dev-&gt;parent)<BR>&nbsp;&nbsp;&nbsp;device_unlock(dev-&gt;parent);</P>
<P>&nbsp;&nbsp;if (err &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;/* success */<BR>&nbsp;&nbsp;&nbsp;err = count;<BR>&nbsp;&nbsp;} else if (err == 0) {<BR>&nbsp;&nbsp;&nbsp;/* driver didn't accept device */<BR>&nbsp;&nbsp;&nbsp;err = -ENODEV;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;put_device(dev);<BR>&nbsp;bus_put(bus);<BR>&nbsp;return err;<BR>}<BR>static DRIVER_ATTR_WO(bind);</P>
<P>static ssize_t show_drivers_autoprobe(struct bus_type *bus, char *buf)<BR>{<BR>&nbsp;return sprintf(buf, "%d\n", bus-&gt;p-&gt;drivers_autoprobe);<BR>}</P>
<P>static ssize_t store_drivers_autoprobe(struct bus_type *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t count)<BR>{<BR>&nbsp;if (buf[0] == '0')<BR>&nbsp;&nbsp;bus-&gt;p-&gt;drivers_autoprobe = 0;<BR>&nbsp;else<BR>&nbsp;&nbsp;bus-&gt;p-&gt;drivers_autoprobe = 1;<BR>&nbsp;return count;<BR>}</P>
<P>static ssize_t store_drivers_probe(struct bus_type *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buf, size_t count)<BR>{<BR>&nbsp;struct device *dev;<BR>&nbsp;int err = -EINVAL;</P>
<P>&nbsp;dev = bus_find_device_by_name(bus, NULL, buf);<BR>&nbsp;if (!dev)<BR>&nbsp;&nbsp;return -ENODEV;<BR>&nbsp;if (bus_rescan_devices_helper(dev, NULL) == 0)<BR>&nbsp;&nbsp;err = count;<BR>&nbsp;put_device(dev);<BR>&nbsp;return err;<BR>}</P>
<P>static struct device *next_device(struct klist_iter *i)<BR>{<BR>&nbsp;struct klist_node *n = klist_next(i);<BR>&nbsp;struct device *dev = NULL;<BR>&nbsp;struct device_private *dev_prv;</P>
<P>&nbsp;if (n) {<BR>&nbsp;&nbsp;dev_prv = to_device_private_bus(n);<BR>&nbsp;&nbsp;dev = dev_prv-&gt;device;<BR>&nbsp;}<BR>&nbsp;return dev;<BR>}</P>
<P><FONT class=extract>/**<BR>&nbsp;* bus_for_each_dev - device iterator.<BR>&nbsp;* @bus: bus type.<BR>&nbsp;* @start: device to start iterating from.<BR>&nbsp;* @data: data for the callback.<BR>&nbsp;* @fn: function to be called for each device.<BR>&nbsp;*<BR>&nbsp;* Iterate over @bus's list of devices, and call @fn for each,<BR>&nbsp;* passing it @data. If @start is not NULL, we use that device to<BR>&nbsp;* begin iterating from.<BR>&nbsp;*<BR>&nbsp;* We check the return of @fn each time. If it returns anything<BR>&nbsp;* other than 0, we break out and return that value.<BR>&nbsp;*<BR>&nbsp;* NOTE: The device that returns a non-zero value is not retained<BR>&nbsp;* in any way, nor is its refcount incremented. If the caller needs<BR>&nbsp;* to retain this data, it should do so, and increment the reference<BR>&nbsp;* count in the supplied callback.<BR>&nbsp;*/<BR>int bus_for_each_dev(struct bus_type *bus, struct device *start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data, int (*fn)(struct device *, void *))<BR>{<BR>&nbsp;struct klist_iter i;<BR>&nbsp;struct device *dev;<BR>&nbsp;int error = 0;</FONT></P>
<P><FONT class=extract>&nbsp;if (!bus || !bus-&gt;p)<BR>&nbsp;&nbsp;return -EINVAL;</FONT></P>
<P><FONT class=extract>&nbsp;klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_devices, &amp;i,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (start ? &amp;start-&gt;p-&gt;knode_bus : NULL));<BR>&nbsp;while ((dev = next_device(&amp;i)) &amp;&amp; !error)<BR>&nbsp;&nbsp;error = fn(dev, data);<BR>&nbsp;klist_iter_exit(&amp;i);<BR>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(bus_for_each_dev);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* bus_find_device - device iterator for locating a particular device.<BR>&nbsp;* @bus: bus type<BR>&nbsp;* @start: Device to begin with<BR>&nbsp;* @data: Data to pass to match function<BR>&nbsp;* @match: Callback function to check device<BR>&nbsp;*<BR>&nbsp;* This is similar to the bus_for_each_dev() function above, but it<BR>&nbsp;* returns a reference to a device that is 'found' for later use, as<BR>&nbsp;* determined by the @match callback.<BR>&nbsp;*<BR>&nbsp;* The callback should return 0 if the device doesn't match and non-zero<BR>&nbsp;* if it does.&nbsp; If the callback returns non-zero, this function will<BR>&nbsp;* return to the caller and not iterate over any more devices.<BR>&nbsp;*/<BR>struct device *bus_find_device(struct bus_type *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *start, void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*match)(struct device *dev, void *data))<BR>{<BR>&nbsp;struct klist_iter i;<BR>&nbsp;struct device *dev;</FONT></P>
<P><FONT class=extract>&nbsp;if (!bus || !bus-&gt;p)<BR>&nbsp;&nbsp;return NULL;</FONT></P>
<P><FONT class=extract>&nbsp;klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_devices, &amp;i,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (start ? &amp;start-&gt;p-&gt;knode_bus : NULL));<BR>&nbsp;while ((dev = next_device(&amp;i)))<BR>&nbsp;&nbsp;if (match(dev, data) &amp;&amp; get_device(dev))<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;klist_iter_exit(&amp;i);<BR>&nbsp;return dev;<BR>}<BR>EXPORT_SYMBOL_GPL(bus_find_device);</FONT></P>
<P><FONT class=extract>static int match_name(struct device *dev, void *data)<BR>{<BR>&nbsp;const char *name = data;</FONT></P>
<P><FONT class=extract>&nbsp;return sysfs_streq(name, dev_name(dev));<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* bus_find_device_by_name - device iterator for locating a particular device of a specific name<BR>&nbsp;* @bus: bus type<BR>&nbsp;* @start: Device to begin with<BR>&nbsp;* @name: name of the device to match<BR>&nbsp;*<BR>&nbsp;* This is similar to the bus_find_device() function above, but it handles<BR>&nbsp;* searching by a name automatically, no need to write another strcmp matching<BR>&nbsp;* function.<BR>&nbsp;*/<BR>struct device *bus_find_device_by_name(struct bus_type *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *start, const char *name)<BR>{<BR>&nbsp;return bus_find_device(bus, start, (void *)name, match_name);<BR>}<BR>EXPORT_SYMBOL_GPL(bus_find_device_by_name);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* subsys_find_device_by_id - find a device with a specific enumeration number<BR>&nbsp;* @subsys: subsystem<BR>&nbsp;* @id: index 'id' in struct device<BR>&nbsp;* @hint: device to check first<BR>&nbsp;*<BR>&nbsp;* Check the hint's next object and if it is a match return it directly,<BR>&nbsp;* otherwise, fall back to a full list search. Either way a reference for<BR>&nbsp;* the returned object is taken.<BR>&nbsp;*/<BR>struct device *subsys_find_device_by_id(struct bus_type *subsys, unsigned int id,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct device *hint)<BR>{<BR>&nbsp;struct klist_iter i;<BR>&nbsp;struct device *dev;</FONT></P>
<P><FONT class=extract>&nbsp;if (!subsys)<BR>&nbsp;&nbsp;return NULL;</FONT></P>
<P><FONT class=extract>&nbsp;if (hint) {<BR>&nbsp;&nbsp;klist_iter_init_node(&amp;subsys-&gt;p-&gt;klist_devices, &amp;i, &amp;hint-&gt;p-&gt;knode_bus);<BR>&nbsp;&nbsp;dev = next_device(&amp;i);<BR>&nbsp;&nbsp;if (dev &amp;&amp; dev-&gt;id == id &amp;&amp; get_device(dev)) {<BR>&nbsp;&nbsp;&nbsp;klist_iter_exit(&amp;i);<BR>&nbsp;&nbsp;&nbsp;return dev;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;klist_iter_exit(&amp;i);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;klist_iter_init_node(&amp;subsys-&gt;p-&gt;klist_devices, &amp;i, NULL);<BR>&nbsp;while ((dev = next_device(&amp;i))) {<BR>&nbsp;&nbsp;if (dev-&gt;id == id &amp;&amp; get_device(dev)) {<BR>&nbsp;&nbsp;&nbsp;klist_iter_exit(&amp;i);<BR>&nbsp;&nbsp;&nbsp;return dev;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;klist_iter_exit(&amp;i);<BR>&nbsp;return NULL;<BR>}<BR>EXPORT_SYMBOL_GPL(subsys_find_device_by_id);</FONT></P>
<P><FONT class=extract>static struct device_driver *next_driver(struct klist_iter *i)<BR>{<BR>&nbsp;struct klist_node *n = klist_next(i);<BR>&nbsp;struct driver_private *drv_priv;</FONT></P>
<P><FONT class=extract>&nbsp;if (n) {<BR>&nbsp;&nbsp;drv_priv = container_of(n, struct driver_private, knode_bus);<BR>&nbsp;&nbsp;return drv_priv-&gt;driver;<BR>&nbsp;}<BR>&nbsp;return NULL;<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* bus_for_each_drv - driver iterator<BR>&nbsp;* @bus: bus we're dealing with.<BR>&nbsp;* @start: driver to start iterating on.<BR>&nbsp;* @data: data to pass to the callback.<BR>&nbsp;* @fn: function to call for each driver.<BR>&nbsp;*<BR>&nbsp;* This is nearly identical to the device iterator above.<BR>&nbsp;* We iterate over each driver that belongs to @bus, and call<BR>&nbsp;* @fn for each. If @fn returns anything but 0, we break out<BR>&nbsp;* and return it. If @start is not NULL, we use it as the head<BR>&nbsp;* of the list.<BR>&nbsp;*<BR>&nbsp;* NOTE: we don't return the driver that returns a non-zero<BR>&nbsp;* value, nor do we leave the reference count incremented for that<BR>&nbsp;* driver. If the caller needs to know that info, it must set it<BR>&nbsp;* in the callback. It must also be sure to increment the refcount<BR>&nbsp;* so it doesn't disappear before returning to the caller.<BR>&nbsp;*/<BR>int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data, int (*fn)(struct device_driver *, void *))<BR>{<BR>&nbsp;struct klist_iter i;<BR>&nbsp;struct device_driver *drv;<BR>&nbsp;int error = 0;</FONT></P>
<P><FONT class=extract>&nbsp;if (!bus)<BR>&nbsp;&nbsp;return -EINVAL;</FONT></P>
<P><FONT class=extract>&nbsp;klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_drivers, &amp;i,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start ? &amp;start-&gt;p-&gt;knode_bus : NULL);<BR>&nbsp;while ((drv = next_driver(&amp;i)) &amp;&amp; !error)<BR>&nbsp;&nbsp;error = fn(drv, data);<BR>&nbsp;klist_iter_exit(&amp;i);<BR>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(bus_for_each_drv);</FONT></P>
<P><FONT class=extract>static int device_add_attrs(struct bus_type *bus, struct device *dev)<BR>{<BR>&nbsp;int error = 0;<BR>&nbsp;int i;</FONT></P>
<P><FONT class=extract>&nbsp;if (!bus-&gt;dev_attrs)<BR>&nbsp;&nbsp;return 0;</FONT></P>
<P><FONT class=extract>&nbsp;for (i = 0; bus-&gt;dev_attrs[i].attr.name; i++) {<BR>&nbsp;&nbsp;error = device_create_file(dev, &amp;bus-&gt;dev_attrs[i]);<BR>&nbsp;&nbsp;if (error) {<BR>&nbsp;&nbsp;&nbsp;while (--i &gt;= 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;device_remove_file(dev, &amp;bus-&gt;dev_attrs[i]);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;return error;<BR>}</FONT></P>
<P><FONT class=extract>static void device_remove_attrs(struct bus_type *bus, struct device *dev)<BR>{<BR>&nbsp;int i;</FONT></P>
<P><FONT class=extract>&nbsp;if (bus-&gt;dev_attrs) {<BR>&nbsp;&nbsp;for (i = 0; bus-&gt;dev_attrs[i].attr.name; i++)<BR>&nbsp;&nbsp;&nbsp;device_remove_file(dev, &amp;bus-&gt;dev_attrs[i]);<BR>&nbsp;}<BR>}</FONT></P>
<P>/**<BR>&nbsp;* bus_add_device - add device to bus<BR>&nbsp;* @dev: device being added<BR>&nbsp;*<BR>&nbsp;* - Add device's bus attributes.<BR>&nbsp;* - Create links to device's bus.<BR>&nbsp;* - Add the device to its bus's list of devices.<BR>&nbsp;*/<BR>int bus_add_device(struct device *dev)<BR>{<BR>&nbsp;struct bus_type *bus = bus_get(dev-&gt;bus);<BR>&nbsp;int error = 0;</P>
<P>&nbsp;if (bus) {<BR>&nbsp;&nbsp;pr_debug("bus: '%s': add device %s\n", bus-&gt;name, dev_name(dev));<BR>&nbsp;&nbsp;error = device_add_attrs(bus, dev);<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto out_put;<BR>&nbsp;&nbsp;error = device_add_groups(dev, bus-&gt;dev_groups);<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto out_id;<BR>&nbsp;&nbsp;error = sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;dev-&gt;kobj, dev_name(dev));<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto out_groups;<BR>&nbsp;&nbsp;error = sysfs_create_link(&amp;dev-&gt;kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, "subsystem");<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto out_subsys;<BR>&nbsp;&nbsp;klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);<BR>&nbsp;}<BR>&nbsp;return 0;</P>
<P>out_subsys:<BR>&nbsp;sysfs_remove_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj, dev_name(dev));<BR>out_groups:<BR>&nbsp;device_remove_groups(dev, bus-&gt;dev_groups);<BR>out_id:<BR>&nbsp;device_remove_attrs(bus, dev);<BR>out_put:<BR>&nbsp;bus_put(dev-&gt;bus);<BR>&nbsp;return error;<BR>}</P>
<P><FONT class=extract>/**<BR>&nbsp;* bus_probe_device - probe drivers for a new device<BR>&nbsp;* @dev: device to probe<BR>&nbsp;*<BR>&nbsp;* - Automatically probe for a driver if the bus allows it.<BR>&nbsp;*/<BR>void bus_probe_device(struct device *dev)<BR>{<BR>&nbsp;struct bus_type *bus = dev-&gt;bus;<BR>&nbsp;struct subsys_interface *sif;</FONT></P>
<P><FONT class=extract>&nbsp;if (!bus)<BR>&nbsp;&nbsp;return;</FONT></P>
<P><FONT class=extract>&nbsp;if (bus-&gt;p-&gt;drivers_autoprobe)<BR>&nbsp;&nbsp;device_initial_probe(dev);</FONT></P>
<P><FONT class=extract>&nbsp;mutex_lock(&amp;bus-&gt;p-&gt;mutex);<BR>&nbsp;list_for_each_entry(sif, &amp;bus-&gt;p-&gt;interfaces, node)<BR>&nbsp;&nbsp;if (sif-&gt;add_dev)<BR>&nbsp;&nbsp;&nbsp;sif-&gt;add_dev(dev, sif);<BR>&nbsp;mutex_unlock(&amp;bus-&gt;p-&gt;mutex);<BR>}</FONT></P>
<P>/**<BR>&nbsp;* bus_remove_device - remove device from bus<BR>&nbsp;* @dev: device to be removed<BR>&nbsp;*<BR>&nbsp;* - Remove device from all interfaces.<BR>&nbsp;* - Remove symlink from bus' directory.<BR>&nbsp;* - Delete device from bus's list.<BR>&nbsp;* - Detach from its driver.<BR>&nbsp;* - Drop reference taken in bus_add_device().<BR>&nbsp;*/<BR>void bus_remove_device(struct device *dev)<BR>{<BR>&nbsp;struct bus_type *bus = dev-&gt;bus;<BR>&nbsp;struct subsys_interface *sif;</P>
<P>&nbsp;if (!bus)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;mutex_lock(&amp;bus-&gt;p-&gt;mutex);<BR>&nbsp;list_for_each_entry(sif, &amp;bus-&gt;p-&gt;interfaces, node)<BR>&nbsp;&nbsp;if (sif-&gt;remove_dev)<BR>&nbsp;&nbsp;&nbsp;sif-&gt;remove_dev(dev, sif);<BR>&nbsp;mutex_unlock(&amp;bus-&gt;p-&gt;mutex);</P>
<P>&nbsp;sysfs_remove_link(&amp;dev-&gt;kobj, "subsystem");<BR>&nbsp;sysfs_remove_link(&amp;dev-&gt;bus-&gt;p-&gt;devices_kset-&gt;kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp; dev_name(dev));<BR>&nbsp;device_remove_attrs(dev-&gt;bus, dev);<BR>&nbsp;device_remove_groups(dev, dev-&gt;bus-&gt;dev_groups);<BR>&nbsp;if (klist_node_attached(&amp;dev-&gt;p-&gt;knode_bus))<BR>&nbsp;&nbsp;klist_del(&amp;dev-&gt;p-&gt;knode_bus);</P>
<P>&nbsp;pr_debug("bus: '%s': remove device %s\n",<BR>&nbsp;&nbsp; dev-&gt;bus-&gt;name, dev_name(dev));<BR>&nbsp;device_release_driver(dev);<BR>&nbsp;bus_put(dev-&gt;bus);<BR>}</P>
<P>static int __must_check add_bind_files(struct device_driver *drv)<BR>{<BR>&nbsp;int ret;</P>
<P>&nbsp;ret = driver_create_file(drv, &amp;driver_attr_unbind);<BR>&nbsp;if (ret == 0) {<BR>&nbsp;&nbsp;ret = driver_create_file(drv, &amp;driver_attr_bind);<BR>&nbsp;&nbsp;if (ret)<BR>&nbsp;&nbsp;&nbsp;driver_remove_file(drv, &amp;driver_attr_unbind);<BR>&nbsp;}<BR>&nbsp;return ret;<BR>}</P>
<P>static void remove_bind_files(struct device_driver *drv)<BR>{<BR>&nbsp;driver_remove_file(drv, &amp;driver_attr_bind);<BR>&nbsp;driver_remove_file(drv, &amp;driver_attr_unbind);<BR>}</P>
<P>static BUS_ATTR(drivers_probe, S_IWUSR, NULL, store_drivers_probe);<BR>static BUS_ATTR(drivers_autoprobe, S_IWUSR | S_IRUGO,<BR>&nbsp;&nbsp;show_drivers_autoprobe, store_drivers_autoprobe);</P>
<P>static int add_probe_files(struct bus_type *bus)<BR>{<BR>&nbsp;int retval;</P>
<P>&nbsp;retval = bus_create_file(bus, &amp;bus_attr_drivers_probe);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;retval = bus_create_file(bus, &amp;bus_attr_drivers_autoprobe);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;bus_remove_file(bus, &amp;bus_attr_drivers_probe);<BR>out:<BR>&nbsp;return retval;<BR>}</P>
<P>static void remove_probe_files(struct bus_type *bus)<BR>{<BR>&nbsp;bus_remove_file(bus, &amp;bus_attr_drivers_autoprobe);<BR>&nbsp;bus_remove_file(bus, &amp;bus_attr_drivers_probe);<BR>}</P>
<P>static ssize_t uevent_store(struct device_driver *drv, const char *buf,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count)<BR>{<BR>&nbsp;enum kobject_action action;</P>
<P>&nbsp;if (kobject_action_type(buf, count, &amp;action) == 0)<BR>&nbsp;&nbsp;kobject_uevent(&amp;drv-&gt;p-&gt;kobj, action);<BR>&nbsp;return count;<BR>}<BR>static DRIVER_ATTR_WO(uevent);</P>
<P>static void driver_attach_async(void *_drv, async_cookie_t cookie)<BR>{<BR>&nbsp;struct device_driver *drv = _drv;<BR>&nbsp;int ret;</P>
<P>&nbsp;ret = driver_attach(drv);</P>
<P>&nbsp;pr_debug("bus: '%s': driver %s async attach completed: %d\n",<BR>&nbsp;&nbsp; drv-&gt;bus-&gt;name, drv-&gt;name, ret);<BR>}</P>
<P>/**<BR>&nbsp;* bus_add_driver - Add a driver to the bus.<BR>&nbsp;* @drv: driver.<BR>&nbsp;*/<BR>int bus_add_driver(struct device_driver *drv)<BR>{<BR>&nbsp;struct bus_type *bus;<BR>&nbsp;struct driver_private *priv;<BR>&nbsp;int error = 0;</P>
<P>&nbsp;bus = bus_get(drv-&gt;bus);<BR>&nbsp;if (!bus)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;pr_debug("bus: '%s': add driver %s\n", bus-&gt;name, drv-&gt;name);</P>
<P>&nbsp;priv = kzalloc(sizeof(*priv), GFP_KERNEL);<BR>&nbsp;if (!priv) {<BR>&nbsp;&nbsp;error = -ENOMEM;<BR>&nbsp;&nbsp;goto out_put_bus;<BR>&nbsp;}<BR>&nbsp;klist_init(&amp;priv-&gt;klist_devices, NULL, NULL);<BR>&nbsp;priv-&gt;driver = drv;<BR>&nbsp;drv-&gt;p = priv;<BR>&nbsp;priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset;<BR>&nbsp;error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, NULL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%s", drv-&gt;name);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto out_unregister;</P>
<P>&nbsp;klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);<BR>&nbsp;if (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) {<BR>&nbsp;&nbsp;if (driver_allows_async_probing(drv)) {<BR>&nbsp;&nbsp;&nbsp;pr_debug("bus: '%s': probing driver %s asynchronously\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;drv-&gt;bus-&gt;name, drv-&gt;name);<BR>&nbsp;&nbsp;&nbsp;async_schedule(driver_attach_async, drv);<BR>&nbsp;&nbsp;} else {<BR>&nbsp;&nbsp;&nbsp;error = driver_attach(drv);<BR>&nbsp;&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;&nbsp;goto out_unregister;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;module_add_driver(drv-&gt;owner, drv);</P>
<P>&nbsp;error = driver_create_file(drv, &amp;driver_attr_uevent);<BR>&nbsp;if (error) {<BR>&nbsp;&nbsp;printk(KERN_ERR "%s: uevent attr (%s) failed\n",<BR>&nbsp;&nbsp;&nbsp;__func__, drv-&gt;name);<BR>&nbsp;}<BR>&nbsp;error = driver_add_groups(drv, bus-&gt;drv_groups);<BR>&nbsp;if (error) {<BR>&nbsp;&nbsp;/* How the hell do we get out of this pickle? Give up */<BR>&nbsp;&nbsp;printk(KERN_ERR "%s: driver_create_groups(%s) failed\n",<BR>&nbsp;&nbsp;&nbsp;__func__, drv-&gt;name);<BR>&nbsp;}</P>
<P>&nbsp;if (!drv-&gt;suppress_bind_attrs) {<BR>&nbsp;&nbsp;error = add_bind_files(drv);<BR>&nbsp;&nbsp;if (error) {<BR>&nbsp;&nbsp;&nbsp;/* Ditto */<BR>&nbsp;&nbsp;&nbsp;printk(KERN_ERR "%s: add_bind_files(%s) failed\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;__func__, drv-&gt;name);<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;return 0;</P>
<P>out_unregister:<BR>&nbsp;kobject_put(&amp;priv-&gt;kobj);<BR>&nbsp;kfree(drv-&gt;p);<BR>&nbsp;drv-&gt;p = NULL;<BR>out_put_bus:<BR>&nbsp;bus_put(bus);<BR>&nbsp;return error;<BR>}</P>
<P>/**<BR>&nbsp;* bus_remove_driver - delete driver from bus's knowledge.<BR>&nbsp;* @drv: driver.<BR>&nbsp;*<BR>&nbsp;* Detach the driver from the devices it controls, and remove<BR>&nbsp;* it from its bus's list of drivers. Finally, we drop the reference<BR>&nbsp;* to the bus we took in bus_add_driver().<BR>&nbsp;*/<BR>void bus_remove_driver(struct device_driver *drv)<BR>{<BR>&nbsp;if (!drv-&gt;bus)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;if (!drv-&gt;suppress_bind_attrs)<BR>&nbsp;&nbsp;remove_bind_files(drv);<BR>&nbsp;driver_remove_groups(drv, drv-&gt;bus-&gt;drv_groups);<BR>&nbsp;driver_remove_file(drv, &amp;driver_attr_uevent);<BR>&nbsp;klist_remove(&amp;drv-&gt;p-&gt;knode_bus);<BR>&nbsp;pr_debug("bus: '%s': remove driver %s\n", drv-&gt;bus-&gt;name, drv-&gt;name);<BR>&nbsp;driver_detach(drv);<BR>&nbsp;module_remove_driver(drv);<BR>&nbsp;kobject_put(&amp;drv-&gt;p-&gt;kobj);<BR>&nbsp;bus_put(drv-&gt;bus);<BR>}</P>
<P>/* Helper for bus_rescan_devices's iter */<BR>static int __must_check bus_rescan_devices_helper(struct device *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data)<BR>{<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;if (!dev-&gt;driver) {<BR>&nbsp;&nbsp;if (dev-&gt;parent)&nbsp;/* Needed for USB */<BR>&nbsp;&nbsp;&nbsp;device_lock(dev-&gt;parent);<BR>&nbsp;&nbsp;ret = device_attach(dev);<BR>&nbsp;&nbsp;if (dev-&gt;parent)<BR>&nbsp;&nbsp;&nbsp;device_unlock(dev-&gt;parent);<BR>&nbsp;}<BR>&nbsp;return ret &lt; 0 ? ret : 0;<BR>}</P>
<P>/**<BR>&nbsp;* bus_rescan_devices - rescan devices on the bus for possible drivers<BR>&nbsp;* @bus: the bus to scan.<BR>&nbsp;*<BR>&nbsp;* This function will look for devices on the bus with no driver<BR>&nbsp;* attached and rescan it against existing drivers to see if it matches<BR>&nbsp;* any by calling device_attach() for the unbound devices.<BR>&nbsp;*/<BR>int bus_rescan_devices(struct bus_type *bus)<BR>{<BR>&nbsp;return bus_for_each_dev(bus, NULL, NULL, bus_rescan_devices_helper);<BR>}<BR>EXPORT_SYMBOL_GPL(bus_rescan_devices);</P>
<P>/**<BR>&nbsp;* device_reprobe - remove driver for a device and probe for a new driver<BR>&nbsp;* @dev: the device to reprobe<BR>&nbsp;*<BR>&nbsp;* This function detaches the attached driver (if any) for the given<BR>&nbsp;* device and restarts the driver probing process.&nbsp; It is intended<BR>&nbsp;* to use if probing criteria changed during a devices lifetime and<BR>&nbsp;* driver attachment should change accordingly.<BR>&nbsp;*/<BR>int device_reprobe(struct device *dev)<BR>{<BR>&nbsp;if (dev-&gt;driver) {<BR>&nbsp;&nbsp;if (dev-&gt;parent)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Needed for USB */<BR>&nbsp;&nbsp;&nbsp;device_lock(dev-&gt;parent);<BR>&nbsp;&nbsp;device_release_driver(dev);<BR>&nbsp;&nbsp;if (dev-&gt;parent)<BR>&nbsp;&nbsp;&nbsp;device_unlock(dev-&gt;parent);<BR>&nbsp;}<BR>&nbsp;return bus_rescan_devices_helper(dev, NULL);<BR>}<BR>EXPORT_SYMBOL_GPL(device_reprobe);</P>
<P>/**<BR>&nbsp;* find_bus - locate bus by name.<BR>&nbsp;* @name: name of bus.<BR>&nbsp;*<BR>&nbsp;* Call kset_find_obj() to iterate over list of buses to<BR>&nbsp;* find a bus by name. Return bus if found.<BR>&nbsp;*<BR>&nbsp;* Note that kset_find_obj increments bus' reference count.<BR>&nbsp;*/<BR>#if 0<BR>struct bus_type *find_bus(char *name)<BR>{<BR>&nbsp;struct kobject *k = kset_find_obj(bus_kset, name);<BR>&nbsp;return k ? to_bus(k) : NULL;<BR>}<BR>#endif&nbsp; /*&nbsp; 0&nbsp; */</P>
<P>static int bus_add_groups(struct bus_type *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups)<BR>{<BR>&nbsp;return sysfs_create_groups(&amp;bus-&gt;p-&gt;subsys.kobj, groups);<BR>}</P>
<P>static void bus_remove_groups(struct bus_type *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups)<BR>{<BR>&nbsp;sysfs_remove_groups(&amp;bus-&gt;p-&gt;subsys.kobj, groups);<BR>}</P>
<P>static void klist_devices_get(struct klist_node *n)<BR>{<BR>&nbsp;struct device_private *dev_prv = to_device_private_bus(n);<BR>&nbsp;struct device *dev = dev_prv-&gt;device;</P>
<P>&nbsp;get_device(dev);<BR>}</P>
<P>static void klist_devices_put(struct klist_node *n)<BR>{<BR>&nbsp;struct device_private *dev_prv = to_device_private_bus(n);<BR>&nbsp;struct device *dev = dev_prv-&gt;device;</P>
<P>&nbsp;put_device(dev);<BR>}</P>
<P>static ssize_t bus_uevent_store(struct bus_type *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const char *buf, size_t count)<BR>{<BR>&nbsp;enum kobject_action action;</P>
<P>&nbsp;if (kobject_action_type(buf, count, &amp;action) == 0)<BR>&nbsp;&nbsp;kobject_uevent(&amp;bus-&gt;p-&gt;subsys.kobj, action);<BR>&nbsp;return count;<BR>}<BR>static BUS_ATTR(uevent, S_IWUSR, NULL, bus_uevent_store);</P>
<P>/**<BR>&nbsp;* bus_register - register a driver-core subsystem<BR>&nbsp;* @bus: bus to register<BR>&nbsp;*<BR>&nbsp;* Once we have that, we register the bus with the kobject<BR>&nbsp;* infrastructure, then register the children subsystems it has:<BR>&nbsp;* the devices and drivers that belong to the subsystem.<BR>&nbsp;*/<BR>int bus_register(struct bus_type *bus)<BR>{<BR>&nbsp;int retval;<BR>&nbsp;struct subsys_private *priv;<BR>&nbsp;struct lock_class_key *key = &amp;bus-&gt;lock_key;</P>
<P>&nbsp;priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL);<BR>&nbsp;if (!priv)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;priv-&gt;bus = bus;<BR>&nbsp;bus-&gt;p = priv;</P>
<P>&nbsp;BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</P>
<P>&nbsp;retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, "%s", bus-&gt;name);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;priv-&gt;subsys.kobj.kset = bus_kset;<BR>&nbsp;priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;<BR>&nbsp;priv-&gt;drivers_autoprobe = 1;</P>
<P>&nbsp;retval = kset_register(&amp;priv-&gt;subsys);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;retval = bus_create_file(bus, &amp;bus_attr_uevent);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto bus_uevent_fail;</P>
<P>&nbsp;priv-&gt;devices_kset = kset_create_and_add("devices", NULL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;priv-&gt;subsys.kobj);<BR>&nbsp;if (!priv-&gt;devices_kset) {<BR>&nbsp;&nbsp;retval = -ENOMEM;<BR>&nbsp;&nbsp;goto bus_devices_fail;<BR>&nbsp;}</P>
<P>&nbsp;priv-&gt;drivers_kset = kset_create_and_add("drivers", NULL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;priv-&gt;subsys.kobj);<BR>&nbsp;if (!priv-&gt;drivers_kset) {<BR>&nbsp;&nbsp;retval = -ENOMEM;<BR>&nbsp;&nbsp;goto bus_drivers_fail;<BR>&nbsp;}</P>
<P>&nbsp;INIT_LIST_HEAD(&amp;priv-&gt;interfaces);<BR>&nbsp;__mutex_init(&amp;priv-&gt;mutex, "subsys mutex", key);<BR>&nbsp;klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);<BR>&nbsp;klist_init(&amp;priv-&gt;klist_drivers, NULL, NULL);</P>
<P>&nbsp;retval = add_probe_files(bus);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto bus_probe_files_fail;</P>
<P>&nbsp;retval = bus_add_groups(bus, bus-&gt;bus_groups);<BR>&nbsp;if (retval)<BR>&nbsp;&nbsp;goto bus_groups_fail;</P>
<P>&nbsp;pr_debug("bus: '%s': registered\n", bus-&gt;name);<BR>&nbsp;return 0;</P>
<P>bus_groups_fail:<BR>&nbsp;remove_probe_files(bus);<BR>bus_probe_files_fail:<BR>&nbsp;kset_unregister(bus-&gt;p-&gt;drivers_kset);<BR>bus_drivers_fail:<BR>&nbsp;kset_unregister(bus-&gt;p-&gt;devices_kset);<BR>bus_devices_fail:<BR>&nbsp;bus_remove_file(bus, &amp;bus_attr_uevent);<BR>bus_uevent_fail:<BR>&nbsp;kset_unregister(&amp;bus-&gt;p-&gt;subsys);<BR>out:<BR>&nbsp;kfree(bus-&gt;p);<BR>&nbsp;bus-&gt;p = NULL;<BR>&nbsp;return retval;<BR>}<BR>EXPORT_SYMBOL_GPL(bus_register);</P>
<P>/**<BR>&nbsp;* bus_unregister - remove a bus from the system<BR>&nbsp;* @bus: bus.<BR>&nbsp;*<BR>&nbsp;* Unregister the child subsystems and the bus itself.<BR>&nbsp;* Finally, we call bus_put() to release the refcount<BR>&nbsp;*/<BR>void bus_unregister(struct bus_type *bus)<BR>{<BR>&nbsp;pr_debug("bus: '%s': unregistering\n", bus-&gt;name);<BR>&nbsp;if (bus-&gt;dev_root)<BR>&nbsp;&nbsp;device_unregister(bus-&gt;dev_root);<BR>&nbsp;bus_remove_groups(bus, bus-&gt;bus_groups);<BR>&nbsp;remove_probe_files(bus);<BR>&nbsp;kset_unregister(bus-&gt;p-&gt;drivers_kset);<BR>&nbsp;kset_unregister(bus-&gt;p-&gt;devices_kset);<BR>&nbsp;bus_remove_file(bus, &amp;bus_attr_uevent);<BR>&nbsp;kset_unregister(&amp;bus-&gt;p-&gt;subsys);<BR>}<BR>EXPORT_SYMBOL_GPL(bus_unregister);</P>
<P>int bus_register_notifier(struct bus_type *bus, struct notifier_block *nb)<BR>{<BR>&nbsp;return blocking_notifier_chain_register(&amp;bus-&gt;p-&gt;bus_notifier, nb);<BR>}<BR>EXPORT_SYMBOL_GPL(bus_register_notifier);</P>
<P>int bus_unregister_notifier(struct bus_type *bus, struct notifier_block *nb)<BR>{<BR>&nbsp;return blocking_notifier_chain_unregister(&amp;bus-&gt;p-&gt;bus_notifier, nb);<BR>}<BR>EXPORT_SYMBOL_GPL(bus_unregister_notifier);</P>
<P>struct kset *bus_get_kset(struct bus_type *bus)<BR>{<BR>&nbsp;return &amp;bus-&gt;p-&gt;subsys;<BR>}<BR>EXPORT_SYMBOL_GPL(bus_get_kset);</P>
<P>struct klist *bus_get_device_klist(struct bus_type *bus)<BR>{<BR>&nbsp;return &amp;bus-&gt;p-&gt;klist_devices;<BR>}<BR>EXPORT_SYMBOL_GPL(bus_get_device_klist);</P>
<P>/*<BR>&nbsp;* Yes, this forcibly breaks the klist abstraction temporarily.&nbsp; It<BR>&nbsp;* just wants to sort the klist, not change reference counts and<BR>&nbsp;* take/drop locks rapidly in the process.&nbsp; It does all this while<BR>&nbsp;* holding the lock for the list, so objects can't otherwise be<BR>&nbsp;* added/removed while we're swizzling.<BR>&nbsp;*/<BR>static void device_insertion_sort_klist(struct device *a, struct list_head *list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int (*compare)(const struct device *a,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const struct device *b))<BR>{<BR>&nbsp;struct klist_node *n;<BR>&nbsp;struct device_private *dev_prv;<BR>&nbsp;struct device *b;</P>
<P>&nbsp;list_for_each_entry(n, list, n_node) {<BR>&nbsp;&nbsp;dev_prv = to_device_private_bus(n);<BR>&nbsp;&nbsp;b = dev_prv-&gt;device;<BR>&nbsp;&nbsp;if (compare(a, b) &lt;= 0) {<BR>&nbsp;&nbsp;&nbsp;list_move_tail(&amp;a-&gt;p-&gt;knode_bus.n_node,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;b-&gt;p-&gt;knode_bus.n_node);<BR>&nbsp;&nbsp;&nbsp;return;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;list_move_tail(&amp;a-&gt;p-&gt;knode_bus.n_node, list);<BR>}</P>
<P>void bus_sort_breadthfirst(struct bus_type *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*compare)(const struct device *a,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct device *b))<BR>{<BR>&nbsp;LIST_HEAD(sorted_devices);<BR>&nbsp;struct klist_node *n, *tmp;<BR>&nbsp;struct device_private *dev_prv;<BR>&nbsp;struct device *dev;<BR>&nbsp;struct klist *device_klist;</P>
<P>&nbsp;device_klist = bus_get_device_klist(bus);</P>
<P>&nbsp;spin_lock(&amp;device_klist-&gt;k_lock);<BR>&nbsp;list_for_each_entry_safe(n, tmp, &amp;device_klist-&gt;k_list, n_node) {<BR>&nbsp;&nbsp;dev_prv = to_device_private_bus(n);<BR>&nbsp;&nbsp;dev = dev_prv-&gt;device;<BR>&nbsp;&nbsp;device_insertion_sort_klist(dev, &amp;sorted_devices, compare);<BR>&nbsp;}<BR>&nbsp;list_splice(&amp;sorted_devices, &amp;device_klist-&gt;k_list);<BR>&nbsp;spin_unlock(&amp;device_klist-&gt;k_lock);<BR>}<BR>EXPORT_SYMBOL_GPL(bus_sort_breadthfirst);</P>
<P>/**<BR>&nbsp;* subsys_dev_iter_init - initialize subsys device iterator<BR>&nbsp;* @iter: subsys iterator to initialize<BR>&nbsp;* @subsys: the subsys we wanna iterate over<BR>&nbsp;* @start: the device to start iterating from, if any<BR>&nbsp;* @type: device_type of the devices to iterate over, NULL for all<BR>&nbsp;*<BR>&nbsp;* Initialize subsys iterator @iter such that it iterates over devices<BR>&nbsp;* of @subsys.&nbsp; If @start is set, the list iteration will start there,<BR>&nbsp;* otherwise if it is NULL, the iteration starts at the beginning of<BR>&nbsp;* the list.<BR>&nbsp;*/<BR>void subsys_dev_iter_init(struct subsys_dev_iter *iter, struct bus_type *subsys,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct device *start, const struct device_type *type)<BR>{<BR>&nbsp;struct klist_node *start_knode = NULL;</P>
<P>&nbsp;if (start)<BR>&nbsp;&nbsp;start_knode = &amp;start-&gt;p-&gt;knode_bus;<BR>&nbsp;klist_iter_init_node(&amp;subsys-&gt;p-&gt;klist_devices, &amp;iter-&gt;ki, start_knode);<BR>&nbsp;iter-&gt;type = type;<BR>}<BR>EXPORT_SYMBOL_GPL(subsys_dev_iter_init);</P>
<P>/**<BR>&nbsp;* subsys_dev_iter_next - iterate to the next device<BR>&nbsp;* @iter: subsys iterator to proceed<BR>&nbsp;*<BR>&nbsp;* Proceed @iter to the next device and return it.&nbsp; Returns NULL if<BR>&nbsp;* iteration is complete.<BR>&nbsp;*<BR>&nbsp;* The returned device is referenced and won't be released till<BR>&nbsp;* iterator is proceed to the next device or exited.&nbsp; The caller is<BR>&nbsp;* free to do whatever it wants to do with the device including<BR>&nbsp;* calling back into subsys code.<BR>&nbsp;*/<BR>struct device *subsys_dev_iter_next(struct subsys_dev_iter *iter)<BR>{<BR>&nbsp;struct klist_node *knode;<BR>&nbsp;struct device *dev;</P>
<P>&nbsp;for (;;) {<BR>&nbsp;&nbsp;knode = klist_next(&amp;iter-&gt;ki);<BR>&nbsp;&nbsp;if (!knode)<BR>&nbsp;&nbsp;&nbsp;return NULL;<BR>&nbsp;&nbsp;dev = to_device_private_bus(knode)-&gt;device;<BR>&nbsp;&nbsp;if (!iter-&gt;type || iter-&gt;type == dev-&gt;type)<BR>&nbsp;&nbsp;&nbsp;return dev;<BR>&nbsp;}<BR>}<BR>EXPORT_SYMBOL_GPL(subsys_dev_iter_next);</P>
<P>/**<BR>&nbsp;* subsys_dev_iter_exit - finish iteration<BR>&nbsp;* @iter: subsys iterator to finish<BR>&nbsp;*<BR>&nbsp;* Finish an iteration.&nbsp; Always call this function after iteration is<BR>&nbsp;* complete whether the iteration ran till the end or not.<BR>&nbsp;*/<BR>void subsys_dev_iter_exit(struct subsys_dev_iter *iter)<BR>{<BR>&nbsp;klist_iter_exit(&amp;iter-&gt;ki);<BR>}<BR>EXPORT_SYMBOL_GPL(subsys_dev_iter_exit);</P>
<P>int subsys_interface_register(struct subsys_interface *sif)<BR>{<BR>&nbsp;struct bus_type *subsys;<BR>&nbsp;struct subsys_dev_iter iter;<BR>&nbsp;struct device *dev;</P>
<P>&nbsp;if (!sif || !sif-&gt;subsys)<BR>&nbsp;&nbsp;return -ENODEV;</P>
<P>&nbsp;subsys = bus_get(sif-&gt;subsys);<BR>&nbsp;if (!subsys)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;mutex_lock(&amp;subsys-&gt;p-&gt;mutex);<BR>&nbsp;list_add_tail(&amp;sif-&gt;node, &amp;subsys-&gt;p-&gt;interfaces);<BR>&nbsp;if (sif-&gt;add_dev) {<BR>&nbsp;&nbsp;subsys_dev_iter_init(&amp;iter, subsys, NULL, NULL);<BR>&nbsp;&nbsp;while ((dev = subsys_dev_iter_next(&amp;iter)))<BR>&nbsp;&nbsp;&nbsp;sif-&gt;add_dev(dev, sif);<BR>&nbsp;&nbsp;subsys_dev_iter_exit(&amp;iter);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;subsys-&gt;p-&gt;mutex);</P>
<P>&nbsp;return 0;<BR>}<BR>EXPORT_SYMBOL_GPL(subsys_interface_register);</P>
<P>void subsys_interface_unregister(struct subsys_interface *sif)<BR>{<BR>&nbsp;struct bus_type *subsys;<BR>&nbsp;struct subsys_dev_iter iter;<BR>&nbsp;struct device *dev;</P>
<P>&nbsp;if (!sif || !sif-&gt;subsys)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;subsys = sif-&gt;subsys;</P>
<P>&nbsp;mutex_lock(&amp;subsys-&gt;p-&gt;mutex);<BR>&nbsp;list_del_init(&amp;sif-&gt;node);<BR>&nbsp;if (sif-&gt;remove_dev) {<BR>&nbsp;&nbsp;subsys_dev_iter_init(&amp;iter, subsys, NULL, NULL);<BR>&nbsp;&nbsp;while ((dev = subsys_dev_iter_next(&amp;iter)))<BR>&nbsp;&nbsp;&nbsp;sif-&gt;remove_dev(dev, sif);<BR>&nbsp;&nbsp;subsys_dev_iter_exit(&amp;iter);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;subsys-&gt;p-&gt;mutex);</P>
<P>&nbsp;bus_put(subsys);<BR>}<BR>EXPORT_SYMBOL_GPL(subsys_interface_unregister);</P>
<P>static void system_root_device_release(struct device *dev)<BR>{<BR>&nbsp;kfree(dev);<BR>}</P>
<P>static int subsys_register(struct bus_type *subsys,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct kobject *parent_of_root)<BR>{<BR>&nbsp;struct device *dev;<BR>&nbsp;int err;</P>
<P>&nbsp;err = bus_register(subsys);<BR>&nbsp;if (err &lt; 0)<BR>&nbsp;&nbsp;return err;</P>
<P>&nbsp;dev = kzalloc(sizeof(struct device), GFP_KERNEL);<BR>&nbsp;if (!dev) {<BR>&nbsp;&nbsp;err = -ENOMEM;<BR>&nbsp;&nbsp;goto err_dev;<BR>&nbsp;}</P>
<P>&nbsp;err = dev_set_name(dev, "%s", subsys-&gt;name);<BR>&nbsp;if (err &lt; 0)<BR>&nbsp;&nbsp;goto err_name;</P>
<P>&nbsp;dev-&gt;kobj.parent = parent_of_root;<BR>&nbsp;dev-&gt;groups = groups;<BR>&nbsp;dev-&gt;release = system_root_device_release;</P>
<P>&nbsp;err = device_register(dev);<BR>&nbsp;if (err &lt; 0)<BR>&nbsp;&nbsp;goto err_dev_reg;</P>
<P>&nbsp;subsys-&gt;dev_root = dev;<BR>&nbsp;return 0;</P>
<P>err_dev_reg:<BR>&nbsp;put_device(dev);<BR>&nbsp;dev = NULL;<BR>err_name:<BR>&nbsp;kfree(dev);<BR>err_dev:<BR>&nbsp;bus_unregister(subsys);<BR>&nbsp;return err;<BR>}</P>
<P>/**<BR>&nbsp;* subsys_system_register - register a subsystem at /sys/devices/system/<BR>&nbsp;* @subsys: system subsystem<BR>&nbsp;* @groups: default attributes for the root device<BR>&nbsp;*<BR>&nbsp;* All 'system' subsystems have a /sys/devices/system/&lt;name&gt; root device<BR>&nbsp;* with the name of the subsystem. The root device can carry subsystem-<BR>&nbsp;* wide attributes. All registered devices are below this single root<BR>&nbsp;* device and are named after the subsystem with a simple enumeration<BR>&nbsp;* number appended. The registered devices are not explicitly named;<BR>&nbsp;* only 'id' in the device needs to be set.<BR>&nbsp;*<BR>&nbsp;* Do not use this interface for anything new, it exists for compatibility<BR>&nbsp;* with bad ideas only. New subsystems should use plain subsystems; and<BR>&nbsp;* add the subsystem-wide attributes should be added to the subsystem<BR>&nbsp;* directory itself and not some create fake root-device placed in<BR>&nbsp;* /sys/devices/system/&lt;name&gt;.<BR>&nbsp;*/<BR>int subsys_system_register(struct bus_type *subsys,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups)<BR>{<BR>&nbsp;return subsys_register(subsys, groups, &amp;system_kset-&gt;kobj);<BR>}<BR>EXPORT_SYMBOL_GPL(subsys_system_register);</P>
<P>/**<BR>&nbsp;* subsys_virtual_register - register a subsystem at /sys/devices/virtual/<BR>&nbsp;* @subsys: virtual subsystem<BR>&nbsp;* @groups: default attributes for the root device<BR>&nbsp;*<BR>&nbsp;* All 'virtual' subsystems have a /sys/devices/system/&lt;name&gt; root device<BR>&nbsp;* with the name of the subystem.&nbsp; The root device can carry subsystem-wide<BR>&nbsp;* attributes.&nbsp; All registered devices are below this single root device.<BR>&nbsp;* There's no restriction on device naming.&nbsp; This is for kernel software<BR>&nbsp;* constructs which need sysfs interface.<BR>&nbsp;*/<BR>int subsys_virtual_register(struct bus_type *subsys,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct attribute_group **groups)<BR>{<BR>&nbsp;struct kobject *virtual_dir;</P>
<P>&nbsp;virtual_dir = virtual_device_parent(NULL);<BR>&nbsp;if (!virtual_dir)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;return subsys_register(subsys, groups, virtual_dir);<BR>}<BR>EXPORT_SYMBOL_GPL(subsys_virtual_register);</P>
<P>int __init buses_init(void)<BR>{<BR>&nbsp;bus_kset = kset_create_and_add("bus", &amp;bus_uevent_ops, NULL);<BR>&nbsp;if (!bus_kset)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;system_kset = kset_create_and_add("system", NULL, &amp;devices_kset-&gt;kobj);<BR>&nbsp;if (!system_kset)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;return 0;<BR>}