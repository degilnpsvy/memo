/**<BR>&nbsp;* bus_for_each_dev - device iterator.<BR>&nbsp;* @bus: bus type.<BR>&nbsp;* @start: device to start iterating from.<BR>&nbsp;* @data: data for the callback.<BR>&nbsp;* @fn: function to be called for each device.<BR>&nbsp;*<BR>&nbsp;* Iterate over @bus's list of devices, and call @fn for each,<BR>&nbsp;* passing it @data. If @start is not NULL, we use that device to<BR>&nbsp;* begin iterating from.<BR>&nbsp;*<BR>&nbsp;* We check the return of @fn each time. If it returns anything<BR>&nbsp;* other than 0, we break out and return that value.<BR>&nbsp;*<BR>&nbsp;* NOTE: The device that returns a non-zero value is not retained<BR>&nbsp;* in any way, nor is its refcount incremented. If the caller needs<BR>&nbsp;* to retain this data, it should do so, and increment the reference<BR>&nbsp;* count in the supplied callback.<BR>&nbsp;*/<BR>int bus_for_each_dev(struct bus_type *bus, struct device *start,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data, int (*fn)(struct device *, void *))<BR>{<BR>&nbsp;struct klist_iter i;<BR>&nbsp;struct device *dev;<BR>&nbsp;int error = 0;</P>
<P>&nbsp;if (!bus || !bus-&gt;p)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_devices, &amp;i,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (start ? &amp;start-&gt;p-&gt;knode_bus : NULL));<BR>&nbsp;while ((dev = next_device(&amp;i)) &amp;&amp; !error)<BR>&nbsp;&nbsp;error = fn(dev, data);<BR>&nbsp;klist_iter_exit(&amp;i);<BR>&nbsp;return error;<BR>}<BR>EXPORT_SYMBOL_GPL(bus_for_each_dev);