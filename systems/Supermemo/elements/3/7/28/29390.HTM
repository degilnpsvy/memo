/**<BR>&nbsp;* <FONT class=clozed>bus_find_device</FONT> - device iterator for locating a particular device.<BR>&nbsp;* @bus: bus type<BR>&nbsp;* @start: Device to begin with<BR>&nbsp;* @data: Data to pass to match function<BR>&nbsp;* @match: Callback function to check device<BR>&nbsp;*<BR>&nbsp;* This is similar to the bus_for_each_dev() function above, but it<BR>&nbsp;* returns a reference to a device that is 'found' for later use, as<BR>&nbsp;* determined by the @match callback.<BR>&nbsp;*<BR>&nbsp;* The callback should return 0 if the device doesn't match and non-zero<BR>&nbsp;* if it does.&nbsp; If the callback returns non-zero, this function will<BR>&nbsp;* return to the caller and not iterate over any more devices.<BR>&nbsp;*/<BR>struct device *bus_find_device(struct bus_type *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *start, void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*match)(struct device *dev, void *data))<BR>{<BR>&nbsp;struct klist_iter i;<BR>&nbsp;struct device *dev; 
<P></P>
<P>&nbsp;if (!bus || !bus-&gt;p)<BR>&nbsp;&nbsp;return NULL;</P>
<P><FONT class=clozed>&nbsp;klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_devices, &amp;i,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (start ? &amp;start-&gt;p-&gt;knode_bus : NULL));<BR>&nbsp;while ((dev = next_device(&amp;i)))<BR>&nbsp;&nbsp;if (match(dev, data) &amp;&amp; get_device(dev))<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;klist_iter_exit(&amp;i)</FONT>;<BR>&nbsp;return dev;<BR>}<BR>EXPORT_SYMBOL_GPL(bus_find_device);