/**<BR>&nbsp;*&nbsp;completion_done - Test to see if a completion has any waiters<BR>&nbsp;*&nbsp;@x:&nbsp;completion structure<BR>&nbsp;*<BR>&nbsp;*&nbsp;Return: 0 if there are waiters (wait_for_completion() in progress)<BR>&nbsp;*&nbsp;&nbsp; 1 if there are no waiters.<BR>&nbsp;*<BR>&nbsp;*/<BR>bool completion_done(struct completion *x)<BR>{<BR>&nbsp;if (!READ_ONCE(x-&gt;done))<BR>&nbsp;&nbsp;return false;</P>
<P>&nbsp;/*<BR>&nbsp; * If -&gt;done, we need to wait for complete() to release -&gt;wait.lock<BR>&nbsp; * otherwise we can end up freeing the completion before complete()<BR>&nbsp; * is done referencing it.<BR>&nbsp; *<BR>&nbsp; * The RMB pairs with complete()'s RELEASE of -&gt;wait.lock and orders<BR>&nbsp; * the loads of -&gt;done and -&gt;wait.lock such that we cannot observe<BR>&nbsp; * the lock before complete() acquires it while observing the -&gt;done<BR>&nbsp; * after it's acquired the lock.<BR>&nbsp; */<BR>&nbsp;smp_rmb();<BR>&nbsp;spin_unlock_wait(&amp;x-&gt;wait.lock);<BR>&nbsp;return true;<BR>}<BR>EXPORT_SYMBOL(completion_done);