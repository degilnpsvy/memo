/**<BR>&nbsp;*&nbsp;try_wait_for_completion - try to decrement a completion without blocking<BR>&nbsp;*&nbsp;@x:&nbsp;completion structure<BR>&nbsp;*<BR>&nbsp;*&nbsp;Return: 0 if a decrement cannot be done without blocking<BR>&nbsp;*&nbsp;&nbsp; 1 if a decrement succeeded.<BR>&nbsp;*<BR>&nbsp;*&nbsp;If a completion is being used as a counting completion,<BR>&nbsp;*&nbsp;attempt to decrement the counter without blocking. This<BR>&nbsp;*&nbsp;enables us to avoid waiting if the resource the completion<BR>&nbsp;*&nbsp;is protecting is not available.<BR>&nbsp;*/<BR>bool try_wait_for_completion(struct completion *x)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;int ret = 1;</P>
<P>&nbsp;/*<BR>&nbsp; * Since x-&gt;done will need to be locked only<BR>&nbsp; * in the non-blocking case, we check x-&gt;done<BR>&nbsp; * first without taking the lock so we can<BR>&nbsp; * return early in the blocking case.<BR>&nbsp; */<BR>&nbsp;if (!READ_ONCE(x-&gt;done))<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;spin_lock_irqsave(&amp;x-&gt;wait.lock, flags);<BR>&nbsp;if (!x-&gt;done)<BR>&nbsp;&nbsp;ret = 0;<BR>&nbsp;else<BR>&nbsp;&nbsp;x-&gt;done--;<BR>&nbsp;spin_unlock_irqrestore(&amp;x-&gt;wait.lock, flags);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL(try_wait_for_completion);