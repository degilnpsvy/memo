/**<BR>&nbsp;* class_find_device - device iterator for locating a particular device<BR>&nbsp;* @class: the class we're iterating<BR>&nbsp;* @start: Device to begin with<BR>&nbsp;* @data: data for the match function<BR>&nbsp;* @match: function to check device<BR>&nbsp;*<BR>&nbsp;* This is similar to the class_for_each_dev() function above, but it<BR>&nbsp;* returns a reference to a device that is 'found' for later use, as<BR>&nbsp;* determined by the @match callback.<BR>&nbsp;*<BR>&nbsp;* The callback should return 0 if the device doesn't match and non-zero<BR>&nbsp;* if it does.&nbsp; If the callback returns non-zero, this function will<BR>&nbsp;* return to the caller and not iterate over any more devices.<BR>&nbsp;*<BR>&nbsp;* Note, you will need to drop the reference with put_device() after use.<BR>&nbsp;*<BR>&nbsp;* @fn is allowed to do anything including calling back into class<BR>&nbsp;* code.&nbsp; There's no locking restriction.<BR>&nbsp;*/<BR>struct device *class_find_device(struct class *class, struct device *start,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp; int (*match)(struct device *, const void *))<BR>{<BR>&nbsp;struct class_dev_iter iter;<BR>&nbsp;struct device *dev; 
<P></P>
<P>&nbsp;if (!class)<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;if (<SPAN class=cloze>[...]</SPAN>) {<BR>&nbsp;&nbsp;WARN(1, "%s called for class '%s' before it was initialized",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __func__, class-&gt;name);<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;}</P>
<P>&nbsp;class_dev_iter_init(&amp;iter, class, start, NULL);<BR>&nbsp;while ((dev = class_dev_iter_next(&amp;iter))) {<BR>&nbsp;&nbsp;if (match(dev, data)) {<BR>&nbsp;&nbsp;&nbsp;get_device(dev);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;class_dev_iter_exit(&amp;iter);</P>
<P>&nbsp;return dev;<BR>}<BR>EXPORT_SYMBOL_GPL(class_find_device);