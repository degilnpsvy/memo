/* Function checks whether WFx (WFI/WFE) instructions are set up to be trapped.<BR>&nbsp;* The function returns the target EL (1-3) if the instruction is to be trapped;<BR>&nbsp;* otherwise it returns 0 indicating it is not trapped.<BR>&nbsp;*/<BR>static inline int check_wfx_trap(CPUARMState *env, bool is_wfe)<BR>{<BR>&nbsp;&nbsp;&nbsp; int cur_el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; uint64_t mask;</P>
<P>&nbsp;&nbsp;&nbsp; /* If we are currently in EL0 then we need to check if SCTLR is set up for<BR>&nbsp;&nbsp;&nbsp;&nbsp; * WFx instructions being trapped to EL1. These trap bits don't exist in v7.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (cur_el &lt; 1 &amp;&amp; arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int target_el;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = is_wfe ? SCTLR_nTWE : SCTLR_nTWI;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_is_secure_below_el3(env) &amp;&amp; !arm_el_is_aa64(env, 3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Secure EL0 and Secure PL1 is at EL3 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(env-&gt;cp15.sctlr_el[target_el] &amp; mask)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return target_el;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* We are not trapping to EL1; trap to EL2 if HCR_EL2 requires it<BR>&nbsp;&nbsp;&nbsp;&nbsp; * No need for ARM_FEATURE check as if HCR_EL2 doesn't exist the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * bits will be zero indicating no trap.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (cur_el &lt; 2 &amp;&amp; !arm_is_secure(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = (is_wfe) ? HCR_TWE : HCR_TWI;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;cp15.hcr_el2 &amp; mask) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* We are not trapping to EL1 or EL2; trap to EL3 if SCR_EL3 requires it */<BR>&nbsp;&nbsp;&nbsp; if (cur_el &lt; 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = (is_wfe) ? SCR_TWE : SCR_TWI;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;cp15.scr_el3 &amp; mask) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>void HELPER(wfi)(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(arm_env_get_cpu(env));<BR>&nbsp;&nbsp;&nbsp; int target_el = check_wfx_trap(env, false);</P>
<P>&nbsp;&nbsp;&nbsp; if (cpu_has_work(cs)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Don't bother to go into our "low power state" if<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * we would just wake up immediately.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (target_el) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pc -= 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise_exception(env, EXCP_UDEF, syn_wfx(1, 0xe, 0), target_el);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = EXCP_HLT;<BR>&nbsp;&nbsp;&nbsp; cs-&gt;halted = 1;<BR>&nbsp;&nbsp;&nbsp; cpu_loop_exit(cs);<BR>}</P>
<P>void HELPER(wfe)(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* This is a hint instruction that is semantically different<BR>&nbsp;&nbsp;&nbsp;&nbsp; * from YIELD even though we currently implement it identically.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Don't actually halt the CPU, just yield back to top<BR>&nbsp;&nbsp;&nbsp;&nbsp; * level loop. This is not going into a "low power state"<BR>&nbsp;&nbsp;&nbsp;&nbsp; * (ie halting until some event occurs), so we never take<BR>&nbsp;&nbsp;&nbsp;&nbsp; * a configurable trap to a different exception level.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; HELPER(yield)(env);<BR>}</P>
<P>void HELPER(yield)(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);</P>
<P>&nbsp;&nbsp;&nbsp; /* This is a non-trappable hint instruction that generally indicates<BR>&nbsp;&nbsp;&nbsp;&nbsp; * that the guest is currently busy-looping. Yield control back to the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * top level loop so that a more deserving VCPU has a chance to run.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = EXCP_YIELD;<BR>&nbsp;&nbsp;&nbsp; cpu_loop_exit(cs);<BR>}</P>
<P>/* Raise an internal-to-QEMU exception. This is limited to only<BR>&nbsp;* those EXCP values which are special cases for QEMU to interrupt<BR>&nbsp;* execution and not to be used for exceptions which are passed to<BR>&nbsp;* the guest (those must all have syndrome information and thus should<BR>&nbsp;* use exception_with_syndrome).<BR>&nbsp;*/<BR>void HELPER(exception_internal)(CPUARMState *env, uint32_t excp)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(arm_env_get_cpu(env));</P>
<P>&nbsp;&nbsp;&nbsp; assert(excp_is_internal(excp));<BR>&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = excp;<BR>&nbsp;&nbsp;&nbsp; cpu_loop_exit(cs);<BR>}</P>
<P>/* Raise an exception with the specified syndrome register value */<BR>void HELPER(exception_with_syndrome)(CPUARMState *env, uint32_t excp,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t syndrome, uint32_t target_el)<BR>{<BR>&nbsp;&nbsp;&nbsp; raise_exception(env, excp, syndrome, target_el);<BR>}