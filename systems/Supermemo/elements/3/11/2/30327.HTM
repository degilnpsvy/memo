# target-arm/helper.c 
<P></P>
<P>#include "qemu/osdep.h"<BR>#include "cpu.h"<BR>#include "internals.h"<BR>#include "exec/gdbstub.h"<BR>#include "exec/helper-proto.h"<BR>#include "qemu/host-utils.h"<BR>#include "sysemu/arch_init.h"<BR>#include "sysemu/sysemu.h"<BR>#include "qemu/bitops.h"<BR>#include "qemu/crc32c.h"<BR>#include "exec/exec-all.h"<BR>#include "exec/cpu_ldst.h"<BR>#include "arm_ldst.h"<BR>#include &lt;zlib.h&gt; /* For crc32 */<BR>#include "exec/semihost.h"<BR>#include "sysemu/kvm.h"</P>
<P></P>
<P><FONT class=extract>#define ARM_CPU_FREQ 1000000000 /* FIXME: 1 GHz, should be configurable */</FONT></P>
<P><FONT class=extract>#ifndef CONFIG_USER_ONLY<BR>static bool get_phys_addr(CPUARMState *env, target_ulong address,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access_type, ARMMMUIdx mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwaddr *phys_ptr, MemTxAttrs *attrs, int *prot,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong *page_size, uint32_t *fsr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUFaultInfo *fi);</FONT></P>
<P><FONT class=extract>static bool get_phys_addr_lpae(CPUARMState *env, target_ulong address,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access_type, ARMMMUIdx mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwaddr *phys_ptr, MemTxAttrs *txattrs, int *prot,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong *page_size_ptr, uint32_t *fsr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUFaultInfo *fi);</FONT></P>
<P><FONT class=extract>/* Definitions for the PMCCNTR and PMCR registers */<BR>#define PMCRD&nbsp;&nbsp; 0x8<BR>#define PMCRC&nbsp;&nbsp; 0x4<BR>#define PMCRE&nbsp;&nbsp; 0x1<BR>#endif</FONT></P>
<P>static int vfp_gdb_get_reg(CPUARMState *env, uint8_t *buf, int reg)<BR>{<BR>&nbsp;&nbsp;&nbsp; int nregs;</P>
<P>&nbsp;&nbsp;&nbsp; /* VFP data registers are always little-endian.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; nregs = arm_feature(env, ARM_FEATURE_VFP3) ? 32 : 16;<BR>&nbsp;&nbsp;&nbsp; if (reg &lt; nregs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stfq_le_p(buf, env-&gt;vfp.regs[reg]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 8;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_NEON)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Aliases for Q regs.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nregs += 16;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (reg &lt; nregs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stfq_le_p(buf, env-&gt;vfp.regs[(reg - 32) * 2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stfq_le_p(buf + 8, env-&gt;vfp.regs[(reg - 32) * 2 + 1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 16;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; switch (reg - nregs) {<BR>&nbsp;&nbsp;&nbsp; case 0: stl_p(buf, env-&gt;vfp.xregs[ARM_VFP_FPSID]); return 4;<BR>&nbsp;&nbsp;&nbsp; case 1: stl_p(buf, env-&gt;vfp.xregs[ARM_VFP_FPSCR]); return 4;<BR>&nbsp;&nbsp;&nbsp; case 2: stl_p(buf, env-&gt;vfp.xregs[ARM_VFP_FPEXC]); return 4;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>static int vfp_gdb_set_reg(CPUARMState *env, uint8_t *buf, int reg)<BR>{<BR>&nbsp;&nbsp;&nbsp; int nregs;</P>
<P>&nbsp;&nbsp;&nbsp; nregs = arm_feature(env, ARM_FEATURE_VFP3) ? 32 : 16;<BR>&nbsp;&nbsp;&nbsp; if (reg &lt; nregs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;vfp.regs[reg] = ldfq_le_p(buf);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 8;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_NEON)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nregs += 16;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (reg &lt; nregs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;vfp.regs[(reg - 32) * 2] = ldfq_le_p(buf);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;vfp.regs[(reg - 32) * 2 + 1] = ldfq_le_p(buf + 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 16;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; switch (reg - nregs) {<BR>&nbsp;&nbsp;&nbsp; case 0: env-&gt;vfp.xregs[ARM_VFP_FPSID] = ldl_p(buf); return 4;<BR>&nbsp;&nbsp;&nbsp; case 1: env-&gt;vfp.xregs[ARM_VFP_FPSCR] = ldl_p(buf); return 4;<BR>&nbsp;&nbsp;&nbsp; case 2: env-&gt;vfp.xregs[ARM_VFP_FPEXC] = ldl_p(buf) &amp; (1 &lt;&lt; 30); return 4;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>static int aarch64_fpu_gdb_get_reg(CPUARMState *env, uint8_t *buf, int reg)<BR>{<BR>&nbsp;&nbsp;&nbsp; switch (reg) {<BR>&nbsp;&nbsp;&nbsp; case 0 ... 31:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 128 bit FP register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stfq_le_p(buf, env-&gt;vfp.regs[reg * 2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stfq_le_p(buf + 8, env-&gt;vfp.regs[reg * 2 + 1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 16;<BR>&nbsp;&nbsp;&nbsp; case 32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* FPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stl_p(buf, vfp_get_fpsr(env));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 4;<BR>&nbsp;&nbsp;&nbsp; case 33:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* FPCR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stl_p(buf, vfp_get_fpcr(env));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 4;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static int aarch64_fpu_gdb_set_reg(CPUARMState *env, uint8_t *buf, int reg)<BR>{<BR>&nbsp;&nbsp;&nbsp; switch (reg) {<BR>&nbsp;&nbsp;&nbsp; case 0 ... 31:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 128 bit FP register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;vfp.regs[reg * 2] = ldfq_le_p(buf);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;vfp.regs[reg * 2 + 1] = ldfq_le_p(buf + 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 16;<BR>&nbsp;&nbsp;&nbsp; case 32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* FPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vfp_set_fpsr(env, ldl_p(buf));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 4;<BR>&nbsp;&nbsp;&nbsp; case 33:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* FPCR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vfp_set_fpcr(env, ldl_p(buf));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 4;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P><FONT class=extract>static uint64_t raw_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; assert(ri-&gt;fieldoffset);<BR>&nbsp;&nbsp;&nbsp; if (cpreg_field_is_64bit(ri)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CPREG_FIELD64(env, ri);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CPREG_FIELD32(env, ri);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void raw_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; assert(ri-&gt;fieldoffset);<BR>&nbsp;&nbsp;&nbsp; if (cpreg_field_is_64bit(ri)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPREG_FIELD64(env, ri) = value;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPREG_FIELD32(env, ri) = value;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void *raw_ptr(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (char *)env + ri-&gt;fieldoffset;<BR>}</FONT></P>
<P><FONT class=extract>uint64_t read_raw_cp_reg(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Raw read of a coprocessor register (as needed for migration, etc). */<BR>&nbsp;&nbsp;&nbsp; if (ri-&gt;type &amp; ARM_CP_CONST) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ri-&gt;resetvalue;<BR>&nbsp;&nbsp;&nbsp; } else if (ri-&gt;raw_readfn) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ri-&gt;raw_readfn(env, ri);<BR>&nbsp;&nbsp;&nbsp; } else if (ri-&gt;readfn) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ri-&gt;readfn(env, ri);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return raw_read(env, ri);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void write_raw_cp_reg(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t v)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Raw write of a coprocessor register (as needed for migration, etc).<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Note that constant registers are treated as write-ignored; the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * caller should check for success by whether a readback gives the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * value written.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (ri-&gt;type &amp; ARM_CP_CONST) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; } else if (ri-&gt;raw_writefn) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ri-&gt;raw_writefn(env, ri, v);<BR>&nbsp;&nbsp;&nbsp; } else if (ri-&gt;writefn) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ri-&gt;writefn(env, ri, v);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw_write(env, ri, v);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static bool raw_accessors_invalid(const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp; /* Return true if the regdef would cause an assertion if you called<BR>&nbsp;&nbsp;&nbsp; * read_raw_cp_reg() or write_raw_cp_reg() on it (ie if it is a<BR>&nbsp;&nbsp;&nbsp; * program bug for it not to have the NO_RAW flag).<BR>&nbsp;&nbsp;&nbsp; * NB that returning false here doesn't necessarily mean that calling<BR>&nbsp;&nbsp;&nbsp; * read/write_raw_cp_reg() is safe, because we can't distinguish "has<BR>&nbsp;&nbsp;&nbsp; * read/write access functions which are safe for raw use" from "has<BR>&nbsp;&nbsp;&nbsp; * read/write access functions which have side effects but has forgotten<BR>&nbsp;&nbsp;&nbsp; * to provide raw access functions".<BR>&nbsp;&nbsp;&nbsp; * The tests here line up with the conditions in read/write_raw_cp_reg()<BR>&nbsp;&nbsp;&nbsp; * and assertions in raw_read()/raw_write().<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if ((ri-&gt;type &amp; ARM_CP_CONST) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ri-&gt;fieldoffset ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((ri-&gt;raw_writefn || ri-&gt;writefn) &amp;&amp; (ri-&gt;raw_readfn || ri-&gt;readfn))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return true;<BR>}</FONT></P>
<P><FONT class=extract>bool write_cpustate_to_list(ARMCPU *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Write the coprocessor state from cpu-&gt;env to the (index,value) list. */<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; bool ok = true;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; cpu-&gt;cpreg_array_len; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t regidx = kvm_to_cpreg_id(cpu-&gt;cpreg_indexes[i]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ri = get_arm_cp_reginfo(cpu-&gt;cp_regs, regidx);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!ri) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ri-&gt;type &amp; ARM_CP_NO_RAW) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_values[i] = read_raw_cp_reg(&amp;cpu-&gt;env, ri);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return ok;<BR>}</FONT></P>
<P><FONT class=extract>bool write_list_to_cpustate(ARMCPU *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; bool ok = true;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; cpu-&gt;cpreg_array_len; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t regidx = kvm_to_cpreg_id(cpu-&gt;cpreg_indexes[i]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t v = cpu-&gt;cpreg_values[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ri = get_arm_cp_reginfo(cpu-&gt;cp_regs, regidx);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!ri) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ri-&gt;type &amp; ARM_CP_NO_RAW) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Write value and confirm it reads back as written<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * (to catch read-only registers and partially read-only<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * registers where the incoming migration value doesn't match)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_raw_cp_reg(&amp;cpu-&gt;env, ri, v);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (read_raw_cp_reg(&amp;cpu-&gt;env, ri) != v) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return ok;<BR>}</FONT></P>
<P><FONT class=extract>static void add_cpreg_to_list(gpointer key, gpointer opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; uint64_t regidx;<BR>&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; regidx = *(uint32_t *)key;<BR>&nbsp;&nbsp;&nbsp; ri = get_arm_cp_reginfo(cpu-&gt;cp_regs, regidx);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!(ri-&gt;type &amp; (ARM_CP_NO_RAW|ARM_CP_ALIAS))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_indexes[cpu-&gt;cpreg_array_len] = cpreg_to_kvm_id(regidx);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The value array need not be initialized at this point */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_array_len++;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void count_cpreg(gpointer key, gpointer opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; uint64_t regidx;<BR>&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; regidx = *(uint32_t *)key;<BR>&nbsp;&nbsp;&nbsp; ri = get_arm_cp_reginfo(cpu-&gt;cp_regs, regidx);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!(ri-&gt;type &amp; (ARM_CP_NO_RAW|ARM_CP_ALIAS))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_array_len++;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static gint cpreg_key_compare(gconstpointer a, gconstpointer b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t aidx = cpreg_to_kvm_id(*(uint32_t *)a);<BR>&nbsp;&nbsp;&nbsp; uint64_t bidx = cpreg_to_kvm_id(*(uint32_t *)b);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (aidx &gt; bidx) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (aidx &lt; bidx) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</FONT></P>
<P><FONT class=extract>void init_cpreg_list(ARMCPU *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Initialise the cpreg_tuples[] array based on the cp_regs hash.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Note that we require cpreg_tuples[] to be sorted by key ID.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; GList *keys;<BR>&nbsp;&nbsp;&nbsp; int arraylen;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; keys = g_hash_table_get_keys(cpu-&gt;cp_regs);<BR>&nbsp;&nbsp;&nbsp; keys = g_list_sort(keys, cpreg_key_compare);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_array_len = 0;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; g_list_foreach(keys, count_cpreg, cpu);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; arraylen = cpu-&gt;cpreg_array_len;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_indexes = g_new(uint64_t, arraylen);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_values = g_new(uint64_t, arraylen);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_vmstate_indexes = g_new(uint64_t, arraylen);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_vmstate_values = g_new(uint64_t, arraylen);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_vmstate_array_len = cpu-&gt;cpreg_array_len;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;cpreg_array_len = 0;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; g_list_foreach(keys, add_cpreg_to_list, cpu);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; assert(cpu-&gt;cpreg_array_len == arraylen);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; g_list_free(keys);<BR>}</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Some registers are not accessible if EL3.NS=0 and EL3 is using AArch32 but<BR>&nbsp;* they are accessible when EL3 is using AArch64 regardless of EL3.NS.<BR>&nbsp;*<BR>&nbsp;* access_el3_aa32ns: Used to check AArch32 register views.<BR>&nbsp;* access_el3_aa32ns_aa64any: Used to check both AArch32/64 register views.<BR>&nbsp;*/<BR>static CPAccessResult access_el3_aa32ns(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; bool secure = arm_is_secure_below_el3(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; assert(!arm_el_is_aa64(env, 3));<BR>&nbsp;&nbsp;&nbsp; if (secure) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_UNCATEGORIZED;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult access_el3_aa32ns_aa64any(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (!arm_el_is_aa64(env, 3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return access_el3_aa32ns(env, ri, isread);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>/* Some secure-only AArch32 registers trap to EL3 if used from<BR>&nbsp;* Secure EL1 (but are just ordinary UNDEF in other non-EL3 contexts).<BR>&nbsp;* Note that an access from Secure EL1 can only happen if EL3 is AArch64.<BR>&nbsp;* We assume that the .access field is set to PL1_RW.<BR>&nbsp;*/<BR>static CPAccessResult access_trap_aa32s_el1(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL3;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* This will be EL1 NS and EL2 NS, which just UNDEF */<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_UNCATEGORIZED;<BR>}</FONT></P>
<P><FONT class=extract>/* Check for traps to "powerdown debug" registers, which are controlled<BR>&nbsp;* by MDCR.TDOSA<BR>&nbsp;*/<BR>static CPAccessResult access_tdosa(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; int el = arm_current_el(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (el &lt; 2 &amp;&amp; (env-&gt;cp15.mdcr_el2 &amp; MDCR_TDOSA)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (el &lt; 3 &amp;&amp; (env-&gt;cp15.mdcr_el3 &amp; MDCR_TDOSA)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL3;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>/* Check for traps to "debug ROM" registers, which are controlled<BR>&nbsp;* by MDCR_EL2.TDRA for EL2 but by the more general MDCR_EL3.TDA for EL3.<BR>&nbsp;*/<BR>static CPAccessResult access_tdra(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; int el = arm_current_el(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (el &lt; 2 &amp;&amp; (env-&gt;cp15.mdcr_el2 &amp; MDCR_TDRA)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (el &lt; 3 &amp;&amp; (env-&gt;cp15.mdcr_el3 &amp; MDCR_TDA)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL3;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>/* Check for traps to general debug registers, which are controlled<BR>&nbsp;* by MDCR_EL2.TDA for EL2 and MDCR_EL3.TDA for EL3.<BR>&nbsp;*/<BR>static CPAccessResult access_tda(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; int el = arm_current_el(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (el &lt; 2 &amp;&amp; (env-&gt;cp15.mdcr_el2 &amp; MDCR_TDA)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (el &lt; 3 &amp;&amp; (env-&gt;cp15.mdcr_el3 &amp; MDCR_TDA)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL3;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>/* Check for traps to performance monitor registers, which are controlled<BR>&nbsp;* by MDCR_EL2.TPM for EL2 and MDCR_EL3.TPM for EL3.<BR>&nbsp;*/<BR>static CPAccessResult access_tpm(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; int el = arm_current_el(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (el &lt; 2 &amp;&amp; (env-&gt;cp15.mdcr_el2 &amp; MDCR_TPM)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (el &lt; 3 &amp;&amp; (env-&gt;cp15.mdcr_el3 &amp; MDCR_TPM)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL3;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static void dacr_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1); /* Flush TLB as domain not tracked in TLB */<BR>}</FONT></P>
<P><FONT class=extract>static void fcse_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (raw_read(env, ri) != value) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Unlike real hardware the qemu TLB uses virtual addresses,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * not modified virtual addresses, so this causes a TLB flush.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void contextidr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (raw_read(env, ri) != value &amp;&amp; !arm_feature(env, ARM_FEATURE_MPU)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !extended_addresses_enabled(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* For VMSA (when not using the LPAE long descriptor page table<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * format) this register includes the ASID, so do a TLB flush.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * For PMSA it is purely a process ID and no action is needed.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>}</FONT></P>
<P><FONT class=extract>static void tlbiall_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate all (TLBIALL) */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>}</FONT></P>
<P><FONT class=extract>static void tlbimva_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate single TLB entry by MVA and ASID (TLBIMVA) */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tlb_flush_page(CPU(cpu), value &amp; TARGET_PAGE_MASK);<BR>}</FONT></P>
<P><FONT class=extract>static void tlbiasid_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate by ASID (TLBIASID) */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), value == 0);<BR>}</FONT></P>
<P><FONT class=extract>static void tlbimvaa_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate single entry by MVA, all ASIDs (TLBIMVAA) */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tlb_flush_page(CPU(cpu), value &amp; TARGET_PAGE_MASK);<BR>}</FONT></P>
<P><FONT class=extract>/* IS variants of TLB operations must affect all cores */<BR>static void tlbiall_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush(other_cs, 1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbiasid_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush(other_cs, value == 0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbimva_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page(other_cs, value &amp; TARGET_PAGE_MASK);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbimvaa_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page(other_cs, value &amp; TARGET_PAGE_MASK);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbiall_nsnh_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = ENV_GET_CPU(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(cs, ARMMMUIdx_S12NSE1, ARMMMUIdx_S12NSE0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S2NS, -1);<BR>}</FONT></P>
<P><FONT class=extract>static void tlbiall_nsnh_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(other_cs, ARMMMUIdx_S12NSE1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S12NSE0, ARMMMUIdx_S2NS, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbiipas2_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate by IPA. This has to invalidate any structures that<BR>&nbsp;&nbsp;&nbsp;&nbsp; * contain only stage 2 translation information, but does not need<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to apply to structures that contain combined stage 1 and stage 2<BR>&nbsp;&nbsp;&nbsp;&nbsp; * translation information.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This must NOP if EL2 isn't implemented or SCR_EL3.NS is zero.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = ENV_GET_CPU(env);<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_EL2) || !(env-&gt;cp15.scr_el3 &amp; SCR_NS)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; pageaddr = sextract64(value &lt;&lt; 12, 0, 40);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(cs, pageaddr, ARMMMUIdx_S2NS, -1);<BR>}</FONT></P>
<P><FONT class=extract>static void tlbiipas2_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_EL2) || !(env-&gt;cp15.scr_el3 &amp; SCR_NS)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; pageaddr = sextract64(value &lt;&lt; 12, 0, 40);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(other_cs, pageaddr, ARMMMUIdx_S2NS, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbiall_hyp_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = ENV_GET_CPU(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(cs, ARMMMUIdx_S1E2, -1);<BR>}</FONT></P>
<P><FONT class=extract>static void tlbiall_hyp_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(other_cs, ARMMMUIdx_S1E2, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbimva_hyp_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = ENV_GET_CPU(env);<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr = value &amp; ~MAKE_64BIT_MASK(0, 12);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(cs, pageaddr, ARMMMUIdx_S1E2, -1);<BR>}</FONT></P>
<P><FONT class=extract>static void tlbimva_hyp_is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr = value &amp; ~MAKE_64BIT_MASK(0, 12);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(other_cs, pageaddr, ARMMMUIdx_S1E2, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* Define the secure and non-secure FCSE identifier CP registers<BR>&nbsp;&nbsp;&nbsp;&nbsp; * separately because there is no secure bank in V8 (no _EL3).&nbsp; This allows<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the secure register to be properly reset and migrated. There is also no<BR>&nbsp;&nbsp;&nbsp;&nbsp; * v8 EL1 version of the register so the non-secure instance stands alone.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "FCSEIDR(NS)",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 13, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .secure = ARM_CP_SECSTATE_NS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.fcseidr_ns),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, .writefn = fcse_write, .raw_writefn = raw_write, },<BR>&nbsp;&nbsp;&nbsp; { .name = "FCSEIDR(S)",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 13, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .secure = ARM_CP_SECSTATE_S,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.fcseidr_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, .writefn = fcse_write, .raw_writefn = raw_write, },<BR>&nbsp;&nbsp;&nbsp; /* Define the secure and non-secure context identifier CP registers<BR>&nbsp;&nbsp;&nbsp;&nbsp; * separately because there is no secure bank in V8 (no _EL3).&nbsp; This allows<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the secure register to be properly reset and migrated.&nbsp; In the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * non-secure case, the 32-bit register will have reset and migration<BR>&nbsp;&nbsp;&nbsp;&nbsp; * disabled during registration as it is handled by the 64-bit instance.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "CONTEXTIDR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 13, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .secure = ARM_CP_SECSTATE_NS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.contextidr_el[1]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, .writefn = contextidr_write, .raw_writefn = raw_write, },<BR>&nbsp;&nbsp;&nbsp; { .name = "CONTEXTIDR(S)", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 13, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .secure = ARM_CP_SECSTATE_S,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.contextidr_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, .writefn = contextidr_write, .raw_writefn = raw_write, },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo not_v8_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* NB: Some of these registers exist in v8 but with more precise<BR>&nbsp;&nbsp;&nbsp;&nbsp; * definitions that don't use CP_ANY wildcards (mostly in v8_cp_reginfo[]).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; /* MMU Domain access control / MPU write buffer control */<BR>&nbsp;&nbsp;&nbsp; { .name = "DACR",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = CP_ANY, .crn = 3, .crm = CP_ANY, .opc2 = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = dacr_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetoflow32(CPUARMState, cp15.dacr_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetoflow32(CPUARMState, cp15.dacr_ns) } },<BR>&nbsp;&nbsp;&nbsp; /* ARMv7 allocates a range of implementation defined TLB LOCKDOWN regs.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * For v6 and v5, these mappings are overly broad.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "TLB_LOCKDOWN", .cp = 15, .crn = 10, .crm = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = CP_ANY, .access = PL1_RW, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLB_LOCKDOWN", .cp = 15, .crn = 10, .crm = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = CP_ANY, .access = PL1_RW, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLB_LOCKDOWN", .cp = 15, .crn = 10, .crm = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = CP_ANY, .access = PL1_RW, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLB_LOCKDOWN", .cp = 15, .crn = 10, .crm = 8,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = CP_ANY, .access = PL1_RW, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; /* Cache maintenance ops; some of this space may be overridden later. */<BR>&nbsp;&nbsp;&nbsp; { .name = "CACHEMAINT", .cp = 15, .crn = 7, .crm = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = 0, .opc2 = CP_ANY, .access = PL1_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP | ARM_CP_OVERRIDE },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo not_v6_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* Not all pre-v6 cores implemented this WFI, so this is slightly<BR>&nbsp;&nbsp;&nbsp;&nbsp; * over-broad.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "WFI_v5", .cp = 15, .crn = 7, .crm = 8, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_WFI },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo not_v7_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* Standard v6 WFI (also used in some pre-v6 cores); not in v7 (which<BR>&nbsp;&nbsp;&nbsp;&nbsp; * is UNPREDICTABLE; we choose to NOP as most implementations do).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "WFI_v6", .cp = 15, .crn = 7, .crm = 0, .opc1 = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_WFI },<BR>&nbsp;&nbsp;&nbsp; /* L1 cache lockdown. Not architectural in v6 and earlier but in practice<BR>&nbsp;&nbsp;&nbsp;&nbsp; * implemented in 926, 946, 1026, 1136, 1176 and 11MPCore. StrongARM and<BR>&nbsp;&nbsp;&nbsp;&nbsp; * OMAPCP will override this space.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "DLOCKDOWN", .cp = 15, .crn = 9, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.c9_data),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "ILOCKDOWN", .cp = 15, .crn = 9, .crm = 0, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.c9_insn),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* v6 doesn't have the cache ID registers but Linux reads them anyway */<BR>&nbsp;&nbsp;&nbsp; { .name = "DUMMY", .cp = 15, .crn = 0, .crm = 0, .opc1 = 1, .opc2 = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST | ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* We don't implement pre-v7 debug but most CPUs had at least a DBGDIDR;<BR>&nbsp;&nbsp;&nbsp;&nbsp; * implementing it as RAZ means the "debug architecture version" bits<BR>&nbsp;&nbsp;&nbsp;&nbsp; * will read as a reserved value, which should cause Linux to not try<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to use the debug hardware.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "DBGDIDR", .cp = 14, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* MMU TLB control. Note that the wildcarding means we cover not just<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the unified TLB ops but also the dside/iside/inner-shareable variants.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIALL", .cp = 15, .crn = 8, .crm = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = 0, .access = PL1_W, .writefn = tlbiall_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVA", .cp = 15, .crn = 8, .crm = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = 1, .access = PL1_W, .writefn = tlbimva_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIASID", .cp = 15, .crn = 8, .crm = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = 2, .access = PL1_W, .writefn = tlbiasid_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVAA", .cp = 15, .crn = 8, .crm = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = 3, .access = PL1_W, .writefn = tlbimvaa_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; { .name = "PRRR", .cp = 15, .crn = 10, .crm = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = 0, .opc2 = 0, .access = PL1_RW, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "NMRR", .cp = 15, .crn = 10, .crm = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = 0, .opc2 = 1, .access = PL1_RW, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static void cpacr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t mask = 0;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* In ARMv8 most bits of CPACR_EL1 are RES0. */<BR>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ARMv7 defines bits for unimplemented coprocessors as RAZ/WI.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * ASEDIS [31] and D32DIS [30] are both UNK/SBZP without VFP.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * TRCDIS [28] is RAZ/WI since we do not implement a trace macrocell.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_VFP)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* VFP coprocessor: cp10 &amp; cp11 [23:20] */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= (1 &lt;&lt; 31) | (1 &lt;&lt; 30) | (0xf &lt;&lt; 20);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_NEON)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ASEDIS [31] bit is RAO/WI */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value |= (1 &lt;&lt; 31);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* VFPv3 and upwards with NEON implement 32 double precision<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * registers (D0-D31).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_NEON) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_feature(env, ARM_FEATURE_VFP3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* D32DIS [30] is RAO/WI if D16-31 are not implemented. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value |= (1 &lt;&lt; 30);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value &amp;= mask;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.cpacr_el1 = value;<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult cpacr_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Check if CPACR accesses are to be trapped to EL2 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == 1 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (env-&gt;cp15.cptr_el[2] &amp; CPTR_TCPAC) &amp;&amp; !arm_is_secure(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Check if CPACR accesses are to be trapped to EL3 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (arm_current_el(env) &lt; 3 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (env-&gt;cp15.cptr_el[3] &amp; CPTR_TCPAC)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult cptr_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Check if CPTR accesses are set to trap to EL3 */<BR>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == 2 &amp;&amp; (env-&gt;cp15.cptr_el[3] &amp; CPTR_TCPAC)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL3;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo v6_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* prefetch by MVA in v6, NOP in v7 */<BR>&nbsp;&nbsp;&nbsp; { .name = "MVA_prefetch",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 7, .crm = 13, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; /* We need to break the TB after ISB to execute self-modifying code<BR>&nbsp;&nbsp;&nbsp;&nbsp; * correctly and also to take any pending interrupts immediately.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * So use arm_cp_write_ignore() function instead of ARM_CP_NOP flag.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "ISB", .cp = 15, .crn = 7, .crm = 5, .opc1 = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_W, .type = ARM_CP_NO_RAW, .writefn = arm_cp_write_ignore },<BR>&nbsp;&nbsp;&nbsp; { .name = "DSB", .cp = 15, .crn = 7, .crm = 10, .opc1 = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "DMB", .cp = 15, .crn = 7, .crm = 10, .opc1 = 0, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "IFAR", .cp = 15, .crn = 6, .crm = 0, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.ifar_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.ifar_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, },<BR>&nbsp;&nbsp;&nbsp; /* Watchpoint Fault Address Register : should actually only be present<BR>&nbsp;&nbsp;&nbsp;&nbsp; * for 1136, 1176, 11MPCore.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "WFAR", .cp = 15, .crn = 6, .crm = 0, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_CONST, .resetvalue = 0, },<BR>&nbsp;&nbsp;&nbsp; { .name = "CPACR", .state = ARM_CP_STATE_BOTH, .opc0 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .crn = 1, .crm = 0, .opc1 = 0, .opc2 = 2, .accessfn = cpacr_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.cpacr_el1),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, .writefn = cpacr_write },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static CPAccessResult pmreg_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Performance monitor registers user accessibility is controlled<BR>&nbsp;&nbsp;&nbsp;&nbsp; * by PMUSERENR. MDCR_EL2.TPM and MDCR_EL3.TPM allow configurable<BR>&nbsp;&nbsp;&nbsp;&nbsp; * trapping to EL2 or EL3 for other accesses.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int el = arm_current_el(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (el == 0 &amp;&amp; !env-&gt;cp15.c9_pmuserenr) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (el &lt; 2 &amp;&amp; (env-&gt;cp15.mdcr_el2 &amp; MDCR_TPM)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (el &lt; 3 &amp;&amp; (env-&gt;cp15.mdcr_el3 &amp; MDCR_TPM)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL3;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>#ifndef CONFIG_USER_ONLY</FONT></P>
<P><FONT class=extract>static inline bool arm_ccnt_enabled(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* This does not support checking PMCCFILTR_EL0 register */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!(env-&gt;cp15.c9_pmcr &amp; PMCRE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return true;<BR>}</FONT></P>
<P><FONT class=extract>void pmccntr_sync(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t temp_ticks;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; temp_ticks = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARM_CPU_FREQ, NANOSECONDS_PER_SECOND);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (env-&gt;cp15.c9_pmcr &amp; PMCRD) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Increment once every 64 processor clock cycles */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp_ticks /= 64;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_ccnt_enabled(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.c15_ccnt = temp_ticks - env-&gt;cp15.c15_ccnt;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void pmcr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; pmccntr_sync(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (value &amp; PMCRC) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The counter has been reset */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.c15_ccnt = 0;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* only the DP, X, D and E bits are writable */<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pmcr &amp;= ~0x39;<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pmcr |= (value &amp; 0x39);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; pmccntr_sync(env);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t pmccntr_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t total_ticks;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!arm_ccnt_enabled(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Counter is disabled, do not change value */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;cp15.c15_ccnt;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; total_ticks = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARM_CPU_FREQ, NANOSECONDS_PER_SECOND);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (env-&gt;cp15.c9_pmcr &amp; PMCRD) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Increment once every 64 processor clock cycles */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total_ticks /= 64;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return total_ticks - env-&gt;cp15.c15_ccnt;<BR>}</FONT></P>
<P><FONT class=extract>static void pmccntr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t total_ticks;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!arm_ccnt_enabled(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Counter is disabled, set the absolute value */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.c15_ccnt = value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; total_ticks = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARM_CPU_FREQ, NANOSECONDS_PER_SECOND);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (env-&gt;cp15.c9_pmcr &amp; PMCRD) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Increment once every 64 processor clock cycles */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total_ticks /= 64;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c15_ccnt = total_ticks - value;<BR>}</FONT></P>
<P><FONT class=extract>static void pmccntr_write32(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t cur_val = pmccntr_read(env, NULL);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; pmccntr_write(env, ri, deposit64(cur_val, 0, 32, value));<BR>}</FONT></P>
<P><FONT class=extract>#else /* CONFIG_USER_ONLY */</FONT></P>
<P><FONT class=extract>void pmccntr_sync(CPUARMState *env)<BR>{<BR>}</FONT></P>
<P><FONT class=extract>#endif</FONT></P>
<P><FONT class=extract>static void pmccfiltr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; pmccntr_sync(env);<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.pmccfiltr_el0 = value &amp; 0x7E000000;<BR>&nbsp;&nbsp;&nbsp; pmccntr_sync(env);<BR>}</FONT></P>
<P><FONT class=extract>static void pmcntenset_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; value &amp;= (1 &lt;&lt; 31);<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pmcnten |= value;<BR>}</FONT></P>
<P><FONT class=extract>static void pmcntenclr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; value &amp;= (1 &lt;&lt; 31);<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pmcnten &amp;= ~value;<BR>}</FONT></P>
<P><FONT class=extract>static void pmovsr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pmovsr &amp;= ~value;<BR>}</FONT></P>
<P><FONT class=extract>static void pmxevtyper_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pmxevtyper = value &amp; 0xff;<BR>}</FONT></P>
<P><FONT class=extract>static void pmuserenr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pmuserenr = value &amp; 1;<BR>}</FONT></P>
<P><FONT class=extract>static void pmintenset_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* We have no event counters so only the C bit can be changed */<BR>&nbsp;&nbsp;&nbsp; value &amp;= (1 &lt;&lt; 31);<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pminten |= value;<BR>}</FONT></P>
<P><FONT class=extract>static void pmintenclr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; value &amp;= (1 &lt;&lt; 31);<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c9_pminten &amp;= ~value;<BR>}</FONT></P>
<P><FONT class=extract>static void vbar_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Note that even though the AArch64 view of this register has bits<BR>&nbsp;&nbsp;&nbsp;&nbsp; * [10:0] all RES0 we can only mask the bottom 5, to comply with the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * architectural requirements for bits which are RES0 only in some<BR>&nbsp;&nbsp;&nbsp;&nbsp; * contexts. (ARMv8 would permit us to do no masking at all, but ARMv7<BR>&nbsp;&nbsp;&nbsp;&nbsp; * requires the bottom five bits to be RAZ/WI because they're UNK/SBZP.)<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value &amp; ~0x1FULL);<BR>}</FONT></P>
<P><FONT class=extract>static void scr_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* We only mask off bits that are RES0 both for AArch64 and AArch32.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * For bits that vary between AArch32/64, code needs to check the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * current execution mode before directly using the feature bit.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t valid_mask = SCR_AARCH64_MASK | SCR_AARCH32_MASK;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_EL2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; valid_mask &amp;= ~SCR_HCE;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* On ARMv7, SMD (or SCD as it is called in v7) is only<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * supported if EL2 exists. The bit is UNK/SBZP when<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * EL2 is unavailable. In QEMU ARMv7, we force it to always zero<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * when EL2 is unavailable.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * On ARMv8, this bit is always available.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V7) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; valid_mask &amp;= ~SCR_SMD;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Clear all-context RES0 bits.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; value &amp;= valid_mask;<BR>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t ccsidr_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Acquire the CSSELR index from the bank corresponding to the CCSIDR<BR>&nbsp;&nbsp;&nbsp;&nbsp; * bank<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t index = A32_BANKED_REG_GET(env, csselr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ri-&gt;secure &amp; ARM_CP_SECSTATE_S);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return cpu-&gt;ccsidr[index];<BR>}</FONT></P>
<P><FONT class=extract>static void csselr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value &amp; 0xf);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t isr_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = ENV_GET_CPU(env);<BR>&nbsp;&nbsp;&nbsp; uint64_t ret = 0;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (cs-&gt;interrupt_request &amp; CPU_INTERRUPT_HARD) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret |= CPSR_I;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (cs-&gt;interrupt_request &amp; CPU_INTERRUPT_FIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret |= CPSR_F;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* External aborts are not possible in QEMU so A bit is always clear */<BR>&nbsp;&nbsp;&nbsp; return ret;<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo v7_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* the old v6 WFI, UNPREDICTABLE in v7 but we choose to NOP */<BR>&nbsp;&nbsp;&nbsp; { .name = "NOP", .cp = 15, .crn = 7, .crm = 0, .opc1 = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; /* Performance monitors are implementation defined in v7,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * but with an ARM recommended set of registers, which we<BR>&nbsp;&nbsp;&nbsp;&nbsp; * follow (although we don't actually implement any counters)<BR>&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Performance registers fall into three categories:<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; (a) always UNDEF in PL0, RW in PL1 (PMINTENSET, PMINTENCLR)<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; (b) RO in PL0 (ie UNDEF on write), RW in PL1 (PMUSERENR)<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; (c) UNDEF in PL0 if PMUSERENR.EN==0, otherwise accessible (all others)<BR>&nbsp;&nbsp;&nbsp;&nbsp; * For the cases controlled by PMUSERENR we must set .access to PL0_RW<BR>&nbsp;&nbsp;&nbsp;&nbsp; * or PL0_RO as appropriate and then check PMUSERENR in the helper fn.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCNTENSET", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState, cp15.c9_pmcnten),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmcntenset_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCNTENSET_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 12, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pmcnten), .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmcntenset_write, .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCNTENCLR", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState, cp15.c9_pmcnten),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmcntenclr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCNTENCLR_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 12, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pmcnten),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmcntenclr_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMOVSR", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .fieldoffset = offsetof(CPUARMState, cp15.c9_pmovsr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmovsr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMOVSCLR_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 12, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pmovsr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmovsr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; /* Unimplemented so WI. */<BR>&nbsp;&nbsp;&nbsp; { .name = "PMSWINC", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_W, .accessfn = pmreg_access, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; /* Since we don't implement any events, writing to PMSELR is UNPREDICTABLE.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * We choose to RAZ/WI.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "PMSELR", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .type = ARM_CP_CONST, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access },<BR>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCCNTR", .cp = 15, .crn = 9, .crm = 13, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .resetvalue = 0, .type = ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = pmccntr_read, .writefn = pmccntr_write32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCCNTR_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 13, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = pmccntr_read, .writefn = pmccntr_write, },<BR>#endif<BR>&nbsp;&nbsp;&nbsp; { .name = "PMCCFILTR_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 15, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmccfiltr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.pmccfiltr_el0),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMXEVTYPER", .cp = 15, .crn = 9, .crm = 13, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pmxevtyper),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access, .writefn = pmxevtyper_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; /* Unimplemented, RAZ/WI. */<BR>&nbsp;&nbsp;&nbsp; { .name = "PMXEVCNTR", .cp = 15, .crn = 9, .crm = 13, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .type = ARM_CP_CONST, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMUSERENR", .cp = 15, .crn = 9, .crm = 14, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R | PL1_RW, .accessfn = access_tpm,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pmuserenr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmuserenr_write, .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMUSERENR_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 14, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R | PL1_RW, .accessfn = access_tpm, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pmuserenr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmuserenr_write, .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMINTENSET", .cp = 15, .crn = 9, .crm = 14, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tpm,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pminten),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmintenset_write, .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMINTENCLR", .cp = 15, .crn = 9, .crm = 14, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tpm, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pminten),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmintenclr_write, },<BR>&nbsp;&nbsp;&nbsp; { .name = "PMINTENCLR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 9, .crm = 14, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tpm, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pminten),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmintenclr_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "VBAR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .crn = 12, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .writefn = vbar_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.vbar_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.vbar_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "CCSIDR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .crn = 0, .crm = 0, .opc1 = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .readfn = ccsidr_read, .type = ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; { .name = "CSSELR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .crn = 0, .crm = 0, .opc1 = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .writefn = csselr_write, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.csselr_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.csselr_ns) } },<BR>&nbsp;&nbsp;&nbsp; /* Auxiliary ID register: this actually has an IMPDEF value but for now<BR>&nbsp;&nbsp;&nbsp;&nbsp; * just RAZ for all cores:<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "AIDR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 1, .crn = 0, .crm = 0, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* Auxiliary fault status registers: these also are IMPDEF, and we<BR>&nbsp;&nbsp;&nbsp;&nbsp; * choose to RAZ/WI for all cores.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "AFSR0_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 5, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AFSR1_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 5, .crm = 1, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* MAIR can just read-as-written because we don't implement caches<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and so don't need to care about memory attributes.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "MAIR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 10, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.mair_el[1]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "MAIR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 10, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .fieldoffset = offsetof(CPUARMState, cp15.mair_el[3]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* For non-long-descriptor page tables these are PRRR and NMRR;<BR>&nbsp;&nbsp;&nbsp;&nbsp; * regardless they still act as reads-as-written for QEMU.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp; /* MAIR0/1 are defined separately from their 64-bit counterpart which<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * allows them to assign the correct fieldoffset based on the endianness<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * handled in the field definitions.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "MAIR0", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 10, .crm = 2, .opc2 = 0, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.mair0_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.mair0_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetfn = arm_cp_reset_ignore },<BR>&nbsp;&nbsp;&nbsp; { .name = "MAIR1", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 10, .crm = 2, .opc2 = 1, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.mair1_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.mair1_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetfn = arm_cp_reset_ignore },<BR>&nbsp;&nbsp;&nbsp; { .name = "ISR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 12, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_R, .readfn = isr_read },<BR>&nbsp;&nbsp;&nbsp; /* 32 bit ITLB invalidates */<BR>&nbsp;&nbsp;&nbsp; { .name = "ITLBIALL", .cp = 15, .opc1 = 0, .crn = 8, .crm = 5, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbiall_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "ITLBIMVA", .cp = 15, .opc1 = 0, .crn = 8, .crm = 5, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbimva_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "ITLBIASID", .cp = 15, .opc1 = 0, .crn = 8, .crm = 5, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbiasid_write },<BR>&nbsp;&nbsp;&nbsp; /* 32 bit DTLB invalidates */<BR>&nbsp;&nbsp;&nbsp; { .name = "DTLBIALL", .cp = 15, .opc1 = 0, .crn = 8, .crm = 6, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbiall_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "DTLBIMVA", .cp = 15, .opc1 = 0, .crn = 8, .crm = 6, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbimva_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "DTLBIASID", .cp = 15, .opc1 = 0, .crn = 8, .crm = 6, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbiasid_write },<BR>&nbsp;&nbsp;&nbsp; /* 32 bit TLB invalidates */<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIALL", .cp = 15, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbiall_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVA", .cp = 15, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbimva_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIASID", .cp = 15, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbiasid_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVAA", .cp = 15, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbimvaa_write },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo v7mp_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* 32 bit TLB invalidates, Inner Shareable */<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIALLIS", .cp = 15, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbiall_is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVAIS", .cp = 15, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbimva_is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIASIDIS", .cp = 15, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbiasid_is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVAAIS", .cp = 15, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbimvaa_is_write },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static void teecr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; value &amp;= 1;<BR>&nbsp;&nbsp;&nbsp; env-&gt;teecr = value;<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult teehbr_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == 0 &amp;&amp; (env-&gt;teecr &amp; 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo t2ee_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "TEECR", .cp = 14, .crn = 0, .crm = 0, .opc1 = 6, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, teecr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = teecr_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TEEHBR", .cp = 14, .crn = 1, .crm = 0, .opc1 = 6, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .fieldoffset = offsetof(CPUARMState, teehbr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = teehbr_access, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo v6k_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "TPIDR_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .opc2 = 2, .crn = 13, .crm = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.tpidr_el[0]), .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "TPIDRURW", .cp = 15, .crn = 13, .crm = 0, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetoflow32(CPUARMState, cp15.tpidrurw_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetoflow32(CPUARMState, cp15.tpidrurw_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetfn = arm_cp_reset_ignore },<BR>&nbsp;&nbsp;&nbsp; { .name = "TPIDRRO_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .opc2 = 3, .crn = 13, .crm = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R|PL1_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.tpidrro_el[0]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0},<BR>&nbsp;&nbsp;&nbsp; { .name = "TPIDRURO", .cp = 15, .crn = 13, .crm = 0, .opc1 = 0, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R|PL1_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetoflow32(CPUARMState, cp15.tpidruro_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetoflow32(CPUARMState, cp15.tpidruro_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetfn = arm_cp_reset_ignore },<BR>&nbsp;&nbsp;&nbsp; { .name = "TPIDR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .opc2 = 4, .crn = 13, .crm = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.tpidr_el[1]), .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "TPIDRPRW", .opc1 = 0, .cp = 15, .crn = 13, .crm = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetoflow32(CPUARMState, cp15.tpidrprw_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetoflow32(CPUARMState, cp15.tpidrprw_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>#ifndef CONFIG_USER_ONLY</FONT></P>
<P><FONT class=extract>static CPAccessResult gt_cntfrq_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* CNTFRQ: not visible from PL0 if both PL0PCTEN and PL0VCTEN are zero.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Writable only at the highest implemented exception level.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int el = arm_current_el(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; switch (el) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!extract32(env-&gt;cp15.c14_cntkctl, 0, 2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!isread &amp;&amp; ri-&gt;state == ARM_CP_STATE_AA32 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Accesses from 32-bit Secure EL1 UNDEF (*not* trap to EL3!) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_UNCATEGORIZED;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!isread &amp;&amp; el &lt; arm_highest_el(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_UNCATEGORIZED;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult gt_counter_access(CPUARMState *env, int timeridx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned int cur_el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; bool secure = arm_is_secure(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* CNT[PV]CT: not visible from PL0 if ELO[PV]CTEN is zero */<BR>&nbsp;&nbsp;&nbsp; if (cur_el == 0 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !extract32(env-&gt;cp15.c14_cntkctl, timeridx, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL2) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timeridx == GTIMER_PHYS &amp;&amp; !secure &amp;&amp; cur_el &lt; 2 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !extract32(env-&gt;cp15.cnthctl_el2, 0, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult gt_timer_access(CPUARMState *env, int timeridx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned int cur_el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; bool secure = arm_is_secure(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* CNT[PV]_CVAL, CNT[PV]_CTL, CNT[PV]_TVAL: not visible from PL0 if<BR>&nbsp;&nbsp;&nbsp;&nbsp; * EL0[PV]TEN is zero.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (cur_el == 0 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !extract32(env-&gt;cp15.c14_cntkctl, 9 - timeridx, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL2) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timeridx == GTIMER_PHYS &amp;&amp; !secure &amp;&amp; cur_el &lt; 2 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !extract32(env-&gt;cp15.cnthctl_el2, 1, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult gt_pct_access(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_counter_access(env, GTIMER_PHYS, isread);<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult gt_vct_access(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_counter_access(env, GTIMER_VIRT, isread);<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult gt_ptimer_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_timer_access(env, GTIMER_PHYS, isread);<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult gt_vtimer_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_timer_access(env, GTIMER_VIRT, isread);<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult gt_stimer_access(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* The AArch64 register view of the secure physical timer is<BR>&nbsp;&nbsp;&nbsp;&nbsp; * always accessible from EL3, and configurably accessible from<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Secure EL1.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; switch (arm_current_el(env)) {<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_is_secure(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(env-&gt;cp15.scr_el3 &amp; SCR_ST)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t gt_get_countervalue(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / GTIMER_SCALE;<BR>}</FONT></P>
<P><FONT class=extract>static void gt_recalc_timer(ARMCPU *cpu, int timeridx)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMGenericTimer *gt = &amp;cpu-&gt;env.cp15.c14_timer[timeridx];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (gt-&gt;ctl &amp; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Timer enabled: calculate and set current ISTATUS, irq, and<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * reset timer to when ISTATUS next has to change<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t offset = timeridx == GTIMER_VIRT ?<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;env.cp15.cntvoff_el2 : 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t count = gt_get_countervalue(&amp;cpu-&gt;env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note that this must be unsigned 64 bit arithmetic: */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int istatus = count - offset &gt;= gt-&gt;cval;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t nexttick;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gt-&gt;ctl = deposit32(gt-&gt;ctl, 2, 1, istatus);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_set_irq(cpu-&gt;gt_timer_outputs[timeridx],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (istatus &amp;&amp; !(gt-&gt;ctl &amp; 2)));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (istatus) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Next transition is when count rolls back over to zero */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nexttick = UINT64_MAX;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Next transition is when we hit cval */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nexttick = gt-&gt;cval + offset;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note that the desired next expiry time might be beyond the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * signed-64-bit range of a QEMUTimer -- in this case we just<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * set the timer for as far in the future as possible. When the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * timer expires we will reset the timer for any remaining period.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nexttick &gt; INT64_MAX / GTIMER_SCALE) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nexttick = INT64_MAX / GTIMER_SCALE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timer_mod(cpu-&gt;gt_timer[timeridx], nexttick);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Timer disabled: ISTATUS and timer output always clear */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gt-&gt;ctl &amp;= ~4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_set_irq(cpu-&gt;gt_timer_outputs[timeridx], 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timer_del(cpu-&gt;gt_timer[timeridx]);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void gt_timer_reset(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int timeridx)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; timer_del(cpu-&gt;gt_timer[timeridx]);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t gt_cnt_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_get_countervalue(env);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t gt_virt_cnt_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_get_countervalue(env) - env-&gt;cp15.cntvoff_el2;<BR>}</FONT></P>
<P><FONT class=extract>static void gt_cval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int timeridx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c14_timer[timeridx].cval = value;<BR>&nbsp;&nbsp;&nbsp; gt_recalc_timer(arm_env_get_cpu(env), timeridx);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t gt_tval_read(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int timeridx)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t offset = timeridx == GTIMER_VIRT ? env-&gt;cp15.cntvoff_el2 : 0;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return (uint32_t)(env-&gt;cp15.c14_timer[timeridx].cval -<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gt_get_countervalue(env) - offset));<BR>}</FONT></P>
<P><FONT class=extract>static void gt_tval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int timeridx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t offset = timeridx == GTIMER_VIRT ? env-&gt;cp15.cntvoff_el2 : 0;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c14_timer[timeridx].cval = gt_get_countervalue(env) - offset +<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sextract64(value, 0, 32);<BR>&nbsp;&nbsp;&nbsp; gt_recalc_timer(arm_env_get_cpu(env), timeridx);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_ctl_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int timeridx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; uint32_t oldval = env-&gt;cp15.c14_timer[timeridx].ctl;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c14_timer[timeridx].ctl = deposit64(oldval, 0, 2, value);<BR>&nbsp;&nbsp;&nbsp; if ((oldval ^ value) &amp; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Enable toggled */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gt_recalc_timer(cpu, timeridx);<BR>&nbsp;&nbsp;&nbsp; } else if ((oldval ^ value) &amp; 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* IMASK toggled: don't need to recalculate,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * just set the interrupt line based on ISTATUS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_set_irq(cpu-&gt;gt_timer_outputs[timeridx],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (oldval &amp; 4) &amp;&amp; !(value &amp; 2));<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void gt_phys_timer_reset(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_timer_reset(env, ri, GTIMER_PHYS);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_phys_cval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_cval_write(env, ri, GTIMER_PHYS, value);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t gt_phys_tval_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_tval_read(env, ri, GTIMER_PHYS);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_phys_tval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_tval_write(env, ri, GTIMER_PHYS, value);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_phys_ctl_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_ctl_write(env, ri, GTIMER_PHYS, value);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_virt_timer_reset(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_timer_reset(env, ri, GTIMER_VIRT);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_virt_cval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_cval_write(env, ri, GTIMER_VIRT, value);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t gt_virt_tval_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_tval_read(env, ri, GTIMER_VIRT);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_virt_tval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_tval_write(env, ri, GTIMER_VIRT, value);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_virt_ctl_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_ctl_write(env, ri, GTIMER_VIRT, value);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_cntvoff_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; gt_recalc_timer(cpu, GTIMER_VIRT);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_hyp_timer_reset(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_timer_reset(env, ri, GTIMER_HYP);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_hyp_cval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_cval_write(env, ri, GTIMER_HYP, value);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t gt_hyp_tval_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_tval_read(env, ri, GTIMER_HYP);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_hyp_tval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_tval_write(env, ri, GTIMER_HYP, value);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_hyp_ctl_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_ctl_write(env, ri, GTIMER_HYP, value);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_sec_timer_reset(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_timer_reset(env, ri, GTIMER_SEC);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_sec_cval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_cval_write(env, ri, GTIMER_SEC, value);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t gt_sec_tval_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return gt_tval_read(env, ri, GTIMER_SEC);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_sec_tval_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_tval_write(env, ri, GTIMER_SEC, value);<BR>}</FONT></P>
<P><FONT class=extract>static void gt_sec_ctl_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; gt_ctl_write(env, ri, GTIMER_SEC, value);<BR>}</FONT></P>
<P><FONT class=extract>void arm_gt_ptimer_cb(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; gt_recalc_timer(cpu, GTIMER_PHYS);<BR>}</FONT></P>
<P><FONT class=extract>void arm_gt_vtimer_cb(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; gt_recalc_timer(cpu, GTIMER_VIRT);<BR>}</FONT></P>
<P><FONT class=extract>void arm_gt_htimer_cb(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; gt_recalc_timer(cpu, GTIMER_HYP);<BR>}</FONT></P>
<P><FONT class=extract>void arm_gt_stimer_cb(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; gt_recalc_timer(cpu, GTIMER_SEC);<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo generic_timer_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* Note that CNTFRQ is purely reads-as-written for the benefit<BR>&nbsp;&nbsp;&nbsp;&nbsp; * of software; writing it doesn't actually change the timer frequency.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Our reset value matches the fixed frequency we implement the timer at.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTFRQ", .cp = 15, .crn = 14, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R, .accessfn = gt_cntfrq_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState, cp15.c14_cntfrq),<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTFRQ_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R, .accessfn = gt_cntfrq_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_cntfrq),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = (1000 * 1000 * 1000) / GTIMER_SCALE,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; /* overall control: mostly access permissions */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTKCTL", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 14, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_cntkctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; /* per-timer control */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_CTL", .cp = 15, .crn = 14, .crm = 2, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .secure = ARM_CP_SECSTATE_NS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO | ARM_CP_ALIAS, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cp15.c14_timer[GTIMER_PHYS].ctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_phys_ctl_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_CTL(S)",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 14, .crm = 2, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .secure = ARM_CP_SECSTATE_S,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO | ARM_CP_ALIAS, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cp15.c14_timer[GTIMER_SEC].ctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_sec_ctl_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_CTL_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 2, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_PHYS].ctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_phys_ctl_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTV_CTL", .cp = 15, .crn = 14, .crm = 3, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO | ARM_CP_ALIAS, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vtimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cp15.c14_timer[GTIMER_VIRT].ctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_virt_ctl_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTV_CTL_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 3, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vtimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_VIRT].ctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_virt_ctl_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; /* TimerValue views: a 32 bit downcounting view of the underlying state */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_TVAL", .cp = 15, .crn = 14, .crm = 2, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .secure = ARM_CP_SECSTATE_NS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW | ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_phys_tval_read, .writefn = gt_phys_tval_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_TVAL(S)",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 14, .crm = 2, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .secure = ARM_CP_SECSTATE_S,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW | ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_sec_tval_read, .writefn = gt_sec_tval_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_TVAL_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW | ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access, .resetfn = gt_phys_timer_reset,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_phys_tval_read, .writefn = gt_phys_tval_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTV_TVAL", .cp = 15, .crn = 14, .crm = 3, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW | ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vtimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_virt_tval_read, .writefn = gt_virt_tval_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTV_TVAL_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW | ARM_CP_IO, .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vtimer_access, .resetfn = gt_virt_timer_reset,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_virt_tval_read, .writefn = gt_virt_tval_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; /* The counter itself */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTPCT", .cp = 15, .crm = 14, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_64BIT | ARM_CP_NO_RAW | ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_pct_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_cnt_read, .resetfn = arm_cp_reset_ignore,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTPCT_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_NO_RAW | ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_pct_access, .readfn = gt_cnt_read,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTVCT", .cp = 15, .crm = 14, .opc1 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_64BIT | ARM_CP_NO_RAW | ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vct_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_virt_cnt_read, .resetfn = arm_cp_reset_ignore,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTVCT_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_NO_RAW | ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vct_access, .readfn = gt_virt_cnt_read,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; /* Comparison value, indicating when the timer goes off */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_CVAL", .cp = 15, .crm = 14, .opc1 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .secure = ARM_CP_SECSTATE_NS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_64BIT | ARM_CP_IO | ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_PHYS].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_phys_cval_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_CVAL(S)", .cp = 15, .crm = 14, .opc1 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .secure = ARM_CP_SECSTATE_S,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_64BIT | ARM_CP_IO | ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_SEC].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_sec_cval_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTP_CVAL_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 2, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_PHYS].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, .accessfn = gt_ptimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_phys_cval_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTV_CVAL", .cp = 15, .crm = 14, .opc1 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_64BIT | ARM_CP_IO | ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_VIRT].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_vtimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_virt_cval_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTV_CVAL_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 14, .crm = 3, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW | PL0_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_VIRT].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, .accessfn = gt_vtimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_virt_cval_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; /* Secure timer -- this is actually restricted to only EL3<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and configurably Secure-EL1 via the accessfn.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTPS_TVAL_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 7, .crn = 14, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW | ARM_CP_IO, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_stimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_sec_tval_read,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_sec_tval_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetfn = gt_sec_timer_reset,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTPS_CTL_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 7, .crn = 14, .crm = 2, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_stimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_SEC].ctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_sec_ctl_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTPS_CVAL_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 7, .crn = 14, .crm = 2, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = gt_stimer_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_SEC].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_sec_cval_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>#else<BR>/* In user-mode none of the generic timer registers are accessible,<BR>&nbsp;* and their implementation depends on QEMU_CLOCK_VIRTUAL and qdev gpio outputs,<BR>&nbsp;* so instead just don't register any of them.<BR>&nbsp;*/<BR>static const ARMCPRegInfo generic_timer_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>#endif</FONT></P>
<P><FONT class=extract>static void par_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_LPAE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; } else if (arm_feature(env, ARM_FEATURE_V7)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw_write(env, ri, value &amp; 0xfffff6ff);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw_write(env, ri, value &amp; 0xfffff1ff);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>#ifndef CONFIG_USER_ONLY<BR>/* get_phys_addr() isn't present for user-mode-only targets */</FONT></P>
<P><FONT class=extract>static CPAccessResult ats_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (ri-&gt;opc2 &amp; 4) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The ATS12NSO* operations must trap to EL3 if executed in<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Secure EL1 (which can only happen if EL3 is AArch64).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * They are simply UNDEF if executed from NS EL1.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * They function normally from EL2 or EL3.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_UNCATEGORIZED_EL3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_UNCATEGORIZED;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t do_ats_write(CPUARMState *env, uint64_t value,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access_type, ARMMMUIdx mmu_idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; hwaddr phys_addr;<BR>&nbsp;&nbsp;&nbsp; target_ulong page_size;<BR>&nbsp;&nbsp;&nbsp; int prot;<BR>&nbsp;&nbsp;&nbsp; uint32_t fsr;<BR>&nbsp;&nbsp;&nbsp; bool ret;<BR>&nbsp;&nbsp;&nbsp; uint64_t par64;<BR>&nbsp;&nbsp;&nbsp; MemTxAttrs attrs = {};<BR>&nbsp;&nbsp;&nbsp; ARMMMUFaultInfo fi = {};</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; ret = get_phys_addr(env, value, access_type, mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;phys_addr, &amp;attrs, &amp;prot, &amp;page_size, &amp;fsr, &amp;fi);<BR>&nbsp;&nbsp;&nbsp; if (extended_addresses_enabled(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* fsr is a DFSR/IFSR value for the long descriptor<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * translation table format, but with WnR always clear.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Convert it to a 64-bit PAR.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; par64 = (1 &lt;&lt; 11); /* LPAE bit always set */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!ret) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; par64 |= phys_addr &amp; ~0xfffULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!attrs.secure) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; par64 |= (1 &lt;&lt; 9); /* NS */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We don't set the ATTR or SH fields in the PAR. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; par64 |= 1; /* F */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; par64 |= (fsr &amp; 0x3f) &lt;&lt; 1; /* FS */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note that S2WLK and FSTAGE are always zero, because we don't<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * implement virtualization and therefore there can't be a stage 2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * fault.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* fsr is a DFSR/IFSR value for the short descriptor<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * translation table format (with WnR always clear).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Convert it to a 32-bit PAR.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!ret) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We do not set any attribute bits in the PAR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (page_size == (1 &lt;&lt; 24)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; arm_feature(env, ARM_FEATURE_V7)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; par64 = (phys_addr &amp; 0xff000000) | (1 &lt;&lt; 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; par64 = phys_addr &amp; 0xfffff000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!attrs.secure) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; par64 |= (1 &lt;&lt; 9); /* NS */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; par64 = ((fsr &amp; (1 &lt;&lt; 10)) &gt;&gt; 5) | ((fsr &amp; (1 &lt;&lt; 12)) &gt;&gt; 6) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((fsr &amp; 0xf) &lt;&lt; 1) | 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return par64;<BR>}</FONT></P>
<P><FONT class=extract>static void ats_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; int access_type = ri-&gt;opc2 &amp; 1;<BR>&nbsp;&nbsp;&nbsp; uint64_t par64;<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx mmu_idx;<BR>&nbsp;&nbsp;&nbsp; int el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; bool secure = arm_is_secure_below_el3(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; switch (ri-&gt;opc2 &amp; 6) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* stage 1 current state PL1: ATS1CPR, ATS1CPW */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (el) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = ARMMMUIdx_S1E3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = ARMMMUIdx_S1NSE1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = secure ? ARMMMUIdx_S1SE1 : ARMMMUIdx_S1NSE1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* stage 1 current state PL0: ATS1CUR, ATS1CUW */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (el) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = ARMMMUIdx_S1SE0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = ARMMMUIdx_S1NSE0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = secure ? ARMMMUIdx_S1SE0 : ARMMMUIdx_S1NSE0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 4:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* stage 1+2 NonSecure PL1: ATS12NSOPR, ATS12NSOPW */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = ARMMMUIdx_S12NSE1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 6:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* stage 1+2 NonSecure PL0: ATS12NSOUR, ATS12NSOUW */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = ARMMMUIdx_S12NSE0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; par64 = do_ats_write(env, value, access_type, mmu_idx);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; A32_BANKED_CURRENT_REG_SET(env, par, par64);<BR>}</FONT></P>
<P><FONT class=extract>static void ats1h_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; int access_type = ri-&gt;opc2 &amp; 1;<BR>&nbsp;&nbsp;&nbsp; uint64_t par64;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; par64 = do_ats_write(env, value, access_type, ARMMMUIdx_S2NS);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; A32_BANKED_CURRENT_REG_SET(env, par, par64);<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult at_s1e2_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == 3 &amp;&amp; !(env-&gt;cp15.scr_el3 &amp; SCR_NS)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static void ats_write64(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; int access_type = ri-&gt;opc2 &amp; 1;<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx mmu_idx;<BR>&nbsp;&nbsp;&nbsp; int secure = arm_is_secure_below_el3(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; switch (ri-&gt;opc2 &amp; 6) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (ri-&gt;opc1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0: /* AT S1E1R, AT S1E1W */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = secure ? ARMMMUIdx_S1SE1 : ARMMMUIdx_S1NSE1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4: /* AT S1E2R, AT S1E2W */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = ARMMMUIdx_S1E2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 6: /* AT S1E3R, AT S1E3W */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = ARMMMUIdx_S1E3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2: /* AT S1E0R, AT S1E0W */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = secure ? ARMMMUIdx_S1SE0 : ARMMMUIdx_S1NSE0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 4: /* AT S12E1R, AT S12E1W */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = secure ? ARMMMUIdx_S1SE1 : ARMMMUIdx_S12NSE1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 6: /* AT S12E0R, AT S12E0W */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx = secure ? ARMMMUIdx_S1SE0 : ARMMMUIdx_S12NSE0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; env-&gt;cp15.par_el[1] = do_ats_write(env, value, access_type, mmu_idx);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo vapa_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "PAR", .cp = 15, .crn = 7, .crm = 4, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetoflow32(CPUARMState, cp15.par_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetoflow32(CPUARMState, cp15.par_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = par_write },<BR>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; /* This underdecoding is safe because the reginfo is NO_RAW. */<BR>&nbsp;&nbsp;&nbsp; { .name = "ATS", .cp = 15, .crn = 7, .crm = 8, .opc1 = 0, .opc2 = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .accessfn = ats_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = ats_write, .type = ARM_CP_NO_RAW },<BR>#endif<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>/* Return basic MPU access permission bits.&nbsp; */<BR>static uint32_t simple_mpu_ap_bits(uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t ret;<BR>&nbsp;&nbsp;&nbsp; uint32_t mask;<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; ret = 0;<BR>&nbsp;&nbsp;&nbsp; mask = 3;<BR>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 16; i += 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret |= (val &gt;&gt; i) &amp; mask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask &lt;&lt;= 2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return ret;<BR>}</FONT></P>
<P><FONT class=extract>/* Pad basic MPU access permission bits to extended format.&nbsp; */<BR>static uint32_t extended_mpu_ap_bits(uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t ret;<BR>&nbsp;&nbsp;&nbsp; uint32_t mask;<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; ret = 0;<BR>&nbsp;&nbsp;&nbsp; mask = 3;<BR>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 16; i += 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret |= (val &amp; mask) &lt;&lt; i;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask &lt;&lt;= 2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return ret;<BR>}</FONT></P>
<P><FONT class=extract>static void pmsav5_data_ap_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.pmsav5_data_ap = extended_mpu_ap_bits(value);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t pmsav5_data_ap_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return simple_mpu_ap_bits(env-&gt;cp15.pmsav5_data_ap);<BR>}</FONT></P>
<P><FONT class=extract>static void pmsav5_insn_ap_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.pmsav5_insn_ap = extended_mpu_ap_bits(value);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t pmsav5_insn_ap_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return simple_mpu_ap_bits(env-&gt;cp15.pmsav5_insn_ap);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t pmsav7_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t *u32p = *(uint32_t **)raw_ptr(env, ri);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!u32p) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; u32p += env-&gt;cp15.c6_rgnr;<BR>&nbsp;&nbsp;&nbsp; return *u32p;<BR>}</FONT></P>
<P><FONT class=extract>static void pmsav7_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; uint32_t *u32p = *(uint32_t **)raw_ptr(env, ri);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!u32p) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; u32p += env-&gt;cp15.c6_rgnr;<BR>&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1); /* Mappings may have changed - purge! */<BR>&nbsp;&nbsp;&nbsp; *u32p = value;<BR>}</FONT></P>
<P><FONT class=extract>static void pmsav7_reset(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; uint32_t *u32p = *(uint32_t **)raw_ptr(env, ri);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!u32p) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; memset(u32p, 0, sizeof(*u32p) * cpu-&gt;pmsav7_dregion);<BR>}</FONT></P>
<P><FONT class=extract>static void pmsav7_rgnr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; uint32_t nrgs = cpu-&gt;pmsav7_dregion;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (value &gt;= nrgs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_GUEST_ERROR,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "PMSAv7 RGNR write &gt;= # supported regions, %" PRIu32<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " &gt; %" PRIu32 "\n", (uint32_t)value, nrgs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo pmsav7_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "DRBAR", .cp = 15, .crn = 6, .opc1 = 0, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, pmsav7.drbar),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = pmsav7_read, .writefn = pmsav7_write, .resetfn = pmsav7_reset },<BR>&nbsp;&nbsp;&nbsp; { .name = "DRSR", .cp = 15, .crn = 6, .opc1 = 0, .crm = 1, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, pmsav7.drsr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = pmsav7_read, .writefn = pmsav7_write, .resetfn = pmsav7_reset },<BR>&nbsp;&nbsp;&nbsp; { .name = "DRACR", .cp = 15, .crn = 6, .opc1 = 0, .crm = 1, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, pmsav7.dracr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = pmsav7_read, .writefn = pmsav7_write, .resetfn = pmsav7_reset },<BR>&nbsp;&nbsp;&nbsp; { .name = "RGNR", .cp = 15, .crn = 6, .opc1 = 0, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c6_rgnr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmsav7_rgnr_write },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo pmsav5_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "DATA_AP", .cp = 15, .crn = 5, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.pmsav5_data_ap),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = pmsav5_data_ap_read, .writefn = pmsav5_data_ap_write, },<BR>&nbsp;&nbsp;&nbsp; { .name = "INSN_AP", .cp = 15, .crn = 5, .crm = 0, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.pmsav5_insn_ap),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = pmsav5_insn_ap_read, .writefn = pmsav5_insn_ap_write, },<BR>&nbsp;&nbsp;&nbsp; { .name = "DATA_EXT_AP", .cp = 15, .crn = 5, .crm = 0, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.pmsav5_data_ap),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, },<BR>&nbsp;&nbsp;&nbsp; { .name = "INSN_EXT_AP", .cp = 15, .crn = 5, .crm = 0, .opc1 = 0, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.pmsav5_insn_ap),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, },<BR>&nbsp;&nbsp;&nbsp; { .name = "DCACHE_CFG", .cp = 15, .crn = 2, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c2_data), .resetvalue = 0, },<BR>&nbsp;&nbsp;&nbsp; { .name = "ICACHE_CFG", .cp = 15, .crn = 2, .crm = 0, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c2_insn), .resetvalue = 0, },<BR>&nbsp;&nbsp;&nbsp; /* Protection region base and size registers */<BR>&nbsp;&nbsp;&nbsp; { .name = "946_PRBS0", .cp = 15, .crn = 6, .crm = 0, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc2 = CP_ANY, .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c6_region[0]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "946_PRBS1", .cp = 15, .crn = 6, .crm = 1, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc2 = CP_ANY, .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c6_region[1]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "946_PRBS2", .cp = 15, .crn = 6, .crm = 2, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc2 = CP_ANY, .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c6_region[2]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "946_PRBS3", .cp = 15, .crn = 6, .crm = 3, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc2 = CP_ANY, .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c6_region[3]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "946_PRBS4", .cp = 15, .crn = 6, .crm = 4, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc2 = CP_ANY, .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c6_region[4]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "946_PRBS5", .cp = 15, .crn = 6, .crm = 5, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc2 = CP_ANY, .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c6_region[5]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "946_PRBS6", .cp = 15, .crn = 6, .crm = 6, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc2 = CP_ANY, .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c6_region[6]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "946_PRBS7", .cp = 15, .crn = 6, .crm = 7, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc2 = CP_ANY, .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c6_region[7]) },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static void vmsa_ttbcr_raw_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCR *tcr = raw_ptr(env, ri);<BR>&nbsp;&nbsp;&nbsp; int maskshift = extract32(value, 0, 3);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_LPAE) &amp;&amp; (value &amp; TTBCR_EAE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Pre ARMv8 bits [21:19], [15:14] and [6:3] are UNK/SBZP when<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * using Long-desciptor translation table format */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value &amp;= ~((7 &lt;&lt; 19) | (3 &lt;&lt; 14) | (0xf &lt;&lt; 3));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* In an implementation that includes the Security Extensions<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * TTBCR has additional fields PD0 [4] and PD1 [5] for<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Short-descriptor translation table format.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value &amp;= TTBCR_PD1 | TTBCR_PD0 | TTBCR_N;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value &amp;= TTBCR_N;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Update the masks corresponding to the TCR bank being written<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Note that we always calculate mask and base_mask, but<BR>&nbsp;&nbsp;&nbsp;&nbsp; * they are only used for short-descriptor tables (ie if EAE is 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp; * for long-descriptor tables the TCR fields are used differently<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and the mask and base_mask values are meaningless.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;raw_tcr = value;<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;mask = ~(((uint32_t)0xffffffffu) &gt;&gt; maskshift);<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;base_mask = ~((uint32_t)0x3fffu &gt;&gt; maskshift);<BR>}</FONT></P>
<P><FONT class=extract>static void vmsa_ttbcr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_LPAE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* With LPAE the TTBCR could result in a change of ASID<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * via the TTBCR.A1 bit, so do a TLB flush.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; vmsa_ttbcr_raw_write(env, ri, value);<BR>}</FONT></P>
<P><FONT class=extract>static void vmsa_ttbcr_reset(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCR *tcr = raw_ptr(env, ri);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Reset both the TCR as well as the masks corresponding to the bank of<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the TCR being reset.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;raw_tcr = 0;<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;mask = 0;<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;base_mask = 0xffffc000u;<BR>}</FONT></P>
<P><FONT class=extract>static void vmsa_tcr_el1_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; TCR *tcr = raw_ptr(env, ri);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* For AArch64 the A1 bit could result in a change of ASID, so TLB flush. */<BR>&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>&nbsp;&nbsp;&nbsp; tcr-&gt;raw_tcr = value;<BR>}</FONT></P>
<P><FONT class=extract>static void vmsa_ttbr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* 64 bit accesses to the TTBRs can change the ASID and so we<BR>&nbsp;&nbsp;&nbsp;&nbsp; * must flush the TLB.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (cpreg_field_is_64bit(ri)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>}</FONT></P>
<P><FONT class=extract>static void vttbr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Accesses to VTTBR may change the VMID so we must flush the TLB.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (raw_read(env, ri) != value) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(cs, ARMMMUIdx_S12NSE1, ARMMMUIdx_S12NSE0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S2NS, -1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo vmsa_pmsa_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "DFSR", .cp = 15, .crn = 5, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetoflow32(CPUARMState, cp15.dfsr_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetoflow32(CPUARMState, cp15.dfsr_ns) }, },<BR>&nbsp;&nbsp;&nbsp; { .name = "IFSR", .cp = 15, .crn = 5, .crm = 0, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetoflow32(CPUARMState, cp15.ifsr_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetoflow32(CPUARMState, cp15.ifsr_ns) } },<BR>&nbsp;&nbsp;&nbsp; { .name = "DFAR", .cp = 15, .opc1 = 0, .crn = 6, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.dfar_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.dfar_ns) } },<BR>&nbsp;&nbsp;&nbsp; { .name = "FAR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .crn = 6, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.far_el[1]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo vmsa_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "ESR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .crn = 5, .crm = 2, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.esr_el[1]), .resetvalue = 0, },<BR>&nbsp;&nbsp;&nbsp; { .name = "TTBR0_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 2, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .writefn = vmsa_ttbr_write, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.ttbr0_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.ttbr0_ns) } },<BR>&nbsp;&nbsp;&nbsp; { .name = "TTBR1_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 2, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .writefn = vmsa_ttbr_write, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.ttbr1_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.ttbr1_ns) } },<BR>&nbsp;&nbsp;&nbsp; { .name = "TCR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .crn = 2, .crm = 0, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .writefn = vmsa_tcr_el1_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetfn = vmsa_ttbcr_reset, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.tcr_el[1]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "TTBCR", .cp = 15, .crn = 2, .crm = 0, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_ALIAS, .writefn = vmsa_ttbcr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .raw_writefn = vmsa_ttbcr_raw_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetoflow32(CPUARMState, cp15.tcr_el[3]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetoflow32(CPUARMState, cp15.tcr_el[1])} },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static void omap_ticonfig_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c15_ticonfig = value &amp; 0xe7;<BR>&nbsp;&nbsp;&nbsp; /* The OS_TYPE bit in this register changes the reported CPUID! */<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c0_cpuid = (value &amp; (1 &lt;&lt; 5)) ?<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARM_CPUID_TI915T : ARM_CPUID_TI925T;<BR>}</FONT></P>
<P><FONT class=extract>static void omap_threadid_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c15_threadid = value &amp; 0xffff;<BR>}</FONT></P>
<P><FONT class=extract>static void omap_wfi_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Wait-for-interrupt (deprecated) */<BR>&nbsp;&nbsp;&nbsp; cpu_interrupt(CPU(arm_env_get_cpu(env)), CPU_INTERRUPT_HALT);<BR>}</FONT></P>
<P><FONT class=extract>static void omap_cachemaint_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* On OMAP there are registers indicating the max/min index of dcache lines<BR>&nbsp;&nbsp;&nbsp;&nbsp; * containing a dirty line; cache flush operations have to reset these.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c15_i_max = 0x000;<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c15_i_min = 0xff0;<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo omap_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "DFSR", .cp = 15, .crn = 5, .crm = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = CP_ANY, .access = PL1_RW, .type = ARM_CP_OVERRIDE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState, cp15.esr_el[1]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, },<BR>&nbsp;&nbsp;&nbsp; { .name = "", .cp = 15, .crn = 15, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "TICONFIG", .cp = 15, .crn = 15, .crm = 1, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c15_ticonfig), .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = omap_ticonfig_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "IMAX", .cp = 15, .crn = 15, .crm = 2, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c15_i_max), .resetvalue = 0, },<BR>&nbsp;&nbsp;&nbsp; { .name = "IMIN", .cp = 15, .crn = 15, .crm = 3, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0xff0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c15_i_min) },<BR>&nbsp;&nbsp;&nbsp; { .name = "THREADID", .cp = 15, .crn = 15, .crm = 4, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c15_threadid), .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = omap_threadid_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TI925T_STATUS", .cp = 15, .crn = 15,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .crm = 8, .opc1 = 0, .opc2 = 0, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = arm_cp_read_zero, .writefn = omap_wfi_write, },<BR>&nbsp;&nbsp;&nbsp; /* TODO: Peripheral port remap register:<BR>&nbsp;&nbsp;&nbsp;&nbsp; * On OMAP2 mcr p15, 0, rn, c15, c2, 4 sets up the interrupt controller<BR>&nbsp;&nbsp;&nbsp;&nbsp; * base address at $rn &amp; ~0xfff and map size of 0x200 &lt;&lt; ($rn &amp; 0xfff),<BR>&nbsp;&nbsp;&nbsp;&nbsp; * when MMU is off.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "OMAP_CACHEMAINT", .cp = 15, .crn = 7, .crm = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = 0, .opc2 = CP_ANY, .access = PL1_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_OVERRIDE | ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = omap_cachemaint_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "C9", .cp = 15, .crn = 9,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .crm = CP_ANY, .opc1 = CP_ANY, .opc2 = CP_ANY, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST | ARM_CP_OVERRIDE, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static void xscale_cpar_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.c15_cpar = value &amp; 0x3fff;<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo xscale_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "XSCALE_CPAR",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 15, .crm = 1, .opc1 = 0, .opc2 = 0, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c15_cpar), .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = xscale_cpar_write, },<BR>&nbsp;&nbsp;&nbsp; { .name = "XSCALE_AUXCR",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 1, .crm = 0, .opc1 = 0, .opc2 = 1, .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c1_xscaleauxcr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, },<BR>&nbsp;&nbsp;&nbsp; /* XScale specific cache-lockdown: since we have no cache we NOP these<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and hope the guest does not really rely on cache behaviour.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "XSCALE_LOCK_ICACHE_LINE",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 9, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "XSCALE_UNLOCK_ICACHE",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 9, .crm = 1, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "XSCALE_DCACHE_LOCK",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 9, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "XSCALE_UNLOCK_DCACHE",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 9, .crm = 2, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo dummy_c15_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* RAZ/WI the whole crn=15 space, when we don't have a more specific<BR>&nbsp;&nbsp;&nbsp;&nbsp; * implementation of this implementation-defined space.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Ideally this should eventually disappear in favour of actually<BR>&nbsp;&nbsp;&nbsp;&nbsp; * implementing the correct behaviour for all cores.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "C15_IMPDEF", .cp = 15, .crn = 15,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .crm = CP_ANY, .opc1 = CP_ANY, .opc2 = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST | ARM_CP_NO_RAW | ARM_CP_OVERRIDE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo cache_dirty_status_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* Cache status: RAZ because we have no cache so it's always clean */<BR>&nbsp;&nbsp;&nbsp; { .name = "CDSR", .cp = 15, .crn = 7, .crm = 10, .opc1 = 0, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST | ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo cache_block_ops_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* We never have a a block transfer operation in progress */<BR>&nbsp;&nbsp;&nbsp; { .name = "BXSR", .cp = 15, .crn = 7, .crm = 12, .opc1 = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_CONST | ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* The cache ops themselves: these all NOP for QEMU */<BR>&nbsp;&nbsp;&nbsp; { .name = "IICR", .cp = 15, .crm = 5, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP|ARM_CP_64BIT },<BR>&nbsp;&nbsp;&nbsp; { .name = "IDCR", .cp = 15, .crm = 6, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP|ARM_CP_64BIT },<BR>&nbsp;&nbsp;&nbsp; { .name = "CDCR", .cp = 15, .crm = 12, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_W, .type = ARM_CP_NOP|ARM_CP_64BIT },<BR>&nbsp;&nbsp;&nbsp; { .name = "PIR", .cp = 15, .crm = 12, .opc1 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_W, .type = ARM_CP_NOP|ARM_CP_64BIT },<BR>&nbsp;&nbsp;&nbsp; { .name = "PDR", .cp = 15, .crm = 12, .opc1 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_W, .type = ARM_CP_NOP|ARM_CP_64BIT },<BR>&nbsp;&nbsp;&nbsp; { .name = "CIDCR", .cp = 15, .crm = 14, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP|ARM_CP_64BIT },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo cache_test_clean_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* The cache test-and-clean instructions always return (1 &lt;&lt; 30)<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to indicate that there are no dirty cache lines.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "TC_DCACHE", .cp = 15, .crn = 7, .crm = 10, .opc1 = 0, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_CONST | ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = (1 &lt;&lt; 30) },<BR>&nbsp;&nbsp;&nbsp; { .name = "TCI_DCACHE", .cp = 15, .crn = 7, .crm = 14, .opc1 = 0, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_CONST | ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = (1 &lt;&lt; 30) },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo strongarm_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* Ignore ReadBuffer accesses */<BR>&nbsp;&nbsp;&nbsp; { .name = "C9_READBUFFER", .cp = 15, .crn = 9,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .crm = CP_ANY, .opc1 = CP_ANY, .opc2 = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST | ARM_CP_OVERRIDE | ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static uint64_t midr_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; unsigned int cur_el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; bool secure = arm_is_secure(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_feature(&amp;cpu-&gt;env, ARM_FEATURE_EL2) &amp;&amp; !secure &amp;&amp; cur_el == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;cp15.vpidr_el2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return raw_read(env, ri);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t mpidr_read_val(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(arm_env_get_cpu(env));<BR>&nbsp;&nbsp;&nbsp; uint64_t mpidr = cpu-&gt;mp_affinity;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V7MP)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mpidr |= (1U &lt;&lt; 31);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Cores which are uniprocessor (non-coherent)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * but still implement the MP extensions set<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * bit 30. (For instance, Cortex-R5).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cpu-&gt;mp_is_up) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mpidr |= (1u &lt;&lt; 30);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return mpidr;<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t mpidr_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; unsigned int cur_el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; bool secure = arm_is_secure(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL2) &amp;&amp; !secure &amp;&amp; cur_el == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;cp15.vmpidr_el2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return mpidr_read_val(env);<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo mpidr_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "MPIDR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .readfn = mpidr_read, .type = ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo lpae_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* NOP AMAIR0/1 */<BR>&nbsp;&nbsp;&nbsp; { .name = "AMAIR0", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .crn = 10, .crm = 3, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* AMAIR1 is mapped to AMAIR_EL1[63:32] */<BR>&nbsp;&nbsp;&nbsp; { .name = "AMAIR1", .cp = 15, .crn = 10, .crm = 3, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "PAR", .cp = 15, .crm = 7, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_64BIT, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.par_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.par_ns)} },<BR>&nbsp;&nbsp;&nbsp; { .name = "TTBR0", .cp = 15, .crm = 2, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_64BIT | ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.ttbr0_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.ttbr0_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = vmsa_ttbr_write, },<BR>&nbsp;&nbsp;&nbsp; { .name = "TTBR1", .cp = 15, .crm = 2, .opc1 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_64BIT | ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.ttbr1_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.ttbr1_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = vmsa_ttbr_write, },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static uint64_t aa64_fpcr_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return vfp_get_fpcr(env);<BR>}</FONT></P>
<P><FONT class=extract>static void aa64_fpcr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; vfp_set_fpcr(env, value);<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t aa64_fpsr_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return vfp_get_fpsr(env);<BR>}</FONT></P>
<P><FONT class=extract>static void aa64_fpsr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; vfp_set_fpsr(env, value);<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult aa64_daif_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == 0 &amp;&amp; !(env-&gt;cp15.sctlr_el[1] &amp; SCTLR_UMA)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static void aa64_daif_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;daif = value &amp; PSTATE_DAIF;<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult aa64_cacheop_access(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Cache invalidate/clean: NOP, but EL0 must UNDEF unless<BR>&nbsp;&nbsp;&nbsp;&nbsp; * SCTLR_EL1.UCI is set.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == 0 &amp;&amp; !(env-&gt;cp15.sctlr_el[1] &amp; SCTLR_UCI)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>/* See: D4.7.2 TLB maintenance requirements and the TLB maintenance instructions<BR>&nbsp;* Page D4-1736 (DDI0487A.b)<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_vmalle1_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(cs, ARMMMUIdx_S1SE1, ARMMMUIdx_S1SE0, -1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(cs, ARMMMUIdx_S12NSE1, ARMMMUIdx_S12NSE0, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_vmalle1is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; bool sec = arm_is_secure_below_el3(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sec) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(other_cs, ARMMMUIdx_S1SE1, ARMMMUIdx_S1SE0, -1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(other_cs, ARMMMUIdx_S12NSE1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S12NSE0, -1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_alle1_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Note that the 'ALL' scope must invalidate both stage 1 and<BR>&nbsp;&nbsp;&nbsp;&nbsp; * stage 2 translations, whereas most other scopes only invalidate<BR>&nbsp;&nbsp;&nbsp;&nbsp; * stage 1 translations.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(cs, ARMMMUIdx_S1SE1, ARMMMUIdx_S1SE0, -1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(cs, ARMMMUIdx_S12NSE1, ARMMMUIdx_S12NSE0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S2NS, -1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(cs, ARMMMUIdx_S12NSE1, ARMMMUIdx_S12NSE0, -1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_alle2_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(cs, ARMMMUIdx_S1E2, -1);<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_alle3_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(cs, ARMMMUIdx_S1E3, -1);<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_alle1is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Note that the 'ALL' scope must invalidate both stage 1 and<BR>&nbsp;&nbsp;&nbsp;&nbsp; * stage 2 translations, whereas most other scopes only invalidate<BR>&nbsp;&nbsp;&nbsp;&nbsp; * stage 1 translations.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; bool sec = arm_is_secure_below_el3(env);<BR>&nbsp;&nbsp;&nbsp; bool has_el2 = arm_feature(env, ARM_FEATURE_EL2);<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sec) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(other_cs, ARMMMUIdx_S1SE1, ARMMMUIdx_S1SE0, -1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (has_el2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(other_cs, ARMMMUIdx_S12NSE1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S12NSE0, ARMMMUIdx_S2NS, -1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(other_cs, ARMMMUIdx_S12NSE1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S12NSE0, -1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_alle2is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(other_cs, ARMMMUIdx_S1E2, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_alle3is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_by_mmuidx(other_cs, ARMMMUIdx_S1E3, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_vae1_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate by VA, EL1&amp;0 (AArch64 version).<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Currently handles all of VAE1, VAAE1, VAALE1 and VALE1,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * since we don't support flush-for-specific-ASID-only or<BR>&nbsp;&nbsp;&nbsp;&nbsp; * flush-last-level-only.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr = sextract64(value &lt;&lt; 12, 0, 56);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(cs, pageaddr, ARMMMUIdx_S1SE1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1SE0, -1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(cs, pageaddr, ARMMMUIdx_S12NSE1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S12NSE0, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_vae2_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate by VA, EL2<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Currently handles both VAE2 and VALE2, since we don't support<BR>&nbsp;&nbsp;&nbsp;&nbsp; * flush-last-level-only.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr = sextract64(value &lt;&lt; 12, 0, 56);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(cs, pageaddr, ARMMMUIdx_S1E2, -1);<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_vae3_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate by VA, EL3<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Currently handles both VAE3 and VALE3, since we don't support<BR>&nbsp;&nbsp;&nbsp;&nbsp; * flush-last-level-only.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr = sextract64(value &lt;&lt; 12, 0, 56);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(cs, pageaddr, ARMMMUIdx_S1E3, -1);<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_vae1is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; bool sec = arm_is_secure_below_el3(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr = sextract64(value &lt;&lt; 12, 0, 56);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sec) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(other_cs, pageaddr, ARMMMUIdx_S1SE1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1SE0, -1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(other_cs, pageaddr, ARMMMUIdx_S12NSE1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx_S12NSE0, -1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_vae2is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr = sextract64(value &lt;&lt; 12, 0, 56);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(other_cs, pageaddr, ARMMMUIdx_S1E2, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_vae3is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr = sextract64(value &lt;&lt; 12, 0, 56);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(other_cs, pageaddr, ARMMMUIdx_S1E3, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_ipas2e1_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Invalidate by IPA. This has to invalidate any structures that<BR>&nbsp;&nbsp;&nbsp;&nbsp; * contain only stage 2 translation information, but does not need<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to apply to structures that contain combined stage 1 and stage 2<BR>&nbsp;&nbsp;&nbsp;&nbsp; * translation information.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This must NOP if EL2 isn't implemented or SCR_EL3.NS is zero.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_EL2) || !(env-&gt;cp15.scr_el3 &amp; SCR_NS)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; pageaddr = sextract64(value &lt;&lt; 12, 0, 48);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(cs, pageaddr, ARMMMUIdx_S2NS, -1);<BR>}</FONT></P>
<P><FONT class=extract>static void tlbi_aa64_ipas2e1is_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *other_cs;<BR>&nbsp;&nbsp;&nbsp; uint64_t pageaddr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_EL2) || !(env-&gt;cp15.scr_el3 &amp; SCR_NS)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; pageaddr = sextract64(value &lt;&lt; 12, 0, 48);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_FOREACH(other_cs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush_page_by_mmuidx(other_cs, pageaddr, ARMMMUIdx_S2NS, -1);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult aa64_zva_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* We don't implement EL2, so the only control on DC ZVA is the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * bit in the SCTLR which can prohibit access for EL0.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == 0 &amp;&amp; !(env-&gt;cp15.sctlr_el[1] &amp; SCTLR_DZE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t aa64_dczid_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; int dzp_bit = 1 &lt;&lt; 4;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* DZP indicates whether DC ZVA access is allowed */<BR>&nbsp;&nbsp;&nbsp; if (aa64_zva_access(env, NULL, false) == CP_ACCESS_OK) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dzp_bit = 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return cpu-&gt;dcz_blocksize | dzp_bit;<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult sp_el0_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (!(env-&gt;pstate &amp; PSTATE_SP)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Access to SP_EL0 is undefined if it's being used as<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the stack pointer.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_UNCATEGORIZED;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static uint64_t spsel_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return env-&gt;pstate &amp; PSTATE_SP;<BR>}</FONT></P>
<P><FONT class=extract>static void spsel_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; update_spsel(env, val);<BR>}</FONT></P>
<P><FONT class=extract>static void sctlr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (raw_read(env, ri) == value) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Skip the TLB flush if nothing actually changed; Linux likes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * to do a lot of pointless SCTLR writes.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; /* ??? Lots of these bits are not implemented.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; /* This may enable/disable the MMU, so do a TLB flush.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>}</FONT></P>
<P><FONT class=extract>static CPAccessResult fpexc32_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; if ((env-&gt;cp15.cptr_el[2] &amp; CPTR_TFP) &amp;&amp; arm_current_el(env) == 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_FP_EL2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (env-&gt;cp15.cptr_el[3] &amp; CPTR_TFP) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_FP_EL3;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static void sdcr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;cp15.mdcr_el3 = value &amp; SDCR_VALID_MASK;<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo v8_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* Minimal set of EL0-visible registers. This will need to be expanded<BR>&nbsp;&nbsp;&nbsp;&nbsp; * significantly for system emulation of AArch64 CPUs.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "NZCV", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .opc2 = 0, .crn = 4, .crm = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .type = ARM_CP_NZCV },<BR>&nbsp;&nbsp;&nbsp; { .name = "DAIF", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .opc2 = 1, .crn = 4, .crm = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .accessfn = aa64_daif_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, daif),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = aa64_daif_write, .resetfn = arm_cp_reset_ignore },<BR>&nbsp;&nbsp;&nbsp; { .name = "FPCR", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .opc2 = 0, .crn = 4, .crm = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .readfn = aa64_fpcr_read, .writefn = aa64_fpcr_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "FPSR", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .opc2 = 1, .crn = 4, .crm = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .readfn = aa64_fpsr_read, .writefn = aa64_fpsr_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "DCZID_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .opc2 = 7, .crn = 0, .crm = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = aa64_dczid_read },<BR>&nbsp;&nbsp;&nbsp; { .name = "DC_ZVA", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 3, .crn = 7, .crm = 4, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_W, .type = ARM_CP_DC_ZVA,<BR>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Avoid overhead of an access check that always passes in user-mode */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = aa64_zva_access,<BR>#endif<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; { .name = "CURRENTEL", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .opc2 = 2, .crn = 4, .crm = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CURRENTEL },<BR>&nbsp;&nbsp;&nbsp; /* Cache ops: all NOPs since we don't emulate caches */<BR>&nbsp;&nbsp;&nbsp; { .name = "IC_IALLUIS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 7, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "IC_IALLU", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 7, .crm = 5, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "IC_IVAU", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 3, .crn = 7, .crm = 5, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_W, .type = ARM_CP_NOP,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = aa64_cacheop_access },<BR>&nbsp;&nbsp;&nbsp; { .name = "DC_IVAC", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 7, .crm = 6, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "DC_ISW", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 7, .crm = 6, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "DC_CVAC", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 3, .crn = 7, .crm = 10, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_W, .type = ARM_CP_NOP,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = aa64_cacheop_access },<BR>&nbsp;&nbsp;&nbsp; { .name = "DC_CSW", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 7, .crm = 10, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "DC_CVAU", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 3, .crn = 7, .crm = 11, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_W, .type = ARM_CP_NOP,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = aa64_cacheop_access },<BR>&nbsp;&nbsp;&nbsp; { .name = "DC_CIVAC", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 3, .crn = 7, .crm = 14, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_W, .type = ARM_CP_NOP,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = aa64_cacheop_access },<BR>&nbsp;&nbsp;&nbsp; { .name = "DC_CISW", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 7, .crm = 14, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; /* TLBI operations */<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VMALLE1IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vmalle1is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VAE1IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae1is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_ASIDE1IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vmalle1is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VAAE1IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae1is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VALE1IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae1is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VAALE1IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae1is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VMALLE1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vmalle1_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VAE1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae1_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_ASIDE1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vmalle1_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VAAE1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae1_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VALE1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae1_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VAALE1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae1_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_IPAS2E1IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_ipas2e1is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_IPAS2LE1IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 0, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_ipas2e1is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_ALLE1IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 3, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_alle1is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VMALLS12E1IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 3, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_alle1is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_IPAS2E1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 4, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_ipas2e1_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_IPAS2LE1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 4, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_ipas2e1_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_ALLE1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 7, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_alle1_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VMALLS12E1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 7, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_alle1is_write },<BR>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; /* 64 bit address translation operations */<BR>&nbsp;&nbsp;&nbsp; { .name = "AT_S1E1R", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 7, .crm = 8, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW, .writefn = ats_write64 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AT_S1E1W", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 7, .crm = 8, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW, .writefn = ats_write64 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AT_S1E0R", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 7, .crm = 8, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW, .writefn = ats_write64 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AT_S1E0W", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 0, .crn = 7, .crm = 8, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW, .writefn = ats_write64 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AT_S12E1R", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 7, .crm = 8, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW, .writefn = ats_write64 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AT_S12E1W", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 7, .crm = 8, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW, .writefn = ats_write64 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AT_S12E0R", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 7, .crm = 8, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW, .writefn = ats_write64 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AT_S12E0W", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 7, .crm = 8, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW, .writefn = ats_write64 },<BR>&nbsp;&nbsp;&nbsp; /* AT S1E2* are elsewhere as they UNDEF from EL3 if EL2 is not present */<BR>&nbsp;&nbsp;&nbsp; { .name = "AT_S1E3R", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 6, .crn = 7, .crm = 8, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_W, .type = ARM_CP_NO_RAW, .writefn = ats_write64 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AT_S1E3W", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 6, .crn = 7, .crm = 8, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_W, .type = ARM_CP_NO_RAW, .writefn = ats_write64 },<BR>&nbsp;&nbsp;&nbsp; { .name = "PAR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 7, .crm = 4, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.par_el[1]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = par_write },<BR>#endif<BR>&nbsp;&nbsp;&nbsp; /* TLB invalidate last level of translation table walk */<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVALIS", .cp = 15, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbimva_is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVAALIS", .cp = 15, .opc1 = 0, .crn = 8, .crm = 3, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbimvaa_is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVAL", .cp = 15, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbimva_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVAAL", .cp = 15, .opc1 = 0, .crn = 8, .crm = 7, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL1_W, .writefn = tlbimvaa_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVALH", .cp = 15, .opc1 = 4, .crn = 8, .crm = 7, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbimva_hyp_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVALHIS",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 4, .crn = 8, .crm = 3, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbimva_hyp_is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIIPAS2",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 4, .crn = 8, .crm = 4, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbiipas2_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIIPAS2IS",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 4, .crn = 8, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbiipas2_is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIIPAS2L",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 4, .crn = 8, .crm = 4, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbiipas2_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIIPAS2LIS",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 4, .crn = 8, .crm = 0, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbiipas2_is_write },<BR>&nbsp;&nbsp;&nbsp; /* 32 bit cache operations */<BR>&nbsp;&nbsp;&nbsp; { .name = "ICIALLUIS", .cp = 15, .opc1 = 0, .crn = 7, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP, .access = PL1_W },<BR>&nbsp;&nbsp;&nbsp; { .name = "BPIALLUIS", .cp = 15, .opc1 = 0, .crn = 7, .crm = 1, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP, .access = PL1_W },<BR>&nbsp;&nbsp;&nbsp; { .name = "ICIALLU", .cp = 15, .opc1 = 0, .crn = 7, .crm = 5, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP, .access = PL1_W },<BR>&nbsp;&nbsp;&nbsp; { .name = "ICIMVAU", .cp = 15, .opc1 = 0, .crn = 7, .crm = 5, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP, .access = PL1_W },<BR>&nbsp;&nbsp;&nbsp; { .name = "BPIALL", .cp = 15, .opc1 = 0, .crn = 7, .crm = 5, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP, .access = PL1_W },<BR>&nbsp;&nbsp;&nbsp; { .name = "BPIMVA", .cp = 15, .opc1 = 0, .crn = 7, .crm = 5, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP, .access = PL1_W },<BR>&nbsp;&nbsp;&nbsp; { .name = "DCIMVAC", .cp = 15, .opc1 = 0, .crn = 7, .crm = 6, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP, .access = PL1_W },<BR>&nbsp;&nbsp;&nbsp; { .name = "DCISW", .cp = 15, .opc1 = 0, .crn = 7, .crm = 6, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP, .access = PL1_W },<BR>&nbsp;&nbsp;&nbsp; { .name = "DCCMVAC", .cp = 15, .opc1 = 0, .crn = 7, .crm = 10, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP, .access = PL1_W },<BR>&nbsp;&nbsp;&nbsp; { .name = "DCCSW", .cp = 15, .opc1 = 0, .crn = 7, .crm = 10, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP, .access = PL1_W },<BR>&nbsp;&nbsp;&nbsp; { .name = "DCCMVAU", .cp = 15, .opc1 = 0, .crn = 7, .crm = 11, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP, .access = PL1_W },<BR>&nbsp;&nbsp;&nbsp; { .name = "DCCIMVAC", .cp = 15, .opc1 = 0, .crn = 7, .crm = 14, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP, .access = PL1_W },<BR>&nbsp;&nbsp;&nbsp; { .name = "DCCISW", .cp = 15, .opc1 = 0, .crn = 7, .crm = 14, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP, .access = PL1_W },<BR>&nbsp;&nbsp;&nbsp; /* MMU Domain access control / MPU write buffer control */<BR>&nbsp;&nbsp;&nbsp; { .name = "DACR", .cp = 15, .opc1 = 0, .crn = 3, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = dacr_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetoflow32(CPUARMState, cp15.dacr_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetoflow32(CPUARMState, cp15.dacr_ns) } },<BR>&nbsp;&nbsp;&nbsp; { .name = "ELR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 4, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, elr_el[1]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "SPSR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 4, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, banked_spsr[BANK_SVC]) },<BR>&nbsp;&nbsp;&nbsp; /* We rely on the access checks not allowing the guest to write to the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * state field when SPSel indicates that it's being used as the stack<BR>&nbsp;&nbsp;&nbsp;&nbsp; * pointer.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "SP_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 4, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = sp_el0_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, sp_el[0]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "SP_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 4, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, sp_el[1]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "SPSel", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 4, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .readfn = spsel_read, .writefn = spsel_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "FPEXC32_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 5, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, vfp.xregs[ARM_VFP_FPEXC]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .accessfn = fpexc32_access },<BR>&nbsp;&nbsp;&nbsp; { .name = "DACR32_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 3, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = dacr_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.dacr32_el2) },<BR>&nbsp;&nbsp;&nbsp; { .name = "IFSR32_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 5, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.ifsr32_el2) },<BR>&nbsp;&nbsp;&nbsp; { .name = "SPSR_IRQ", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 4, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, banked_spsr[BANK_IRQ]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "SPSR_ABT", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 4, .crm = 3, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, banked_spsr[BANK_ABT]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "SPSR_UND", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 4, .crm = 3, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, banked_spsr[BANK_UND]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "SPSR_FIQ", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 4, .crm = 3, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, banked_spsr[BANK_FIQ]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "MDCR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 1, .crm = 3, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .fieldoffset = offsetof(CPUARMState, cp15.mdcr_el3) },<BR>&nbsp;&nbsp;&nbsp; { .name = "SDCR", .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 1, .crm = 3, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_trap_aa32s_el1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = sdcr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState, cp15.mdcr_el3) },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>/* Used to describe the behaviour of EL2 regs when EL2 does not exist.&nbsp; */<BR>static const ARMCPRegInfo el3_no_el2_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "VBAR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 12, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = arm_cp_read_zero, .writefn = arm_cp_write_ignore },<BR>&nbsp;&nbsp;&nbsp; { .name = "HCR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 1, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = arm_cp_read_zero, .writefn = arm_cp_write_ignore },<BR>&nbsp;&nbsp;&nbsp; { .name = "CPTR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 1, .crm = 1, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "MAIR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 10, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "HMAIR1", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = 4, .crn = 10, .crm = 2, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AMAIR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 10, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "HMAIR1", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = 4, .crn = 10, .crm = 3, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AFSR0_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 5, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AFSR1_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 5, .crm = 1, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "TCR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 2, .crm = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "VTCR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 2, .crm = 1, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .accessfn = access_el3_aa32ns_aa64any,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "VTTBR", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 6, .crm = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .accessfn = access_el3_aa32ns,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST | ARM_CP_64BIT, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "VTTBR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 2, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "SCTLR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 1, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "TPIDR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 13, .crm = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "TTBR0_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 2, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "HTTBR", .cp = 15, .opc1 = 4, .crm = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_64BIT | ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTHCTL_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 14, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTVOFF_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 14, .crm = 0, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTVOFF", .cp = 15, .opc1 = 4, .crm = 14,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_64BIT | ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTHP_CVAL_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 14, .crm = 2, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTHP_CVAL", .cp = 15, .opc1 = 6, .crm = 14,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_64BIT | ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTHP_TVAL_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 14, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTHP_CTL_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 14, .crm = 2, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "MDCR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 1, .crm = 1, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .accessfn = access_tda,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "HPFAR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 6, .crm = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .accessfn = access_el3_aa32ns_aa64any,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "HSTR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 1, .crm = 1, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static void hcr_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; uint64_t valid_mask = HCR_MASK;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; valid_mask &amp;= ~HCR_HCD;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; valid_mask &amp;= ~HCR_TSC;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Clear RES0 bits.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; value &amp;= valid_mask;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* These bits change the MMU setup:<BR>&nbsp;&nbsp;&nbsp;&nbsp; * HCR_VM enables stage 2 translation<BR>&nbsp;&nbsp;&nbsp;&nbsp; * HCR_PTW forbids certain page-table setups<BR>&nbsp;&nbsp;&nbsp;&nbsp; * HCR_DC Disables stage1 and enables stage2 translation<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if ((raw_read(env, ri) ^ value) &amp; (HCR_VM | HCR_PTW | HCR_DC)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_flush(CPU(cpu), 1);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo el2_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "HCR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 1, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .fieldoffset = offsetof(CPUARMState, cp15.hcr_el2),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = hcr_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "ELR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 4, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, elr_el[2]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "ESR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 5, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .fieldoffset = offsetof(CPUARMState, cp15.esr_el[2]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "FAR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 6, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .fieldoffset = offsetof(CPUARMState, cp15.far_el[2]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "SPSR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 4, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, banked_spsr[BANK_HYP]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "VBAR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 12, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .writefn = vbar_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.vbar_el[2]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "SP_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 4, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, sp_el[2]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "CPTR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 1, .crm = 1, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .accessfn = cptr_access, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.cptr_el[2]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "MAIR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 10, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .fieldoffset = offsetof(CPUARMState, cp15.mair_el[2]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "HMAIR1", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = 4, .crn = 10, .crm = 2, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetofhigh32(CPUARMState, cp15.mair_el[2]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "AMAIR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 10, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* HAMAIR1 is mapped to AMAIR_EL2[63:32] */<BR>&nbsp;&nbsp;&nbsp; { .name = "HMAIR1", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = 4, .crn = 10, .crm = 3, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AFSR0_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 5, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AFSR1_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 5, .crm = 1, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "TCR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 2, .crm = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* no .writefn needed as this can't cause an ASID change;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * no .raw_writefn or .resetfn needed as we never use mask/base_mask<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.tcr_el[2]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "VTCR", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 4, .crn = 2, .crm = 1, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .accessfn = access_el3_aa32ns,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.vtcr_el2) },<BR>&nbsp;&nbsp;&nbsp; { .name = "VTCR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 2, .crm = 1, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* no .writefn needed as this can't cause an ASID change;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * no .raw_writefn or .resetfn needed as we never use mask/base_mask<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.vtcr_el2) },<BR>&nbsp;&nbsp;&nbsp; { .name = "VTTBR", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 6, .crm = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_64BIT | ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .accessfn = access_el3_aa32ns,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.vttbr_el2),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = vttbr_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "VTTBR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 2, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .writefn = vttbr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.vttbr_el2) },<BR>&nbsp;&nbsp;&nbsp; { .name = "SCTLR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 1, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .raw_writefn = raw_write, .writefn = sctlr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.sctlr_el[2]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "TPIDR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 13, .crm = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.tpidr_el[2]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "TTBR0_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 2, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.ttbr0_el[2]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "HTTBR", .cp = 15, .opc1 = 4, .crm = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_64BIT | ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.ttbr0_el[2]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIALLNSNH",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 4, .crn = 8, .crm = 7, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbiall_nsnh_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIALLNSNHIS",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 4, .crn = 8, .crm = 3, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbiall_nsnh_is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIALLH", .cp = 15, .opc1 = 4, .crn = 8, .crm = 7, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbiall_hyp_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIALLHIS", .cp = 15, .opc1 = 4, .crn = 8, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbiall_hyp_is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVAH", .cp = 15, .opc1 = 4, .crn = 8, .crm = 7, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbimva_hyp_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBIMVAHIS", .cp = 15, .opc1 = 4, .crn = 8, .crm = 3, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbimva_hyp_is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_ALLE2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 7, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_alle2_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VAE2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 7, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae2_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VALE2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 7, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae2_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_ALLE2IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_alle2is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VAE2IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 3, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae2is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VALE2IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 8, .crm = 3, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae2is_write },<BR>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; /* Unlike the other EL2-related AT operations, these must<BR>&nbsp;&nbsp;&nbsp;&nbsp; * UNDEF from EL3 if EL2 is not implemented, which is why we<BR>&nbsp;&nbsp;&nbsp;&nbsp; * define them here rather than with the rest of the AT ops.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "AT_S1E2R", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 7, .crm = 8, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .accessfn = at_s1e2_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .writefn = ats_write64 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AT_S1E2W", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 4, .crn = 7, .crm = 8, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W, .accessfn = at_s1e2_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW, .writefn = ats_write64 },<BR>&nbsp;&nbsp;&nbsp; /* The AArch32 ATS1H* operations are CONSTRAINED UNPREDICTABLE<BR>&nbsp;&nbsp;&nbsp;&nbsp; * if EL2 is not implemented; we choose to UNDEF. Behaviour at EL3<BR>&nbsp;&nbsp;&nbsp;&nbsp; * with SCR.NS == 0 outside Monitor mode is UNPREDICTABLE; we choose<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to behave as if SCR.NS was 1.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "ATS1HR", .cp = 15, .opc1 = 4, .crn = 7, .crm = 8, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = ats1h_write, .type = ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; { .name = "ATS1HW", .cp = 15, .opc1 = 4, .crn = 7, .crm = 8, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = ats1h_write, .type = ARM_CP_NO_RAW },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTHCTL_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 14, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ARMv7 requires bit 0 and 1 to reset to 1. ARMv8 defines the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * reset values as IMPDEF. We choose to reset to 3 to comply with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * both ARMv7 and ARMv8.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .resetvalue = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.cnthctl_el2) },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTVOFF_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 14, .crm = 0, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_IO, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_cntvoff_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.cntvoff_el2) },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTVOFF", .cp = 15, .opc1 = 4, .crm = 14,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_64BIT | ARM_CP_ALIAS | ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_cntvoff_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.cntvoff_el2) },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTHP_CVAL_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 14, .crm = 2, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_HYP].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO, .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_hyp_cval_write, .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTHP_CVAL", .cp = 15, .opc1 = 6, .crm = 14,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_HYP].cval),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_64BIT | ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_hyp_cval_write, .raw_writefn = raw_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTHP_TVAL_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 14, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW | ARM_CP_IO, .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetfn = gt_hyp_timer_reset,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = gt_hyp_tval_read, .writefn = gt_hyp_tval_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "CNTHP_CTL_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 14, .crm = 2, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c14_timer[GTIMER_HYP].ctl),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = gt_hyp_ctl_write, .raw_writefn = raw_write },<BR>#endif<BR>&nbsp;&nbsp;&nbsp; /* The only field of MDCR_EL2 that has a defined architectural reset value<BR>&nbsp;&nbsp;&nbsp;&nbsp; * is MDCR_EL2.HPMN which should reset to the value of PMCR_EL0.N; but we<BR>&nbsp;&nbsp;&nbsp;&nbsp; * don't impelment any PMU event counters, so using zero as a reset<BR>&nbsp;&nbsp;&nbsp;&nbsp; * value for MDCR_EL2 is okay<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "MDCR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 1, .crm = 1, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.mdcr_el2), },<BR>&nbsp;&nbsp;&nbsp; { .name = "HPFAR", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 4, .crn = 6, .crm = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .accessfn = access_el3_aa32ns,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.hpfar_el2) },<BR>&nbsp;&nbsp;&nbsp; { .name = "HPFAR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 6, .crm = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.hpfar_el2) },<BR>&nbsp;&nbsp;&nbsp; { .name = "HSTR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc0 = 3, .opc1 = 4, .crn = 1, .crm = 1, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.hstr_el2) },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static CPAccessResult nsacr_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* The NSACR is RW at EL3, and RO for NS EL1 and NS EL2.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * At Secure EL1 it traps to EL3.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_EL3;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* Accesses from EL1 NS and EL2 NS are UNDEF for write but allow reads. */<BR>&nbsp;&nbsp;&nbsp; if (isread) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP_UNCATEGORIZED;<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo el3_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "SCR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 1, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .fieldoffset = offsetof(CPUARMState, cp15.scr_el3),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0, .writefn = scr_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "SCR",&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 1, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_trap_aa32s_el1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState, cp15.scr_el3),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = scr_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "SDER32_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 1, .crm = 1, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.sder) },<BR>&nbsp;&nbsp;&nbsp; { .name = "SDER",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 1, .crm = 1, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState, cp15.sder) },<BR>&nbsp;&nbsp;&nbsp; { .name = "MVBAR", .cp = 15, .opc1 = 0, .crn = 12, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_trap_aa32s_el1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = vbar_write, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.mvbar) },<BR>&nbsp;&nbsp;&nbsp; { .name = "TTBR0_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 2, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .writefn = vmsa_ttbr_write, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.ttbr0_el[3]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "TCR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 2, .crm = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* no .writefn needed as this can't cause an ASID change;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * we must provide a .raw_writefn and .resetfn because we handle<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * reset and migration for the AArch32 TTBCR(S), which might be<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * using mask and base_mask.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetfn = vmsa_ttbcr_reset, .raw_writefn = vmsa_ttbcr_raw_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.tcr_el[3]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "ELR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 4, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, elr_el[3]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "ESR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 5, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .fieldoffset = offsetof(CPUARMState, cp15.esr_el[3]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "FAR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 6, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .fieldoffset = offsetof(CPUARMState, cp15.far_el[3]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "SPSR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 4, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, banked_spsr[BANK_MON]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "VBAR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 12, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .writefn = vbar_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.vbar_el[3]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "CPTR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 1, .crm = 1, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .accessfn = cptr_access, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.cptr_el[3]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "TPIDR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 13, .crm = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.tpidr_el[3]) },<BR>&nbsp;&nbsp;&nbsp; { .name = "AMAIR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 10, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AFSR0_EL3", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 5, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "AFSR1_EL3", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 5, .crm = 1, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_ALLE3IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 6, .crn = 8, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_alle3is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VAE3IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 6, .crn = 8, .crm = 3, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae3is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VALE3IS", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 6, .crn = 8, .crm = 3, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae3is_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_ALLE3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 6, .crn = 8, .crm = 7, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_alle3_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VAE3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 6, .crn = 8, .crm = 7, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae3_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLBI_VALE3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 1, .opc1 = 6, .crn = 8, .crm = 7, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = tlbi_aa64_vae3_write },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static CPAccessResult ctr_el0_access(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Only accessible in EL0 if SCTLR.UCT is set (and only in AArch64,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * but the AArch32 CTR has its own reginfo struct)<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == 0 &amp;&amp; !(env-&gt;cp15.sctlr_el[1] &amp; SCTLR_UCT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return CP_ACCESS_TRAP;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return CP_ACCESS_OK;<BR>}</FONT></P>
<P><FONT class=extract>static void oslar_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Writes to OSLAR_EL1 may update the OS lock status, which can be<BR>&nbsp;&nbsp;&nbsp;&nbsp; * read via a bit in OSLSR_EL1.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int oslock;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (ri-&gt;state == ARM_CP_STATE_AA32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oslock = (value == 0xC5ACCE55);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oslock = value &amp; 1;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; env-&gt;cp15.oslsr_el1 = deposit32(env-&gt;cp15.oslsr_el1, 1, 1, oslock);<BR>}</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo debug_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* DBGDRAR, DBGDSAR: always RAZ since we don't implement memory mapped<BR>&nbsp;&nbsp;&nbsp;&nbsp; * debug components. The AArch64 version of DBGDRAR is named MDRAR_EL1;<BR>&nbsp;&nbsp;&nbsp;&nbsp; * unlike DBGDRAR it is never accessible from EL0.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * DBGDSAR is deprecated and must RAZ from v8 anyway, so it has no AArch64<BR>&nbsp;&nbsp;&nbsp;&nbsp; * accessor.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "DBGDRAR", .cp = 14, .crn = 1, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .accessfn = access_tdra,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "MDRAR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 2, .opc1 = 0, .crn = 1, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .accessfn = access_tdra,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "DBGDSAR", .cp = 14, .crn = 2, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .accessfn = access_tdra,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* Monitor debug system control register; the 32-bit alias is DBGDSCRext. */<BR>&nbsp;&nbsp;&nbsp; { .name = "MDSCR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tda,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.mdscr_el1),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; /* MDCCSR_EL0, aka DBGDSCRint. This is a read-only mirror of MDSCR_EL1.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * We don't implement the configurable EL0 access.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "MDCCSR_EL0", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .accessfn = access_tda,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.mdscr_el1), },<BR>&nbsp;&nbsp;&nbsp; { .name = "OSLAR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 1, .crm = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = access_tdosa,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = oslar_write },<BR>&nbsp;&nbsp;&nbsp; { .name = "OSLSR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 1, .crm = 1, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .resetvalue = 10,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = access_tdosa,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.oslsr_el1) },<BR>&nbsp;&nbsp;&nbsp; /* Dummy OSDLR_EL1: 32-bit Linux will read this */<BR>&nbsp;&nbsp;&nbsp; { .name = "OSDLR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 1, .crm = 3, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tdosa,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; /* Dummy DBGVCR: Linux wants to clear this on startup, but we don't<BR>&nbsp;&nbsp;&nbsp;&nbsp; * implement vector catch debug events yet.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "DBGVCR",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tda,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>static const ARMCPRegInfo debug_lpae_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* 64 bit access versions of the (dummy) debug registers */<BR>&nbsp;&nbsp;&nbsp; { .name = "DBGDRAR", .cp = 14, .crm = 1, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_CONST|ARM_CP_64BIT, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "DBGDSAR", .cp = 14, .crm = 2, .opc1 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .type = ARM_CP_CONST|ARM_CP_64BIT, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</FONT></P>
<P><FONT class=extract>void hw_watchpoint_update(ARMCPU *cpu, int n)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; vaddr len = 0;<BR>&nbsp;&nbsp;&nbsp; vaddr wvr = env-&gt;cp15.dbgwvr[n];<BR>&nbsp;&nbsp;&nbsp; uint64_t wcr = env-&gt;cp15.dbgwcr[n];<BR>&nbsp;&nbsp;&nbsp; int mask;<BR>&nbsp;&nbsp;&nbsp; int flags = BP_CPU | BP_STOP_BEFORE_ACCESS;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (env-&gt;cpu_watchpoint[n]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_watchpoint_remove_by_ref(CPU(cpu), env-&gt;cpu_watchpoint[n]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cpu_watchpoint[n] = NULL;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!extract64(wcr, 0, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* E bit clear : watchpoint disabled */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; switch (extract64(wcr, 3, 2)) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* LSC 00 is reserved and must behave as if the wp is disabled */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags |= BP_MEM_READ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags |= BP_MEM_WRITE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags |= BP_MEM_ACCESS;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Attempts to use both MASK and BAS fields simultaneously are<BR>&nbsp;&nbsp;&nbsp;&nbsp; * CONSTRAINED UNPREDICTABLE; we opt to ignore BAS in this case,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * thus generating a watchpoint for every byte in the masked region.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; mask = extract64(wcr, 24, 4);<BR>&nbsp;&nbsp;&nbsp; if (mask == 1 || mask == 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Reserved values of MASK; we must act as if the mask value was<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * some non-reserved value, or as if the watchpoint were disabled.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * We choose the latter.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; } else if (mask) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Watchpoint covers an aligned area up to 2GB in size */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = 1ULL &lt;&lt; mask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If masked bits in WVR are not zero it's CONSTRAINED UNPREDICTABLE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * whether the watchpoint fires when the unmasked bits match; we opt<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * to generate the exceptions.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wvr &amp;= ~(len - 1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Watchpoint covers bytes defined by the byte address select bits */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bas = extract64(wcr, 5, 8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int basstart;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bas == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* This must act as if the watchpoint is disabled */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extract64(wvr, 2, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Deprecated case of an only 4-aligned address. BAS[7:4] are<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * ignored, and BAS[3:0] define which bytes to watch.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bas &amp;= 0xf;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The BAS bits are supposed to be programmed to indicate a contiguous<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * range of bytes. Otherwise it is CONSTRAINED UNPREDICTABLE whether<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * we fire for each byte in the word/doubleword addressed by the WVR.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * We choose to ignore any non-zero bits after the first range of 1s.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; basstart = ctz32(bas);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = cto32(bas &gt;&gt; basstart);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wvr += basstart;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; cpu_watchpoint_insert(CPU(cpu), wvr, len, flags,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;env-&gt;cpu_watchpoint[n]);<BR>}</FONT></P>
<P><FONT class=extract>void hw_watchpoint_update_all(ARMCPU *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Completely clear out existing QEMU watchpoints and our array, to<BR>&nbsp;&nbsp;&nbsp;&nbsp; * avoid possible stale entries following migration load.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; cpu_watchpoint_remove_all(CPU(cpu), BP_CPU);<BR>&nbsp;&nbsp;&nbsp; memset(env-&gt;cpu_watchpoint, 0, sizeof(env-&gt;cpu_watchpoint));</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; ARRAY_SIZE(cpu-&gt;env.cpu_watchpoint); i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hw_watchpoint_update(cpu, i);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void dbgwvr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; int i = ri-&gt;crm;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Bits [63:49] are hardwired to the value of bit [48]; that is, the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * register reads and behaves as if values written are sign extended.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Bits [1:0] are RES0.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; value = sextract64(value, 0, 49) &amp; ~3ULL;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; hw_watchpoint_update(cpu, i);<BR>}</FONT></P>
<P><FONT class=extract>static void dbgwcr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; int i = ri-&gt;crm;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; hw_watchpoint_update(cpu, i);<BR>}</FONT></P>
<P>void hw_breakpoint_update(ARMCPU *cpu, int n)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; uint64_t bvr = env-&gt;cp15.dbgbvr[n];<BR>&nbsp;&nbsp;&nbsp; uint64_t bcr = env-&gt;cp15.dbgbcr[n];<BR>&nbsp;&nbsp;&nbsp; vaddr addr;<BR>&nbsp;&nbsp;&nbsp; int bt;<BR>&nbsp;&nbsp;&nbsp; int flags = BP_CPU;</P>
<P>&nbsp;&nbsp;&nbsp; if (env-&gt;cpu_breakpoint[n]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_breakpoint_remove_by_ref(CPU(cpu), env-&gt;cpu_breakpoint[n]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cpu_breakpoint[n] = NULL;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (!extract64(bcr, 0, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* E bit clear : watchpoint disabled */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; bt = extract64(bcr, 20, 4);</P>
<P>&nbsp;&nbsp;&nbsp; switch (bt) {<BR>&nbsp;&nbsp;&nbsp; case 4: /* unlinked address mismatch (reserved if AArch64) */<BR>&nbsp;&nbsp;&nbsp; case 5: /* linked address mismatch (reserved if AArch64) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_UNIMP,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "arm: address mismatch breakpoint types not implemented");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; case 0: /* unlinked address match */<BR>&nbsp;&nbsp;&nbsp; case 1: /* linked address match */<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Bits [63:49] are hardwired to the value of bit [48]; that is,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * we behave as if the register was sign extended. Bits [1:0] are<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * RES0. The BAS field is used to allow setting breakpoints on 16<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * bit wide instructions; it is CONSTRAINED UNPREDICTABLE whether<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * a bp will fire if the addresses covered by the bp and the addresses<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * covered by the insn overlap but the insn doesn't start at the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * start of the bp address range. We choose to require the insn and<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the bp to have the same address. The constraints on writing to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * BAS enforced in dbgbcr_write mean we have only four cases:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; 0b0000&nbsp; =&gt; no breakpoint<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; 0b0011&nbsp; =&gt; breakpoint on addr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; 0b1100&nbsp; =&gt; breakpoint on addr + 2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; 0b1111&nbsp; =&gt; breakpoint on addr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * See also figure D2-3 in the v8 ARM ARM (DDI0487A.c).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bas = extract64(bcr, 5, 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr = sextract64(bvr, 0, 49) &amp; ~3ULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bas == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bas == 0xc) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr += 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; case 2: /* unlinked context ID match */<BR>&nbsp;&nbsp;&nbsp; case 8: /* unlinked VMID match (reserved if no EL2) */<BR>&nbsp;&nbsp;&nbsp; case 10: /* unlinked context ID and VMID match (reserved if no EL2) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_UNIMP,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "arm: unlinked context breakpoint types not implemented");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; case 9: /* linked VMID match (reserved if no EL2) */<BR>&nbsp;&nbsp;&nbsp; case 11: /* linked context ID and VMID match (reserved if no EL2) */<BR>&nbsp;&nbsp;&nbsp; case 3: /* linked context ID match */<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We must generate no events for Linked context matches (unless<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * they are linked to by some other bp/wp, which is handled in<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * updates for the linking bp/wp). We choose to also generate no events<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * for reserved values.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cpu_breakpoint_insert(CPU(cpu), addr, flags, &amp;env-&gt;cpu_breakpoint[n]);<BR>}</P>
<P>void hw_breakpoint_update_all(ARMCPU *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; /* Completely clear out existing QEMU breakpoints and our array, to<BR>&nbsp;&nbsp;&nbsp;&nbsp; * avoid possible stale entries following migration load.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; cpu_breakpoint_remove_all(CPU(cpu), BP_CPU);<BR>&nbsp;&nbsp;&nbsp; memset(env-&gt;cpu_breakpoint, 0, sizeof(env-&gt;cpu_breakpoint));</P>
<P>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; ARRAY_SIZE(cpu-&gt;env.cpu_breakpoint); i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hw_breakpoint_update(cpu, i);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void dbgbvr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; int i = ri-&gt;crm;</P>
<P>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; hw_breakpoint_update(cpu, i);<BR>}</P>
<P>static void dbgbcr_write(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; int i = ri-&gt;crm;</P>
<P>&nbsp;&nbsp;&nbsp; /* BAS[3] is a read-only copy of BAS[2], and BAS[1] a read-only<BR>&nbsp;&nbsp;&nbsp;&nbsp; * copy of BAS[0].<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; value = deposit64(value, 6, 1, extract64(value, 5, 1));<BR>&nbsp;&nbsp;&nbsp; value = deposit64(value, 8, 1, extract64(value, 7, 1));</P>
<P>&nbsp;&nbsp;&nbsp; raw_write(env, ri, value);<BR>&nbsp;&nbsp;&nbsp; hw_breakpoint_update(cpu, i);<BR>}</P>
<P>static void define_debug_regs(ARMCPU *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Define v7 and v8 architectural debug registers.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * These are just dummy implementations for now.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; int wrps, brps, ctx_cmps;<BR>&nbsp;&nbsp;&nbsp; ARMCPRegInfo dbgdidr = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "DBGDIDR", .cp = 14, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .accessfn = access_tda,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .resetvalue = cpu-&gt;dbgdidr,<BR>&nbsp;&nbsp;&nbsp; };</P>
<P>&nbsp;&nbsp;&nbsp; /* Note that all these register fields hold "number of Xs minus 1". */<BR>&nbsp;&nbsp;&nbsp; brps = extract32(cpu-&gt;dbgdidr, 24, 4);<BR>&nbsp;&nbsp;&nbsp; wrps = extract32(cpu-&gt;dbgdidr, 28, 4);<BR>&nbsp;&nbsp;&nbsp; ctx_cmps = extract32(cpu-&gt;dbgdidr, 20, 4);</P>
<P>&nbsp;&nbsp;&nbsp; assert(ctx_cmps &lt;= brps);</P>
<P>&nbsp;&nbsp;&nbsp; /* The DBGDIDR and ID_AA64DFR0_EL1 define various properties<BR>&nbsp;&nbsp;&nbsp;&nbsp; * of the debug registers such as number of breakpoints;<BR>&nbsp;&nbsp;&nbsp;&nbsp; * check that if they both exist then they agree.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(&amp;cpu-&gt;env, ARM_FEATURE_AARCH64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(extract32(cpu-&gt;id_aa64dfr0, 12, 4) == brps);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(extract32(cpu-&gt;id_aa64dfr0, 20, 4) == wrps);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(extract32(cpu-&gt;id_aa64dfr0, 28, 4) == ctx_cmps);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;dbgdidr);<BR>&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, debug_cp_reginfo);</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(&amp;cpu-&gt;env, ARM_FEATURE_LPAE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, debug_lpae_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; brps + 1; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo dbgregs[] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "DBGBVR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 0, .crm = i, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tda,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.dbgbvr[i]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = dbgbvr_write, .raw_writefn = raw_write<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "DBGBCR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 0, .crm = i, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tda,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.dbgbcr[i]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = dbgbcr_write, .raw_writefn = raw_write<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, dbgregs);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; wrps + 1; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo dbgregs[] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "DBGWVR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 0, .crm = i, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tda,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.dbgwvr[i]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = dbgwvr_write, .raw_writefn = raw_write<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "DBGWCR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 14, .opc0 = 2, .opc1 = 0, .crn = 0, .crm = i, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = access_tda,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.dbgwcr[i]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = dbgwcr_write, .raw_writefn = raw_write<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, dbgregs);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void register_cp_regs_for_features(ARMCPU *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Register all the coprocessor registers based on feature bits */<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_M)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* M profile has no coprocessor registers */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Must go early as it is full of wildcards that may be<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * overridden by later definitions.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, not_v8_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V6)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The ID registers all have impdef reset values */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo v6_idregs[] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_PFR0", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_pfr0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_PFR1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_pfr1 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_DFR0", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_dfr0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AFR0", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_afr0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_MMFR0", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_mmfr0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_MMFR1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_mmfr1 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_MMFR2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_mmfr2 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_MMFR3", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_mmfr3 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_ISAR0", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_isar0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_ISAR1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_isar1 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_ISAR2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_isar2 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_ISAR3", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_isar3 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_ISAR4", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_isar4 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_ISAR5", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_isar5 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_MMFR4", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_mmfr4 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 7 is as yet unallocated and must RAZ */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_ISAR7_RESERVED", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, v6_idregs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, v6_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, not_v6_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V6K)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, v6k_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V7MP) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_feature(env, ARM_FEATURE_MPU)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, v7mp_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V7)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* v7 performance monitor control register: same implementor<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * field as main ID register, and we implement only the cycle<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * count register.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo pmcr = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "PMCR", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO | ARM_CP_ALIAS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetoflow32(CPUARMState, cp15.c9_pmcr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .accessfn = pmreg_access, .writefn = pmcr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo pmcr64 = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "PMCR_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 12, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_RW, .accessfn = pmreg_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_IO,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c9_pmcr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;midr &amp; 0xff000000,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = pmcr_write, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;pmcr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;pmcr64);<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo clidr = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "CLIDR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .crn = 0, .crm = 0, .opc1 = 1, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu-&gt;clidr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;clidr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, v7_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_debug_regs(cpu);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, not_v7_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* AArch64 ID registers, which all have impdef reset values.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Note that within the ID register ranges the unused slots<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * must all RAZ, not UNDEF; future architecture versions may<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * define new registers here.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo v8_idregs[] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64PFR0_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_aa64pfr0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64PFR1_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_aa64pfr1},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64PFR2_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64PFR3_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64PFR4_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64PFR5_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64PFR6_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64PFR7_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64DFR0_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We mask out the PMUVer field, because we don't currently<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * implement the PMU. Not advertising it prevents the guest<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * from trying to use it and getting UNDEFs on registers we<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * don't implement.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_aa64dfr0 &amp; ~0xf00 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64DFR1_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_aa64dfr1 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64DFR2_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64DFR3_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64AFR0_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_aa64afr0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64AFR1_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_aa64afr1 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64AFR2_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64AFR3_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64ISAR0_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_aa64isar0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64ISAR1_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_aa64isar1 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64ISAR2_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64ISAR3_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64ISAR4_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64ISAR5_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64ISAR6_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64ISAR7_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64MMFR0_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_aa64mmfr0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64MMFR1_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;id_aa64mmfr1 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64MMFR2_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64MMFR3_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64MMFR4_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64MMFR5_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64MMFR6_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ID_AA64MMFR7_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "MVFR0_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;mvfr0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "MVFR1_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;mvfr1 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "MVFR2_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;mvfr2 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "MVFR3_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "MVFR4_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "MVFR5_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "MVFR6_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "MVFR7_EL1_RESERVED", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "PMCEID0", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 9, .crm = 12, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .accessfn = pmreg_access, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;pmceid0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "PMCEID0_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 12, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .accessfn = pmreg_access, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;pmceid0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "PMCEID1", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 9, .crm = 12, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .accessfn = pmreg_access, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;pmceid1 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "PMCEID1_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .crn = 9, .crm = 12, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .accessfn = pmreg_access, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;pmceid1 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* RVBAR_EL1 is only implemented if EL1 is the highest EL */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_EL3) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_feature(env, ARM_FEATURE_EL2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo rvbar = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "RVBAR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 12, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .access = PL1_R, .resetvalue = cpu-&gt;rvbar<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;rvbar);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, v8_idregs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, v8_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t vmpidr_def = mpidr_read_val(env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo vpidr_regs[] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "VPIDR", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 4, .crn = 0, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .accessfn = access_el3_aa32ns,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;midr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.vpidr_el2) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "VPIDR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 0, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .resetvalue = cpu-&gt;midr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.vpidr_el2) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "VMPIDR", .state = ARM_CP_STATE_AA32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 4, .crn = 0, .crm = 0, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .accessfn = access_el3_aa32ns,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = vmpidr_def,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.vmpidr_el2) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "VMPIDR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 0, .crm = 0, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = vmpidr_def,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.vmpidr_el2) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, vpidr_regs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, el2_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* RVBAR_EL2 is only implemented if EL2 is the highest EL */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo rvbar = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "RVBAR_EL2", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 12, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .access = PL2_R, .resetvalue = cpu-&gt;rvbar<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;rvbar);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If EL2 is missing but higher ELs are enabled, we need to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * register the no_el2 reginfos.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* When EL3 exists but not EL2, VPIDR and VMPIDR take the value<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * of MIDR_EL1 and MPIDR_EL1.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo vpidr_regs[] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "VPIDR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 0, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .accessfn = access_el3_aa32ns_aa64any,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .resetvalue = cpu-&gt;midr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.vpidr_el2) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "VMPIDR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 0, .crm = 0, .opc2 = 5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .accessfn = access_el3_aa32ns_aa64any,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NO_RAW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = arm_cp_write_ignore, .readfn = mpidr_read },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, vpidr_regs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, el3_no_el2_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, el3_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo el3_regs[] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "RVBAR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 12, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .access = PL3_R, .resetvalue = cpu-&gt;rvbar },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "SCTLR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 1, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .raw_writefn = raw_write, .writefn = sctlr_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.sctlr_el[3]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;reset_sctlr },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, el3_regs);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* The behaviour of NSACR is sufficiently various that we don't<BR>&nbsp;&nbsp;&nbsp;&nbsp; * try to describe it in a single reginfo:<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; if EL3 is 64 bit, then trap to EL3 from S EL1,<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; reads as constant 0xc00 from NS EL1 and NS EL2<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; if EL3 is 32 bit, then RW at EL3, RO at NS EL1 and NS EL2<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; if v7 without EL3, register doesn't exist<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; if v8 without EL3, reads as constant 0xc00 from NS EL1 and NS EL2<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_AARCH64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo nsacr = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "NSACR", .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 1, .crm = 1, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .accessfn = nsacr_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0xc00<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;nsacr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo nsacr = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "NSACR",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 1, .crm = 1, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW | PL1_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.nsacr)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;nsacr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo nsacr = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "NSACR", .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .opc1 = 0, .crn = 1, .crm = 1, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0xc00<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;nsacr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_MPU)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V6)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* PMSAv6 not implemented */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(arm_feature(env, ARM_FEATURE_V7));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, vmsa_pmsa_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, pmsav7_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, pmsav5_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, vmsa_pmsa_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, vmsa_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_THUMB2EE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, t2ee_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_GENERIC_TIMER)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, generic_timer_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_VAPA)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, vapa_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_CACHE_TEST_CLEAN)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, cache_test_clean_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_CACHE_DIRTY_REG)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, cache_dirty_status_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_CACHE_BLOCK_OPS)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, cache_block_ops_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_OMAPCP)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, omap_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_STRONGARM)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, strongarm_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_XSCALE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, xscale_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_DUMMY_C15_REGS)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, dummy_c15_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_LPAE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, lpae_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* Slightly awkwardly, the OMAP and StrongARM cores need all of<BR>&nbsp;&nbsp;&nbsp;&nbsp; * cp15 crn=0 to be writes-ignored, whereas for other cores they should<BR>&nbsp;&nbsp;&nbsp;&nbsp; * be read-only (ie write causes UNDEF exception).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo id_pre_v8_midr_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Pre-v8 MIDR space.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Note that the MIDR isn't a simple constant register because<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * of the TI925 behaviour where writes to another register can<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * cause the MIDR value to change.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Unimplemented registers in the c15 0 0 0 space default to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * MIDR. Define MIDR first as this entire space, then CTR, TCMTR<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * and friends override accordingly.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "MIDR",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .resetvalue = cpu-&gt;midr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = arm_cp_write_ignore, .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = midr_read,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c0_cpuid),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_OVERRIDE },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* crn = 0 op1 = 0 crm = 3..7 : currently unassigned; we RAZ. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "DUMMY",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 0, .crm = 3, .opc1 = 0, .opc2 = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "DUMMY",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 0, .crm = 4, .opc1 = 0, .opc2 = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "DUMMY",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 0, .crm = 5, .opc1 = 0, .opc2 = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "DUMMY",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 0, .crm = 6, .opc1 = 0, .opc2 = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "DUMMY",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 0, .crm = 7, .opc1 = 0, .opc2 = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo id_v8_midr_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "MIDR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_NO_RAW, .resetvalue = cpu-&gt;midr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c0_cpuid),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .readfn = midr_read },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* crn = 0 op1 = 0 crm = 0 op2 = 4,7 : AArch32 aliases of MIDR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "MIDR", .type = ARM_CP_ALIAS | ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .resetvalue = cpu-&gt;midr },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "MIDR", .type = ARM_CP_ALIAS | ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 7,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .resetvalue = cpu-&gt;midr },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "REVIDR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 0, .opc2 = 6,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu-&gt;revidr },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo id_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* These are common to v8 and pre-v8 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "CTR",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu-&gt;ctr },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "CTR_EL0", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 3, .opc2 = 1, .crn = 0, .crm = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL0_R, .accessfn = ctr_el0_access,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST, .resetvalue = cpu-&gt;ctr },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* TCMTR and TLBTR exist in v8 but have no 64-bit versions */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "TCMTR",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* TLBTR is specific to VMSA */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo id_tlbtr_reginfo = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "TLBTR",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* MPUIR is specific to PMSA V6+ */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo id_mpuir_reginfo = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "MPUIR",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;pmsav7_dregion &lt;&lt; 8<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo crn0_wi_reginfo = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "CRN0_WI", .cp = 15, .crn = 0, .crm = CP_ANY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc1 = CP_ANY, .opc2 = CP_ANY, .access = PL1_W,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_NOP | ARM_CP_OVERRIDE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_OMAPCP) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_feature(env, ARM_FEATURE_STRONGARM)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo *r;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Register the blanket "writes ignored" value first to cover the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * whole space. Then update the specific ID registers to allow write<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * access, so that they ignore writes rather than causing them to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * UNDEF.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;crn0_wi_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (r = id_pre_v8_midr_cp_reginfo;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r-&gt;type != ARM_CP_SENTINEL; r++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r-&gt;access = PL1_RW;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (r = id_cp_reginfo; r-&gt;type != ARM_CP_SENTINEL; r++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r-&gt;access = PL1_RW;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id_tlbtr_reginfo.access = PL1_RW;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id_tlbtr_reginfo.access = PL1_RW;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, id_v8_midr_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, id_pre_v8_midr_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, id_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_MPU)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;id_tlbtr_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (arm_feature(env, ARM_FEATURE_V7)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;id_mpuir_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_MPIDR)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, mpidr_cp_reginfo);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_AUXCR)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo auxcr_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ACTLR_EL1", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 1, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = cpu-&gt;reset_auxcr },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ACTLR_EL2", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 4, .crn = 1, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL2_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "ACTLR_EL3", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 6, .crn = 1, .crm = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL3_RW, .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, auxcr_reginfo);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_CBAR)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_AARCH64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 32 bit view is [31:18] 0...0 [43:32]. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t cbar32 = (extract64(cpu-&gt;reset_cbar, 18, 14) &lt;&lt; 18)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | extract64(cpu-&gt;reset_cbar, 32, 12);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo cbar_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "CBAR",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 15, .crm = 0, .opc1 = 4, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .resetvalue = cpu-&gt;reset_cbar },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { .name = "CBAR_EL1", .state = ARM_CP_STATE_AA64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .type = ARM_CP_CONST,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 1, .crn = 15, .crm = 3, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R, .resetvalue = cbar32 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We don't implement a r/w 64 bit CBAR currently */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(arm_feature(env, ARM_FEATURE_CBAR_RO));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, cbar_reginfo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo cbar = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "CBAR",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cp = 15, .crn = 15, .crm = 0, .opc1 = 4, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_R|PL3_W, .resetvalue = cpu-&gt;reset_cbar,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cp15.c15_config_base_address)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_CBAR_RO)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbar.access = PL1_R;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbar.fieldoffset = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbar.type = ARM_CP_CONST;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;cbar);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Generic registers whose values depend on the implementation */<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo sctlr = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "SCTLR", .state = ARM_CP_STATE_BOTH,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc0 = 3, .opc1 = 0, .crn = 1, .crm = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bank_fieldoffsets = { offsetof(CPUARMState, cp15.sctlr_s),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUARMState, cp15.sctlr_ns) },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = sctlr_write, .resetvalue = cpu-&gt;reset_sctlr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .raw_writefn = raw_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_XSCALE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Normally we would always end the TB on an SCTLR write, but Linux<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * arch/arm/mach-pxa/sleep.S expects two instructions following<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * an MMU enable to execute from cache.&nbsp; Imitate this behaviour.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sctlr.type |= ARM_CP_SUPPRESS_TB_END;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;sctlr);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P><FONT class=extract>ARMCPU *cpu_arm_init(const char *cpu_model)<BR>{<BR>&nbsp;&nbsp;&nbsp; return ARM_CPU(cpu_generic_init(TYPE_ARM_CPU, cpu_model));<BR>}</FONT></P>
<P><FONT class=extract>void arm_cpu_register_gdb_regs_for_features(ARMCPU *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_AARCH64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gdb_register_coprocessor(cs, aarch64_fpu_gdb_get_reg,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aarch64_fpu_gdb_set_reg,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 34, "aarch64-fpu.xml", 0);<BR>&nbsp;&nbsp;&nbsp; } else if (arm_feature(env, ARM_FEATURE_NEON)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gdb_register_coprocessor(cs, vfp_gdb_get_reg, vfp_gdb_set_reg,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 51, "arm-neon.xml", 0);<BR>&nbsp;&nbsp;&nbsp; } else if (arm_feature(env, ARM_FEATURE_VFP3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gdb_register_coprocessor(cs, vfp_gdb_get_reg, vfp_gdb_set_reg,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 35, "arm-vfp3.xml", 0);<BR>&nbsp;&nbsp;&nbsp; } else if (arm_feature(env, ARM_FEATURE_VFP)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gdb_register_coprocessor(cs, vfp_gdb_get_reg, vfp_gdb_set_reg,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19, "arm-vfp.xml", 0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>/* Sort alphabetically by type name, except for "any". */<BR>static gint arm_cpu_list_compare(gconstpointer a, gconstpointer b)<BR>{<BR>&nbsp;&nbsp;&nbsp; ObjectClass *class_a = (ObjectClass *)a;<BR>&nbsp;&nbsp;&nbsp; ObjectClass *class_b = (ObjectClass *)b;<BR>&nbsp;&nbsp;&nbsp; const char *name_a, *name_b;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; name_a = object_class_get_name(class_a);<BR>&nbsp;&nbsp;&nbsp; name_b = object_class_get_name(class_b);<BR>&nbsp;&nbsp;&nbsp; if (strcmp(name_a, "any-" TYPE_ARM_CPU) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp; } else if (strcmp(name_b, "any-" TYPE_ARM_CPU) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return strcmp(name_a, name_b);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void arm_cpu_list_entry(gpointer data, gpointer user_data)<BR>{<BR>&nbsp;&nbsp;&nbsp; ObjectClass *oc = data;<BR>&nbsp;&nbsp;&nbsp; CPUListState *s = user_data;<BR>&nbsp;&nbsp;&nbsp; const char *typename;<BR>&nbsp;&nbsp;&nbsp; char *name;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; typename = object_class_get_name(oc);<BR>&nbsp;&nbsp;&nbsp; name = g_strndup(typename, strlen(typename) - strlen("-" TYPE_ARM_CPU));<BR>&nbsp;&nbsp;&nbsp; (*s-&gt;cpu_fprintf)(s-&gt;file, "&nbsp; %s\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name);<BR>&nbsp;&nbsp;&nbsp; g_free(name);<BR>}</FONT></P>
<P><FONT class=extract>void arm_cpu_list(FILE *f, fprintf_function cpu_fprintf)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUListState s = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .file = f,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .cpu_fprintf = cpu_fprintf,<BR>&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp; GSList *list;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; list = object_class_get_list(TYPE_ARM_CPU, false);<BR>&nbsp;&nbsp;&nbsp; list = g_slist_sort(list, arm_cpu_list_compare);<BR>&nbsp;&nbsp;&nbsp; (*cpu_fprintf)(f, "Available CPUs:\n");<BR>&nbsp;&nbsp;&nbsp; g_slist_foreach(list, arm_cpu_list_entry, &amp;s);<BR>&nbsp;&nbsp;&nbsp; g_slist_free(list);<BR>#ifdef CONFIG_KVM<BR>&nbsp;&nbsp;&nbsp; /* The 'host' CPU type is dynamically registered only if KVM is<BR>&nbsp;&nbsp;&nbsp;&nbsp; * enabled, so we have to special-case it here:<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; (*cpu_fprintf)(f, "&nbsp; host (only available in KVM mode)\n");<BR>#endif<BR>}</FONT></P>
<P><FONT class=extract>static void arm_cpu_add_definition(gpointer data, gpointer user_data)<BR>{<BR>&nbsp;&nbsp;&nbsp; ObjectClass *oc = data;<BR>&nbsp;&nbsp;&nbsp; CpuDefinitionInfoList **cpu_list = user_data;<BR>&nbsp;&nbsp;&nbsp; CpuDefinitionInfoList *entry;<BR>&nbsp;&nbsp;&nbsp; CpuDefinitionInfo *info;<BR>&nbsp;&nbsp;&nbsp; const char *typename;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; typename = object_class_get_name(oc);<BR>&nbsp;&nbsp;&nbsp; info = g_malloc0(sizeof(*info));<BR>&nbsp;&nbsp;&nbsp; info-&gt;name = g_strndup(typename,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strlen(typename) - strlen("-" TYPE_ARM_CPU));</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; entry = g_malloc0(sizeof(*entry));<BR>&nbsp;&nbsp;&nbsp; entry-&gt;value = info;<BR>&nbsp;&nbsp;&nbsp; entry-&gt;next = *cpu_list;<BR>&nbsp;&nbsp;&nbsp; *cpu_list = entry;<BR>}</FONT></P>
<P><FONT class=extract>CpuDefinitionInfoList *arch_query_cpu_definitions(Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; CpuDefinitionInfoList *cpu_list = NULL;<BR>&nbsp;&nbsp;&nbsp; GSList *list;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; list = object_class_get_list(TYPE_ARM_CPU, false);<BR>&nbsp;&nbsp;&nbsp; g_slist_foreach(list, arm_cpu_add_definition, &amp;cpu_list);<BR>&nbsp;&nbsp;&nbsp; g_slist_free(list);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return cpu_list;<BR>}</FONT></P>
<P>static void add_cpreg_to_hashtable(ARMCPU *cpu, const ARMCPRegInfo *r,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *opaque, int state, int secstate,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int crm, int opc1, int opc2)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Private utility function for define_one_arm_cp_reg_with_opaque():<BR>&nbsp;&nbsp;&nbsp;&nbsp; * add a single reginfo struct to the hash table.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t *key = g_new(uint32_t, 1);<BR>&nbsp;&nbsp;&nbsp; ARMCPRegInfo *r2 = g_memdup(r, sizeof(ARMCPRegInfo));<BR>&nbsp;&nbsp;&nbsp; int is64 = (r-&gt;type &amp; ARM_CP_64BIT) ? 1 : 0;<BR>&nbsp;&nbsp;&nbsp; int ns = (secstate &amp; ARM_CP_SECSTATE_NS) ? 1 : 0;</P>
<P>&nbsp;&nbsp;&nbsp; /* Reset the secure state to the specific incoming state.&nbsp; This is<BR>&nbsp;&nbsp;&nbsp;&nbsp; * necessary as the register may have been defined with both states.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; r2-&gt;secure = secstate;</P>
<P>&nbsp;&nbsp;&nbsp; if (r-&gt;bank_fieldoffsets[0] &amp;&amp; r-&gt;bank_fieldoffsets[1]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Register is banked (using both entries in array).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Overwriting fieldoffset as the array is only used to define<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * banked registers but later only fieldoffset is used.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2-&gt;fieldoffset = r-&gt;bank_fieldoffsets[ns];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (state == ARM_CP_STATE_AA32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r-&gt;bank_fieldoffsets[0] &amp;&amp; r-&gt;bank_fieldoffsets[1]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If the register is banked then we don't need to migrate or<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * reset the 32-bit instance in certain cases:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 1) If the register has both 32-bit and 64-bit instances then we<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; can count on the 64-bit instance taking care of the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; non-secure bank.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 2) If ARMv8 is enabled then we can count on a 64-bit version<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; taking care of the secure bank.&nbsp; This requires that separate<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; 32 and 64-bit definitions are provided.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((r-&gt;state == ARM_CP_STATE_BOTH &amp;&amp; ns) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (arm_feature(&amp;cpu-&gt;env, ARM_FEATURE_V8) &amp;&amp; !ns)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2-&gt;type |= ARM_CP_ALIAS;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ((secstate != r-&gt;secure) &amp;&amp; !ns) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The register is not banked so we only want to allow migration of<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the non-secure instance.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2-&gt;type |= ARM_CP_ALIAS;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r-&gt;state == ARM_CP_STATE_BOTH) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We assume it is a cp15 register if the .cp field is left unset.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r2-&gt;cp == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2-&gt;cp = 15;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>#ifdef HOST_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r2-&gt;fieldoffset) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2-&gt;fieldoffset += sizeof(uint32_t);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (state == ARM_CP_STATE_AA64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* To allow abbreviation of ARMCPRegInfo<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * definitions, we treat cp == 0 as equivalent to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the value for "standard guest-visible sysreg".<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * STATE_BOTH definitions are also always "standard<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * sysreg" in their AArch64 view (the .cp value may<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * be non-zero for the benefit of the AArch32 view).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r-&gt;cp == 0 || r-&gt;state == ARM_CP_STATE_BOTH) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2-&gt;cp = CP_REG_ARM64_SYSREG_CP;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *key = ENCODE_AA64_CP_REG(r2-&gt;cp, r2-&gt;crn, crm,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2-&gt;opc0, opc1, opc2);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *key = ENCODE_CP_REG(r2-&gt;cp, is64, ns, r2-&gt;crn, crm, opc1, opc2);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (opaque) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2-&gt;opaque = opaque;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* reginfo passed to helpers is correct for the actual access,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and is never ARM_CP_STATE_BOTH:<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; r2-&gt;state = state;<BR>&nbsp;&nbsp;&nbsp; /* Make sure reginfo passed to helpers for wildcarded regs<BR>&nbsp;&nbsp;&nbsp;&nbsp; * has the correct crm/opc1/opc2 for this reg, not CP_ANY:<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; r2-&gt;crm = crm;<BR>&nbsp;&nbsp;&nbsp; r2-&gt;opc1 = opc1;<BR>&nbsp;&nbsp;&nbsp; r2-&gt;opc2 = opc2;<BR>&nbsp;&nbsp;&nbsp; /* By convention, for wildcarded registers only the first<BR>&nbsp;&nbsp;&nbsp;&nbsp; * entry is used for migration; the others are marked as<BR>&nbsp;&nbsp;&nbsp;&nbsp; * ALIAS so we don't try to transfer the register<BR>&nbsp;&nbsp;&nbsp;&nbsp; * multiple times. Special registers (ie NOP/WFI) are<BR>&nbsp;&nbsp;&nbsp;&nbsp; * never migratable and not even raw-accessible.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if ((r-&gt;type &amp; ARM_CP_SPECIAL)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2-&gt;type |= ARM_CP_NO_RAW;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (((r-&gt;crm == CP_ANY) &amp;&amp; crm != 0) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((r-&gt;opc1 == CP_ANY) &amp;&amp; opc1 != 0) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((r-&gt;opc2 == CP_ANY) &amp;&amp; opc2 != 0)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2-&gt;type |= ARM_CP_ALIAS;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Check that raw accesses are either forbidden or handled. Note that<BR>&nbsp;&nbsp;&nbsp;&nbsp; * we can't assert this earlier because the setup of fieldoffset for<BR>&nbsp;&nbsp;&nbsp;&nbsp; * banked registers has to be done first.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!(r2-&gt;type &amp; ARM_CP_NO_RAW)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(!raw_accessors_invalid(r2));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Overriding of an existing definition must be explicitly<BR>&nbsp;&nbsp;&nbsp;&nbsp; * requested.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!(r-&gt;type &amp; ARM_CP_OVERRIDE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo *oldreg;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldreg = g_hash_table_lookup(cpu-&gt;cp_regs, key);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (oldreg &amp;&amp; !(oldreg-&gt;type &amp; ARM_CP_OVERRIDE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Register redefined: cp=%d %d bit "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "crn=%d crm=%d opc1=%d opc2=%d, "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "was %s, now %s\n", r2-&gt;cp, 32 + 32 * is64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2-&gt;crn, r2-&gt;crm, r2-&gt;opc1, r2-&gt;opc2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oldreg-&gt;name, r2-&gt;name);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; g_hash_table_insert(cpu-&gt;cp_regs, key, r2);<BR>}</P>
<P><BR>void define_one_arm_cp_reg_with_opaque(ARMCPU *cpu,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *r, void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Define implementations of coprocessor registers.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * We store these in a hashtable because typically<BR>&nbsp;&nbsp;&nbsp;&nbsp; * there are less than 150 registers in a space which<BR>&nbsp;&nbsp;&nbsp;&nbsp; * is 16*16*16*8*8 = 262144 in size.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Wildcarding is supported for the crm, opc1 and opc2 fields.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * If a register is defined twice then the second definition is<BR>&nbsp;&nbsp;&nbsp;&nbsp; * used, so this can be used to define some generic registers and<BR>&nbsp;&nbsp;&nbsp;&nbsp; * then override them with implementation specific variations.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * At least one of the original and the second definition should<BR>&nbsp;&nbsp;&nbsp;&nbsp; * include ARM_CP_OVERRIDE in its type bits -- this is just a guard<BR>&nbsp;&nbsp;&nbsp;&nbsp; * against accidental use.<BR>&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp; * The state field defines whether the register is to be<BR>&nbsp;&nbsp;&nbsp;&nbsp; * visible in the AArch32 or AArch64 execution state. If the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * state is set to ARM_CP_STATE_BOTH then we synthesise a<BR>&nbsp;&nbsp;&nbsp;&nbsp; * reginfo structure for the AArch32 view, which sees the lower<BR>&nbsp;&nbsp;&nbsp;&nbsp; * 32 bits of the 64 bit register.<BR>&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Only registers visible in AArch64 may set r-&gt;opc0; opc0 cannot<BR>&nbsp;&nbsp;&nbsp;&nbsp; * be wildcarded. AArch64 registers are always considered to be 64<BR>&nbsp;&nbsp;&nbsp;&nbsp; * bits; the ARM_CP_64BIT* flag applies only to the AArch32 view of<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the register, if any.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int crm, opc1, opc2, state;<BR>&nbsp;&nbsp;&nbsp; int crmmin = (r-&gt;crm == CP_ANY) ? 0 : r-&gt;crm;<BR>&nbsp;&nbsp;&nbsp; int crmmax = (r-&gt;crm == CP_ANY) ? 15 : r-&gt;crm;<BR>&nbsp;&nbsp;&nbsp; int opc1min = (r-&gt;opc1 == CP_ANY) ? 0 : r-&gt;opc1;<BR>&nbsp;&nbsp;&nbsp; int opc1max = (r-&gt;opc1 == CP_ANY) ? 7 : r-&gt;opc1;<BR>&nbsp;&nbsp;&nbsp; int opc2min = (r-&gt;opc2 == CP_ANY) ? 0 : r-&gt;opc2;<BR>&nbsp;&nbsp;&nbsp; int opc2max = (r-&gt;opc2 == CP_ANY) ? 7 : r-&gt;opc2;<BR>&nbsp;&nbsp;&nbsp; /* 64 bit registers have only CRm and Opc1 fields */<BR>&nbsp;&nbsp;&nbsp; assert(!((r-&gt;type &amp; ARM_CP_64BIT) &amp;&amp; (r-&gt;opc2 || r-&gt;crn)));<BR>&nbsp;&nbsp;&nbsp; /* op0 only exists in the AArch64 encodings */<BR>&nbsp;&nbsp;&nbsp; assert((r-&gt;state != ARM_CP_STATE_AA32) || (r-&gt;opc0 == 0));<BR>&nbsp;&nbsp;&nbsp; /* AArch64 regs are all 64 bit so ARM_CP_64BIT is meaningless */<BR>&nbsp;&nbsp;&nbsp; assert((r-&gt;state != ARM_CP_STATE_AA64) || !(r-&gt;type &amp; ARM_CP_64BIT));<BR>&nbsp;&nbsp;&nbsp; /* The AArch64 pseudocode CheckSystemAccess() specifies that op1<BR>&nbsp;&nbsp;&nbsp;&nbsp; * encodes a minimum access level for the register. We roll this<BR>&nbsp;&nbsp;&nbsp;&nbsp; * runtime check into our general permission check code, so check<BR>&nbsp;&nbsp;&nbsp;&nbsp; * here that the reginfo's specified permissions are strict enough<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to encompass the generic architectural permission check.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (r-&gt;state != ARM_CP_STATE_AA32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mask = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (r-&gt;opc1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0: case 1: case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* min_EL EL1 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = PL1_RW;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* min_EL EL0 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = PL0_RW;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* min_EL EL2 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = PL2_RW;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 5:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* unallocated encoding, so not possible */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(false);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 6:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* min_EL EL3 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = PL3_RW;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 7:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* min_EL EL1, secure mode only (we don't check the latter) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = PL1_RW;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* broken reginfo with out-of-range opc1 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(false);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* assert our permissions are not too lax (stricter is fine) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert((r-&gt;access &amp; ~mask) == 0);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Check that the register definition has enough info to handle<BR>&nbsp;&nbsp;&nbsp;&nbsp; * reads and writes if they are permitted.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!(r-&gt;type &amp; (ARM_CP_SPECIAL|ARM_CP_CONST))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r-&gt;access &amp; PL3_R) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert((r-&gt;fieldoffset ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (r-&gt;bank_fieldoffsets[0] &amp;&amp; r-&gt;bank_fieldoffsets[1])) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r-&gt;readfn);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r-&gt;access &amp; PL3_W) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert((r-&gt;fieldoffset ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (r-&gt;bank_fieldoffsets[0] &amp;&amp; r-&gt;bank_fieldoffsets[1])) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r-&gt;writefn);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* Bad type field probably means missing sentinel at end of reg list */<BR>&nbsp;&nbsp;&nbsp; assert(cptype_valid(r-&gt;type));<BR>&nbsp;&nbsp;&nbsp; for (crm = crmmin; crm &lt;= crmmax; crm++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (opc1 = opc1min; opc1 &lt;= opc1max; opc1++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (opc2 = opc2min; opc2 &lt;= opc2max; opc2++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (state = ARM_CP_STATE_AA32;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state &lt;= ARM_CP_STATE_AA64; state++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r-&gt;state != state &amp;&amp; r-&gt;state != ARM_CP_STATE_BOTH) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (state == ARM_CP_STATE_AA32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Under AArch32 CP registers can be common<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * (same for secure and non-secure world) or banked.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (r-&gt;secure) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CP_SECSTATE_S:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CP_SECSTATE_NS:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add_cpreg_to_hashtable(cpu, r, opaque, state,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r-&gt;secure, crm, opc1, opc2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add_cpreg_to_hashtable(cpu, r, opaque, state,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARM_CP_SECSTATE_S,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; crm, opc1, opc2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add_cpreg_to_hashtable(cpu, r, opaque, state,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARM_CP_SECSTATE_NS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; crm, opc1, opc2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* AArch64 registers get mapped to non-secure instance<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * of AArch32 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add_cpreg_to_hashtable(cpu, r, opaque, state,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARM_CP_SECSTATE_NS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; crm, opc1, opc2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void define_arm_cp_regs_with_opaque(ARMCPU *cpu,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *regs, void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Define a whole list of registers */<BR>&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *r;<BR>&nbsp;&nbsp;&nbsp; for (r = regs; r-&gt;type != ARM_CP_SENTINEL; r++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg_with_opaque(cpu, r, opaque);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>const ARMCPRegInfo *get_arm_cp_reginfo(GHashTable *cpregs, uint32_t encoded_cp)<BR>{<BR>&nbsp;&nbsp;&nbsp; return g_hash_table_lookup(cpregs, &amp;encoded_cp);<BR>}</P>
<P>void arm_cp_write_ignore(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Helper coprocessor write function for write-ignore registers */<BR>}</P>
<P>uint64_t arm_cp_read_zero(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Helper coprocessor write function for read-as-zero registers */<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>void arm_cp_reset_ignore(CPUARMState *env, const ARMCPRegInfo *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Helper coprocessor reset function for do-nothing-on-reset registers */<BR>}</P>
<P>static int bad_mode_switch(CPUARMState *env, int mode, CPSRWriteType write_type)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Return true if it is not valid for us to switch to<BR>&nbsp;&nbsp;&nbsp;&nbsp; * this CPU mode (ie all the UNPREDICTABLE cases in<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the ARM ARM CPSRWriteByInstr pseudocode).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp; /* Changes to or from Hyp via MSR and CPS are illegal. */<BR>&nbsp;&nbsp;&nbsp; if (write_type == CPSRWriteByInstr &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((env-&gt;uncached_cpsr &amp; CPSR_M) == ARM_CPU_MODE_HYP ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode == ARM_CPU_MODE_HYP)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch (mode) {<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_USR:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_SYS:<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_SVC:<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_ABT:<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_UND:<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_IRQ:<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_FIQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note that we don't implement the IMPDEF NSACR.RFR which in v7<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * allows FIQ mode to be Secure-only. (In v8 this doesn't exist.)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If HCR.TGE is set then changes from Monitor to NS PL1 via MSR<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * and CPS are treated as illegal mode changes.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (write_type == CPSRWriteByInstr &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (env-&gt;cp15.hcr_el2 &amp; HCR_TGE) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (env-&gt;uncached_cpsr &amp; CPSR_M) == ARM_CPU_MODE_MON &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_HYP:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return !arm_feature(env, ARM_FEATURE_EL2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || arm_current_el(env) &lt; 2 || arm_is_secure(env);<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_MON:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return arm_current_el(env) &lt; 3;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P><FONT class=extract>uint32_t cpsr_read(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int ZF;<BR>&nbsp;&nbsp;&nbsp; ZF = (env-&gt;ZF == 0);<BR>&nbsp;&nbsp;&nbsp; return env-&gt;uncached_cpsr | (env-&gt;NF &amp; 0x80000000) | (ZF &lt;&lt; 30) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (env-&gt;CF &lt;&lt; 29) | ((env-&gt;VF &amp; 0x80000000) &gt;&gt; 3) | (env-&gt;QF &lt;&lt; 27)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (env-&gt;thumb &lt;&lt; 5) | ((env-&gt;condexec_bits &amp; 3) &lt;&lt; 25)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ((env-&gt;condexec_bits &amp; 0xfc) &lt;&lt; 8)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (env-&gt;GE &lt;&lt; 16) | (env-&gt;daif &amp; CPSR_AIF);<BR>}</FONT></P>
<P><FONT class=extract>void cpsr_write(CPUARMState *env, uint32_t val, uint32_t mask,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPSRWriteType write_type)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t changed_daif;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (mask &amp; CPSR_NZCV) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;ZF = (~val) &amp; CPSR_Z;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;NF = val;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;CF = (val &gt;&gt; 29) &amp; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;VF = (val &lt;&lt; 3) &amp; 0x80000000;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (mask &amp; CPSR_Q)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;QF = ((val &amp; CPSR_Q) != 0);<BR>&nbsp;&nbsp;&nbsp; if (mask &amp; CPSR_T)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;thumb = ((val &amp; CPSR_T) != 0);<BR>&nbsp;&nbsp;&nbsp; if (mask &amp; CPSR_IT_0_1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;condexec_bits &amp;= ~3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;condexec_bits |= (val &gt;&gt; 25) &amp; 3;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (mask &amp; CPSR_IT_2_7) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;condexec_bits &amp;= 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;condexec_bits |= (val &gt;&gt; 8) &amp; 0xfc;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (mask &amp; CPSR_GE) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;GE = (val &gt;&gt; 16) &amp; 0xf;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* In a V7 implementation that includes the security extensions but does<BR>&nbsp;&nbsp;&nbsp;&nbsp; * not include Virtualization Extensions the SCR.FW and SCR.AW bits control<BR>&nbsp;&nbsp;&nbsp;&nbsp; * whether non-secure software is allowed to change the CPSR_F and CPSR_A<BR>&nbsp;&nbsp;&nbsp;&nbsp; * bits respectively.<BR>&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp; * In a V8 implementation, it is permitted for privileged software to<BR>&nbsp;&nbsp;&nbsp;&nbsp; * change the CPSR A/F bits regardless of the SCR.AW/FW bits.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (write_type != CPSRWriteRaw &amp;&amp; !arm_feature(env, ARM_FEATURE_V8) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_feature(env, ARM_FEATURE_EL3) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_feature(env, ARM_FEATURE_EL2) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_is_secure(env)) {</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; changed_daif = (env-&gt;daif ^ val) &amp; mask;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (changed_daif &amp; CPSR_A) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Check to see if we are allowed to change the masking of async<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * abort exceptions from a non-secure state.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(env-&gt;cp15.scr_el3 &amp; SCR_AW)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_GUEST_ERROR,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Ignoring attempt to switch CPSR_A flag from "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "non-secure world with SCR.AW bit clear\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask &amp;= ~CPSR_A;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (changed_daif &amp; CPSR_F) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Check to see if we are allowed to change the masking of FIQ<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * exceptions from a non-secure state.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(env-&gt;cp15.scr_el3 &amp; SCR_FW)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_GUEST_ERROR,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Ignoring attempt to switch CPSR_F flag from "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "non-secure world with SCR.FW bit clear\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask &amp;= ~CPSR_F;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Check whether non-maskable FIQ (NMFI) support is enabled.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * If this bit is set software is not allowed to mask<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * FIQs, but is allowed to set CPSR_F to 0.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((A32_BANKED_CURRENT_REG_GET(env, sctlr) &amp; SCTLR_NMFI) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (val &amp; CPSR_F)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_GUEST_ERROR,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Ignoring attempt to enable CPSR_F flag "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "(non-maskable FIQ [NMFI] support enabled)\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask &amp;= ~CPSR_F;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; env-&gt;daif &amp;= ~(CPSR_AIF &amp; mask);<BR>&nbsp;&nbsp;&nbsp; env-&gt;daif |= val &amp; CPSR_AIF &amp; mask;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (write_type != CPSRWriteRaw &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((env-&gt;uncached_cpsr ^ val) &amp; mask &amp; CPSR_M)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((env-&gt;uncached_cpsr &amp; CPSR_M) == ARM_CPU_MODE_USR) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note that we can only get here in USR mode if this is a<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * gdb stub write; for this case we follow the architectural<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * behaviour for guest writes in USR mode of ignoring an attempt<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * to switch mode. (Those are caught by translate.c for writes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * triggered by guest instructions.)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask &amp;= ~CPSR_M;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (bad_mode_switch(env, val &amp; CPSR_M, write_type)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Attempt to switch to an invalid mode: this is UNPREDICTABLE in<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * v7, and has defined behaviour in v8:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; + leave CPSR.M untouched<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; + allow changes to the other CPSR fields<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; + set PSTATE.IL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * For user changes via the GDB stub, we don't set PSTATE.IL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * as this would be unnecessarily harsh for a user error.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask &amp;= ~CPSR_M;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (write_type != CPSRWriteByGDBStub &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= CPSR_IL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val |= CPSR_IL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch_mode(env, val &amp; CPSR_M);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; mask &amp;= ~CACHED_CPSR_BITS;<BR>&nbsp;&nbsp;&nbsp; env-&gt;uncached_cpsr = (env-&gt;uncached_cpsr &amp; ~mask) | (val &amp; mask);<BR>}</FONT></P>
<P><FONT class=extract>/* Sign/zero extend */<BR>uint32_t HELPER(sxtb16)(uint32_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t res;<BR>&nbsp;&nbsp;&nbsp; res = (uint16_t)(int8_t)x;<BR>&nbsp;&nbsp;&nbsp; res |= (uint32_t)(int8_t)(x &gt;&gt; 16) &lt;&lt; 16;<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</FONT></P>
<P><FONT class=extract>uint32_t HELPER(uxtb16)(uint32_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t res;<BR>&nbsp;&nbsp;&nbsp; res = (uint16_t)(uint8_t)x;<BR>&nbsp;&nbsp;&nbsp; res |= (uint32_t)(uint8_t)(x &gt;&gt; 16) &lt;&lt; 16;<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</FONT></P>
<P><FONT class=extract>uint32_t HELPER(clz)(uint32_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; return clz32(x);<BR>}</FONT></P>
<P><FONT class=extract>int32_t HELPER(sdiv)(int32_t num, int32_t den)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (den == 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; if (num == INT_MIN &amp;&amp; den == -1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return INT_MIN;<BR>&nbsp;&nbsp;&nbsp; return num / den;<BR>}</FONT></P>
<P><FONT class=extract>uint32_t HELPER(udiv)(uint32_t num, uint32_t den)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (den == 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; return num / den;<BR>}</FONT></P>
<P><FONT class=extract>uint32_t HELPER(rbit)(uint32_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; return revbit32(x);<BR>}</FONT></P>
<P><FONT class=extract>#if defined(CONFIG_USER_ONLY)</FONT></P>
<P><FONT class=extract>/* These should probably raise undefined insn exceptions.&nbsp; */<BR>void HELPER(v7m_msr)(CPUARMState *env, uint32_t reg, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; cpu_abort(CPU(cpu), "v7m_msr %d\n", reg);<BR>}</FONT></P>
<P><FONT class=extract>uint32_t HELPER(v7m_mrs)(CPUARMState *env, uint32_t reg)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; cpu_abort(CPU(cpu), "v7m_mrs %d\n", reg);<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</FONT></P>
<P><FONT class=extract>void switch_mode(CPUARMState *env, int mode)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (mode != ARM_CPU_MODE_USR) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_abort(CPU(cpu), "Tried to switch out of user mode\n");<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P>uint32_t arm_phys_excp_target_el(CPUState *cs, uint32_t excp_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t cur_el, bool secure)<BR>{<BR>&nbsp;&nbsp;&nbsp; return 1;<BR>}</P>
<P>void aarch64_sync_64_to_32(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>}</P>
<P>#else</P>
<P>void switch_mode(CPUARMState *env, int mode)<BR>{<BR>&nbsp;&nbsp;&nbsp; int old_mode;<BR>&nbsp;&nbsp;&nbsp; int i;</P>
<P>&nbsp;&nbsp;&nbsp; old_mode = env-&gt;uncached_cpsr &amp; CPSR_M;<BR>&nbsp;&nbsp;&nbsp; if (mode == old_mode)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</P>
<P>&nbsp;&nbsp;&nbsp; if (old_mode == ARM_CPU_MODE_FIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy (env-&gt;fiq_regs, env-&gt;regs + 8, 5 * sizeof(uint32_t));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy (env-&gt;regs + 8, env-&gt;usr_regs, 5 * sizeof(uint32_t));<BR>&nbsp;&nbsp;&nbsp; } else if (mode == ARM_CPU_MODE_FIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy (env-&gt;usr_regs, env-&gt;regs + 8, 5 * sizeof(uint32_t));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy (env-&gt;regs + 8, env-&gt;fiq_regs, 5 * sizeof(uint32_t));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; i = bank_number(old_mode);<BR>&nbsp;&nbsp;&nbsp; env-&gt;banked_r13[i] = env-&gt;regs[13];<BR>&nbsp;&nbsp;&nbsp; env-&gt;banked_r14[i] = env-&gt;regs[14];<BR>&nbsp;&nbsp;&nbsp; env-&gt;banked_spsr[i] = env-&gt;spsr;</P>
<P>&nbsp;&nbsp;&nbsp; i = bank_number(mode);<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = env-&gt;banked_r13[i];<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[14] = env-&gt;banked_r14[i];<BR>&nbsp;&nbsp;&nbsp; env-&gt;spsr = env-&gt;banked_spsr[i];<BR>}</P>
<P>/* Physical Interrupt Target EL Lookup Table<BR>&nbsp;*<BR>&nbsp;* [ From ARM ARM section G1.13.4 (Table G1-15) ]<BR>&nbsp;*<BR>&nbsp;* The below multi-dimensional table is used for looking up the target<BR>&nbsp;* exception level given numerous condition criteria.&nbsp; Specifically, the<BR>&nbsp;* target EL is based on SCR and HCR routing controls as well as the<BR>&nbsp;* currently executing EL and secure state.<BR>&nbsp;*<BR>&nbsp;*&nbsp;&nbsp;&nbsp; Dimensions:<BR>&nbsp;*&nbsp;&nbsp;&nbsp; target_el_table[2][2][2][2][2][4]<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; +--- Current EL<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; +------ Non-secure(0)/Secure(1)<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp; |&nbsp; +--------- HCR mask override<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp; +------------ SCR exec state control<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; +--------------- SCR mask override<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------------------ 32-bit(0)/64-bit(1) EL3<BR>&nbsp;*<BR>&nbsp;*&nbsp;&nbsp;&nbsp; The table values are as such:<BR>&nbsp;*&nbsp;&nbsp;&nbsp; 0-3 = EL0-EL3<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; -1 = Cannot occur<BR>&nbsp;*<BR>&nbsp;* The ARM ARM target EL table includes entries indicating that an "exception<BR>&nbsp;* is not taken".&nbsp; The two cases where this is applicable are:<BR>&nbsp;*&nbsp;&nbsp;&nbsp; 1) An exception is taken from EL3 but the SCR does not have the exception<BR>&nbsp;*&nbsp;&nbsp;&nbsp; routed to EL3.<BR>&nbsp;*&nbsp;&nbsp;&nbsp; 2) An exception is taken from EL2 but the HCR does not have the exception<BR>&nbsp;*&nbsp;&nbsp;&nbsp; routed to EL2.<BR>&nbsp;* In these two cases, the below table contain a target of EL1.&nbsp; This value is<BR>&nbsp;* returned as it is expected that the consumer of the table data will check<BR>&nbsp;* for "target EL &gt;= current EL" to ensure the exception is not taken.<BR>&nbsp;*<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCR&nbsp;&nbsp;&nbsp;&nbsp; HCR<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64&nbsp; EA&nbsp;&nbsp;&nbsp;&nbsp; AMO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; From<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BIT IRQ&nbsp;&nbsp;&nbsp;&nbsp; IMO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Non-secure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Secure<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EL3 FIQ&nbsp; RW FMO&nbsp;&nbsp; EL0 EL1 EL2 EL3&nbsp;&nbsp; EL0 EL1 EL2 EL3<BR>&nbsp;*/<BR>static const int8_t target_el_table[2][2][2][2][2][4] = {<BR>&nbsp;&nbsp;&nbsp; {{{{/* 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0 */{ 1,&nbsp; 1,&nbsp; 2, -1 },{ 3, -1, -1,&nbsp; 3 },},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {/* 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp; 1 */{ 2,&nbsp; 2,&nbsp; 2, -1 },{ 3, -1, -1,&nbsp; 3 },},},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{/* 0&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;&nbsp; 0 */{ 1,&nbsp; 1,&nbsp; 2, -1 },{ 3, -1, -1,&nbsp; 3 },},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {/* 0&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;&nbsp; 1 */{ 2,&nbsp; 2,&nbsp; 2, -1 },{ 3, -1, -1,&nbsp; 3 },},},},<BR>&nbsp;&nbsp;&nbsp;&nbsp; {{{/* 0&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp; 0 */{ 3,&nbsp; 3,&nbsp; 3, -1 },{ 3, -1, -1,&nbsp; 3 },},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {/* 0&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp; 1 */{ 3,&nbsp; 3,&nbsp; 3, -1 },{ 3, -1, -1,&nbsp; 3 },},},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{/* 0&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp; 0 */{ 3,&nbsp; 3,&nbsp; 3, -1 },{ 3, -1, -1,&nbsp; 3 },},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {/* 0&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp; 1 */{ 3,&nbsp; 3,&nbsp; 3, -1 },{ 3, -1, -1,&nbsp; 3 },},},},},<BR>&nbsp;&nbsp;&nbsp; {{{{/* 1&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp; 0 */{ 1,&nbsp; 1,&nbsp; 2, -1 },{ 1,&nbsp; 1, -1,&nbsp; 1 },},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {/* 1&nbsp;&nbsp; 0&nbsp;&nbsp; 0&nbsp;&nbsp; 1 */{ 2,&nbsp; 2,&nbsp; 2, -1 },{ 1,&nbsp; 1, -1,&nbsp; 1 },},},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{/* 1&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;&nbsp; 0 */{ 1,&nbsp; 1,&nbsp; 1, -1 },{ 1,&nbsp; 1, -1,&nbsp; 1 },},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {/* 1&nbsp;&nbsp; 0&nbsp;&nbsp; 1&nbsp;&nbsp; 1 */{ 2,&nbsp; 2,&nbsp; 2, -1 },{ 1,&nbsp; 1, -1,&nbsp; 1 },},},},<BR>&nbsp;&nbsp;&nbsp;&nbsp; {{{/* 1&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp; 0 */{ 3,&nbsp; 3,&nbsp; 3, -1 },{ 3,&nbsp; 3, -1,&nbsp; 3 },},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {/* 1&nbsp;&nbsp; 1&nbsp;&nbsp; 0&nbsp;&nbsp; 1 */{ 3,&nbsp; 3,&nbsp; 3, -1 },{ 3,&nbsp; 3, -1,&nbsp; 3 },},},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{/* 1&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp; 0 */{ 3,&nbsp; 3,&nbsp; 3, -1 },{ 3,&nbsp; 3, -1,&nbsp; 3 },},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {/* 1&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp; 1 */{ 3,&nbsp; 3,&nbsp; 3, -1 },{ 3,&nbsp; 3, -1,&nbsp; 3 },},},},},<BR>};</P>
<P>/*<BR>&nbsp;* Determine the target EL for physical exceptions<BR>&nbsp;*/<BR>uint32_t arm_phys_excp_target_el(CPUState *cs, uint32_t excp_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t cur_el, bool secure)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = cs-&gt;env_ptr;<BR>&nbsp;&nbsp;&nbsp; int rw;<BR>&nbsp;&nbsp;&nbsp; int scr;<BR>&nbsp;&nbsp;&nbsp; int hcr;<BR>&nbsp;&nbsp;&nbsp; int target_el;<BR>&nbsp;&nbsp;&nbsp; /* Is the highest EL AArch64? */<BR>&nbsp;&nbsp;&nbsp; int is64 = arm_feature(env, ARM_FEATURE_AARCH64);</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rw = ((env-&gt;cp15.scr_el3 &amp; SCR_RW) == SCR_RW);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Either EL2 is the highest EL (and so the EL2 register width<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * is given by is64); or there is no EL2 or EL3, in which case<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the value of 'rw' does not affect the table lookup anyway.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rw = is64;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch (excp_idx) {<BR>&nbsp;&nbsp;&nbsp; case EXCP_IRQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scr = ((env-&gt;cp15.scr_el3 &amp; SCR_IRQ) == SCR_IRQ);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcr = ((env-&gt;cp15.hcr_el2 &amp; HCR_IMO) == HCR_IMO);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EXCP_FIQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scr = ((env-&gt;cp15.scr_el3 &amp; SCR_FIQ) == SCR_FIQ);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcr = ((env-&gt;cp15.hcr_el2 &amp; HCR_FMO) == HCR_FMO);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scr = ((env-&gt;cp15.scr_el3 &amp; SCR_EA) == SCR_EA);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcr = ((env-&gt;cp15.hcr_el2 &amp; HCR_AMO) == HCR_AMO);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; };</P>
<P>&nbsp;&nbsp;&nbsp; /* If HCR.TGE is set then HCR is treated as being 1 */<BR>&nbsp;&nbsp;&nbsp; hcr |= ((env-&gt;cp15.hcr_el2 &amp; HCR_TGE) == HCR_TGE);</P>
<P>&nbsp;&nbsp;&nbsp; /* Perform a table-lookup for the target EL given the current state */<BR>&nbsp;&nbsp;&nbsp; target_el = target_el_table[is64][scr][rw][hcr][secure][cur_el];</P>
<P>&nbsp;&nbsp;&nbsp; assert(target_el &gt; 0);</P>
<P>&nbsp;&nbsp;&nbsp; return target_el;<BR>}</P>
<P><FONT class=extract>static void v7m_push(CPUARMState *env, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(arm_env_get_cpu(env));</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; env-&gt;regs[13] -= 4;<BR>&nbsp;&nbsp;&nbsp; stl_phys(cs-&gt;as, env-&gt;regs[13], val);<BR>}</FONT></P>
<P><FONT class=extract>static uint32_t v7m_pop(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(arm_env_get_cpu(env));<BR>&nbsp;&nbsp;&nbsp; uint32_t val;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; val = ldl_phys(cs-&gt;as, env-&gt;regs[13]);<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[13] += 4;<BR>&nbsp;&nbsp;&nbsp; return val;<BR>}</FONT></P>
<P><FONT class=extract>/* Switch to V7M main or process stack pointer.&nbsp; */<BR>static void switch_v7m_sp(CPUARMState *env, int process)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t tmp;<BR>&nbsp;&nbsp;&nbsp; if (env-&gt;v7m.current_sp != process) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = env-&gt;v7m.other_sp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;v7m.other_sp = env-&gt;regs[13];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = tmp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;v7m.current_sp = process;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static void do_v7m_exception_exit(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t type;<BR>&nbsp;&nbsp;&nbsp; uint32_t xpsr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; type = env-&gt;regs[15];<BR>&nbsp;&nbsp;&nbsp; if (env-&gt;v7m.exception != 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; armv7m_nvic_complete_irq(env-&gt;nvic, env-&gt;v7m.exception);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Switch to the target stack.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; switch_v7m_sp(env, (type &amp; 4) != 0);<BR>&nbsp;&nbsp;&nbsp; /* Pop registers.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[0] = v7m_pop(env);<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[1] = v7m_pop(env);<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[2] = v7m_pop(env);<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[3] = v7m_pop(env);<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[12] = v7m_pop(env);<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[14] = v7m_pop(env);<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[15] = v7m_pop(env);<BR>&nbsp;&nbsp;&nbsp; if (env-&gt;regs[15] &amp; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_GUEST_ERROR,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "M profile return from interrupt with misaligned "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "PC is UNPREDICTABLE\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Actual hardware seems to ignore the lsbit, and there are several<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * RTOSes out there which incorrectly assume the r15 in the stack<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * frame should be a Thumb-style "lsbit indicates ARM/Thumb" value.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[15] &amp;= ~1U;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; xpsr = v7m_pop(env);<BR>&nbsp;&nbsp;&nbsp; xpsr_write(env, xpsr, 0xfffffdff);<BR>&nbsp;&nbsp;&nbsp; /* Undo stack alignment.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (xpsr &amp; 0x200)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] |= 4;<BR>&nbsp;&nbsp;&nbsp; /* ??? The exception return type specifies Thread/Handler mode.&nbsp; However<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this is also implied by the xPSR value. Not sure what to do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if there is a mismatch.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; /* ??? Likewise for mismatches between the CONTROL register and the stack<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointer.&nbsp; */<BR>}</FONT></P>
<P><FONT class=extract>static void arm_log_exception(int idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (qemu_loglevel_mask(CPU_LOG_INT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *exc = NULL;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (idx &gt;= 0 &amp;&amp; idx &lt; ARRAY_SIZE(excnames)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exc = excnames[idx];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!exc) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exc = "unknown";<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_INT, "Taking exception %d [%s]\n", idx, exc);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>void arm_v7m_cpu_do_interrupt(CPUState *cs)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; uint32_t xpsr = xpsr_read(env);<BR>&nbsp;&nbsp;&nbsp; uint32_t lr;<BR>&nbsp;&nbsp;&nbsp; uint32_t addr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; arm_log_exception(cs-&gt;exception_index);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; lr = 0xfffffff1;<BR>&nbsp;&nbsp;&nbsp; if (env-&gt;v7m.current_sp)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lr |= 4;<BR>&nbsp;&nbsp;&nbsp; if (env-&gt;v7m.exception == 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lr |= 8;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* For exceptions we just mark as pending on the NVIC, and let that<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle it.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; /* TODO: Need to escalate if the current priority is higher than the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; one we're raising.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; switch (cs-&gt;exception_index) {<BR>&nbsp;&nbsp;&nbsp; case EXCP_UDEF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; armv7m_nvic_set_pending(env-&gt;nvic, ARMV7M_EXCP_USAGE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; case EXCP_SWI:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The PC already points to the next instruction.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; armv7m_nvic_set_pending(env-&gt;nvic, ARMV7M_EXCP_SVC);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; case EXCP_PREFETCH_ABORT:<BR>&nbsp;&nbsp;&nbsp; case EXCP_DATA_ABORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* TODO: if we implemented the MPU registers, this is where we<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * should set the MMFAR, etc from exception.fsr and exception.vaddress.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; armv7m_nvic_set_pending(env-&gt;nvic, ARMV7M_EXCP_MEM);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; case EXCP_BKPT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (semihosting_enabled()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nr = arm_lduw_code(env, env-&gt;regs[15], arm_sctlr_b(env)) &amp; 0xff;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nr == 0xab) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[15] += 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_INT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "...handling as semihosting call 0x%x\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[0] = do_arm_semihosting(env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; armv7m_nvic_set_pending(env-&gt;nvic, ARMV7M_EXCP_DEBUG);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; case EXCP_IRQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;v7m.exception = armv7m_nvic_acknowledge_irq(env-&gt;nvic);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EXCP_EXCEPTION_EXIT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do_v7m_exception_exit(env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_abort(cs, "Unhandled exception 0x%x\n", cs-&gt;exception_index);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; /* Never happens.&nbsp; Keep compiler happy.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Align stack pointer.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; /* ??? Should only do this if Configuration Control Register<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STACKALIGN bit is set.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (env-&gt;regs[13] &amp; 4) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] -= 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xpsr |= 0x200;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* Switch to the handler mode.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; v7m_push(env, xpsr);<BR>&nbsp;&nbsp;&nbsp; v7m_push(env, env-&gt;regs[15]);<BR>&nbsp;&nbsp;&nbsp; v7m_push(env, env-&gt;regs[14]);<BR>&nbsp;&nbsp;&nbsp; v7m_push(env, env-&gt;regs[12]);<BR>&nbsp;&nbsp;&nbsp; v7m_push(env, env-&gt;regs[3]);<BR>&nbsp;&nbsp;&nbsp; v7m_push(env, env-&gt;regs[2]);<BR>&nbsp;&nbsp;&nbsp; v7m_push(env, env-&gt;regs[1]);<BR>&nbsp;&nbsp;&nbsp; v7m_push(env, env-&gt;regs[0]);<BR>&nbsp;&nbsp;&nbsp; switch_v7m_sp(env, 0);<BR>&nbsp;&nbsp;&nbsp; /* Clear IT bits */<BR>&nbsp;&nbsp;&nbsp; env-&gt;condexec_bits = 0;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[14] = lr;<BR>&nbsp;&nbsp;&nbsp; addr = ldl_phys(cs-&gt;as, env-&gt;v7m.vecbase + env-&gt;v7m.exception * 4);<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[15] = addr &amp; 0xfffffffe;<BR>&nbsp;&nbsp;&nbsp; env-&gt;thumb = addr &amp; 1;<BR>}</FONT></P>
<P>/* Function used to synchronize QEMU's AArch64 register set with AArch32<BR>&nbsp;* register set.&nbsp; This is necessary when switching between AArch32 and AArch64<BR>&nbsp;* execution state.<BR>&nbsp;*/<BR>void aarch64_sync_32_to_64(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; uint32_t mode = env-&gt;uncached_cpsr &amp; CPSR_M;</P>
<P>&nbsp;&nbsp;&nbsp; /* We can blanket copy R[0:7] to X[0:7] */<BR>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 8; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[i] = env-&gt;regs[i];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Unless we are in FIQ mode, x8-x12 come from the user registers r8-r12.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Otherwise, they come from the banked user regs.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_FIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 8; i &lt; 13; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[i] = env-&gt;usr_regs[i - 8];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 8; i &lt; 13; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[i] = env-&gt;regs[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Registers x13-x23 are the various mode SP and FP registers. Registers<BR>&nbsp;&nbsp;&nbsp;&nbsp; * r13 and r14 are only copied if we are in that mode, otherwise we copy<BR>&nbsp;&nbsp;&nbsp;&nbsp; * from the mode banked register.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_USR || mode == ARM_CPU_MODE_SYS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[13] = env-&gt;regs[13];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[14] = env-&gt;regs[14];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[13] = env-&gt;banked_r13[bank_number(ARM_CPU_MODE_USR)];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* HYP is an exception in that it is copied from r14 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_HYP) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[14] = env-&gt;regs[14];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[14] = env-&gt;banked_r14[bank_number(ARM_CPU_MODE_USR)];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_HYP) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[15] = env-&gt;regs[13];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[15] = env-&gt;banked_r13[bank_number(ARM_CPU_MODE_HYP)];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_IRQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[16] = env-&gt;regs[14];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[17] = env-&gt;regs[13];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[16] = env-&gt;banked_r14[bank_number(ARM_CPU_MODE_IRQ)];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[17] = env-&gt;banked_r13[bank_number(ARM_CPU_MODE_IRQ)];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_SVC) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[18] = env-&gt;regs[14];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[19] = env-&gt;regs[13];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[18] = env-&gt;banked_r14[bank_number(ARM_CPU_MODE_SVC)];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[19] = env-&gt;banked_r13[bank_number(ARM_CPU_MODE_SVC)];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_ABT) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[20] = env-&gt;regs[14];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[21] = env-&gt;regs[13];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[20] = env-&gt;banked_r14[bank_number(ARM_CPU_MODE_ABT)];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[21] = env-&gt;banked_r13[bank_number(ARM_CPU_MODE_ABT)];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_UND) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[22] = env-&gt;regs[14];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[23] = env-&gt;regs[13];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[22] = env-&gt;banked_r14[bank_number(ARM_CPU_MODE_UND)];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[23] = env-&gt;banked_r13[bank_number(ARM_CPU_MODE_UND)];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Registers x24-x30 are mapped to r8-r14 in FIQ mode.&nbsp; If we are in FIQ<BR>&nbsp;&nbsp;&nbsp;&nbsp; * mode, then we can copy from r8-r14.&nbsp; Otherwise, we copy from the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * FIQ bank for r8-r14.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_FIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 24; i &lt; 31; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[i] = env-&gt;regs[i - 16];&nbsp;&nbsp; /* X[24:30] &lt;- R[8:14] */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 24; i &lt; 29; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[i] = env-&gt;fiq_regs[i - 24];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[29] = env-&gt;banked_r13[bank_number(ARM_CPU_MODE_FIQ)];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[30] = env-&gt;banked_r14[bank_number(ARM_CPU_MODE_FIQ)];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; env-&gt;pc = env-&gt;regs[15];<BR>}</P>
<P>/* Function used to synchronize QEMU's AArch32 register set with AArch64<BR>&nbsp;* register set.&nbsp; This is necessary when switching between AArch32 and AArch64<BR>&nbsp;* execution state.<BR>&nbsp;*/<BR>void aarch64_sync_64_to_32(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; uint32_t mode = env-&gt;uncached_cpsr &amp; CPSR_M;</P>
<P>&nbsp;&nbsp;&nbsp; /* We can blanket copy X[0:7] to R[0:7] */<BR>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 8; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[i] = env-&gt;xregs[i];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Unless we are in FIQ mode, r8-r12 come from the user registers x8-x12.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Otherwise, we copy x8-x12 into the banked user regs.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_FIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 8; i &lt; 13; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;usr_regs[i - 8] = env-&gt;xregs[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 8; i &lt; 13; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[i] = env-&gt;xregs[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Registers r13 &amp; r14 depend on the current mode.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * If we are in a given mode, we copy the corresponding x registers to r13<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and r14.&nbsp; Otherwise, we copy the x register to the banked r13 and r14<BR>&nbsp;&nbsp;&nbsp;&nbsp; * for the mode.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_USR || mode == ARM_CPU_MODE_SYS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = env-&gt;xregs[13];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[14] = env-&gt;xregs[14];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r13[bank_number(ARM_CPU_MODE_USR)] = env-&gt;xregs[13];</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* HYP is an exception in that it does not have its own banked r14 but<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * shares the USR r14<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_HYP) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[14] = env-&gt;xregs[14];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r14[bank_number(ARM_CPU_MODE_USR)] = env-&gt;xregs[14];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_HYP) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = env-&gt;xregs[15];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r13[bank_number(ARM_CPU_MODE_HYP)] = env-&gt;xregs[15];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_IRQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[14] = env-&gt;xregs[16];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = env-&gt;xregs[17];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r14[bank_number(ARM_CPU_MODE_IRQ)] = env-&gt;xregs[16];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r13[bank_number(ARM_CPU_MODE_IRQ)] = env-&gt;xregs[17];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_SVC) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[14] = env-&gt;xregs[18];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = env-&gt;xregs[19];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r14[bank_number(ARM_CPU_MODE_SVC)] = env-&gt;xregs[18];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r13[bank_number(ARM_CPU_MODE_SVC)] = env-&gt;xregs[19];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_ABT) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[14] = env-&gt;xregs[20];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = env-&gt;xregs[21];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r14[bank_number(ARM_CPU_MODE_ABT)] = env-&gt;xregs[20];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r13[bank_number(ARM_CPU_MODE_ABT)] = env-&gt;xregs[21];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_UND) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[14] = env-&gt;xregs[22];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = env-&gt;xregs[23];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r14[bank_number(ARM_CPU_MODE_UND)] = env-&gt;xregs[22];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r13[bank_number(ARM_CPU_MODE_UND)] = env-&gt;xregs[23];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Registers x24-x30 are mapped to r8-r14 in FIQ mode.&nbsp; If we are in FIQ<BR>&nbsp;&nbsp;&nbsp;&nbsp; * mode, then we can copy to r8-r14.&nbsp; Otherwise, we copy to the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * FIQ bank for r8-r14.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (mode == ARM_CPU_MODE_FIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 24; i &lt; 31; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[i - 16] = env-&gt;xregs[i];&nbsp;&nbsp; /* X[24:30] -&gt; R[8:14] */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 24; i &lt; 29; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;fiq_regs[i - 24] = env-&gt;xregs[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r13[bank_number(ARM_CPU_MODE_FIQ)] = env-&gt;xregs[29];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r14[bank_number(ARM_CPU_MODE_FIQ)] = env-&gt;xregs[30];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; env-&gt;regs[15] = env-&gt;pc;<BR>}</P>
<P>static void arm_cpu_do_interrupt_aarch32(CPUState *cs)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; uint32_t addr;<BR>&nbsp;&nbsp;&nbsp; uint32_t mask;<BR>&nbsp;&nbsp;&nbsp; int new_mode;<BR>&nbsp;&nbsp;&nbsp; uint32_t offset;<BR>&nbsp;&nbsp;&nbsp; uint32_t moe;</P>
<P>&nbsp;&nbsp;&nbsp; /* If this is a debug exception we must update the DBGDSCR.MOE bits */<BR>&nbsp;&nbsp;&nbsp; switch (env-&gt;exception.syndrome &gt;&gt; ARM_EL_EC_SHIFT) {<BR>&nbsp;&nbsp;&nbsp; case EC_BREAKPOINT:<BR>&nbsp;&nbsp;&nbsp; case EC_BREAKPOINT_SAME_EL:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; moe = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EC_WATCHPOINT:<BR>&nbsp;&nbsp;&nbsp; case EC_WATCHPOINT_SAME_EL:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; moe = 10;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EC_AA32_BKPT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; moe = 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EC_VECTORCATCH:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; moe = 5;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; moe = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (moe) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.mdscr_el1 = deposit64(env-&gt;cp15.mdscr_el1, 2, 4, moe);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* TODO: Vectored interrupt controller.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; switch (cs-&gt;exception_index) {<BR>&nbsp;&nbsp;&nbsp; case EXCP_UDEF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_mode = ARM_CPU_MODE_UND;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr = 0x04;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = CPSR_I;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;thumb)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EXCP_SWI:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_mode = ARM_CPU_MODE_SVC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr = 0x08;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = CPSR_I;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The PC already points to the next instruction.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EXCP_BKPT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.fsr = 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Fall through to prefetch abort.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; case EXCP_PREFETCH_ABORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A32_BANKED_CURRENT_REG_SET(env, ifsr, env-&gt;exception.fsr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A32_BANKED_CURRENT_REG_SET(env, ifar, env-&gt;exception.vaddress);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_INT, "...with IFSR 0x%x IFAR 0x%x\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.fsr, (uint32_t)env-&gt;exception.vaddress);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_mode = ARM_CPU_MODE_ABT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr = 0x0c;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = CPSR_A | CPSR_I;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EXCP_DATA_ABORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A32_BANKED_CURRENT_REG_SET(env, dfsr, env-&gt;exception.fsr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A32_BANKED_CURRENT_REG_SET(env, dfar, env-&gt;exception.vaddress);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_INT, "...with DFSR 0x%x DFAR 0x%x\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.fsr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (uint32_t)env-&gt;exception.vaddress);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_mode = ARM_CPU_MODE_ABT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr = 0x10;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = CPSR_A | CPSR_I;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 8;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EXCP_IRQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_mode = ARM_CPU_MODE_IRQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr = 0x18;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Disable IRQ and imprecise data aborts.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = CPSR_A | CPSR_I;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;cp15.scr_el3 &amp; SCR_IRQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* IRQ routed to monitor mode */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_mode = ARM_CPU_MODE_MON;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= CPSR_F;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EXCP_FIQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_mode = ARM_CPU_MODE_FIQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr = 0x1c;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Disable FIQ, IRQ and imprecise data aborts.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = CPSR_A | CPSR_I | CPSR_F;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;cp15.scr_el3 &amp; SCR_FIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* FIQ routed to monitor mode */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_mode = ARM_CPU_MODE_MON;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EXCP_SMC:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_mode = ARM_CPU_MODE_MON;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr = 0x08;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = CPSR_A | CPSR_I | CPSR_F;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_abort(cs, "Unhandled exception 0x%x\n", cs-&gt;exception_index);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; /* Never happens.&nbsp; Keep compiler happy.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (new_mode == ARM_CPU_MODE_MON) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr += env-&gt;cp15.mvbar;<BR>&nbsp;&nbsp;&nbsp; } else if (A32_BANKED_CURRENT_REG_GET(env, sctlr) &amp; SCTLR_V) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* High vectors. When enabled, base address cannot be remapped. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr += 0xffff0000;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ARM v7 architectures provide a vector base address register to remap<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the interrupt vector table.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * This register is only followed in non-monitor mode, and is banked.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Note: only bits 31:5 are valid.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr += A32_BANKED_CURRENT_REG_GET(env, vbar);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if ((env-&gt;uncached_cpsr &amp; CPSR_M) == ARM_CPU_MODE_MON) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.scr_el3 &amp;= ~SCR_NS;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch_mode (env, new_mode);<BR>&nbsp;&nbsp;&nbsp; /* For exceptions taken to AArch32 we must clear the SS bit in both<BR>&nbsp;&nbsp;&nbsp;&nbsp; * PSTATE and in the old-state value we save to SPSR_&lt;mode&gt;, so zero it now.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; env-&gt;uncached_cpsr &amp;= ~PSTATE_SS;<BR>&nbsp;&nbsp;&nbsp; env-&gt;spsr = cpsr_read(env);<BR>&nbsp;&nbsp;&nbsp; /* Clear IT bits.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; env-&gt;condexec_bits = 0;<BR>&nbsp;&nbsp;&nbsp; /* Switch to the new mode, and to the correct instruction set.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; env-&gt;uncached_cpsr = (env-&gt;uncached_cpsr &amp; ~CPSR_M) | new_mode;<BR>&nbsp;&nbsp;&nbsp; /* Set new mode endianness */<BR>&nbsp;&nbsp;&nbsp; env-&gt;uncached_cpsr &amp;= ~CPSR_E;<BR>&nbsp;&nbsp;&nbsp; if (env-&gt;cp15.sctlr_el[arm_current_el(env)] &amp; SCTLR_EE) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;uncached_cpsr |= ~CPSR_E;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; env-&gt;daif |= mask;<BR>&nbsp;&nbsp;&nbsp; /* this is a lie, as the was no c1_sys on V4T/V5, but who cares<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and we should just guard the thumb mode on V4 */<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V4T)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;thumb = (A32_BANKED_CURRENT_REG_GET(env, sctlr) &amp; SCTLR_TE) != 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[14] = env-&gt;regs[15] + offset;<BR>&nbsp;&nbsp;&nbsp; env-&gt;regs[15] = addr;<BR>}</P>
<P>/* Handle exception entry to a target EL which is using AArch64 */<BR>static void arm_cpu_do_interrupt_aarch64(CPUState *cs)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; unsigned int new_el = env-&gt;exception.target_el;<BR>&nbsp;&nbsp;&nbsp; target_ulong addr = env-&gt;cp15.vbar_el[new_el];<BR>&nbsp;&nbsp;&nbsp; unsigned int new_mode = aarch64_pstate_mode(new_el, true);</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) &lt; new_el) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Entry vector offset depends on whether the implemented EL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * immediately lower than the target level is using AArch32 or AArch64<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool is_aa64;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (new_el) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_aa64 = (env-&gt;cp15.scr_el3 &amp; SCR_RW) != 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_aa64 = (env-&gt;cp15.hcr_el2 &amp; HCR_RW) != 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_aa64 = is_a64(env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_aa64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr += 0x400;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr += 0x600;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else if (pstate_read(env) &amp; PSTATE_SP) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr += 0x200;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch (cs-&gt;exception_index) {<BR>&nbsp;&nbsp;&nbsp; case EXCP_PREFETCH_ABORT:<BR>&nbsp;&nbsp;&nbsp; case EXCP_DATA_ABORT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.far_el[new_el] = env-&gt;exception.vaddress;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_INT, "...with FAR 0x%" PRIx64 "\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.far_el[new_el]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* fall through */<BR>&nbsp;&nbsp;&nbsp; case EXCP_BKPT:<BR>&nbsp;&nbsp;&nbsp; case EXCP_UDEF:<BR>&nbsp;&nbsp;&nbsp; case EXCP_SWI:<BR>&nbsp;&nbsp;&nbsp; case EXCP_HVC:<BR>&nbsp;&nbsp;&nbsp; case EXCP_HYP_TRAP:<BR>&nbsp;&nbsp;&nbsp; case EXCP_SMC:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.esr_el[new_el] = env-&gt;exception.syndrome;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EXCP_IRQ:<BR>&nbsp;&nbsp;&nbsp; case EXCP_VIRQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr += 0x80;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EXCP_FIQ:<BR>&nbsp;&nbsp;&nbsp; case EXCP_VFIQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr += 0x100;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case EXCP_SEMIHOST:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_INT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "...handling as semihosting call 0x%" PRIx64 "\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[0] = do_arm_semihosting(env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_abort(cs, "Unhandled exception 0x%x\n", cs-&gt;exception_index);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (is_a64(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_spsr[aarch64_banked_spsr_index(new_el)] = pstate_read(env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aarch64_save_sp(env, arm_current_el(env));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;elr_el[new_el] = env-&gt;pc;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_spsr[aarch64_banked_spsr_index(new_el)] = cpsr_read(env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;elr_el[new_el] = env-&gt;regs[15];</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aarch64_sync_32_to_64(env);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;condexec_bits = 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_INT, "...with ELR 0x%" PRIx64 "\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;elr_el[new_el]);</P>
<P>&nbsp;&nbsp;&nbsp; pstate_write(env, PSTATE_DAIF | new_mode);<BR>&nbsp;&nbsp;&nbsp; env-&gt;aarch64 = 1;<BR>&nbsp;&nbsp;&nbsp; aarch64_restore_sp(env, new_el);</P>
<P>&nbsp;&nbsp;&nbsp; env-&gt;pc = addr;</P>
<P>&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_INT, "...to EL%d PC 0x%" PRIx64 " PSTATE 0x%x\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_el, env-&gt;pc, pstate_read(env));<BR>}</P>
<P>static inline bool check_for_semihosting(CPUState *cs)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Check whether this exception is a semihosting call; if so<BR>&nbsp;&nbsp;&nbsp;&nbsp; * then handle it and return true; otherwise return false.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; if (is_a64(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cs-&gt;exception_index == EXCP_SEMIHOST) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* This is always the 64-bit semihosting exception.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * The "is this usermode" and "is semihosting enabled"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * checks have been done at translate time.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_INT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "...handling as semihosting call 0x%" PRIx64 "\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;xregs[0] = do_arm_semihosting(env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t imm;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Only intercept calls from privileged modes, to provide some<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * semblance of security.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!semihosting_enabled() ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((env-&gt;uncached_cpsr &amp; CPSR_M) == ARM_CPU_MODE_USR)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (cs-&gt;exception_index) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case EXCP_SWI:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Check for semihosting interrupt.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;thumb) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imm = arm_lduw_code(env, env-&gt;regs[15] - 2, arm_sctlr_b(env))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; 0xff;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (imm == 0xab) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imm = arm_ldl_code(env, env-&gt;regs[15] - 4, arm_sctlr_b(env))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; 0xffffff;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (imm == 0x123456) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case EXCP_BKPT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* See if this is a semihosting syscall.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;thumb) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imm = arm_lduw_code(env, env-&gt;regs[15], arm_sctlr_b(env))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; 0xff;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (imm == 0xab) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[15] += 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_INT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "...handling as semihosting call 0x%x\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[0] = do_arm_semihosting(env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Handle a CPU exception for A and R profile CPUs.<BR>&nbsp;* Do any appropriate logging, handle PSCI calls, and then hand off<BR>&nbsp;* to the AArch64-entry or AArch32-entry function depending on the<BR>&nbsp;* target exception level's register width.<BR>&nbsp;*/<BR>void arm_cpu_do_interrupt(CPUState *cs)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; unsigned int new_el = env-&gt;exception.target_el;</P>
<P>&nbsp;&nbsp;&nbsp; assert(!IS_M(env));</P>
<P>&nbsp;&nbsp;&nbsp; arm_log_exception(cs-&gt;exception_index);<BR>&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_INT, "...from EL%d to EL%d\n", arm_current_el(env),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_el);<BR>&nbsp;&nbsp;&nbsp; if (qemu_loglevel_mask(CPU_LOG_INT)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !excp_is_internal(cs-&gt;exception_index)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_INT, "...with ESR %x/0x%" PRIx32 "\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.syndrome &gt;&gt; ARM_EL_EC_SHIFT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.syndrome);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_is_psci_call(cpu, cs-&gt;exception_index)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_handle_psci_call(cpu);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(CPU_LOG_INT, "...handled as PSCI call\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Semihosting semantics depend on the register width of the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * code that caused the exception, not the target exception level,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * so must be handled here.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (check_for_semihosting(cs)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; assert(!excp_is_internal(cs-&gt;exception_index));<BR>&nbsp;&nbsp;&nbsp; if (arm_el_is_aa64(env, new_el)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_cpu_do_interrupt_aarch64(cs);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_cpu_do_interrupt_aarch32(cs);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; arm_call_el_change_hook(cpu);</P>
<P>&nbsp;&nbsp;&nbsp; if (!kvm_enabled()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;interrupt_request |= CPU_INTERRUPT_EXITTB;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Return the exception level which controls this address translation regime */<BR>static inline uint32_t regime_el(CPUARMState *env, ARMMMUIdx mmu_idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; switch (mmu_idx) {<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S2NS:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1E2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1E3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1SE0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return arm_el_is_aa64(env, 3) ? 1 : 3;<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1SE1:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1NSE0:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1NSE1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Return true if this address translation regime is secure */<BR>static inline bool regime_is_secure(CPUARMState *env, ARMMMUIdx mmu_idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; switch (mmu_idx) {<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S12NSE0:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S12NSE1:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1NSE0:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1NSE1:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1E2:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S2NS:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1E3:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1SE0:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1SE1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Return the SCTLR value which controls this address translation regime */<BR>static inline uint32_t regime_sctlr(CPUARMState *env, ARMMMUIdx mmu_idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; return env-&gt;cp15.sctlr_el[regime_el(env, mmu_idx)];<BR>}</P>
<P>/* Return true if the specified stage of address translation is disabled */<BR>static inline bool regime_translation_disabled(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx mmu_idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (mmu_idx == ARMMMUIdx_S2NS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (env-&gt;cp15.hcr_el2 &amp; HCR_VM) == 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return (regime_sctlr(env, mmu_idx) &amp; SCTLR_M) == 0;<BR>}</P>
<P>static inline bool regime_translation_big_endian(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx mmu_idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (regime_sctlr(env, mmu_idx) &amp; SCTLR_EE) != 0;<BR>}</P>
<P>/* Return the TCR controlling this translation regime */<BR>static inline TCR *regime_tcr(CPUARMState *env, ARMMMUIdx mmu_idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (mmu_idx == ARMMMUIdx_S2NS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return &amp;env-&gt;cp15.vtcr_el2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return &amp;env-&gt;cp15.tcr_el[regime_el(env, mmu_idx)];<BR>}</P>
<P>/* Return the TTBR associated with this translation regime */<BR>static inline uint64_t regime_ttbr(CPUARMState *env, ARMMMUIdx mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ttbrn)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (mmu_idx == ARMMMUIdx_S2NS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;cp15.vttbr_el2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (ttbrn == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;cp15.ttbr0_el[regime_el(env, mmu_idx)];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;cp15.ttbr1_el[regime_el(env, mmu_idx)];<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Return true if the translation regime is using LPAE format page tables */<BR>static inline bool regime_using_lpae_format(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx mmu_idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; int el = regime_el(env, mmu_idx);<BR>&nbsp;&nbsp;&nbsp; if (el == 2 || arm_el_is_aa64(env, el)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_LPAE)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (regime_tcr(env, mmu_idx)-&gt;raw_tcr &amp; TTBCR_EAE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return false;<BR>}</P>
<P>/* Returns true if the stage 1 translation regime is using LPAE format page<BR>&nbsp;* tables. Used when raising alignment exceptions, whose FSR changes depending<BR>&nbsp;* on whether the long or short descriptor format is in use. */<BR>bool arm_s1_regime_using_lpae_format(CPUARMState *env, ARMMMUIdx mmu_idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (mmu_idx == ARMMMUIdx_S12NSE0 || mmu_idx == ARMMMUIdx_S12NSE1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx += ARMMMUIdx_S1NSE0;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return regime_using_lpae_format(env, mmu_idx);<BR>}</P>
<P>static inline bool regime_is_user(CPUARMState *env, ARMMMUIdx mmu_idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; switch (mmu_idx) {<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1SE0:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S1NSE0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S12NSE0:<BR>&nbsp;&nbsp;&nbsp; case ARMMMUIdx_S12NSE1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Translate section/page access permissions to page<BR>&nbsp;* R/W protection flags<BR>&nbsp;*<BR>&nbsp;* @env:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUARMState<BR>&nbsp;* @mmu_idx:&nbsp;&nbsp;&nbsp;&nbsp; MMU index indicating required translation regime<BR>&nbsp;* @ap:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The 3-bit access permissions (AP[2:0])<BR>&nbsp;* @domain_prot: The 2-bit domain access permissions<BR>&nbsp;*/<BR>static inline int ap_to_rw_prot(CPUARMState *env, ARMMMUIdx mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ap, int domain_prot)<BR>{<BR>&nbsp;&nbsp;&nbsp; bool is_user = regime_is_user(env, mmu_idx);</P>
<P>&nbsp;&nbsp;&nbsp; if (domain_prot == 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return PAGE_READ | PAGE_WRITE;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch (ap) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V7)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (regime_sctlr(env, mmu_idx) &amp; (SCTLR_S | SCTLR_R)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case SCTLR_S:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return is_user ? 0 : PAGE_READ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case SCTLR_R:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return PAGE_READ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return is_user ? 0 : PAGE_READ | PAGE_WRITE;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_user) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return PAGE_READ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return PAGE_READ | PAGE_WRITE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return PAGE_READ | PAGE_WRITE;<BR>&nbsp;&nbsp;&nbsp; case 4: /* Reserved.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; case 5:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return is_user ? 0 : PAGE_READ;<BR>&nbsp;&nbsp;&nbsp; case 6:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return PAGE_READ;<BR>&nbsp;&nbsp;&nbsp; case 7:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_V6K)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return PAGE_READ;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Translate section/page access permissions to page<BR>&nbsp;* R/W protection flags.<BR>&nbsp;*<BR>&nbsp;* @ap:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The 2-bit simple AP (AP[2:1])<BR>&nbsp;* @is_user: TRUE if accessing from PL0<BR>&nbsp;*/<BR>static inline int simple_ap_to_rw_prot_is_user(int ap, bool is_user)<BR>{<BR>&nbsp;&nbsp;&nbsp; switch (ap) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return is_user ? 0 : PAGE_READ | PAGE_WRITE;<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return PAGE_READ | PAGE_WRITE;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return is_user ? 0 : PAGE_READ;<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return PAGE_READ;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static inline int<BR>simple_ap_to_rw_prot(CPUARMState *env, ARMMMUIdx mmu_idx, int ap)<BR>{<BR>&nbsp;&nbsp;&nbsp; return simple_ap_to_rw_prot_is_user(ap, regime_is_user(env, mmu_idx));<BR>}</P>
<P>/* Translate S2 section/page access permissions to protection flags<BR>&nbsp;*<BR>&nbsp;* @env:&nbsp;&nbsp;&nbsp;&nbsp; CPUARMState<BR>&nbsp;* @s2ap:&nbsp;&nbsp;&nbsp; The 2-bit stage2 access permissions (S2AP)<BR>&nbsp;* @xn:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XN (execute-never) bit<BR>&nbsp;*/<BR>static int get_S2prot(CPUARMState *env, int s2ap, int xn)<BR>{<BR>&nbsp;&nbsp;&nbsp; int prot = 0;</P>
<P>&nbsp;&nbsp;&nbsp; if (s2ap &amp; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prot |= PAGE_READ;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (s2ap &amp; 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prot |= PAGE_WRITE;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (!xn) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_el_is_aa64(env, 2) || prot &amp; PAGE_READ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prot |= PAGE_EXEC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return prot;<BR>}</P>
<P>/* Translate section/page access permissions to protection flags<BR>&nbsp;*<BR>&nbsp;* @env:&nbsp;&nbsp;&nbsp;&nbsp; CPUARMState<BR>&nbsp;* @mmu_idx: MMU index indicating required translation regime<BR>&nbsp;* @is_aa64: TRUE if AArch64<BR>&nbsp;* @ap:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The 2-bit simple AP (AP[2:1])<BR>&nbsp;* @ns:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS (non-secure) bit<BR>&nbsp;* @xn:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XN (execute-never) bit<BR>&nbsp;* @pxn:&nbsp;&nbsp;&nbsp;&nbsp; PXN (privileged execute-never) bit<BR>&nbsp;*/<BR>static int get_S1prot(CPUARMState *env, ARMMMUIdx mmu_idx, bool is_aa64,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ap, int ns, int xn, int pxn)<BR>{<BR>&nbsp;&nbsp;&nbsp; bool is_user = regime_is_user(env, mmu_idx);<BR>&nbsp;&nbsp;&nbsp; int prot_rw, user_rw;<BR>&nbsp;&nbsp;&nbsp; bool have_wxn;<BR>&nbsp;&nbsp;&nbsp; int wxn = 0;</P>
<P>&nbsp;&nbsp;&nbsp; assert(mmu_idx != ARMMMUIdx_S2NS);</P>
<P>&nbsp;&nbsp;&nbsp; user_rw = simple_ap_to_rw_prot_is_user(ap, true);<BR>&nbsp;&nbsp;&nbsp; if (is_user) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prot_rw = user_rw;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prot_rw = simple_ap_to_rw_prot_is_user(ap, false);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (ns &amp;&amp; arm_is_secure(env) &amp;&amp; (env-&gt;cp15.scr_el3 &amp; SCR_SIF)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return prot_rw;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* TODO have_wxn should be replaced with<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; ARM_FEATURE_V8 || (ARM_FEATURE_V7 &amp;&amp; ARM_FEATURE_EL2)<BR>&nbsp;&nbsp;&nbsp;&nbsp; * when ARM_FEATURE_EL2 starts getting set. For now we assume all LPAE<BR>&nbsp;&nbsp;&nbsp;&nbsp; * compatible processors have EL2, which is required for [U]WXN.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; have_wxn = arm_feature(env, ARM_FEATURE_LPAE);</P>
<P>&nbsp;&nbsp;&nbsp; if (have_wxn) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wxn = regime_sctlr(env, mmu_idx) &amp; SCTLR_WXN;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (is_aa64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (regime_el(env, mmu_idx)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!is_user) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xn = pxn || (user_rw &amp; PAGE_WRITE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else if (arm_feature(env, ARM_FEATURE_V7)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (regime_el(env, mmu_idx)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_user) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xn = xn || !(user_rw &amp; PAGE_READ);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int uwxn = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (have_wxn) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uwxn = regime_sctlr(env, mmu_idx) &amp; SCTLR_UWXN;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xn = xn || !(prot_rw &amp; PAGE_READ) || pxn ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (uwxn &amp;&amp; (user_rw &amp; PAGE_WRITE));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xn = wxn = 0;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (xn || (wxn &amp;&amp; (prot_rw &amp; PAGE_WRITE))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return prot_rw;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return prot_rw | PAGE_EXEC;<BR>}</P>
<P>static bool get_level1_table_address(CPUARMState *env, ARMMMUIdx mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t *table, uint32_t address)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Note that we can only get here for an AArch32 PL0/PL1 lookup */<BR>&nbsp;&nbsp;&nbsp; TCR *tcr = regime_tcr(env, mmu_idx);</P>
<P>&nbsp;&nbsp;&nbsp; if (address &amp; tcr-&gt;mask) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tcr-&gt;raw_tcr &amp; TTBCR_PD1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Translation table walk disabled for TTBR1 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *table = regime_ttbr(env, mmu_idx, 1) &amp; 0xffffc000;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tcr-&gt;raw_tcr &amp; TTBCR_PD0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Translation table walk disabled for TTBR0 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *table = regime_ttbr(env, mmu_idx, 0) &amp; tcr-&gt;base_mask;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; *table |= (address &gt;&gt; 18) &amp; 0x3ffc;<BR>&nbsp;&nbsp;&nbsp; return true;<BR>}</P>
<P>/* Translate a S1 pagetable walk through S2 if needed.&nbsp; */<BR>static hwaddr S1_ptw_translate(CPUARMState *env, ARMMMUIdx mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwaddr addr, MemTxAttrs txattrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t *fsr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUFaultInfo *fi)<BR>{<BR>&nbsp;&nbsp;&nbsp; if ((mmu_idx == ARMMMUIdx_S1NSE0 || mmu_idx == ARMMMUIdx_S1NSE1) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !regime_translation_disabled(env, ARMMMUIdx_S2NS)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong s2size;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwaddr s2pa;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s2prot;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ret;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = get_phys_addr_lpae(env, addr, 0, ARMMMUIdx_S2NS, &amp;s2pa,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;txattrs, &amp;s2prot, &amp;s2size, fsr, fi);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ret) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi-&gt;s2addr = addr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi-&gt;stage2 = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi-&gt;s1ptw = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ~0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr = s2pa;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return addr;<BR>}</P>
<P>/* All loads done in the course of a page table walk go through here.<BR>&nbsp;* TODO: rather than ignoring errors from physical memory reads (which<BR>&nbsp;* are external aborts in ARM terminology) we should propagate this<BR>&nbsp;* error out so that we can turn it into a Data Abort if this walk<BR>&nbsp;* was being done for a CPU load/store or an address translation instruction<BR>&nbsp;* (but not if it was for a debug access).<BR>&nbsp;*/<BR>static uint32_t arm_ldl_ptw(CPUState *cs, hwaddr addr, bool is_secure,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx mmu_idx, uint32_t *fsr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUFaultInfo *fi)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; MemTxAttrs attrs = {};<BR>&nbsp;&nbsp;&nbsp; AddressSpace *as;</P>
<P>&nbsp;&nbsp;&nbsp; attrs.secure = is_secure;<BR>&nbsp;&nbsp;&nbsp; as = arm_addressspace(cs, attrs);<BR>&nbsp;&nbsp;&nbsp; addr = S1_ptw_translate(env, mmu_idx, addr, attrs, fsr, fi);<BR>&nbsp;&nbsp;&nbsp; if (fi-&gt;s1ptw) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (regime_translation_big_endian(env, mmu_idx)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return address_space_ldl_be(as, addr, attrs, NULL);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return address_space_ldl_le(as, addr, attrs, NULL);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static uint64_t arm_ldq_ptw(CPUState *cs, hwaddr addr, bool is_secure,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx mmu_idx, uint32_t *fsr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUFaultInfo *fi)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; MemTxAttrs attrs = {};<BR>&nbsp;&nbsp;&nbsp; AddressSpace *as;</P>
<P>&nbsp;&nbsp;&nbsp; attrs.secure = is_secure;<BR>&nbsp;&nbsp;&nbsp; as = arm_addressspace(cs, attrs);<BR>&nbsp;&nbsp;&nbsp; addr = S1_ptw_translate(env, mmu_idx, addr, attrs, fsr, fi);<BR>&nbsp;&nbsp;&nbsp; if (fi-&gt;s1ptw) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (regime_translation_big_endian(env, mmu_idx)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return address_space_ldq_be(as, addr, attrs, NULL);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return address_space_ldq_le(as, addr, attrs, NULL);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static bool get_phys_addr_v5(CPUARMState *env, uint32_t address,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access_type, ARMMMUIdx mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwaddr *phys_ptr, int *prot,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong *page_size, uint32_t *fsr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUFaultInfo *fi)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(arm_env_get_cpu(env));<BR>&nbsp;&nbsp;&nbsp; int code;<BR>&nbsp;&nbsp;&nbsp; uint32_t table;<BR>&nbsp;&nbsp;&nbsp; uint32_t desc;<BR>&nbsp;&nbsp;&nbsp; int type;<BR>&nbsp;&nbsp;&nbsp; int ap;<BR>&nbsp;&nbsp;&nbsp; int domain = 0;<BR>&nbsp;&nbsp;&nbsp; int domain_prot;<BR>&nbsp;&nbsp;&nbsp; hwaddr phys_addr;<BR>&nbsp;&nbsp;&nbsp; uint32_t dacr;</P>
<P>&nbsp;&nbsp;&nbsp; /* Pagetable walk.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; /* Lookup l1 descriptor.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!get_level1_table_address(env, mmu_idx, &amp;table, address)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Section translation fault if page walk is disabled by PD0 or PD1 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 5;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; desc = arm_ldl_ptw(cs, table, regime_is_secure(env, mmu_idx),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx, fsr, fi);<BR>&nbsp;&nbsp;&nbsp; type = (desc &amp; 3);<BR>&nbsp;&nbsp;&nbsp; domain = (desc &gt;&gt; 5) &amp; 0x0f;<BR>&nbsp;&nbsp;&nbsp; if (regime_el(env, mmu_idx) == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dacr = env-&gt;cp15.dacr_ns;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dacr = env-&gt;cp15.dacr_s;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; domain_prot = (dacr &gt;&gt; (domain * 2)) &amp; 3;<BR>&nbsp;&nbsp;&nbsp; if (type == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Section translation fault.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 5;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (domain_prot == 0 || domain_prot == 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (type == 2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 9; /* Section domain fault.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 11; /* Page domain fault.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (type == 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 1Mb section.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_addr = (desc &amp; 0xfff00000) | (address &amp; 0x000fffff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ap = (desc &gt;&gt; 10) &amp; 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 13;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *page_size = 1024 * 1024;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Lookup l2 entry.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (type == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Coarse pagetable.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table = (desc &amp; 0xfffffc00) | ((address &gt;&gt; 10) &amp; 0x3fc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Fine pagetable.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table = (desc &amp; 0xfffff000) | ((address &gt;&gt; 8) &amp; 0xffc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc = arm_ldl_ptw(cs, table, regime_is_secure(env, mmu_idx),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx, fsr, fi);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (desc &amp; 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0: /* Page translation fault.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 7;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1: /* 64k page.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_addr = (desc &amp; 0xffff0000) | (address &amp; 0xffff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ap = (desc &gt;&gt; (4 + ((address &gt;&gt; 13) &amp; 6))) &amp; 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *page_size = 0x10000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2: /* 4k page.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_addr = (desc &amp; 0xfffff000) | (address &amp; 0xfff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ap = (desc &gt;&gt; (4 + ((address &gt;&gt; 9) &amp; 6))) &amp; 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *page_size = 0x1000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3: /* 1k page, or ARMv6/XScale "extended small (4k) page" */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (type == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ARMv6/XScale extended small page format */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_XSCALE)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || arm_feature(env, ARM_FEATURE_V6)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_addr = (desc &amp; 0xfffff000) | (address &amp; 0xfff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *page_size = 0x1000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* UNPREDICTABLE in ARMv5; we choose to take a<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * page translation fault.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 7;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_addr = (desc &amp; 0xfffffc00) | (address &amp; 0x3ff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *page_size = 0x400;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ap = (desc &gt;&gt; 4) &amp; 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Never happens, but compiler isn't smart enough to tell.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 15;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; *prot = ap_to_rw_prot(env, mmu_idx, ap, domain_prot);<BR>&nbsp;&nbsp;&nbsp; *prot |= *prot ? PAGE_EXEC : 0;<BR>&nbsp;&nbsp;&nbsp; if (!(*prot &amp; (1 &lt;&lt; access_type))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Access permission fault.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; *phys_ptr = phys_addr;<BR>&nbsp;&nbsp;&nbsp; return false;<BR>do_fault:<BR>&nbsp;&nbsp;&nbsp; *fsr = code | (domain &lt;&lt; 4);<BR>&nbsp;&nbsp;&nbsp; return true;<BR>}</P>
<P>static bool get_phys_addr_v6(CPUARMState *env, uint32_t address,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access_type, ARMMMUIdx mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwaddr *phys_ptr, MemTxAttrs *attrs, int *prot,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong *page_size, uint32_t *fsr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUFaultInfo *fi)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(arm_env_get_cpu(env));<BR>&nbsp;&nbsp;&nbsp; int code;<BR>&nbsp;&nbsp;&nbsp; uint32_t table;<BR>&nbsp;&nbsp;&nbsp; uint32_t desc;<BR>&nbsp;&nbsp;&nbsp; uint32_t xn;<BR>&nbsp;&nbsp;&nbsp; uint32_t pxn = 0;<BR>&nbsp;&nbsp;&nbsp; int type;<BR>&nbsp;&nbsp;&nbsp; int ap;<BR>&nbsp;&nbsp;&nbsp; int domain = 0;<BR>&nbsp;&nbsp;&nbsp; int domain_prot;<BR>&nbsp;&nbsp;&nbsp; hwaddr phys_addr;<BR>&nbsp;&nbsp;&nbsp; uint32_t dacr;<BR>&nbsp;&nbsp;&nbsp; bool ns;</P>
<P>&nbsp;&nbsp;&nbsp; /* Pagetable walk.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; /* Lookup l1 descriptor.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!get_level1_table_address(env, mmu_idx, &amp;table, address)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Section translation fault if page walk is disabled by PD0 or PD1 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 5;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; desc = arm_ldl_ptw(cs, table, regime_is_secure(env, mmu_idx),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx, fsr, fi);<BR>&nbsp;&nbsp;&nbsp; type = (desc &amp; 3);<BR>&nbsp;&nbsp;&nbsp; if (type == 0 || (type == 3 &amp;&amp; !arm_feature(env, ARM_FEATURE_PXN))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Section translation fault, or attempt to use the encoding<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * which is Reserved on implementations without PXN.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 5;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if ((type == 1) || !(desc &amp; (1 &lt;&lt; 18))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Page or Section.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; domain = (desc &gt;&gt; 5) &amp; 0x0f;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (regime_el(env, mmu_idx) == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dacr = env-&gt;cp15.dacr_ns;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dacr = env-&gt;cp15.dacr_s;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; domain_prot = (dacr &gt;&gt; (domain * 2)) &amp; 3;<BR>&nbsp;&nbsp;&nbsp; if (domain_prot == 0 || domain_prot == 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (type != 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 9; /* Section domain fault.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 11; /* Page domain fault.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (type != 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (desc &amp; (1 &lt;&lt; 18)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Supersection.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_addr = (desc &amp; 0xff000000) | (address &amp; 0x00ffffff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_addr |= (uint64_t)extract32(desc, 20, 4) &lt;&lt; 32;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_addr |= (uint64_t)extract32(desc, 5, 4) &lt;&lt; 36;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *page_size = 0x1000000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Section.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_addr = (desc &amp; 0xfff00000) | (address &amp; 0x000fffff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *page_size = 0x100000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ap = ((desc &gt;&gt; 10) &amp; 3) | ((desc &gt;&gt; 13) &amp; 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xn = desc &amp; (1 &lt;&lt; 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pxn = desc &amp; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 13;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ns = extract32(desc, 19, 1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_PXN)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pxn = (desc &gt;&gt; 2) &amp; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ns = extract32(desc, 3, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Lookup l2 entry.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table = (desc &amp; 0xfffffc00) | ((address &gt;&gt; 10) &amp; 0x3fc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc = arm_ldl_ptw(cs, table, regime_is_secure(env, mmu_idx),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx, fsr, fi);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ap = ((desc &gt;&gt; 4) &amp; 3) | ((desc &gt;&gt; 7) &amp; 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (desc &amp; 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0: /* Page translation fault.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 7;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1: /* 64k page.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_addr = (desc &amp; 0xffff0000) | (address &amp; 0xffff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xn = desc &amp; (1 &lt;&lt; 15);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *page_size = 0x10000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2: case 3: /* 4k page.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_addr = (desc &amp; 0xfffff000) | (address &amp; 0xfff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xn = desc &amp; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *page_size = 0x1000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Never happens, but compiler isn't smart enough to tell.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = 15;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (domain_prot == 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pxn &amp;&amp; !regime_is_user(env, mmu_idx)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xn = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (xn &amp;&amp; access_type == 2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V6K) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (regime_sctlr(env, mmu_idx) &amp; SCTLR_AFE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The simplified model uses AP[0] as an access control bit.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((ap &amp; 1) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Access flag fault.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code = (code == 15) ? 6 : 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot = simple_ap_to_rw_prot(env, mmu_idx, ap &gt;&gt; 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot = ap_to_rw_prot(env, mmu_idx, ap, domain_prot);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*prot &amp;&amp; !xn) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot |= PAGE_EXEC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(*prot &amp; (1 &lt;&lt; access_type))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Access permission fault.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (ns) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The NS bit will (as required by the architecture) have no effect if<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the CPU doesn't support TZ or this is a non-secure translation<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * regime, because the attribute will already be non-secure.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrs-&gt;secure = false;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; *phys_ptr = phys_addr;<BR>&nbsp;&nbsp;&nbsp; return false;<BR>do_fault:<BR>&nbsp;&nbsp;&nbsp; *fsr = code | (domain &lt;&lt; 4);<BR>&nbsp;&nbsp;&nbsp; return true;<BR>}</P>
<P>/* Fault type for long-descriptor MMU fault reporting; this corresponds<BR>&nbsp;* to bits [5..2] in the STATUS field in long-format DFSR/IFSR.<BR>&nbsp;*/<BR>typedef enum {<BR>&nbsp;&nbsp;&nbsp; translation_fault = 1,<BR>&nbsp;&nbsp;&nbsp; access_fault = 2,<BR>&nbsp;&nbsp;&nbsp; permission_fault = 3,<BR>} MMUFaultType;</P>
<P>/*<BR>&nbsp;* check_s2_mmu_setup<BR>&nbsp;* @cpu:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPU<BR>&nbsp;* @is_aa64:&nbsp;&nbsp;&nbsp; True if the translation regime is in AArch64 state<BR>&nbsp;* @startlevel: Suggested starting level<BR>&nbsp;* @inputsize:&nbsp; Bitsize of IPAs<BR>&nbsp;* @stride:&nbsp;&nbsp;&nbsp;&nbsp; Page-table stride (See the ARM ARM)<BR>&nbsp;*<BR>&nbsp;* Returns true if the suggested S2 translation parameters are OK and<BR>&nbsp;* false otherwise.<BR>&nbsp;*/<BR>static bool check_s2_mmu_setup(ARMCPU *cpu, bool is_aa64, int level,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int inputsize, int stride)<BR>{<BR>&nbsp;&nbsp;&nbsp; const int grainsize = stride + 3;<BR>&nbsp;&nbsp;&nbsp; int startsizecheck;</P>
<P>&nbsp;&nbsp;&nbsp; /* Negative levels are never allowed.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (level &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; startsizecheck = inputsize - ((3 - level) * stride + grainsize);<BR>&nbsp;&nbsp;&nbsp; if (startsizecheck &lt; 1 || startsizecheck &gt; stride + 4) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (is_aa64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int pamax = arm_pamax(cpu);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (stride) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 13: /* 64KB Pages.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (level == 0 || (level == 1 &amp;&amp; pamax &lt;= 42)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 11: /* 16KB Pages.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (level == 0 || (level == 1 &amp;&amp; pamax &lt;= 40)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 9: /* 4KB Pages.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (level == 0 &amp;&amp; pamax &lt;= 42) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Inputsize checks.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (inputsize &gt; pamax &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (arm_el_is_aa64(env, 1) || inputsize &gt; 40)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* This is CONSTRAINED UNPREDICTABLE and we choose to fault.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* AArch32 only supports 4KB pages. Assert on that.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(stride == 9);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (level == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return true;<BR>}</P>
<P>static bool get_phys_addr_lpae(CPUARMState *env, target_ulong address,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access_type, ARMMMUIdx mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwaddr *phys_ptr, MemTxAttrs *txattrs, int *prot,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong *page_size_ptr, uint32_t *fsr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUFaultInfo *fi)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);<BR>&nbsp;&nbsp;&nbsp; /* Read an LPAE long-descriptor translation table. */<BR>&nbsp;&nbsp;&nbsp; MMUFaultType fault_type = translation_fault;<BR>&nbsp;&nbsp;&nbsp; uint32_t level;<BR>&nbsp;&nbsp;&nbsp; uint32_t epd = 0;<BR>&nbsp;&nbsp;&nbsp; int32_t t0sz, t1sz;<BR>&nbsp;&nbsp;&nbsp; uint32_t tg;<BR>&nbsp;&nbsp;&nbsp; uint64_t ttbr;<BR>&nbsp;&nbsp;&nbsp; int ttbr_select;<BR>&nbsp;&nbsp;&nbsp; hwaddr descaddr, indexmask, indexmask_grainsize;<BR>&nbsp;&nbsp;&nbsp; uint32_t tableattrs;<BR>&nbsp;&nbsp;&nbsp; target_ulong page_size;<BR>&nbsp;&nbsp;&nbsp; uint32_t attrs;<BR>&nbsp;&nbsp;&nbsp; int32_t stride = 9;<BR>&nbsp;&nbsp;&nbsp; int32_t addrsize;<BR>&nbsp;&nbsp;&nbsp; int inputsize;<BR>&nbsp;&nbsp;&nbsp; int32_t tbi = 0;<BR>&nbsp;&nbsp;&nbsp; TCR *tcr = regime_tcr(env, mmu_idx);<BR>&nbsp;&nbsp;&nbsp; int ap, ns, xn, pxn;<BR>&nbsp;&nbsp;&nbsp; uint32_t el = regime_el(env, mmu_idx);<BR>&nbsp;&nbsp;&nbsp; bool ttbr1_valid = true;<BR>&nbsp;&nbsp;&nbsp; uint64_t descaddrmask;<BR>&nbsp;&nbsp;&nbsp; bool aarch64 = arm_el_is_aa64(env, el);</P>
<P>&nbsp;&nbsp;&nbsp; /* TODO:<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This code does not handle the different format TCR for VTCR_EL2.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This code also does not support shareability levels.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Attribute and permission bit handling should also be checked when adding<BR>&nbsp;&nbsp;&nbsp;&nbsp; * support for those page table walks.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (aarch64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; level = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addrsize = 64;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (el &gt; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mmu_idx != ARMMMUIdx_S2NS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tbi = extract64(tcr-&gt;raw_tcr, 20, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extract64(address, 55, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tbi = extract64(tcr-&gt;raw_tcr, 38, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tbi = extract64(tcr-&gt;raw_tcr, 37, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tbi *= 8;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If we are in 64-bit EL2 or EL3 then there is no TTBR1, so mark it<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * invalid.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (el &gt; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ttbr1_valid = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; level = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addrsize = 32;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* There is no TTBR1 for EL2 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (el == 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ttbr1_valid = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Determine whether this address is in the region controlled by<BR>&nbsp;&nbsp;&nbsp;&nbsp; * TTBR0 or TTBR1 (or if it is in neither region and should fault).<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This is a Non-secure PL0/1 stage 1 translation, so controlled by<BR>&nbsp;&nbsp;&nbsp;&nbsp; * TTBCR/TTBR0/TTBR1 in accordance with ARM ARM DDI0406C table B-32:<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (aarch64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* AArch64 translation.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0sz = extract32(tcr-&gt;raw_tcr, 0, 6);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0sz = MIN(t0sz, 39);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0sz = MAX(t0sz, 16);<BR>&nbsp;&nbsp;&nbsp; } else if (mmu_idx != ARMMMUIdx_S2NS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* AArch32 stage 1 translation.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0sz = extract32(tcr-&gt;raw_tcr, 0, 3);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* AArch32 stage 2 translation.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool sext = extract32(tcr-&gt;raw_tcr, 4, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool sign = extract32(tcr-&gt;raw_tcr, 3, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Address size is 40-bit for a stage 2 translation,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * and t0sz can be negative (from -8 to 7),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * so we need to adjust it to use the TTBR selecting logic below.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addrsize = 40;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t0sz = sextract32(tcr-&gt;raw_tcr, 0, 4) + 8;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If the sign-extend bit is not the same as t0sz[3], the result<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * is unpredictable. Flag this as a guest error.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sign != sext) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_GUEST_ERROR,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "AArch32: VTCR.S / VTCR.T0SZ[3] missmatch\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; t1sz = extract32(tcr-&gt;raw_tcr, 16, 6);<BR>&nbsp;&nbsp;&nbsp; if (aarch64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1sz = MIN(t1sz, 39);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1sz = MAX(t1sz, 16);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (t0sz &amp;&amp; !extract64(address, addrsize - t0sz, t0sz - tbi)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* there is a ttbr0 region and we are in it (high bits all zero) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ttbr_select = 0;<BR>&nbsp;&nbsp;&nbsp; } else if (ttbr1_valid &amp;&amp; t1sz &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !extract64(~address, addrsize - t1sz, t1sz - tbi)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* there is a ttbr1 region and we are in it (high bits all one) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ttbr_select = 1;<BR>&nbsp;&nbsp;&nbsp; } else if (!t0sz) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ttbr0 region is "everything not in the ttbr1 region" */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ttbr_select = 0;<BR>&nbsp;&nbsp;&nbsp; } else if (!t1sz &amp;&amp; ttbr1_valid) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ttbr1 region is "everything not in the ttbr0 region" */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ttbr_select = 1;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* in the gap between the two regions, this is a Translation fault */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fault_type = translation_fault;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Note that QEMU ignores shareability and cacheability attributes,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * so we don't need to do anything with the SH, ORGN, IRGN fields<BR>&nbsp;&nbsp;&nbsp;&nbsp; * in the TTBCR.&nbsp; Similarly, TTBCR:A1 selects whether we get the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * ASID from TTBR0 or TTBR1, but QEMU's TLB doesn't currently<BR>&nbsp;&nbsp;&nbsp;&nbsp; * implement any ASID-like capability so we can ignore it (instead<BR>&nbsp;&nbsp;&nbsp;&nbsp; * we will always flush the TLB any time the ASID is changed).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (ttbr_select == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ttbr = regime_ttbr(env, mmu_idx, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (el &lt; 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; epd = extract32(tcr-&gt;raw_tcr, 7, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputsize = addrsize - t0sz;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tg = extract32(tcr-&gt;raw_tcr, 14, 2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tg == 1) { /* 64KB pages */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stride = 13;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tg == 2) { /* 16KB pages */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stride = 11;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We should only be here if TTBR1 is valid */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(ttbr1_valid);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ttbr = regime_ttbr(env, mmu_idx, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; epd = extract32(tcr-&gt;raw_tcr, 23, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputsize = addrsize - t1sz;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tg = extract32(tcr-&gt;raw_tcr, 30, 2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tg == 3)&nbsp; { /* 64KB pages */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stride = 13;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tg == 1) { /* 16KB pages */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stride = 11;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Here we should have set up all the parameters for the translation:<BR>&nbsp;&nbsp;&nbsp;&nbsp; * inputsize, ttbr, epd, stride, tbi<BR>&nbsp;&nbsp;&nbsp;&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp; if (epd) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Translation table walk disabled =&gt; Translation fault on TLB miss<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Note: This is always 0 on 64-bit EL2 and EL3.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (mmu_idx != ARMMMUIdx_S2NS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The starting level depends on the virtual address size (which can<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * be up to 48 bits) and the translation granule size. It indicates<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the number of strides (stride bits at a time) needed to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * consume the bits of the input address. In the pseudocode this is:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; level = 4 - RoundUp((inputsize - grainsize) / stride)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * where their 'inputsize' is our 'inputsize', 'grainsize' is<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * our 'stride + 3' and 'stride' is our 'stride'.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Applying the usual "rounded up m/n is (m+n-1)/n" and simplifying:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * = 4 - (inputsize - stride - 3 + stride - 1) / stride<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * = 4 - (inputsize - 4) / stride;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; level = 4 - (inputsize - 4) / stride;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* For stage 2 translations the starting level is specified by the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * VTCR_EL2.SL0 field (whose interpretation depends on the page size)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t sl0 = extract32(tcr-&gt;raw_tcr, 6, 2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t startlevel;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool ok;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!aarch64 || stride == 9) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* AArch32 or 4KB pages */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; startlevel = 2 - sl0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 16KB or 64KB pages */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; startlevel = 3 - sl0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Check that the starting level is valid. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok = check_s2_mmu_setup(cpu, aarch64, startlevel,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inputsize, stride);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!ok) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fault_type = translation_fault;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; level = startlevel;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; indexmask_grainsize = (1ULL &lt;&lt; (stride + 3)) - 1;<BR>&nbsp;&nbsp;&nbsp; indexmask = (1ULL &lt;&lt; (inputsize - (stride * (4 - level)))) - 1;</P>
<P>&nbsp;&nbsp;&nbsp; /* Now we can extract the actual base address from the TTBR */<BR>&nbsp;&nbsp;&nbsp; descaddr = extract64(ttbr, 0, 48);<BR>&nbsp;&nbsp;&nbsp; descaddr &amp;= ~indexmask;</P>
<P>&nbsp;&nbsp;&nbsp; /* The address field in the descriptor goes up to bit 39 for ARMv7<BR>&nbsp;&nbsp;&nbsp;&nbsp; * but up to bit 47 for ARMv8, but we use the descaddrmask<BR>&nbsp;&nbsp;&nbsp;&nbsp; * up to bit 39 for AArch32, because we don't need other bits in that case<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to construct next descriptor address (anyway they should be all zeroes).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; descaddrmask = ((1ull &lt;&lt; (aarch64 ? 48 : 40)) - 1) &amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~indexmask_grainsize;</P>
<P>&nbsp;&nbsp;&nbsp; /* Secure accesses start with the page table in secure memory and<BR>&nbsp;&nbsp;&nbsp;&nbsp; * can be downgraded to non-secure at any step. Non-secure accesses<BR>&nbsp;&nbsp;&nbsp;&nbsp; * remain non-secure. We implement this by just ORing in the NSTable/NS<BR>&nbsp;&nbsp;&nbsp;&nbsp; * bits at each step.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tableattrs = regime_is_secure(env, mmu_idx) ? 0 : (1 &lt;&lt; 4);<BR>&nbsp;&nbsp;&nbsp; for (;;) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t descriptor;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool nstable;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; descaddr |= (address &gt;&gt; (stride * (4 - level))) &amp; indexmask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; descaddr &amp;= ~7ULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nstable = extract32(tableattrs, 4, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; descriptor = arm_ldq_ptw(cs, descaddr, !nstable, mmu_idx, fsr, fi);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fi-&gt;s1ptw) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(descriptor &amp; 1) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (!(descriptor &amp; 2) &amp;&amp; (level == 3))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Invalid, or the Reserved level 3 encoding */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; descaddr = descriptor &amp; descaddrmask;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((descriptor &amp; 2) &amp;&amp; (level &lt; 3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Table entry. The top five bits are attributes which&nbsp; may<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * propagate down through lower levels of the table (and<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * which are all arranged so that 0 means "no effect", so<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * we can gather them up by ORing in the bits at each level).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tableattrs |= extract64(descriptor, 59, 5);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; level++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indexmask = indexmask_grainsize;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Block entry at level 1 or 2, or page entry at level 3.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * These are basically the same thing, although the number<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * of bits we pull in from the vaddr varies.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; page_size = (1ULL &lt;&lt; ((stride * (4 - level)) + 3));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; descaddr |= (address &amp; (page_size - 1));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Extract attributes from the descriptor */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrs = extract64(descriptor, 2, 10)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (extract64(descriptor, 52, 12) &lt;&lt; 10);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mmu_idx == ARMMMUIdx_S2NS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Stage 2 table descriptors do not include any attribute fields */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Merge in attributes from table descriptors */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrs |= extract32(tableattrs, 0, 2) &lt;&lt; 11; /* XN, PXN */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrs |= extract32(tableattrs, 3, 1) &lt;&lt; 5; /* APTable[1] =&gt; AP[2] */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The sense of AP[1] vs APTable[0] is reversed, as APTable[0] == 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * means "force PL1 access only", which means forcing AP[1] to 0.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extract32(tableattrs, 2, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrs &amp;= ~(1 &lt;&lt; 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrs |= nstable &lt;&lt; 3; /* NS */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* Here descaddr is the final physical address, and attributes<BR>&nbsp;&nbsp;&nbsp;&nbsp; * are all in attrs.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; fault_type = access_fault;<BR>&nbsp;&nbsp;&nbsp; if ((attrs &amp; (1 &lt;&lt; 8)) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Access flag */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; ap = extract32(attrs, 4, 2);<BR>&nbsp;&nbsp;&nbsp; xn = extract32(attrs, 12, 1);</P>
<P>&nbsp;&nbsp;&nbsp; if (mmu_idx == ARMMMUIdx_S2NS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ns = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot = get_S2prot(env, ap, xn);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ns = extract32(attrs, 3, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pxn = extract32(attrs, 11, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot = get_S1prot(env, mmu_idx, aarch64, ap, ns, xn, pxn);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; fault_type = permission_fault;<BR>&nbsp;&nbsp;&nbsp; if (!(*prot &amp; (1 &lt;&lt; access_type))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto do_fault;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (ns) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The NS bit will (as required by the architecture) have no effect if<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the CPU doesn't support TZ or this is a non-secure translation<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * regime, because the attribute will already be non-secure.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; txattrs-&gt;secure = false;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; *phys_ptr = descaddr;<BR>&nbsp;&nbsp;&nbsp; *page_size_ptr = page_size;<BR>&nbsp;&nbsp;&nbsp; return false;</P>
<P>do_fault:<BR>&nbsp;&nbsp;&nbsp; /* Long-descriptor format IFSR/DFSR value */<BR>&nbsp;&nbsp;&nbsp; *fsr = (1 &lt;&lt; 9) | (fault_type &lt;&lt; 2) | level;<BR>&nbsp;&nbsp;&nbsp; /* Tag the error as S2 for failed S1 PTW at S2 or ordinary S2.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; fi-&gt;stage2 = fi-&gt;s1ptw || (mmu_idx == ARMMMUIdx_S2NS);<BR>&nbsp;&nbsp;&nbsp; return true;<BR>}</P>
<P>static inline void get_phys_addr_pmsav7_default(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUIdx mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t address, int *prot)<BR>{<BR>&nbsp;&nbsp;&nbsp; *prot = PAGE_READ | PAGE_WRITE;<BR>&nbsp;&nbsp;&nbsp; switch (address) {<BR>&nbsp;&nbsp;&nbsp; case 0xF0000000 ... 0xFFFFFFFF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (regime_sctlr(env, mmu_idx) &amp; SCTLR_V) { /* hivecs execing is ok */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot |= PAGE_EXEC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 0x00000000 ... 0x7FFFFFFF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot |= PAGE_EXEC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>}</P>
<P>static bool get_phys_addr_pmsav7(CPUARMState *env, uint32_t address,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access_type, ARMMMUIdx mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwaddr *phys_ptr, int *prot, uint32_t *fsr)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; int n;<BR>&nbsp;&nbsp;&nbsp; bool is_user = regime_is_user(env, mmu_idx);</P>
<P>&nbsp;&nbsp;&nbsp; *phys_ptr = address;<BR>&nbsp;&nbsp;&nbsp; *prot = 0;</P>
<P>&nbsp;&nbsp;&nbsp; if (regime_translation_disabled(env, mmu_idx)) { /* MPU disabled */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_phys_addr_pmsav7_default(env, mmu_idx, address, prot);<BR>&nbsp;&nbsp;&nbsp; } else { /* MPU enabled */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (n = (int)cpu-&gt;pmsav7_dregion - 1; n &gt;= 0; n--) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* region search */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t base = env-&gt;pmsav7.drbar[n];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t rsize = extract32(env-&gt;pmsav7.drsr[n], 1, 5);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t rmask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool srdis = false;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(env-&gt;pmsav7.drsr[n] &amp; 0x1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!rsize) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_GUEST_ERROR, "DRSR.Rsize field can not be 0");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rmask = (1ull &lt;&lt; rsize) - 1;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (base &amp; rmask) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_GUEST_ERROR, "DRBAR %" PRIx32 " misaligned "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "to DRSR region size, mask = %" PRIx32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base, rmask);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (address &lt; base || address &gt; base + rmask) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Region matched */</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rsize &gt;= 8) { /* no subregions for regions &lt; 256 bytes */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i, snd;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t srdis_mask;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize -= 3; /* sub region size (power of 2) */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; snd = ((address - base) &gt;&gt; rsize) &amp; 0x7;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srdis = extract32(env-&gt;pmsav7.drsr[n], snd + 8, 1);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srdis_mask = srdis ? 0x3 : 0x0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 2; i &lt;= 8 &amp;&amp; rsize &lt; TARGET_PAGE_BITS; i *= 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* This will check in groups of 2, 4 and then 8, whether<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the subregion bits are consistent. rsize is incremented<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * back up to give the region size, considering consistent<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * adjacent subregions as one region. Stop testing if rsize<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * is already big enough for an entire QEMU page.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int snd_rounded = snd &amp; ~(i - 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t srdis_multi = extract32(env-&gt;pmsav7.drsr[n],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; snd_rounded + 8, i);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (srdis_mask ^ srdis_multi) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; srdis_mask = (srdis_mask &lt;&lt; i) | srdis_mask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rsize &lt; TARGET_PAGE_BITS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_UNIMP, "No support for MPU (sub)region"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "alignment of %" PRIu32 " bits. Minimum is %d\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize, TARGET_PAGE_BITS);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (srdis) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (n == -1) { /* no hits */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cpu-&gt;pmsav7_dregion &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (is_user || !(regime_sctlr(env, mmu_idx) &amp; SCTLR_BR))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* background fault */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *fsr = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_phys_addr_pmsav7_default(env, mmu_idx, address, prot);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else { /* a MPU hit! */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t ap = extract32(env-&gt;pmsav7.dracr[n], 8, 3);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_user) { /* User mode AP bit decoding */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (ap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 5:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; /* no access */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot |= PAGE_WRITE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* fall through */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 6:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot |= PAGE_READ | PAGE_EXEC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_GUEST_ERROR,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Bad value for AP bits in DRACR %"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIx32 "\n", ap);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else { /* Priv. mode AP bits decoding */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (ap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; /* no access */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot |= PAGE_WRITE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* fall through */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 5:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 6:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot |= PAGE_READ | PAGE_EXEC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_GUEST_ERROR,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Bad value for AP bits in DRACR %"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIx32 "\n", ap);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* execute never */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;pmsav7.dracr[n] &amp; (1 &lt;&lt; 12)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot &amp;= ~PAGE_EXEC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; *fsr = 0x00d; /* Permission fault */<BR>&nbsp;&nbsp;&nbsp; return !(*prot &amp; (1 &lt;&lt; access_type));<BR>}</P>
<P>static bool get_phys_addr_pmsav5(CPUARMState *env, uint32_t address,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access_type, ARMMMUIdx mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwaddr *phys_ptr, int *prot, uint32_t *fsr)<BR>{<BR>&nbsp;&nbsp;&nbsp; int n;<BR>&nbsp;&nbsp;&nbsp; uint32_t mask;<BR>&nbsp;&nbsp;&nbsp; uint32_t base;<BR>&nbsp;&nbsp;&nbsp; bool is_user = regime_is_user(env, mmu_idx);</P>
<P>&nbsp;&nbsp;&nbsp; *phys_ptr = address;<BR>&nbsp;&nbsp;&nbsp; for (n = 7; n &gt;= 0; n--) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base = env-&gt;cp15.c6_region[n];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((base &amp; 1) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = 1 &lt;&lt; ((base &gt;&gt; 1) &amp; 0x1f);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Keep this shift separate from the above to avoid an<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (undefined) &lt;&lt; 32.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = (mask &lt;&lt; 1) - 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (((base ^ address) &amp; ~mask) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (n &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *fsr = 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (access_type == 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = env-&gt;cp15.pmsav5_insn_ap;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = env-&gt;cp15.pmsav5_data_ap;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; mask = (mask &gt;&gt; (n * 4)) &amp; 0xf;<BR>&nbsp;&nbsp;&nbsp; switch (mask) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *fsr = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_user) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *fsr = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot = PAGE_READ | PAGE_WRITE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot = PAGE_READ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!is_user) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot |= PAGE_WRITE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot = PAGE_READ | PAGE_WRITE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 5:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_user) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *fsr = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot = PAGE_READ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 6:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot = PAGE_READ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Bad permission.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *fsr = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; *prot |= PAGE_EXEC;<BR>&nbsp;&nbsp;&nbsp; return false;<BR>}</P>
<P>/* get_phys_addr - get the physical address for this virtual address<BR>&nbsp;*<BR>&nbsp;* Find the physical address corresponding to the given virtual address,<BR>&nbsp;* by doing a translation table walk on MMU based systems or using the<BR>&nbsp;* MPU state on MPU based systems.<BR>&nbsp;*<BR>&nbsp;* Returns false if the translation was successful. Otherwise, phys_ptr, attrs,<BR>&nbsp;* prot and page_size may not be filled in, and the populated fsr value provides<BR>&nbsp;* information on why the translation aborted, in the format of a<BR>&nbsp;* DFSR/IFSR fault register, with the following caveats:<BR>&nbsp;*&nbsp; * we honour the short vs long DFSR format differences.<BR>&nbsp;*&nbsp; * the WnR bit is never set (the caller must do this).<BR>&nbsp;*&nbsp; * for PSMAv5 based systems we don't bother to return a full FSR format<BR>&nbsp;*&nbsp;&nbsp;&nbsp; value.<BR>&nbsp;*<BR>&nbsp;* @env: CPUARMState<BR>&nbsp;* @address: virtual address to get physical address for<BR>&nbsp;* @access_type: 0 for read, 1 for write, 2 for execute<BR>&nbsp;* @mmu_idx: MMU index indicating required translation regime<BR>&nbsp;* @phys_ptr: set to the physical address corresponding to the virtual address<BR>&nbsp;* @attrs: set to the memory transaction attributes to use<BR>&nbsp;* @prot: set to the permissions for the page containing phys_ptr<BR>&nbsp;* @page_size: set to the size of the page containing phys_ptr<BR>&nbsp;* @fsr: set to the DFSR/IFSR value on failure<BR>&nbsp;*/<BR>static bool get_phys_addr(CPUARMState *env, target_ulong address,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access_type, ARMMMUIdx mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwaddr *phys_ptr, MemTxAttrs *attrs, int *prot,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong *page_size, uint32_t *fsr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUFaultInfo *fi)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (mmu_idx == ARMMMUIdx_S12NSE0 || mmu_idx == ARMMMUIdx_S12NSE1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Call ourselves recursively to do the stage 1 and then stage 2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * translations.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwaddr ipa;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s2_prot;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ret;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = get_phys_addr(env, address, access_type,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx + ARMMMUIdx_S1NSE0, &amp;ipa, attrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prot, page_size, fsr, fi);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If S1 fails or S2 is disabled, return early.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ret || regime_translation_disabled(env, ARMMMUIdx_S2NS)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *phys_ptr = ipa;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ret;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* S1 is done. Now do S2 translation.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = get_phys_addr_lpae(env, ipa, access_type, ARMMMUIdx_S2NS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_ptr, attrs, &amp;s2_prot,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; page_size, fsr, fi);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi-&gt;s2addr = ipa;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Combine the S1 and S2 perms.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot &amp;= s2_prot;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ret;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * For non-EL2 CPUs a stage1+stage2 translation is just stage 1.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mmu_idx += ARMMMUIdx_S1NSE0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* The page table entries may downgrade secure to non-secure, but<BR>&nbsp;&nbsp;&nbsp;&nbsp; * cannot upgrade an non-secure translation regime's attributes<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to secure.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; attrs-&gt;secure = regime_is_secure(env, mmu_idx);<BR>&nbsp;&nbsp;&nbsp; attrs-&gt;user = regime_is_user(env, mmu_idx);</P>
<P>&nbsp;&nbsp;&nbsp; /* Fast Context Switch Extension. This doesn't exist at all in v8.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * In v7 and earlier it affects all stage 1 translations.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (address &lt; 0x02000000 &amp;&amp; mmu_idx != ARMMMUIdx_S2NS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (regime_el(env, mmu_idx) == 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address += env-&gt;cp15.fcseidr_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address += env-&gt;cp15.fcseidr_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* pmsav7 has special handling for when MPU is disabled so call it before<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the common MMU/MPU disabled check below.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_MPU) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_feature(env, ARM_FEATURE_V7)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *page_size = TARGET_PAGE_SIZE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return get_phys_addr_pmsav7(env, address, access_type, mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_ptr, prot, fsr);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (regime_translation_disabled(env, mmu_idx)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* MMU/MPU disabled.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *phys_ptr = address;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *page_size = TARGET_PAGE_SIZE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_MPU)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Pre-v7 MPU */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *page_size = TARGET_PAGE_SIZE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return get_phys_addr_pmsav5(env, address, access_type, mmu_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_ptr, prot, fsr);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (regime_using_lpae_format(env, mmu_idx)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return get_phys_addr_lpae(env, address, access_type, mmu_idx, phys_ptr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrs, prot, page_size, fsr, fi);<BR>&nbsp;&nbsp;&nbsp; } else if (regime_sctlr(env, mmu_idx) &amp; SCTLR_XP) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return get_phys_addr_v6(env, address, access_type, mmu_idx, phys_ptr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrs, prot, page_size, fsr, fi);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return get_phys_addr_v5(env, address, access_type, mmu_idx, phys_ptr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prot, page_size, fsr, fi);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Walk the page table and (if the mapping exists) add the page<BR>&nbsp;* to the TLB. Return false on success, or true on failure. Populate<BR>&nbsp;* fsr with ARM DFSR/IFSR fault register format value on failure.<BR>&nbsp;*/<BR>bool arm_tlb_fill(CPUState *cs, vaddr address,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access_type, int mmu_idx, uint32_t *fsr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMMMUFaultInfo *fi)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; hwaddr phys_addr;<BR>&nbsp;&nbsp;&nbsp; target_ulong page_size;<BR>&nbsp;&nbsp;&nbsp; int prot;<BR>&nbsp;&nbsp;&nbsp; int ret;<BR>&nbsp;&nbsp;&nbsp; MemTxAttrs attrs = {};</P>
<P>&nbsp;&nbsp;&nbsp; ret = get_phys_addr(env, address, access_type, mmu_idx, &amp;phys_addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;attrs, &amp;prot, &amp;page_size, fsr, fi);<BR>&nbsp;&nbsp;&nbsp; if (!ret) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Map a single [sub]page.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; phys_addr &amp;= TARGET_PAGE_MASK;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address &amp;= TARGET_PAGE_MASK;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_set_page_with_attrs(cs, address, phys_addr, attrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prot, mmu_idx, page_size);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return ret;<BR>}</P>
<P>hwaddr arm_cpu_get_phys_page_attrs_debug(CPUState *cs, vaddr addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemTxAttrs *attrs)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; hwaddr phys_addr;<BR>&nbsp;&nbsp;&nbsp; target_ulong page_size;<BR>&nbsp;&nbsp;&nbsp; int prot;<BR>&nbsp;&nbsp;&nbsp; bool ret;<BR>&nbsp;&nbsp;&nbsp; uint32_t fsr;<BR>&nbsp;&nbsp;&nbsp; ARMMMUFaultInfo fi = {};</P>
<P>&nbsp;&nbsp;&nbsp; *attrs = (MemTxAttrs) {};</P>
<P>&nbsp;&nbsp;&nbsp; ret = get_phys_addr(env, addr, 0, cpu_mmu_index(env, false), &amp;phys_addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrs, &amp;prot, &amp;page_size, &amp;fsr, &amp;fi);</P>
<P>&nbsp;&nbsp;&nbsp; if (ret) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return phys_addr;<BR>}</P>
<P>uint32_t HELPER(v7m_mrs)(CPUARMState *env, uint32_t reg)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; switch (reg) {<BR>&nbsp;&nbsp;&nbsp; case 0: /* APSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return xpsr_read(env) &amp; 0xf8000000;<BR>&nbsp;&nbsp;&nbsp; case 1: /* IAPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return xpsr_read(env) &amp; 0xf80001ff;<BR>&nbsp;&nbsp;&nbsp; case 2: /* EAPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return xpsr_read(env) &amp; 0xff00fc00;<BR>&nbsp;&nbsp;&nbsp; case 3: /* xPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return xpsr_read(env) &amp; 0xff00fdff;<BR>&nbsp;&nbsp;&nbsp; case 5: /* IPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return xpsr_read(env) &amp; 0x000001ff;<BR>&nbsp;&nbsp;&nbsp; case 6: /* EPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return xpsr_read(env) &amp; 0x0700fc00;<BR>&nbsp;&nbsp;&nbsp; case 7: /* IEPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return xpsr_read(env) &amp; 0x0700edff;<BR>&nbsp;&nbsp;&nbsp; case 8: /* MSP */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;v7m.current_sp ? env-&gt;v7m.other_sp : env-&gt;regs[13];<BR>&nbsp;&nbsp;&nbsp; case 9: /* PSP */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;v7m.current_sp ? env-&gt;regs[13] : env-&gt;v7m.other_sp;<BR>&nbsp;&nbsp;&nbsp; case 16: /* PRIMASK */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (env-&gt;daif &amp; PSTATE_I) != 0;<BR>&nbsp;&nbsp;&nbsp; case 17: /* BASEPRI */<BR>&nbsp;&nbsp;&nbsp; case 18: /* BASEPRI_MAX */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;v7m.basepri;<BR>&nbsp;&nbsp;&nbsp; case 19: /* FAULTMASK */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (env-&gt;daif &amp; PSTATE_F) != 0;<BR>&nbsp;&nbsp;&nbsp; case 20: /* CONTROL */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;v7m.control;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ??? For debugging only.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_abort(CPU(cpu), "Unimplemented system register read (%d)\n", reg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void HELPER(v7m_msr)(CPUARMState *env, uint32_t reg, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; switch (reg) {<BR>&nbsp;&nbsp;&nbsp; case 0: /* APSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xpsr_write(env, val, 0xf8000000);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 1: /* IAPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xpsr_write(env, val, 0xf8000000);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2: /* EAPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xpsr_write(env, val, 0xfe00fc00);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 3: /* xPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xpsr_write(env, val, 0xfe00fc00);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 5: /* IPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* IPSR bits are readonly.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 6: /* EPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xpsr_write(env, val, 0x0600fc00);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 7: /* IEPSR */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xpsr_write(env, val, 0x0600fc00);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 8: /* MSP */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;v7m.current_sp)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;v7m.other_sp = val;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = val;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 9: /* PSP */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;v7m.current_sp)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = val;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;v7m.other_sp = val;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 16: /* PRIMASK */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (val &amp; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;daif |= PSTATE_I;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;daif &amp;= ~PSTATE_I;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 17: /* BASEPRI */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;v7m.basepri = val &amp; 0xff;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 18: /* BASEPRI_MAX */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val &amp;= 0xff;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (val != 0 &amp;&amp; (val &lt; env-&gt;v7m.basepri || env-&gt;v7m.basepri == 0))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;v7m.basepri = val;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 19: /* FAULTMASK */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (val &amp; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;daif |= PSTATE_F;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;daif &amp;= ~PSTATE_F;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 20: /* CONTROL */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;v7m.control = val &amp; 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch_v7m_sp(env, (val &amp; 2) != 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ??? For debugging only.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_abort(CPU(cpu), "Unimplemented system register write (%d)\n", reg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>#endif</P>
<P>void HELPER(dc_zva)(CPUARMState *env, uint64_t vaddr_in)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Implement DC ZVA, which zeroes a fixed-length block of memory.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Note that we do not implement the (architecturally mandated)<BR>&nbsp;&nbsp;&nbsp;&nbsp; * alignment fault for attempts to use this on Device memory<BR>&nbsp;&nbsp;&nbsp;&nbsp; * (which matches the usual QEMU behaviour of not implementing either<BR>&nbsp;&nbsp;&nbsp;&nbsp; * alignment faults or any memory attribute handling).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; uint64_t blocklen = 4 &lt;&lt; cpu-&gt;dcz_blocksize;<BR>&nbsp;&nbsp;&nbsp; uint64_t vaddr = vaddr_in &amp; ~(blocklen - 1);</P>
<P>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Slightly awkwardly, QEMU's TARGET_PAGE_SIZE may be less than<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the block size so we might have to do more than one TLB lookup.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * We know that in fact for any v8 CPU the page size is at least 4K<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * and the block size must be 2K or less, but TARGET_PAGE_SIZE is only<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * 1K as an artefact of legacy v5 subpage support being present in the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * same QEMU executable.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int maxidx = DIV_ROUND_UP(blocklen, TARGET_PAGE_SIZE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *hostaddr[maxidx];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int try, i;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned mmu_idx = cpu_mmu_index(env, false);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi = make_memop_idx(MO_UB, mmu_idx);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (try = 0; try &lt; 2; try++) {</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; maxidx; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hostaddr[i] = tlb_vaddr_to_host(env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vaddr + TARGET_PAGE_SIZE * i,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1, mmu_idx);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!hostaddr[i]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i == maxidx) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If it's all in the TLB it's fair game for just writing to;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * we know we don't need to update dirty status, etc.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; maxidx - 1; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset(hostaddr[i], 0, TARGET_PAGE_SIZE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset(hostaddr[i], 0, blocklen - (i * TARGET_PAGE_SIZE));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* OK, try a store and see if we can populate the tlb. This<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * might cause an exception if the memory isn't writable,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * in which case we will longjmp out of here. We must for<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * this purpose use the actual register value passed to us<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * so that we get the fault address right.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; helper_ret_stb_mmu(env, vaddr_in, 0, oi, GETRA());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Now we can populate the other TLB entries, if any */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; maxidx; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t va = vaddr + TARGET_PAGE_SIZE * i;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (va != (vaddr_in &amp; TARGET_PAGE_MASK)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; helper_ret_stb_mmu(env, va, 0, oi, GETRA());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Slow path (probably attempt to do this to an I/O device or<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * similar, or clearing of a block of code we have translations<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * cached for). Just do a series of byte writes as the architecture<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * demands. It's not worth trying to use a cpu_physical_memory_map(),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * memset(), unmap() sequence here because:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; + we'd need to account for the blocksize being larger than a page<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; + the direct-RAM access case is almost always going to be dealt<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; with in the fastpath code above, so there's no speed benefit<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; + we would have to deal with the map returning NULL because the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; bounce buffer was in use<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; blocklen; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; helper_ret_stb_mmu(env, vaddr + i, 0, oi, GETRA());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>#else<BR>&nbsp;&nbsp;&nbsp; memset(g2h(vaddr), 0, blocklen);<BR>#endif<BR>}</P>
<P>/* Note that signed overflow is undefined in C.&nbsp; The following routines are<BR>&nbsp;&nbsp; careful to use unsigned types where modulo arithmetic is required.<BR>&nbsp;&nbsp; Failure to do so _will_ break on newer gcc.&nbsp; */</P>
<P>/* Signed saturating arithmetic.&nbsp; */</P>
<P>/* Perform 16-bit signed saturating addition.&nbsp; */<BR>static inline uint16_t add16_sat(uint16_t a, uint16_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint16_t res;</P>
<P>&nbsp;&nbsp;&nbsp; res = a + b;<BR>&nbsp;&nbsp;&nbsp; if (((res ^ a) &amp; 0x8000) &amp;&amp; !((a ^ b) &amp; 0x8000)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a &amp; 0x8000)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0x8000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0x7fff;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</P>
<P>/* Perform 8-bit signed saturating addition.&nbsp; */<BR>static inline uint8_t add8_sat(uint8_t a, uint8_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t res;</P>
<P>&nbsp;&nbsp;&nbsp; res = a + b;<BR>&nbsp;&nbsp;&nbsp; if (((res ^ a) &amp; 0x80) &amp;&amp; !((a ^ b) &amp; 0x80)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a &amp; 0x80)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0x80;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0x7f;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</P>
<P>/* Perform 16-bit signed saturating subtraction.&nbsp; */<BR>static inline uint16_t sub16_sat(uint16_t a, uint16_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint16_t res;</P>
<P>&nbsp;&nbsp;&nbsp; res = a - b;<BR>&nbsp;&nbsp;&nbsp; if (((res ^ a) &amp; 0x8000) &amp;&amp; ((a ^ b) &amp; 0x8000)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a &amp; 0x8000)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0x8000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0x7fff;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</P>
<P>/* Perform 8-bit signed saturating subtraction.&nbsp; */<BR>static inline uint8_t sub8_sat(uint8_t a, uint8_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t res;</P>
<P>&nbsp;&nbsp;&nbsp; res = a - b;<BR>&nbsp;&nbsp;&nbsp; if (((res ^ a) &amp; 0x80) &amp;&amp; ((a ^ b) &amp; 0x80)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a &amp; 0x80)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0x80;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0x7f;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</P>
<P>#define ADD16(a, b, n) RESULT(add16_sat(a, b), n, 16);<BR>#define SUB16(a, b, n) RESULT(sub16_sat(a, b), n, 16);<BR>#define ADD8(a, b, n)&nbsp; RESULT(add8_sat(a, b), n, 8);<BR>#define SUB8(a, b, n)&nbsp; RESULT(sub8_sat(a, b), n, 8);<BR>#define PFX q</P>
<P>#include "op_addsub.h"</P>
<P>/* Unsigned saturating arithmetic.&nbsp; */<BR>static inline uint16_t add16_usat(uint16_t a, uint16_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint16_t res;<BR>&nbsp;&nbsp;&nbsp; res = a + b;<BR>&nbsp;&nbsp;&nbsp; if (res &lt; a)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0xffff;<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</P>
<P>static inline uint16_t sub16_usat(uint16_t a, uint16_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (a &gt; b)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a - b;<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>static inline uint8_t add8_usat(uint8_t a, uint8_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t res;<BR>&nbsp;&nbsp;&nbsp; res = a + b;<BR>&nbsp;&nbsp;&nbsp; if (res &lt; a)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0xff;<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</P>
<P>static inline uint8_t sub8_usat(uint8_t a, uint8_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (a &gt; b)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a - b;<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>#define ADD16(a, b, n) RESULT(add16_usat(a, b), n, 16);<BR>#define SUB16(a, b, n) RESULT(sub16_usat(a, b), n, 16);<BR>#define ADD8(a, b, n)&nbsp; RESULT(add8_usat(a, b), n, 8);<BR>#define SUB8(a, b, n)&nbsp; RESULT(sub8_usat(a, b), n, 8);<BR>#define PFX uq</P>
<P>#include "op_addsub.h"</P>
<P>/* Signed modulo arithmetic.&nbsp; */<BR>#define SARITH16(a, b, n, op) do { \<BR>&nbsp;&nbsp;&nbsp; int32_t sum; \<BR>&nbsp;&nbsp;&nbsp; sum = (int32_t)(int16_t)(a) op (int32_t)(int16_t)(b); \<BR>&nbsp;&nbsp;&nbsp; RESULT(sum, n, 16); \<BR>&nbsp;&nbsp;&nbsp; if (sum &gt;= 0) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ge |= 3 &lt;&lt; (n * 2); \<BR>&nbsp;&nbsp;&nbsp; } while(0)</P>
<P>#define SARITH8(a, b, n, op) do { \<BR>&nbsp;&nbsp;&nbsp; int32_t sum; \<BR>&nbsp;&nbsp;&nbsp; sum = (int32_t)(int8_t)(a) op (int32_t)(int8_t)(b); \<BR>&nbsp;&nbsp;&nbsp; RESULT(sum, n, 8); \<BR>&nbsp;&nbsp;&nbsp; if (sum &gt;= 0) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ge |= 1 &lt;&lt; n; \<BR>&nbsp;&nbsp;&nbsp; } while(0)</P>
<P><BR>#define ADD16(a, b, n) SARITH16(a, b, n, +)<BR>#define SUB16(a, b, n) SARITH16(a, b, n, -)<BR>#define ADD8(a, b, n)&nbsp; SARITH8(a, b, n, +)<BR>#define SUB8(a, b, n)&nbsp; SARITH8(a, b, n, -)<BR>#define PFX s<BR>#define ARITH_GE</P>
<P>#include "op_addsub.h"</P>
<P>/* Unsigned modulo arithmetic.&nbsp; */<BR>#define ADD16(a, b, n) do { \<BR>&nbsp;&nbsp;&nbsp; uint32_t sum; \<BR>&nbsp;&nbsp;&nbsp; sum = (uint32_t)(uint16_t)(a) + (uint32_t)(uint16_t)(b); \<BR>&nbsp;&nbsp;&nbsp; RESULT(sum, n, 16); \<BR>&nbsp;&nbsp;&nbsp; if ((sum &gt;&gt; 16) == 1) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ge |= 3 &lt;&lt; (n * 2); \<BR>&nbsp;&nbsp;&nbsp; } while(0)</P>
<P>#define ADD8(a, b, n) do { \<BR>&nbsp;&nbsp;&nbsp; uint32_t sum; \<BR>&nbsp;&nbsp;&nbsp; sum = (uint32_t)(uint8_t)(a) + (uint32_t)(uint8_t)(b); \<BR>&nbsp;&nbsp;&nbsp; RESULT(sum, n, 8); \<BR>&nbsp;&nbsp;&nbsp; if ((sum &gt;&gt; 8) == 1) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ge |= 1 &lt;&lt; n; \<BR>&nbsp;&nbsp;&nbsp; } while(0)</P>
<P>#define SUB16(a, b, n) do { \<BR>&nbsp;&nbsp;&nbsp; uint32_t sum; \<BR>&nbsp;&nbsp;&nbsp; sum = (uint32_t)(uint16_t)(a) - (uint32_t)(uint16_t)(b); \<BR>&nbsp;&nbsp;&nbsp; RESULT(sum, n, 16); \<BR>&nbsp;&nbsp;&nbsp; if ((sum &gt;&gt; 16) == 0) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ge |= 3 &lt;&lt; (n * 2); \<BR>&nbsp;&nbsp;&nbsp; } while(0)</P>
<P>#define SUB8(a, b, n) do { \<BR>&nbsp;&nbsp;&nbsp; uint32_t sum; \<BR>&nbsp;&nbsp;&nbsp; sum = (uint32_t)(uint8_t)(a) - (uint32_t)(uint8_t)(b); \<BR>&nbsp;&nbsp;&nbsp; RESULT(sum, n, 8); \<BR>&nbsp;&nbsp;&nbsp; if ((sum &gt;&gt; 8) == 0) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ge |= 1 &lt;&lt; n; \<BR>&nbsp;&nbsp;&nbsp; } while(0)</P>
<P>#define PFX u<BR>#define ARITH_GE</P>
<P>#include "op_addsub.h"</P>
<P>/* Halved signed arithmetic.&nbsp; */<BR>#define ADD16(a, b, n) \<BR>&nbsp; RESULT(((int32_t)(int16_t)(a) + (int32_t)(int16_t)(b)) &gt;&gt; 1, n, 16)<BR>#define SUB16(a, b, n) \<BR>&nbsp; RESULT(((int32_t)(int16_t)(a) - (int32_t)(int16_t)(b)) &gt;&gt; 1, n, 16)<BR>#define ADD8(a, b, n) \<BR>&nbsp; RESULT(((int32_t)(int8_t)(a) + (int32_t)(int8_t)(b)) &gt;&gt; 1, n, 8)<BR>#define SUB8(a, b, n) \<BR>&nbsp; RESULT(((int32_t)(int8_t)(a) - (int32_t)(int8_t)(b)) &gt;&gt; 1, n, 8)<BR>#define PFX sh</P>
<P>#include "op_addsub.h"</P>
<P>/* Halved unsigned arithmetic.&nbsp; */<BR>#define ADD16(a, b, n) \<BR>&nbsp; RESULT(((uint32_t)(uint16_t)(a) + (uint32_t)(uint16_t)(b)) &gt;&gt; 1, n, 16)<BR>#define SUB16(a, b, n) \<BR>&nbsp; RESULT(((uint32_t)(uint16_t)(a) - (uint32_t)(uint16_t)(b)) &gt;&gt; 1, n, 16)<BR>#define ADD8(a, b, n) \<BR>&nbsp; RESULT(((uint32_t)(uint8_t)(a) + (uint32_t)(uint8_t)(b)) &gt;&gt; 1, n, 8)<BR>#define SUB8(a, b, n) \<BR>&nbsp; RESULT(((uint32_t)(uint8_t)(a) - (uint32_t)(uint8_t)(b)) &gt;&gt; 1, n, 8)<BR>#define PFX uh</P>
<P>#include "op_addsub.h"</P>
<P>static inline uint8_t do_usad(uint8_t a, uint8_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (a &gt; b)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a - b;<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return b - a;<BR>}</P>
<P>/* Unsigned sum of absolute byte differences.&nbsp; */<BR>uint32_t HELPER(usad8)(uint32_t a, uint32_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t sum;<BR>&nbsp;&nbsp;&nbsp; sum = do_usad(a, b);<BR>&nbsp;&nbsp;&nbsp; sum += do_usad(a &gt;&gt; 8, b &gt;&gt; 8);<BR>&nbsp;&nbsp;&nbsp; sum += do_usad(a &gt;&gt; 16, b &gt;&gt;16);<BR>&nbsp;&nbsp;&nbsp; sum += do_usad(a &gt;&gt; 24, b &gt;&gt; 24);<BR>&nbsp;&nbsp;&nbsp; return sum;<BR>}</P>
<P>/* For ARMv6 SEL instruction.&nbsp; */<BR>uint32_t HELPER(sel_flags)(uint32_t flags, uint32_t a, uint32_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t mask;</P>
<P>&nbsp;&nbsp;&nbsp; mask = 0;<BR>&nbsp;&nbsp;&nbsp; if (flags &amp; 1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= 0xff;<BR>&nbsp;&nbsp;&nbsp; if (flags &amp; 2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= 0xff00;<BR>&nbsp;&nbsp;&nbsp; if (flags &amp; 4)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= 0xff0000;<BR>&nbsp;&nbsp;&nbsp; if (flags &amp; 8)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask |= 0xff000000;<BR>&nbsp;&nbsp;&nbsp; return (a &amp; mask) | (b &amp; ~mask);<BR>}</P>
<P>/* VFP support.&nbsp; We follow the convention used for VFP instructions:<BR>&nbsp;&nbsp; Single precision routines have a "s" suffix, double precision a<BR>&nbsp;&nbsp; "d" suffix.&nbsp; */</P>
<P>/* Convert host exception flags to vfp form.&nbsp; */<BR>static inline int vfp_exceptbits_from_host(int host_bits)<BR>{<BR>&nbsp;&nbsp;&nbsp; int target_bits = 0;</P>
<P>&nbsp;&nbsp;&nbsp; if (host_bits &amp; float_flag_invalid)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_bits |= 1;<BR>&nbsp;&nbsp;&nbsp; if (host_bits &amp; float_flag_divbyzero)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_bits |= 2;<BR>&nbsp;&nbsp;&nbsp; if (host_bits &amp; float_flag_overflow)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_bits |= 4;<BR>&nbsp;&nbsp;&nbsp; if (host_bits &amp; (float_flag_underflow | float_flag_output_denormal))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_bits |= 8;<BR>&nbsp;&nbsp;&nbsp; if (host_bits &amp; float_flag_inexact)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_bits |= 0x10;<BR>&nbsp;&nbsp;&nbsp; if (host_bits &amp; float_flag_input_denormal)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_bits |= 0x80;<BR>&nbsp;&nbsp;&nbsp; return target_bits;<BR>}</P>
<P>uint32_t HELPER(vfp_get_fpscr)(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; uint32_t fpscr;</P>
<P>&nbsp;&nbsp;&nbsp; fpscr = (env-&gt;vfp.xregs[ARM_VFP_FPSCR] &amp; 0xffc8ffff)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (env-&gt;vfp.vec_len &lt;&lt; 16)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (env-&gt;vfp.vec_stride &lt;&lt; 20);<BR>&nbsp;&nbsp;&nbsp; i = get_float_exception_flags(&amp;env-&gt;vfp.fp_status);<BR>&nbsp;&nbsp;&nbsp; i |= get_float_exception_flags(&amp;env-&gt;vfp.standard_fp_status);<BR>&nbsp;&nbsp;&nbsp; fpscr |= vfp_exceptbits_from_host(i);<BR>&nbsp;&nbsp;&nbsp; return fpscr;<BR>}</P>
<P>uint32_t vfp_get_fpscr(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return HELPER(vfp_get_fpscr)(env);<BR>}</P>
<P>/* Convert vfp exception flags to target form.&nbsp; */<BR>static inline int vfp_exceptbits_to_host(int target_bits)<BR>{<BR>&nbsp;&nbsp;&nbsp; int host_bits = 0;</P>
<P>&nbsp;&nbsp;&nbsp; if (target_bits &amp; 1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host_bits |= float_flag_invalid;<BR>&nbsp;&nbsp;&nbsp; if (target_bits &amp; 2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host_bits |= float_flag_divbyzero;<BR>&nbsp;&nbsp;&nbsp; if (target_bits &amp; 4)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host_bits |= float_flag_overflow;<BR>&nbsp;&nbsp;&nbsp; if (target_bits &amp; 8)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host_bits |= float_flag_underflow;<BR>&nbsp;&nbsp;&nbsp; if (target_bits &amp; 0x10)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host_bits |= float_flag_inexact;<BR>&nbsp;&nbsp;&nbsp; if (target_bits &amp; 0x80)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host_bits |= float_flag_input_denormal;<BR>&nbsp;&nbsp;&nbsp; return host_bits;<BR>}</P>
<P>void HELPER(vfp_set_fpscr)(CPUARMState *env, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; uint32_t changed;</P>
<P>&nbsp;&nbsp;&nbsp; changed = env-&gt;vfp.xregs[ARM_VFP_FPSCR];<BR>&nbsp;&nbsp;&nbsp; env-&gt;vfp.xregs[ARM_VFP_FPSCR] = (val &amp; 0xffc8ffff);<BR>&nbsp;&nbsp;&nbsp; env-&gt;vfp.vec_len = (val &gt;&gt; 16) &amp; 7;<BR>&nbsp;&nbsp;&nbsp; env-&gt;vfp.vec_stride = (val &gt;&gt; 20) &amp; 3;</P>
<P>&nbsp;&nbsp;&nbsp; changed ^= val;<BR>&nbsp;&nbsp;&nbsp; if (changed &amp; (3 &lt;&lt; 22)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = (val &gt;&gt; 22) &amp; 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (i) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case FPROUNDING_TIEEVEN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = float_round_nearest_even;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case FPROUNDING_POSINF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = float_round_up;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case FPROUNDING_NEGINF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = float_round_down;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case FPROUNDING_ZERO:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = float_round_to_zero;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_float_rounding_mode(i, &amp;env-&gt;vfp.fp_status);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (changed &amp; (1 &lt;&lt; 24)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_flush_to_zero((val &amp; (1 &lt;&lt; 24)) != 0, &amp;env-&gt;vfp.fp_status);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_flush_inputs_to_zero((val &amp; (1 &lt;&lt; 24)) != 0, &amp;env-&gt;vfp.fp_status);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (changed &amp; (1 &lt;&lt; 25))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_default_nan_mode((val &amp; (1 &lt;&lt; 25)) != 0, &amp;env-&gt;vfp.fp_status);</P>
<P>&nbsp;&nbsp;&nbsp; i = vfp_exceptbits_to_host(val);<BR>&nbsp;&nbsp;&nbsp; set_float_exception_flags(i, &amp;env-&gt;vfp.fp_status);<BR>&nbsp;&nbsp;&nbsp; set_float_exception_flags(0, &amp;env-&gt;vfp.standard_fp_status);<BR>}</P>
<P>void vfp_set_fpscr(CPUARMState *env, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; HELPER(vfp_set_fpscr)(env, val);<BR>}</P>
<P>#define VFP_HELPER(name, p) HELPER(glue(glue(vfp_,name),p))</P>
<P>#define VFP_BINOP(name) \<BR>float32 VFP_HELPER(name, s)(float32 a, float32 b, void *fpstp) \<BR>{ \<BR>&nbsp;&nbsp;&nbsp; float_status *fpst = fpstp; \<BR>&nbsp;&nbsp;&nbsp; return float32_ ## name(a, b, fpst); \<BR>} \<BR>float64 VFP_HELPER(name, d)(float64 a, float64 b, void *fpstp) \<BR>{ \<BR>&nbsp;&nbsp;&nbsp; float_status *fpst = fpstp; \<BR>&nbsp;&nbsp;&nbsp; return float64_ ## name(a, b, fpst); \<BR>}<BR>VFP_BINOP(add)<BR>VFP_BINOP(sub)<BR>VFP_BINOP(mul)<BR>VFP_BINOP(div)<BR>VFP_BINOP(min)<BR>VFP_BINOP(max)<BR>VFP_BINOP(minnum)<BR>VFP_BINOP(maxnum)<BR>#undef VFP_BINOP</P>
<P>float32 VFP_HELPER(neg, s)(float32 a)<BR>{<BR>&nbsp;&nbsp;&nbsp; return float32_chs(a);<BR>}</P>
<P>float64 VFP_HELPER(neg, d)(float64 a)<BR>{<BR>&nbsp;&nbsp;&nbsp; return float64_chs(a);<BR>}</P>
<P>float32 VFP_HELPER(abs, s)(float32 a)<BR>{<BR>&nbsp;&nbsp;&nbsp; return float32_abs(a);<BR>}</P>
<P>float64 VFP_HELPER(abs, d)(float64 a)<BR>{<BR>&nbsp;&nbsp;&nbsp; return float64_abs(a);<BR>}</P>
<P>float32 VFP_HELPER(sqrt, s)(float32 a, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return float32_sqrt(a, &amp;env-&gt;vfp.fp_status);<BR>}</P>
<P>float64 VFP_HELPER(sqrt, d)(float64 a, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return float64_sqrt(a, &amp;env-&gt;vfp.fp_status);<BR>}</P>
<P>/* XXX: check quiet/signaling case */<BR>#define DO_VFP_cmp(p, type) \<BR>void VFP_HELPER(cmp, p)(type a, type b, CPUARMState *env)&nbsp; \<BR>{ \<BR>&nbsp;&nbsp;&nbsp; uint32_t flags; \<BR>&nbsp;&nbsp;&nbsp; switch(type ## _compare_quiet(a, b, &amp;env-&gt;vfp.fp_status)) { \<BR>&nbsp;&nbsp;&nbsp; case 0: flags = 0x6; break; \<BR>&nbsp;&nbsp;&nbsp; case -1: flags = 0x8; break; \<BR>&nbsp;&nbsp;&nbsp; case 1: flags = 0x2; break; \<BR>&nbsp;&nbsp;&nbsp; default: case 2: flags = 0x3; break; \<BR>&nbsp;&nbsp;&nbsp; } \<BR>&nbsp;&nbsp;&nbsp; env-&gt;vfp.xregs[ARM_VFP_FPSCR] = (flags &lt;&lt; 28) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (env-&gt;vfp.xregs[ARM_VFP_FPSCR] &amp; 0x0fffffff); \<BR>} \<BR>void VFP_HELPER(cmpe, p)(type a, type b, CPUARMState *env) \<BR>{ \<BR>&nbsp;&nbsp;&nbsp; uint32_t flags; \<BR>&nbsp;&nbsp;&nbsp; switch(type ## _compare(a, b, &amp;env-&gt;vfp.fp_status)) { \<BR>&nbsp;&nbsp;&nbsp; case 0: flags = 0x6; break; \<BR>&nbsp;&nbsp;&nbsp; case -1: flags = 0x8; break; \<BR>&nbsp;&nbsp;&nbsp; case 1: flags = 0x2; break; \<BR>&nbsp;&nbsp;&nbsp; default: case 2: flags = 0x3; break; \<BR>&nbsp;&nbsp;&nbsp; } \<BR>&nbsp;&nbsp;&nbsp; env-&gt;vfp.xregs[ARM_VFP_FPSCR] = (flags &lt;&lt; 28) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (env-&gt;vfp.xregs[ARM_VFP_FPSCR] &amp; 0x0fffffff); \<BR>}<BR>DO_VFP_cmp(s, float32)<BR>DO_VFP_cmp(d, float64)<BR>#undef DO_VFP_cmp</P>
<P>/* Integer to float and float to integer conversions */</P>
<P>#define CONV_ITOF(name, fsz, sign) \<BR>&nbsp;&nbsp;&nbsp; float##fsz HELPER(name)(uint32_t x, void *fpstp) \<BR>{ \<BR>&nbsp;&nbsp;&nbsp; float_status *fpst = fpstp; \<BR>&nbsp;&nbsp;&nbsp; return sign##int32_to_##float##fsz((sign##int32_t)x, fpst); \<BR>}</P>
<P>#define CONV_FTOI(name, fsz, sign, round) \<BR>uint32_t HELPER(name)(float##fsz x, void *fpstp) \<BR>{ \<BR>&nbsp;&nbsp;&nbsp; float_status *fpst = fpstp; \<BR>&nbsp;&nbsp;&nbsp; if (float##fsz##_is_any_nan(x)) { \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_invalid, fpst); \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; \<BR>&nbsp;&nbsp;&nbsp; } \<BR>&nbsp;&nbsp;&nbsp; return float##fsz##_to_##sign##int32##round(x, fpst); \<BR>}</P>
<P>#define FLOAT_CONVS(name, p, fsz, sign) \<BR>CONV_ITOF(vfp_##name##to##p, fsz, sign) \<BR>CONV_FTOI(vfp_to##name##p, fsz, sign, ) \<BR>CONV_FTOI(vfp_to##name##z##p, fsz, sign, _round_to_zero)</P>
<P>FLOAT_CONVS(si, s, 32, )<BR>FLOAT_CONVS(si, d, 64, )<BR>FLOAT_CONVS(ui, s, 32, u)<BR>FLOAT_CONVS(ui, d, 64, u)</P>
<P>#undef CONV_ITOF<BR>#undef CONV_FTOI<BR>#undef FLOAT_CONVS</P>
<P>/* floating point conversion */<BR>float64 VFP_HELPER(fcvtd, s)(float32 x, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; float64 r = float32_to_float64(x, &amp;env-&gt;vfp.fp_status);<BR>&nbsp;&nbsp;&nbsp; /* ARM requires that S&lt;-&gt;D conversion of any kind of NaN generates<BR>&nbsp;&nbsp;&nbsp;&nbsp; * a quiet NaN by forcing the most significant frac bit to 1.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; return float64_maybe_silence_nan(r, &amp;env-&gt;vfp.fp_status);<BR>}</P>
<P>float32 VFP_HELPER(fcvts, d)(float64 x, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; float32 r =&nbsp; float64_to_float32(x, &amp;env-&gt;vfp.fp_status);<BR>&nbsp;&nbsp;&nbsp; /* ARM requires that S&lt;-&gt;D conversion of any kind of NaN generates<BR>&nbsp;&nbsp;&nbsp;&nbsp; * a quiet NaN by forcing the most significant frac bit to 1.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; return float32_maybe_silence_nan(r, &amp;env-&gt;vfp.fp_status);<BR>}</P>
<P>/* VFP3 fixed point conversion.&nbsp; */<BR>#define VFP_CONV_FIX_FLOAT(name, p, fsz, isz, itype) \<BR>float##fsz HELPER(vfp_##name##to##p)(uint##isz##_t&nbsp; x, uint32_t shift, \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *fpstp) \<BR>{ \<BR>&nbsp;&nbsp;&nbsp; float_status *fpst = fpstp; \<BR>&nbsp;&nbsp;&nbsp; float##fsz tmp; \<BR>&nbsp;&nbsp;&nbsp; tmp = itype##_to_##float##fsz(x, fpst); \<BR>&nbsp;&nbsp;&nbsp; return float##fsz##_scalbn(tmp, -(int)shift, fpst); \<BR>}</P>
<P>/* Notice that we want only input-denormal exception flags from the<BR>&nbsp;* scalbn operation: the other possible flags (overflow+inexact if<BR>&nbsp;* we overflow to infinity, output-denormal) aren't correct for the<BR>&nbsp;* complete scale-and-convert operation.<BR>&nbsp;*/<BR>#define VFP_CONV_FLOAT_FIX_ROUND(name, p, fsz, isz, itype, round) \<BR>uint##isz##_t HELPER(vfp_to##name##p##round)(float##fsz x, \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t shift, \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *fpstp) \<BR>{ \<BR>&nbsp;&nbsp;&nbsp; float_status *fpst = fpstp; \<BR>&nbsp;&nbsp;&nbsp; int old_exc_flags = get_float_exception_flags(fpst); \<BR>&nbsp;&nbsp;&nbsp; float##fsz tmp; \<BR>&nbsp;&nbsp;&nbsp; if (float##fsz##_is_any_nan(x)) { \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_invalid, fpst); \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; \<BR>&nbsp;&nbsp;&nbsp; } \<BR>&nbsp;&nbsp;&nbsp; tmp = float##fsz##_scalbn(x, shift, fpst); \<BR>&nbsp;&nbsp;&nbsp; old_exc_flags |= get_float_exception_flags(fpst) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; float_flag_input_denormal; \<BR>&nbsp;&nbsp;&nbsp; set_float_exception_flags(old_exc_flags, fpst); \<BR>&nbsp;&nbsp;&nbsp; return float##fsz##_to_##itype##round(tmp, fpst); \<BR>}</P>
<P>#define VFP_CONV_FIX(name, p, fsz, isz, itype)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>VFP_CONV_FIX_FLOAT(name, p, fsz, isz, itype)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>VFP_CONV_FLOAT_FIX_ROUND(name, p, fsz, isz, itype, _round_to_zero) \<BR>VFP_CONV_FLOAT_FIX_ROUND(name, p, fsz, isz, itype, )</P>
<P>#define VFP_CONV_FIX_A64(name, p, fsz, isz, itype)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>VFP_CONV_FIX_FLOAT(name, p, fsz, isz, itype)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>VFP_CONV_FLOAT_FIX_ROUND(name, p, fsz, isz, itype, )</P>
<P>VFP_CONV_FIX(sh, d, 64, 64, int16)<BR>VFP_CONV_FIX(sl, d, 64, 64, int32)<BR>VFP_CONV_FIX_A64(sq, d, 64, 64, int64)<BR>VFP_CONV_FIX(uh, d, 64, 64, uint16)<BR>VFP_CONV_FIX(ul, d, 64, 64, uint32)<BR>VFP_CONV_FIX_A64(uq, d, 64, 64, uint64)<BR>VFP_CONV_FIX(sh, s, 32, 32, int16)<BR>VFP_CONV_FIX(sl, s, 32, 32, int32)<BR>VFP_CONV_FIX_A64(sq, s, 32, 64, int64)<BR>VFP_CONV_FIX(uh, s, 32, 32, uint16)<BR>VFP_CONV_FIX(ul, s, 32, 32, uint32)<BR>VFP_CONV_FIX_A64(uq, s, 32, 64, uint64)<BR>#undef VFP_CONV_FIX<BR>#undef VFP_CONV_FIX_FLOAT<BR>#undef VFP_CONV_FLOAT_FIX_ROUND</P>
<P>/* Set the current fp rounding mode and return the old one.<BR>&nbsp;* The argument is a softfloat float_round_ value.<BR>&nbsp;*/<BR>uint32_t HELPER(set_rmode)(uint32_t rmode, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; float_status *fp_status = &amp;env-&gt;vfp.fp_status;</P>
<P>&nbsp;&nbsp;&nbsp; uint32_t prev_rmode = get_float_rounding_mode(fp_status);<BR>&nbsp;&nbsp;&nbsp; set_float_rounding_mode(rmode, fp_status);</P>
<P>&nbsp;&nbsp;&nbsp; return prev_rmode;<BR>}</P>
<P>/* Set the current fp rounding mode in the standard fp status and return<BR>&nbsp;* the old one. This is for NEON instructions that need to change the<BR>&nbsp;* rounding mode but wish to use the standard FPSCR values for everything<BR>&nbsp;* else. Always set the rounding mode back to the correct value after<BR>&nbsp;* modifying it.<BR>&nbsp;* The argument is a softfloat float_round_ value.<BR>&nbsp;*/<BR>uint32_t HELPER(set_neon_rmode)(uint32_t rmode, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; float_status *fp_status = &amp;env-&gt;vfp.standard_fp_status;</P>
<P>&nbsp;&nbsp;&nbsp; uint32_t prev_rmode = get_float_rounding_mode(fp_status);<BR>&nbsp;&nbsp;&nbsp; set_float_rounding_mode(rmode, fp_status);</P>
<P>&nbsp;&nbsp;&nbsp; return prev_rmode;<BR>}</P>
<P>/* Half precision conversions.&nbsp; */<BR>static float32 do_fcvt_f16_to_f32(uint32_t a, CPUARMState *env, float_status *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; int ieee = (env-&gt;vfp.xregs[ARM_VFP_FPSCR] &amp; (1 &lt;&lt; 26)) == 0;<BR>&nbsp;&nbsp;&nbsp; float32 r = float16_to_float32(make_float16(a), ieee, s);<BR>&nbsp;&nbsp;&nbsp; if (ieee) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float32_maybe_silence_nan(r, s);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return r;<BR>}</P>
<P>static uint32_t do_fcvt_f32_to_f16(float32 a, CPUARMState *env, float_status *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; int ieee = (env-&gt;vfp.xregs[ARM_VFP_FPSCR] &amp; (1 &lt;&lt; 26)) == 0;<BR>&nbsp;&nbsp;&nbsp; float16 r = float32_to_float16(a, ieee, s);<BR>&nbsp;&nbsp;&nbsp; if (ieee) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = float16_maybe_silence_nan(r, s);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return float16_val(r);<BR>}</P>
<P>float32 HELPER(neon_fcvt_f16_to_f32)(uint32_t a, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return do_fcvt_f16_to_f32(a, env, &amp;env-&gt;vfp.standard_fp_status);<BR>}</P>
<P>uint32_t HELPER(neon_fcvt_f32_to_f16)(float32 a, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return do_fcvt_f32_to_f16(a, env, &amp;env-&gt;vfp.standard_fp_status);<BR>}</P>
<P>float32 HELPER(vfp_fcvt_f16_to_f32)(uint32_t a, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return do_fcvt_f16_to_f32(a, env, &amp;env-&gt;vfp.fp_status);<BR>}</P>
<P>uint32_t HELPER(vfp_fcvt_f32_to_f16)(float32 a, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return do_fcvt_f32_to_f16(a, env, &amp;env-&gt;vfp.fp_status);<BR>}</P>
<P>float64 HELPER(vfp_fcvt_f16_to_f64)(uint32_t a, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int ieee = (env-&gt;vfp.xregs[ARM_VFP_FPSCR] &amp; (1 &lt;&lt; 26)) == 0;<BR>&nbsp;&nbsp;&nbsp; float64 r = float16_to_float64(make_float16(a), ieee, &amp;env-&gt;vfp.fp_status);<BR>&nbsp;&nbsp;&nbsp; if (ieee) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float64_maybe_silence_nan(r, &amp;env-&gt;vfp.fp_status);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return r;<BR>}</P>
<P>uint32_t HELPER(vfp_fcvt_f64_to_f16)(float64 a, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int ieee = (env-&gt;vfp.xregs[ARM_VFP_FPSCR] &amp; (1 &lt;&lt; 26)) == 0;<BR>&nbsp;&nbsp;&nbsp; float16 r = float64_to_float16(a, ieee, &amp;env-&gt;vfp.fp_status);<BR>&nbsp;&nbsp;&nbsp; if (ieee) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = float16_maybe_silence_nan(r, &amp;env-&gt;vfp.fp_status);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return float16_val(r);<BR>}</P>
<P>#define float32_two make_float32(0x40000000)<BR>#define float32_three make_float32(0x40400000)<BR>#define float32_one_point_five make_float32(0x3fc00000)</P>
<P>float32 HELPER(recps_f32)(float32 a, float32 b, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; float_status *s = &amp;env-&gt;vfp.standard_fp_status;<BR>&nbsp;&nbsp;&nbsp; if ((float32_is_infinity(a) &amp;&amp; float32_is_zero_or_denormal(b)) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (float32_is_infinity(b) &amp;&amp; float32_is_zero_or_denormal(a))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(float32_is_zero(a) || float32_is_zero(b))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_input_denormal, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float32_two;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return float32_sub(float32_two, float32_mul(a, b, s), s);<BR>}</P>
<P>float32 HELPER(rsqrts_f32)(float32 a, float32 b, CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; float_status *s = &amp;env-&gt;vfp.standard_fp_status;<BR>&nbsp;&nbsp;&nbsp; float32 product;<BR>&nbsp;&nbsp;&nbsp; if ((float32_is_infinity(a) &amp;&amp; float32_is_zero_or_denormal(b)) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (float32_is_infinity(b) &amp;&amp; float32_is_zero_or_denormal(a))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(float32_is_zero(a) || float32_is_zero(b))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_input_denormal, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float32_one_point_five;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; product = float32_mul(a, b, s);<BR>&nbsp;&nbsp;&nbsp; return float32_div(float32_sub(float32_three, product, s), float32_two, s);<BR>}</P>
<P>/* NEON helpers.&nbsp; */</P>
<P>/* Constants 256 and 512 are used in some helpers; we avoid relying on<BR>&nbsp;* int-&gt;float conversions at run-time.&nbsp; */<BR>#define float64_256 make_float64(0x4070000000000000LL)<BR>#define float64_512 make_float64(0x4080000000000000LL)<BR>#define float32_maxnorm make_float32(0x7f7fffff)<BR>#define float64_maxnorm make_float64(0x7fefffffffffffffLL)</P>
<P>/* Reciprocal functions<BR>&nbsp;*<BR>&nbsp;* The algorithm that must be used to calculate the estimate<BR>&nbsp;* is specified by the ARM ARM, see FPRecipEstimate()<BR>&nbsp;*/</P>
<P>static float64 recip_estimate(float64 a, float_status *real_fp_status)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* These calculations mustn't set any fp exception flags,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * so we use a local copy of the fp_status.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; float_status dummy_status = *real_fp_status;<BR>&nbsp;&nbsp;&nbsp; float_status *s = &amp;dummy_status;<BR>&nbsp;&nbsp;&nbsp; /* q = (int)(a * 512.0) */<BR>&nbsp;&nbsp;&nbsp; float64 q = float64_mul(float64_512, a, s);<BR>&nbsp;&nbsp;&nbsp; int64_t q_int = float64_to_int64_round_to_zero(q, s);</P>
<P>&nbsp;&nbsp;&nbsp; /* r = 1.0 / (((double)q + 0.5) / 512.0) */<BR>&nbsp;&nbsp;&nbsp; q = int64_to_float64(q_int, s);<BR>&nbsp;&nbsp;&nbsp; q = float64_add(q, float64_half, s);<BR>&nbsp;&nbsp;&nbsp; q = float64_div(q, float64_512, s);<BR>&nbsp;&nbsp;&nbsp; q = float64_div(float64_one, q, s);</P>
<P>&nbsp;&nbsp;&nbsp; /* s = (int)(256.0 * r + 0.5) */<BR>&nbsp;&nbsp;&nbsp; q = float64_mul(q, float64_256, s);<BR>&nbsp;&nbsp;&nbsp; q = float64_add(q, float64_half, s);<BR>&nbsp;&nbsp;&nbsp; q_int = float64_to_int64_round_to_zero(q, s);</P>
<P>&nbsp;&nbsp;&nbsp; /* return (double)s / 256.0 */<BR>&nbsp;&nbsp;&nbsp; return float64_div(int64_to_float64(q_int, s), float64_256, s);<BR>}</P>
<P>/* Common wrapper to call recip_estimate */<BR>static float64 call_recip_estimate(float64 num, int off, float_status *fpst)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t val64 = float64_val(num);<BR>&nbsp;&nbsp;&nbsp; uint64_t frac = extract64(val64, 0, 52);<BR>&nbsp;&nbsp;&nbsp; int64_t exp = extract64(val64, 52, 11);<BR>&nbsp;&nbsp;&nbsp; uint64_t sbit;<BR>&nbsp;&nbsp;&nbsp; float64 scaled, estimate;</P>
<P>&nbsp;&nbsp;&nbsp; /* Generate the scaled number for the estimate function */<BR>&nbsp;&nbsp;&nbsp; if (exp == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extract64(frac, 51, 1) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exp = -1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frac = extract64(frac, 0, 50) &lt;&lt; 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frac = extract64(frac, 0, 51) &lt;&lt; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* scaled = '0' : '01111111110' : fraction&lt;51:44&gt; : Zeros(44); */<BR>&nbsp;&nbsp;&nbsp; scaled = make_float64((0x3feULL &lt;&lt; 52)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | extract64(frac, 44, 8) &lt;&lt; 44);</P>
<P>&nbsp;&nbsp;&nbsp; estimate = recip_estimate(scaled, fpst);</P>
<P>&nbsp;&nbsp;&nbsp; /* Build new result */<BR>&nbsp;&nbsp;&nbsp; val64 = float64_val(estimate);<BR>&nbsp;&nbsp;&nbsp; sbit = 0x8000000000000000ULL &amp; val64;<BR>&nbsp;&nbsp;&nbsp; exp = off - exp;<BR>&nbsp;&nbsp;&nbsp; frac = extract64(val64, 0, 52);</P>
<P>&nbsp;&nbsp;&nbsp; if (exp == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frac = 1ULL &lt;&lt; 51 | extract64(frac, 1, 51);<BR>&nbsp;&nbsp;&nbsp; } else if (exp == -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frac = 1ULL &lt;&lt; 50 | extract64(frac, 2, 50);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exp = 0;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return make_float64(sbit | (exp &lt;&lt; 52) | frac);<BR>}</P>
<P>static bool round_to_inf(float_status *fpst, bool sign_bit)<BR>{<BR>&nbsp;&nbsp;&nbsp; switch (fpst-&gt;float_rounding_mode) {<BR>&nbsp;&nbsp;&nbsp; case float_round_nearest_even: /* Round to Nearest */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp; case float_round_up: /* Round to +Inf */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return !sign_bit;<BR>&nbsp;&nbsp;&nbsp; case float_round_down: /* Round to -Inf */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sign_bit;<BR>&nbsp;&nbsp;&nbsp; case float_round_to_zero: /* Round to Zero */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>}</P>
<P>float32 HELPER(recpe_f32)(float32 input, void *fpstp)<BR>{<BR>&nbsp;&nbsp;&nbsp; float_status *fpst = fpstp;<BR>&nbsp;&nbsp;&nbsp; float32 f32 = float32_squash_input_denormal(input, fpst);<BR>&nbsp;&nbsp;&nbsp; uint32_t f32_val = float32_val(f32);<BR>&nbsp;&nbsp;&nbsp; uint32_t f32_sbit = 0x80000000ULL &amp; f32_val;<BR>&nbsp;&nbsp;&nbsp; int32_t f32_exp = extract32(f32_val, 23, 8);<BR>&nbsp;&nbsp;&nbsp; uint32_t f32_frac = extract32(f32_val, 0, 23);<BR>&nbsp;&nbsp;&nbsp; float64 f64, r64;<BR>&nbsp;&nbsp;&nbsp; uint64_t r64_val;<BR>&nbsp;&nbsp;&nbsp; int64_t r64_exp;<BR>&nbsp;&nbsp;&nbsp; uint64_t r64_frac;</P>
<P>&nbsp;&nbsp;&nbsp; if (float32_is_any_nan(f32)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float32 nan = f32;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (float32_is_signaling_nan(f32, fpst)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_invalid, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nan = float32_maybe_silence_nan(f32, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fpst-&gt;default_nan_mode) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nan =&nbsp; float32_default_nan(fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nan;<BR>&nbsp;&nbsp;&nbsp; } else if (float32_is_infinity(f32)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float32_set_sign(float32_zero, float32_is_neg(f32));<BR>&nbsp;&nbsp;&nbsp; } else if (float32_is_zero(f32)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_divbyzero, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float32_set_sign(float32_infinity, float32_is_neg(f32));<BR>&nbsp;&nbsp;&nbsp; } else if ((f32_val &amp; ~(1ULL &lt;&lt; 31)) &lt; (1ULL &lt;&lt; 21)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Abs(value) &lt; 2.0^-128 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_overflow | float_flag_inexact, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (round_to_inf(fpst, f32_sbit)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float32_set_sign(float32_infinity, float32_is_neg(f32));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float32_set_sign(float32_maxnorm, float32_is_neg(f32));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else if (f32_exp &gt;= 253 &amp;&amp; fpst-&gt;flush_to_zero) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_underflow, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float32_set_sign(float32_zero, float32_is_neg(f32));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P><BR>&nbsp;&nbsp;&nbsp; f64 = make_float64(((int64_t)(f32_exp) &lt;&lt; 52) | (int64_t)(f32_frac) &lt;&lt; 29);<BR>&nbsp;&nbsp;&nbsp; r64 = call_recip_estimate(f64, 253, fpst);<BR>&nbsp;&nbsp;&nbsp; r64_val = float64_val(r64);<BR>&nbsp;&nbsp;&nbsp; r64_exp = extract64(r64_val, 52, 11);<BR>&nbsp;&nbsp;&nbsp; r64_frac = extract64(r64_val, 0, 52);</P>
<P>&nbsp;&nbsp;&nbsp; /* result = sign : result_exp&lt;7:0&gt; : fraction&lt;51:29&gt;; */<BR>&nbsp;&nbsp;&nbsp; return make_float32(f32_sbit |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (r64_exp &amp; 0xff) &lt;&lt; 23 |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extract64(r64_frac, 29, 24));<BR>}</P>
<P>float64 HELPER(recpe_f64)(float64 input, void *fpstp)<BR>{<BR>&nbsp;&nbsp;&nbsp; float_status *fpst = fpstp;<BR>&nbsp;&nbsp;&nbsp; float64 f64 = float64_squash_input_denormal(input, fpst);<BR>&nbsp;&nbsp;&nbsp; uint64_t f64_val = float64_val(f64);<BR>&nbsp;&nbsp;&nbsp; uint64_t f64_sbit = 0x8000000000000000ULL &amp; f64_val;<BR>&nbsp;&nbsp;&nbsp; int64_t f64_exp = extract64(f64_val, 52, 11);<BR>&nbsp;&nbsp;&nbsp; float64 r64;<BR>&nbsp;&nbsp;&nbsp; uint64_t r64_val;<BR>&nbsp;&nbsp;&nbsp; int64_t r64_exp;<BR>&nbsp;&nbsp;&nbsp; uint64_t r64_frac;</P>
<P>&nbsp;&nbsp;&nbsp; /* Deal with any special cases */<BR>&nbsp;&nbsp;&nbsp; if (float64_is_any_nan(f64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float64 nan = f64;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (float64_is_signaling_nan(f64, fpst)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_invalid, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nan = float64_maybe_silence_nan(f64, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fpst-&gt;default_nan_mode) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nan =&nbsp; float64_default_nan(fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nan;<BR>&nbsp;&nbsp;&nbsp; } else if (float64_is_infinity(f64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float64_set_sign(float64_zero, float64_is_neg(f64));<BR>&nbsp;&nbsp;&nbsp; } else if (float64_is_zero(f64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_divbyzero, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float64_set_sign(float64_infinity, float64_is_neg(f64));<BR>&nbsp;&nbsp;&nbsp; } else if ((f64_val &amp; ~(1ULL &lt;&lt; 63)) &lt; (1ULL &lt;&lt; 50)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Abs(value) &lt; 2.0^-1024 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_overflow | float_flag_inexact, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (round_to_inf(fpst, f64_sbit)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float64_set_sign(float64_infinity, float64_is_neg(f64));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float64_set_sign(float64_maxnorm, float64_is_neg(f64));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else if (f64_exp &gt;= 2045 &amp;&amp; fpst-&gt;flush_to_zero) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_underflow, fpst);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float64_set_sign(float64_zero, float64_is_neg(f64));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; r64 = call_recip_estimate(f64, 2045, fpst);<BR>&nbsp;&nbsp;&nbsp; r64_val = float64_val(r64);<BR>&nbsp;&nbsp;&nbsp; r64_exp = extract64(r64_val, 52, 11);<BR>&nbsp;&nbsp;&nbsp; r64_frac = extract64(r64_val, 0, 52);</P>
<P>&nbsp;&nbsp;&nbsp; /* result = sign : result_exp&lt;10:0&gt; : fraction&lt;51:0&gt; */<BR>&nbsp;&nbsp;&nbsp; return make_float64(f64_sbit |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((r64_exp &amp; 0x7ff) &lt;&lt; 52) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r64_frac);<BR>}</P>
<P>/* The algorithm that must be used to calculate the estimate<BR>&nbsp;* is specified by the ARM ARM.<BR>&nbsp;*/<BR>static float64 recip_sqrt_estimate(float64 a, float_status *real_fp_status)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* These calculations mustn't set any fp exception flags,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * so we use a local copy of the fp_status.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; float_status dummy_status = *real_fp_status;<BR>&nbsp;&nbsp;&nbsp; float_status *s = &amp;dummy_status;<BR>&nbsp;&nbsp;&nbsp; float64 q;<BR>&nbsp;&nbsp;&nbsp; int64_t q_int;</P>
<P>&nbsp;&nbsp;&nbsp; if (float64_lt(a, float64_half, s)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* range 0.25 &lt;= a &lt; 0.5 */</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* a in units of 1/512 rounded down */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* q0 = (int)(a * 512.0);&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = float64_mul(float64_512, a, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q_int = float64_to_int64_round_to_zero(q, s);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* reciprocal root r */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* r = 1.0 / sqrt(((double)q0 + 0.5) / 512.0);&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = int64_to_float64(q_int, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = float64_add(q, float64_half, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = float64_div(q, float64_512, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = float64_sqrt(q, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = float64_div(float64_one, q, s);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* range 0.5 &lt;= a &lt; 1.0 */</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* a in units of 1/256 rounded down */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* q1 = (int)(a * 256.0); */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = float64_mul(float64_256, a, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int64_t q_int = float64_to_int64_round_to_zero(q, s);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* reciprocal root r */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* r = 1.0 /sqrt(((double)q1 + 0.5) / 256); */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = int64_to_float64(q_int, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = float64_add(q, float64_half, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = float64_div(q, float64_256, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = float64_sqrt(q, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q = float64_div(float64_one, q, s);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* r in units of 1/256 rounded to nearest */<BR>&nbsp;&nbsp;&nbsp; /* s = (int)(256.0 * r + 0.5); */</P>
<P>&nbsp;&nbsp;&nbsp; q = float64_mul(q, float64_256,s );<BR>&nbsp;&nbsp;&nbsp; q = float64_add(q, float64_half, s);<BR>&nbsp;&nbsp;&nbsp; q_int = float64_to_int64_round_to_zero(q, s);</P>
<P>&nbsp;&nbsp;&nbsp; /* return (double)s / 256.0;*/<BR>&nbsp;&nbsp;&nbsp; return float64_div(int64_to_float64(q_int, s), float64_256, s);<BR>}</P>
<P>float32 HELPER(rsqrte_f32)(float32 input, void *fpstp)<BR>{<BR>&nbsp;&nbsp;&nbsp; float_status *s = fpstp;<BR>&nbsp;&nbsp;&nbsp; float32 f32 = float32_squash_input_denormal(input, s);<BR>&nbsp;&nbsp;&nbsp; uint32_t val = float32_val(f32);<BR>&nbsp;&nbsp;&nbsp; uint32_t f32_sbit = 0x80000000 &amp; val;<BR>&nbsp;&nbsp;&nbsp; int32_t f32_exp = extract32(val, 23, 8);<BR>&nbsp;&nbsp;&nbsp; uint32_t f32_frac = extract32(val, 0, 23);<BR>&nbsp;&nbsp;&nbsp; uint64_t f64_frac;<BR>&nbsp;&nbsp;&nbsp; uint64_t val64;<BR>&nbsp;&nbsp;&nbsp; int result_exp;<BR>&nbsp;&nbsp;&nbsp; float64 f64;</P>
<P>&nbsp;&nbsp;&nbsp; if (float32_is_any_nan(f32)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float32 nan = f32;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (float32_is_signaling_nan(f32, s)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_invalid, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nan = float32_maybe_silence_nan(f32, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s-&gt;default_nan_mode) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nan =&nbsp; float32_default_nan(s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nan;<BR>&nbsp;&nbsp;&nbsp; } else if (float32_is_zero(f32)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_divbyzero, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float32_set_sign(float32_infinity, float32_is_neg(f32));<BR>&nbsp;&nbsp;&nbsp; } else if (float32_is_neg(f32)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_invalid, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float32_default_nan(s);<BR>&nbsp;&nbsp;&nbsp; } else if (float32_is_infinity(f32)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float32_zero;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Scale and normalize to a double-precision value between 0.25 and 1.0,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * preserving the parity of the exponent.&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp; f64_frac = ((uint64_t) f32_frac) &lt;&lt; 29;<BR>&nbsp;&nbsp;&nbsp; if (f32_exp == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (extract64(f64_frac, 51, 1) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f64_frac = f64_frac &lt;&lt; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f32_exp = f32_exp-1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f64_frac = extract64(f64_frac, 0, 51) &lt;&lt; 1;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (extract64(f32_exp, 0, 1) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f64 = make_float64(((uint64_t) f32_sbit) &lt;&lt; 32<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (0x3feULL &lt;&lt; 52)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | f64_frac);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f64 = make_float64(((uint64_t) f32_sbit) &lt;&lt; 32<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (0x3fdULL &lt;&lt; 52)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | f64_frac);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; result_exp = (380 - f32_exp) / 2;</P>
<P>&nbsp;&nbsp;&nbsp; f64 = recip_sqrt_estimate(f64, s);</P>
<P>&nbsp;&nbsp;&nbsp; val64 = float64_val(f64);</P>
<P>&nbsp;&nbsp;&nbsp; val = ((result_exp &amp; 0xff) &lt;&lt; 23)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ((val64 &gt;&gt; 29)&nbsp; &amp; 0x7fffff);<BR>&nbsp;&nbsp;&nbsp; return make_float32(val);<BR>}</P>
<P>float64 HELPER(rsqrte_f64)(float64 input, void *fpstp)<BR>{<BR>&nbsp;&nbsp;&nbsp; float_status *s = fpstp;<BR>&nbsp;&nbsp;&nbsp; float64 f64 = float64_squash_input_denormal(input, s);<BR>&nbsp;&nbsp;&nbsp; uint64_t val = float64_val(f64);<BR>&nbsp;&nbsp;&nbsp; uint64_t f64_sbit = 0x8000000000000000ULL &amp; val;<BR>&nbsp;&nbsp;&nbsp; int64_t f64_exp = extract64(val, 52, 11);<BR>&nbsp;&nbsp;&nbsp; uint64_t f64_frac = extract64(val, 0, 52);<BR>&nbsp;&nbsp;&nbsp; int64_t result_exp;<BR>&nbsp;&nbsp;&nbsp; uint64_t result_frac;</P>
<P>&nbsp;&nbsp;&nbsp; if (float64_is_any_nan(f64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float64 nan = f64;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (float64_is_signaling_nan(f64, s)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_invalid, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nan = float64_maybe_silence_nan(f64, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s-&gt;default_nan_mode) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nan =&nbsp; float64_default_nan(s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nan;<BR>&nbsp;&nbsp;&nbsp; } else if (float64_is_zero(f64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_divbyzero, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float64_set_sign(float64_infinity, float64_is_neg(f64));<BR>&nbsp;&nbsp;&nbsp; } else if (float64_is_neg(f64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_raise(float_flag_invalid, s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float64_default_nan(s);<BR>&nbsp;&nbsp;&nbsp; } else if (float64_is_infinity(f64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return float64_zero;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Scale and normalize to a double-precision value between 0.25 and 1.0,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * preserving the parity of the exponent.&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp; if (f64_exp == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (extract64(f64_frac, 51, 1) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f64_frac = f64_frac &lt;&lt; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f64_exp = f64_exp - 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f64_frac = extract64(f64_frac, 0, 51) &lt;&lt; 1;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (extract64(f64_exp, 0, 1) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f64 = make_float64(f64_sbit<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (0x3feULL &lt;&lt; 52)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | f64_frac);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f64 = make_float64(f64_sbit<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (0x3fdULL &lt;&lt; 52)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | f64_frac);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; result_exp = (3068 - f64_exp) / 2;</P>
<P>&nbsp;&nbsp;&nbsp; f64 = recip_sqrt_estimate(f64, s);</P>
<P>&nbsp;&nbsp;&nbsp; result_frac = extract64(float64_val(f64), 0, 52);</P>
<P>&nbsp;&nbsp;&nbsp; return make_float64(f64_sbit |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((result_exp &amp; 0x7ff) &lt;&lt; 52) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result_frac);<BR>}</P>
<P>uint32_t HELPER(recpe_u32)(uint32_t a, void *fpstp)<BR>{<BR>&nbsp;&nbsp;&nbsp; float_status *s = fpstp;<BR>&nbsp;&nbsp;&nbsp; float64 f64;</P>
<P>&nbsp;&nbsp;&nbsp; if ((a &amp; 0x80000000) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0xffffffff;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; f64 = make_float64((0x3feULL &lt;&lt; 52)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ((int64_t)(a &amp; 0x7fffffff) &lt;&lt; 21));</P>
<P>&nbsp;&nbsp;&nbsp; f64 = recip_estimate(f64, s);</P>
<P>&nbsp;&nbsp;&nbsp; return 0x80000000 | ((float64_val(f64) &gt;&gt; 21) &amp; 0x7fffffff);<BR>}</P>
<P>uint32_t HELPER(rsqrte_u32)(uint32_t a, void *fpstp)<BR>{<BR>&nbsp;&nbsp;&nbsp; float_status *fpst = fpstp;<BR>&nbsp;&nbsp;&nbsp; float64 f64;</P>
<P>&nbsp;&nbsp;&nbsp; if ((a &amp; 0xc0000000) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0xffffffff;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (a &amp; 0x80000000) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f64 = make_float64((0x3feULL &lt;&lt; 52)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ((uint64_t)(a &amp; 0x7fffffff) &lt;&lt; 21));<BR>&nbsp;&nbsp;&nbsp; } else { /* bits 31-30 == '01' */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f64 = make_float64((0x3fdULL &lt;&lt; 52)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ((uint64_t)(a &amp; 0x3fffffff) &lt;&lt; 22));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; f64 = recip_sqrt_estimate(f64, fpst);</P>
<P>&nbsp;&nbsp;&nbsp; return 0x80000000 | ((float64_val(f64) &gt;&gt; 21) &amp; 0x7fffffff);<BR>}</P>
<P>/* VFPv4 fused multiply-accumulate */<BR>float32 VFP_HELPER(muladd, s)(float32 a, float32 b, float32 c, void *fpstp)<BR>{<BR>&nbsp;&nbsp;&nbsp; float_status *fpst = fpstp;<BR>&nbsp;&nbsp;&nbsp; return float32_muladd(a, b, c, 0, fpst);<BR>}</P>
<P>float64 VFP_HELPER(muladd, d)(float64 a, float64 b, float64 c, void *fpstp)<BR>{<BR>&nbsp;&nbsp;&nbsp; float_status *fpst = fpstp;<BR>&nbsp;&nbsp;&nbsp; return float64_muladd(a, b, c, 0, fpst);<BR>}</P>
<P>/* ARMv8 round to integral */<BR>float32 HELPER(rints_exact)(float32 x, void *fp_status)<BR>{<BR>&nbsp;&nbsp;&nbsp; return float32_round_to_int(x, fp_status);<BR>}</P>
<P>float64 HELPER(rintd_exact)(float64 x, void *fp_status)<BR>{<BR>&nbsp;&nbsp;&nbsp; return float64_round_to_int(x, fp_status);<BR>}</P>
<P>float32 HELPER(rints)(float32 x, void *fp_status)<BR>{<BR>&nbsp;&nbsp;&nbsp; int old_flags = get_float_exception_flags(fp_status), new_flags;<BR>&nbsp;&nbsp;&nbsp; float32 ret;</P>
<P>&nbsp;&nbsp;&nbsp; ret = float32_round_to_int(x, fp_status);</P>
<P>&nbsp;&nbsp;&nbsp; /* Suppress any inexact exceptions the conversion produced */<BR>&nbsp;&nbsp;&nbsp; if (!(old_flags &amp; float_flag_inexact)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_flags = get_float_exception_flags(fp_status);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_float_exception_flags(new_flags &amp; ~float_flag_inexact, fp_status);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return ret;<BR>}</P>
<P>float64 HELPER(rintd)(float64 x, void *fp_status)<BR>{<BR>&nbsp;&nbsp;&nbsp; int old_flags = get_float_exception_flags(fp_status), new_flags;<BR>&nbsp;&nbsp;&nbsp; float64 ret;</P>
<P>&nbsp;&nbsp;&nbsp; ret = float64_round_to_int(x, fp_status);</P>
<P>&nbsp;&nbsp;&nbsp; new_flags = get_float_exception_flags(fp_status);</P>
<P>&nbsp;&nbsp;&nbsp; /* Suppress any inexact exceptions the conversion produced */<BR>&nbsp;&nbsp;&nbsp; if (!(old_flags &amp; float_flag_inexact)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_flags = get_float_exception_flags(fp_status);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_float_exception_flags(new_flags &amp; ~float_flag_inexact, fp_status);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return ret;<BR>}</P>
<P>/* Convert ARM rounding mode to softfloat */<BR>int arm_rmode_to_sf(int rmode)<BR>{<BR>&nbsp;&nbsp;&nbsp; switch (rmode) {<BR>&nbsp;&nbsp;&nbsp; case FPROUNDING_TIEAWAY:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rmode = float_round_ties_away;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case FPROUNDING_ODD:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* FIXME: add support for TIEAWAY and ODD */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_log_mask(LOG_UNIMP, "arm: unimplemented rounding mode: %d\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rmode);<BR>&nbsp;&nbsp;&nbsp; case FPROUNDING_TIEEVEN:<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rmode = float_round_nearest_even;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case FPROUNDING_POSINF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rmode = float_round_up;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case FPROUNDING_NEGINF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rmode = float_round_down;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case FPROUNDING_ZERO:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rmode = float_round_to_zero;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return rmode;<BR>}</P>
<P>/* CRC helpers.<BR>&nbsp;* The upper bytes of val (above the number specified by 'bytes') must have<BR>&nbsp;* been zeroed out by the caller.<BR>&nbsp;*/<BR>uint32_t HELPER(crc32)(uint32_t acc, uint32_t val, uint32_t bytes)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t buf[4];</P>
<P>&nbsp;&nbsp;&nbsp; stl_le_p(buf, val);</P>
<P>&nbsp;&nbsp;&nbsp; /* zlib crc32 converts the accumulator and output to one's complement.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; return crc32(acc ^ 0xffffffff, buf, bytes) ^ 0xffffffff;<BR>}</P>
<P>uint32_t HELPER(crc32c)(uint32_t acc, uint32_t val, uint32_t bytes)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint8_t buf[4];</P>
<P>&nbsp;&nbsp;&nbsp; stl_le_p(buf, val);</P>
<P>&nbsp;&nbsp;&nbsp; /* Linux crc32c converts the output to one's complement.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; return crc32c(acc, buf, bytes) ^ 0xffffffff;<BR>}