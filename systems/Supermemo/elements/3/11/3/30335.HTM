/* Note: we convert the 64 bit args to 32 bit and do some alignment<BR>&nbsp;&nbsp; and endian swap. Maybe it would be better to do the alignment<BR>&nbsp;&nbsp; and endian swap in tcg_reg_alloc_call(). */<BR>void tcg_gen_callN(TCGContext *s, void *func, TCGArg ret,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nargs, TCGArg *args)<BR>{<BR>&nbsp;&nbsp;&nbsp; int i, real_args, nb_rets, pi, pi_first;<BR>&nbsp;&nbsp;&nbsp; unsigned sizemask, flags;<BR>&nbsp;&nbsp;&nbsp; TCGHelperInfo *info;
<P></P>
<P>&nbsp;&nbsp;&nbsp; info = g_hash_table_lookup(s-&gt;helpers, (gpointer)func);<BR>&nbsp;&nbsp;&nbsp; flags = info-&gt;flags;<BR>&nbsp;&nbsp;&nbsp; sizemask = info-&gt;sizemask;</P>
<P>#if defined(__sparc__) &amp;&amp; !defined(__arch64__) \<BR>&nbsp;&nbsp;&nbsp; &amp;&amp; !defined(CONFIG_TCG_INTERPRETER)<BR>&nbsp;&nbsp;&nbsp; /* We have 64-bit values in one register, but need to pass as two<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; separate parameters.&nbsp; Split them.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int orig_sizemask = sizemask;<BR>&nbsp;&nbsp;&nbsp; int orig_nargs = nargs;<BR>&nbsp;&nbsp;&nbsp; TCGv_i64 retl, reth;</P>
<P>&nbsp;&nbsp;&nbsp; TCGV_UNUSED_I64(retl);<BR>&nbsp;&nbsp;&nbsp; TCGV_UNUSED_I64(reth);<BR>&nbsp;&nbsp;&nbsp; if (sizemask != 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg *split_args = __builtin_alloca(sizeof(TCGArg) * nargs * 2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = real_args = 0; i &lt; nargs; ++i) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int is_64bit = sizemask &amp; (1 &lt;&lt; (i+1)*2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_64bit) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 orig = MAKE_TCGV_I64(args[i]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 h = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 l = tcg_temp_new_i32();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_extr_i64_i32(l, h, orig);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; split_args[real_args++] = GET_TCGV_I32(h);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; split_args[real_args++] = GET_TCGV_I32(l);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; split_args[real_args++] = args[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nargs = real_args;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args = split_args;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizemask = 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TCG_TARGET_EXTEND_ARGS) &amp;&amp; TCG_TARGET_REG_BITS == 64<BR>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; nargs; ++i) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int is_64bit = sizemask &amp; (1 &lt;&lt; (i+1)*2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int is_signed = sizemask &amp; (2 &lt;&lt; (i+1)*2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!is_64bit) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 temp = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 orig = MAKE_TCGV_I64(args[i]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_signed) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ext32s_i64(temp, orig);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_ext32u_i64(temp, orig);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args[i] = GET_TCGV_I64(temp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>#endif /* TCG_TARGET_EXTEND_ARGS */</P>
<P>&nbsp;&nbsp;&nbsp; pi_first = pi = s-&gt;gen_next_parm_idx;<BR>&nbsp;&nbsp;&nbsp; if (ret != TCG_CALL_DUMMY_ARG) {<BR>#if defined(__sparc__) &amp;&amp; !defined(__arch64__) \<BR>&nbsp;&nbsp;&nbsp; &amp;&amp; !defined(CONFIG_TCG_INTERPRETER)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (orig_sizemask &amp; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The 32-bit ABI is going to return the 64-bit value in<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the %o0/%o1 register pair.&nbsp; Prepare for this by using<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; two return temporaries, and reassemble below.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retl = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reth = tcg_temp_new_i64();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = GET_TCGV_I64(reth);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = GET_TCGV_I64(retl);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nb_rets = 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = ret;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nb_rets = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS &lt; 64 &amp;&amp; (sizemask &amp; 1)) {<BR>#ifdef HOST_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = ret + 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = ret;<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = ret;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = ret + 1;<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nb_rets = 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = ret;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nb_rets = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nb_rets = 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; real_args = 0;<BR>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; nargs; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int is_64bit = sizemask &amp; (1 &lt;&lt; (i+1)*2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS &lt; 64 &amp;&amp; is_64bit) {<BR>#ifdef TCG_TARGET_CALL_ALIGN_ARGS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* some targets want aligned 64 bit args */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (real_args &amp; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = TCG_CALL_DUMMY_ARG;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real_args++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If stack grows up, then we will be placing successive<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arguments at lower addresses, which means we need to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reverse the order compared to how we would normally<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; treat either big or little-endian.&nbsp; For those arguments<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; that will wind up in registers, this still works for<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HPPA (the only current STACK_GROWSUP target) since the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; argument registers are *also* allocated in decreasing<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; order.&nbsp; If another such target is added, this logic may<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; have to get more complicated to differentiate between<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack arguments and register arguments.&nbsp; */<BR>#if defined(HOST_WORDS_BIGENDIAN) != defined(TCG_TARGET_STACK_GROWSUP)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = args[i] + 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = args[i];<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = args[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = args[i] + 1;<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real_args += 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = args[i];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real_args++;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = (uintptr_t)func;<BR>&nbsp;&nbsp;&nbsp; s-&gt;gen_opparam_buf[pi++] = flags;</P>
<P>&nbsp;&nbsp;&nbsp; i = s-&gt;gen_next_op_idx;<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(i &lt; OPC_BUF_SIZE);<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(pi &lt;= OPPARAM_BUF_SIZE);</P>
<P>&nbsp;&nbsp;&nbsp; /* Set links for sequential allocation during translation.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; s-&gt;gen_op_buf[i] = (TCGOp){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .opc = INDEX_op_call,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .callo = nb_rets,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .calli = real_args,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .args = pi_first,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .prev = i - 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .next = i + 1<BR>&nbsp;&nbsp;&nbsp; };</P>
<P>&nbsp;&nbsp;&nbsp; /* Make sure the calli field didn't overflow.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_debug_assert(s-&gt;gen_op_buf[i].calli == real_args);</P>
<P>&nbsp;&nbsp;&nbsp; s-&gt;gen_op_buf[0].prev = i;<BR>&nbsp;&nbsp;&nbsp; s-&gt;gen_next_op_idx = i + 1;<BR>&nbsp;&nbsp;&nbsp; s-&gt;gen_next_parm_idx = pi;</P>
<P>#if defined(__sparc__) &amp;&amp; !defined(__arch64__) \<BR>&nbsp;&nbsp;&nbsp; &amp;&amp; !defined(CONFIG_TCG_INTERPRETER)<BR>&nbsp;&nbsp;&nbsp; /* Free all of the parts we allocated above.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; for (i = real_args = 0; i &lt; orig_nargs; ++i) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int is_64bit = orig_sizemask &amp; (1 &lt;&lt; (i+1)*2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_64bit) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 h = MAKE_TCGV_I32(args[real_args++]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i32 l = MAKE_TCGV_I32(args[real_args++]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(h);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i32(l);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real_args++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (orig_sizemask &amp; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The 32-bit ABI returned two 32-bit pieces.&nbsp; Re-assemble them.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note that describing these as TCGv_i64 eliminates an unnecessary<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zero-extension that tcg_gen_concat_i32_i64 would create.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_gen_concat32_i64(MAKE_TCGV_I64(ret), retl, reth);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(retl);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(reth);<BR>&nbsp;&nbsp;&nbsp; }<BR>#elif defined(TCG_TARGET_EXTEND_ARGS) &amp;&amp; TCG_TARGET_REG_BITS == 64<BR>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; nargs; ++i) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int is_64bit = sizemask &amp; (1 &lt;&lt; (i+1)*2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!is_64bit) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGv_i64 temp = MAKE_TCGV_I64(args[i]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_temp_free_i64(temp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>#endif /* TCG_TARGET_EXTEND_ARGS */<BR>}