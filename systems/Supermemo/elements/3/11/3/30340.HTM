# target-arm/cpu.c
<P></P>
<P>/*<BR>&nbsp;* QEMU ARM CPU<BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2012 SUSE LINUX Products GmbH<BR>&nbsp;*<BR>&nbsp;* This program is free software; you can redistribute it and/or<BR>&nbsp;* modify it under the terms of the GNU General Public License<BR>&nbsp;* as published by the Free Software Foundation; either version 2<BR>&nbsp;* of the License, or (at your option) any later version.<BR>&nbsp;*<BR>&nbsp;* This program is distributed in the hope that it will be useful,<BR>&nbsp;* but WITHOUT ANY WARRANTY; without even the implied warranty of<BR>&nbsp;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp; See the<BR>&nbsp;* GNU General Public License for more details.<BR>&nbsp;*<BR>&nbsp;* You should have received a copy of the GNU General Public License<BR>&nbsp;* along with this program; if not, see<BR>&nbsp;* &lt;<A href="http://www.gnu.org/licenses/gpl-2.0.html">http://www.gnu.org/licenses/gpl-2.0.html</A>&gt;<BR>&nbsp;*/</P>
<P></P>
<P>#include "qemu/osdep.h"<BR>#include "qapi/error.h"<BR>#include "cpu.h"<BR>#include "internals.h"<BR>#include "qemu-common.h"<BR>#include "exec/exec-all.h"<BR>#include "hw/qdev-properties.h"<BR>#if !defined(CONFIG_USER_ONLY)<BR>#include "hw/loader.h"<BR>#endif<BR>#include "hw/arm/arm.h"<BR>#include "sysemu/sysemu.h"<BR>#include "sysemu/kvm.h"<BR>#include "kvm_arm.h"</P>
<P>static void arm_cpu_set_pc(CPUState *cs, vaddr value)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;env.regs[15] = value;<BR>}</P>
<P>static bool arm_cpu_has_work(CPUState *cs)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);</P>
<P>&nbsp;&nbsp;&nbsp; return !cpu-&gt;powered_off<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; cs-&gt;interrupt_request &amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (CPU_INTERRUPT_FIQ | CPU_INTERRUPT_HARD<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | CPU_INTERRUPT_VFIQ | CPU_INTERRUPT_VIRQ<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | CPU_INTERRUPT_EXITTB);<BR>}</P>
<P>void arm_register_el_change_hook(ARMCPU *cpu, ARMELChangeHook *hook,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* We currently only support registering a single hook function */<BR>&nbsp;&nbsp;&nbsp; assert(!cpu-&gt;el_change_hook);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;el_change_hook = hook;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;el_change_hook_opaque = opaque;<BR>}</P>
<P>static void cp_reg_reset(gpointer key, gpointer value, gpointer opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Reset a single ARMCPRegInfo register */<BR>&nbsp;&nbsp;&nbsp; ARMCPRegInfo *ri = value;<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;</P>
<P>&nbsp;&nbsp;&nbsp; if (ri-&gt;type &amp; (ARM_CP_SPECIAL | ARM_CP_ALIAS)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (ri-&gt;resetfn) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ri-&gt;resetfn(&amp;cpu-&gt;env, ri);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* A zero offset is never possible as it would be regs[0]<BR>&nbsp;&nbsp;&nbsp;&nbsp; * so we use it to indicate that reset is being handled elsewhere.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This is basically only used for fields in non-core coprocessors<BR>&nbsp;&nbsp;&nbsp;&nbsp; * (like the pxa2xx ones).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!ri-&gt;fieldoffset) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (cpreg_field_is_64bit(ri)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPREG_FIELD64(&amp;cpu-&gt;env, ri) = ri-&gt;resetvalue;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPREG_FIELD32(&amp;cpu-&gt;env, ri) = ri-&gt;resetvalue;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void cp_reg_check_reset(gpointer key, gpointer value,&nbsp; gpointer opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Purely an assertion check: we've already done reset once,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * so now check that running the reset for the cpreg doesn't<BR>&nbsp;&nbsp;&nbsp;&nbsp; * change its value. This traps bugs where two different cpregs<BR>&nbsp;&nbsp;&nbsp;&nbsp; * both try to reset the same state field but to different values.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARMCPRegInfo *ri = value;<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; uint64_t oldvalue, newvalue;</P>
<P>&nbsp;&nbsp;&nbsp; if (ri-&gt;type &amp; (ARM_CP_SPECIAL | ARM_CP_ALIAS | ARM_CP_NO_RAW)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; oldvalue = read_raw_cp_reg(&amp;cpu-&gt;env, ri);<BR>&nbsp;&nbsp;&nbsp; cp_reg_reset(key, value, opaque);<BR>&nbsp;&nbsp;&nbsp; newvalue = read_raw_cp_reg(&amp;cpu-&gt;env, ri);<BR>&nbsp;&nbsp;&nbsp; assert(oldvalue == newvalue);<BR>}</P>
<P>/* CPUClass::reset() */<BR>static void arm_cpu_reset(CPUState *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(s);<BR>&nbsp;&nbsp;&nbsp; ARMCPUClass *acc = ARM_CPU_GET_CLASS(cpu);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; acc-&gt;parent_reset(s);</P>
<P>&nbsp;&nbsp;&nbsp; memset(env, 0, offsetof(CPUARMState, features));<BR>&nbsp;&nbsp;&nbsp; g_hash_table_foreach(cpu-&gt;cp_regs, cp_reg_reset, cpu);<BR>&nbsp;&nbsp;&nbsp; g_hash_table_foreach(cpu-&gt;cp_regs, cp_reg_check_reset, cpu);</P>
<P>&nbsp;&nbsp;&nbsp; env-&gt;vfp.xregs[ARM_VFP_FPSID] = cpu-&gt;reset_fpsid;<BR>&nbsp;&nbsp;&nbsp; env-&gt;vfp.xregs[ARM_VFP_MVFR0] = cpu-&gt;mvfr0;<BR>&nbsp;&nbsp;&nbsp; env-&gt;vfp.xregs[ARM_VFP_MVFR1] = cpu-&gt;mvfr1;<BR>&nbsp;&nbsp;&nbsp; env-&gt;vfp.xregs[ARM_VFP_MVFR2] = cpu-&gt;mvfr2;</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;powered_off = cpu-&gt;start_powered_off;<BR>&nbsp;&nbsp;&nbsp; s-&gt;halted = cpu-&gt;start_powered_off;</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_IWMMXT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;iwmmxt.cregs[ARM_IWMMXT_wCID] = 0x69051000 | 'Q';<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_AARCH64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 64 bit CPUs always start in 64 bit mode */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;aarch64 = 1;<BR>#if defined(CONFIG_USER_ONLY)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pstate = PSTATE_MODE_EL0t;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Userspace expects access to DC ZVA, CTL_EL0 and the cache ops */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.sctlr_el[1] |= SCTLR_UCT | SCTLR_UCI | SCTLR_DZE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* and to the FP/Neon instructions */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.cpacr_el1 = deposit64(env-&gt;cp15.cpacr_el1, 20, 2, 3);<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Reset into the highest available EL */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pstate = PSTATE_MODE_EL3h;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (arm_feature(env, ARM_FEATURE_EL2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pstate = PSTATE_MODE_EL2h;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pstate = PSTATE_MODE_EL1h;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pc = cpu-&gt;rvbar;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; } else {<BR>#if defined(CONFIG_USER_ONLY)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Userspace expects access to cp10 and cp11 for FP/Neon */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.cpacr_el1 = deposit64(env-&gt;cp15.cpacr_el1, 20, 4, 0xf);<BR>#endif<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>#if defined(CONFIG_USER_ONLY)<BR>&nbsp;&nbsp;&nbsp; env-&gt;uncached_cpsr = ARM_CPU_MODE_USR;<BR>&nbsp;&nbsp;&nbsp; /* For user mode we must enable access to coprocessors */<BR>&nbsp;&nbsp;&nbsp; env-&gt;vfp.xregs[ARM_VFP_FPEXC] = 1 &lt;&lt; 30;<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_IWMMXT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.c15_cpar = 3;<BR>&nbsp;&nbsp;&nbsp; } else if (arm_feature(env, ARM_FEATURE_XSCALE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.c15_cpar = 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>#else<BR>&nbsp;&nbsp;&nbsp; /* SVC mode with interrupts disabled.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; env-&gt;uncached_cpsr = ARM_CPU_MODE_SVC;<BR>&nbsp;&nbsp;&nbsp; env-&gt;daif = PSTATE_D | PSTATE_A | PSTATE_I | PSTATE_F;<BR>&nbsp;&nbsp;&nbsp; /* On ARMv7-M the CPSR_I is the value of the PRIMASK register, and is<BR>&nbsp;&nbsp;&nbsp;&nbsp; * clear at reset. Initial SP and PC are loaded from ROM.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (IS_M(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t initial_msp; /* Loaded from 0x0 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t initial_pc; /* Loaded from 0x4 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint8_t *rom;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;daif &amp;= ~PSTATE_I;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rom = rom_ptr(0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rom) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Address zero is covered by ROM which hasn't yet been<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * copied into physical memory.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initial_msp = ldl_p(rom);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initial_pc = ldl_p(rom + 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Address zero not covered by a ROM blob, or the ROM blob<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * is in non-modifiable memory and this is a second reset after<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * it got copied into memory. In the latter case, rom_ptr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * will return a NULL pointer and we should use ldl_phys instead.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initial_msp = ldl_phys(s-&gt;as, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initial_pc = ldl_phys(s-&gt;as, 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = initial_msp &amp; 0xFFFFFFFC;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[15] = initial_pc &amp; ~1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;thumb = initial_pc &amp; 1;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* AArch32 has a hard highvec setting of 0xFFFF0000.&nbsp; If we are currently<BR>&nbsp;&nbsp;&nbsp;&nbsp; * executing as AArch32 then check if highvecs are enabled and<BR>&nbsp;&nbsp;&nbsp;&nbsp; * adjust the PC accordingly.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (A32_BANKED_CURRENT_REG_GET(env, sctlr) &amp; SCTLR_V) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[15] = 0xFFFF0000;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; env-&gt;vfp.xregs[ARM_VFP_FPEXC] = 0;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; set_flush_to_zero(1, &amp;env-&gt;vfp.standard_fp_status);<BR>&nbsp;&nbsp;&nbsp; set_flush_inputs_to_zero(1, &amp;env-&gt;vfp.standard_fp_status);<BR>&nbsp;&nbsp;&nbsp; set_default_nan_mode(1, &amp;env-&gt;vfp.standard_fp_status);<BR>&nbsp;&nbsp;&nbsp; set_float_detect_tininess(float_tininess_before_rounding,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;env-&gt;vfp.fp_status);<BR>&nbsp;&nbsp;&nbsp; set_float_detect_tininess(float_tininess_before_rounding,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;env-&gt;vfp.standard_fp_status);<BR>&nbsp;&nbsp;&nbsp; tlb_flush(s, 1);</P>
<P>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; if (kvm_enabled()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kvm_arm_reset_vcpu(cpu);<BR>&nbsp;&nbsp;&nbsp; }<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; hw_breakpoint_update_all(cpu);<BR>&nbsp;&nbsp;&nbsp; hw_watchpoint_update_all(cpu);<BR>}</P>
<P>bool arm_cpu_exec_interrupt(CPUState *cs, int interrupt_request)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUClass *cc = CPU_GET_CLASS(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = cs-&gt;env_ptr;<BR>&nbsp;&nbsp;&nbsp; uint32_t cur_el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; bool secure = arm_is_secure(env);<BR>&nbsp;&nbsp;&nbsp; uint32_t target_el;<BR>&nbsp;&nbsp;&nbsp; uint32_t excp_idx;<BR>&nbsp;&nbsp;&nbsp; bool ret = false;</P>
<P>&nbsp;&nbsp;&nbsp; if (interrupt_request &amp; CPU_INTERRUPT_FIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; excp_idx = EXCP_FIQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = arm_phys_excp_target_el(cs, excp_idx, cur_el, secure);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_excp_unmasked(cs, excp_idx, target_el)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = excp_idx;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.target_el = target_el;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc-&gt;do_interrupt(cs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (interrupt_request &amp; CPU_INTERRUPT_HARD) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; excp_idx = EXCP_IRQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = arm_phys_excp_target_el(cs, excp_idx, cur_el, secure);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_excp_unmasked(cs, excp_idx, target_el)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = excp_idx;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.target_el = target_el;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc-&gt;do_interrupt(cs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (interrupt_request &amp; CPU_INTERRUPT_VIRQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; excp_idx = EXCP_VIRQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_excp_unmasked(cs, excp_idx, target_el)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = excp_idx;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.target_el = target_el;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc-&gt;do_interrupt(cs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (interrupt_request &amp; CPU_INTERRUPT_VFIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; excp_idx = EXCP_VFIQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_excp_unmasked(cs, excp_idx, target_el)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = excp_idx;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.target_el = target_el;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc-&gt;do_interrupt(cs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return ret;<BR>}</P>
<P>#if !defined(CONFIG_USER_ONLY) || !defined(TARGET_AARCH64)<BR>static bool arm_v7m_cpu_exec_interrupt(CPUState *cs, int interrupt_request)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUClass *cc = CPU_GET_CLASS(cs);<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; bool ret = false;</P>
<P><BR>&nbsp;&nbsp;&nbsp; if (interrupt_request &amp; CPU_INTERRUPT_FIQ<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !(env-&gt;daif &amp; PSTATE_F)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = EXCP_FIQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc-&gt;do_interrupt(cs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = true;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* ARMv7-M interrupt return works by loading a magic value<BR>&nbsp;&nbsp;&nbsp;&nbsp; * into the PC.&nbsp; On real hardware the load causes the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * return to occur.&nbsp; The qemu implementation performs the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * jump normally, then does the exception return when the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * CPU tries to execute code at the magic address.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This will cause the magic PC value to be pushed to<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the stack if an interrupt occurred at the wrong time.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * We avoid this by disabling interrupts when<BR>&nbsp;&nbsp;&nbsp;&nbsp; * pc contains a magic address.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (interrupt_request &amp; CPU_INTERRUPT_HARD<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !(env-&gt;daif &amp; PSTATE_I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (env-&gt;regs[15] &lt; 0xfffffff0)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = EXCP_IRQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc-&gt;do_interrupt(cs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = true;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return ret;<BR>}<BR>#endif</P>
<P>#ifndef CONFIG_USER_ONLY<BR>static void arm_cpu_set_irq(void *opaque, int irq, int level)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);<BR>&nbsp;&nbsp;&nbsp; static const int mask[] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ARM_CPU_IRQ] = CPU_INTERRUPT_HARD,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ARM_CPU_FIQ] = CPU_INTERRUPT_FIQ,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ARM_CPU_VIRQ] = CPU_INTERRUPT_VIRQ,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ARM_CPU_VFIQ] = CPU_INTERRUPT_VFIQ<BR>&nbsp;&nbsp;&nbsp; };</P>
<P>&nbsp;&nbsp;&nbsp; switch (irq) {<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_VIRQ:<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_VFIQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(arm_feature(env, ARM_FEATURE_EL2));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* fall through */<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_IRQ:<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_FIQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (level) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_interrupt(cs, mask[irq]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_reset_interrupt(cs, mask[irq]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void arm_cpu_kvm_set_irq(void *opaque, int irq, int level)<BR>{<BR>#ifdef CONFIG_KVM<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = opaque;<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);<BR>&nbsp;&nbsp;&nbsp; int kvm_irq = KVM_ARM_IRQ_TYPE_CPU &lt;&lt; KVM_ARM_IRQ_TYPE_SHIFT;</P>
<P>&nbsp;&nbsp;&nbsp; switch (irq) {<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_IRQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kvm_irq |= KVM_ARM_IRQ_CPU_IRQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_FIQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kvm_irq |= KVM_ARM_IRQ_CPU_FIQ;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; kvm_irq |= cs-&gt;cpu_index &lt;&lt; KVM_ARM_IRQ_VCPU_SHIFT;<BR>&nbsp;&nbsp;&nbsp; kvm_set_irq(kvm_state, kvm_irq, level ? 1 : 0);<BR>#endif<BR>}</P>
<P>static bool arm_cpu_virtio_is_big_endian(CPUState *cs)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; cpu_synchronize_state(cs);<BR>&nbsp;&nbsp;&nbsp; return arm_cpu_data_is_big_endian(env);<BR>}</P>
<P>#endif</P>
<P>static inline void set_feature(CPUARMState *env, int feature)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;features |= 1ULL &lt;&lt; feature;<BR>}</P>
<P>static inline void unset_feature(CPUARMState *env, int feature)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;features &amp;= ~(1ULL &lt;&lt; feature);<BR>}</P>
<P>static int<BR>print_insn_thumb1(bfd_vma pc, disassemble_info *info)<BR>{<BR>&nbsp; return print_insn_arm(pc | 1, info);<BR>}</P>
<P>static void arm_disas_set_info(CPUState *cpu, disassemble_info *info)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *ac = ARM_CPU(cpu);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;ac-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; if (is_a64(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We might not be compiled with the A64 disassembler<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * because it needs a C++ compiler. Leave print_insn<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * unset in this case to use the caller default behaviour.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>#if defined(CONFIG_ARM_A64_DIS)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;print_insn = print_insn_arm_a64;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; } else if (env-&gt;thumb) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;print_insn = print_insn_thumb1;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;print_insn = print_insn_arm;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (bswap_code(arm_sctlr_b(env))) {<BR>#ifdef TARGET_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;endian = BFD_ENDIAN_LITTLE;<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;endian = BFD_ENDIAN_BIG;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>#define ARM_CPUS_PER_CLUSTER 8</P>
<P>static void arm_cpu_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(obj);<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);<BR>&nbsp;&nbsp;&nbsp; static bool inited;<BR>&nbsp;&nbsp;&nbsp; uint32_t Aff1, Aff0;</P>
<P>&nbsp;&nbsp;&nbsp; cs-&gt;env_ptr = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; cpu_exec_init(cs, &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;cp_regs = g_hash_table_new_full(g_int_hash, g_int_equal,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_free, g_free);</P>
<P>&nbsp;&nbsp;&nbsp; /* This cpu-id-to-MPIDR affinity is used only for TCG; KVM will override it.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * We don't support setting cluster ID ([16..23]) (known as Aff2<BR>&nbsp;&nbsp;&nbsp;&nbsp; * in later ARM ARM versions), or any of the higher affinity level fields,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * so these bits always RAZ.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; Aff1 = cs-&gt;cpu_index / ARM_CPUS_PER_CLUSTER;<BR>&nbsp;&nbsp;&nbsp; Aff0 = cs-&gt;cpu_index % ARM_CPUS_PER_CLUSTER;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mp_affinity = (Aff1 &lt;&lt; ARM_AFF1_SHIFT) | Aff0;</P>
<P>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; /* Our inbound IRQ and FIQ lines */<BR>&nbsp;&nbsp;&nbsp; if (kvm_enabled()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* VIRQ and VFIQ are unused with KVM but we add them to maintain<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the same interface as non-KVM CPUs.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_init_gpio_in(DEVICE(cpu), arm_cpu_kvm_set_irq, 4);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_init_gpio_in(DEVICE(cpu), arm_cpu_set_irq, 4);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;gt_timer[GTIMER_PHYS] = timer_new(QEMU_CLOCK_VIRTUAL, GTIMER_SCALE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_gt_ptimer_cb, cpu);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;gt_timer[GTIMER_VIRT] = timer_new(QEMU_CLOCK_VIRTUAL, GTIMER_SCALE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_gt_vtimer_cb, cpu);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;gt_timer[GTIMER_HYP] = timer_new(QEMU_CLOCK_VIRTUAL, GTIMER_SCALE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_gt_htimer_cb, cpu);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;gt_timer[GTIMER_SEC] = timer_new(QEMU_CLOCK_VIRTUAL, GTIMER_SCALE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_gt_stimer_cb, cpu);<BR>&nbsp;&nbsp;&nbsp; qdev_init_gpio_out(DEVICE(cpu), cpu-&gt;gt_timer_outputs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARRAY_SIZE(cpu-&gt;gt_timer_outputs));<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; /* DTB consumers generally don't in fact care what the 'compatible'<BR>&nbsp;&nbsp;&nbsp;&nbsp; * string is, so always provide some string and trust that a hypothetical<BR>&nbsp;&nbsp;&nbsp;&nbsp; * picky DTB consumer will also provide a helpful error message.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "qemu,unknown";<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;psci_version = 1; /* By default assume PSCI v0.1 */<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;kvm_target = QEMU_KVM_ARM_TARGET_NONE;</P>
<P>&nbsp;&nbsp;&nbsp; if (tcg_enabled()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;psci_version = 2; /* TCG implements PSCI 0.2 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!inited) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inited = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_translate_init();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static Property arm_cpu_reset_cbar_property =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFINE_PROP_UINT64("reset-cbar", ARMCPU, reset_cbar, 0);</P>
<P>static Property arm_cpu_reset_hivecs_property =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFINE_PROP_BOOL("reset-hivecs", ARMCPU, reset_hivecs, false);</P>
<P>static Property arm_cpu_rvbar_property =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFINE_PROP_UINT64("rvbar", ARMCPU, rvbar, 0);</P>
<P>static Property arm_cpu_has_el3_property =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFINE_PROP_BOOL("has_el3", ARMCPU, has_el3, true);</P>
<P>static Property arm_cpu_has_mpu_property =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFINE_PROP_BOOL("has-mpu", ARMCPU, has_mpu, true);</P>
<P>static Property arm_cpu_pmsav7_dregion_property =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFINE_PROP_UINT32("pmsav7-dregion", ARMCPU, pmsav7_dregion, 16);</P>
<P>static void arm_cpu_post_init(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(&amp;cpu-&gt;env, ARM_FEATURE_CBAR) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_feature(&amp;cpu-&gt;env, ARM_FEATURE_CBAR_RO)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_property_add_static(DEVICE(obj), &amp;arm_cpu_reset_cbar_property,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (!arm_feature(&amp;cpu-&gt;env, ARM_FEATURE_M)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_property_add_static(DEVICE(obj), &amp;arm_cpu_reset_hivecs_property,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(&amp;cpu-&gt;env, ARM_FEATURE_AARCH64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_property_add_static(DEVICE(obj), &amp;arm_cpu_rvbar_property,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(&amp;cpu-&gt;env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Add the has_el3 state CPU property only if EL3 is allowed.&nbsp; This will<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * prevent "has_el3" from existing on CPUs which cannot support EL3.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_property_add_static(DEVICE(obj), &amp;arm_cpu_has_el3_property,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);</P>
<P>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_add_link(obj, "secure-memory",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TYPE_MEMORY_REGION,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Object **)&amp;cpu-&gt;secure_memory,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_prop_allow_set_link_before_realize,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJ_PROP_LINK_UNREF_ON_RELEASE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);<BR>#endif<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(&amp;cpu-&gt;env, ARM_FEATURE_MPU)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_property_add_static(DEVICE(obj), &amp;arm_cpu_has_mpu_property,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(&amp;cpu-&gt;env, ARM_FEATURE_V7)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_property_add_static(DEVICE(obj),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;arm_cpu_pmsav7_dregion_property,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>}</P>
<P>static void arm_cpu_finalizefn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);<BR>&nbsp;&nbsp;&nbsp; g_hash_table_destroy(cpu-&gt;cp_regs);<BR>}</P>
<P>static void arm_cpu_realizefn(DeviceState *dev, Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(dev);<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(dev);<BR>&nbsp;&nbsp;&nbsp; ARMCPUClass *acc = ARM_CPU_GET_CLASS(dev);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; /* Some features automatically imply others: */<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_V7);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_ARM_DIV);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_LPAE);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V7)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_VAPA);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_THUMB2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_MPIDR);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_M)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_V6K);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_V6);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V6K)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_V6);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_MVFR);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V6)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_M)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_AUXCR);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_V5)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_V4T);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_M)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_THUMB_DIV);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_ARM_DIV)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_THUMB_DIV);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_VFP4)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_VFP3);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_VFP_FP16);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_VFP3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_VFP);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_LPAE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_V7MP);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_PXN);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_CBAR_RO)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_CBAR);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_THUMB2) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_feature(env, ARM_FEATURE_M)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_feature(env, ARM_FEATURE_THUMB_DSP);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (cpu-&gt;reset_hivecs) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr |= (1 &lt;&lt; 13);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (!cpu-&gt;has_el3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If the has_el3 CPU property is disabled then we need to disable the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * feature.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unset_feature(env, ARM_FEATURE_EL3);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Disable the security extension feature bits in the processor feature<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * registers as well. These are id_pfr1[7:4] and id_aa64pfr0[15:12].<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr1 &amp;= ~0xf0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;id_aa64pfr0 &amp;= ~0xf000;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_EL2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Disable the hypervisor feature bits in the processor feature<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * registers if we don't have EL2. These are id_pfr1[15:12] and<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * id_aa64pfr0_el1[11:8].<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;id_aa64pfr0 &amp;= ~0xf00;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr1 &amp;= ~0xf000;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (!cpu-&gt;has_mpu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unset_feature(env, ARM_FEATURE_MPU);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_MPU) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_feature(env, ARM_FEATURE_V7)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t nr = cpu-&gt;pmsav7_dregion;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nr &gt; 0xff) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "PMSAv7 MPU #regions invalid %" PRIu32, nr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nr) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pmsav7.drbar = g_new0(uint32_t, nr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pmsav7.drsr = g_new0(uint32_t, nr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pmsav7.dracr = g_new0(uint32_t, nr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; register_cp_regs_for_features(cpu);<BR>&nbsp;&nbsp;&nbsp; arm_cpu_register_gdb_regs_for_features(cpu);</P>
<P>&nbsp;&nbsp;&nbsp; init_cpreg_list(cpu);</P>
<P>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; if (cpu-&gt;has_el3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;num_ases = 2;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;num_ases = 1;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (cpu-&gt;has_el3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddressSpace *as;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!cpu-&gt;secure_memory) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu-&gt;secure_memory = cs-&gt;memory;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as = address_space_init_shareable(cpu-&gt;secure_memory,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "cpu-secure-memory");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_address_space_init(cs, as, ARMASIdx_S);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; cpu_address_space_init(cs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address_space_init_shareable(cs-&gt;memory,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "cpu-memory"),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMASIdx_NS);<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; qemu_init_vcpu(cs);<BR>&nbsp;&nbsp;&nbsp; cpu_reset(cs);</P>
<P>&nbsp;&nbsp;&nbsp; acc-&gt;parent_realize(dev, errp);<BR>}</P>
<P>static ObjectClass *arm_cpu_class_by_name(const char *cpu_model)<BR>{<BR>&nbsp;&nbsp;&nbsp; ObjectClass *oc;<BR>&nbsp;&nbsp;&nbsp; char *typename;<BR>&nbsp;&nbsp;&nbsp; char **cpuname;</P>
<P>&nbsp;&nbsp;&nbsp; if (!cpu_model) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; cpuname = g_strsplit(cpu_model, ",", 1);<BR>&nbsp;&nbsp;&nbsp; typename = g_strdup_printf("%s-" TYPE_ARM_CPU, cpuname[0]);<BR>&nbsp;&nbsp;&nbsp; oc = object_class_by_name(typename);<BR>&nbsp;&nbsp;&nbsp; g_strfreev(cpuname);<BR>&nbsp;&nbsp;&nbsp; g_free(typename);<BR>&nbsp;&nbsp;&nbsp; if (!oc || !object_class_dynamic_cast(oc, TYPE_ARM_CPU) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_class_is_abstract(oc)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return oc;<BR>}</P>
<P>/* CPU models. These are not needed for the AArch64 linux-user build. */<BR>#if !defined(CONFIG_USER_ONLY) || !defined(TARGET_AARCH64)</P>
<P>static void arm926_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "arm,arm926";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_VFP);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_DUMMY_C15_REGS);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_CACHE_TEST_CLEAN);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x41069265;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_fpsid = 0x41011090;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0x1dd20d2;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00090078;<BR>}</P>
<P>static void arm946_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "arm,arm946";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_MPU);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_DUMMY_C15_REGS);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x41059461;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0x0f004006;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000078;<BR>}</P>
<P>static void arm1026_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "arm,arm1026";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_VFP);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_AUXCR);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_DUMMY_C15_REGS);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_CACHE_TEST_CLEAN);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x4106a262;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_fpsid = 0x410110a0;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0x1dd20d2;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00090078;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_auxcr = 1;<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The 1026 had an IFAR at c6,c0,0,1 rather than the ARMv6 c6,c0,0,2 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPRegInfo ifar = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "IFAR", .cp = 15, .crn = 6, .crm = 0, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.ifar_ns),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .resetvalue = 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg(cpu, &amp;ifar);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void arm1136_r2_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);<BR>&nbsp;&nbsp;&nbsp; /* What qemu calls "arm1136_r2" is actually the 1136 r0p2, ie an<BR>&nbsp;&nbsp;&nbsp;&nbsp; * older core than plain "arm1136". In particular this does not<BR>&nbsp;&nbsp;&nbsp;&nbsp; * have the v6K features.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * These ID register values are correct for 1136 but may be wrong<BR>&nbsp;&nbsp;&nbsp;&nbsp; * for 1136_r2 (in particular r0p2 does not actually implement most<BR>&nbsp;&nbsp;&nbsp;&nbsp; * of the ID registers).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "arm,arm1136";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V6);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_VFP);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_DUMMY_C15_REGS);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_CACHE_DIRTY_REG);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_CACHE_BLOCK_OPS);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x4107b362;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_fpsid = 0x410120b4;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr0 = 0x11111111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr1 = 0x00000000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0x1dd20d2;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00050078;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr0 = 0x111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr1 = 0x1;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_dfr0 = 0x2;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_afr0 = 0x3;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr0 = 0x01130003;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr1 = 0x10030302;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr2 = 0x01222110;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar0 = 0x00140011;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar1 = 0x12002111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar2 = 0x11231111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar3 = 0x01102131;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar4 = 0x141;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_auxcr = 7;<BR>}</P>
<P>static void arm1136_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "arm,arm1136";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V6K);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V6);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_VFP);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_DUMMY_C15_REGS);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_CACHE_DIRTY_REG);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_CACHE_BLOCK_OPS);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x4117b363;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_fpsid = 0x410120b4;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr0 = 0x11111111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr1 = 0x00000000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0x1dd20d2;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00050078;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr0 = 0x111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr1 = 0x1;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_dfr0 = 0x2;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_afr0 = 0x3;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr0 = 0x01130003;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr1 = 0x10030302;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr2 = 0x01222110;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar0 = 0x00140011;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar1 = 0x12002111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar2 = 0x11231111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar3 = 0x01102131;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar4 = 0x141;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_auxcr = 7;<BR>}</P>
<P>static void arm1176_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "arm,arm1176";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V6K);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_VFP);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_VAPA);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_DUMMY_C15_REGS);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_CACHE_DIRTY_REG);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_CACHE_BLOCK_OPS);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_EL3);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x410fb767;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_fpsid = 0x410120b5;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr0 = 0x11111111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr1 = 0x00000000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0x1dd20d2;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00050078;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr0 = 0x111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr1 = 0x11;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_dfr0 = 0x33;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_afr0 = 0;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr0 = 0x01130003;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr1 = 0x10030302;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr2 = 0x01222100;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar0 = 0x0140011;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar1 = 0x12002111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar2 = 0x11231121;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar3 = 0x01102131;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar4 = 0x01141;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_auxcr = 7;<BR>}</P>
<P>static void arm11mpcore_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "arm,arm11mpcore";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V6K);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_VFP);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_VAPA);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_MPIDR);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_DUMMY_C15_REGS);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x410fb022;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_fpsid = 0x410120b4;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr0 = 0x11111111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr1 = 0x00000000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0x1d192992; /* 32K icache 32K dcache */<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr0 = 0x111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr1 = 0x1;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_dfr0 = 0;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_afr0 = 0x2;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr0 = 0x01100103;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr1 = 0x10020302;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr2 = 0x01222000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar0 = 0x00100011;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar1 = 0x12002111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar2 = 0x11221011;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar3 = 0x01102131;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar4 = 0x141;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_auxcr = 1;<BR>}</P>
<P>static void cortex_m3_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V7);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_M);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x410fc231;<BR>}</P>
<P>static void cortex_m4_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V7);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_M);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_THUMB_DSP);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x410fc240; /* r0p0 */<BR>}<BR>static void arm_v7m_class_init(ObjectClass *oc, void *data)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUClass *cc = CPU_CLASS(oc);</P>
<P>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; cc-&gt;do_interrupt = arm_v7m_cpu_do_interrupt;<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; cc-&gt;cpu_exec_interrupt = arm_v7m_cpu_exec_interrupt;<BR>}</P>
<P>static const ARMCPRegInfo cortexr5_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* Dummy the TCM region regs for the moment */<BR>&nbsp;&nbsp;&nbsp; { .name = "ATCM", .cp = 15, .opc1 = 0, .crn = 9, .crm = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_CONST },<BR>&nbsp;&nbsp;&nbsp; { .name = "BTCM", .cp = 15, .opc1 = 0, .crn = 9, .crm = 1, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_CONST },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</P>
<P>static void cortex_r5_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V7);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_THUMB_DIV);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_ARM_DIV);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V7MP);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_MPU);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x411fc153; /* r1p3 */<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr0 = 0x0131;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr1 = 0x001;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_dfr0 = 0x010400;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_afr0 = 0x0;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr0 = 0x0210030;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr1 = 0x00000000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr2 = 0x01200000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr3 = 0x0211;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar0 = 0x2101111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar1 = 0x13112111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar2 = 0x21232141;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar3 = 0x01112131;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar4 = 0x0010142;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar5 = 0x0;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mp_is_up = true;<BR>&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, cortexr5_cp_reginfo);<BR>}</P>
<P>static const ARMCPRegInfo cortexa8_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; { .name = "L2LOCKDOWN", .cp = 15, .crn = 9, .crm = 0, .opc1 = 1, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; { .name = "L2AUXCR", .cp = 15, .crn = 9, .crm = 0, .opc1 = 1, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</P>
<P>static void cortex_a8_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "arm,cortex-a8";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V7);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_VFP3);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_NEON);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_THUMB2EE);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_DUMMY_C15_REGS);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_EL3);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x410fc080;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_fpsid = 0x410330c0;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr0 = 0x11110222;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr1 = 0x00011100;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0x82048004;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00c50078;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr0 = 0x1031;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr1 = 0x11;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_dfr0 = 0x400;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_afr0 = 0;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr0 = 0x31100003;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr1 = 0x20000000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr2 = 0x01202000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr3 = 0x11;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar0 = 0x00101111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar1 = 0x12112111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar2 = 0x21232031;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar3 = 0x11112131;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar4 = 0x00111142;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;dbgdidr = 0x15141000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;clidr = (1 &lt;&lt; 27) | (2 &lt;&lt; 24) | 3;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ccsidr[0] = 0xe007e01a; /* 16k L1 dcache. */<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ccsidr[1] = 0x2007e01a; /* 16k L1 icache. */<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ccsidr[2] = 0xf0000000; /* No L2 icache. */<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_auxcr = 2;<BR>&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, cortexa8_cp_reginfo);<BR>}</P>
<P>static const ARMCPRegInfo cortexa9_cp_reginfo[] = {<BR>&nbsp;&nbsp;&nbsp; /* power_control should be set to maximum latency. Again,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * default to 0 and set by private hook<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "A9_PWRCTL", .cp = 15, .crn = 15, .crm = 0, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c15_power_control) },<BR>&nbsp;&nbsp;&nbsp; { .name = "A9_DIAG", .cp = 15, .crn = 15, .crm = 0, .opc1 = 0, .opc2 = 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c15_diagnostic) },<BR>&nbsp;&nbsp;&nbsp; { .name = "A9_PWRDIAG", .cp = 15, .crn = 15, .crm = 0, .opc1 = 0, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fieldoffset = offsetof(CPUARMState, cp15.c15_power_diagnostic) },<BR>&nbsp;&nbsp;&nbsp; { .name = "NEONBUSY", .cp = 15, .crn = 15, .crm = 1, .opc1 = 0, .opc2 = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0, .type = ARM_CP_CONST },<BR>&nbsp;&nbsp;&nbsp; /* TLB lockdown control */<BR>&nbsp;&nbsp;&nbsp; { .name = "TLB_LOCKR", .cp = 15, .crn = 15, .crm = 4, .opc1 = 5, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .resetvalue = 0, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLB_LOCKW", .cp = 15, .crn = 15, .crm = 4, .opc1 = 5, .opc2 = 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_W, .resetvalue = 0, .type = ARM_CP_NOP },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLB_VA", .cp = 15, .crn = 15, .crm = 5, .opc1 = 5, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0, .type = ARM_CP_CONST },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLB_PA", .cp = 15, .crn = 15, .crm = 6, .opc1 = 5, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0, .type = ARM_CP_CONST },<BR>&nbsp;&nbsp;&nbsp; { .name = "TLB_ATTR", .cp = 15, .crn = 15, .crm = 7, .opc1 = 5, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0, .type = ARM_CP_CONST },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</P>
<P>static void cortex_a9_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "arm,cortex-a9";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V7);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_VFP3);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_VFP_FP16);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_NEON);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_THUMB2EE);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_EL3);<BR>&nbsp;&nbsp;&nbsp; /* Note that A9 supports the MP extensions even for<BR>&nbsp;&nbsp;&nbsp;&nbsp; * A9UP and single-core A9MP (which are both different<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and valid configurations; we don't model A9UP).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V7MP);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_CBAR);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x410fc090;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_fpsid = 0x41033090;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr0 = 0x11110222;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr1 = 0x01111111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0x80038003;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00c50078;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr0 = 0x1031;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr1 = 0x11;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_dfr0 = 0x000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_afr0 = 0;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr0 = 0x00100103;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr1 = 0x20000000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr2 = 0x01230000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr3 = 0x00002111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar0 = 0x00101111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar1 = 0x13112111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar2 = 0x21232041;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar3 = 0x11112131;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar4 = 0x00111142;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;dbgdidr = 0x35141000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;clidr = (1 &lt;&lt; 27) | (1 &lt;&lt; 24) | 3;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ccsidr[0] = 0xe00fe019; /* 16k L1 dcache. */<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ccsidr[1] = 0x200fe019; /* 16k L1 icache. */<BR>&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, cortexa9_cp_reginfo);<BR>}</P>
<P>#ifndef CONFIG_USER_ONLY<BR>static uint64_t a15_l2ctlr_read(CPUARMState *env, const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Linux wants the number of processors from here.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Might as well set the interrupt-controller bit too.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; return ((smp_cpus - 1) &lt;&lt; 24) | (1 &lt;&lt; 23);<BR>}<BR>#endif</P>
<P>static const ARMCPRegInfo cortexa15_cp_reginfo[] = {<BR>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; { .name = "L2CTLR", .cp = 15, .crn = 9, .crm = 0, .opc1 = 1, .opc2 = 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .resetvalue = 0, .readfn = a15_l2ctlr_read,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .writefn = arm_cp_write_ignore, },<BR>#endif<BR>&nbsp;&nbsp;&nbsp; { .name = "L2ECTLR", .cp = 15, .crn = 9, .crm = 0, .opc1 = 1, .opc2 = 3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .access = PL1_RW, .type = ARM_CP_CONST, .resetvalue = 0 },<BR>&nbsp;&nbsp;&nbsp; REGINFO_SENTINEL<BR>};</P>
<P>static void cortex_a15_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "arm,cortex-a15";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V7);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_VFP4);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_NEON);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_THUMB2EE);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_ARM_DIV);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_GENERIC_TIMER);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_DUMMY_C15_REGS);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_CBAR_RO);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_LPAE);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_EL3);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;kvm_target = QEMU_KVM_ARM_TARGET_CORTEX_A15;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x412fc0f1;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_fpsid = 0x410430f0;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr0 = 0x10110222;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;mvfr1 = 0x11111111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0x8444c004;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00c50078;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr0 = 0x00001131;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_pfr1 = 0x00011011;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_dfr0 = 0x02010555;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;pmceid0 = 0x0000000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;pmceid1 = 0x00000000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_afr0 = 0x00000000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr0 = 0x10201105;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr1 = 0x20000000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr2 = 0x01240000;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_mmfr3 = 0x02102211;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar0 = 0x02101110;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar1 = 0x13112111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar2 = 0x21232041;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar3 = 0x11112131;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;id_isar4 = 0x10011142;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;dbgdidr = 0x3515f021;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;clidr = 0x0a200023;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ccsidr[0] = 0x701fe00a; /* 32K L1 dcache */<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ccsidr[1] = 0x201fe00a; /* 32K L1 icache */<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ccsidr[2] = 0x711fe07a; /* 4096K L2 unified cache */<BR>&nbsp;&nbsp;&nbsp; define_arm_cp_regs(cpu, cortexa15_cp_reginfo);<BR>}</P>
<P>static void ti925t_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V4T);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_OMAPCP);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = ARM_CPUID_TI925T;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0x5109149;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000070;<BR>}</P>
<P>static void sa1100_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "intel,sa1100";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_STRONGARM);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_DUMMY_C15_REGS);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x4401A11B;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000070;<BR>}</P>
<P>static void sa1110_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_STRONGARM);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_DUMMY_C15_REGS);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x6901B119;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000070;<BR>}</P>
<P>static void pxa250_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "marvell,xscale";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_XSCALE);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x69052100;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0xd172172;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000078;<BR>}</P>
<P>static void pxa255_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "marvell,xscale";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_XSCALE);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x69052d00;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0xd172172;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000078;<BR>}</P>
<P>static void pxa260_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "marvell,xscale";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_XSCALE);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x69052903;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0xd172172;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000078;<BR>}</P>
<P>static void pxa261_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "marvell,xscale";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_XSCALE);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x69052d05;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0xd172172;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000078;<BR>}</P>
<P>static void pxa262_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "marvell,xscale";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_XSCALE);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x69052d06;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0xd172172;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000078;<BR>}</P>
<P>static void pxa270a0_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "marvell,xscale";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_XSCALE);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_IWMMXT);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x69054110;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0xd172172;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000078;<BR>}</P>
<P>static void pxa270a1_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "marvell,xscale";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_XSCALE);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_IWMMXT);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x69054111;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0xd172172;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000078;<BR>}</P>
<P>static void pxa270b0_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "marvell,xscale";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_XSCALE);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_IWMMXT);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x69054112;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0xd172172;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000078;<BR>}</P>
<P>static void pxa270b1_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "marvell,xscale";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_XSCALE);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_IWMMXT);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x69054113;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0xd172172;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000078;<BR>}</P>
<P>static void pxa270c0_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "marvell,xscale";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_XSCALE);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_IWMMXT);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x69054114;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0xd172172;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000078;<BR>}</P>
<P>static void pxa270c5_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);</P>
<P>&nbsp;&nbsp;&nbsp; cpu-&gt;dtb_compatible = "marvell,xscale";<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V5);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_XSCALE);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_IWMMXT);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0x69054117;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;ctr = 0xd172172;<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;reset_sctlr = 0x00000078;<BR>}</P>
<P>#ifdef CONFIG_USER_ONLY<BR>static void arm_any_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(obj);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V8);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_VFP4);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_NEON);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_THUMB2EE);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V8_AES);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V8_SHA1);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V8_SHA256);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_V8_PMULL);<BR>&nbsp;&nbsp;&nbsp; set_feature(&amp;cpu-&gt;env, ARM_FEATURE_CRC);<BR>&nbsp;&nbsp;&nbsp; cpu-&gt;midr = 0xffffffff;<BR>}<BR>#endif</P>
<P>#endif /* !defined(CONFIG_USER_ONLY) || !defined(TARGET_AARCH64) */</P>
<P>typedef struct ARMCPUInfo {<BR>&nbsp;&nbsp;&nbsp; const char *name;<BR>&nbsp;&nbsp;&nbsp; void (*initfn)(Object *obj);<BR>&nbsp;&nbsp;&nbsp; void (*class_init)(ObjectClass *oc, void *data);<BR>} ARMCPUInfo;</P>
<P>static const ARMCPUInfo arm_cpus[] = {<BR>#if !defined(CONFIG_USER_ONLY) || !defined(TARGET_AARCH64)<BR>&nbsp;&nbsp;&nbsp; { .name = "arm926",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .initfn = arm926_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "arm946",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .initfn = arm946_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "arm1026",&nbsp;&nbsp;&nbsp;&nbsp; .initfn = arm1026_initfn },<BR>&nbsp;&nbsp;&nbsp; /* What QEMU calls "arm1136-r2" is actually the 1136 r0p2, i.e. an<BR>&nbsp;&nbsp;&nbsp;&nbsp; * older core than plain "arm1136". In particular this does not<BR>&nbsp;&nbsp;&nbsp;&nbsp; * have the v6K features.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; { .name = "arm1136-r2",&nbsp; .initfn = arm1136_r2_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "arm1136",&nbsp;&nbsp;&nbsp;&nbsp; .initfn = arm1136_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "arm1176",&nbsp;&nbsp;&nbsp;&nbsp; .initfn = arm1176_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "arm11mpcore", .initfn = arm11mpcore_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "cortex-m3",&nbsp;&nbsp; .initfn = cortex_m3_initfn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .class_init = arm_v7m_class_init },<BR>&nbsp;&nbsp;&nbsp; { .name = "cortex-m4",&nbsp;&nbsp; .initfn = cortex_m4_initfn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .class_init = arm_v7m_class_init },<BR>&nbsp;&nbsp;&nbsp; { .name = "cortex-r5",&nbsp;&nbsp; .initfn = cortex_r5_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "cortex-a8",&nbsp;&nbsp; .initfn = cortex_a8_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "cortex-a9",&nbsp;&nbsp; .initfn = cortex_a9_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "cortex-a15",&nbsp; .initfn = cortex_a15_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "ti925t",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .initfn = ti925t_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "sa1100",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .initfn = sa1100_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "sa1110",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .initfn = sa1110_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "pxa250",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .initfn = pxa250_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "pxa255",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .initfn = pxa255_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "pxa260",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .initfn = pxa260_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "pxa261",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .initfn = pxa261_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "pxa262",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .initfn = pxa262_initfn },<BR>&nbsp;&nbsp;&nbsp; /* "pxa270" is an alias for "pxa270-a0" */<BR>&nbsp;&nbsp;&nbsp; { .name = "pxa270",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .initfn = pxa270a0_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "pxa270-a0",&nbsp;&nbsp; .initfn = pxa270a0_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "pxa270-a1",&nbsp;&nbsp; .initfn = pxa270a1_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "pxa270-b0",&nbsp;&nbsp; .initfn = pxa270b0_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "pxa270-b1",&nbsp;&nbsp; .initfn = pxa270b1_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "pxa270-c0",&nbsp;&nbsp; .initfn = pxa270c0_initfn },<BR>&nbsp;&nbsp;&nbsp; { .name = "pxa270-c5",&nbsp;&nbsp; .initfn = pxa270c5_initfn },<BR>#ifdef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; { .name = "any",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .initfn = arm_any_initfn },<BR>#endif<BR>#endif<BR>&nbsp;&nbsp;&nbsp; { .name = NULL }<BR>};</P>
<P>static Property arm_cpu_properties[] = {<BR>&nbsp;&nbsp;&nbsp; DEFINE_PROP_BOOL("start-powered-off", ARMCPU, start_powered_off, false),<BR>&nbsp;&nbsp;&nbsp; DEFINE_PROP_UINT32("psci-conduit", ARMCPU, psci_conduit, 0),<BR>&nbsp;&nbsp;&nbsp; DEFINE_PROP_UINT32("midr", ARMCPU, midr, 0),<BR>&nbsp;&nbsp;&nbsp; DEFINE_PROP_UINT64("mp-affinity", ARMCPU, mp_affinity, 0),<BR>&nbsp;&nbsp;&nbsp; DEFINE_PROP_END_OF_LIST()<BR>};</P>
<P>#ifdef CONFIG_USER_ONLY<BR>static int arm_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mmu_idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; env-&gt;exception.vaddress = address;<BR>&nbsp;&nbsp;&nbsp; if (rw == 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = EXCP_PREFETCH_ABORT;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = EXCP_DATA_ABORT;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return 1;<BR>}<BR>#endif</P>
<P>static gchar *arm_gdb_arch_name(CPUState *cs)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_IWMMXT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return g_strdup("iwmmxt");<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return g_strdup("arm");<BR>}</P>
<P>static void arm_cpu_class_init(ObjectClass *oc, void *data)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPUClass *acc = ARM_CPU_CLASS(oc);<BR>&nbsp;&nbsp;&nbsp; CPUClass *cc = CPU_CLASS(acc);<BR>&nbsp;&nbsp;&nbsp; DeviceClass *dc = DEVICE_CLASS(oc);</P>
<P>&nbsp;&nbsp;&nbsp; acc-&gt;parent_realize = dc-&gt;realize;<BR>&nbsp;&nbsp;&nbsp; dc-&gt;realize = arm_cpu_realizefn;<BR>&nbsp;&nbsp;&nbsp; dc-&gt;props = arm_cpu_properties;</P>
<P>&nbsp;&nbsp;&nbsp; acc-&gt;parent_reset = cc-&gt;reset;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;reset = arm_cpu_reset;</P>
<P>&nbsp;&nbsp;&nbsp; cc-&gt;class_by_name = arm_cpu_class_by_name;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;has_work = arm_cpu_has_work;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;cpu_exec_interrupt = arm_cpu_exec_interrupt;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;dump_state = arm_cpu_dump_state;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;set_pc = arm_cpu_set_pc;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;gdb_read_register = arm_cpu_gdb_read_register;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;gdb_write_register = arm_cpu_gdb_write_register;<BR>#ifdef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; cc-&gt;handle_mmu_fault = arm_cpu_handle_mmu_fault;<BR>#else<BR>&nbsp;&nbsp;&nbsp; cc-&gt;do_interrupt = arm_cpu_do_interrupt;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;do_unaligned_access = arm_cpu_do_unaligned_access;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;get_phys_page_attrs_debug = arm_cpu_get_phys_page_attrs_debug;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;asidx_from_attrs = arm_asidx_from_attrs;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;vmsd = &amp;vmstate_arm_cpu;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;virtio_is_big_endian = arm_cpu_virtio_is_big_endian;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;write_elf64_note = arm_cpu_write_elf64_note;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;write_elf32_note = arm_cpu_write_elf32_note;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; cc-&gt;gdb_num_core_regs = 26;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;gdb_core_xml_file = "arm-core.xml";<BR>&nbsp;&nbsp;&nbsp; cc-&gt;gdb_arch_name = arm_gdb_arch_name;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;gdb_stop_before_watchpoint = true;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;debug_excp_handler = arm_debug_excp_handler;<BR>&nbsp;&nbsp;&nbsp; cc-&gt;debug_check_watchpoint = arm_debug_check_watchpoint;</P>
<P>&nbsp;&nbsp;&nbsp; cc-&gt;disas_set_info = arm_disas_set_info;</P>
<P>&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Reason: arm_cpu_initfn() calls cpu_exec_init(), which saves<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the object in cpus -&gt; dangling pointer after final<BR>&nbsp;&nbsp;&nbsp;&nbsp; * object_unref().<BR>&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Once this is fixed, the devices that create ARM CPUs should be<BR>&nbsp;&nbsp;&nbsp;&nbsp; * updated not to set cannot_destroy_with_object_finalize_yet,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * unless they still screw up something else.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; dc-&gt;cannot_destroy_with_object_finalize_yet = true;<BR>}</P>
<P>static void cpu_register(const ARMCPUInfo *info)<BR>{<BR>&nbsp;&nbsp;&nbsp; TypeInfo type_info = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .parent = TYPE_ARM_CPU,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .instance_size = sizeof(ARMCPU),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .instance_init = info-&gt;initfn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .class_size = sizeof(ARMCPUClass),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .class_init = info-&gt;class_init,<BR>&nbsp;&nbsp;&nbsp; };</P>
<P>&nbsp;&nbsp;&nbsp; type_info.name = g_strdup_printf("%s-" TYPE_ARM_CPU, info-&gt;name);<BR>&nbsp;&nbsp;&nbsp; type_register(&amp;type_info);<BR>&nbsp;&nbsp;&nbsp; g_free((void *)type_info.name);<BR>}</P>
<P>static const TypeInfo arm_cpu_type_info = {<BR>&nbsp;&nbsp;&nbsp; .name = TYPE_ARM_CPU,<BR>&nbsp;&nbsp;&nbsp; .parent = TYPE_CPU,<BR>&nbsp;&nbsp;&nbsp; .instance_size = sizeof(ARMCPU),<BR>&nbsp;&nbsp;&nbsp; .instance_init = arm_cpu_initfn,<BR>&nbsp;&nbsp;&nbsp; .instance_post_init = arm_cpu_post_init,<BR>&nbsp;&nbsp;&nbsp; .instance_finalize = arm_cpu_finalizefn,<BR>&nbsp;&nbsp;&nbsp; .abstract = true,<BR>&nbsp;&nbsp;&nbsp; .class_size = sizeof(ARMCPUClass),<BR>&nbsp;&nbsp;&nbsp; .class_init = arm_cpu_class_init,<BR>};</P>
<P>static void arm_cpu_register_types(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; const ARMCPUInfo *info = arm_cpus;</P>
<P>&nbsp;&nbsp;&nbsp; type_register_static(&amp;arm_cpu_type_info);</P>
<P>&nbsp;&nbsp;&nbsp; while (info-&gt;name) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_register(info);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info++;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>type_init(arm_cpu_register_types)