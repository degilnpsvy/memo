# target-arm/cpu.h 
<P></P>
<P>/*<BR>&nbsp;* ARM virtual CPU header<BR>&nbsp;*<BR>&nbsp;*&nbsp; Copyright (c) 2003 Fabrice Bellard<BR>&nbsp;*<BR>&nbsp;* This library is free software; you can redistribute it and/or<BR>&nbsp;* modify it under the terms of the GNU Lesser General Public<BR>&nbsp;* License as published by the Free Software Foundation; either<BR>&nbsp;* version 2 of the License, or (at your option) any later version.<BR>&nbsp;*<BR>&nbsp;* This library is distributed in the hope that it will be useful,<BR>&nbsp;* but WITHOUT ANY WARRANTY; without even the implied warranty of<BR>&nbsp;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp; See the GNU<BR>&nbsp;* Lesser General Public License for more details.<BR>&nbsp;*<BR>&nbsp;* You should have received a copy of the GNU Lesser General Public<BR>&nbsp;* License along with this library; if not, see &lt;<A href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.<BR>&nbsp;*/ </P>
<P></P>
<P>#ifndef ARM_CPU_H<BR>#define ARM_CPU_H</P>
<P>#include "kvm-consts.h"</P>
<P><FONT class=extract>#if defined(TARGET_AARCH64)<BR>&nbsp; /* AArch64 definitions */<BR>#&nbsp; define TARGET_LONG_BITS 64<BR>#else<BR>#&nbsp; define TARGET_LONG_BITS 32<BR>#endif</FONT></P>
<P><FONT class=extract>#define CPUArchState struct CPUARMState</FONT></P>
<P>#include "qemu-common.h"<BR>#include "cpu-qom.h"<BR>#include "exec/cpu-defs.h"</P>
<P>#include "fpu/softfloat.h"</P>
<P><FONT class=extract>#define EXCP_UDEF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; /* undefined instruction */<BR>#define EXCP_SWI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; /* software interrupt */<BR>#define EXCP_PREFETCH_ABORT&nbsp; 3<BR>#define EXCP_DATA_ABORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4<BR>#define EXCP_IRQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5<BR>#define EXCP_FIQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6<BR>#define EXCP_BKPT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7<BR>#define EXCP_EXCEPTION_EXIT&nbsp; 8&nbsp;&nbsp; /* Return from v7M exception.&nbsp; */<BR>#define EXCP_KERNEL_TRAP&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; /* Jumped to kernel code page.&nbsp; */<BR>#define EXCP_STREX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10<BR>#define EXCP_HVC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp; /* HyperVisor Call */<BR>#define EXCP_HYP_TRAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12<BR>#define EXCP_SMC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13&nbsp;&nbsp; /* Secure Monitor Call */<BR>#define EXCP_VIRQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14<BR>#define EXCP_VFIQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15<BR>#define EXCP_SEMIHOST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp; /* semihosting call (A64 only) */</FONT></P>
<P><FONT class=extract>#define ARMV7M_EXCP_RESET&nbsp;&nbsp; 1<BR>#define ARMV7M_EXCP_NMI&nbsp;&nbsp;&nbsp;&nbsp; 2<BR>#define ARMV7M_EXCP_HARD&nbsp;&nbsp;&nbsp; 3<BR>#define ARMV7M_EXCP_MEM&nbsp;&nbsp;&nbsp;&nbsp; 4<BR>#define ARMV7M_EXCP_BUS&nbsp;&nbsp;&nbsp;&nbsp; 5<BR>#define ARMV7M_EXCP_USAGE&nbsp;&nbsp; 6<BR>#define ARMV7M_EXCP_SVC&nbsp;&nbsp;&nbsp;&nbsp; 11<BR>#define ARMV7M_EXCP_DEBUG&nbsp;&nbsp; 12<BR>#define ARMV7M_EXCP_PENDSV&nbsp; 14<BR>#define ARMV7M_EXCP_SYSTICK 15</FONT></P>
<P><FONT class=extract>/* ARM-specific interrupt pending bits.&nbsp; */<BR>#define CPU_INTERRUPT_FIQ&nbsp;&nbsp; CPU_INTERRUPT_TGT_EXT_1<BR>#define CPU_INTERRUPT_VIRQ&nbsp; CPU_INTERRUPT_TGT_EXT_2<BR>#define CPU_INTERRUPT_VFIQ&nbsp; CPU_INTERRUPT_TGT_EXT_3</FONT></P>
<P><FONT class=extract>/* The usual mapping for an AArch64 system register to its AArch32<BR>&nbsp;* counterpart is for the 32 bit world to have access to the lower<BR>&nbsp;* half only (with writes leaving the upper half untouched). It's<BR>&nbsp;* therefore useful to be able to pass TCG the offset of the least<BR>&nbsp;* significant half of a uint64_t struct member.<BR>&nbsp;*/<BR>#ifdef HOST_WORDS_BIGENDIAN<BR>#define offsetoflow32(S, M) (offsetof(S, M) + sizeof(uint32_t))<BR>#define offsetofhigh32(S, M) offsetof(S, M)<BR>#else<BR>#define offsetoflow32(S, M) offsetof(S, M)<BR>#define offsetofhigh32(S, M) (offsetof(S, M) + sizeof(uint32_t))<BR>#endif</FONT></P>
<P>/* Meanings of the ARMCPU object's four inbound GPIO lines */<BR>#define ARM_CPU_IRQ 0<BR>#define ARM_CPU_FIQ 1<BR>#define ARM_CPU_VIRQ 2<BR>#define ARM_CPU_VFIQ 3</P>
<P>#define NB_MMU_MODES 7<BR>/* ARM-specific extra insn start words:<BR>&nbsp;* 1: Conditional execution bits<BR>&nbsp;* 2: Partial exception syndrome for data aborts<BR>&nbsp;*/<BR>#define TARGET_INSN_START_EXTRA_WORDS 2</P>
<P>/* The 2nd extra word holding syndrome info for data aborts does not use<BR>&nbsp;* the upper 6 bits nor the lower 14 bits. We mask and shift it down to<BR>&nbsp;* help the sleb128 encoder do a better job.<BR>&nbsp;* When restoring the CPU state, we shift it back up.<BR>&nbsp;*/<BR>#define ARM_INSN_START_WORD2_MASK ((1 &lt;&lt; 26) - 1)<BR>#define ARM_INSN_START_WORD2_SHIFT 14</P>
<P>/* We currently assume float and double are IEEE single and double<BR>&nbsp;&nbsp; precision respectively.<BR>&nbsp;&nbsp; Doing runtime conversions is tricky because VFP registers may contain<BR>&nbsp;&nbsp; integer values (eg. as the result of a FTOSI instruction).<BR>&nbsp;&nbsp; s&lt;2n&gt; maps to the least significant half of d&lt;n&gt;<BR>&nbsp;&nbsp; s&lt;2n+1&gt; maps to the most significant half of d&lt;n&gt;<BR>&nbsp;*/</P>
<P><FONT class=extract>/* CPU state for each instance of a generic timer (in cp15 c14) */<BR>typedef struct ARMGenericTimer {<BR>&nbsp;&nbsp;&nbsp; uint64_t cval; /* Timer CompareValue register */<BR>&nbsp;&nbsp;&nbsp; uint64_t ctl; /* Timer Control register */<BR>} ARMGenericTimer;</FONT></P>
<P>#define GTIMER_PHYS 0<BR>#define GTIMER_VIRT 1<BR>#define GTIMER_HYP&nbsp; 2<BR>#define GTIMER_SEC&nbsp; 3<BR>#define NUM_GTIMERS 4</P>
<P>typedef struct {<BR>&nbsp;&nbsp;&nbsp; uint64_t raw_tcr;<BR>&nbsp;&nbsp;&nbsp; uint32_t mask;<BR>&nbsp;&nbsp;&nbsp; uint32_t base_mask;<BR>} TCR;</P>
<P><FONT class=extract>typedef struct CPUARMState {<BR>&nbsp;&nbsp;&nbsp; /* Regs for current mode.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t regs[16];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* 32/64 switch only happens when taking and returning from<BR>&nbsp;&nbsp;&nbsp;&nbsp; * exceptions so the overlap semantics are taken care of then<BR>&nbsp;&nbsp;&nbsp;&nbsp; * instead of having a complicated union.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; /* Regs for A64 mode.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint64_t xregs[32];<BR>&nbsp;&nbsp;&nbsp; uint64_t pc;<BR>&nbsp;&nbsp;&nbsp; /* PSTATE isn't an architectural register for ARMv8. However, it is<BR>&nbsp;&nbsp;&nbsp;&nbsp; * convenient for us to assemble the underlying state into a 32 bit format<BR>&nbsp;&nbsp;&nbsp;&nbsp; * identical to the architectural format used for the SPSR. (This is also<BR>&nbsp;&nbsp;&nbsp;&nbsp; * what the Linux kernel's 'pstate' field in signal handlers and KVM's<BR>&nbsp;&nbsp;&nbsp;&nbsp; * 'pstate' register are.) Of the PSTATE bits:<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; NZCV are kept in the split out env-&gt;CF/VF/NF/ZF, (which have the same<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp; semantics as for AArch32, as described in the comments on each field)<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; nRW (also known as M[4]) is kept, inverted, in env-&gt;aarch64<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; DAIF (exception masks) are kept in env-&gt;daif<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; all other bits are stored in their correct places in env-&gt;pstate<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t pstate;<BR>&nbsp;&nbsp;&nbsp; uint32_t aarch64; /* 1 if CPU is in aarch64 state; inverse of PSTATE.nRW */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Frequently accessed CPSR bits are stored separately for efficiency.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This contains all the other bits.&nbsp; Use cpsr_{read,write} to access<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the whole CPSR.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t uncached_cpsr;<BR>&nbsp;&nbsp;&nbsp; uint32_t spsr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Banked registers.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint64_t banked_spsr[8];<BR>&nbsp;&nbsp;&nbsp; uint32_t banked_r13[8];<BR>&nbsp;&nbsp;&nbsp; uint32_t banked_r14[8];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* These hold r8-r12.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t usr_regs[5];<BR>&nbsp;&nbsp;&nbsp; uint32_t fiq_regs[5];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* cpsr flag cache for faster execution */<BR>&nbsp;&nbsp;&nbsp; uint32_t CF; /* 0 or 1 */<BR>&nbsp;&nbsp;&nbsp; uint32_t VF; /* V is the bit 31. All other bits are undefined */<BR>&nbsp;&nbsp;&nbsp; uint32_t NF; /* N is bit 31. All other bits are undefined.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t ZF; /* Z set if zero.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t QF; /* 0 or 1 */<BR>&nbsp;&nbsp;&nbsp; uint32_t GE; /* cpsr[19:16] */<BR>&nbsp;&nbsp;&nbsp; uint32_t thumb; /* cpsr[5]. 0 = arm mode, 1 = thumb mode. */<BR>&nbsp;&nbsp;&nbsp; uint32_t condexec_bits; /* IT bits.&nbsp; cpsr[15:10,26:25].&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint64_t daif; /* exception masks, in the bits they are in PSTATE */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; uint64_t elr_el[4]; /* AArch64 exception link regs&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint64_t sp_el[4]; /* AArch64 banked stack pointers */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* System control coprocessor (cp15) */<BR>&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c0_cpuid;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union { /* Cache size selection */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_csselr0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t csselr_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_csselr1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t csselr_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t csselr_el[4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union { /* System control register. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_sctlr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t sctlr_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t hsctlr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t sctlr_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t sctlr_el[4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t cpacr_el1; /* Architectural feature access control register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t cptr_el[4];&nbsp; /* ARMv8 feature trap registers */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c1_xscaleauxcr; /* XScale auxiliary control register.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t sder; /* Secure debug enable register. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t nsacr; /* Non-secure access control register. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union { /* MMU translation table base 0. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_ttbr0_0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t ttbr0_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_ttbr0_1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t ttbr0_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t ttbr0_el[4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union { /* MMU translation table base 1. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_ttbr1_0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t ttbr1_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_ttbr1_1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t ttbr1_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t ttbr1_el[4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t vttbr_el2; /* Virtualization Translation Table Base.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* MMU translation table base control. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCR tcr_el[4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCR vtcr_el2; /* Virtualization Translation Control.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c2_data; /* MPU data cacheable bits.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c2_insn; /* MPU instruction cacheable bits.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union { /* MMU domain access control register<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * MPU write buffer control.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t dacr_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t dacr_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t dacr32_el2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t pmsav5_data_ap; /* PMSAv5 MPU data access permissions */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t pmsav5_insn_ap; /* PMSAv5 MPU insn access permissions */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t hcr_el2; /* Hypervisor configuration register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t scr_el3; /* Secure configuration register.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union { /* Fault status registers.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t ifsr_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t ifsr_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t ifsr32_el2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_dfsr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t dfsr_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t hsr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t dfsr_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t esr_el[4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c6_region[8]; /* MPU base/size registers.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union { /* Fault address registers. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_far0;<BR>#ifdef HOST_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t ifar_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t dfar_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t ifar_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t dfar_s;<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t dfar_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t ifar_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t dfar_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t ifar_s;<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_far3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t far_el[4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t hpfar_el2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t hstr_el2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union { /* Translation result. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_par_0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t par_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_par_1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t par_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t par_el[4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c6_rgnr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c9_insn; /* Cache lockdown registers.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c9_data;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t c9_pmcr; /* performance monitor control register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t c9_pmcnten; /* perf monitor counter enables */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c9_pmovsr; /* perf monitor overflow status */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c9_pmxevtyper; /* perf monitor event type */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c9_pmuserenr; /* perf monitor user enable */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c9_pminten; /* perf monitor interrupt enables */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union { /* Memory attribute redirection */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>#ifdef HOST_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_mair_0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t mair1_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t mair0_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_mair_1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t mair1_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t mair0_s;<BR>#else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_mair_0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t mair0_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t mair1_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_mair_1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t mair0_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t mair1_s;<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t mair_el[4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union { /* vector base address register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_vbar;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t vbar_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t hvbar;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t vbar_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t vbar_el[4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t mvbar; /* (monitor) vector base address register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct { /* FCSE PID. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t fcseidr_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t fcseidr_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union { /* Context ID. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_contextidr_0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t contextidr_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _unused_contextidr_1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t contextidr_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t contextidr_el[4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union { /* User RW Thread register. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t tpidrurw_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t tpidrprw_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t htpidr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t _tpidr_el3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t tpidr_el[4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The secure banks of these registers don't map anywhere */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t tpidrurw_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t tpidrprw_s;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t tpidruro_s;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union { /* User RO Thread register. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t tpidruro_ns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t tpidrro_el[1];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t c14_cntfrq; /* Counter Frequency register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t c14_cntkctl; /* Timer Control register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t cnthctl_el2; /* Counter/Timer Hyp Control register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t cntvoff_el2; /* Counter Virtual Offset register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMGenericTimer c14_timer[NUM_GTIMERS];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c15_cpar; /* XScale Coprocessor Access Register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c15_ticonfig; /* TI925T configuration byte.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c15_i_max; /* Maximum D-cache dirty line index.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c15_i_min; /* Minimum D-cache dirty line index.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c15_threadid; /* TI debugger thread-ID.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c15_config_base_address; /* SCU base address.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c15_diagnostic; /* diagnostic register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c15_power_diagnostic;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t c15_power_control; /* power control */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t dbgbvr[16]; /* breakpoint value registers */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t dbgbcr[16]; /* breakpoint control registers */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t dbgwvr[16]; /* watchpoint value registers */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t dbgwcr[16]; /* watchpoint control registers */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t mdscr_el1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t oslsr_el1; /* OS Lock Status */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t mdcr_el2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t mdcr_el3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If the counter is enabled, this stores the last time the counter<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * was reset. Otherwise it stores the counter value<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t c15_ccnt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t pmccfiltr_el0; /* Performance Monitor Filter Register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t vpidr_el2; /* Virtualization Processor ID Register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t vmpidr_el2; /* Virtualization Multiprocessor ID Register */<BR>&nbsp;&nbsp;&nbsp; } cp15;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t other_sp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t vecbase;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t basepri;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t control;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int current_sp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int exception;<BR>&nbsp;&nbsp;&nbsp; } v7m;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Information associated with an exception about to be taken:<BR>&nbsp;&nbsp;&nbsp;&nbsp; * code which raises an exception must set cs-&gt;exception_index and<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the relevant parts of this structure; the cpu_do_interrupt function<BR>&nbsp;&nbsp;&nbsp;&nbsp; * will then set the guest-visible registers as part of the exception<BR>&nbsp;&nbsp;&nbsp;&nbsp; * entry process.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t syndrome; /* AArch64 format syndrome register */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t fsr; /* AArch32 format fault status register info */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t vaddress; /* virtual addr associated with exception, if any */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t target_el; /* EL the exception should be targeted for */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If we implement EL2 we will also need to store information<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * about the intermediate physical address for stage 2 faults.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; } exception;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Thumb-2 EE state.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t teecr;<BR>&nbsp;&nbsp;&nbsp; uint32_t teehbr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* VFP coprocessor state.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* VFP/Neon register state. Note that the mapping between S, D and Q<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * views of the register bank differs between AArch64 and AArch32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * In AArch32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; Qn = regs[2n+1]:regs[2n]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; Dn = regs[n]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; Sn = regs[n/2] bits 31..0 for even n, and bits 63..32 for odd n<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * (and regs[32] to regs[63] are inaccessible)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * In AArch64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; Qn = regs[2n+1]:regs[2n]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; Dn = regs[2n]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; Sn = regs[2n] bits 31..0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * This corresponds to the architecturally defined mapping between<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the two execution states, and means we do not need to explicitly<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * map these registers when changing states.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float64 regs[64];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t xregs[16];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We store these fpcsr fields separately for convenience.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int vec_len;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int vec_stride;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* scratch space when Tn are not sufficient.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t scratch[8];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* fp_status is the "normal" fp status. standard_fp_status retains<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * values corresponding to the ARM "Standard FPSCR Value", ie<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * default-NaN, flush-to-zero, round-to-nearest and is used by<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * any operations (generally Neon) which the architecture defines<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * as controlled by the standard FPSCR value rather than the FPSCR.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * To avoid having to transfer exception bits around, we simply<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * say that the FPSCR cumulative exception flags are the logical<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * OR of the flags in the two fp statuses. This relies on the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * only thing which needs to read the exception flags being<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * an explicit FPSCR read.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_status fp_status;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float_status standard_fp_status;<BR>&nbsp;&nbsp;&nbsp; } vfp;<BR>&nbsp;&nbsp;&nbsp; uint64_t exclusive_addr;<BR>&nbsp;&nbsp;&nbsp; uint64_t exclusive_val;<BR>&nbsp;&nbsp;&nbsp; uint64_t exclusive_high;<BR>#if defined(CONFIG_USER_ONLY)<BR>&nbsp;&nbsp;&nbsp; uint64_t exclusive_test;<BR>&nbsp;&nbsp;&nbsp; uint32_t exclusive_info;<BR>#endif</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* iwMMXt coprocessor state.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t regs[16];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t val;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t cregs[16];<BR>&nbsp;&nbsp;&nbsp; } iwmmxt;</FONT></P>
<P><FONT class=extract>#if defined(CONFIG_USER_ONLY)<BR>&nbsp;&nbsp;&nbsp; /* For usermode syscall translation.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int eabi;<BR>#endif</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; struct CPUBreakpoint *cpu_breakpoint[16];<BR>&nbsp;&nbsp;&nbsp; struct CPUWatchpoint *cpu_watchpoint[16];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPU_COMMON</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* These fields after the common ones so they are preserved on reset.&nbsp; */</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Internal CPU feature flags.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint64_t features;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* PMSAv7 MPU */<BR>&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t *drbar;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t *drsr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t *dracr;<BR>&nbsp;&nbsp;&nbsp; } pmsav7;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; void *nvic;<BR>&nbsp;&nbsp;&nbsp; const struct arm_boot_info *boot_info;<BR>} CPUARMState;</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* ARMELChangeHook:<BR>&nbsp;* type of a function which can be registered via arm_register_el_change_hook()<BR>&nbsp;* to get callbacks when the CPU changes its exception level or mode.<BR>&nbsp;*/<BR>typedef void ARMELChangeHook(ARMCPU *cpu, void *opaque);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* ARMCPU:<BR>&nbsp;* @env: #CPUARMState<BR>&nbsp;*<BR>&nbsp;* An ARM CPU core.<BR>&nbsp;*/<BR>struct ARMCPU {<BR>&nbsp;&nbsp;&nbsp; /*&lt; private &gt;*/<BR>&nbsp;&nbsp;&nbsp; CPUState parent_obj;<BR>&nbsp;&nbsp;&nbsp; /*&lt; public &gt;*/</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; CPUARMState env;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Coprocessor information */<BR>&nbsp;&nbsp;&nbsp; GHashTable *cp_regs;<BR>&nbsp;&nbsp;&nbsp; /* For marshalling (mostly coprocessor) register state between the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * kernel and QEMU (for KVM) and between two QEMUs (for migration),<BR>&nbsp;&nbsp;&nbsp;&nbsp; * we use these arrays.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; /* List of register indexes managed via these arrays; (full KVM style<BR>&nbsp;&nbsp;&nbsp;&nbsp; * 64 bit indexes, not CPRegInfo 32 bit indexes)<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint64_t *cpreg_indexes;<BR>&nbsp;&nbsp;&nbsp; /* Values of the registers (cpreg_indexes[i]'s value is cpreg_values[i]) */<BR>&nbsp;&nbsp;&nbsp; uint64_t *cpreg_values;<BR>&nbsp;&nbsp;&nbsp; /* Length of the indexes, values, reset_values arrays */<BR>&nbsp;&nbsp;&nbsp; int32_t cpreg_array_len;<BR>&nbsp;&nbsp;&nbsp; /* These are used only for migration: incoming data arrives in<BR>&nbsp;&nbsp;&nbsp;&nbsp; * these fields and is sanity checked in post_load before copying<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to the working data structures above.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint64_t *cpreg_vmstate_indexes;<BR>&nbsp;&nbsp;&nbsp; uint64_t *cpreg_vmstate_values;<BR>&nbsp;&nbsp;&nbsp; int32_t cpreg_vmstate_array_len;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Timers used by the generic (architected) timer */<BR>&nbsp;&nbsp;&nbsp; QEMUTimer *gt_timer[NUM_GTIMERS];<BR>&nbsp;&nbsp;&nbsp; /* GPIO outputs for generic timer */<BR>&nbsp;&nbsp;&nbsp; qemu_irq gt_timer_outputs[NUM_GTIMERS];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* MemoryRegion to use for secure physical accesses */<BR>&nbsp;&nbsp;&nbsp; MemoryRegion *secure_memory;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* 'compatible' string for this CPU for Linux device trees */<BR>&nbsp;&nbsp;&nbsp; const char *dtb_compatible;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* PSCI version for this CPU<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Bits[31:16] = Major Version<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Bits[15:0] = Minor Version<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t psci_version;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Should CPU start in PSCI powered-off state? */<BR>&nbsp;&nbsp;&nbsp; bool start_powered_off;<BR>&nbsp;&nbsp;&nbsp; /* CPU currently in PSCI powered-off state */<BR>&nbsp;&nbsp;&nbsp; bool powered_off;<BR>&nbsp;&nbsp;&nbsp; /* CPU has security extension */<BR>&nbsp;&nbsp;&nbsp; bool has_el3;<BR>&nbsp;&nbsp;&nbsp; /* CPU has PMU (Performance Monitor Unit) */<BR>&nbsp;&nbsp;&nbsp; bool has_pmu;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* CPU has memory protection unit */<BR>&nbsp;&nbsp;&nbsp; bool has_mpu;<BR>&nbsp;&nbsp;&nbsp; /* PMSAv7 MPU number of supported regions */<BR>&nbsp;&nbsp;&nbsp; uint32_t pmsav7_dregion;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* PSCI conduit used to invoke PSCI methods<BR>&nbsp;&nbsp;&nbsp;&nbsp; * 0 - disabled, 1 - smc, 2 - hvc<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t psci_conduit;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* [QEMU_]KVM_ARM_TARGET_* constant for this CPU, or<BR>&nbsp;&nbsp;&nbsp;&nbsp; * QEMU_KVM_ARM_TARGET_NONE if the kernel doesn't support this CPU type.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t kvm_target;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* KVM init features for this CPU */<BR>&nbsp;&nbsp;&nbsp; uint32_t kvm_init_features[7];</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* Uniprocessor system with MP extensions */<BR>&nbsp;&nbsp;&nbsp; bool mp_is_up;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* The instance init functions for implementation-specific subclasses<BR>&nbsp;&nbsp;&nbsp;&nbsp; * set these fields to specify the implementation-dependent values of<BR>&nbsp;&nbsp;&nbsp;&nbsp; * various constant registers and reset values of non-constant<BR>&nbsp;&nbsp;&nbsp;&nbsp; * registers.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Some of these might become QOM properties eventually.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Field names match the official register names as defined in the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * ARMv7AR ARM Architecture Reference Manual. A reset_ prefix<BR>&nbsp;&nbsp;&nbsp;&nbsp; * is used for reset values of non-constant registers; no reset_<BR>&nbsp;&nbsp;&nbsp;&nbsp; * prefix means a constant register.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t midr;<BR>&nbsp;&nbsp;&nbsp; uint32_t revidr;<BR>&nbsp;&nbsp;&nbsp; uint32_t reset_fpsid;<BR>&nbsp;&nbsp;&nbsp; uint32_t mvfr0;<BR>&nbsp;&nbsp;&nbsp; uint32_t mvfr1;<BR>&nbsp;&nbsp;&nbsp; uint32_t mvfr2;<BR>&nbsp;&nbsp;&nbsp; uint32_t ctr;<BR>&nbsp;&nbsp;&nbsp; uint32_t reset_sctlr;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_pfr0;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_pfr1;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_dfr0;<BR>&nbsp;&nbsp;&nbsp; uint32_t pmceid0;<BR>&nbsp;&nbsp;&nbsp; uint32_t pmceid1;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_afr0;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_mmfr0;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_mmfr1;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_mmfr2;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_mmfr3;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_mmfr4;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_isar0;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_isar1;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_isar2;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_isar3;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_isar4;<BR>&nbsp;&nbsp;&nbsp; uint32_t id_isar5;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64pfr0;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64pfr1;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64dfr0;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64dfr1;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64afr0;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64afr1;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64isar0;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64isar1;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64mmfr0;<BR>&nbsp;&nbsp;&nbsp; uint64_t id_aa64mmfr1;<BR>&nbsp;&nbsp;&nbsp; uint32_t dbgdidr;<BR>&nbsp;&nbsp;&nbsp; uint32_t clidr;<BR>&nbsp;&nbsp;&nbsp; uint64_t mp_affinity; /* MP ID without feature bits */<BR>&nbsp;&nbsp;&nbsp; /* The elements of this array are the CCSIDR values for each cache,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * in the order L1DCache, L1ICache, L2DCache, L2ICache, etc.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint32_t ccsidr[16];<BR>&nbsp;&nbsp;&nbsp; uint64_t reset_cbar;<BR>&nbsp;&nbsp;&nbsp; uint32_t reset_auxcr;<BR>&nbsp;&nbsp;&nbsp; bool reset_hivecs;<BR>&nbsp;&nbsp;&nbsp; /* DCZ blocksize, in log_2(words), ie low 4 bits of DCZID_EL0 */<BR>&nbsp;&nbsp;&nbsp; uint32_t dcz_blocksize;<BR>&nbsp;&nbsp;&nbsp; uint64_t rvbar;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; ARMELChangeHook *el_change_hook;<BR>&nbsp;&nbsp;&nbsp; void *el_change_hook_opaque;<BR>};</FONT></P>
<P><FONT class=extract>static inline ARMCPU *arm_env_get_cpu(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return container_of(env, ARMCPU, env);<BR>}</FONT></P>
<P><FONT class=extract>#define ENV_GET_CPU(e) CPU(arm_env_get_cpu(e))</FONT></P>
<P><FONT class=extract>#define ENV_OFFSET offsetof(ARMCPU, env)</FONT></P>
<P><FONT class=extract>#ifndef CONFIG_USER_ONLY<BR>extern const struct VMStateDescription vmstate_arm_cpu;<BR>#endif</FONT></P>
<P>void arm_cpu_do_interrupt(CPUState *cpu);<BR>void arm_v7m_cpu_do_interrupt(CPUState *cpu);<BR>bool arm_cpu_exec_interrupt(CPUState *cpu, int int_req);</P>
<P>void arm_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int flags);</P>
<P>hwaddr arm_cpu_get_phys_page_attrs_debug(CPUState *cpu, vaddr addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemTxAttrs *attrs);</P>
<P>int arm_cpu_gdb_read_register(CPUState *cpu, uint8_t *buf, int reg);<BR>int arm_cpu_gdb_write_register(CPUState *cpu, uint8_t *buf, int reg);</P>
<P>int arm_cpu_write_elf64_note(WriteCoreDumpFunction f, CPUState *cs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cpuid, void *opaque);<BR>int arm_cpu_write_elf32_note(WriteCoreDumpFunction f, CPUState *cs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cpuid, void *opaque);</P>
<P>#ifdef TARGET_AARCH64<BR>int aarch64_cpu_gdb_read_register(CPUState *cpu, uint8_t *buf, int reg);<BR>int aarch64_cpu_gdb_write_register(CPUState *cpu, uint8_t *buf, int reg);<BR>#endif</P>
<P>ARMCPU *cpu_arm_init(const char *cpu_model);<BR>target_ulong do_arm_semihosting(CPUARMState *env);<BR>void aarch64_sync_32_to_64(CPUARMState *env);<BR>void aarch64_sync_64_to_32(CPUARMState *env);</P>
<P><FONT class=extract>static inline bool is_a64(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return env-&gt;aarch64;<BR>}</FONT></P>
<P><FONT class=extract>/* you can call this signal handler from your SIGBUS and SIGSEGV<BR>&nbsp;&nbsp; signal handlers to inform the virtual CPU of exceptions. non zero<BR>&nbsp;&nbsp; is returned if the signal was handled by the virtual CPU.&nbsp; */<BR>int cpu_arm_signal_handler(int host_signum, void *pinfo,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *puc);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* pmccntr_sync<BR>&nbsp;* @env: CPUARMState<BR>&nbsp;*<BR>&nbsp;* Synchronises the counter in the PMCCNTR. This must always be called twice,<BR>&nbsp;* once before any action that might affect the timer and again afterwards.<BR>&nbsp;* The function is used to swap the state of the register if required.<BR>&nbsp;* This only happens when not in user mode (!CONFIG_USER_ONLY)<BR>&nbsp;*/<BR>void pmccntr_sync(CPUARMState *env);</FONT></P>
<P>/* SCTLR bit meanings. Several bits have been reused in newer<BR>&nbsp;* versions of the architecture; in that case we define constants<BR>&nbsp;* for both old and new bit meanings. Code which tests against those<BR>&nbsp;* bits should probably check or otherwise arrange that the CPU<BR>&nbsp;* is the architectural version it expects.<BR>&nbsp;*/<BR>#define SCTLR_M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 0)<BR>#define SCTLR_A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 1)<BR>#define SCTLR_C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 2)<BR>#define SCTLR_W&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 3) /* up to v6; RAO in v7 */<BR>#define SCTLR_SA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 3)<BR>#define SCTLR_P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 4) /* up to v5; RAO in v6 and v7 */<BR>#define SCTLR_SA0&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 4) /* v8 onward, AArch64 only */<BR>#define SCTLR_D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 5) /* up to v5; RAO in v6 */<BR>#define SCTLR_CP15BEN (1U &lt;&lt; 5) /* v7 onward */<BR>#define SCTLR_L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 6) /* up to v5; RAO in v6 and v7; RAZ in v8 */<BR>#define SCTLR_B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 7) /* up to v6; RAZ in v7 */<BR>#define SCTLR_ITD&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 7) /* v8 onward */<BR>#define SCTLR_S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 8) /* up to v6; RAZ in v7 */<BR>#define SCTLR_SED&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 8) /* v8 onward */<BR>#define SCTLR_R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 9) /* up to v6; RAZ in v7 */<BR>#define SCTLR_UMA&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 9) /* v8 onward, AArch64 only */<BR>#define SCTLR_F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 10) /* up to v6 */<BR>#define SCTLR_SW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 10) /* v7 onward */<BR>#define SCTLR_Z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 11)<BR>#define SCTLR_I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 12)<BR>#define SCTLR_V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 13)<BR>#define SCTLR_RR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 14) /* up to v7 */<BR>#define SCTLR_DZE&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 14) /* v8 onward, AArch64 only */<BR>#define SCTLR_L4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 15) /* up to v6; RAZ in v7 */<BR>#define SCTLR_UCT&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 15) /* v8 onward, AArch64 only */<BR>#define SCTLR_DT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 16) /* up to ??, RAO in v6 and v7 */<BR>#define SCTLR_nTWI&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 16) /* v8 onward */<BR>#define SCTLR_HA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 17)<BR>#define SCTLR_BR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 17) /* PMSA only */<BR>#define SCTLR_IT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 18) /* up to ??, RAO in v6 and v7 */<BR>#define SCTLR_nTWE&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 18) /* v8 onward */<BR>#define SCTLR_WXN&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 19)<BR>#define SCTLR_ST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 20) /* up to ??, RAZ in v6 */<BR>#define SCTLR_UWXN&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 20) /* v7 onward */<BR>#define SCTLR_FI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 21)<BR>#define SCTLR_U&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 22)<BR>#define SCTLR_XP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 23) /* up to v6; v7 onward RAO */<BR>#define SCTLR_VE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 24) /* up to v7 */<BR>#define SCTLR_E0E&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 24) /* v8 onward, AArch64 only */<BR>#define SCTLR_EE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 25)<BR>#define SCTLR_L2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 26) /* up to v6, RAZ in v7 */<BR>#define SCTLR_UCI&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 26) /* v8 onward, AArch64 only */<BR>#define SCTLR_NMFI&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 27)<BR>#define SCTLR_TRE&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 28)<BR>#define SCTLR_AFE&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 29)<BR>#define SCTLR_TE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 30)</P>
<P>#define CPTR_TCPAC&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 31)<BR>#define CPTR_TTA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 20)<BR>#define CPTR_TFP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 10)</P>
<P>#define MDCR_EPMAD&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 21)<BR>#define MDCR_EDAD&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 20)<BR>#define MDCR_SPME&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 17)<BR>#define MDCR_SDD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 16)<BR>#define MDCR_SPD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3U &lt;&lt; 14)<BR>#define MDCR_TDRA&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 11)<BR>#define MDCR_TDOSA&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 10)<BR>#define MDCR_TDA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 9)<BR>#define MDCR_TDE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 8)<BR>#define MDCR_HPME&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 7)<BR>#define MDCR_TPM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 6)<BR>#define MDCR_TPMCR&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 5)</P>
<P>/* Not all of the MDCR_EL3 bits are present in the 32-bit SDCR */<BR>#define SDCR_VALID_MASK (MDCR_EPMAD | MDCR_EDAD | MDCR_SPME | MDCR_SPD)</P>
<P>#define CPSR_M (0x1fU)<BR>#define CPSR_T (1U &lt;&lt; 5)<BR>#define CPSR_F (1U &lt;&lt; 6)<BR>#define CPSR_I (1U &lt;&lt; 7)<BR>#define CPSR_A (1U &lt;&lt; 8)<BR>#define CPSR_E (1U &lt;&lt; 9)<BR>#define CPSR_IT_2_7 (0xfc00U)<BR>#define CPSR_GE (0xfU &lt;&lt; 16)<BR>#define CPSR_IL (1U &lt;&lt; 20)<BR>/* Note that the RESERVED bits include bit 21, which is PSTATE_SS in<BR>&nbsp;* an AArch64 SPSR but RES0 in AArch32 SPSR and CPSR. In QEMU we use<BR>&nbsp;* env-&gt;uncached_cpsr bit 21 to store PSTATE.SS when executing in AArch32,<BR>&nbsp;* where it is live state but not accessible to the AArch32 code.<BR>&nbsp;*/<BR>#define CPSR_RESERVED (0x7U &lt;&lt; 21)<BR>#define CPSR_J (1U &lt;&lt; 24)<BR>#define CPSR_IT_0_1 (3U &lt;&lt; 25)<BR>#define CPSR_Q (1U &lt;&lt; 27)<BR>#define CPSR_V (1U &lt;&lt; 28)<BR>#define CPSR_C (1U &lt;&lt; 29)<BR>#define CPSR_Z (1U &lt;&lt; 30)<BR>#define CPSR_N (1U &lt;&lt; 31)<BR>#define CPSR_NZCV (CPSR_N | CPSR_Z | CPSR_C | CPSR_V)<BR>#define CPSR_AIF (CPSR_A | CPSR_I | CPSR_F)</P>
<P>#define CPSR_IT (CPSR_IT_0_1 | CPSR_IT_2_7)<BR>#define CACHED_CPSR_BITS (CPSR_T | CPSR_AIF | CPSR_GE | CPSR_IT | CPSR_Q \<BR>&nbsp;&nbsp;&nbsp; | CPSR_NZCV)<BR>/* Bits writable in user mode.&nbsp; */<BR>#define CPSR_USER (CPSR_NZCV | CPSR_Q | CPSR_GE)<BR>/* Execution state bits.&nbsp; MRS read as zero, MSR writes ignored.&nbsp; */<BR>#define CPSR_EXEC (CPSR_T | CPSR_IT | CPSR_J | CPSR_IL)<BR>/* Mask of bits which may be set by exception return copying them from SPSR */<BR>#define CPSR_ERET_MASK (~CPSR_RESERVED)</P>
<P>#define TTBCR_N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (7U &lt;&lt; 0) /* TTBCR.EAE==0 */<BR>#define TTBCR_T0SZ&nbsp;&nbsp; (7U &lt;&lt; 0) /* TTBCR.EAE==1 */<BR>#define TTBCR_PD0&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 4)<BR>#define TTBCR_PD1&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 5)<BR>#define TTBCR_EPD0&nbsp;&nbsp; (1U &lt;&lt; 7)<BR>#define TTBCR_IRGN0&nbsp; (3U &lt;&lt; 8)<BR>#define TTBCR_ORGN0&nbsp; (3U &lt;&lt; 10)<BR>#define TTBCR_SH0&nbsp;&nbsp;&nbsp; (3U &lt;&lt; 12)<BR>#define TTBCR_T1SZ&nbsp;&nbsp; (3U &lt;&lt; 16)<BR>#define TTBCR_A1&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 22)<BR>#define TTBCR_EPD1&nbsp;&nbsp; (1U &lt;&lt; 23)<BR>#define TTBCR_IRGN1&nbsp; (3U &lt;&lt; 24)<BR>#define TTBCR_ORGN1&nbsp; (3U &lt;&lt; 26)<BR>#define TTBCR_SH1&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 28)<BR>#define TTBCR_EAE&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 31)</P>
<P>/* Bit definitions for ARMv8 SPSR (PSTATE) format.<BR>&nbsp;* Only these are valid when in AArch64 mode; in<BR>&nbsp;* AArch32 mode SPSRs are basically CPSR-format.<BR>&nbsp;*/<BR>#define PSTATE_SP (1U)<BR>#define PSTATE_M (0xFU)<BR>#define PSTATE_nRW (1U &lt;&lt; 4)<BR>#define PSTATE_F (1U &lt;&lt; 6)<BR>#define PSTATE_I (1U &lt;&lt; 7)<BR>#define PSTATE_A (1U &lt;&lt; 8)<BR>#define PSTATE_D (1U &lt;&lt; 9)<BR>#define PSTATE_IL (1U &lt;&lt; 20)<BR>#define PSTATE_SS (1U &lt;&lt; 21)<BR>#define PSTATE_V (1U &lt;&lt; 28)<BR>#define PSTATE_C (1U &lt;&lt; 29)<BR>#define PSTATE_Z (1U &lt;&lt; 30)<BR>#define PSTATE_N (1U &lt;&lt; 31)<BR>#define PSTATE_NZCV (PSTATE_N | PSTATE_Z | PSTATE_C | PSTATE_V)<BR>#define PSTATE_DAIF (PSTATE_D | PSTATE_A | PSTATE_I | PSTATE_F)<BR>#define CACHED_PSTATE_BITS (PSTATE_NZCV | PSTATE_DAIF)<BR>/* Mode values for AArch64 */<BR>#define PSTATE_MODE_EL3h 13<BR>#define PSTATE_MODE_EL3t 12<BR>#define PSTATE_MODE_EL2h 9<BR>#define PSTATE_MODE_EL2t 8<BR>#define PSTATE_MODE_EL1h 5<BR>#define PSTATE_MODE_EL1t 4<BR>#define PSTATE_MODE_EL0t 0</P>
<P><FONT class=extract>/* Map EL and handler into a PSTATE_MODE.&nbsp; */<BR>static inline unsigned int aarch64_pstate_mode(unsigned int el, bool handler)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (el &lt;&lt; 2) | handler;<BR>}</FONT></P>
<P><FONT class=extract>/* Return the current PSTATE value. For the moment we don't support 32&lt;-&gt;64 bit<BR>&nbsp;* interprocessing, so we don't attempt to sync with the cpsr state used by<BR>&nbsp;* the 32 bit decoder.<BR>&nbsp;*/<BR>static inline uint32_t pstate_read(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int ZF;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; ZF = (env-&gt;ZF == 0);<BR>&nbsp;&nbsp;&nbsp; return (env-&gt;NF &amp; 0x80000000) | (ZF &lt;&lt; 30)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (env-&gt;CF &lt;&lt; 29) | ((env-&gt;VF &amp; 0x80000000) &gt;&gt; 3)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | env-&gt;pstate | env-&gt;daif;<BR>}</FONT></P>
<P><FONT class=extract>static inline void pstate_write(CPUARMState *env, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;ZF = (~val) &amp; PSTATE_Z;<BR>&nbsp;&nbsp;&nbsp; env-&gt;NF = val;<BR>&nbsp;&nbsp;&nbsp; env-&gt;CF = (val &gt;&gt; 29) &amp; 1;<BR>&nbsp;&nbsp;&nbsp; env-&gt;VF = (val &lt;&lt; 3) &amp; 0x80000000;<BR>&nbsp;&nbsp;&nbsp; env-&gt;daif = val &amp; PSTATE_DAIF;<BR>&nbsp;&nbsp;&nbsp; env-&gt;pstate = val &amp; ~CACHED_PSTATE_BITS;<BR>}</FONT></P>
<P><FONT class=extract>/* Return the current CPSR value.&nbsp; */<BR>uint32_t cpsr_read(CPUARMState *env);</FONT></P>
<P><FONT class=extract>typedef enum CPSRWriteType {<BR>&nbsp;&nbsp;&nbsp; CPSRWriteByInstr = 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* from guest MSR or CPS */<BR>&nbsp;&nbsp;&nbsp; CPSRWriteExceptionReturn = 1, /* from guest exception return insn */<BR>&nbsp;&nbsp;&nbsp; CPSRWriteRaw = 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* trust values, do not switch reg banks */<BR>&nbsp;&nbsp;&nbsp; CPSRWriteByGDBStub = 3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* from the GDB stub */<BR>} CPSRWriteType;</FONT></P>
<P><FONT class=extract>/* Set the CPSR.&nbsp; Note that some bits of mask must be all-set or all-clear.*/<BR>void cpsr_write(CPUARMState *env, uint32_t val, uint32_t mask,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPSRWriteType write_type);</FONT></P>
<P><FONT class=extract>/* Return the current xPSR value.&nbsp; */<BR>static inline uint32_t xpsr_read(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int ZF;<BR>&nbsp;&nbsp;&nbsp; ZF = (env-&gt;ZF == 0);<BR>&nbsp;&nbsp;&nbsp; return (env-&gt;NF &amp; 0x80000000) | (ZF &lt;&lt; 30)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (env-&gt;CF &lt;&lt; 29) | ((env-&gt;VF &amp; 0x80000000) &gt;&gt; 3) | (env-&gt;QF &lt;&lt; 27)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (env-&gt;thumb &lt;&lt; 24) | ((env-&gt;condexec_bits &amp; 3) &lt;&lt; 25)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ((env-&gt;condexec_bits &amp; 0xfc) &lt;&lt; 8)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | env-&gt;v7m.exception;<BR>}</FONT></P>
<P><FONT class=extract>/* Set the xPSR.&nbsp; Note that some bits of mask must be all-set or all-clear.&nbsp; */<BR>static inline void xpsr_write(CPUARMState *env, uint32_t val, uint32_t mask)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (mask &amp; CPSR_NZCV) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;ZF = (~val) &amp; CPSR_Z;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;NF = val;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;CF = (val &gt;&gt; 29) &amp; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;VF = (val &lt;&lt; 3) &amp; 0x80000000;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (mask &amp; CPSR_Q)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;QF = ((val &amp; CPSR_Q) != 0);<BR>&nbsp;&nbsp;&nbsp; if (mask &amp; (1 &lt;&lt; 24))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;thumb = ((val &amp; (1 &lt;&lt; 24)) != 0);<BR>&nbsp;&nbsp;&nbsp; if (mask &amp; CPSR_IT_0_1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;condexec_bits &amp;= ~3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;condexec_bits |= (val &gt;&gt; 25) &amp; 3;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (mask &amp; CPSR_IT_2_7) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;condexec_bits &amp;= 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;condexec_bits |= (val &gt;&gt; 8) &amp; 0xfc;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (mask &amp; 0x1ff) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;v7m.exception = val &amp; 0x1ff;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P>#define HCR_VM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 0)<BR>#define HCR_SWIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 1)<BR>#define HCR_PTW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 2)<BR>#define HCR_FMO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 3)<BR>#define HCR_IMO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 4)<BR>#define HCR_AMO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 5)<BR>#define HCR_VF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 6)<BR>#define HCR_VI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 7)<BR>#define HCR_VSE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 8)<BR>#define HCR_FB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 9)<BR>#define HCR_BSU_MASK&nbsp; (3ULL &lt;&lt; 10)<BR>#define HCR_DC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 12)<BR>#define HCR_TWI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 13)<BR>#define HCR_TWE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 14)<BR>#define HCR_TID0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 15)<BR>#define HCR_TID1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 16)<BR>#define HCR_TID2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 17)<BR>#define HCR_TID3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 18)<BR>#define HCR_TSC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 19)<BR>#define HCR_TIDCP&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 20)<BR>#define HCR_TACR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 21)<BR>#define HCR_TSW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 22)<BR>#define HCR_TPC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 23)<BR>#define HCR_TPU&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 24)<BR>#define HCR_TTLB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 25)<BR>#define HCR_TVM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 26)<BR>#define HCR_TGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 27)<BR>#define HCR_TDZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 28)<BR>#define HCR_HCD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 29)<BR>#define HCR_TRVM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 30)<BR>#define HCR_RW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 31)<BR>#define HCR_CD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 32)<BR>#define HCR_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ULL &lt;&lt; 33)<BR>#define HCR_MASK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((1ULL &lt;&lt; 34) - 1)</P>
<P>#define SCR_NS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 0)<BR>#define SCR_IRQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 1)<BR>#define SCR_FIQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 2)<BR>#define SCR_EA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 3)<BR>#define SCR_FW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 4)<BR>#define SCR_AW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 5)<BR>#define SCR_NET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 6)<BR>#define SCR_SMD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 7)<BR>#define SCR_HCE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 8)<BR>#define SCR_SIF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 9)<BR>#define SCR_RW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 10)<BR>#define SCR_ST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 11)<BR>#define SCR_TWI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 12)<BR>#define SCR_TWE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1U &lt;&lt; 13)<BR>#define SCR_AARCH32_MASK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0x3fff &amp; ~(SCR_RW | SCR_ST))<BR>#define SCR_AARCH64_MASK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0x3fff &amp; ~SCR_NET)</P>
<P>/* Return the current FPSCR value.&nbsp; */<BR>uint32_t vfp_get_fpscr(CPUARMState *env);<BR>void vfp_set_fpscr(CPUARMState *env, uint32_t val);</P>
<P>/* For A64 the FPSCR is split into two logically distinct registers,<BR>&nbsp;* FPCR and FPSR. However since they still use non-overlapping bits<BR>&nbsp;* we store the underlying state in fpscr and just mask on read/write.<BR>&nbsp;*/<BR>#define FPSR_MASK 0xf800009f<BR>#define FPCR_MASK 0x07f79f00<BR>static inline uint32_t vfp_get_fpsr(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return vfp_get_fpscr(env) &amp; FPSR_MASK;<BR>}</P>
<P>static inline void vfp_set_fpsr(CPUARMState *env, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t new_fpscr = (vfp_get_fpscr(env) &amp; ~FPSR_MASK) | (val &amp; FPSR_MASK);<BR>&nbsp;&nbsp;&nbsp; vfp_set_fpscr(env, new_fpscr);<BR>}</P>
<P>static inline uint32_t vfp_get_fpcr(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return vfp_get_fpscr(env) &amp; FPCR_MASK;<BR>}</P>
<P>static inline void vfp_set_fpcr(CPUARMState *env, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t new_fpscr = (vfp_get_fpscr(env) &amp; ~FPCR_MASK) | (val &amp; FPCR_MASK);<BR>&nbsp;&nbsp;&nbsp; vfp_set_fpscr(env, new_fpscr);<BR>}</P>
<P><FONT class=extract>enum arm_cpu_mode {<BR>&nbsp; ARM_CPU_MODE_USR = 0x10,<BR>&nbsp; ARM_CPU_MODE_FIQ = 0x11,<BR>&nbsp; ARM_CPU_MODE_IRQ = 0x12,<BR>&nbsp; ARM_CPU_MODE_SVC = 0x13,<BR>&nbsp; ARM_CPU_MODE_MON = 0x16,<BR>&nbsp; ARM_CPU_MODE_ABT = 0x17,<BR>&nbsp; ARM_CPU_MODE_HYP = 0x1a,<BR>&nbsp; ARM_CPU_MODE_UND = 0x1b,<BR>&nbsp; ARM_CPU_MODE_SYS = 0x1f<BR>};</FONT></P>
<P>/* VFP system registers.&nbsp; */<BR>#define ARM_VFP_FPSID&nbsp;&nbsp; 0<BR>#define ARM_VFP_FPSCR&nbsp;&nbsp; 1<BR>#define ARM_VFP_MVFR2&nbsp;&nbsp; 5<BR>#define ARM_VFP_MVFR1&nbsp;&nbsp; 6<BR>#define ARM_VFP_MVFR0&nbsp;&nbsp; 7<BR>#define ARM_VFP_FPEXC&nbsp;&nbsp; 8<BR>#define ARM_VFP_FPINST&nbsp; 9<BR>#define ARM_VFP_FPINST2 10</P>
<P>/* iwMMXt coprocessor control registers.&nbsp; */<BR>#define ARM_IWMMXT_wCID&nbsp;&nbsp;0<BR>#define ARM_IWMMXT_wCon&nbsp;&nbsp;1<BR>#define ARM_IWMMXT_wCSSF&nbsp;2<BR>#define ARM_IWMMXT_wCASF&nbsp;3<BR>#define ARM_IWMMXT_wCGR0&nbsp;8<BR>#define ARM_IWMMXT_wCGR1&nbsp;9<BR>#define ARM_IWMMXT_wCGR2&nbsp;10<BR>#define ARM_IWMMXT_wCGR3&nbsp;11</P>
<P>/* If adding a feature bit which corresponds to a Linux ELF<BR>&nbsp;* HWCAP bit, remember to update the feature-bit-to-hwcap<BR>&nbsp;* mapping in linux-user/elfload.c:get_elf_hwcap().<BR>&nbsp;*/<BR><FONT class=extract>enum arm_features {<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_VFP,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_AUXCR,&nbsp; /* ARM1026 Auxiliary control register.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_XSCALE, /* Intel XScale extensions.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_IWMMXT, /* Intel iwMMXt extension.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_V6,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_V6K,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_V7,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_THUMB2,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_MPU,&nbsp;&nbsp;&nbsp; /* Only has Memory Protection Unit, not full MMU.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_VFP3,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_VFP_FP16,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_NEON,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_THUMB_DIV, /* divide supported in Thumb encoding */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_M, /* Microcontroller profile.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_OMAPCP, /* OMAP specific CP15 ops handling.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_THUMB2EE,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_V7MP,&nbsp;&nbsp;&nbsp; /* v7 Multiprocessing Extensions */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_V4T,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_V5,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_STRONGARM,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_VAPA, /* cp15 VA to PA lookups */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_ARM_DIV, /* divide supported in ARM encoding */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_VFP4, /* VFPv4 (implies that NEON is v2) */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_GENERIC_TIMER,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_MVFR, /* Media and VFP Feature Registers 0 and 1 */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_DUMMY_C15_REGS, /* RAZ/WI all of cp15 crn=15 */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_CACHE_TEST_CLEAN, /* 926/1026 style test-and-clean ops */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_CACHE_DIRTY_REG, /* 1136/1176 cache dirty status register */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_CACHE_BLOCK_OPS, /* v6 optional cache block operations */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_MPIDR, /* has cp15 MPIDR */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_PXN, /* has Privileged Execute Never bit */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_LPAE, /* has Large Physical Address Extension */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_V8,<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_AARCH64, /* supports 64 bit mode */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_V8_AES, /* implements AES part of v8 Crypto Extensions */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_CBAR, /* has cp15 CBAR */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_CRC, /* ARMv8 CRC instructions */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_CBAR_RO, /* has cp15 CBAR and it is read-only */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_EL2, /* has EL2 Virtualization support */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_EL3, /* has EL3 Secure monitor support */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_V8_SHA1, /* implements SHA1 part of v8 Crypto Extensions */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_V8_SHA256, /* implements SHA256 part of v8 Crypto Extensions */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_V8_PMULL, /* implements PMULL part of v8 Crypto Extensions */<BR>&nbsp;&nbsp;&nbsp; ARM_FEATURE_THUMB_DSP, /* DSP insns supported in the Thumb encodings */<BR>};</FONT></P>
<P><FONT class=extract>static inline int arm_feature(CPUARMState *env, int feature)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (env-&gt;features &amp; (1ULL &lt;&lt; feature)) != 0;<BR>}</FONT></P>
<P><FONT class=extract>#if !defined(CONFIG_USER_ONLY)<BR>/* Return true if exception levels below EL3 are in secure state,<BR>&nbsp;* or would be following an exception return to that level.<BR>&nbsp;* Unlike arm_is_secure() (which is always a question about the<BR>&nbsp;* _current_ state of the CPU) this doesn't care about the current<BR>&nbsp;* EL or mode.<BR>&nbsp;*/<BR>static inline bool arm_is_secure_below_el3(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return !(env-&gt;cp15.scr_el3 &amp; SCR_NS);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If EL3 is not supported then the secure state is implementation<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * defined, in which case QEMU defaults to non-secure.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>/* Return true if the CPU is AArch64 EL3 or AArch32 Mon */<BR>static inline bool arm_is_el3_or_mon(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_a64(env) &amp;&amp; extract32(env-&gt;pstate, 2, 2) == 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* CPU currently in AArch64 state and EL3 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (!is_a64(env) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (env-&gt;uncached_cpsr &amp; CPSR_M) == ARM_CPU_MODE_MON) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* CPU currently in AArch32 state and monitor mode */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return false;<BR>}</FONT></P>
<P><FONT class=extract>/* Return true if the processor is in secure state */<BR>static inline bool arm_is_secure(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_is_el3_or_mon(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return arm_is_secure_below_el3(env);<BR>}</FONT></P>
<P><FONT class=extract>#else<BR>static inline bool arm_is_secure_below_el3(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return false;<BR>}</FONT></P>
<P><FONT class=extract>static inline bool arm_is_secure(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return false;<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>/* Return true if the specified exception level is running in AArch64 state. */<BR>static inline bool arm_el_is_aa64(CPUARMState *env, int el)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* This isn't valid for EL0 (if we're in EL0, is_a64() is what you want,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and if we're not in EL0 then the state of EL0 isn't well defined.)<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; assert(el &gt;= 1 &amp;&amp; el &lt;= 3);<BR>&nbsp;&nbsp;&nbsp; bool aa64 = arm_feature(env, ARM_FEATURE_AARCH64);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* The highest exception level is always at the maximum supported<BR>&nbsp;&nbsp;&nbsp;&nbsp; * register width, and then lower levels have a register width controlled<BR>&nbsp;&nbsp;&nbsp;&nbsp; * by bits in the SCR or HCR registers.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (el == 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return aa64;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aa64 = aa64 &amp;&amp; (env-&gt;cp15.scr_el3 &amp; SCR_RW);<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (el == 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return aa64;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL2) &amp;&amp; !arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aa64 = aa64 &amp;&amp; (env-&gt;cp15.hcr_el2 &amp; HCR_RW);<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return aa64;<BR>}</FONT></P>
<P><FONT class=extract>/* Function for determing whether guest cp register reads and writes should<BR>&nbsp;* access the secure or non-secure bank of a cp register.&nbsp; When EL3 is<BR>&nbsp;* operating in AArch32 state, the NS-bit determines whether the secure<BR>&nbsp;* instance of a cp register should be used. When EL3 is AArch64 (or if<BR>&nbsp;* it doesn't exist at all) then there is no register banking, and all<BR>&nbsp;* accesses are to the non-secure version.<BR>&nbsp;*/<BR>static inline bool access_secure_reg(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; bool ret = (arm_feature(env, ARM_FEATURE_EL3) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_el_is_aa64(env, 3) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !(env-&gt;cp15.scr_el3 &amp; SCR_NS));</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return ret;<BR>}</FONT></P>
<P><FONT class=extract>/* Macros for accessing a specified CP register bank */<BR>#define A32_BANKED_REG_GET(_env, _regname, _secure)&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; ((_secure) ? (_env)-&gt;cp15._regname##_s : (_env)-&gt;cp15._regname##_ns)</FONT></P>
<P><FONT class=extract>#define A32_BANKED_REG_SET(_env, _regname, _secure, _val)&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_secure) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (_env)-&gt;cp15._regname##_s = (_val);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (_env)-&gt;cp15._regname##_ns = (_val);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; } while (0)</FONT></P>
<P><FONT class=extract>/* Macros for automatically accessing a specific CP register bank depending on<BR>&nbsp;* the current secure state of the system.&nbsp; These macros are not intended for<BR>&nbsp;* supporting instruction translation reads/writes as these are dependent<BR>&nbsp;* solely on the SCR.NS bit and not the mode.<BR>&nbsp;*/<BR>#define A32_BANKED_CURRENT_REG_GET(_env, _regname)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; A32_BANKED_REG_GET((_env), _regname,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (arm_is_secure(_env) &amp;&amp; !arm_el_is_aa64((_env), 3)))</FONT></P>
<P><FONT class=extract>#define A32_BANKED_CURRENT_REG_SET(_env, _regname, _val)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; A32_BANKED_REG_SET((_env), _regname,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (arm_is_secure(_env) &amp;&amp; !arm_el_is_aa64((_env), 3)), \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (_val))</FONT></P>
<P>void arm_cpu_list(FILE *f, fprintf_function cpu_fprintf);<BR>uint32_t arm_phys_excp_target_el(CPUState *cs, uint32_t excp_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t cur_el, bool secure);</P>
<P><FONT class=extract>/* Interface between CPU and Interrupt controller.&nbsp; */<BR>void armv7m_nvic_set_pending(void *opaque, int irq);<BR>int armv7m_nvic_acknowledge_irq(void *opaque);<BR>void armv7m_nvic_complete_irq(void *opaque, int irq);</FONT></P>
<P>/* Interface for defining coprocessor registers.<BR>&nbsp;* Registers are defined in tables of arm_cp_reginfo structs<BR>&nbsp;* which are passed to define_arm_cp_regs().<BR>&nbsp;*/</P>
<P>/* When looking up a coprocessor register we look for it<BR>&nbsp;* via an integer which encodes all of:<BR>&nbsp;*&nbsp; coprocessor number<BR>&nbsp;*&nbsp; Crn, Crm, opc1, opc2 fields<BR>&nbsp;*&nbsp; 32 or 64 bit register (ie is it accessed via MRC/MCR<BR>&nbsp;*&nbsp;&nbsp;&nbsp; or via MRRC/MCRR?)<BR>&nbsp;*&nbsp; non-secure/secure bank (AArch32 only)<BR>&nbsp;* We allow 4 bits for opc1 because MRRC/MCRR have a 4 bit field.<BR>&nbsp;* (In this case crn and opc2 should be zero.)<BR>&nbsp;* For AArch64, there is no 32/64 bit size distinction;<BR>&nbsp;* instead all registers have a 2 bit op0, 3 bit op1 and op2,<BR>&nbsp;* and 4 bit CRn and CRm. The encoding patterns are chosen<BR>&nbsp;* to be easy to convert to and from the KVM encodings, and also<BR>&nbsp;* so that the hashtable can contain both AArch32 and AArch64<BR>&nbsp;* registers (to allow for interprocessing where we might run<BR>&nbsp;* 32 bit code on a 64 bit core).<BR>&nbsp;*/<BR>/* This bit is private to our hashtable cpreg; in KVM register<BR>&nbsp;* IDs the AArch64/32 distinction is the KVM_REG_ARM/ARM64<BR>&nbsp;* in the upper bits of the 64 bit ID.<BR>&nbsp;*/<BR>#define CP_REG_AA64_SHIFT 28<BR>#define CP_REG_AA64_MASK (1 &lt;&lt; CP_REG_AA64_SHIFT)</P>
<P>/* To enable banking of coprocessor registers depending on ns-bit we<BR>&nbsp;* add a bit to distinguish between secure and non-secure cpregs in the<BR>&nbsp;* hashtable.<BR>&nbsp;*/<BR>#define CP_REG_NS_SHIFT 29<BR>#define CP_REG_NS_MASK (1 &lt;&lt; CP_REG_NS_SHIFT)</P>
<P>#define ENCODE_CP_REG(cp, is64, ns, crn, crm, opc1, opc2)&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; ((ns) &lt;&lt; CP_REG_NS_SHIFT | ((cp) &lt;&lt; 16) | ((is64) &lt;&lt; 15) |&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; ((crn) &lt;&lt; 11) | ((crm) &lt;&lt; 7) | ((opc1) &lt;&lt; 3) | (opc2))</P>
<P>#define ENCODE_AA64_CP_REG(cp, crn, crm, op0, op1, op2) \<BR>&nbsp;&nbsp;&nbsp; (CP_REG_AA64_MASK |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; ((cp) &lt;&lt; CP_REG_ARM_COPROC_SHIFT) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; ((op0) &lt;&lt; CP_REG_ARM64_SYSREG_OP0_SHIFT) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; ((op1) &lt;&lt; CP_REG_ARM64_SYSREG_OP1_SHIFT) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; ((crn) &lt;&lt; CP_REG_ARM64_SYSREG_CRN_SHIFT) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; ((crm) &lt;&lt; CP_REG_ARM64_SYSREG_CRM_SHIFT) |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; ((op2) &lt;&lt; CP_REG_ARM64_SYSREG_OP2_SHIFT))</P>
<P>/* Convert a full 64 bit KVM register ID to the truncated 32 bit<BR>&nbsp;* version used as a key for the coprocessor register hashtable<BR>&nbsp;*/<BR>static inline uint32_t kvm_to_cpreg_id(uint64_t kvmid)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t cpregid = kvmid;<BR>&nbsp;&nbsp;&nbsp; if ((kvmid &amp; CP_REG_ARCH_MASK) == CP_REG_ARM64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpregid |= CP_REG_AA64_MASK;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((kvmid &amp; CP_REG_SIZE_MASK) == CP_REG_SIZE_U64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpregid |= (1 &lt;&lt; 15);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* KVM is always non-secure so add the NS flag on AArch32 register<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * entries.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpregid |= 1 &lt;&lt; CP_REG_NS_SHIFT;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return cpregid;<BR>}</P>
<P>/* Convert a truncated 32 bit hashtable key into the full<BR>&nbsp;* 64 bit KVM register ID.<BR>&nbsp;*/<BR>static inline uint64_t cpreg_to_kvm_id(uint32_t cpregid)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t kvmid;</P>
<P>&nbsp;&nbsp;&nbsp; if (cpregid &amp; CP_REG_AA64_MASK) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kvmid = cpregid &amp; ~CP_REG_AA64_MASK;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kvmid |= CP_REG_SIZE_U64 | CP_REG_ARM64;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kvmid = cpregid &amp; ~(1 &lt;&lt; 15);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cpregid &amp; (1 &lt;&lt; 15)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kvmid |= CP_REG_SIZE_U64 | CP_REG_ARM;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kvmid |= CP_REG_SIZE_U32 | CP_REG_ARM;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return kvmid;<BR>}</P>
<P>/* ARMCPRegInfo type field bits. If the SPECIAL bit is set this is a<BR>&nbsp;* special-behaviour cp reg and bits [15..8] indicate what behaviour<BR>&nbsp;* it has. Otherwise it is a simple cp reg, where CONST indicates that<BR>&nbsp;* TCG can assume the value to be constant (ie load at translate time)<BR>&nbsp;* and 64BIT indicates a 64 bit wide coprocessor register. SUPPRESS_TB_END<BR>&nbsp;* indicates that the TB should not be ended after a write to this register<BR>&nbsp;* (the default is that the TB ends after cp writes). OVERRIDE permits<BR>&nbsp;* a register definition to override a previous definition for the<BR>&nbsp;* same (cp, is64, crn, crm, opc1, opc2) tuple: either the new or the<BR>&nbsp;* old must have the OVERRIDE bit set.<BR>&nbsp;* ALIAS indicates that this register is an alias view of some underlying<BR>&nbsp;* state which is also visible via another register, and that the other<BR>&nbsp;* register is handling migration and reset; registers marked ALIAS will not be<BR>&nbsp;* migrated but may have their state set by syncing of register state from KVM.<BR>&nbsp;* NO_RAW indicates that this register has no underlying state and does not<BR>&nbsp;* support raw access for state saving/loading; it will not be used for either<BR>&nbsp;* migration or KVM state synchronization. (Typically this is for "registers"<BR>&nbsp;* which are actually used as instructions for cache maintenance and so on.)<BR>&nbsp;* IO indicates that this register does I/O and therefore its accesses<BR>&nbsp;* need to be surrounded by gen_io_start()/gen_io_end(). In particular,<BR>&nbsp;* registers which implement clocks or timers require this.<BR>&nbsp;*/<BR>#define ARM_CP_SPECIAL 1<BR>#define ARM_CP_CONST 2<BR>#define ARM_CP_64BIT 4<BR>#define ARM_CP_SUPPRESS_TB_END 8<BR>#define ARM_CP_OVERRIDE 16<BR>#define ARM_CP_ALIAS 32<BR>#define ARM_CP_IO 64<BR>#define ARM_CP_NO_RAW 128<BR>#define ARM_CP_NOP (ARM_CP_SPECIAL | (1 &lt;&lt; 8))<BR>#define ARM_CP_WFI (ARM_CP_SPECIAL | (2 &lt;&lt; 8))<BR>#define ARM_CP_NZCV (ARM_CP_SPECIAL | (3 &lt;&lt; 8))<BR>#define ARM_CP_CURRENTEL (ARM_CP_SPECIAL | (4 &lt;&lt; 8))<BR>#define ARM_CP_DC_ZVA (ARM_CP_SPECIAL | (5 &lt;&lt; 8))<BR>#define ARM_LAST_SPECIAL ARM_CP_DC_ZVA<BR>/* Used only as a terminator for ARMCPRegInfo lists */<BR>#define ARM_CP_SENTINEL 0xffff<BR>/* Mask of only the flag bits in a type field */<BR>#define ARM_CP_FLAG_MASK 0xff</P>
<P>/* Valid values for ARMCPRegInfo state field, indicating which of<BR>&nbsp;* the AArch32 and AArch64 execution states this register is visible in.<BR>&nbsp;* If the reginfo doesn't explicitly specify then it is AArch32 only.<BR>&nbsp;* If the reginfo is declared to be visible in both states then a second<BR>&nbsp;* reginfo is synthesised for the AArch32 view of the AArch64 register,<BR>&nbsp;* such that the AArch32 view is the lower 32 bits of the AArch64 one.<BR>&nbsp;* Note that we rely on the values of these enums as we iterate through<BR>&nbsp;* the various states in some places.<BR>&nbsp;*/<BR>enum {<BR>&nbsp;&nbsp;&nbsp; ARM_CP_STATE_AA32 = 0,<BR>&nbsp;&nbsp;&nbsp; ARM_CP_STATE_AA64 = 1,<BR>&nbsp;&nbsp;&nbsp; ARM_CP_STATE_BOTH = 2,<BR>};</P>
<P>/* ARM CP register secure state flags.&nbsp; These flags identify security state<BR>&nbsp;* attributes for a given CP register entry.<BR>&nbsp;* The existence of both or neither secure and non-secure flags indicates that<BR>&nbsp;* the register has both a secure and non-secure hash entry.&nbsp; A single one of<BR>&nbsp;* these flags causes the register to only be hashed for the specified<BR>&nbsp;* security state.<BR>&nbsp;* Although definitions may have any combination of the S/NS bits, each<BR>&nbsp;* registered entry will only have one to identify whether the entry is secure<BR>&nbsp;* or non-secure.<BR>&nbsp;*/<BR>enum {<BR>&nbsp;&nbsp;&nbsp; ARM_CP_SECSTATE_S =&nbsp;&nbsp; (1 &lt;&lt; 0), /* bit[0]: Secure state register */<BR>&nbsp;&nbsp;&nbsp; ARM_CP_SECSTATE_NS =&nbsp; (1 &lt;&lt; 1), /* bit[1]: Non-secure state register */<BR>};</P>
<P>/* Return true if cptype is a valid type field. This is used to try to<BR>&nbsp;* catch errors where the sentinel has been accidentally left off the end<BR>&nbsp;* of a list of registers.<BR>&nbsp;*/<BR>static inline bool cptype_valid(int cptype)<BR>{<BR>&nbsp;&nbsp;&nbsp; return ((cptype &amp; ~ARM_CP_FLAG_MASK) == 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || ((cptype &amp; ARM_CP_SPECIAL) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((cptype &amp; ~ARM_CP_FLAG_MASK) &lt;= ARM_LAST_SPECIAL));<BR>}</P>
<P><FONT class=extract>/* Access rights:<BR>&nbsp;* We define bits for Read and Write access for what rev C of the v7-AR ARM ARM<BR>&nbsp;* defines as PL0 (user), PL1 (fiq/irq/svc/abt/und/sys, ie privileged), and<BR>&nbsp;* PL2 (hyp). The other level which has Read and Write bits is Secure PL1<BR>&nbsp;* (ie any of the privileged modes in Secure state, or Monitor mode).<BR>&nbsp;* If a register is accessible in one privilege level it's always accessible<BR>&nbsp;* in higher privilege levels too. Since "Secure PL1" also follows this rule<BR>&nbsp;* (ie anything visible in PL2 is visible in S-PL1, some things are only<BR>&nbsp;* visible in S-PL1) but "Secure PL1" is a bit of a mouthful, we bend the<BR>&nbsp;* terminology a little and call this PL3.<BR>&nbsp;* In AArch64 things are somewhat simpler as the PLx bits line up exactly<BR>&nbsp;* with the ELx exception levels.<BR>&nbsp;*<BR>&nbsp;* If access permissions for a register are more complex than can be<BR>&nbsp;* described with these bits, then use a laxer set of restrictions, and<BR>&nbsp;* do the more restrictive/complex check inside a helper function.<BR>&nbsp;*/<BR>#define PL3_R 0x80<BR>#define PL3_W 0x40<BR>#define PL2_R (0x20 | PL3_R)<BR>#define PL2_W (0x10 | PL3_W)<BR>#define PL1_R (0x08 | PL2_R)<BR>#define PL1_W (0x04 | PL2_W)<BR>#define PL0_R (0x02 | PL1_R)<BR>#define PL0_W (0x01 | PL1_W)</FONT></P>
<P><FONT class=extract>#define PL3_RW (PL3_R | PL3_W)<BR>#define PL2_RW (PL2_R | PL2_W)<BR>#define PL1_RW (PL1_R | PL1_W)<BR>#define PL0_RW (PL0_R | PL0_W)</FONT></P>
<P><FONT class=extract>/* Return the highest implemented Exception Level */<BR>static inline int arm_highest_el(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return 1;<BR>}</FONT></P>
<P><FONT class=extract>/* Return the current Exception Level (as per ARMv8; note that this differs<BR>&nbsp;* from the ARMv7 Privilege Level).<BR>&nbsp;*/<BR>static inline int arm_current_el(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_M)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return !((env-&gt;v7m.exception == 0) &amp;&amp; (env-&gt;v7m.control &amp; 1));<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (is_a64(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return extract32(env-&gt;pstate, 2, 2);<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; switch (env-&gt;uncached_cpsr &amp; 0x1f) {<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_USR:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_HYP:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_MON:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_is_secure(env) &amp;&amp; !arm_el_is_aa64(env, 3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If EL3 is 32-bit then all secure privileged modes run in<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * EL3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>typedef struct ARMCPRegInfo ARMCPRegInfo;</FONT></P>
<P>typedef enum CPAccessResult {<BR>&nbsp;&nbsp;&nbsp; /* Access is permitted */<BR>&nbsp;&nbsp;&nbsp; CP_ACCESS_OK = 0,<BR>&nbsp;&nbsp;&nbsp; /* Access fails due to a configurable trap or enable which would<BR>&nbsp;&nbsp;&nbsp;&nbsp; * result in a categorized exception syndrome giving information about<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the failing instruction (ie syndrome category 0x3, 0x4, 0x5, 0x6,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * 0xc or 0x18). The exception is taken to the usual target EL (EL1 or<BR>&nbsp;&nbsp;&nbsp;&nbsp; * PL1 if in EL0, otherwise to the current EL).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; CP_ACCESS_TRAP = 1,<BR>&nbsp;&nbsp;&nbsp; /* Access fails and results in an exception syndrome 0x0 ("uncategorized").<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Note that this is not a catch-all case -- the set of cases which may<BR>&nbsp;&nbsp;&nbsp;&nbsp; * result in this failure is specifically defined by the architecture.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; CP_ACCESS_TRAP_UNCATEGORIZED = 2,<BR>&nbsp;&nbsp;&nbsp; /* As CP_ACCESS_TRAP, but for traps directly to EL2 or EL3 */<BR>&nbsp;&nbsp;&nbsp; CP_ACCESS_TRAP_EL2 = 3,<BR>&nbsp;&nbsp;&nbsp; CP_ACCESS_TRAP_EL3 = 4,<BR>&nbsp;&nbsp;&nbsp; /* As CP_ACCESS_UNCATEGORIZED, but for traps directly to EL2 or EL3 */<BR>&nbsp;&nbsp;&nbsp; CP_ACCESS_TRAP_UNCATEGORIZED_EL2 = 5,<BR>&nbsp;&nbsp;&nbsp; CP_ACCESS_TRAP_UNCATEGORIZED_EL3 = 6,<BR>&nbsp;&nbsp;&nbsp; /* Access fails and results in an exception syndrome for an FP access,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * trapped directly to EL2 or EL3<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; CP_ACCESS_TRAP_FP_EL2 = 7,<BR>&nbsp;&nbsp;&nbsp; CP_ACCESS_TRAP_FP_EL3 = 8,<BR>} CPAccessResult;</P>
<P>/* Access functions for coprocessor registers. These cannot fail and<BR>&nbsp;* may not raise exceptions.<BR>&nbsp;*/<BR>typedef uint64_t CPReadFn(CPUARMState *env, const ARMCPRegInfo *opaque);<BR>typedef void CPWriteFn(CPUARMState *env, const ARMCPRegInfo *opaque,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value);<BR>/* Access permission check functions for coprocessor registers. */<BR>typedef CPAccessResult CPAccessFn(CPUARMState *env,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *opaque,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool isread);<BR>/* Hook function for register reset */<BR>typedef void CPResetFn(CPUARMState *env, const ARMCPRegInfo *opaque);</P>
<P>#define CP_ANY 0xff</P>
<P>/* Definition of an ARM coprocessor register */<BR>struct ARMCPRegInfo {<BR>&nbsp;&nbsp;&nbsp; /* Name of register (useful mainly for debugging, need not be unique) */<BR>&nbsp;&nbsp;&nbsp; const char *name;<BR>&nbsp;&nbsp;&nbsp; /* Location of register: coprocessor number and (crn,crm,opc1,opc2)<BR>&nbsp;&nbsp;&nbsp;&nbsp; * tuple. Any of crm, opc1 and opc2 may be CP_ANY to indicate a<BR>&nbsp;&nbsp;&nbsp;&nbsp; * 'wildcard' field -- any value of that field in the MRC/MCR insn<BR>&nbsp;&nbsp;&nbsp;&nbsp; * will be decoded to this register. The register read and write<BR>&nbsp;&nbsp;&nbsp;&nbsp; * callbacks will be passed an ARMCPRegInfo with the crn/crm/opc1/opc2<BR>&nbsp;&nbsp;&nbsp;&nbsp; * used by the program, so it is possible to register a wildcard and<BR>&nbsp;&nbsp;&nbsp;&nbsp; * then behave differently on read/write if necessary.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * For 64 bit registers, only crm and opc1 are relevant; crn and opc2<BR>&nbsp;&nbsp;&nbsp;&nbsp; * must both be zero.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * For AArch64-visible registers, opc0 is also used.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Since there are no "coprocessors" in AArch64, cp is purely used as a<BR>&nbsp;&nbsp;&nbsp;&nbsp; * way to distinguish (for KVM's benefit) guest-visible system registers<BR>&nbsp;&nbsp;&nbsp;&nbsp; * from demuxed ones provided to preserve the "no side effects on<BR>&nbsp;&nbsp;&nbsp;&nbsp; * KVM register read/write from QEMU" semantics. cp==0x13 is guest<BR>&nbsp;&nbsp;&nbsp;&nbsp; * visible (to match KVM's encoding); cp==0 will be converted to<BR>&nbsp;&nbsp;&nbsp;&nbsp; * cp==0x13 when the ARMCPRegInfo is registered, for convenience.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint8_t cp;<BR>&nbsp;&nbsp;&nbsp; uint8_t crn;<BR>&nbsp;&nbsp;&nbsp; uint8_t crm;<BR>&nbsp;&nbsp;&nbsp; uint8_t opc0;<BR>&nbsp;&nbsp;&nbsp; uint8_t opc1;<BR>&nbsp;&nbsp;&nbsp; uint8_t opc2;<BR>&nbsp;&nbsp;&nbsp; /* Execution state in which this register is visible: ARM_CP_STATE_* */<BR>&nbsp;&nbsp;&nbsp; int state;<BR>&nbsp;&nbsp;&nbsp; /* Register type: ARM_CP_* bits/values */<BR>&nbsp;&nbsp;&nbsp; int type;<BR>&nbsp;&nbsp;&nbsp; /* Access rights: PL*_[RW] */<BR>&nbsp;&nbsp;&nbsp; int access;<BR>&nbsp;&nbsp;&nbsp; /* Security state: ARM_CP_SECSTATE_* bits/values */<BR>&nbsp;&nbsp;&nbsp; int secure;<BR>&nbsp;&nbsp;&nbsp; /* The opaque pointer passed to define_arm_cp_regs_with_opaque() when<BR>&nbsp;&nbsp;&nbsp;&nbsp; * this register was defined: can be used to hand data through to the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * register read/write functions, since they are passed the ARMCPRegInfo*.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; void *opaque;<BR>&nbsp;&nbsp;&nbsp; /* Value of this register, if it is ARM_CP_CONST. Otherwise, if<BR>&nbsp;&nbsp;&nbsp;&nbsp; * fieldoffset is non-zero, the reset value of the register.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint64_t resetvalue;<BR>&nbsp;&nbsp;&nbsp; /* Offset of the field in CPUARMState for this register.<BR>&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This is not needed if either:<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; 1. type is ARM_CP_CONST or one of the ARM_CP_SPECIALs<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; 2. both readfn and writefn are specified<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ptrdiff_t fieldoffset; /* offsetof(CPUARMState, field) */</P>
<P>&nbsp;&nbsp;&nbsp; /* Offsets of the secure and non-secure fields in CPUARMState for the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * register if it is banked.&nbsp; These fields are only used during the static<BR>&nbsp;&nbsp;&nbsp;&nbsp; * registration of a register.&nbsp; During hashing the bank associated<BR>&nbsp;&nbsp;&nbsp;&nbsp; * with a given security state is copied to fieldoffset which is used from<BR>&nbsp;&nbsp;&nbsp;&nbsp; * there on out.<BR>&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp; * It is expected that register definitions use either fieldoffset or<BR>&nbsp;&nbsp;&nbsp;&nbsp; * bank_fieldoffsets in the definition but not both.&nbsp; It is also expected<BR>&nbsp;&nbsp;&nbsp;&nbsp; * that both bank offsets are set when defining a banked register.&nbsp; This<BR>&nbsp;&nbsp;&nbsp;&nbsp; * use indicates that a register is banked.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ptrdiff_t bank_fieldoffsets[2];</P>
<P>&nbsp;&nbsp;&nbsp; /* Function for making any access checks for this register in addition to<BR>&nbsp;&nbsp;&nbsp;&nbsp; * those specified by the 'access' permissions bits. If NULL, no extra<BR>&nbsp;&nbsp;&nbsp;&nbsp; * checks required. The access check is performed at runtime, not at<BR>&nbsp;&nbsp;&nbsp;&nbsp; * translate time.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; CPAccessFn *accessfn;<BR>&nbsp;&nbsp;&nbsp; /* Function for handling reads of this register. If NULL, then reads<BR>&nbsp;&nbsp;&nbsp;&nbsp; * will be done by loading from the offset into CPUARMState specified<BR>&nbsp;&nbsp;&nbsp;&nbsp; * by fieldoffset.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; CPReadFn *readfn;<BR>&nbsp;&nbsp;&nbsp; /* Function for handling writes of this register. If NULL, then writes<BR>&nbsp;&nbsp;&nbsp;&nbsp; * will be done by writing to the offset into CPUARMState specified<BR>&nbsp;&nbsp;&nbsp;&nbsp; * by fieldoffset.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; CPWriteFn *writefn;<BR>&nbsp;&nbsp;&nbsp; /* Function for doing a "raw" read; used when we need to copy<BR>&nbsp;&nbsp;&nbsp;&nbsp; * coprocessor state to the kernel for KVM or out for<BR>&nbsp;&nbsp;&nbsp;&nbsp; * migration. This only needs to be provided if there is also a<BR>&nbsp;&nbsp;&nbsp;&nbsp; * readfn and it has side effects (for instance clear-on-read bits).<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; CPReadFn *raw_readfn;<BR>&nbsp;&nbsp;&nbsp; /* Function for doing a "raw" write; used when we need to copy KVM<BR>&nbsp;&nbsp;&nbsp;&nbsp; * kernel coprocessor state into userspace, or for inbound<BR>&nbsp;&nbsp;&nbsp;&nbsp; * migration. This only needs to be provided if there is also a<BR>&nbsp;&nbsp;&nbsp;&nbsp; * writefn and it masks out "unwritable" bits or has write-one-to-clear<BR>&nbsp;&nbsp;&nbsp;&nbsp; * or similar behaviour.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; CPWriteFn *raw_writefn;<BR>&nbsp;&nbsp;&nbsp; /* Function for resetting the register. If NULL, then reset will be done<BR>&nbsp;&nbsp;&nbsp;&nbsp; * by writing resetvalue to the field specified in fieldoffset. If<BR>&nbsp;&nbsp;&nbsp;&nbsp; * fieldoffset is 0 then no reset will be done.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; CPResetFn *resetfn;<BR>};</P>
<P>/* Macros which are lvalues for the field in CPUARMState for the<BR>&nbsp;* ARMCPRegInfo *ri.<BR>&nbsp;*/<BR>#define CPREG_FIELD32(env, ri) \<BR>&nbsp;&nbsp;&nbsp; (*(uint32_t *)((char *)(env) + (ri)-&gt;fieldoffset))<BR>#define CPREG_FIELD64(env, ri) \<BR>&nbsp;&nbsp;&nbsp; (*(uint64_t *)((char *)(env) + (ri)-&gt;fieldoffset))</P>
<P>#define REGINFO_SENTINEL { .type = ARM_CP_SENTINEL }</P>
<P>void define_arm_cp_regs_with_opaque(ARMCPU *cpu,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *regs, void *opaque);<BR>void define_one_arm_cp_reg_with_opaque(ARMCPU *cpu,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *regs, void *opaque);<BR>static inline void define_arm_cp_regs(ARMCPU *cpu, const ARMCPRegInfo *regs)<BR>{<BR>&nbsp;&nbsp;&nbsp; define_arm_cp_regs_with_opaque(cpu, regs, 0);<BR>}<BR>static inline void define_one_arm_cp_reg(ARMCPU *cpu, const ARMCPRegInfo *regs)<BR>{<BR>&nbsp;&nbsp;&nbsp; define_one_arm_cp_reg_with_opaque(cpu, regs, 0);<BR>}<BR>const ARMCPRegInfo *get_arm_cp_reginfo(GHashTable *cpregs, uint32_t encoded_cp);</P>
<P>/* CPWriteFn that can be used to implement writes-ignored behaviour */<BR>void arm_cp_write_ignore(CPUARMState *env, const ARMCPRegInfo *ri,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t value);<BR>/* CPReadFn that can be used for read-as-zero behaviour */<BR>uint64_t arm_cp_read_zero(CPUARMState *env, const ARMCPRegInfo *ri);</P>
<P>/* CPResetFn that does nothing, for use if no reset is required even<BR>&nbsp;* if fieldoffset is non zero.<BR>&nbsp;*/<BR>void arm_cp_reset_ignore(CPUARMState *env, const ARMCPRegInfo *opaque);</P>
<P>/* Return true if this reginfo struct's field in the cpu state struct<BR>&nbsp;* is 64 bits wide.<BR>&nbsp;*/<BR>static inline bool cpreg_field_is_64bit(const ARMCPRegInfo *ri)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (ri-&gt;state == ARM_CP_STATE_AA64) || (ri-&gt;type &amp; ARM_CP_64BIT);<BR>}</P>
<P>static inline bool cp_access_ok(int current_el,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri, int isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (ri-&gt;access &gt;&gt; ((current_el * 2) + isread)) &amp; 1;<BR>}</P>
<P>/* Raw read of a coprocessor register (as needed for migration, etc) */<BR>uint64_t read_raw_cp_reg(CPUARMState *env, const ARMCPRegInfo *ri);</P>
<P>/**<BR>&nbsp;* write_list_to_cpustate<BR>&nbsp;* @cpu: ARMCPU<BR>&nbsp;*<BR>&nbsp;* For each register listed in the ARMCPU cpreg_indexes list, write<BR>&nbsp;* its value from the cpreg_values list into the ARMCPUState structure.<BR>&nbsp;* This updates TCG's working data structures from KVM data or<BR>&nbsp;* from incoming migration state.<BR>&nbsp;*<BR>&nbsp;* Returns: true if all register values were updated correctly,<BR>&nbsp;* false if some register was unknown or could not be written.<BR>&nbsp;* Note that we do not stop early on failure -- we will attempt<BR>&nbsp;* writing all registers in the list.<BR>&nbsp;*/<BR>bool write_list_to_cpustate(ARMCPU *cpu);</P>
<P>/**<BR>&nbsp;* write_cpustate_to_list:<BR>&nbsp;* @cpu: ARMCPU<BR>&nbsp;*<BR>&nbsp;* For each register listed in the ARMCPU cpreg_indexes list, write<BR>&nbsp;* its value from the ARMCPUState structure into the cpreg_values list.<BR>&nbsp;* This is used to copy info from TCG's working data structures into<BR>&nbsp;* KVM or for outbound migration.<BR>&nbsp;*<BR>&nbsp;* Returns: true if all register values were read correctly,<BR>&nbsp;* false if some register was unknown or could not be read.<BR>&nbsp;* Note that we do not stop early on failure -- we will attempt<BR>&nbsp;* reading all registers in the list.<BR>&nbsp;*/<BR>bool write_cpustate_to_list(ARMCPU *cpu);</P>
<P>/* Does the core conform to the "MicroController" profile. e.g. Cortex-M3.<BR>&nbsp;&nbsp; Note the M in older cores (eg. ARM7TDMI) stands for Multiply. These are<BR>&nbsp;&nbsp; conventional cores (ie. Application or Realtime profile).&nbsp; */</P>
<P>#define IS_M(env) arm_feature(env, ARM_FEATURE_M)</P>
<P>#define ARM_CPUID_TI915T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x54029152<BR>#define ARM_CPUID_TI925T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x54029252</P>
<P>#if defined(CONFIG_USER_ONLY)<BR>#define TARGET_PAGE_BITS 12<BR>#else<BR>/* The ARM MMU allows 1k pages.&nbsp; */<BR>/* ??? Linux doesn't actually use these, and they're deprecated in recent<BR>&nbsp;&nbsp; architecture revisions.&nbsp; Maybe a configure option to disable them.&nbsp; */<BR>#define TARGET_PAGE_BITS 10<BR>#endif</P>
<P>#if defined(TARGET_AARCH64)<BR>#&nbsp; define TARGET_PHYS_ADDR_SPACE_BITS 48<BR>#&nbsp; define TARGET_VIRT_ADDR_SPACE_BITS 64<BR>#else<BR>#&nbsp; define TARGET_PHYS_ADDR_SPACE_BITS 40<BR>#&nbsp; define TARGET_VIRT_ADDR_SPACE_BITS 32<BR>#endif</P>
<P>static inline bool arm_excp_unmasked(CPUState *cs, unsigned int excp_idx,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int target_el)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = cs-&gt;env_ptr;<BR>&nbsp;&nbsp;&nbsp; unsigned int cur_el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; bool secure = arm_is_secure(env);<BR>&nbsp;&nbsp;&nbsp; bool pstate_unmasked;<BR>&nbsp;&nbsp;&nbsp; int8_t unmasked = 0;</P>
<P>&nbsp;&nbsp;&nbsp; /* Don't take exceptions if they target a lower EL.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This check should catch any exceptions that would not be taken but left<BR>&nbsp;&nbsp;&nbsp;&nbsp; * pending.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (cur_el &gt; target_el) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch (excp_idx) {<BR>&nbsp;&nbsp;&nbsp; case EXCP_FIQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstate_unmasked = !(env-&gt;daif &amp; PSTATE_F);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case EXCP_IRQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstate_unmasked = !(env-&gt;daif &amp; PSTATE_I);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case EXCP_VFIQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (secure || !(env-&gt;cp15.hcr_el2 &amp; HCR_FMO)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* VFIQs are only taken when hypervized and non-secure.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return !(env-&gt;daif &amp; PSTATE_F);<BR>&nbsp;&nbsp;&nbsp; case EXCP_VIRQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (secure || !(env-&gt;cp15.hcr_el2 &amp; HCR_IMO)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* VIRQs are only taken when hypervized and non-secure.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return !(env-&gt;daif &amp; PSTATE_I);<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Use the target EL, current execution state and SCR/HCR settings to<BR>&nbsp;&nbsp;&nbsp;&nbsp; * determine whether the corresponding CPSR bit is used to mask the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * interrupt.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if ((target_el &gt; cur_el) &amp;&amp; (target_el != 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Exceptions targeting a higher EL may not be maskable */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_AARCH64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 64-bit masking rules are simple: exceptions to EL3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * can't be masked, and exceptions to EL2 can only be<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * masked from Secure state. The HCR and SCR settings<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * don't affect the masking logic, only the interrupt routing.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (target_el == 3 || !secure) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unmasked = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The old 32-bit-only environment has a more complicated<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * masking setup. HCR and SCR bits not only affect interrupt<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * routing but also change the behaviour of masking.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool hcr, scr;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (excp_idx) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case EXCP_FIQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If FIQs are routed to EL3 or EL2 then there are cases where<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * we override the CPSR.F in determining if the exception is<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * masked or not. If neither of these are set then we fall back<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * to the CPSR.F setting otherwise we further assess the state<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * below.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcr = (env-&gt;cp15.hcr_el2 &amp; HCR_FMO);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scr = (env-&gt;cp15.scr_el3 &amp; SCR_FIQ);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* When EL3 is 32-bit, the SCR.FW bit controls whether the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * CPSR.F bit masks FIQ interrupts when taken in non-secure<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * state. If SCR.FW is set then FIQs can be masked by CPSR.F<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * when non-secure but only when FIQs are only routed to EL3.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scr = scr &amp;&amp; !((env-&gt;cp15.scr_el3 &amp; SCR_FW) &amp;&amp; !hcr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case EXCP_IRQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* When EL3 execution state is 32-bit, if HCR.IMO is set then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * we may override the CPSR.I masking when in non-secure state.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * The SCR.IRQ setting has already been taken into consideration<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * when setting the target EL, so it does not have a further<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * affect here.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcr = (env-&gt;cp15.hcr_el2 &amp; HCR_IMO);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scr = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((scr || hcr) &amp;&amp; !secure) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unmasked = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* The PSTATE bits only mask the interrupt if we have not overriden the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * ability above.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; return unmasked || pstate_unmasked;<BR>}</P>
<P><FONT class=extract>#define cpu_init(cpu_model) CPU(cpu_arm_init(cpu_model))</FONT></P>
<P><FONT class=extract>#define cpu_signal_handler cpu_arm_signal_handler</FONT><BR><FONT class=extract>#define cpu_list arm_cpu_list</FONT></P>
<P><FONT class=extract>/* ARM has the following "translation regimes" (as the ARM ARM calls them):<BR>&nbsp;*<BR>&nbsp;* If EL3 is 64-bit:<BR>&nbsp;*&nbsp; + NonSecure EL1 &amp; 0 stage 1<BR>&nbsp;*&nbsp; + NonSecure EL1 &amp; 0 stage 2<BR>&nbsp;*&nbsp; + NonSecure EL2<BR>&nbsp;*&nbsp; + Secure EL1 &amp; EL0<BR>&nbsp;*&nbsp; + Secure EL3<BR>&nbsp;* If EL3 is 32-bit:<BR>&nbsp;*&nbsp; + NonSecure PL1 &amp; 0 stage 1<BR>&nbsp;*&nbsp; + NonSecure PL1 &amp; 0 stage 2<BR>&nbsp;*&nbsp; + NonSecure PL2<BR>&nbsp;*&nbsp; + Secure PL0 &amp; PL1<BR>&nbsp;* (reminder: for 32 bit EL3, Secure PL1 is *EL3*, not EL1.)<BR>&nbsp;*<BR>&nbsp;* For QEMU, an mmu_idx is not quite the same as a translation regime because:<BR>&nbsp;*&nbsp; 1. we need to split the "EL1 &amp; 0" regimes into two mmu_idxes, because they<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; may differ in access permissions even if the VA-&gt;PA map is the same<BR>&nbsp;*&nbsp; 2. we want to cache in our TLB the full VA-&gt;IPA-&gt;PA lookup for a stage 1+2<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; translation, which means that we have one mmu_idx that deals with two<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; concatenated translation regimes [this sort of combined s1+2 TLB is<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; architecturally permitted]<BR>&nbsp;*&nbsp; 3. we don't need to allocate an mmu_idx to translations that we won't be<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; handling via the TLB. The only way to do a stage 1 translation without<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; the immediate stage 2 translation is via the ATS or AT system insns,<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; which can be slow-pathed and always do a page table walk.<BR>&nbsp;*&nbsp; 4. we can also safely fold together the "32 bit EL3" and "64 bit EL3"<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; translation regimes, because they map reasonably well to each other<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; and they can't both be active at the same time.<BR>&nbsp;* This gives us the following list of mmu_idx values:<BR>&nbsp;*<BR>&nbsp;* NS EL0 (aka NS PL0) stage 1+2<BR>&nbsp;* NS EL1 (aka NS PL1) stage 1+2<BR>&nbsp;* NS EL2 (aka NS PL2)<BR>&nbsp;* S EL3 (aka S PL1)<BR>&nbsp;* S EL0 (aka S PL0)<BR>&nbsp;* S EL1 (not used if EL3 is 32 bit)<BR>&nbsp;* NS EL0+1 stage 2<BR>&nbsp;*<BR>&nbsp;* (The last of these is an mmu_idx because we want to be able to use the TLB<BR>&nbsp;* for the accesses done as part of a stage 1 page table walk, rather than<BR>&nbsp;* having to walk the stage 2 page table over and over.)<BR>&nbsp;*<BR>&nbsp;* Our enumeration includes at the end some entries which are not "true"<BR>&nbsp;* mmu_idx values in that they don't have corresponding TLBs and are only<BR>&nbsp;* valid for doing slow path page table walks.<BR>&nbsp;*<BR>&nbsp;* The constant names here are patterned after the general style of the names<BR>&nbsp;* of the AT/ATS operations.<BR>&nbsp;* The values used are carefully arranged to make mmu_idx =&gt; EL lookup easy.<BR>&nbsp;*/<BR>typedef enum ARMMMUIdx {<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S12NSE0 = 0,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S12NSE1 = 1,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1E2 = 2,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1E3 = 3,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1SE0 = 4,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1SE1 = 5,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S2NS = 6,<BR>&nbsp;&nbsp;&nbsp; /* Indexes below here don't have TLBs and are used only for AT system<BR>&nbsp;&nbsp;&nbsp;&nbsp; * instructions or for the first stage of an S12 page table walk.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1NSE0 = 7,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1NSE1 = 8,<BR>} ARMMMUIdx;</FONT></P>
<P><FONT class=extract>#define MMU_USER_IDX 0</FONT></P>
<P><FONT class=extract>/* Return the exception level we're running at if this is our mmu_idx */<BR>static inline int arm_mmu_idx_to_el(ARMMMUIdx mmu_idx)<BR>{<BR>&nbsp;&nbsp;&nbsp; assert(mmu_idx &lt; ARMMMUIdx_S2NS);<BR>&nbsp;&nbsp;&nbsp; return mmu_idx &amp; 3;<BR>}</FONT></P>
<P><FONT class=extract>/* Determine the current mmu_idx to use for normal loads/stores */<BR>static inline int cpu_mmu_index(CPUARMState *env, bool ifetch)<BR>{<BR>&nbsp;&nbsp;&nbsp; int el = arm_current_el(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (el &lt; 2 &amp;&amp; arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ARMMMUIdx_S1SE0 + el;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return el;<BR>}</FONT></P>
<P><FONT class=extract>/* Indexes used when registering address spaces with cpu_address_space_init */<BR>typedef enum ARMASIdx {<BR>&nbsp;&nbsp;&nbsp; ARMASIdx_NS = 0,<BR>&nbsp;&nbsp;&nbsp; ARMASIdx_S = 1,<BR>} ARMASIdx;</FONT></P>
<P><FONT class=extract>/* Return the Exception Level targeted by debug exceptions. */<BR>static inline int arm_debug_target_el(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; bool secure = arm_is_secure(env);<BR>&nbsp;&nbsp;&nbsp; bool route_to_el2 = false;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL2) &amp;&amp; !secure) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; route_to_el2 = env-&gt;cp15.hcr_el2 &amp; HCR_TGE ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.mdcr_el2 &amp; (1 &lt;&lt; 8);<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (route_to_el2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;<BR>&nbsp;&nbsp;&nbsp; } else if (arm_feature(env, ARM_FEATURE_EL3) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_el_is_aa64(env, 3) &amp;&amp; secure) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>static inline bool aa64_generate_debug_exceptions(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_is_secure(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* MDCR_EL3.SDD disables debug events from Secure state */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extract32(env-&gt;cp15.mdcr_el3, 16, 1) != 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || arm_current_el(env) == 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == arm_debug_target_el(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((extract32(env-&gt;cp15.mdscr_el1, 13, 1) == 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (env-&gt;daif &amp; PSTATE_D)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return true;<BR>}</FONT></P>
<P><FONT class=extract>static inline bool aa32_generate_debug_exceptions(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int el = arm_current_el(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (el == 0 &amp;&amp; arm_el_is_aa64(env, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return aa64_generate_debug_exceptions(env);<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (arm_is_secure(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int spd;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (el == 0 &amp;&amp; (env-&gt;cp15.sder &amp; 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* SDER.SUIDEN means debug exceptions from Secure EL0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * are always enabled. Otherwise they are controlled by<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * SDCR.SPD like those from other Secure ELs.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spd = extract32(env-&gt;cp15.mdcr_el3, 14, 2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (spd) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* SPD == 0b01 is reserved, but behaves as 0b00. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* For 0b00 we return true if external secure invasive debug<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * is enabled. On real hardware this is controlled by external<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * signals to the core. QEMU always permits debug, and behaves<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * as if DBGEN, SPIDEN, NIDEN and SPNIDEN are all tied high.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return el != 2;<BR>}</FONT></P>
<P><FONT class=extract>/* Return true if debugging exceptions are currently enabled.<BR>&nbsp;* This corresponds to what in ARM ARM pseudocode would be<BR>&nbsp;*&nbsp;&nbsp;&nbsp; if UsingAArch32() then<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return AArch32.GenerateDebugExceptions()<BR>&nbsp;*&nbsp;&nbsp;&nbsp; else<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return AArch64.GenerateDebugExceptions()<BR>&nbsp;* We choose to push the if() down into this function for clarity,<BR>&nbsp;* since the pseudocode has it at all callsites except for the one in<BR>&nbsp;* CheckSoftwareStep(), where it is elided because both branches would<BR>&nbsp;* always return the same value.<BR>&nbsp;*<BR>&nbsp;* Parts of the pseudocode relating to EL2 and EL3 are omitted because we<BR>&nbsp;* don't yet implement those exception levels or their associated trap bits.<BR>&nbsp;*/<BR>static inline bool arm_generate_debug_exceptions(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (env-&gt;aarch64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return aa64_generate_debug_exceptions(env);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return aa32_generate_debug_exceptions(env);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>/* Is single-stepping active? (Note that the "is EL_D AArch64?" check<BR>&nbsp;* implicitly means this always returns false in pre-v8 CPUs.)<BR>&nbsp;*/<BR>static inline bool arm_singlestep_active(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return extract32(env-&gt;cp15.mdscr_el1, 0, 1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; arm_el_is_aa64(env, arm_debug_target_el(env))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; arm_generate_debug_exceptions(env);<BR>}</FONT></P>
<P><FONT class=extract>static inline bool arm_sctlr_b(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We need not implement SCTLR.ITD in user-mode emulation, so<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * let linux-user ignore the fact that it conflicts with SCTLR_B.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * This lets people run BE32 binaries with "-cpu any".<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>#ifndef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_feature(env, ARM_FEATURE_V7) &amp;&amp;<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (env-&gt;cp15.sctlr_el[1] &amp; SCTLR_B) != 0;<BR>}</FONT></P>
<P><FONT class=extract>/* Return true if the processor is in big-endian mode. */<BR>static inline bool arm_cpu_data_is_big_endian(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int cur_el;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* In 32bit endianness is determined by looking at CPSR's E bit */<BR>&nbsp;&nbsp;&nbsp; if (!is_a64(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<BR>#ifdef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* In system mode, BE32 is modelled in line with the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * architecture (as word-invariant big-endianness), where loads<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * and stores are done little endian but from addresses which<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * are adjusted by XORing with the appropriate constant. So the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * endianness to use for the raw data access is not affected by<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * SCTLR.B.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * In user mode, however, we model BE32 as byte-invariant<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * big-endianness (because user-only code cannot tell the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * difference), and so we need to use a data access endianness<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * that depends on SCTLR.B.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_sctlr_b(env) ||<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((env-&gt;uncached_cpsr &amp; CPSR_E) ? 1 : 0);<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; cur_el = arm_current_el(env);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (cur_el == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (env-&gt;cp15.sctlr_el[1] &amp; SCTLR_E0E) != 0;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return (env-&gt;cp15.sctlr_el[cur_el] &amp; SCTLR_EE) != 0;<BR>}</FONT></P>
<P>#include "exec/cpu-all.h"</P>
<P>/* Bit usage in the TB flags field: bit 31 indicates whether we are<BR>&nbsp;* in 32 or 64 bit mode. The meaning of the other bits depends on that.<BR>&nbsp;* We put flags which are shared between 32 and 64 bit mode at the top<BR>&nbsp;* of the word, and flags which apply to only one mode at the bottom.<BR>&nbsp;*/<BR>#define ARM_TBFLAG_AARCH64_STATE_SHIFT 31<BR>#define ARM_TBFLAG_AARCH64_STATE_MASK&nbsp; (1U &lt;&lt; ARM_TBFLAG_AARCH64_STATE_SHIFT)<BR>#define ARM_TBFLAG_MMUIDX_SHIFT 28<BR>#define ARM_TBFLAG_MMUIDX_MASK (0x7 &lt;&lt; ARM_TBFLAG_MMUIDX_SHIFT)<BR>#define ARM_TBFLAG_SS_ACTIVE_SHIFT 27<BR>#define ARM_TBFLAG_SS_ACTIVE_MASK (1 &lt;&lt; ARM_TBFLAG_SS_ACTIVE_SHIFT)<BR>#define ARM_TBFLAG_PSTATE_SS_SHIFT 26<BR>#define ARM_TBFLAG_PSTATE_SS_MASK (1 &lt;&lt; ARM_TBFLAG_PSTATE_SS_SHIFT)<BR>/* Target EL if we take a floating-point-disabled exception */<BR>#define ARM_TBFLAG_FPEXC_EL_SHIFT 24<BR>#define ARM_TBFLAG_FPEXC_EL_MASK (0x3 &lt;&lt; ARM_TBFLAG_FPEXC_EL_SHIFT)</P>
<P>/* Bit usage when in AArch32 state: */<BR>#define ARM_TBFLAG_THUMB_SHIFT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#define ARM_TBFLAG_THUMB_MASK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; ARM_TBFLAG_THUMB_SHIFT)<BR>#define ARM_TBFLAG_VECLEN_SHIFT&nbsp;&nbsp;&nbsp;&nbsp; 1<BR>#define ARM_TBFLAG_VECLEN_MASK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0x7 &lt;&lt; ARM_TBFLAG_VECLEN_SHIFT)<BR>#define ARM_TBFLAG_VECSTRIDE_SHIFT&nbsp; 4<BR>#define ARM_TBFLAG_VECSTRIDE_MASK&nbsp;&nbsp; (0x3 &lt;&lt; ARM_TBFLAG_VECSTRIDE_SHIFT)<BR>#define ARM_TBFLAG_VFPEN_SHIFT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7<BR>#define ARM_TBFLAG_VFPEN_MASK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; ARM_TBFLAG_VFPEN_SHIFT)<BR>#define ARM_TBFLAG_CONDEXEC_SHIFT&nbsp;&nbsp; 8<BR>#define ARM_TBFLAG_CONDEXEC_MASK&nbsp;&nbsp;&nbsp; (0xff &lt;&lt; ARM_TBFLAG_CONDEXEC_SHIFT)<BR>#define ARM_TBFLAG_SCTLR_B_SHIFT&nbsp;&nbsp;&nbsp; 16<BR>#define ARM_TBFLAG_SCTLR_B_MASK&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; ARM_TBFLAG_SCTLR_B_SHIFT)<BR>/* We store the bottom two bits of the CPAR as TB flags and handle<BR>&nbsp;* checks on the other bits at runtime<BR>&nbsp;*/<BR>#define ARM_TBFLAG_XSCALE_CPAR_SHIFT 17<BR>#define ARM_TBFLAG_XSCALE_CPAR_MASK (3 &lt;&lt; ARM_TBFLAG_XSCALE_CPAR_SHIFT)<BR>/* Indicates whether cp register reads and writes by guest code should access<BR>&nbsp;* the secure or nonsecure bank of banked registers; note that this is not<BR>&nbsp;* the same thing as the current security state of the processor!<BR>&nbsp;*/<BR>#define ARM_TBFLAG_NS_SHIFT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19<BR>#define ARM_TBFLAG_NS_MASK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; ARM_TBFLAG_NS_SHIFT)<BR>#define ARM_TBFLAG_BE_DATA_SHIFT&nbsp;&nbsp;&nbsp; 20<BR>#define ARM_TBFLAG_BE_DATA_MASK&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; ARM_TBFLAG_BE_DATA_SHIFT)</P>
<P>/* Bit usage when in AArch64 state: currently we have no A64 specific bits */</P>
<P>/* some convenience accessor macros */<BR>#define ARM_TBFLAG_AARCH64_STATE(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_AARCH64_STATE_MASK) &gt;&gt; ARM_TBFLAG_AARCH64_STATE_SHIFT)<BR>#define ARM_TBFLAG_MMUIDX(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_MMUIDX_MASK) &gt;&gt; ARM_TBFLAG_MMUIDX_SHIFT)<BR>#define ARM_TBFLAG_SS_ACTIVE(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_SS_ACTIVE_MASK) &gt;&gt; ARM_TBFLAG_SS_ACTIVE_SHIFT)<BR>#define ARM_TBFLAG_PSTATE_SS(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_PSTATE_SS_MASK) &gt;&gt; ARM_TBFLAG_PSTATE_SS_SHIFT)<BR>#define ARM_TBFLAG_FPEXC_EL(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_FPEXC_EL_MASK) &gt;&gt; ARM_TBFLAG_FPEXC_EL_SHIFT)<BR>#define ARM_TBFLAG_THUMB(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_THUMB_MASK) &gt;&gt; ARM_TBFLAG_THUMB_SHIFT)<BR>#define ARM_TBFLAG_VECLEN(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_VECLEN_MASK) &gt;&gt; ARM_TBFLAG_VECLEN_SHIFT)<BR>#define ARM_TBFLAG_VECSTRIDE(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_VECSTRIDE_MASK) &gt;&gt; ARM_TBFLAG_VECSTRIDE_SHIFT)<BR>#define ARM_TBFLAG_VFPEN(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_VFPEN_MASK) &gt;&gt; ARM_TBFLAG_VFPEN_SHIFT)<BR>#define ARM_TBFLAG_CONDEXEC(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_CONDEXEC_MASK) &gt;&gt; ARM_TBFLAG_CONDEXEC_SHIFT)<BR>#define ARM_TBFLAG_SCTLR_B(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_SCTLR_B_MASK) &gt;&gt; ARM_TBFLAG_SCTLR_B_SHIFT)<BR>#define ARM_TBFLAG_XSCALE_CPAR(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_XSCALE_CPAR_MASK) &gt;&gt; ARM_TBFLAG_XSCALE_CPAR_SHIFT)<BR>#define ARM_TBFLAG_NS(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_NS_MASK) &gt;&gt; ARM_TBFLAG_NS_SHIFT)<BR>#define ARM_TBFLAG_BE_DATA(F) \<BR>&nbsp;&nbsp;&nbsp; (((F) &amp; ARM_TBFLAG_BE_DATA_MASK) &gt;&gt; ARM_TBFLAG_BE_DATA_SHIFT)</P>
<P><FONT class=extract>static inline bool bswap_code(bool sctlr_b)<BR>{<BR>#ifdef CONFIG_USER_ONLY<BR>&nbsp;&nbsp;&nbsp; /* BE8 (SCTLR.B = 0, TARGET_WORDS_BIGENDIAN = 1) is mixed endian.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * The invalid combination SCTLR.B=1/CPSR.E=1/TARGET_WORDS_BIGENDIAN=0<BR>&nbsp;&nbsp;&nbsp;&nbsp; * would also end up as a mixed-endian mode with BE code, LE data.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; return<BR>#ifdef TARGET_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 ^<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sctlr_b;<BR>#else<BR>&nbsp;&nbsp;&nbsp; /* All code access in ARM is little endian, and there are no loaders<BR>&nbsp;&nbsp;&nbsp;&nbsp; * doing swaps that need to be reversed<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>#endif<BR>}</FONT></P>
<P>/* Return the exception level to which FP-disabled exceptions should<BR>&nbsp;* be taken, or 0 if FP is enabled.<BR>&nbsp;*/<BR>static inline int fp_exception_el(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int fpen;<BR>&nbsp;&nbsp;&nbsp; int cur_el = arm_current_el(env);</P>
<P>&nbsp;&nbsp;&nbsp; /* CPACR and the CPTR registers don't exist before v6, so FP is<BR>&nbsp;&nbsp;&nbsp;&nbsp; * always accessible<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_V6)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* The CPACR controls traps to EL1, or PL1 if we're 32 bit:<BR>&nbsp;&nbsp;&nbsp;&nbsp; * 0, 2 : trap EL0 and EL1/PL1 accesses<BR>&nbsp;&nbsp;&nbsp;&nbsp; * 1&nbsp;&nbsp;&nbsp; : trap only EL0 accesses<BR>&nbsp;&nbsp;&nbsp;&nbsp; * 3&nbsp;&nbsp;&nbsp; : trap no accesses<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; fpen = extract32(env-&gt;cp15.cpacr_el1, 20, 2);<BR>&nbsp;&nbsp;&nbsp; switch (fpen) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cur_el == 0 || cur_el == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Trap to PL1, which might be EL1 or EL3 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_is_secure(env) &amp;&amp; !arm_el_is_aa64(env, 3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cur_el == 3 &amp;&amp; !is_a64(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Secure PL1 running at EL3 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cur_el == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* For the CPTR registers we don't need to guard with an ARM_FEATURE<BR>&nbsp;&nbsp;&nbsp;&nbsp; * check because zero bits in the registers mean "don't trap".<BR>&nbsp;&nbsp;&nbsp;&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp; /* CPTR_EL2 : present in v7VE or v8 */<BR>&nbsp;&nbsp;&nbsp; if (cur_el &lt;= 2 &amp;&amp; extract32(env-&gt;cp15.cptr_el[2], 10, 1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Trap FP ops at EL2, NS-EL1 or NS-EL0 to EL2 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* CPTR_EL3 : present in v8 */<BR>&nbsp;&nbsp;&nbsp; if (extract32(env-&gt;cp15.cptr_el[3], 10, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Trap all FP ops to EL3 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>#ifdef CONFIG_USER_ONLY<BR>static inline bool arm_cpu_bswap_data(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return<BR>#ifdef TARGET_WORDS_BIGENDIAN<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 ^<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_cpu_data_is_big_endian(env);<BR>}<BR>#endif</P>
<P>static inline void cpu_get_tb_cpu_state(CPUARMState *env, target_ulong *pc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong *cs_base, uint32_t *flags)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (is_a64(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pc = env-&gt;pc;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *flags = ARM_TBFLAG_AARCH64_STATE_MASK;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pc = env-&gt;regs[15];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *flags = (env-&gt;thumb &lt;&lt; ARM_TBFLAG_THUMB_SHIFT)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (env-&gt;vfp.vec_len &lt;&lt; ARM_TBFLAG_VECLEN_SHIFT)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (env-&gt;vfp.vec_stride &lt;&lt; ARM_TBFLAG_VECSTRIDE_SHIFT)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (env-&gt;condexec_bits &lt;&lt; ARM_TBFLAG_CONDEXEC_SHIFT)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (arm_sctlr_b(env) &lt;&lt; ARM_TBFLAG_SCTLR_B_SHIFT);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(access_secure_reg(env))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *flags |= ARM_TBFLAG_NS_MASK;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;vfp.xregs[ARM_VFP_FPEXC] &amp; (1 &lt;&lt; 30)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || arm_el_is_aa64(env, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *flags |= ARM_TBFLAG_VFPEN_MASK;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *flags |= (extract32(env-&gt;cp15.c15_cpar, 0, 2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; ARM_TBFLAG_XSCALE_CPAR_SHIFT);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; *flags |= (cpu_mmu_index(env, false) &lt;&lt; ARM_TBFLAG_MMUIDX_SHIFT);<BR>&nbsp;&nbsp;&nbsp; /* The SS_ACTIVE and PSTATE_SS bits correspond to the state machine<BR>&nbsp;&nbsp;&nbsp;&nbsp; * states defined in the ARM ARM for software singlestep:<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; SS_ACTIVE&nbsp;&nbsp; PSTATE.SS&nbsp;&nbsp; State<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Inactive (the TB flag for SS is always 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Active-pending<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Active-not-pending<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arm_singlestep_active(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *flags |= ARM_TBFLAG_SS_ACTIVE_MASK;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_a64(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;pstate &amp; PSTATE_SS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *flags |= ARM_TBFLAG_PSTATE_SS_MASK;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;uncached_cpsr &amp; PSTATE_SS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *flags |= ARM_TBFLAG_PSTATE_SS_MASK;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_cpu_data_is_big_endian(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *flags |= ARM_TBFLAG_BE_DATA_MASK;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; *flags |= fp_exception_el(env) &lt;&lt; ARM_TBFLAG_FPEXC_EL_SHIFT;</P>
<P>&nbsp;&nbsp;&nbsp; *cs_base = 0;<BR>}</P>
<P>enum {<BR>&nbsp;&nbsp;&nbsp; QEMU_PSCI_CONDUIT_DISABLED = 0,<BR>&nbsp;&nbsp;&nbsp; QEMU_PSCI_CONDUIT_SMC = 1,<BR>&nbsp;&nbsp;&nbsp; QEMU_PSCI_CONDUIT_HVC = 2,<BR>};</P>
<P>#ifndef CONFIG_USER_ONLY<BR>/* Return the address space index to use for a memory access */<BR>static inline int arm_asidx_from_attrs(CPUState *cs, MemTxAttrs attrs)<BR>{<BR>&nbsp;&nbsp;&nbsp; return attrs.secure ? ARMASIdx_S : ARMASIdx_NS;<BR>}</P>
<P>/* Return the AddressSpace to use for a memory access<BR>&nbsp;* (which depends on whether the access is S or NS, and whether<BR>&nbsp;* the board gave us a separate AddressSpace for S accesses).<BR>&nbsp;*/<BR>static inline AddressSpace *arm_addressspace(CPUState *cs, MemTxAttrs attrs)<BR>{<BR>&nbsp;&nbsp;&nbsp; return cpu_get_address_space(cs, arm_asidx_from_attrs(cs, attrs));<BR>}<BR>#endif</P>
<P>/**<BR>&nbsp;* arm_register_el_change_hook:<BR>&nbsp;* Register a hook function which will be called back whenever this<BR>&nbsp;* CPU changes exception level or mode. The hook function will be<BR>&nbsp;* passed a pointer to the ARMCPU and the opaque data pointer passed<BR>&nbsp;* to this function when the hook was registered.<BR>&nbsp;*<BR>&nbsp;* Note that we currently only support registering a single hook function,<BR>&nbsp;* and will assert if this function is called twice.<BR>&nbsp;* This facility is intended for the use of the GICv3 emulation.<BR>&nbsp;*/<BR>void arm_register_el_change_hook(ARMCPU *cpu, ARMELChangeHook *hook,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *opaque);</P>
<P>/**<BR>&nbsp;* arm_get_el_change_hook_opaque:<BR>&nbsp;* Return the opaque data that will be used by the el_change_hook<BR>&nbsp;* for this CPU.<BR>&nbsp;*/<BR>static inline void *arm_get_el_change_hook_opaque(ARMCPU *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; return cpu-&gt;el_change_hook_opaque;<BR>}</P>
<P>#endif