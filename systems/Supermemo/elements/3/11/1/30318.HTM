# target-arm/op_helper.c 
<P></P>
<P>/*<BR>&nbsp;*&nbsp; ARM helper routines<BR>&nbsp;*<BR>&nbsp;*&nbsp; Copyright (c) 2005-2007 CodeSourcery, LLC<BR>&nbsp;*<BR>&nbsp;* This library is free software; you can redistribute it and/or<BR>&nbsp;* modify it under the terms of the GNU Lesser General Public<BR>&nbsp;* License as published by the Free Software Foundation; either<BR>&nbsp;* version 2 of the License, or (at your option) any later version.<BR>&nbsp;*<BR>&nbsp;* This library is distributed in the hope that it will be useful,<BR>&nbsp;* but WITHOUT ANY WARRANTY; without even the implied warranty of<BR>&nbsp;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp; See the GNU<BR>&nbsp;* Lesser General Public License for more details.<BR>&nbsp;*<BR>&nbsp;* You should have received a copy of the GNU Lesser General Public<BR>&nbsp;* License along with this library; if not, see &lt;<A href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.<BR>&nbsp;*/<BR>#include "qemu/osdep.h"<BR>#include "cpu.h"<BR>#include "exec/helper-proto.h"<BR>#include "internals.h"<BR>#include "exec/exec-all.h"<BR>#include "exec/cpu_ldst.h"</P>
<P></P>
<P><FONT class=extract>#define SIGNBIT (uint32_t)0x80000000<BR>#define SIGNBIT64 ((uint64_t)1 &lt;&lt; 63)</FONT></P>
<P><FONT class=extract>static void raise_exception(CPUARMState *env, uint32_t excp,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t syndrome, uint32_t target_el)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(arm_env_get_cpu(env));</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; assert(!excp_is_internal(excp));<BR>&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = excp;<BR>&nbsp;&nbsp;&nbsp; env-&gt;exception.syndrome = syndrome;<BR>&nbsp;&nbsp;&nbsp; env-&gt;exception.target_el = target_el;<BR>&nbsp;&nbsp;&nbsp; cpu_loop_exit(cs);<BR>}</FONT></P>
<P><FONT class=extract>static int exception_target_el(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int target_el = MAX(1, arm_current_el(env));</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* No such thing as secure EL1 if EL3 is aarch32, so update the target EL<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to EL3 in this case.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arm_is_secure(env) &amp;&amp; !arm_el_is_aa64(env, 3) &amp;&amp; target_el == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 3;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return target_el;<BR>}</FONT></P>
<P>uint32_t HELPER(neon_tbl)(CPUARMState *env, uint32_t ireg, uint32_t def,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t rn, uint32_t maxindex)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t val;<BR>&nbsp;&nbsp;&nbsp; uint32_t tmp;<BR>&nbsp;&nbsp;&nbsp; int index;<BR>&nbsp;&nbsp;&nbsp; int shift;<BR>&nbsp;&nbsp;&nbsp; uint64_t *table;<BR>&nbsp;&nbsp;&nbsp; table = (uint64_t *)&amp;env-&gt;vfp.regs[rn];<BR>&nbsp;&nbsp;&nbsp; val = 0;<BR>&nbsp;&nbsp;&nbsp; for (shift = 0; shift &lt; 32; shift += 8) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = (ireg &gt;&gt; shift) &amp; 0xff;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (index &lt; maxindex) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = (table[index &gt;&gt; 3] &gt;&gt; ((index &amp; 7) &lt;&lt; 3)) &amp; 0xff;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val |= tmp &lt;&lt; shift;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val |= def &amp; (0xff &lt;&lt; shift);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return val;<BR>}</P>
<P>#if !defined(CONFIG_USER_ONLY)</P>
<P>static inline uint32_t merge_syn_data_abort(uint32_t template_syn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int target_el,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool same_el,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool s1ptw, bool is_write,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int fsc)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t syn;</P>
<P>&nbsp;&nbsp;&nbsp; /* ISV is only set for data aborts routed to EL2 and<BR>&nbsp;&nbsp;&nbsp;&nbsp; * never for stage-1 page table walks faulting on stage 2.<BR>&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Furthermore, ISV is only set for certain kinds of load/stores.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * If the template syndrome does not have ISV set, we should leave<BR>&nbsp;&nbsp;&nbsp;&nbsp; * it cleared.<BR>&nbsp;&nbsp;&nbsp;&nbsp; *<BR>&nbsp;&nbsp;&nbsp;&nbsp; * See ARMv8 specs, D7-1974:<BR>&nbsp;&nbsp;&nbsp;&nbsp; * ISS encoding for an exception from a Data Abort, the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * ISV field.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!(template_syn &amp; ARM_EL_ISV) || target_el != 2 || s1ptw) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syn = syn_data_abort_no_iss(same_el,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, s1ptw, is_write, fsc);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Fields: IL, ISV, SAS, SSE, SRT, SF and AR come from the template<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * syndrome created at translation time.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Now we create the runtime syndrome with the remaining fields.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syn = syn_data_abort_with_iss(same_el,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 0, 0, 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, s1ptw, is_write, fsc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Merge the runtime syndrome with the template syndrome.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syn |= template_syn;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return syn;<BR>}</P>
<P><FONT class=extract>/* try to fill the TLB and return an exception if error. If retaddr is<BR>&nbsp;* NULL, it means that the function was called in C code (i.e. not<BR>&nbsp;* from generated code or from helper.c)<BR>&nbsp;*/<BR>void tlb_fill(CPUState *cs, target_ulong addr, MMUAccessType access_type,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mmu_idx, uintptr_t retaddr)<BR>{<BR>&nbsp;&nbsp;&nbsp; bool ret;<BR>&nbsp;&nbsp;&nbsp; uint32_t fsr = 0;<BR>&nbsp;&nbsp;&nbsp; ARMMMUFaultInfo fi = {};</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; ret = arm_tlb_fill(cs, addr, access_type, mmu_idx, &amp;fsr, &amp;fi);<BR>&nbsp;&nbsp;&nbsp; if (unlikely(ret)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t syn, exc;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int target_el;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool same_el;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (retaddr) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* now we have a real cpu fault */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_restore_state(cs, retaddr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = exception_target_el(env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fi.stage2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.hpfar_el2 = extract64(fi.s2addr, 12, 47) &lt;&lt; 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; same_el = arm_current_el(env) == target_el;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* AArch64 syndrome does not have an LPAE bit */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syn = fsr &amp; ~(1 &lt;&lt; 9);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* For insn and data aborts we assume there is no instruction syndrome<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * information; this is always true for exceptions reported to EL1.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (access_type == MMU_INST_FETCH) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syn = syn_insn_abort(same_el, 0, fi.s1ptw, syn);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exc = EXCP_PREFETCH_ABORT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syn = merge_syn_data_abort(env-&gt;exception.syndrome, target_el,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; same_el, fi.s1ptw,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_type == MMU_DATA_STORE, syn);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (access_type == MMU_DATA_STORE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; arm_feature(env, ARM_FEATURE_V6)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsr |= (1 &lt;&lt; 11);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exc = EXCP_DATA_ABORT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.vaddress = addr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.fsr = fsr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise_exception(env, exc, syn, target_el);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</FONT></P>
<P><FONT class=extract>/* Raise a data fault alignment exception for the specified virtual address */<BR>void arm_cpu_do_unaligned_access(CPUState *cs, vaddr vaddr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MMUAccessType access_type,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mmu_idx, uintptr_t retaddr)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; int target_el;<BR>&nbsp;&nbsp;&nbsp; bool same_el;<BR>&nbsp;&nbsp;&nbsp; uint32_t syn;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (retaddr) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* now we have a real cpu fault */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_restore_state(cs, retaddr);<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; target_el = exception_target_el(env);<BR>&nbsp;&nbsp;&nbsp; same_el = (arm_current_el(env) == target_el);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; env-&gt;exception.vaddress = vaddr;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* the DFSR for an alignment fault depends on whether we're using<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the LPAE long descriptor format, or the short descriptor format<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arm_s1_regime_using_lpae_format(env, cpu_mmu_index(env, false))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.fsr = (1 &lt;&lt; 9) | 0x21;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.fsr = 0x1;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (access_type == MMU_DATA_STORE &amp;&amp; arm_feature(env, ARM_FEATURE_V6)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.fsr |= (1 &lt;&lt; 11);<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; syn = merge_syn_data_abort(env-&gt;exception.syndrome, target_el,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; same_el, 0, access_type == MMU_DATA_STORE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x21);<BR>&nbsp;&nbsp;&nbsp; raise_exception(env, EXCP_DATA_ABORT, syn, target_el);<BR>}</FONT></P>
<P>#endif /* !defined(CONFIG_USER_ONLY) */</P>
<P><FONT class=extract>uint32_t HELPER(add_setq)(CPUARMState *env, uint32_t a, uint32_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t res = a + b;<BR>&nbsp;&nbsp;&nbsp; if (((res ^ a) &amp; SIGNBIT) &amp;&amp; !((a ^ b) &amp; SIGNBIT))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;QF = 1;<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</FONT></P>
<P><FONT class=extract>uint32_t HELPER(add_saturate)(CPUARMState *env, uint32_t a, uint32_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t res = a + b;<BR>&nbsp;&nbsp;&nbsp; if (((res ^ a) &amp; SIGNBIT) &amp;&amp; !((a ^ b) &amp; SIGNBIT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;QF = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = ~(((int32_t)a &gt;&gt; 31) ^ SIGNBIT);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</FONT></P>
<P><FONT class=extract>uint32_t HELPER(sub_saturate)(CPUARMState *env, uint32_t a, uint32_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t res = a - b;<BR>&nbsp;&nbsp;&nbsp; if (((res ^ a) &amp; SIGNBIT) &amp;&amp; ((a ^ b) &amp; SIGNBIT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;QF = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = ~(((int32_t)a &gt;&gt; 31) ^ SIGNBIT);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</FONT></P>
<P><FONT class=extract>uint32_t HELPER(double_saturate)(CPUARMState *env, int32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t res;<BR>&nbsp;&nbsp;&nbsp; if (val &gt;= 0x40000000) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = ~SIGNBIT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;QF = 1;<BR>&nbsp;&nbsp;&nbsp; } else if (val &lt;= (int32_t)0xc0000000) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = SIGNBIT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;QF = 1;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = val &lt;&lt; 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</FONT></P>
<P><FONT class=extract>uint32_t HELPER(add_usaturate)(CPUARMState *env, uint32_t a, uint32_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t res = a + b;<BR>&nbsp;&nbsp;&nbsp; if (res &lt; a) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;QF = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = ~0;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</FONT></P>
<P><FONT class=extract>uint32_t HELPER(sub_usaturate)(CPUARMState *env, uint32_t a, uint32_t b)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t res = a - b;<BR>&nbsp;&nbsp;&nbsp; if (res &gt; a) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;QF = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res = 0;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</FONT></P>
<P><FONT class=extract>/* Signed saturation.&nbsp; */<BR>static inline uint32_t do_ssat(CPUARMState *env, int32_t val, int shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; int32_t top;<BR>&nbsp;&nbsp;&nbsp; uint32_t mask;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; top = val &gt;&gt; shift;<BR>&nbsp;&nbsp;&nbsp; mask = (1u &lt;&lt; shift) - 1;<BR>&nbsp;&nbsp;&nbsp; if (top &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;QF = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return mask;<BR>&nbsp;&nbsp;&nbsp; } else if (top &lt; -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;QF = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ~mask;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return val;<BR>}</FONT></P>
<P><FONT class=extract>/* Unsigned saturation.&nbsp; */<BR>static inline uint32_t do_usat(CPUARMState *env, int32_t val, int shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t max;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; max = (1u &lt;&lt; shift) - 1;<BR>&nbsp;&nbsp;&nbsp; if (val &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;QF = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; } else if (val &gt; max) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;QF = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return max;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return val;<BR>}</FONT></P>
<P><FONT class=extract>/* Signed saturate.&nbsp; */<BR>uint32_t HELPER(ssat)(CPUARMState *env, uint32_t x, uint32_t shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; return do_ssat(env, x, shift);<BR>}</FONT></P>
<P><FONT class=extract>/* Dual halfword signed saturate.&nbsp; */<BR>uint32_t HELPER(ssat16)(CPUARMState *env, uint32_t x, uint32_t shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t res;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; res = (uint16_t)do_ssat(env, (int16_t)x, shift);<BR>&nbsp;&nbsp;&nbsp; res |= do_ssat(env, ((int32_t)x) &gt;&gt; 16, shift) &lt;&lt; 16;<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</FONT></P>
<P><FONT class=extract>/* Unsigned saturate.&nbsp; */<BR>uint32_t HELPER(usat)(CPUARMState *env, uint32_t x, uint32_t shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; return do_usat(env, x, shift);<BR>}</FONT></P>
<P><FONT class=extract>/* Dual halfword unsigned saturate.&nbsp; */<BR>uint32_t HELPER(usat16)(CPUARMState *env, uint32_t x, uint32_t shift)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t res;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; res = (uint16_t)do_usat(env, (int16_t)x, shift);<BR>&nbsp;&nbsp;&nbsp; res |= do_usat(env, ((int32_t)x) &gt;&gt; 16, shift) &lt;&lt; 16;<BR>&nbsp;&nbsp;&nbsp; return res;<BR>}</FONT></P>
<P><FONT class=extract>void HELPER(setend)(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;uncached_cpsr ^= CPSR_E;<BR>}</FONT></P>
<P><FONT class=extract>/* Function checks whether WFx (WFI/WFE) instructions are set up to be trapped.<BR>&nbsp;* The function returns the target EL (1-3) if the instruction is to be trapped;<BR>&nbsp;* otherwise it returns 0 indicating it is not trapped.<BR>&nbsp;*/<BR>static inline int check_wfx_trap(CPUARMState *env, bool is_wfe)<BR>{<BR>&nbsp;&nbsp;&nbsp; int cur_el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; uint64_t mask;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* If we are currently in EL0 then we need to check if SCTLR is set up for<BR>&nbsp;&nbsp;&nbsp;&nbsp; * WFx instructions being trapped to EL1. These trap bits don't exist in v7.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (cur_el &lt; 1 &amp;&amp; arm_feature(env, ARM_FEATURE_V8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int target_el;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = is_wfe ? SCTLR_nTWE : SCTLR_nTWI;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_is_secure_below_el3(env) &amp;&amp; !arm_el_is_aa64(env, 3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Secure EL0 and Secure PL1 is at EL3 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(env-&gt;cp15.sctlr_el[target_el] &amp; mask)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return target_el;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* We are not trapping to EL1; trap to EL2 if HCR_EL2 requires it<BR>&nbsp;&nbsp;&nbsp;&nbsp; * No need for ARM_FEATURE check as if HCR_EL2 doesn't exist the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * bits will be zero indicating no trap.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (cur_el &lt; 2 &amp;&amp; !arm_is_secure(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = (is_wfe) ? HCR_TWE : HCR_TWI;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;cp15.hcr_el2 &amp; mask) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* We are not trapping to EL1 or EL2; trap to EL3 if SCR_EL3 requires it */<BR>&nbsp;&nbsp;&nbsp; if (cur_el &lt; 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mask = (is_wfe) ? SCR_TWE : SCR_TWI;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (env-&gt;cp15.scr_el3 &amp; mask) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return 0;<BR>}</FONT></P>
<P><FONT class=extract>void HELPER(wfi)(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(arm_env_get_cpu(env));<BR>&nbsp;&nbsp;&nbsp; int target_el = check_wfx_trap(env, false);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (cpu_has_work(cs)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Don't bother to go into our "low power state" if<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * we would just wake up immediately.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (target_el) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pc -= 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise_exception(env, EXCP_UDEF, syn_wfx(1, 0xe, 0), target_el);<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = EXCP_HLT;<BR>&nbsp;&nbsp;&nbsp; cs-&gt;halted = 1;<BR>&nbsp;&nbsp;&nbsp; cpu_loop_exit(cs);<BR>}</FONT></P>
<P><FONT class=extract>void HELPER(wfe)(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* This is a hint instruction that is semantically different<BR>&nbsp;&nbsp;&nbsp;&nbsp; * from YIELD even though we currently implement it identically.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Don't actually halt the CPU, just yield back to top<BR>&nbsp;&nbsp;&nbsp;&nbsp; * level loop. This is not going into a "low power state"<BR>&nbsp;&nbsp;&nbsp;&nbsp; * (ie halting until some event occurs), so we never take<BR>&nbsp;&nbsp;&nbsp;&nbsp; * a configurable trap to a different exception level.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; HELPER(yield)(env);<BR>}</FONT></P>
<P><FONT class=extract>void HELPER(yield)(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(cpu);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; /* This is a non-trappable hint instruction that generally indicates<BR>&nbsp;&nbsp;&nbsp;&nbsp; * that the guest is currently busy-looping. Yield control back to the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * top level loop so that a more deserving VCPU has a chance to run.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = EXCP_YIELD;<BR>&nbsp;&nbsp;&nbsp; cpu_loop_exit(cs);<BR>}</FONT></P>
<P><FONT class=extract>/* Raise an internal-to-QEMU exception. This is limited to only<BR>&nbsp;* those EXCP values which are special cases for QEMU to interrupt<BR>&nbsp;* execution and not to be used for exceptions which are passed to<BR>&nbsp;* the guest (those must all have syndrome information and thus should<BR>&nbsp;* use exception_with_syndrome).<BR>&nbsp;*/<BR>void HELPER(exception_internal)(CPUARMState *env, uint32_t excp)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUState *cs = CPU(arm_env_get_cpu(env));</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; assert(excp_is_internal(excp));<BR>&nbsp;&nbsp;&nbsp; cs-&gt;exception_index = excp;<BR>&nbsp;&nbsp;&nbsp; cpu_loop_exit(cs);<BR>}</FONT></P>
<P><FONT class=extract>/* Raise an exception with the specified syndrome register value */<BR>void HELPER(exception_with_syndrome)(CPUARMState *env, uint32_t excp,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t syndrome, uint32_t target_el)<BR>{<BR>&nbsp;&nbsp;&nbsp; raise_exception(env, excp, syndrome, target_el);<BR>}</FONT></P>
<P>uint32_t HELPER(cpsr_read)(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return cpsr_read(env) &amp; ~(CPSR_EXEC | CPSR_RESERVED);<BR>}</P>
<P>void HELPER(cpsr_write)(CPUARMState *env, uint32_t val, uint32_t mask)<BR>{<BR>&nbsp;&nbsp;&nbsp; cpsr_write(env, val, mask, CPSRWriteByInstr);<BR>}</P>
<P>/* Write the CPSR for a 32-bit exception return */<BR>void HELPER(cpsr_write_eret)(CPUARMState *env, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; cpsr_write(env, val, CPSR_ERET_MASK, CPSRWriteExceptionReturn);</P>
<P>&nbsp;&nbsp;&nbsp; arm_call_el_change_hook(arm_env_get_cpu(env));<BR>}</P>
<P>/* Access to user mode registers from privileged modes.&nbsp; */<BR>uint32_t HELPER(get_user_reg)(CPUARMState *env, uint32_t regno)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint32_t val;</P>
<P>&nbsp;&nbsp;&nbsp; if (regno == 13) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = env-&gt;banked_r13[BANK_USRSYS];<BR>&nbsp;&nbsp;&nbsp; } else if (regno == 14) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = env-&gt;banked_r14[BANK_USRSYS];<BR>&nbsp;&nbsp;&nbsp; } else if (regno &gt;= 8<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (env-&gt;uncached_cpsr &amp; 0x1f) == ARM_CPU_MODE_FIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = env-&gt;usr_regs[regno - 8];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = env-&gt;regs[regno];<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return val;<BR>}</P>
<P>void HELPER(set_user_reg)(CPUARMState *env, uint32_t regno, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (regno == 13) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r13[BANK_USRSYS] = val;<BR>&nbsp;&nbsp;&nbsp; } else if (regno == 14) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r14[BANK_USRSYS] = val;<BR>&nbsp;&nbsp;&nbsp; } else if (regno &gt;= 8<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (env-&gt;uncached_cpsr &amp; 0x1f) == ARM_CPU_MODE_FIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;usr_regs[regno - 8] = val;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[regno] = val;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void HELPER(set_r13_banked)(CPUARMState *env, uint32_t mode, uint32_t val)<BR>{<BR>&nbsp;&nbsp;&nbsp; if ((env-&gt;uncached_cpsr &amp; CPSR_M) == mode) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[13] = val;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r13[bank_number(mode)] = val;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>uint32_t HELPER(get_r13_banked)(CPUARMState *env, uint32_t mode)<BR>{<BR>&nbsp;&nbsp;&nbsp; if ((env-&gt;uncached_cpsr &amp; CPSR_M) == ARM_CPU_MODE_SYS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* SRS instruction is UNPREDICTABLE from System mode; we UNDEF.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Other UNPREDICTABLE and UNDEF cases were caught at translate time.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise_exception(env, EXCP_UDEF, syn_uncategorized(),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exception_target_el(env));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if ((env-&gt;uncached_cpsr &amp; CPSR_M) == mode) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;regs[13];<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;banked_r13[bank_number(mode)];<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void msr_mrs_banked_exc_checks(CPUARMState *env, uint32_t tgtmode,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t regno)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Raise an exception if the requested access is one of the UNPREDICTABLE<BR>&nbsp;&nbsp;&nbsp;&nbsp; * cases; otherwise return. This broadly corresponds to the pseudocode<BR>&nbsp;&nbsp;&nbsp;&nbsp; * BankedRegisterAccessValid() and SPSRAccessValid(),<BR>&nbsp;&nbsp;&nbsp;&nbsp; * except that we have already handled some cases at translate time.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int curmode = env-&gt;uncached_cpsr &amp; CPSR_M;</P>
<P>&nbsp;&nbsp;&nbsp; if (curmode == tgtmode) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto undef;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (tgtmode == ARM_CPU_MODE_USR) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (regno) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 8 ... 12:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (curmode != ARM_CPU_MODE_FIQ) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto undef;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 13:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (curmode == ARM_CPU_MODE_SYS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto undef;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 14:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (curmode == ARM_CPU_MODE_HYP || curmode == ARM_CPU_MODE_SYS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto undef;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (tgtmode == ARM_CPU_MODE_HYP) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (regno) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 17: /* ELR_Hyp */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (curmode != ARM_CPU_MODE_HYP &amp;&amp; curmode != ARM_CPU_MODE_MON) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto undef;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (curmode != ARM_CPU_MODE_MON) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto undef;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return;</P>
<P>undef:<BR>&nbsp;&nbsp;&nbsp; raise_exception(env, EXCP_UDEF, syn_uncategorized(),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exception_target_el(env));<BR>}</P>
<P>void HELPER(msr_banked)(CPUARMState *env, uint32_t value, uint32_t tgtmode,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t regno)<BR>{<BR>&nbsp;&nbsp;&nbsp; msr_mrs_banked_exc_checks(env, tgtmode, regno);</P>
<P>&nbsp;&nbsp;&nbsp; switch (regno) {<BR>&nbsp;&nbsp;&nbsp; case 16: /* SPSRs */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_spsr[bank_number(tgtmode)] = value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 17: /* ELR_Hyp */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;elr_el[2] = value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 13:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r13[bank_number(tgtmode)] = value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 14:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;banked_r14[bank_number(tgtmode)] = value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 8 ... 12:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (tgtmode) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_USR:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;usr_regs[regno - 8] = value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_FIQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;fiq_regs[regno - 8] = value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>uint32_t HELPER(mrs_banked)(CPUARMState *env, uint32_t tgtmode, uint32_t regno)<BR>{<BR>&nbsp;&nbsp;&nbsp; msr_mrs_banked_exc_checks(env, tgtmode, regno);</P>
<P>&nbsp;&nbsp;&nbsp; switch (regno) {<BR>&nbsp;&nbsp;&nbsp; case 16: /* SPSRs */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;banked_spsr[bank_number(tgtmode)];<BR>&nbsp;&nbsp;&nbsp; case 17: /* ELR_Hyp */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;elr_el[2];<BR>&nbsp;&nbsp;&nbsp; case 13:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;banked_r13[bank_number(tgtmode)];<BR>&nbsp;&nbsp;&nbsp; case 14:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;banked_r14[bank_number(tgtmode)];<BR>&nbsp;&nbsp;&nbsp; case 8 ... 12:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (tgtmode) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_USR:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;usr_regs[regno - 8];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_FIQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return env-&gt;fiq_regs[regno - 8];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t isread)<BR>{<BR>&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri = rip;<BR>&nbsp;&nbsp;&nbsp; int target_el;</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_XSCALE) &amp;&amp; ri-&gt;cp &lt; 14<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; extract32(env-&gt;cp15.c15_cpar, ri-&gt;cp, 1) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise_exception(env, EXCP_UDEF, syndrome, exception_target_el(env));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (!ri-&gt;accessfn) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch (ri-&gt;accessfn(env, ri, isread)) {<BR>&nbsp;&nbsp;&nbsp; case CP_ACCESS_OK:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; case CP_ACCESS_TRAP:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = exception_target_el(env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case CP_ACCESS_TRAP_EL2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Requesting a trap to EL2 when we're in EL3 or S-EL0/1 is<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * a bug in the access function.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(!arm_is_secure(env) &amp;&amp; arm_current_el(env) != 3);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case CP_ACCESS_TRAP_EL3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case CP_ACCESS_TRAP_UNCATEGORIZED:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = exception_target_el(env);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syndrome = syn_uncategorized();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case CP_ACCESS_TRAP_UNCATEGORIZED_EL2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syndrome = syn_uncategorized();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case CP_ACCESS_TRAP_UNCATEGORIZED_EL3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syndrome = syn_uncategorized();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case CP_ACCESS_TRAP_FP_EL2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Since we are an implementation that takes exceptions on a trapped<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * conditional insn only if the insn has passed its condition code<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * check, we take the IMPDEF choice to always report CV=1 COND=0xe<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * (which is also the required value for AArch64 traps).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syndrome = syn_fp_access_trap(1, 0xe, false);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case CP_ACCESS_TRAP_FP_EL3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_el = 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syndrome = syn_fp_access_trap(1, 0xe, false);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; raise_exception(env, EXCP_UDEF, syndrome, target_el);<BR>}</P>
<P>void HELPER(set_cp_reg)(CPUARMState *env, void *rip, uint32_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri = rip;</P>
<P>&nbsp;&nbsp;&nbsp; ri-&gt;writefn(env, ri, value);<BR>}</P>
<P>uint32_t HELPER(get_cp_reg)(CPUARMState *env, void *rip)<BR>{<BR>&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri = rip;</P>
<P>&nbsp;&nbsp;&nbsp; return ri-&gt;readfn(env, ri);<BR>}</P>
<P>void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)<BR>{<BR>&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri = rip;</P>
<P>&nbsp;&nbsp;&nbsp; ri-&gt;writefn(env, ri, value);<BR>}</P>
<P>uint64_t HELPER(get_cp_reg64)(CPUARMState *env, void *rip)<BR>{<BR>&nbsp;&nbsp;&nbsp; const ARMCPRegInfo *ri = rip;</P>
<P>&nbsp;&nbsp;&nbsp; return ri-&gt;readfn(env, ri);<BR>}</P>
<P>void HELPER(msr_i_pstate)(CPUARMState *env, uint32_t op, uint32_t imm)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* MSR_i to update PSTATE. This is OK from EL0 only if UMA is set.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Note that SPSel is never OK from EL0; we rely on handle_msr_i()<BR>&nbsp;&nbsp;&nbsp;&nbsp; * to catch that case at translate time.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == 0 &amp;&amp; !(env-&gt;cp15.sctlr_el[1] &amp; SCTLR_UMA)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t syndrome = syn_aa64_sysregtrap(0, extract32(op, 0, 3),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extract32(op, 3, 3), 4,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imm, 0x1f, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise_exception(env, EXCP_UDEF, syndrome, exception_target_el(env));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch (op) {<BR>&nbsp;&nbsp;&nbsp; case 0x05: /* SPSel */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update_spsel(env, imm);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 0x1e: /* DAIFSet */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;daif |= (imm &lt;&lt; 6) &amp; PSTATE_DAIF;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 0x1f: /* DAIFClear */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;daif &amp;= ~((imm &lt;&lt; 6) &amp; PSTATE_DAIF);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void HELPER(clear_pstate_ss)(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; env-&gt;pstate &amp;= ~PSTATE_SS;<BR>}</P>
<P>void HELPER(pre_hvc)(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; int cur_el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; /* FIXME: Use actual secure state.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; bool secure = false;<BR>&nbsp;&nbsp;&nbsp; bool undef;</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_is_psci_call(cpu, EXCP_HVC)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If PSCI is enabled and this looks like a valid PSCI call then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * that overrides the architecturally mandated HVC behaviour.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_EL2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If EL2 doesn't exist, HVC always UNDEFs */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; undef = true;<BR>&nbsp;&nbsp;&nbsp; } else if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* EL3.HCE has priority over EL2.HCD. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; undef = !(env-&gt;cp15.scr_el3 &amp; SCR_HCE);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; undef = env-&gt;cp15.hcr_el2 &amp; HCR_HCD;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* In ARMv7 and ARMv8/AArch32, HVC is undef in secure state.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * For ARMv8/AArch64, HVC is allowed in EL3.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Note that we've already trapped HVC from EL0 at translation<BR>&nbsp;&nbsp;&nbsp;&nbsp; * time.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (secure &amp;&amp; (!is_a64(env) || cur_el == 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; undef = true;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (undef) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise_exception(env, EXCP_UDEF, syn_uncategorized(),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exception_target_el(env));<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void HELPER(pre_smc)(CPUARMState *env, uint32_t syndrome)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);<BR>&nbsp;&nbsp;&nbsp; int cur_el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; bool secure = arm_is_secure(env);<BR>&nbsp;&nbsp;&nbsp; bool smd = env-&gt;cp15.scr_el3 &amp; SCR_SMD;<BR>&nbsp;&nbsp;&nbsp; /* On ARMv8 with EL3 AArch64, SMD applies to both S and NS state.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * On ARMv8 with EL3 AArch32, or ARMv7 with the Virtualization<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; extensions, SMD only applies to NS state.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * On ARMv7 without the Virtualization extensions, the SMD bit<BR>&nbsp;&nbsp;&nbsp;&nbsp; * doesn't exist, but we forbid the guest to set it to 1 in scr_write(),<BR>&nbsp;&nbsp;&nbsp;&nbsp; * so we need not special case this here.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; bool undef = arm_feature(env, ARM_FEATURE_AARCH64) ? smd : smd &amp;&amp; !secure;</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_is_psci_call(cpu, EXCP_SMC)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If PSCI is enabled and this looks like a valid PSCI call then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * that overrides the architecturally mandated SMC behaviour.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (!arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If we have no EL3 then SMC always UNDEFs */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; undef = true;<BR>&nbsp;&nbsp;&nbsp; } else if (!secure &amp;&amp; cur_el == 1 &amp;&amp; (env-&gt;cp15.hcr_el2 &amp; HCR_TSC)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* In NS EL1, HCR controlled routing to EL2 has priority over SMD. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise_exception(env, EXCP_HYP_TRAP, syndrome, 2);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (undef) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise_exception(env, EXCP_UDEF, syn_uncategorized(),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exception_target_el(env));<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static int el_from_spsr(uint32_t spsr)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Return the exception level that this SPSR is requesting a return to,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * or -1 if it is invalid (an illegal return)<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (spsr &amp; PSTATE_nRW) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (spsr &amp; CPSR_M) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_USR:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_HYP:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_FIQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_IRQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_SVC:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_ABT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_UND:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_SYS:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_MON:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Returning to Mon from AArch64 is never possible,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * so this is an illegal return.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extract32(spsr, 1, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Return with reserved M[1] bit set */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extract32(spsr, 0, 4) == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* return to EL0 with M[0] bit set */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return extract32(spsr, 2, 2);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void HELPER(exception_return)(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int cur_el = arm_current_el(env);<BR>&nbsp;&nbsp;&nbsp; unsigned int spsr_idx = aarch64_banked_spsr_index(cur_el);<BR>&nbsp;&nbsp;&nbsp; uint32_t spsr = env-&gt;banked_spsr[spsr_idx];<BR>&nbsp;&nbsp;&nbsp; int new_el;<BR>&nbsp;&nbsp;&nbsp; bool return_to_aa64 = (spsr &amp; PSTATE_nRW) == 0;</P>
<P>&nbsp;&nbsp;&nbsp; aarch64_save_sp(env, cur_el);</P>
<P>&nbsp;&nbsp;&nbsp; env-&gt;exclusive_addr = -1;</P>
<P>&nbsp;&nbsp;&nbsp; /* We must squash the PSTATE.SS bit to zero unless both of the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * following hold:<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; 1. debug exceptions are currently disabled<BR>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; 2. singlestep will be active in the EL we return to<BR>&nbsp;&nbsp;&nbsp;&nbsp; * We check 1 here and 2 after we've done the pstate/cpsr write() to<BR>&nbsp;&nbsp;&nbsp;&nbsp; * transition to the EL we're going to.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (arm_generate_debug_exceptions(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spsr &amp;= ~PSTATE_SS;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; new_el = el_from_spsr(spsr);<BR>&nbsp;&nbsp;&nbsp; if (new_el == -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto illegal_return;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (new_el &gt; cur_el<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (new_el == 2 &amp;&amp; !arm_feature(env, ARM_FEATURE_EL2))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Disallow return to an EL which is unimplemented or higher<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * than the current one.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto illegal_return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (new_el != 0 &amp;&amp; arm_el_is_aa64(env, new_el) != return_to_aa64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Return to an EL which is configured for a different register width */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto illegal_return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (new_el == 2 &amp;&amp; arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Return to the non-existent secure-EL2 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto illegal_return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (new_el == 1 &amp;&amp; (env-&gt;cp15.hcr_el2 &amp; HCR_TGE)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !arm_is_secure_below_el3(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto illegal_return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (!return_to_aa64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;aarch64 = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We do a raw CPSR write because aarch64_sync_64_to_32()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * will sort the register banks out for us, and we've already<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * caught all the bad-mode cases in el_from_spsr().<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpsr_write(env, spsr, ~0, CPSRWriteRaw);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_singlestep_active(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;uncached_cpsr &amp;= ~PSTATE_SS;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aarch64_sync_64_to_32(env);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (spsr &amp; CPSR_T) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[15] = env-&gt;elr_el[cur_el] &amp; ~0x1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;regs[15] = env-&gt;elr_el[cur_el] &amp; ~0x3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;aarch64 = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstate_write(env, spsr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!arm_singlestep_active(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pstate &amp;= ~PSTATE_SS;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aarch64_restore_sp(env, new_el);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pc = env-&gt;elr_el[cur_el];<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; arm_call_el_change_hook(arm_env_get_cpu(env));</P>
<P>&nbsp;&nbsp;&nbsp; return;</P>
<P>illegal_return:<BR>&nbsp;&nbsp;&nbsp; /* Illegal return events of various kinds have architecturally<BR>&nbsp;&nbsp;&nbsp;&nbsp; * mandated behaviour:<BR>&nbsp;&nbsp;&nbsp;&nbsp; * restore NZCV and DAIF from SPSR_ELx<BR>&nbsp;&nbsp;&nbsp;&nbsp; * set PSTATE.IL<BR>&nbsp;&nbsp;&nbsp;&nbsp; * restore PC from ELR_ELx<BR>&nbsp;&nbsp;&nbsp;&nbsp; * no change to exception level, execution state or stack pointer<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; env-&gt;pstate |= PSTATE_IL;<BR>&nbsp;&nbsp;&nbsp; env-&gt;pc = env-&gt;elr_el[cur_el];<BR>&nbsp;&nbsp;&nbsp; spsr &amp;= PSTATE_NZCV | PSTATE_DAIF;<BR>&nbsp;&nbsp;&nbsp; spsr |= pstate_read(env) &amp; ~(PSTATE_NZCV | PSTATE_DAIF);<BR>&nbsp;&nbsp;&nbsp; pstate_write(env, spsr);<BR>&nbsp;&nbsp;&nbsp; if (!arm_singlestep_active(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;pstate &amp;= ~PSTATE_SS;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Return true if the linked breakpoint entry lbn passes its checks */<BR>static bool linked_bp_matches(ARMCPU *cpu, int lbn)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; uint64_t bcr = env-&gt;cp15.dbgbcr[lbn];<BR>&nbsp;&nbsp;&nbsp; int brps = extract32(cpu-&gt;dbgdidr, 24, 4);<BR>&nbsp;&nbsp;&nbsp; int ctx_cmps = extract32(cpu-&gt;dbgdidr, 20, 4);<BR>&nbsp;&nbsp;&nbsp; int bt;<BR>&nbsp;&nbsp;&nbsp; uint32_t contextidr;</P>
<P>&nbsp;&nbsp;&nbsp; /* Links to unimplemented or non-context aware breakpoints are<BR>&nbsp;&nbsp;&nbsp;&nbsp; * CONSTRAINED UNPREDICTABLE: either behave as if disabled, or<BR>&nbsp;&nbsp;&nbsp;&nbsp; * as if linked to an UNKNOWN context-aware breakpoint (in which<BR>&nbsp;&nbsp;&nbsp;&nbsp; * case DBGWCR&lt;n&gt;_EL1.LBN must indicate that breakpoint).<BR>&nbsp;&nbsp;&nbsp;&nbsp; * We choose the former.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (lbn &gt; brps || lbn &lt; (brps - ctx_cmps)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; bcr = env-&gt;cp15.dbgbcr[lbn];</P>
<P>&nbsp;&nbsp;&nbsp; if (extract64(bcr, 0, 1) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Linked breakpoint disabled : generate no events */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; bt = extract64(bcr, 20, 4);</P>
<P>&nbsp;&nbsp;&nbsp; /* We match the whole register even if this is AArch32 using the<BR>&nbsp;&nbsp;&nbsp;&nbsp; * short descriptor format (in which case it holds both PROCID and ASID),<BR>&nbsp;&nbsp;&nbsp;&nbsp; * since we don't implement the optional v7 context ID masking.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; contextidr = extract64(env-&gt;cp15.contextidr_el[1], 0, 32);</P>
<P>&nbsp;&nbsp;&nbsp; switch (bt) {<BR>&nbsp;&nbsp;&nbsp; case 3: /* linked context ID match */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_current_el(env) &gt; 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Context matches never fire in EL2 or (AArch64) EL3 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (contextidr == extract64(env-&gt;cp15.dbgbvr[lbn], 0, 32));<BR>&nbsp;&nbsp;&nbsp; case 5: /* linked address mismatch (reserved in AArch64) */<BR>&nbsp;&nbsp;&nbsp; case 9: /* linked VMID match (reserved if no EL2) */<BR>&nbsp;&nbsp;&nbsp; case 11: /* linked context ID and VMID match (reserved if no EL2) */<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Links to Unlinked context breakpoints must generate no<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * events; we choose to do the same for reserved values too.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return false;<BR>}</P>
<P>static bool bp_wp_matches(ARMCPU *cpu, int n, bool is_wp)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; uint64_t cr;<BR>&nbsp;&nbsp;&nbsp; int pac, hmc, ssc, wt, lbn;<BR>&nbsp;&nbsp;&nbsp; /* Note that for watchpoints the check is against the CPU security<BR>&nbsp;&nbsp;&nbsp;&nbsp; * state, not the S/NS attribute on the offending data access.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; bool is_secure = arm_is_secure(env);<BR>&nbsp;&nbsp;&nbsp; int access_el = arm_current_el(env);</P>
<P>&nbsp;&nbsp;&nbsp; if (is_wp) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPUWatchpoint *wp = env-&gt;cpu_watchpoint[n];</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!wp || !(wp-&gt;flags &amp; BP_WATCHPOINT_HIT)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cr = env-&gt;cp15.dbgwcr[n];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (wp-&gt;hitattrs.user) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The LDRT/STRT/LDT/STT "unprivileged access" instructions should<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * match watchpoints as if they were accesses done at EL0, even if<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the CPU is at EL1 or higher.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_el = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t pc = is_a64(env) ? env-&gt;pc : env-&gt;regs[15];</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!env-&gt;cpu_breakpoint[n] || env-&gt;cpu_breakpoint[n]-&gt;pc != pc) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cr = env-&gt;cp15.dbgbcr[n];<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* The WATCHPOINT_HIT flag guarantees us that the watchpoint is<BR>&nbsp;&nbsp;&nbsp;&nbsp; * enabled and that the address and access type match; for breakpoints<BR>&nbsp;&nbsp;&nbsp;&nbsp; * we know the address matched; check the remaining fields, including<BR>&nbsp;&nbsp;&nbsp;&nbsp; * linked breakpoints. We rely on WCR and BCR having the same layout<BR>&nbsp;&nbsp;&nbsp;&nbsp; * for the LBN, SSC, HMC, PAC/PMC and is-linked fields.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Note that some combinations of {PAC, HMC, SSC} are reserved and<BR>&nbsp;&nbsp;&nbsp;&nbsp; * must act either like some valid combination or as if the watchpoint<BR>&nbsp;&nbsp;&nbsp;&nbsp; * were disabled. We choose the former, and use this together with<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the fact that EL3 must always be Secure and EL2 must always be<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Non-Secure to simplify the code slightly compared to the full<BR>&nbsp;&nbsp;&nbsp;&nbsp; * table in the ARM ARM.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; pac = extract64(cr, 1, 2);<BR>&nbsp;&nbsp;&nbsp; hmc = extract64(cr, 13, 1);<BR>&nbsp;&nbsp;&nbsp; ssc = extract64(cr, 14, 2);</P>
<P>&nbsp;&nbsp;&nbsp; switch (ssc) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (is_secure) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!is_secure) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch (access_el) {<BR>&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!hmc) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extract32(pac, 0, 1) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extract32(pac, 1, 1) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; wt = extract64(cr, 20, 1);<BR>&nbsp;&nbsp;&nbsp; lbn = extract64(cr, 16, 4);</P>
<P>&nbsp;&nbsp;&nbsp; if (wt &amp;&amp; !linked_bp_matches(cpu, lbn)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return true;<BR>}</P>
<P>static bool check_watchpoints(ARMCPU *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; int n;</P>
<P>&nbsp;&nbsp;&nbsp; /* If watchpoints are disabled globally or we can't take debug<BR>&nbsp;&nbsp;&nbsp;&nbsp; * exceptions here then watchpoint firings are ignored.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (extract32(env-&gt;cp15.mdscr_el1, 15, 1) == 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || !arm_generate_debug_exceptions(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; for (n = 0; n &lt; ARRAY_SIZE(env-&gt;cpu_watchpoint); n++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bp_wp_matches(cpu, n, true)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return false;<BR>}</P>
<P>static bool check_breakpoints(ARMCPU *cpu)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; int n;</P>
<P>&nbsp;&nbsp;&nbsp; /* If breakpoints are disabled globally or we can't take debug<BR>&nbsp;&nbsp;&nbsp;&nbsp; * exceptions here then breakpoint firings are ignored.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (extract32(env-&gt;cp15.mdscr_el1, 15, 1) == 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || !arm_generate_debug_exceptions(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; for (n = 0; n &lt; ARRAY_SIZE(env-&gt;cpu_breakpoint); n++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bp_wp_matches(cpu, n, false)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return false;<BR>}</P>
<P>void HELPER(check_breakpoints)(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = arm_env_get_cpu(env);</P>
<P>&nbsp;&nbsp;&nbsp; if (check_breakpoints(cpu)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HELPER(exception_internal(env, EXCP_DEBUG));<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>bool arm_debug_check_watchpoint(CPUState *cs, CPUWatchpoint *wp)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Called by core code when a CPU watchpoint fires; need to check if this<BR>&nbsp;&nbsp;&nbsp;&nbsp; * is also an architectural watchpoint match.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);</P>
<P>&nbsp;&nbsp;&nbsp; return check_watchpoints(cpu);<BR>}</P>
<P>void arm_debug_excp_handler(CPUState *cs)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Called by core code when a watchpoint or breakpoint fires;<BR>&nbsp;&nbsp;&nbsp;&nbsp; * need to check which one and raise the appropriate exception.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARMCPU *cpu = ARM_CPU(cs);<BR>&nbsp;&nbsp;&nbsp; CPUARMState *env = &amp;cpu-&gt;env;<BR>&nbsp;&nbsp;&nbsp; CPUWatchpoint *wp_hit = cs-&gt;watchpoint_hit;</P>
<P>&nbsp;&nbsp;&nbsp; if (wp_hit) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (wp_hit-&gt;flags &amp; BP_CPU) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool wnr = (wp_hit-&gt;flags &amp; BP_WATCHPOINT_HIT_WRITE) != 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool same_el = arm_debug_target_el(env) == arm_current_el(env);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs-&gt;watchpoint_hit = NULL;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extended_addresses_enabled(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.fsr = (1 &lt;&lt; 9) | 0x22;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.fsr = 0x2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.vaddress = wp_hit-&gt;hitaddr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise_exception(env, EXCP_DATA_ABORT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syn_watchpoint(same_el, 0, wnr),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_debug_target_el(env));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t pc = is_a64(env) ? env-&gt;pc : env-&gt;regs[15];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool same_el = (arm_debug_target_el(env) == arm_current_el(env));</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* (1) GDB breakpoints should be handled first.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * (2) Do not raise a CPU exception if no CPU breakpoint has fired,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * since singlestep is also done by generating a debug internal<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * exception.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cpu_breakpoint_test(cs, pc, BP_GDB)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || !cpu_breakpoint_test(cs, pc, BP_CPU)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extended_addresses_enabled(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.fsr = (1 &lt;&lt; 9) | 0x22;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;exception.fsr = 0x2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* FAR is UNKNOWN, so doesn't need setting */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise_exception(env, EXCP_PREFETCH_ABORT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syn_breakpoint(same_el),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arm_debug_target_el(env));<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* ??? Flag setting arithmetic is awkward because we need to do comparisons.<BR>&nbsp;&nbsp; The only way to do that in TCG is a conditional branch, which clobbers<BR>&nbsp;&nbsp; all our temporaries.&nbsp; For now implement these as helper functions.&nbsp; */</P>
<P>/* Similarly for variable shift instructions.&nbsp; */</P>
<P>uint32_t HELPER(shl_cc)(CPUARMState *env, uint32_t x, uint32_t i)<BR>{<BR>&nbsp;&nbsp;&nbsp; int shift = i &amp; 0xff;<BR>&nbsp;&nbsp;&nbsp; if (shift &gt;= 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (shift == 32)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;CF = x &amp; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;CF = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; } else if (shift != 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;CF = (x &gt;&gt; (32 - shift)) &amp; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x &lt;&lt; shift;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return x;<BR>}</P>
<P>uint32_t HELPER(shr_cc)(CPUARMState *env, uint32_t x, uint32_t i)<BR>{<BR>&nbsp;&nbsp;&nbsp; int shift = i &amp; 0xff;<BR>&nbsp;&nbsp;&nbsp; if (shift &gt;= 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (shift == 32)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;CF = (x &gt;&gt; 31) &amp; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;CF = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; } else if (shift != 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;CF = (x &gt;&gt; (shift - 1)) &amp; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x &gt;&gt; shift;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return x;<BR>}</P>
<P>uint32_t HELPER(sar_cc)(CPUARMState *env, uint32_t x, uint32_t i)<BR>{<BR>&nbsp;&nbsp;&nbsp; int shift = i &amp; 0xff;<BR>&nbsp;&nbsp;&nbsp; if (shift &gt;= 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;CF = (x &gt;&gt; 31) &amp; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (int32_t)x &gt;&gt; 31;<BR>&nbsp;&nbsp;&nbsp; } else if (shift != 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;CF = (x &gt;&gt; (shift - 1)) &amp; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (int32_t)x &gt;&gt; shift;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return x;<BR>}</P>
<P>uint32_t HELPER(ror_cc)(CPUARMState *env, uint32_t x, uint32_t i)<BR>{<BR>&nbsp;&nbsp;&nbsp; int shift1, shift;<BR>&nbsp;&nbsp;&nbsp; shift1 = i &amp; 0xff;<BR>&nbsp;&nbsp;&nbsp; shift = shift1 &amp; 0x1f;<BR>&nbsp;&nbsp;&nbsp; if (shift == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (shift1 != 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;CF = (x &gt;&gt; 31) &amp; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;CF = (x &gt;&gt; (shift - 1)) &amp; 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((uint32_t)x &gt;&gt; shift) | (x &lt;&lt; (32 - shift));<BR>&nbsp;&nbsp;&nbsp; }<BR>}