/* Return the Exception Level targeted by debug exceptions. */<BR>static inline int arm_debug_target_el(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; bool secure = arm_is_secure(env);<BR>&nbsp;&nbsp;&nbsp; bool route_to_el2 = false;</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL2) &amp;&amp; !secure) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; route_to_el2 = env-&gt;cp15.hcr_el2 &amp; HCR_TGE ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env-&gt;cp15.mdcr_el2 &amp; (1 &lt;&lt; 8);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (route_to_el2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;<BR>&nbsp;&nbsp;&nbsp; } else if (arm_feature(env, ARM_FEATURE_EL3) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !arm_el_is_aa64(env, 3) &amp;&amp; secure) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static inline bool aa64_generate_debug_exceptions(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_is_secure(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* MDCR_EL3.SDD disables debug events from Secure state */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extract32(env-&gt;cp15.mdcr_el3, 16, 1) != 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || arm_current_el(env) == 3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_current_el(env) == arm_debug_target_el(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((extract32(env-&gt;cp15.mdscr_el1, 13, 1) == 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (env-&gt;daif &amp; PSTATE_D)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return true;<BR>}</P>
<P>static inline bool aa32_generate_debug_exceptions(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; int el = arm_current_el(env);</P>
<P>&nbsp;&nbsp;&nbsp; if (el == 0 &amp;&amp; arm_el_is_aa64(env, 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return aa64_generate_debug_exceptions(env);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (arm_is_secure(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int spd;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (el == 0 &amp;&amp; (env-&gt;cp15.sder &amp; 1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* SDER.SUIDEN means debug exceptions from Secure EL0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * are always enabled. Otherwise they are controlled by<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * SDCR.SPD like those from other Secure ELs.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spd = extract32(env-&gt;cp15.mdcr_el3, 14, 2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (spd) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* SPD == 0b01 is reserved, but behaves as 0b00. */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* For 0b00 we return true if external secure invasive debug<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * is enabled. On real hardware this is controlled by external<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * signals to the core. QEMU always permits debug, and behaves<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * as if DBGEN, SPIDEN, NIDEN and SPNIDEN are all tied high.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return el != 2;<BR>}</P>
<P>/* Return true if debugging exceptions are currently enabled.<BR>&nbsp;* This corresponds to what in ARM ARM pseudocode would be<BR>&nbsp;*&nbsp;&nbsp;&nbsp; if UsingAArch32() then<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return AArch32.GenerateDebugExceptions()<BR>&nbsp;*&nbsp;&nbsp;&nbsp; else<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return AArch64.GenerateDebugExceptions()<BR>&nbsp;* We choose to push the if() down into this function for clarity,<BR>&nbsp;* since the pseudocode has it at all callsites except for the one in<BR>&nbsp;* CheckSoftwareStep(), where it is elided because both branches would<BR>&nbsp;* always return the same value.<BR>&nbsp;*<BR>&nbsp;* Parts of the pseudocode relating to EL2 and EL3 are omitted because we<BR>&nbsp;* don't yet implement those exception levels or their associated trap bits.<BR>&nbsp;*/<BR>static inline bool arm_generate_debug_exceptions(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (env-&gt;aarch64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return aa64_generate_debug_exceptions(env);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return aa32_generate_debug_exceptions(env);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Is single-stepping active? (Note that the "is EL_D AArch64?" check<BR>&nbsp;* implicitly means this always returns false in pre-v8 CPUs.)<BR>&nbsp;*/<BR>static inline bool arm_singlestep_active(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; return extract32(env-&gt;cp15.mdscr_el1, 0, 1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; arm_el_is_aa64(env, arm_debug_target_el(env))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; arm_generate_debug_exceptions(env);<BR>}