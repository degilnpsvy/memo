/* ARM has the following "translation regimes" (as the ARM ARM calls them):<BR>&nbsp;*<BR>&nbsp;* If EL3 is 64-bit:<BR>&nbsp;*&nbsp; + NonSecure EL1 &amp; 0 stage 1<BR>&nbsp;*&nbsp; + NonSecure EL1 &amp; 0 stage 2<BR>&nbsp;*&nbsp; + NonSecure EL2<BR>&nbsp;*&nbsp; + Secure EL1 &amp; EL0<BR>&nbsp;*&nbsp; + Secure EL3<BR>&nbsp;* If EL3 is 32-bit:<BR>&nbsp;*&nbsp; + NonSecure PL1 &amp; 0 stage 1<BR>&nbsp;*&nbsp; + NonSecure PL1 &amp; 0 stage 2<BR>&nbsp;*&nbsp; + NonSecure PL2<BR>&nbsp;*&nbsp; + Secure PL0 &amp; PL1<BR>&nbsp;* (reminder: for 32 bit EL3, Secure PL1 is *EL3*, not EL1.)<BR>&nbsp;*<BR>&nbsp;* For QEMU, an mmu_idx is not quite the same as a translation regime because:<BR>&nbsp;*&nbsp; 1. we need to split the "EL1 &amp; 0" regimes into two mmu_idxes, because they<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; may differ in access permissions even if the VA-&gt;PA map is the same<BR>&nbsp;*&nbsp; 2. we want to cache in our TLB the full VA-&gt;IPA-&gt;PA lookup for a stage 1+2<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; translation, which means that we have one mmu_idx that deals with two<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; concatenated translation regimes [this sort of combined s1+2 TLB is<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; architecturally permitted]<BR>&nbsp;*&nbsp; 3. we don't need to allocate an mmu_idx to translations that we won't be<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; handling via the TLB. The only way to do a stage 1 translation without<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; the immediate stage 2 translation is via the ATS or AT system insns,<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; which can be slow-pathed and always do a page table walk.<BR>&nbsp;*&nbsp; 4. we can also safely fold together the "32 bit EL3" and "64 bit EL3"<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; translation regimes, because they map reasonably well to each other<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; and they can't both be active at the same time.<BR>&nbsp;* This gives us the following list of mmu_idx values:<BR>&nbsp;*<BR>&nbsp;* NS EL0 (aka NS PL0) stage 1+2<BR>&nbsp;* NS EL1 (aka NS PL1) stage 1+2<BR>&nbsp;* NS EL2 (aka NS PL2)<BR>&nbsp;* S EL3 (aka S PL1)<BR>&nbsp;* S EL0 (aka S PL0)<BR>&nbsp;* S EL1 (not used if EL3 is 32 bit)<BR>&nbsp;* NS EL0+1 stage 2<BR>&nbsp;*<BR>&nbsp;* (The last of these is an mmu_idx because we want to be able to use the TLB<BR>&nbsp;* for the accesses done as part of a stage 1 page table walk, rather than<BR>&nbsp;* having to walk the stage 2 page table over and over.)<BR>&nbsp;*<BR>&nbsp;* Our enumeration includes at the end some entries which are not "true"<BR>&nbsp;* mmu_idx values in that they don't have corresponding TLBs and are only<BR>&nbsp;* valid for doing slow path page table walks.<BR>&nbsp;*<BR>&nbsp;* The constant names here are patterned after the general style of the names<BR>&nbsp;* of the AT/ATS operations.<BR>&nbsp;* The values used are carefully arranged to make mmu_idx =&gt; EL lookup easy.<BR>&nbsp;*/<BR>typedef enum ARMMMUIdx {<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S12NSE0 = 0,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S12NSE1 = 1,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1E2 = 2,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1E3 = 3,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1SE0 = 4,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1SE1 = 5,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S2NS = 6,<BR>&nbsp;&nbsp;&nbsp; /* Indexes below here don't have TLBs and are used only for AT system<BR>&nbsp;&nbsp;&nbsp;&nbsp; * instructions or for the first stage of an S12 page table walk.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1NSE0 = 7,<BR>&nbsp;&nbsp;&nbsp; ARMMMUIdx_S1NSE1 = 8,<BR>} ARMMMUIdx; 
<P></P>
<P>#define MMU_USER_IDX 0