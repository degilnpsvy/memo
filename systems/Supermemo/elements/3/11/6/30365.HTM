/* Access rights:<BR>&nbsp;* We define bits for Read and Write access for what rev C of the v7-AR ARM ARM<BR>&nbsp;* defines as PL0 (user), PL1 (fiq/irq/svc/abt/und/sys, ie privileged), and<BR>&nbsp;* PL2 (hyp). The other level which has Read and Write bits is Secure PL1<BR>&nbsp;* (ie any of the privileged modes in Secure state, or Monitor mode).<BR>&nbsp;* If a register is accessible in one privilege level it's always accessible<BR>&nbsp;* in higher privilege levels too. Since "Secure PL1" also follows this rule<BR>&nbsp;* (ie anything visible in PL2 is visible in S-PL1, some things are only<BR>&nbsp;* visible in S-PL1) but "Secure PL1" is a bit of a mouthful, we bend the<BR>&nbsp;* terminology a little and call this PL3.<BR>&nbsp;* In AArch64 things are somewhat simpler as the PLx bits line up exactly<BR>&nbsp;* with the ELx exception levels.<BR>&nbsp;*<BR>&nbsp;* If access permissions for a register are more complex than can be<BR>&nbsp;* described with these bits, then use a laxer set of restrictions, and<BR>&nbsp;* do the more restrictive/complex check inside a helper function.<BR>&nbsp;*/<BR>#define PL3_R 0x80<BR>#define PL3_W 0x40<BR>#define PL2_R (0x20 | PL3_R)<BR>#define PL2_W (0x10 | PL3_W)<BR>#define PL1_R (0x08 | PL2_R)<BR>#define PL1_W (0x04 | PL2_W)<BR>#define PL0_R (0x02 | PL1_R)<BR>#define PL0_W (0x01 | PL1_W)</P>
<P>#define PL3_RW (PL3_R | PL3_W)<BR>#define PL2_RW (PL2_R | PL2_W)<BR>#define PL1_RW (PL1_R | PL1_W)<BR>#define PL0_RW (PL0_R | PL0_W)</P>
<P>/* Return the highest implemented Exception Level */<BR>static inline int arm_highest_el(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_EL2)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return 1;<BR>}</P>
<P>/* Return the current Exception Level (as per ARMv8; note that this differs<BR>&nbsp;* from the ARMv7 Privilege Level).<BR>&nbsp;*/<BR>static inline int arm_current_el(CPUARMState *env)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arm_feature(env, ARM_FEATURE_M)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return !((env-&gt;v7m.exception == 0) &amp;&amp; (env-&gt;v7m.control &amp; 1));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (is_a64(env)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return extract32(env-&gt;pstate, 2, 2);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch (env-&gt;uncached_cpsr &amp; 0x1f) {<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_USR:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_HYP:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;<BR>&nbsp;&nbsp;&nbsp; case ARM_CPU_MODE_MON:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arm_is_secure(env) &amp;&amp; !arm_el_is_aa64(env, 3)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* If EL3 is 32-bit then all secure privileged modes run in<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * EL3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>}