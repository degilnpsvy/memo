<B><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">3.1.3. Invoking GCC to build proper inline assembly code</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Because assembly routines from the kernel headers (and most likely your own headers, if you try making your assembly programming as clean as it is in the linux kernel) are embedded in&nbsp;extern inline&nbsp;functions, GCC must be invoked with the&nbsp;-O&nbsp;flag (or&nbsp;-O2,&nbsp;-O3, etc), for these routines to be available. If not, your code may compile, but not link properly, since it will be looking for non-inlined&nbsp;extern&nbsp;functions in the libraries against which your program is being linked! Another way is to link against libraries that include fallback versions of the routines.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Inline assembly can be disabled with&nbsp;-fno-asm, which will have the compiler die when using extended inline asm syntax, or else generate calls to an external function named&nbsp;asm()that the linker can't resolve. To counter such flag,&nbsp;-fasm&nbsp;restores treatment of the&nbsp;asm&nbsp;keyword.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">More generally, good compile flags for GCC on the x86 platform are</SPAN></P>
<p><B><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">gcc -O2 -fomit-frame-pointer -W -Wall</SPAN></B><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt"></SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">-O2&nbsp;is the good optimization level in most cases. Optimizing besides it takes more time, and yields code that is much larger, but only a bit faster; such over-optimization might be useful for tight loops only (if any), which you may be doing in assembly anyway. In cases when you need really strong compiler optimization for a few files, do consider using up to&nbsp;-O6.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">-fomit-frame-pointer&nbsp;allows generated code to skip the stupid frame pointer maintenance, which makes code smaller and faster, and frees a register for further optimizations. It precludes the easy use of debugging tools (<B>gdb</B>), but when you use these, you just don't care about size and speed anymore anyway.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">-W -Wall&nbsp;enables all useful warnings and helps you to catch obvious stupid errors.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">You can add some CPU-specific&nbsp;-m486&nbsp;or such flag so that GCC will produce code that is more adapted to your precise CPU. Note that modern GCC has&nbsp;-mpentium&nbsp;and such flags (and PGCC has even more), whereas GCC 2.7.x and older versions do not. A good choice of CPU-specific flags should be in the Linux kernel. Check the TeXinfo documentation of your current GCC installation for more.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">-m386&nbsp;will help optimize for size, hence also for speed on computers whose memory is tight and/or loaded, since big programs cause swap, which more than counters any "optimization" intended by the larger code. In such settings, it might be useful to stop using C, and use instead a language that favors code factorization, such as a functional language and/or FORTH, and use a bytecode- or wordcode- based implementation.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Note that you can vary code generation flags from file to file, so performance-critical files will use maximum optimization, whereas other files will be optimized for size.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">To optimize even more, option&nbsp;-mregparm=2&nbsp;and/or corresponding function attribute might help, but might pose lots of problems when linking to foreign code,&nbsp;<I>including&nbsp;libc</I>. There are ways to correctly declare foreign functions so the right call sequences be generated, or you might want to recompile the foreign libraries to use the same register-based calling convention...</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Note that you can add make these flags the default by editing file&nbsp;/usr/lib/gcc-lib/i486-linux/2.7.2.3/specs&nbsp;or wherever that is on your system (better not add&nbsp;-W -Wall&nbsp;there, though). The exact location of the GCC specs files on system can be found by&nbsp;<B>gcc -v</B>.</SPAN>