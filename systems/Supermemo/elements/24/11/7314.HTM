<B><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">5.1.4. Hardware I/O under Linux</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">If you want to perform direct port I/O under Linux, either it's something very simple that does not need OS arbitration, and you should see the&nbsp;IO-Port-Programming&nbsp;mini-HOWTO; or it needs a kernel device driver, and you should try to learn more about kernel hacking, device driver development, kernel modules, etc, for which there are other excellent HOWTOs and documents from the LDP.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Particularly, if what you want is Graphics programming, then do join one of the GGI or XFree86 projects.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Some people have even done better, writing small and robust XFree86 drivers in an interpreted domain-specific language, GAL, and achieving the efficiency of hand C-written drivers through partial evaluation (drivers not only not in asm, but not even in C!). The problem is that the partial evaluator they used to achieve efficiency is not free software. Any taker for a replacement?</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Anyway, in all these cases, you'll be better when using GCC inline assembly with the macros from&nbsp;linux/asm/*.h&nbsp;than writing full assembly source files.</SPAN>