<B><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">5.1.3. Direct Linux syscalls</SPAN></B></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Often you will be told that using&nbsp;C library&nbsp;(libc) is the only way, and direct system calls are bad. This is true. To some extent. In general, you must know that&nbsp;libc&nbsp;is not sacred, and in&nbsp;<I>most</I>&nbsp;cases it only does some checks, then calls kernel, and then sets errno. You can easily do this in your program as well (if you need to), and your program will be dozen times smaller, and this will result in improved performance as well, just because you're not using shared libraries (static binaries are faster). Using or not using&nbsp;libc&nbsp;in assembly programming is more a question of taste/belief than something practical. Remember, Linux is aiming to be POSIX compliant, so does&nbsp;libc. This means that syntax of almost all&nbsp;libc&nbsp;"system calls" exactly matches syntax of real kernel system calls (and vice versa). Besides,&nbsp;GNU libc(glibc) becomes slower and slower from version to version, and eats more and more memory; and so, cases of using direct system calls become quite usual. However, the main drawback of throwing&nbsp;libc&nbsp;away is that you will possibly need to implement several&nbsp;libc&nbsp;specific functions (that are not just syscall wrappers) on your own (printf()&nbsp;and Co.), and you are ready for that, aren't you? :-)</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Here is summary of direct system calls pros and cons.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Pros:</SPAN></P>
<UL style="MARGIN-TOP: 0cm" type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">the smallest possible size; squeezing the last byte out of the system</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">the highest possible speed; squeezing cycles out of your favorite benchmark</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">full control: you can adapt your program/library to your specific language or memory requirements or whatever</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">no pollution by libc cruft</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">no pollution by C calling conventions (if you're developing your own language or environment)</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">static binaries make you independent from libc upgrades or crashes, or from dangling&nbsp;#!&nbsp;path to an interpreter (and are faster)</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l0 level1 lfo1; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">just for the fun out of it (don't you get a kick out of assembly programming?)</SPAN></LI></UL>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Cons:</SPAN></P>
<UL style="MARGIN-TOP: 0cm" type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">If any other program on your computer uses the libc, then duplicating the libc code will actually wastes memory, not saves it.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Services redundantly implemented in many static binaries are a waste of memory. But you can make your libc replacement a shared library.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Size is much better saved by having some kind of bytecode, wordcode, or structure interpreter than by writing everything in assembly. (the interpreter itself could be written either in C or assembly.) The best way to keep multiple binaries small is to not have multiple binaries, but instead to have an interpreter process files with&nbsp;#!prefix. This is how OCaml works when used in wordcode mode (as opposed to optimized native code mode), and it is compatible with using the libc. This is also how Tom Christiansen's Perl PowerTools reimplementation of unix utilities works. Finally, one last way to keep things small, that doesn't depend on an external file with a hardcoded path, be it library or interpreter, is to have only one binary, and have multiply-named hard or soft links to it: the same binary will provide everything you need in an optimal space, with no redundancy of subroutines or useless binary headers; it will dispatch its specific behavior according to its&nbsp;<I>argv[0]</I>; in case it isn't called with a recognized name, it might default to a shell, and be possibly thus also usable as an interpreter!</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">You cannot benefit from the many functionalities that libc provides besides mere linux syscalls: that is, functionality described in section 3 of the manual pages, as opposed to section 2, such as malloc, threads, locale, password, high-level network management, etc.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Therefore, you might have to reimplement large parts of libc, from&nbsp;printf()&nbsp;to&nbsp;malloc()&nbsp;and&nbsp;gethostbyname. It's redundant with the libc effort, and can be&nbsp;<I>quite</I>&nbsp;boring sometimes. Note that some people have already reimplemented "light" replacements for parts of the libc - - check them out! (Redhat's minilibc, Rick Hohensee's libsys, Felix von Leitner's dietlibc, asmutils project is working on pure assembly libc)</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Static libraries prevent you to benefit from libc upgrades as well as from libc add-ons such as the&nbsp;zlibc&nbsp;package, that does on-the-fly transparent decompression of gzip-compressed files.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">The few instructions added by the libc can be a&nbsp;<I>ridiculously</I>&nbsp;small speed overhead as compared to the cost of a system call. If speed is a concern, your main problem is in your usage of system calls, not in their wrapper's implementation.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Using the standard assembly API for system calls is much slower than using the libc API when running in micro-kernel versions of Linux such as L4Linux, that have their own faster calling convention, and pay high convention-translation overhead when using the standard one (L4Linux comes with libc recompiled with their syscall API; of course, you could recompile your code with their API, too).</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">See previous discussion for general speed optimization issue.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l2 level1 lfo2; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">If syscalls are too slow to you, you might want to hack the kernel sources (in C) instead of staying in userland.</SPAN></LI></UL>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">If you've pondered the above pros and cons, and still want to use direct syscalls, then here is some advice.</SPAN></P>
<UL style="MARGIN-TOP: 0cm" type=disc>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l1 level1 lfo3; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">You can easily define your system calling functions in a portable way in C (as opposed to unportable using assembly), by including&nbsp;asm/unistd.h, and using provided macros.</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l1 level1 lfo3; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Since you're trying to replace it, go get the sources for the libc, and grok them. (And if you think you can do better, then send feedback to the authors!)</SPAN></LI>
<LI class=MsoNormal style="MARGIN: 0cm 0cm 0pt; mso-list: l1 level1 lfo3; tab-stops: list 36.0pt"><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">As an example of pure assembly code that does everything you want, examine .</SPAN></LI></UL>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Basically, you issue an&nbsp;int 0x80, with the&nbsp;__NR_syscallname number (from&nbsp;asm/unistd.h) in&nbsp;eax, and parameters (up to six) in&nbsp;ebx,&nbsp;ecx,&nbsp;edx,&nbsp;esi,&nbsp;edi,&nbsp;ebp&nbsp;respectively.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Result is returned in&nbsp;eax, with a negative result being an error, whose opposite is what libc would put into&nbsp;errno. The user-stack is not touched, so you needn't have a valid one when doing a syscall.</SPAN></P>
<TABLE class=MsoNormalTable style="WIDTH: 100%; mso-cellspacing: 1.5pt" cellPadding=0 width="100%" border=0>
<TBODY>
<TR style="mso-yfti-irow: 0; mso-yfti-firstrow: yes; mso-yfti-lastrow: yes">
<TD style="BORDER-RIGHT: #ffffff; PADDING-RIGHT: 0.75pt; BORDER-TOP: #ffffff; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; BORDER-LEFT: #ffffff; WIDTH: 18.75pt; PADDING-TOP: 0.75pt; BORDER-BOTTOM: #ffffff; BACKGROUND-COLOR: transparent" vAlign=top width=25>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt"><v:shapetype id=_x0000_t75 stroked="f" filled="f" path="m@4@5l@4@11@9@11@9@5xe" o:preferrelative="t" o:spt="75" coordsize="21600,21600"><v:stroke joinstyle="miter"></v:stroke><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"></v:f><v:f eqn="sum @0 1 0"></v:f><v:f eqn="sum 0 0 @1"></v:f><v:f eqn="prod @2 1 2"></v:f><v:f eqn="prod @3 21600 pixelWidth"></v:f><v:f eqn="prod @3 21600 pixelHeight"></v:f><v:f eqn="sum @0 0 1"></v:f><v:f eqn="prod @6 1 2"></v:f><v:f eqn="prod @7 21600 pixelWidth"></v:f><v:f eqn="sum @8 21600 0"></v:f><v:f eqn="prod @7 21600 pixelHeight"></v:f><v:f eqn="sum @10 21600 0"></v:f></v:formulas><v:path o:connecttype="rect" gradientshapeok="t" o:extrusionok="f"></v:path><o:lock aspectratio="t" v:ext="edit"></o:lock></v:shapetype><v:shape id=_x0000_i1025 style="WIDTH: 18pt; HEIGHT: 18pt; mso-wrap-distance-left: 3.75pt; mso-wrap-distance-right: 3.75pt" alt="Note" type="#_x0000_t75"><v:imagedata o:href="http://www.tldp.org/HOWTO/images/note.gif" src="file:///C:\DOCUME~1\DONPOP~1\LOCALS~1\Temp\msohtml1\01\clip_image001.gif"></v:imagedata></v:shape></SPAN></P></TD>
<TD style="BORDER-RIGHT: #ffffff; PADDING-RIGHT: 0.75pt; BORDER-TOP: #ffffff; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; BORDER-LEFT: #ffffff; PADDING-TOP: 0.75pt; BORDER-BOTTOM: #ffffff; BACKGROUND-COLOR: transparent" vAlign=top>
<p><A name=""></A><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Passing sixth parameter in&nbsp;ebp&nbsp;appeared in Linux 2.4, previous Linux versions understand only 5 parameters in registers.</SPAN></P></TD></TR></TBODY></TABLE>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">Linux Kernel Internals, and especially How System Calls Are Implemented on i386 Architecture? chapter will give you more robust overview.</SPAN></P>
<p><SPAN lang=EN-US style="FONT-SIZE: 16pt; mso-bidi-font-size: 12.0pt">As for the invocation arguments passed to a process upon startup, the general principle is that the stack originally contains the number of arguments&nbsp;<I>argc</I>, then the list of pointers that constitute&nbsp;<I>*argv</I>, then a null-terminated sequence of null-terminated&nbsp;variable=value&nbsp;strings for the&nbsp;<I>environ</I>ment. For more details, do examine , read the sources of C startup code from your libc (crt0.S&nbsp;or&nbsp;crt1.S), or those from the Linux kernel (exec.c&nbsp;and&nbsp;binfmt_*.c&nbsp;in&nbsp;linux/fs/).</SPAN>