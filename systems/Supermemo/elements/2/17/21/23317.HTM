<H3 id=title-IDAN2PWC class=docSection1Title>17.1. What Is Real Time?</H3>
<P class=docText>Ask five people what "real time" means, and, chances are, you will get five different answers. Some might even cite some numbers. For the purposes of the discussion to follow, we discuss some scenarios and then propose a definition. Many requirements might be said to be soft real time, while others are called hard real time.</P><A name=ch17lev2sec1></A>
<H4 id=title-IDAY2PWC class=docSection2Title>17.1.1. Soft Real Time</H4>
<P class=docText>Most agree that soft real time means that the operation has a deadline, but if the deadline is missed, the quality of the experience could be diminished (but not fatal). Your desktop workstation is a perfect example of soft real-time requirements. When you are editing a document, you expect to see the results of your keystrokes immediately on the screen. When playing your favorite <TT>.mp3</TT> file, you expect to have high-quality audio without any clicks, pops, or gaps in the music.</P>
<P class=docText>In general terms, humans cannot see or hear delays below a few tens of milliseconds. Of course, the musicians in the crowd will tell you that music can be <SPAN class=docEmphasis>colored</SPAN> by delays smaller than that. If a deadline is missed by these so-called soft real-time events, the results may be undesirable, leading to a lower level of "quality" of the experience, but not catastrophic.</P><A name=ch17lev2sec2></A>
<H4 id=title-IDAM3PWC class=docSection2Title>17.1.2. Hard Real Time</H4>
<P class=docText>Hard real time is characterized by the results of a missed deadline. In a hard real-time system, if a deadline is missed, the results are often catastrophic. Of course, <A name=iddle1682></A><A name=iddle1683></A><A name=iddle1687></A><A name=iddle1813></A><A name=iddle1836></A><A name=iddle2324></A><A name=iddle2325></A><A name=iddle2396></A><SPAN class=docEmphasis>catastrophic</SPAN> is a relative term. If your embedded device is controlling the fuel flow to a jet aircraft engine, missing a deadline to respond to pilot input or a change in operational characteristics can lead to disastrous results.</P>
<P class=docText>Note that the duration of the deadline has no bearing on the real-time characteristic. Servicing the tick on an atomic clock is such an example. As long as the tick is processed within the 1-second window before the next tick, the data remains valid. Missing the processing on a tick might throw off our global positioning systems by feet or even miles!</P>
<P class=docText>With this in mind, we draw on a commonly used set of definitions for soft and hard real time. For soft real-time systems, the value of a computation or result is diminished if a deadline is missed. For hard real-time systems, if a single deadline is missed, the system is considered to have failed, and might have catastrophic consequences.</P><A name=ch17lev2sec3></A>
<H4 id=title-IDAKA4PC class=docSection2Title>17.1.3. Linux Scheduling</H4>
<P class=docText>UNIX and Linux were both designed for fairness in their process scheduling. That is, the scheduler tries its best to allocate available resources across all processes that need the CPU and guarantee each process that they can make progress. This very design objective is counter to the requirement for a real-time process. A real-time process must run as soon as possible after it is ready to run. Real time means having predictable and repeatable latency.</P><A name=ch17lev2sec4></A>
<H4 id=title-IDAWA4PC class=docSection2Title>17.1.4. Latency</H4>
<P class=docText>Real-time processes are often associated with a physical event, such as an interrupt arriving from a peripheral device. <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch17lev1sec1.html#ch17fig01">Figure 17-1</A> illustrates the latency components in a Linux system. Latency measurement begins upon receipt of the interrupt we want to process. This is indicated by time <TT>t0</TT> in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch17lev1sec1.html#ch17fig01">Figure 17-1</A>. Sometime later, the interrupt is taken and control is passed to the Interrupt Service Routine (ISR). This is indicated by time <TT>t1</TT>. This interrupt latency is almost entirely dictated by the maximum interrupt off time<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch17lev1sec1.html#ch171">[1]</A></SUP>the time spent in a thread of execution that has hardware interrupts disabled.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch171>[1]</A></SUP> We neglect the context switching time for interrupt processing because it is often negligible compared to interrupt off time.</P></BLOCKQUOTE>
<P class=docText></P><A name=ch17fig01></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 17-1. Latency components</H5>
<P class=docText><IMG border=0 alt="" src="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/images/17elp01.jpg" width=400 height=245></P></CENTER>
<P></P><BR>
<P class=docText><A name=iddle1132></A>It is considered good design practice to minimize the processing done in the actual interrupt service routine. Indeed, this execution context is limited in capability (for example, an ISR cannot call a blocking function, one that might sleep), so it is desirable to simply service the hardware device and leave the data processing to a Linux <SPAN class=docEmphasis>bottom half</SPAN>,<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch17lev1sec1.html#ch172">[2]</A></SUP> also called softIRQs.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch172>[2]</A></SUP> Robert Love explains bottom-half processing in great detail in his book <SPAN class=docEmphasis>Linux Kernel Development</SPAN>. See <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch17lev1sec5.html#ch17lev2sec22">Section 17.5.1</A>, "Suggestions for Additional Reading," at the end of this chapter for the reference.</P></BLOCKQUOTE>
<P class=docText>When the ISR/bottom half has finished its processing, the usual case is to wake up a user space process that is waiting for the data. This is indicated by time <TT>t2</TT> in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch17lev1sec1.html#ch17fig01">Figure 17-1</A>. At some point in time later, the real-time process is selected by the scheduler to run and is given the CPU. This is indicated by time <TT>t3</TT> in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch17lev1sec1.html#ch17fig01">Figure 17-1</A>. Scheduling latency is affected primarily by the number of processes waiting for the CPU and the priorities among them. Setting the Real Time attribute on a process gives it higher priority over normal Linux processes and allows it to be the next process selected to run, assuming that it is the highest priority real-time process waiting for the CPU. The highest-priority real-time process that is ready to run (not blocked on I/O) will always run. You'll see how to set this attribute shortly.