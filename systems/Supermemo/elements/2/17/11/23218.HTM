<H3 id=title-IDAEB5VD class=docSection1Title>2.4. Embedded Linux Distributions</H3>
<P class=docText>What exactly is a distribution anyway? After the Linux kernel boots, it expects to find and mount a root file system. When a suitable root file system has been mounted, startup scripts launch a number of programs and utilities that the system requires. These programs often invoke other programs to do specific tasks, such as spawn a login shell, initialize network interfaces, and launch a user's applications. Each of these programs has specific requirements of the system. Most Linux application programs depend on one or more system libraries. Other programs require configuration and log files, and so on. In summary, even a small embedded Linux system needs many dozens of files populated in an appropriate directory structure on a <SPAN class=docEmphasis>root file system</SPAN>.</P>
<P class=docText>Full-blown desktop systems have many thousands of files on the root file system. These files come from <SPAN class=docEmphasis>packages</SPAN> that are usually grouped by functionality. The packages are typically installed and managed using a package manager. Red Hat's Package Manager (<TT>rpm</TT>) is a popular example and is widely used for installing, removing, and updating packages on a Linux system. If your Linux workstation is based on Red Hat, including the Fedora Core series, typing <TT>rpm -qa</TT> at a command prompt lists all the packages installed on your system.</P>
<P class=docText>A package can consist of many files; indeed, some packages contain hundreds of files. A complete Linux distribution can contain hundreds or even thousands of packages. These are some examples of packages that you might find on an embedded Linux distribution, and their purpose:</P>
<UL>
<LI>
<P class=docText><TT>initscripts</TT> Contains basic system startup and shutdown scripts.</P></LI>
<LI>
<P class=docText><TT>apache</TT> Implements the popular Apache web server.</P></LI>
<LI>
<P class=docText><TT>telnet-server</TT> Contains files necessary to implement telnet server functionality, which allows you to establish Telnet sessions to your embedded target.</P></LI>
<LI>
<P class=docText><TT>glibc</TT> Standard C library</P></LI>
<LI>
<P class=docText><TT>busybox</TT> Compact versions of dozens of popular command line utilities commonly found on UNIX/Linux systems.<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec4.html#ch02fn15">[15]</A></SUP> 
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn15>[15]</A></SUP> This package is important enough to warrant its own chapter. <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch11.html#ch11">Chapter 11</A>, "BusyBox," covers BusyBox in detail.</P></BLOCKQUOTE>
<P></P></LI></UL>
<P class=docText><A name=iddle1199></A>This is the purpose of a Linux <SPAN class=docEmphasis>distribution</SPAN> as the term has come to be used. A typical Linux distribution comes with several CD-ROMs full of useful programs, libraries, tools, utilities, and documentation. Installation of a distribution typically leaves the user with a fully functional system based on a reasonable set of default configuration options, which can be tailored to suit a particular set of requirements. You may be familiar with one of the popular desktop Linux distributions, such as RedHat or Suse.</P>
<P class=docText>A Linux distribution for embedded targets differs in several significant ways. First, the executable target binaries from an embedded distribution will not run on your PC, but are targeted to the architecture and processor of your embedded system. (Of course, if your embedded Linux distribution targets the x86 architecture, this statement does not apply.) A desktop Linux distribution tends to have many GUI tools aimed at the typical desktop user, such as fancy graphical clocks, calculators, personal time-management tools, email clients and more. An embedded Linux distribution typically omits these components in favor of specialized tools aimed at developers, such as memory analysis tools, remote debug facilities, and many more.</P>
<P class=docText>Another significant difference between desktop and embedded Linux distributions is that an embedded distribution typically contains cross-tools, as opposed to native tools. For example, the <TT>gcc</TT> toolchain that ships with an embedded Linux distribution runs on your x86 desktop PC, but produces binary code that runs on your target system. Many of the other tools in the toolchain are similarly configured: They run on the development host (usually an x86 PC) but operate on foreign architectures such as ARM or PowerPC.</P><A name=ch02lev2sec15></A>
<H4 id=title-IDAGE5VD class=docSection2Title>2.4.1. Commercial Linux Distributions</H4>
<P class=docText>There are several vendors of commercial <SPAN class=docEmphasis>embedded</SPAN> Linux distributions. The leading embedded Linux vendors have been shipping embedded Linux distributions for some years. <SPAN class=docEmphasis><A class=docLink href="http://www.linuxdevices.com/" target=_blank>Linuxdevices.com</A></SPAN>, a popular embedded Linux news and information portal, has compiled a comprehensive list of commercially available embedded Linux distributions. It is somewhat dated but is still a very useful starting point. You can find their compilation at <A class=docLink href="http://www.linuxdevices.com/articles/AT9952405558.html" target=_blank>www.linuxdevices.com/articles/AT9952405558.html</A>.</P><A name=ch02lev2sec16></A>
<H4 id=title-IDABF5VD class=docSection2Title>2.4.2. Do-It-Yourself Linux Distributions</H4>
<P class=docText><A name=iddle1358></A>You can choose to assemble all the components you need for your embedded project on your own. You will have to decide whether the risks are worth the effort. If you find yourself involved with embedded Linux purely for the pleasure of it, such as for a hobby or college project, this approach might be a good one. However, plan to spend a significant amount of time assembling all the tools and utilities your project needs, and making sure they all interoperate together.</P>
<P class=docText>For starters, you will need a toolchain. <TT>Gcc</TT> and <TT>binutils</TT> are available from <A class=docLink href="http://www.fsf.org/" target=_blank>www.fsf.org</A> and other mirrors around the world. Both are required to compile the kernel and user-space applications for your project. These are distributed primarily in source code form, and you must compile the tools to suit your particular cross-development environment. Patches are often required to the most recent "stable" source trees of these utilities, especially when they will be used beyond the x86/IA32 architecture. The patches can usually be found at the same location as the base packages. The challenge is to discover which patch you need for your particular problem and/or architecture.