<H3 id=title-IDA0QC3D class=docSection1Title>2.3. Storage Considerations</H3>
<P class=docText>One of the most challenging aspects of embedded systems is that most embedded systems have limited physical resources. Although the Pentium 4 machine on your desktop might have 180GB of hard drive space, it is not uncommon to find embedded systems with a fraction of that amount. In many cases, the hard drive is typically replaced by smaller and less expensive nonvolatile storage devices. Hard drives are bulky, have rotating parts, are sensitive to physical shock, and require <A name=iddle1082></A><A name=iddle1201></A><A name=iddle1398></A><A name=iddle1411></A><A name=iddle1505></A><A name=iddle2160></A><A name=iddle2448></A>multiple power supply voltages, which makes them unsuitable for many embedded systems.</P><A name=ch02lev2sec7></A>
<H4 id=title-IDAQTC3D class=docSection2Title>2.3.1. Flash Memory</H4>
<P class=docText>Nearly everyone is familiar with CompactFlash modules<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fn5">[5]</A></SUP> used in a wide variety of consumer devices, such as digital cameras and PDAs (both great examples of embedded systems). These modules can be thought of as solid-state hard drives, capable of storing many megabytesand even gigabytesof data in a tiny footprint. They contain no moving parts, are relatively rugged, and operate on a single common power supply voltage.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn5>[5]</A></SUP> See <A class=docLink href="http://www.compactflash.org/" target=_blank>www.compactflash.org</A>.</P></BLOCKQUOTE>
<P class=docText>Several manufacturers of Flash memory exist. Flash memory comes in a variety of physical packages and capacities. It is not uncommon to see embedded systems with as little as 1MB or 2MB of nonvolatile storage. More typical storage requirements for embedded Linux systems range from 4MB to 256MB or more. An increasing number of embedded Linux systems have nonvolatile storage into the gigabyte range.</P>
<P class=docText>Flash memory can be written to and erased under software control. Although hard drive technology remains the fastest writable media, Flash writing and erasing speeds have improved considerably over the course of time, though flash write and erase time is still considerably slower. Some fundamental differences exist between hard drive and Flash memory technology that you must understand to properly use the technology.</P>
<P class=docText>Flash memory is divided into relatively large erasable units, referred to as erase blocks. One of the defining characteristics of Flash memory is the way in which data in Flash is written and erased. In a typical Flash memory chip, data can be changed from a binary 1 to a binary 0 under software control, 1 bit/word at a time, but to change a bit from a zero back to a one, an entire block must be erased. Blocks are often called erase blocks for this reason.</P>
<P class=docText>A typical Flash memory device contains many erase blocks. For example, a 4MB Flash chip might contain 64 erase blocks of 64KB each. Flash memory is also available with nonuniform erase block sizes, to facilitate flexible data-storage layout. These are commonly referred to as boot block or boot sector Flash chips. Often the bootloader is stored in the smaller blocks, and the kernel and other required data are stored in the larger blocks. <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fig03">Figure 2-3</A> illustrates the block size layout for a typical <SPAN class=docEmphasis>top boot</SPAN> Flash.</P><A name=ch02fig03></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 2-3. Boot block flash architecture</H5>
<P class=docText><IMG border=0 alt="" src="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/images/02elp03.jpg" width=350 height=333></P></CENTER>
<P></P><BR>
<P class=docText>To modify data stored in a Flash memory array, the block in which the modified data resides must be completely erased. Even if only 1 byte in a block needs to be changed, the entire block must be erased and rewritten.<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fn06">[6]</A></SUP> Flash block sizes are relatively large, compared to traditional hard-drive sector sizes. In comparison, a typical high-performance hard drive has writable sectors of 512 or 1024 bytes. The ramifications of this might be obvious: Write times for updating data in Flash memory can be many times that of a hard drive, due in part to the relatively large quantity of data that must be written back to the Flash for each update. These write cycles can take several seconds, in the worst case.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn06>[6]</A></SUP> Remember, you can change a 1 to a 0 a byte at a time, but you must erase the entire block to change any bit from a 0 back to a 1.</P></BLOCKQUOTE>
<P class=docText><A name=iddle1399></A><A name=iddle1506></A><A name=iddle2143></A><A name=iddle2449></A>Another limitation of Flash memory that must be considered is Flash memory cell write lifetime. A Flash memory cell has a limited number of write cycles before failure. Although the number of cycles is fairly large (100K cycles typical per block), it is easy to imagine a poorly designed Flash storage algorithm (or even a bug) that can quickly destroy Flash devices. It goes without saying that you should avoid configuring your system loggers to output to a Flash-based device.</P><A name=ch02lev2sec8></A>
<H4 id=title-IDAHXC3D class=docSection2Title>2.3.2. NAND Flash</H4>
<P class=docText>NAND Flash is a relatively new Flash technology. When NAND Flash hit the market, traditional Flash memory such as that described in the previous section was referred to as NOR Flash. These distinctions relate to the internal Flash memory cell architecture. NAND Flash devices improve upon some of the limitations of traditional (NOR) Flash by offering smaller block sizes, resulting in faster and more efficient writes and generally more efficient use of the Flash array.</P>
<P class=docText>NOR Flash devices interface to the microprocessor in a fashion similar to many microprocessor peripherals. That is, they have a parallel data and address bus that are connected directly<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fn07">[7]</A></SUP> to the microprocessor data/address bus. Each byte or word in the Flash array can be individually addressed in a random fashion. In contrast, NAND devices are accessed serially through a complex interface that varies among vendors. NAND devices present an operational model more similar to that of a traditional hard drive and associated controller. Data is accessed in serial bursts, which are far smaller than NOR Flash block size. Write cycle lifetime for NAND Flash is an order of magnitude greater than for NOR Flash, although erase times are significantly smaller.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn07>[7]</A></SUP> Directly in the logical sense. The actual circuitry may contain bus buffers or bridge devices, etc.</P></BLOCKQUOTE>
<P class=docText>In summary, NOR Flash can be directly accessed by the microprocessor, and code can even be executed directly out of NOR Flash (though, for performance reasons, this is rarely done, and then only on systems in which resources are extremely scarce). In fact, many processors cannot cache instruction accesses to Flash like they can with DRAM. This further impacts execution speed. In contrast, NAND Flash is more suitable for bulk storage in file system format than raw binary executable code and data storage.</P><A name=ch02lev2sec9></A>
<H4 id=title-IDADYC3D class=docSection2Title>2.3.3. Flash Usage</H4>
<P class=docText><A name=iddle1507></A>An embedded system designer has many options in the layout and use of Flash memory. In the simplest of systems, in which resources are not overly constrained, raw binary data (perhaps compressed) can be stored on the Flash device. When booted, a file system image stored in Flash is read into a Linux ramdisk block device, mounted as a file system and accessed only from RAM. This is often a good design choice when the data in Flash rarely needs to be updated, and any data that does need to be updated is relatively small compared to the size of the ramdisk. It is important to realize that any changes to files in the ramdisk are lost upon reboot or power cycle.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fig04">Figure 2-4</A> illustrates a common Flash memory organization that is typical of a simple embedded system in which nonvolatile storage requirements of dynamic data are small and infrequent.</P><A name=ch02fig04></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 2-4. Example Flash memory layout</H5>
<P class=docText><IMG border=0 alt="" src="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/images/02elp04.jpg" width=300 height=282></P></CENTER>
<P></P><BR>
<P class=docText>The bootloader is often placed in the top or bottom of the Flash memory array. Following the bootloader, space is allocated for the Linux kernel image and the ramdisk file system image,<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fn08">[8]</A></SUP> which holds the root file system. Typically, the Linux kernel and ramdisk file system images are compressed, and the bootloader handles the decompression task during the boot cycle.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn08>[8]</A></SUP> We discuss ramdisk file systems in much detail in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch09.html#ch09">Chapter 9</A>, "File Systems."</P></BLOCKQUOTE>
<P class=docText><A name=iddle1397></A><A name=iddle1453></A><A name=iddle1503></A><A name=iddle1690></A><A name=iddle1702></A><A name=iddle1709></A><A name=iddle2447></A><A name=iddle2626></A>For dynamic data that needs to be saved between reboots and power cycles, another small area of Flash can be dedicated, or another type of nonvolatile storage<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fn09">[9]</A></SUP> can be used. This is a typical configuration for embedded systems with requirements to store configuration data, as might be found in a wireless access point aimed at the consumer market, for example.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn09>[9]</A></SUP> Real-time clock modules often contain small amounts of nonvolatile storage, and Serial EEPROMs are another common choice for nonvolatile storage of small amounts of data.</P></BLOCKQUOTE><A name=ch02lev2sec10></A>
<H4 id=title-IDAH3C3D class=docSection2Title>2.3.4. Flash File Systems</H4>
<P class=docText>The limitations of the simple Flash layout scheme described in the previous paragraphs can be overcome by using a Flash file system to manage data on the Flash device in a manner similar to how data is organized on a hard drive. Early implementations of file systems for Flash devices consisted of a simple block device layer that emulated the 512-byte sector layout of a common hard drive. These simple emulation layers allowed access to data in file format rather than unformatted bulk storage, but they had some performance limitations.</P>
<P class=docText>One of the first enhancements to Flash file systems was the incorporation of wear leveling. As discussed earlier, Flash blocks are subject to a finite write lifetime. Wear-leveling algorithms are used to distribute writes evenly over the physical erase blocks of the Flash memory.</P>
<P class=docText>Another limitation that arises from the Flash architecture is the risk of data loss during a power failure or premature shutdown. Consider that the Flash block sizes are relatively large and that average file sizes being written are often much smaller relative to the block size. You learned previously that Flash blocks must be written one block at a time. Therefore, to write a small 8KB file, you must erase and rewrite an entire Flash block, perhaps 64KB or 128KB in size; in the worst case, this can take tens of seconds to complete. This opens a significant window of risk of data loss due to power failure.</P>
<P class=docText>One of the more popular Flash file systems in use today is JFFS2, or Journaling Flash File System 2. It has several important features aimed at improving overall performance, increasing Flash lifetime, and reducing the risk of data loss in case of power failure. The more significant improvements in the latest JFFS2 file system include improved wear leveling, compression and decompression to squeeze more data into a given Flash size, and support for Linux hard links. We cover this in detail in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch09.html#ch09">Chapter 9</A>, "File Systems," and again in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch10.html#ch10">Chapter 10</A>, "MTD Subsystem," when we discuss the Memory Technology Device (MTD) subsystem.</P><A name=ch02lev2sec11></A>
<H4 id=title-IDAL4C3D class=docSection2Title>2.3.5. Memory Space</H4>
<P class=docText><A name=iddle1022></A><A name=iddle1395></A><A name=iddle2079></A><A name=iddle2445></A>Virtually all legacy embedded operating systems view and manage system memory as a single large, flat address space. That is, a microprocessor's address space exists from 0 to the top of its physical address range. For example, if a microprocessor had 24 physical address lines, its top of memory would be 16MB. Therefore, its hexadecimal address would range from <TT>0x00000000</TT> to <TT>0x00ffffff</TT>. Hardware designs commonly place DRAM starting at the bottom of the range, and Flash memory from the top down. Unused address ranges between the top of DRAM and bottom of FLASH would be allocated for addressing of various peripheral chips on the board. This design approach is often dictated by the choice of microprocessor. <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fig05">Figure 2-5</A> is an example of a typical memory layout for a simple embedded system.</P><A name=ch02fig05></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 2-5. Typical embedded system memory map</H5>
<P class=docText><IMG border=0 alt="" src="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/images/02elp05.jpg" width=400 height=326></P></CENTER>
<P></P><BR>
<P class=docText>In traditional embedded systems based on legacy operating systems, the OS and all the tasks<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fn10">[10]</A></SUP> had equal access rights to all resources in the system. A bug in one process could wipe out memory contents anywhere in the system, whether it belonged to itself, the OS, another task, or even a hardware register somewhere in <A name=iddle1018></A><A name=iddle1233></A><A name=iddle1396></A><A name=iddle1416></A><A name=iddle2076></A><A name=iddle2081></A><A name=iddle2097></A><A name=iddle2446></A><A name=iddle2614></A><A name=iddle2615></A>the address space. Although this approach had simplicity as its most valuable characteristic, it led to bugs that could be difficult to diagnose.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn10>[10]</A></SUP> In this discussion, the word <SPAN class=docEmphasis>task</SPAN> is used to denote any thread of execution, regardless of the mechanism used to spawn, manage, or schedule it.</P></BLOCKQUOTE>
<P class=docText>High-performance microprocessors contain complex hardware engines called Memory Management Units (MMUs) whose purpose is to enable an operating system to exercise a high degree of management and control over its address space and the address space it allocates to processes. This control comes in two primary forms: access rights and memory translation. Access rights allow an operating system to assign specific memory-access privileges to specific tasks. Memory translation allows an operating system to virtualize its address space, which has many benefits.</P>
<P class=docText>The Linux kernel takes advantage of these hardware MMUs to create a <SPAN class=docEmphasis>virtual memory</SPAN> operating system. One of the biggest benefits of virtual memory is that it can make more efficient use of physical memory by presenting the appearance that the system has more memory than is physically present. The other benefit is that the kernel can enforce access rights to each range of system memory that it allocates to a task or process, to prevent one process from errantly accessing memory or other resources that belong to another process or to the kernel itself.</P>
<P class=docText>Let's look at some details of how this works. A tutorial on the complexities of virtual memory systems is beyond the scope of this book.<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fn11">[11]</A></SUP> Instead, we examine the ramifications of a virtual memory system as it appears to an embedded systems developer.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn11>[11]</A></SUP> Many good books cover the details of virtual memory systems. See <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec5.html#ch02lev2sec17">Section 2.5.1</A>, "Suggestions for Additional Reading," at the end of this chapter, for recommendations.</P></BLOCKQUOTE><A name=ch02lev2sec12></A>
<H4 id=title-IDAKFD3D class=docSection2Title>2.3.6. Execution Contexts</H4>
<P class=docText>One of the very first chores that Linux performs when it begins to run is to configure the hardware memory management unit (MMU) on the processor and the data structures used to support it, and to enable address translation. When this step is complete, the kernel runs in its own virtual memory space. The virtual kernel address selected by the kernel developers in recent versions defaults to 0xC0000000. In most architectures, this is a configurable parameter.<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fn12">[12]</A></SUP> If we were to look at the kernel's symbol table, we would find kernel symbols linked at an address starting with 0xC0xxxxxx. As a result, any time the kernel is executing code in kernel space, the instruction pointer of the processor will contain values in this range.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn12>[12]</A></SUP> However, there is seldom a good reason to change it.</P></BLOCKQUOTE>
<P class=docText>In Linux, we refer to two distinctly separate operational contexts, based on the environment in which a given thread<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fn13">[13]</A></SUP> is executing. Threads executing entirely <A name=iddle1789></A><A name=iddle2569></A>within the kernel are said to be operating in <SPAN class=docEmphasis>kernel context,</SPAN> while application programs are said to operate in <SPAN class=docEmphasis>user space context</SPAN>. A user space process can access only memory it owns, and uses kernel system calls to access privileged resources such as file and device I/O. An example might make this more clear.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn13>[13]</A></SUP> The term thread here is used in the generic sense to indicate any sequential flow of instructions.</P></BLOCKQUOTE>
<P class=docText>Consider an application that opens a file and issues a read request (see <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fig06">Figure 2-6</A>). The read function call begins in user space, in the C library <TT>read()</TT> function. The C library then issues a read request to the kernel. The read request results in a context switch from the user's program to the kernel, to service the request for the file's data. Inside the kernel, the read request results in a hard-drive access requesting the sectors containing the file's data.</P><A name=ch02fig06></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 2-6. Simple file read request</H5>
<P class=docText><IMG border=0 alt="" src="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/images/02elp06.jpg" width=350 height=333></P></CENTER>
<P></P><BR>
<P class=docText>Usually the hard-drive read is issued asynchronously to the hardware itself. That is, the request is posted to the hardware, and when the data is ready, the hardware interrupts the processor. The application program waiting for the data <A name=iddle1400></A><A name=iddle1681></A><A name=iddle1686></A><A name=iddle2254></A><A name=iddle2255></A><A name=iddle2450></A><A name=iddle2616></A>is <SPAN class=docEmphasis>blocked</SPAN> on a wait queue until the data is available. Later, when the hard disk has the data ready, it posts a hardware interrupt. (This description is intentionally simplified for the purposes of this illustration.) When the kernel receives the hardware interrupt, it suspends whatever process was executing and proceeds to read the waiting data from the drive. This is an example of a thread of execution operating in kernel context.</P>
<P class=docText>To summarize this discussion, we have identified two general execution contexts, user space and kernel space. When an application program executes a system call that results in a context switch and enters the kernel, it is executing kernel code on behalf of a process. You will often hear this referred to as <SPAN class=docEmphasis>process context</SPAN> within the kernel. In contrast, the interrupt service routine (ISR) handling the IDE drive (or any other ISR, for that matter) is kernel code that is not executing on behalf of any particular process. Several limitations exist in this operational context, including the limitation that the ISR cannot block (sleep) or call any kernel functions that might result in blocking. For further reading on these concepts, consult <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec5.html#ch02lev2sec17">Section 2.5.1</A>, "Suggestions for Additional Reading," at the end of this chapter.</P><A name=ch02lev2sec13></A>
<H4 id=title-IDAUKD3D class=docSection2Title>2.3.7. Process Virtual Memory</H4>
<P class=docText>When a process is spawnedfor example, when the user types <TT>ls</TT> at the Linux command promptthe kernel allocates memory for the process and assigns a range of virtual-memory addresses to the process. The resulting address values bear no fixed relationship to those in the kernel, nor to any other running process. Furthermore, there is no direct correlation between the physical memory addresses on the board and the virtual memory as seen by the process. In fact, it is not uncommon for a process to occupy multiple different physical addresses in main memory during its lifetime as a result of paging and swapping.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02list04">Listing 2-4</A> is the venerable "Hello World," as modified to illustrate the previous concepts. The goal with this example is to illustrate the address space that the kernel assigns to the process. This code was compiled and run on the AMCC Yosemite board, described earlier in this chapter. The board contains 256MB of DRAM memory.</P>
<P class=docText></P><A name=ch02list04></A>
<H5 id=title-IDAPLD3D class=docExampleTitle>Listing 2-4. Hello World, Embedded Style</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
<TBODY>
<TR>
<TD><PRE>#include &lt;stdio.h&gt;

int bss_var;        /* Uninitialized global variable */

int data_var = 1;   /* Initialized global variable */

int main(int argc, char **argv)
{
  void *stack_var;            /* Local variable on the stack */

  stack_var = (void *)main;   /* Don't let the compiler */
                              /* optimize it out */

  printf("Hello, World! Main is executing at %p\n", stack_var);
  printf("This address (%p) is in our stack frame\n", &amp;stack_var);

  /* bss section contains uninitialized data */
  printf("This address (%p) is in our bss section\n", &amp;bss_var);

  /* data section contains initializated data */
  printf("This address (%p) is in our data section\n", &amp;data_var);

  return 0;
}</PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText><A name=iddle1922></A><A name=iddle1923></A><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02list05">Listing 2-5</A> shows the console output that this program produces. Notice that the process called <TT>hello</TT> thinks it is executing somewhere in high RAM just <SPAN class=docEmphasis>above</SPAN> the 256MB boundary (0x10000418). Notice also that the stack address is roughly halfway into a 32-bit address space, well beyond our 256MB of RAM (0x7ff8ebb0). How can this be? DRAM is usually contiguous in systems like these. To the casual observer, it appears that we have nearly 2GB of DRAM available for our use. These <SPAN class=docEmphasis>virtual addresses</SPAN> were assigned by the kernel and are backed by physical RAM somewhere within the 256MB range of available memory on the Yosemite board.</P><A name=ch02list05></A>
<H5 id=title-IDADND3D class=docExampleTitle>Listing 2-5. Hello Output</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
<TBODY>
<TR>
<TD><PRE>root@amcc:~# <SPAN class=docEmphStrong>./hello</SPAN>
Hello, World! Main is executing at 0x10000418
This address (0x7ff8ebb0) is in our stack frame
This address (0x10010a1c) is in our bss section
This address (0x10010a18) is in our data section
root@amcc:~#</PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText><A name=iddle1203></A><A name=iddle1256></A><A name=iddle1387></A><A name=iddle1606></A><A name=iddle2144></A><A name=iddle2464></A>One of the characteristics of a virtual memory system is that when available physical RAM goes below a designated threshold, the kernel can swap memory pages out to a bulk storage medium, usually a hard disk drive. The kernel examines its active memory regions, determines which areas in memory have been least recently used, and swaps these memory regions out to disk, to free them up for the current process. Developers of embedded systems often disable swapping on embedded systems because of performance or resource constraints. For example, it would be ridiculous in most cases to use a relatively slow Flash memory device with limited write life cycles as a swap device. Without a swap device, you must carefully design your applications to exist within the limitations of your available physical memory.</P><A name=ch02lev2sec14></A>
<H4 id=title-IDANPD3D class=docSection2Title>2.3.8. Cross-Development Environment</H4>
<P class=docText>Before we can develop applications and device drivers for an embedded system, we need a set of tools (compiler, utilities, and so on) that will generate binary executables in the proper format for the target system. Consider a simple application written on your desktop PC, such as the traditional "Hello World" example. After you have created the source code on your desktop, you invoke the compiler that came with your desktop system (or that you purchased and installed) to generate a binary executable image. That image file is properly formatted to execute on the machine on which it was compiled. This is referred to as <SPAN class=docEmphasis>native</SPAN> compilation. That is, using compilers on your desktop system, you generate code that will execute on that desktop system.</P>
<P class=docText>Note that <SPAN class=docEmphasis>native</SPAN> does not imply an architecture. Indeed, if you have a toolchain that runs on your target board, you can natively compile applications for your target's architecture. In fact, one great way to test a new kernel and custom board is to repeatedly compile the Linux kernel on it.</P>
<P class=docText>Developing software in a cross-development environment requires that the compiler running on your development host output a binary executable that is incompatible with the desktop development workstation on which it was compiled. The primary reason these tools exist is that it is often impractical or impossible to develop and compile software natively on the embedded system because of resource (typically memory and CPU horsepower) constraints.</P>
<P class=docText>Numerous hidden traps to this approach often catch the unwary newcomer to embedded development. When a given program is compiled, the compiler often knows how to find include files, and where to find libraries that might be required for the compilation to succeed. To illustrate these concepts, let's look again at the "Hello World" program. The example reproduced in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02list04">Listing 2-4</A> above was compiled with the following command line:</P><PRE>gcc -Wall -o hello hello.c</PRE><BR>
<P class=docText>From <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02list04">Listing 2-4</A>, we see an include the file <TT>stdio.h</TT>. This file does not reside in the same directory as the <TT>hello.c</TT> file specified on the <TT>gcc</TT> command line. So how does the compiler find them? Also, the <TT>printf()</TT> function is not defined in the file <TT>hello.c</TT>. Therefore, when <TT>hello.c</TT> is compiled, it will contain an unresolved reference for this symbol. How does the linker resolve this reference at link time?</P>
<P class=docText>Compilers have built-in defaults for locating include files. When the reference to the include file is encountered, the compiler searches its default list of locations to locate the file. A similar process exists for the linker to resolve the reference to the external symbol <TT>printf()</TT>. The linker knows by default to search the C library (<TT>libc-*</TT>) for unresolved references. Again, this default behavior is built into the toolchain.</P>
<P class=docText>Now consider that you are building an application targeting a PowerPC embedded system. Obviously, you will need a cross-compiler to generate binary executables compatible with the PowerPC processor architecture. If you issue a similar compilation command using your cross-compiler to compile the <TT>hello.c</TT> example above, it is possible that your binary executable could end up being accidentally linked with an x86 version of the C library on your development system, attempting to resolve the reference to <TT>printf()</TT>. Of course, the results of running this bogus hybrid executable, containing a mix of PowerPC and x86 binary instructions<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02lev1sec3.html#ch02fn14">[14]</A></SUP> are predictable: crash!</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch02fn14>[14]</A></SUP> In fact, it wouldn't even compile or link, much less run.</P></BLOCKQUOTE>
<P class=docText>The solution to this predicament is to instruct the cross-compiler to look in nonstandard locations to pick up the header files and target specific libraries. We cover this topic in much more detail in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch12.html#ch12">Chapter 12</A>, "Embedded Development Environment." The intent of this example was to illustrate the differences between a native development environment, and a development environment targeted at cross-compilation for embedded systems. This is but one of the complexities of a cross-development environment. The same issue and solutions apply to cross-debugging, as you will see starting in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch14.html#ch14">Chapter 14</A>, "Kernel Debugging Techniques." A proper cross-development environment is crucial to <A name=iddle1028></A><A name=iddle1173></A><A name=iddle1355></A><A name=iddle1381></A><A name=iddle1487></A><A name=iddle1551></A><A name=iddle1647></A><A name=iddle1826></A><A name=iddle2117></A><A name=iddle2176></A><A name=iddle2384></A><A name=iddle2514></A>your success and involves much more than just compilers, as we shall soon see in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch12.html#ch12">Chapter 12</A>, "Embedded Development Environment."