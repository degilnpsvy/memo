<H3 id=-100000 class=docSection1Title>ACPI</H3>
<P class=docText><A name=iddle1026></A><A name=iddle1028></A><A name=iddle1029></A><A name=iddle1030></A><A name=iddle1032></A><A name=iddle1106></A><A name=iddle1777></A><A name=iddle1778></A><A name=iddle3889></A><A name=iddle4032></A><A name=iddle4107></A><A name=iddle4204></A><A name=iddle4206></A><SPAN class=docEmphasis><A name="Advanced Configuration"></A>Advanced Configuration and Power Interface</SPAN><A name="specification that"></A> (ACPI) is a power-management specification that replaces earlier standards such as <SPAN class=docEmphasis>Advanced Power Management</SPAN><A name="transitioning the"></A> (APM). ACPI is responsible for transitioning the system between power states. It also has the task of interfacing with devices and sensors connected to the EC. Such devices are called <SPAN class=docEmphasis>ACPI devices</SPAN><A name="to handle"></A>, and memory devoted to handle them is called <SPAN class=docEmphasis>ACPI space</SPAN>.</P>
<P class=docText><A name="place to"></A>As you saw elsewhere in this book, low-level code is not the place to implement policy. This was the main problem with APM, where most of the power-management policies were part of BIOS firmware. ACPI shifts policy one level up, to the operating system. Using a daemon called <SPAN class=docEmphasis>acpid</SPAN><A name="to be"></A>, ACPI even allows policy to be pushed one more level up, to user-space configuration files. By adding rules to an <SPAN class=docEmphasis>acpid</SPAN><A name="when a"></A> configuration file, you can decide what to do when a hotkey is pressed or when a thermal trip occurs.</P>
<P class=docText><A name="the responsibility"></A>Even with ACPI, low-level BIOS firmware retains the responsibility of interfacing with hardware and detecting ACPI events such as a power button press or a thermal sensor report. To perform this, the BIOS utilizes a special x86 execution mode triggered via <SPAN class=docEmphasis>system management interrupts</SPAN><A name="operating system"></A> (SMIs). The SMI execution mode is transparent to the operating system. To notify the operating system about ACPI events detected in SMI mode, the BIOS asserts a <SPAN class=docEmphasis>system control interrupt</SPAN> (SCI). Look at <SPAN class=docEmphasis>drivers/acpi/osl.c</SPAN><A name="the SCI"></A> for the Linux ACPI code that requests the SCI IRQ.</P>
<P class=docText><A name="Linux ACPI"></A>Linux ACPI components include the following:</P>
<DIV style="FONT-WEIGHT: bold">
<OL class=docList type=1>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="layer that"></A>A core layer that provides ACPI essentials such as the <SPAN class=docEmphasis>ACPI Machine Language</SPAN><A name="in AML"></A> (AML) interpreter. ACPI-specific BIOS code is written in AML, a language that runs on a virtual machine implemented by the operating system's AML interpreter.</P></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="interfacing with"></A>ACPI drivers for interfacing with standard components such as the EC (<SPAN class=docEmphasis>drivers/acpi/ec.c</SPAN>), buttons (<SPAN class=docEmphasis>drivers/acpi/button.c</SPAN>), and fan (<SPAN class=docEmphasis>drivers/acpi/fan.c</SPAN><A name="ACPI drivers"></A>). OEM-specific drivers offer support for features not supported by the standard ACPI drivers. For example, <SPAN class=docEmphasis>drivers/misc/thinkpad_acpi.c</SPAN><SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch20lev1sec4.html#ch20fn01">[1]</A></SUP><A name="implements extras"></A> is the OEM-specific driver that implements extras for IBM/Lenovo Thinkpads. On an IBM/Lenovo Thinkpad, the files under <SPAN class=docEmphasis>/proc/acpi/</SPAN> are generated by the standard ACPI drivers, <A name=iddle1027></A><A name=iddle1031></A><A name=iddle1033></A><A name=iddle1034></A><A name=iddle1035></A><A name=iddle1648></A><A name=iddle2512></A><A name=iddle2596></A><A name=iddle2624></A><A name=iddle3816></A><A name=iddle4177></A>whereas those in <SPAN class=docEmphasis>/proc/acpi/ibm/</SPAN><A name="current temperature"></A> are produced by the OEM-specific driver. So, to get the current temperature, do this:</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch20fn01>[1]</A></SUP><A name="to be"></A> Prior to 2.6.22, this driver used to be <SPAN class=docEmphasis>drivers/acpi/ibm_acpi.c</SPAN>.</P></BLOCKQUOTE>
<DIV class=docText><PRE><SPAN class=docEmphStrong>bash&gt; cat /proc/acpi/thermal_zone/THM0/temperature</SPAN>
temperature:       39 C</PRE></DIV>
<P class=docList><A name="of the"></A>But to turn on the nightlight on top of the LCD display, get help from the OEM-specific driver:</P>
<DIV class=docText><PRE><SPAN class=docEmphStrong>bash&gt; echo on &gt; /proc/acpi/ibm/light</SPAN></PRE></DIV></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList>A kernel thread <SPAN class=docEmphasis>kacpid</SPAN> that ACPI uses to queue work for execution.</P></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="respond to"></A>Individual device drivers that use ACPI's services to respond to transitions in the system's power state. To achieve this, drivers register <TT>suspend()</TT><A name=and></A> and <TT>resume()</TT><A name="the kernel"></A> methods with the kernel's device model. We alluded to these methods while discussing the <TT>platform_driver</TT> structure in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch06.html#ch06">Chapter 6</A>, "Serial Drivers," the <TT>spi_driver</TT> structure in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch08.html#ch08">Chapter 8</A>, "The Inter-Integrated Circuit Protocol," the <TT>pcmcia_driver</TT> structure in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch09.html#ch09">Chapter 9</A>, "PCMCIA and Compact Flash," and the <TT>pci_driver</TT> structure in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch10.html#ch10">Chapter 10</A>.</P></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList>User-space tools such as <SPAN class=docEmphasis>acpitool</SPAN><A name="of various"></A>, which report the state of various ACPI devices, show thermal zone information and suspend the system to different sleep states:</P>
<DIV class=docText><PRE><SPAN class=docEmphStrong>bash&gt; acpitool</SPAN>
Battery #1     : charging, 69.08%, 01:14:02
AC adapter     : on-line
Thermal zone 1 : ok, 38 C</PRE></DIV></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList>The <SPAN class=docEmphasis>acpid</SPAN><A name="policy enabler"></A> daemon, which is the policy enabler for ACPI events. It listens on <SPAN class=docEmphasis>/proc/acpi/events</SPAN><A name="button or"></A> for power-management events reported by the kernel. When you press the power button or when a thermal trip occurs, the kernel ACPI driver dispatches an event to user space via <SPAN class=docEmphasis>/proc/acpi/events.</SPAN><A name="through configuration"></A> Acpid reads this, passes it through configuration scripts present in <SPAN class=docEmphasis>/etc/acpi/events/</SPAN><A name="to execute"></A> and takes specified actions. Assume that you want to execute a specific program (<SPAN class=docEmphasis>/bin/lidhandler</SPAN><A name="For this"></A>) when your laptop's lid button is pressed. For this, add the following to <SPAN class=docEmphasis>/etc/acpi/events/acpi_handler.sh</SPAN>:</P>
<DIV class=docText><PRE>event=button/lid.*
action=/bin/lidhandler</PRE></DIV>
<P class=docList><A name=iddle2329></A><A name=iddle2492></A><A name="for example"></A>You may use cpufreq in tandem with ACPI. You can, for example, add this line inside <SPAN class=docEmphasis>/bin/lidhandler</SPAN><A name="you shut"></A> to drop down the processor frequency when you shut your laptop's lid:</P>
<DIV class=docText><PRE>echo powersave &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</PRE></DIV></DIV></LI></OL></DIV>
<P class=docText><A name="You can"></A>You can download the ACPI specifications from <A class=docLink href="http://www.acpi.info/" target=_blank>www.acpi.info</A>.</P>
<P class=docText><A name="consider that"></A>As an exercise, consider that you have a telemetry card<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch20lev1sec4.html#ch20fn02">[2]</A></SUP><A name="embedded laptop"></A> built in to an embedded laptop derivative, and that the EC is connected to a sensor that measures telemetry strength. To access telemetry strength via <SPAN class=docEmphasis>/proc/acpi/</SPAN> (or <SPAN class=docEmphasis>/sys/bus/acpi/</SPAN><A name="laptop model"></A>), update the corresponding laptop model's "extras" driver present in <SPAN class=docEmphasis>drivers/misc/.</SPAN> If your board is a derivative of an IBM/Lenovo Thinkpad, for example, modify <SPAN class=docEmphasis>drivers/misc/thinkpad_acpi.c</SPAN> accordingly. You may use the <TT>ec_read()</TT> and <TT>ec_write()</TT><A name="in the"></A> kernel functions to access the location that stores telemetry strength in the EC's ACPI space.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch20fn02>[2]</A></SUP><A name="for an"></A> We developed a driver for an example telemetry card in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch11.html#ch11">Chapter 11</A>, "<A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch11.html#ch11">Universal Serial Bus</A>."</P></BLOCKQUOTE>