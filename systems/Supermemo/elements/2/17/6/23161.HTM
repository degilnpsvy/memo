<H3 id=-100000 class=docSection1Title>ECC Reporting</H3>
<P class=docText><A name="contain special"></A>Several memory controllers contain special silicon to measure the fidelity of stored data using <SPAN class=docEmphasis>error correcting codes</SPAN> (ECCs). The <SPAN class=docEmphasis>Error Detection And Correction</SPAN><A name="memory controllers"></A> (EDAC) driver subsystem announces occurrences of memory error events generated by ECC-aware memory controllers. Typical ECC DRAM chips have the capability to correct <SPAN class=docEmphasis>single-bit errors</SPAN> (SBEs) and detect <SPAN class=docEmphasis>multibit errors</SPAN><A name="errors are"></A> (MBEs). In EDAC parlance, the former errors are <SPAN class=docEmphasis>correctable errors</SPAN> (CEs), whereas the latter are <SPAN class=docEmphasis>uncorrectable errors</SPAN> (UEs).</P>
<P class=docText><A name="This means"></A>ECC operations are transparent to the operating system. This means that if your DRAM controller supports ECC, error correction and detection occurs silently without operating system participation. EDAC's task is to report such events and allow users to fashion error handling policies (such as replace a suspect DRAM chip).</P>
<P class=docText><A name="of the"></A>The EDAC driver subsystem consists of the following:</P>
<UL>
<LI>
<P class=docList>A core module called <SPAN class=docEmphasis>edac_mc</SPAN> that provides a set of library routines.</P></LI>
<LI>
<P class=docList><A name="the driver"></A>Separate drivers for interacting with supported memory controllers. For example, the driver module that works with the memory controller that is part of the Intel 82860 North Bridge is called <SPAN class=docEmphasis>i82860_edac</SPAN>.</P></LI></UL>
<P class=docText><A name="sysfs directory"></A>EDAC reports errors via files in the sysfs directory, <SPAN class=docEmphasis>/sys/devices/system/edac/.</SPAN><A name="It also"></A> It also generates messages that can be gleaned from the kernel error log.</P>
<P class=docText><A name="of DRAM"></A>The layout of DRAM chips is specified in terms of the number of chip-selects emanating from the memory controller and the data-transfer width (channels) between the memory controller and the CPU. The number of rows in the DRAM chip array depends on the former, whereas the number of columns hinge on the latter. One of the main aims of EDAC is to point the needle of suspicion at problem DRAM chips, so the EDAC sysfs node structure is designed according to <A name=iddle1007></A><A name=iddle1604></A><A name=iddle1605></A><A name=iddle1852></A><A name=iddle1870></A><A name=iddle1871></A><A name=iddle1882></A><A name=iddle1883></A><A name=iddle2315></A>the physical chip layout: <SPAN class=docEmphasis>/sys/devices/system/edac/mc/mcX/csrowY/</SPAN><A name="in memory"></A> corresponds to chip-select row Y in memory controller X. Each such directory contains details such as the number of detected CEs (<TT>ce_count</TT>), UEs (<TT>ue_count</TT>), channel location, and other attributes.</P><A name=ch20lev2sec1></A>
<H4 id=title-ID0EFGBO class=docSection2Title>Device Example: ECC-Aware Memory Controller</H4>
<P class=docText><A name="for a"></A>Let's add EDAC support for a yet-unsupported memory controller. Assume that you're putting Linux onto a medical grade device that is an embedded x86 derivative. The North Bridge chipset (which includes the memory controller as discussed in the sidebar "<A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch12lev1sec1.html#ch12sb02">The North Bridge</A>" in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch12.html#ch12">Chapter 12</A><A name="ECC reporting"></A>, "Video Drivers") on your board is the Intel 855GME that is capable of ECC reporting. All DRAM banks connected to the 855GME on this system are ECC-enabled chips because this is a life-critical device. EDAC does not yet support the 855GME, so let's take a stab at implementing it.</P>
<P class=docText><A name="two major"></A>ECC DRAM controllers have two major ECC-related registers: an error status register and an error address pointer register, as shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch20.html#ch20tab01">Table 20.1</A><A name="the status"></A>. When an ECC error occurs, the former contains the status (whether the error is an SBE or an MBE), whereas the latter contains the physical address where the error occurred. The EDAC core periodically checks these registers and reports results to user space via sysfs. From a configuration standpoint, all devices inside the 855GME appear to be on PCIbus 0. The DRAM controller resides on device 0 of this bus. DRAM interface control registers (including the ECC-specific registers) map into the corresponding PCI configuration space. To add EDAC support for the 855GME, add hooks to read these registers, as shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch20.html#ch20ex01">Listing 20.1</A>. Refer back to <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch10.html#ch10">Chapter 10</A><A name="device driver"></A>, "Peripheral Component Interconnect," for explanations on PCI device driver methods and data structures.</P><A name=ch20tab01></A>
<P>
<TABLE cellSpacing=0 cellPadding=5 rules=none frame=hsides>
<CAPTION>
<H5 class=docTableTitle>Table 20.1. ECC-Related Registers on the DRAM Controller</H5></CAPTION>
<COLGROUP span=2 align=left>
<COL width=250>
<COL width=250></COLGROUP>
<THEAD></THEAD>
<TBODY>
<TR>
<TD class="docTableCell bottomBorder" vAlign=top align=left>ECC-Specific Registers Residing in the DRAM Controller's PCI Configuration Space</TD>
<TD class="docTableCell bottomBorder" vAlign=bottom align=left>Description</TD></TR>
<TR>
<TD class=docTableCell vAlign=top align=left><TT>I855_ERRSTS_REGISTER</TT></TD>
<TD class=docTableCell vAlign=top align=left><A name="ECC error"></A>The error status register, which signals occurrence of an ECC error. Shows whether the error is an SBE or an MBE.</TD></TR>
<TR>
<TD class=docTableCell vAlign=top align=left><TT>I855_EAP_REGISTER</TT></TD>
<TD class=docTableCell vAlign=top align=left><A name="physical address"></A>The error address pointer register, which contains the physical address where the most recent ECC error occurred.</TD></TR></TBODY></TABLE></P><BR>
<P class=docText></P><A name=ch20ex01></A>
<H5 id=title-ID0E1JBO class=docExampleTitle>Listing 20.1. An EDAC Driver for the 855GME</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 border=1>
<TBODY>
<TR>
<TD>
<DIV class=codeSegmentsExpansionLinks><A name="Code View"></A>Code View:</DIV><PRE>/* Based on drivers/edac/i82860_edac.c */

#define I855_PCI_DEVICE_ID   0x3584 /* PCI Device ID of the memory
                                       controller in the 855 GME */
#define I855_ERRSTS_REGISTER 0x62   /* Error Status Register's offset
                                       in the PCI configuration space */
#define I855_EAP_REGISTER    0x98   /* Error Address Pointer Register's
                                       offset in the PCI configuration space */
struct i855_error_info {
  u16 errsts;  /* Error Type */
  u32 eap;     /* Error Location */
};

/* Get error information */
static void
i855_get_error_info(struct mem_ctl_info *mci,
                    struct i855_error_info *info)
{
  struct pci_dev *pdev;

  pdev = to_pci_dev(mci-&gt;dev);
  /* Read error type */
  pci_read_config_word(pdev, I855_ERRSTS_REGISTER, &amp;info-&gt;errsts);
  /* Read error location */
  pci_read_config_dword(pdev, I855_EAP_REGISTER, &amp;info-&gt;eap);
}

/* Process errors */
static int
i855_process_error_info(struct mem_ctl_info *mci,
                        struct i855_error_info *info,
                        int handle_errors)
{
  int row;

  info-&gt;eap &gt;&gt;= PAGE_SHIFT;
  row = edac_mc_find_csrow_by_page(mci, info-&gt;eap); /* Find culprit row */

  /* Handle using services provided by the EDAC core.
     Populate sysfs, generate error messages, and so on */
  if (is_MBE()) {          /* is_MBE() looks at I855_ERRSTS_REGISTER and checks
                              for an MBE. Implementation not shown */
    edac_mc_handle_ue(mci, info-&gt;eap, 0, row, "i855 UE");
  } else if (is_SBE()) {   /* is_SBE() looks at I855_ERRSTS_REGISTER and checks
                              for an SBE. Implementation not shown */
    edac_mc_handle_ce(mci, info-&gt;eap, 0, info-&gt;derrsyn, row, 0,
                      "i855 CE");
  }

  return 1;
}

/* This method is registered with the EDAC core from i855_probe() */
static void
i855_check(struct mem_ctl_info *mci)
{
  struct i855_error_info info;

  i855_get_error_info(mci, &amp;info);
  i855_process_error_info(mci, &amp;info, 1);
}

/* The PCI driver probe method, part of the pci_driver structure */
static int
i855_probe(struct pci_dev *pdev, int dev_idx)
{
  struct mem_ctl_info *mci;

  /* ... */
  pci_enable_device(pdev);

  /* Allocate control memory for this memory controller.
     The 3 arguments to edac_mc_alloc() correspond to the
     amount of requested private storage, number of chip-select
     rows, and number of channels in your memory layout */
  mci = edac_mc_alloc(0, CSROWS, CHANNELS);
  /* ... */
  mci-&gt;edac_check = i855_check; /* Supply the check method to the
                                   EDAC core */
  /* Do other memory controller initializations */
  /* ... */
  /* Register this memory controller with the EDAC core */
  edac_mc_add_mc(mci, 0);
  /* ... */
}

/* Remove method */
static void __devexit
i855_remove(struct pci_dev *pdev)
{
  struct mem_ctl_info *mci = edac_mc_find_mci_by_pdev(pdev);
  if (mci &amp;&amp; !edac_mc_del_mc(mci)) {
    edac_mc_free(mci); /* Free memory for this controller. Reverse
                          of edac_mc_alloc() */
  }
}

/* PCI Device ID Table */
static const struct pci_device_id i855_pci_tbl[] __devinitdata = {
  {PCI_VEND_DEV(INTEL, I855_PCI_DEVICE_ID),
   PCI_ANY_ID, PCI_ANY_ID, 0, 0,},
  {0,},
};

MODULE_DEVICE_TABLE(pci, i855_pci_tbl);

/* pci_driver structure for this device.
   Re-visit Chapter 10 for a detailed explanation */
static struct pci_driver i855_driver = {
  .name     = "855",
  .probe    = i855_probe,
  .remove   = __devexit_p(i855_remove),
  .id_table = i855_pci_tbl,
};

/* Driver Initialization */
static int __init
i855_init(void)
{
  /* ... */
  pci_rc = pci_register_driver(&amp;i855_driver);
  /* ... */
}

					  </PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText>&nbsp;</P>
<P class=docText><A name=iddle1586></A><A name=iddle1625></A><A name=iddle1626></A><A name=iddle1628></A><A name=iddle1650></A><A name=iddle2110></A><A name=iddle2156></A><A name=iddle3320></A><A name=iddle3558></A><A name=iddle3625></A><A name=iddle4561></A>Look at <SPAN class=docEmphasis>drivers/edac/*</SPAN><A name="source files"></A> for EDAC source files and at <SPAN class=docEmphasis>Documentation/drivers/edac/edac.txt</SPAN><A name="EDAC sysfs"></A> for detailed semantics of EDAC sysfs nodes.