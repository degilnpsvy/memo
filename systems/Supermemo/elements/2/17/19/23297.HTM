<H3 id=title-IDASKPWC class=docSection1Title>14.1. Challenges to Kernel Debugging</H3>
<P class=docText>Debugging a modern operating system involves many challenges. Virtual memory operating systems present their own unique challenges. Gone are the days when we could replace a processor with an in-circuit emulator. Processors have become far too fast and complex. Moreover, pipeline architectures hide important code-execution details, partly because memory accesses on the bus can be ordered differently from code execution, and particularly because of internal caching of instruction streams. It is not always possible to correlate external bus activity to internal processor instruction execution, except at a rather coarse level.</P>
<P class=docText>Some of the challenges you will encounter while debugging Linux kernel code are:</P>
<UL>
<LI>
<P class=docList>Linux kernel code is highly optimized for speed of execution in many areas.</P></LI>
<LI>
<P class=docList>Compilers use optimization techniques that complicate the correlation of C source to actual machine instruction flow. Inline functions are a good example of this.</P></LI>
<LI>
<P class=docList>Single-stepping through compiler optimized code often produces unusual and unexpected results.</P></LI>
<LI>
<P class=docList>Virtual memory isolates user space memory from kernel memory and can make various debugging scenarios especially difficult.</P></LI>
<LI>
<P class=docList>Some code cannot be stepped through with traditional debuggers.</P></LI>
<LI>
<P class=docList>Startup code can be especially difficult because of its proximity to the hardware and the limited resources available (for example, no console, limited memory mapping, and so on).</P></LI></UL>
<P class=docText>The Linux kernel has matured into a very high-performance operating system capable of competing with the best commercial operating systems. Many areas <A name=iddle1207></A><A name=iddle1292></A><A name=iddle1528></A><A name=iddle1532></A><A name=iddle1539></A><A name=iddle1651></A><A name=iddle1737></A><A name=iddle1790></A><A name=iddle1804></A><A name=iddle2172></A><A name=iddle2418></A>within the kernel do not lend themselves to easy analysis by simply reading the source code. Knowledge of the architecture and detailed design are often necessary to understand the code flow in a particular area. Several good books are available that describe the kernel design in detail. Refer to <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch14lev1sec6.html#ch14lev2sec16">Section 14.6.1</A>, "Suggestions for Additional Reading," for recommendations.</P>
<P class=docText>GCC is an optimizing compiler. By default, the Linux kernel is compiled with the <TT>-O2</TT> compiler flag. This enables many optimization algorithms that can change the fundamental structure and order of your code.<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch14lev1sec1.html#ch14fn1">[1]</A></SUP> For example, the Linux kernel makes heavy use of <SPAN class=docEmphasis>inline</SPAN> functions. Inline functions are small functions declared with the <TT>inline</TT> keyword, which results in the function being included directly in the execution thread instead of generating a function call and the associated overhead.<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch14lev1sec1.html#ch14fn2">[2]</A></SUP> <TT>Inline</TT> functions require a minimum of <TT>-O1</TT> optimization level. Therefore, you cannot turn off optimization, which would be desirable for easier debugging.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch14fn1>[1]</A></SUP> See the GCC manual referenced at the end of this chapter in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch14lev1sec6.html#ch14lev2sec16">Section 14.6.1</A>, "Suggestions for Additional Reading" for details on the optimization levels.</P></BLOCKQUOTE>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch14fn2>[2]</A></SUP> Inline functions are like macros, but with the advantage of compile-time type checking.</P></BLOCKQUOTE>
<P class=docText>In many areas within the Linux kernel, single-stepping through code is difficult or impossible. The most obvious examples are code paths that modify the virtual memory settings. When your application makes a system call that results in entry into the kernel, this results in a change in address space as seen by the process. In fact, any transition that involves a processor exception changes the operational context and can be difficult or impossible to single-step through.