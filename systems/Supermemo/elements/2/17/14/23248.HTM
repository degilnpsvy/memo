<H3 id=title-IDAH5PJ class=docSection1Title>7.2. Bootloader Challenges</H3>
<P class=docText>Even a simple "Hello World" program written in C requires significant hardware and software resources. The application developer does not need to know or care much about these details because the C runtime environment transparently provides this infrastructure. A bootloader developer has no such luxury. Every resource that a bootloader requires must be carefully initialized and allocated before it is used. One of the most visible examples of this is Dynamic Random Access Memory (DRAM).</P><A name=ch07lev2sec1></A>
<H4 id=title-IDAS5PJ class=docSection2Title>7.2.1. DRAM Controller</H4>
<P class=docText>DRAM chips cannot be directly read from or written to like other microprocessor bus resources. They require specialized hardware controllers to enable read and write cycles. To further complicate matters, DRAM must be constantly refreshed or the data contained within will be lost. Refresh is accomplished by sequentially reading each location in DRAM in a systematic manner and within the timing specifications set forth by the DRAM manufacturer. Modern DRAM chips support many modes of operation, such as burst mode and dual data rate for high-performance applications. It is the DRAM controller's responsibility to configure DRAM, keep it refreshed within the manufacturer's timing specifications, and respond to the various read and write commands from the processor.</P>
<P class=docText>Setting up a DRAM controller is the source of much frustration for the newcomer to embedded development. It requires detailed knowledge of DRAM architecture, the controller itself, the specific DRAM chips being used, and the overall hardware design. Though this is beyond the scope of this book, the interested <A name=iddle1100></A><A name=iddle1108></A><A name=iddle1204></A><A name=iddle1205></A><A name=iddle1605></A><A name=iddle1824></A><A name=iddle2157></A><A name=iddle2158></A><A name=iddle2301></A>reader can learn more about this important concept by referring to the references at the end of this chapter. <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/app04.html#app04">Appendix D</A>, "SDRAM Interface Considerations," provides more background on this important topic.</P>
<P class=docText>Very little can happen in an embedded system until the DRAM controller and DRAM itself have been properly initialized. One of the first things a bootloader must do is to enable the memory subsystem. After it is initialized, memory can be used as a resource. In fact, one of the first actions many bootloaders perform after memory initialization is to copy themselves into DRAM for faster execution.</P><A name=ch07lev2sec2></A>
<H4 id=title-IDA5CQJ class=docSection2Title>7.2.2. Flash Versus RAM</H4>
<P class=docText>Another complexity inherent in bootloaders is that they are required to be stored in nonvolatile storage but are usually loaded into RAM for execution. Again, the complexity arises from the level of resources available for the bootloader to rely on. In a fully operational computer system running an operating system such as Linux, it is relatively easy to compile a program and invoke it from nonvolatile storage. The runtime libraries, operating system, and compiler work together to create the infrastructure necessary to load a program from nonvolatile storage into memory and pass control to it. The aforementioned "Hello World" program is a perfect example. When compiled, it can be loaded into memory and executed simply by typing the name of the executable (<TT>hello</TT>) on the command line (assuming, of course, that the executable exists somewhere on your <TT>PATH</TT>).</P>
<P class=docText>This infrastructure does not exist when a bootloader gains control upon power-on. Instead, the bootloader must create its own operational context and move itself, if required, to a suitable location in RAM. Furthermore, additional complexity is introduced by the requirement to execute from a read-only medium.</P><A name=ch07lev2sec3></A>
<H4 id=title-IDASDQJ class=docSection2Title>7.2.3. Image Complexity</H4>
<P class=docText>As application developers, we do not need to concern ourselves with the layout of a binary executable file when we develop applications for our favorite platform. The compiler and binary utilities are preconfigured to build a binary executable image containing the proper components needed for a given architecture. The linker places startup (prologue) and shutdown (epilogue) code into the image. These objects set up the proper execution context for your application, which typically starts at <TT>main()</TT> in your application.</P>
<P class=docText><A name=iddle1822></A><A name=iddle2011></A>This is absolutely not the case with a typical bootloader. When the bootloader gets control, there is no context or prior execution environment. In a typical system, there might not be any DRAM until the bootloader initializes the processor and related hardware. Consider what this means. In a typical C function, any local variables are stored on the stack, so a simple function like the one in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch07lev1sec2.html#ch07list01">Listing 7-1</A> is unusable.</P><A name=ch07list01></A>
<H5 id=title-IDA5EQJ class=docExampleTitle>Listing 7-1. Simple C function</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
<TBODY>
<TR>
<TD><PRE>int setup_memory_controller(board_info_t *p)
    {
    unsigned int *dram_controller_register = p-&gt;dc_reg;
...</PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText>When a bootloader gains control on power-on, there is no stack and no stack pointer. Therefore, a simple C function similar to <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch07lev1sec2.html#ch07list01">Listing 7-1</A> will likely crash the processor because the compiler will generate code to create and initialize the pointer <TT>dram_controller_register</TT> on the stack, which does not yet exist. The bootloader must create this execution context before any C functions are called.</P>
<P class=docText>When the bootloader is compiled and linked, the developer must exercise complete control over how the image is constructed and linked. This is especially true if the bootloader is to relocate itself from Flash to RAM. The compiler and linker must be passed a handful of parameters defining the characteristics and layout of the final executable image. Two primary characteristics conspire to add complexity to the final binary executable image.</P>
<P class=docText>The first characteristic that presents complexity is the need to organize the startup code in a format compatible with the processor's boot sequence. The first bytes of executable code must be at a predefined location in Flash, depending on the processor and hardware architecture. For example, the AMCC PowerPC 405GP processor seeks its first machine instructions from a hard-coded address of 0xFFFF_FFFC. Other processors use similar methods with different details. Some processors are configurable at power-on to seek code from one of several predefined locations, depending on hardware configuration signals.</P>
<P class=docText>How does a developer specify the layout of a binary image? The linker is passed a <SPAN class=docEmphasis>linker description file</SPAN>, also called a <SPAN class=docEmphasis>linker command script</SPAN>. This special file can be thought of as a recipe for constructing a binary executable image. <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch07lev1sec2.html#ch07list02">Listing 7-2</A> contains a snippet from an existing linker description file in use in a popular bootloader, which we discuss shortly.</P>
<P class=docText></P><A name=ch07list02></A>
<H5 id=title-IDAPGQJ class=docExampleTitle>Listing 7-2. Linker Command ScriptReset Vector Placement</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
<TBODY>
<TR>
<TD><PRE>SECTIONS
{
  .resetvec 0xFFFFFFFC :
  {
    *(.resetvec)
  } = 0xffff
...</PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText><A name=iddle1956></A><A name=iddle2016></A>A complete description of linker command scripts syntax is beyond the scope of this book. The interested reader is directed to the GNU LD manual referenced at the end of this chapter. Looking at <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch07lev1sec2.html#ch07list02">Listing 7-2</A>, we see the beginning of the definition for the output section of the binary ELF image. It directs the linker to place the section of code called <TT>.resetvec</TT> at a fixed address in the output image, starting at location 0xFFFF_FFFC. Furthermore, it specifies that the rest of this section shall be filled with all ones (0xFFFF.) This is because an erased Flash memory array contains all ones. This technique not only saves wear and tear on the Flash memory, but it also significantly speeds up programming of that sector.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch07lev1sec2.html#ch07list03">Listing 7-3</A> is the complete assembly language file from a recent U-Boot distribution that defines the <TT>.resetvec</TT> code section. It is contained in an assembly language file called <TT>.../cpu/ppc4xx/resetvec.S</TT>. Notice that this code section cannot exceed 4 bytes in length in a machine with only 32 address bits. This is because only a single instruction is defined in this section, no matter what configuration options are present.</P><A name=ch07list03></A>
<H5 id=title-IDAPIQJ class=docExampleTitle>Listing 7-3. Source Definition of <TT>.resetvec</TT></H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
<TBODY>
<TR>
<TD><PRE>/* Copyright MontaVista Software Incorporated, 2000 */
#include &lt;config.h&gt;
      .section .resetvec, "ax"
#if defined(CONFIG_440)
      b _start_440
#else
#if defined(CONFIG_BOOT_PCI) &amp;&amp; defined(CONFIG_MIP405)
      b _start_pci
#else
      b _start
#endif
#endif</PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText><A name=iddle1097></A><A name=iddle1417></A>This assembly language file is very easy to understand, even if you have no assembly language programming experience. Depending on the particular configuration (as specified by the <TT>CONFIG_*</TT> macros), an unconditional branch instruction (<TT>b</TT> in PowerPC assembler syntax) is generated to the appropriate start location in the main body of code. This branch location is a 4-byte PowerPC instruction, and as we saw in the snippet from the linker command script in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch07lev1sec2.html#ch07list02">Listing 7-2</A>, this simple branch instruction is placed in the absolute Flash address of 0xFFFF_FFFC in the output image. As mentioned earlier, the PPC 405GP processor fetches its first instruction from this hard-coded address. This is how the first sequence of code is defined and provided by the developer for this particular architecture and processor combination.</P><A name=ch07lev2sec4></A>
<H4 id=title-IDACKQJ class=docSection2Title>7.2.4. Execution Context</H4>
<P class=docText>The other primary reason for bootloader image complexity is the lack of execution context. When the sequence of instructions from <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch07lev1sec2.html#ch07list03">Listing 7-3</A> starts executing (recall that these are the first machine instructions after power-on), the resources available to the running program are nearly zero. Default values designed into the hardware ensure that fetches from Flash memory work properly and that the system clock has some default values, but little else can be assumed.<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch07lev1sec2.html#ch072">[2]</A></SUP> The reset state of each processor is usually well defined by the manufacturer, but the reset state of a board is defined by the hardware designers.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch072>[2]</A></SUP> The details differ, depending upon architecture, processor, and details of the hardware design.</P></BLOCKQUOTE>
<P class=docText>Indeed, most processors have no DRAM available at startup for temporary storage of variables or, worse, for a stack that is required to use C program calling conventions. If you were forced to write a "Hello World" program with no DRAM and, therefore, no stack, it would be quite different from the traditional "Hello World" example.</P>
<P class=docText>This limitation places significant challenges on the initial body of code designed to initialize the hardware. As a result, one of the first tasks the bootloader performs on startup is to configure enough of the hardware to enable at least some minimal amount of RAM. Some processors designed for embedded use have small amounts of on-chip static RAM available. This is the case with the PPC 405GP we've been discussing. When RAM is available, a stack can be allocated using part of that <A name=iddle1113></A><A name=iddle1118></A><A name=iddle1222></A><A name=iddle1265></A><A name=iddle1313></A><A name=iddle2548></A><A name=iddle2553></A>RAM, and a proper context can be constructed to run higher-level languages such as C. This allows the rest of the processor and platform initialization to be written in something other than assembly language.