<H3 id=-100000 class=docSection1Title>Debugging</H3>
<P class=docText><A name="Before closing"></A>Before closing this chapter, let's visit a few topics related to debugging embedded software.</P><A name=ch18lev2sec17></A>
<H4 id=title-ID0ELJAO class=docSection2Title>Board Rework</H4>
<P class=docText><A name=iddle1300></A><A name=iddle1687></A><A name=iddle1944></A><A name=iddle3126></A><A name=iddle3399></A><A name=iddle3572></A><A name=iddle3636></A><A name=iddle3760></A><A name=iddle4002></A><A name="schematics and"></A>Navigating board schematics and datasheets is an important debugging skill you need while bringing up the bootloader or kernel on embedded hardware. Understanding your board's <SPAN class=docEmphasis>placement plot</SPAN><A name="that shows"></A>, which is a file that shows the position of chips on your board, is a big help when you are debugging a potential hardware problem using an oscilloscope, or when you need to perform minor board rework. <SPAN class=docEmphasis>Reference designators</SPAN> (such as U10 and U11 in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18lev1sec10.html#ch18fig04">Figure 18.4</A><A name="in the"></A>) associate each chip in the schematic with the placement plot. <SPAN class=docEmphasis>Printed circuit boards</SPAN> (PCBs) are usually clothed with <SPAN class=docEmphasis>silk screens</SPAN> that print the reference designator near each chip.</P><A name=ch18fig04></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 18.4. Debugging an I<SUP>2</SUP>C RTC on an embedded system.</H5>
<P class=docText><IMG border=0 alt="" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/MjltNHJhaS9kNy8zY3JncDA4dHMvOTMxZTZhZzU1LjhpMWYvcGdoaWZjaXMwNGc-.jpg" width=475 height=312></P></CENTER>
<P></P><BR>
<P class=docText><A name="board under"></A>Consider this fictitious scenario where USB enumeration doesn't occur on your board under test. The USB hub driver detects device insertions but is not able to assign endpoint addresses. A close look at the schematics reveals that the connections originating from the <TT>SPEED</TT> and <TT>MODE</TT><A name="transceiver have"></A> pins of the USB transceiver have been interchanged by mistake. An examination of the placement plot identifies the location of the transceiver on the PCB. Matching the transceiver's reference designator on the placement plot with the silk screen on the PCB pinpoints the places where you have to solder "yellow wires" to repair the faulty connections.</P>
<P class=docText><A name="additions to"></A>A multimeter and an oscilloscope are worthy additions to your embedded debugging toolkit. As an illustration, let's consider an example situation involving the I<SUP>2</SUP>C RTC, as shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch08lev1sec5.html#ch08fig03">Figure 8.3</A> of <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch08.html#ch08">Chapter 8</A><A name="with a"></A>. That figure is reproduced there with a multimeter/scope attached to probe points of interest. Consider this scenario: You have written an I<SUP>2</SUP><A name="described in"></A>C client driver for this RTC chip as described in the section "<A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch08lev1sec5.html#ch08lev1sec5">Device Example: Real Time Clock</A>" in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch08.html#ch08">Chapter 8</A><A name="it renders"></A>. However, when you run your driver on the board, it renders the system unbootable. Neither does the bootloader come up when you reset the board, nor does your JTAG debugger connect to the target. To understand possible causes of this seemingly fatal error, let's take a closer look at the connection diagram. Because both the RTC and the CPU need an external clock, the board supplies it using a single 32KHz crystal. This 32KHz clock needs to be buffered, however. The RTC buffers the clock for its use and makes it available on an output pin for free. This pin, <TT>CLK_OUT</TT><A name="feeds the"></A>, feeds the clock to the processor. Connect an oscilloscope (or a multimeter that can measure frequency) between <TT>CLK_OUT</TT><A name="to verify"></A> and ground to verify the processor clock frequency. As you can see in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18lev1sec10.html#ch18fig04">Figure 18.4</A><A name="than the"></A>, the scope reads 1KHz rather than the expected 32KHz! What could be wrong here?</P>
<P class=docText><A name="register contains"></A>The RTC control register contains bits that choose the frequency of <TT>CLK_OUT</TT>. While probing the chip (on the lines of <TT>myrtc_attach()</TT> in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch08.html#ch08">Chapter 8</A>), the driver <A name=iddle1688></A><A name=iddle1723></A><A name=iddle1945></A>has erroneously initialized these bits to generate 1KHz on <TT>CLK_OUT</TT><A name="control register"></A>. RTC registers are nonvolatile because of the battery backup, so the control register holds this bad value across reboots. The resulting skewed clock is sufficient to render the system unbootable. Disconnect the RTC's backup battery, drain the registers, reconnect the battery, verify using the scope that the 32KHz clock is restored on <TT>CLK_OUT</TT><A name="start afresh"></A>, fix your driver code, and start afresh!</P><A name=ch18lev2sec18></A>
<H4 id=title-ID0EYQAO class=docSection2Title>Debuggers</H4>
<P class=docText><A name="techniques that"></A>You can use most of the debugging techniques that you will learn in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch21.html#ch21">Chapter 21</A><A name="available for"></A> while embedding Linux. Kernel debuggers are available for several processor platforms. JTAG debuggers, also explored in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch21.html#ch21">Chapter 21</A><A name="popularly used"></A>, are more powerful than kernel debuggers and are popularly used in the embedded space to debug the bootloader, base kernel, and device-driver modules.