<H3 id=-100000 class=docSection1Title>Embedded Drivers</H3>
<P class=docText><A name=iddle1929></A><A name=iddle1931></A><A name=iddle1961></A><A name=iddle1963></A><A name=iddle2083></A><A name=iddle2944></A><A name=iddle3193></A><A name="One of"></A>One of the reasons Linux is so popular in the embedded space is that its formidable application suite works regardless of the hardware platform, thanks to kernel abstraction layers that lie beneath them. So, as shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18lev1sec7.html#ch18fig03">Figure 18.3</A><A name="need to"></A>, all you need to do to get a feature-rich embedded system is to implement the low-level device drivers ensconced between the abstraction layers and the hardware. You need to do one of the following for each peripheral interface on your device:</P><A name=ch18pro01></A>
<UL class=doclist start="">
<LI>Qualify an existing driver. Test and verify that it works as it's supposed to.<BR><BR></LI>
<LI>Find a driver that is a close match and modify it for your hardware.<BR><BR></LI>
<LI>Write a driver from scratch.<BR><BR></LI></UL><A name=ch18fig03></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 18.3. Hardware-independent applications and hardware-dependent drivers.</H5>
<P class=docText>
<DIV class=st1><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/MjltNHJhaS9kNy8zY3JncDA4dHMvOTMxZTZhZzU1aV84aTFmL3BhZmhpdGNsMDNzZy5n.jpg" target=_blank>[View full size image]</A></DIV><IMG border=0 alt="" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/MjltNHJhaS9kNy8zY3JncDA4dHMvOTMxZTZhZzU1LjhpMWYvcGdoaWZjaXMwM2c-.jpg" width=500 height=369>
<P></P></CENTER>
<P></P><BR>
<P class=docText><A name="participates in"></A>Assuming a kernel engineer participates in component selection, you're likely to have existing drivers or close enough matches for most peripheral devices. To take advantage of existing drivers, go through the block diagram and schematics of your hardware, identify the different chipsets, and cobble together a working kernel configuration file that enables the right drivers. Based on your footprint or boot time requirements, modularize possible device drivers or build them into the base kernel.</P>
<P class=docText><A name="device drivers"></A>To learn about device drivers for I/O interfaces commonly found on embedded hardware, let's take a clockwise tour around the embedded controller shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18lev1sec1.html#ch18fig01">Figure 18.1</A>, starting with the NOR flash.</P><A name=ch18lev2sec1></A>
<H4 id=title-ID0EFMAO class=docSection2Title>Flash Memory</H4>
<P class=docText>Embedded devices such as the one in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18lev1sec5.html#ch18fig02">Figure 18.2</A><A name="Many devices"></A>, boot from flash memory and have filesystem data resident on flash-based storage. Many devices use a small NOR flash component for the former and a NAND flash part for the latter.<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18lev1sec7.html#ch18fn02">[2]</A></SUP><A name="and the"></A> NOR memory, thus, holds the bootloader and the base kernel, whereas NAND storage contains filesystem partitions and device driver modules.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch18fn02>[2]</A></SUP><A name="Material "></A> In today's embedded market where the Bill Of Material (BOM) cost is often all-important, it's not uncommon for devices to contain only NAND storage. Such devices boot from NAND flash and have their filesystems also reside in NAND memory. NAND boot needs support from both the processor and the bootloader.</P></BLOCKQUOTE>
<P class=docText><A name="the kernel"></A>Flash drivers are supported by the kernel's MTD subsystem discussed in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17.html#ch17">Chapter 17</A><A name="only an"></A>, "Memory Technology Devices." If you're using an MTD-supported chip, you need to write only an MTD map driver to suitably partition the flash to hold the bootloader, kernel, and filesystem. <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec3.html#ch17ex01">Listings 17.1</A>, <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec3.html#ch17ex02">17.2</A>, and <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec3.html#ch17ex03">17.3</A> in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17.html#ch17">Chapter 17</A><A name="as shown"></A> implement a map driver for the Linux handheld, as shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec3.html#ch17fig02">Figure 17.2</A><A name="of the"></A> of the same chapter.</P><A name=ch18lev2sec2></A>
<H4 id=title-ID0EGOAO class=docSection2Title>UART</H4>
<P class=docText><A name=iddle1924></A><A name=iddle1938></A><A name=iddle1956></A><A name=iddle1969></A><A name=iddle2656></A><A name=iddle4350></A><A name="is responsible"></A>The UART is responsible for serial communication and is an interface you are likely to find on all microcontrollers. UARTs are considered basic hardware, so the kernel contains UART drivers for all microcontrollers on which it runs. On embedded devices, UARTs are used to interface the processor with debug serial ports, modems, touch controllers, GPRS chipsets, Bluetooth chipsets, GPS devices, telemetry electronics, and so on.</P>
<P class=docText>Look at <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch06.html#ch06">Chapter 6</A><A name="on the"></A>, "Serial Drivers," for a detailed discussion on the Linux serial subsystem.</P><A name=ch18lev2sec3></A>
<H4 id=title-ID0E1QAO class=docSection2Title>Buttons and Wheels</H4>
<P class=docText><A name="have several"></A>Your device may have several miscellaneous peripherals such as keypads (micro keyboards organized in the common QWERTY layout, data-entry devices having overloaded keys as found in cell phones, keypads having ABC-type layout, and so on), <A name=iddle1405></A><A name=iddle1933></A><A name=iddle1936></A><A name=iddle1940></A><A name=iddle1964></A><A name=iddle1967></A><A name=iddle1970></A><A name=iddle3522></A><A name=iddle3904></A><A name=iddle4424></A><A name=iddle4449></A><A name=iddle4526></A><A name="lines or"></A>LEDs, roller wheels, and buttons. These I/O devices interface with the CPU via GPIO lines or a CPLD (see the following "<A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18lev1sec7.html#ch18lev2sec11">CPLD/FPGA</A><A name="are usually"></A>" section). Drivers for such peripherals are usually straightforward char or misc drivers. Some of the drivers export device-access via procfs or sysfs rather than through <SPAN class=docEmphasis>/dev</SPAN> nodes.</P><A name=ch18lev2sec4></A>
<H4 id=title-ID0ENVAO class=docSection2Title>PCMCIA/CF</H4>
<P class=docText><A name="common add"></A>A PCMCIA or CF slot is a common add-on to embedded devices. The advantage of, say, WiFi enabling an embedded device using a CF card is that you won't have to respin the board if the WiFi controller goes end of life. Also, because diverse technologies are available in the PCMCIA/CF form factor, you have the freedom to change the connectivity mode from WiFi to another technology such as Bluetooth later. The disadvantage of such a scheme is that even with mechanical retaining, sockets are inherently unreliable. There is the possibility of the card coming loose due to shock and vibe, and resulting intermittent connections.</P>
<P class=docText><A name="are discussed"></A>PCMCIA and CF device drivers are discussed in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch09.html#ch09">Chapter 9</A>, "PCMCIA and Compact Flash."</P><A name=ch18lev2sec5></A>
<H4 id=title-ID0EBWAO class=docSection2Title>SD/MMC</H4>
<P class=docText><A name="storage is"></A>Many embedded processors include controllers that communicate with SD/MMC media. SD/MMC storage is built using NAND flash memory. Like CF cards, SD/MMC cards add several gigabytes of memory to your device. They also offer an easy memory upgrade path, because the available density of SD/MMC cards is constantly increasing.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch14.html#ch14">Chapter 14</A>, "Block Drivers," points you to the SD/MMC subsystem in the kernel.</P><A name=ch18lev2sec6></A>
<H4 id=title-ID0EUWAO class=docSection2Title>USB</H4>
<P class=docText><A name="which you"></A>Legacy computers support the USB host mode, by which you can communicate with most classes of USB devices. Embedded systems frequently also require support for the USB device mode, wherein the system itself functions as a USB device and plugs into other host computers.</P>
<P class=docText><A name="As you"></A>As you saw in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch11.html#ch11">Chapter 11</A><A name="embedded controllers"></A>, "Universal Serial Bus," many embedded controllers support USB OTG that lets your device work either as a USB host or as a USB device. It allows you, for example, to connect a USB pen drive to your embedded device. It also allows your embedded device to function as a USB pen drive by exporting part of its local storage for external access. The Linux USB subsystem offers drivers for USB OTG. For hardware that is not compatible with OTG, the USB Gadget project, now part of the mainline kernel, brings USB device capability.</P><A name=ch18lev2sec7></A>
<H4 id=title-ID0ELXAO class=docSection2Title>RTC</H4>
<P class=docText><A name=iddle1165></A><A name=iddle1922></A><A name=iddle1935></A><A name=iddle1937></A><A name=iddle1941></A><A name=iddle1954></A><A name=iddle1966></A><A name=iddle1968></A><A name=iddle1971></A><A name=iddle3854></A><A name=iddle4291></A><A name=iddle4585></A><A name="RTC support"></A>Many embedded SoCs include RTC support to keep track of wall time, but some rely on an external RTC chip. Unlike x86-based computers where the RTC is part of the South Bridge chipset, embedded controllers commonly interface with external RTCs via slow serial buses such as I<SUP>2</SUP><A name="can drive"></A>C or SPI. You can drive such RTCs by writing client drivers that use the services of the I<SUP>2</SUP>C or SPI core as discussed in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch08.html#ch08">Chapter 8</A>, "The Inter-Integrated Circuit Protocol." <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch02.html#ch02">Chapter 2</A> and <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch05.html#ch05">Chapter 5</A>, "Character Drivers," discussed RTC support on x86-based systems.</P><A name=ch18lev2sec8></A>
<H4 id=title-ID0EO3AO class=docSection2Title>Audio</H4>
<P class=docText>As you saw in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch13.html#ch13">Chapter 13</A><A name="signals for"></A>, "Audio Drivers," an audio codec converts digital audio data to analog sound signals for playback via speakers and performs the reverse operation for recording through a microphone. The codec's connection with the CPU depends on the digital audio interface supported by the embedded controller. The usual way to communicate with a codec is via buses, such as AC'97 or I<SUP>2</SUP>S.</P><A name=ch18lev2sec9></A>
<H4 id=title-ID0EC4AO class=docSection2Title>Touch Screen</H4>
<P class=docText><A name="input mechanism"></A>Touch is the primary input mechanism on several embedded devices. Many PDAs offer soft keyboards for data entry. In <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch06.html#ch06">Chapter 6</A><A name="touch controller"></A>, we developed a driver for a serial touch controller, and in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch07.html#ch07">Chapter 7</A><A name="controller that"></A>, "Input Drivers," we looked at a touch controller that interfaced with the CPU via the SPI bus.</P>
<P class=docText>If your driver conforms to the <SPAN class=docEmphasis>input</SPAN><A name="a graphical"></A> API, it should be straightforward to tie it with a graphical user interface. You might, however, need to add custom support to calibrate and linearize the touch panel.</P><A name=ch18lev2sec10></A>
<H4 id=title-ID0E64AO class=docSection2Title>Video</H4>
<P class=docText><A name="associated displays"></A>Some embedded systems are headless, but many have associated displays. A suitably oriented (landscape or portrait) LCD panel is connected to the video controller that is part of the embedded SoC. Many LCD panels come with integrated touch screens.</P>
<P class=docText><A name="As you"></A>As you learned in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch12.html#ch12">Chapter 12</A><A name="insulate applications"></A>, "Video Drivers," frame buffers insulate applications from display hardware, so porting a compliant GUI to your device is easy, as long as your display driver conforms to the frame buffer interface.</P><A name=ch18lev2sec11></A>
<H4 id=title-ID0EW5AO class=docSection2Title>CPLD/FPGA</H4>
<P class=docText><A name=iddle1546></A><A name=iddle1585></A><A name=iddle1623></A><A name=iddle1844></A><A name=iddle1925></A><A name=iddle1926></A><A name=iddle1927></A><A name=iddle1930></A><A name=iddle1957></A><A name=iddle1958></A><A name=iddle1959></A><A name=iddle1962></A><A name=iddle2053></A><A name=iddle2092></A><A name=iddle4576></A><A name=iddle4582></A><SPAN class=docEmphasis>Complex Programmable Logic Devices</SPAN> (CPLDs) or their heavy-duty counterparts, <SPAN class=docEmphasis>Field Programmable Gate Arrays</SPAN><A name="layer of"></A> (FPGAs), can add a thick layer of fast OS-independent logic. You can program CPLDs (and FPGAs) in a language such as <SPAN class=docEmphasis><A name="integrated circuit"></A>Very high speed integrated circuit Hardware Description Language</SPAN><A name="so by"></A> (VHDL). Electrical signals between the processor and peripherals propagate through the CPLD, so by appropriately programming the CPLD, the OS obtains elegant register interfaces for performing complex I/O. The VHDL code in the CPLD internally latches these register contents onto the data bus after performing necessary control logic.</P>
<P class=docText><A name="LCD controller"></A>Consider, for example, an external serial LCD controller that has to be driven by shifting in each pixel bit. The Linux driver for this device will have a tough time toggling the clock and wiggling I/O pins several times for sending each pixel or command byte to the serial LCD controller. If this LCD controller is routed to the processor via a CPLD, however, the VHDL code can perform the necessary serial shifting by clocking each bit in and present a parallel register interface to the OS for command and data. With these virtual LCD command and data registers, the LCD driver implementation is rendered simple. Essentially, the CPLD converts the cumbersome serial LCD controller to a convenient, parallel one.</P>
<P class=docText><A name="driver developer"></A>If the CPLD engineer and the Linux driver developer collaborate, they can arrive at an optimum partitioning between the VHDL code and the Linux driver that'll save time and cost.</P><A name=ch18lev2sec12></A>
<H4 id=title-ID0EHEBO class=docSection2Title>Connectivity</H4>
<P class=docText><A name="few embedded"></A>Connectivity injects intelligence, so there are few embedded devices that have no communication capability. Popular networking technologies found on embedded devices include WiFi, Bluetooth, cellular modems, Ethernet, and radio communication.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch15.html#ch15">Chapter 15</A>, "Network Interface Cards," explored device drivers for wired networking, and <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch16.html#ch16">Chapter 16</A>, "Linux Without Wires," looked at drivers for wireless communication technologies.</P><A name=ch18lev2sec13></A>
<H4 id=title-ID0EAFBO class=docSection2Title>Domain-Specific Electronics</H4>
<P class=docText><A name="to the"></A>Your device is likely to contain electronics specific to the usage industry domain. It could be a telemetry interface for a hospital-grade device, a sensor for automotive hardware, biometrics for a security gadget, GPRS for a cellular phone, or GPS for a navigation system. These peripherals usually communicate with the embedded controller over <A name=iddle1334></A><A name=iddle1365></A><A name=iddle1601></A><A name=iddle1602></A><A name=iddle1799></A><A name=iddle1858></A><A name=iddle1873></A><A name=iddle1885></A><A name=iddle1923></A><A name=iddle1928></A><A name=iddle1934></A><A name=iddle1955></A><A name=iddle1960></A><A name=iddle1965></A><A name=iddle3044></A><A name=iddle3075></A><A name=iddle3688></A><A name=iddle3690></A><A name=iddle3988></A><A name=iddle4151></A>standard I/O interfaces such as UART, USB, I<SUP>2</SUP>C, SPI, or <SPAN class=docEmphasis>controller area network</SPAN><A name="have little"></A> (CAN). For devices interfacing via a UART, you often have little work to do at the device driver level because the UART driver takes care of the communication. For devices such as a fingerprint sensor that interface via USB, you may have to write a USB client driver. You might also face proprietary interfaces, such as a switching fabric for a network processor, in which case, you may need to write a full-fledged device driver.</P>
<P class=docText><A name="Consider the"></A>Consider the digital media space. Cable or <SPAN class=docEmphasis>Direct-to-home</SPAN><A name="are usually"></A> (DTH) interface systems are usually built around <SPAN class=docEmphasis>set-top box</SPAN><A name="such as"></A> (STB) chipsets. These chips have capabilities such as personal video recording (recording multiple channels to a hard disk, recording a channel while viewing another and so forth) and conditional access (allowing the service provider to control what the end user sees depending on subscription). To achieve this, STB chips have a processor core coupled with a powerful graphics engine. The latter implements MPEG codecs in hardware. Such audio-video codecs can decode compressed digital media standards such as MPEG2 and MPEG4. (MPEG is an acronym for <SPAN class=docEmphasis>Moving Picture Experts Group</SPAN><A name="for developing"></A>, the body responsible for developing motion picture standards.) If you are embedding Linux onto an STB, you will need to drive such audio-video codecs.</P><A name=ch18lev2sec14></A>
<H4 id=title-ID0EYLBO class=docSection2Title>More Drivers</H4>
<P class=docText><A name="the system"></A>If your device serves a life-critical industry domain such as health care, the system memory might have ECC capabilities. <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch20.html#ch20">Chapter 20</A>, "More Devices and Drivers," discusses ECC reporting.</P>
<P class=docText><A name="is battery"></A>If your embedded device is battery powered, you may want to use a suitable CPU frequencygovernor to dynamically scale processor frequency and save power. Chap-ter 20 also discusses CPU frequency drivers and power management.</P>
<P class=docText><A name="that recovers"></A>Most embedded processors have a built-in hardware watchdog that recovers the system from freezes. You looked at watchdog drivers in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch05.html#ch05">Chapter 5</A>. Use a suitable driver from <SPAN class=docEmphasis>drivers/char/watchdog/</SPAN><A name="implement a"></A> as the starting point to implement a driver for your system's watchdog.</P>
<P class=docText>If your embedded device contains circuitry to detect <SPAN class=docEmphasis>brownout</SPAN>,<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18lev1sec7.html#ch18fn03">[3]</A></SUP><A name="kernel to"></A> you might need to add capability to the kernel to sense that condition and take appropriate action.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch18fn03>[3]</A></SUP> <SPAN class=docEmphasis>Brownout</SPAN><A name="below tolerable"></A> is the scenario when input voltage drops below tolerable levels. (<SPAN class=docEmphasis>Blackout</SPAN><A name="on the"></A>, on the other hand, refers to total loss of power.) Brownout detection is especially relevant if your device is powered by a technology such as Power over Ethernet (PoE) rather than a conventional wall socket.</P></BLOCKQUOTE>
<P class=docText><A name="SoCs contain"></A>Several embedded SoCs contain built-in <SPAN class=docEmphasis>pulse-width modulator</SPAN><A name="control analog"></A> (PWM) units. PWMs let you digitally control analog devices such as buzzers. The voltage level <A name=iddle1977></A><A name=iddle1978></A><A name=iddle2066></A><A name=iddle2068></A><A name=iddle3263></A><A name=iddle3840></A><A name=iddle3842></A><A name="target device"></A>supplied to the target device is varied by programming the PWM's duty cycle (the On time of the PWM's output waveform relative to its period). LCD brightness is another example of a feature controllable using PWMs. Depending on the target device and the usage scenario, you can implement char or misc driver interfaces to PWMs.