<H3 id=-100000 class=docSection1Title>Embedded Bootloaders</H3>
<P class=docText><A name="Bootloader development"></A>Bootloader development is usually the starting point of any embedded software effort. You have to decide whether to write a bootloader from scratch or tailor an existing open source bootloader to suit your needs. Each candidate bootloader might be built based on a different philosophy: small footprint, easy portability, fast boot, or the capability to support certain specific features. After you home-in on a starting point, you can design and implement device-specific modifications.</P>
<P class=docText><A name=iddle1303></A><A name=iddle1304></A><A name="use the"></A>In this section, let's use the term <SPAN class=docEmphasis>bootloader</SPAN><A name="This includes"></A> to mean the boot suite. This includes the following:</P>
<UL>
<LI>
<P class=docList>The BIOS, if present</P></LI>
<LI>
<P class=docList><A name="needed to"></A>Any bootstrap code needed to put the bootloader onto the boot device</P></LI>
<LI>
<P class=docList>One or more stages<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18lev1sec4.html#ch18fn01">[1]</A></SUP> of the actual bootloader</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch18fn01>[1]</A></SUP><A name="sometimes called"></A> In embedded bootloader parlance, the first stage of a two-stage bootloader is sometimes called the <SPAN class=docEmphasis>Initial Program Loader</SPAN><A name="is called"></A> (IPL), and the second stage is called the <SPAN class=docEmphasis>Secondary Program Loader</SPAN> (SPL).</P></BLOCKQUOTE></LI>
<LI>
<P class=docList><A name="machine that"></A>Any program executing on an external host machine that talks with the bootloader for the purpose of downloading firmware onto the target device</P></LI></UL>
<P class=docText><A name="responsible for"></A>At the minimum, a bootloader is responsible for processor- and board-specific initializations, loading a kernel and an optional initial ramdisk into memory and passing control to the kernel. In addition, a bootloader might be in charge of providing BIOS services, performing POST, supporting firmware downloads to the target, and passing memory layout and configuration information to the kernel. On embedded devices that use encrypted firmware images for security reasons, bootloaders may have the task of decrypting firmware. Some bootloaders support a debug monitor to load and debug stand-alone code on to the target device. You may also decide to build a failure-recovery mechanism into your bootloader to recoup from kernel corruption on the field.</P>
<P class=docText><A name="chipsets present"></A>In general, bootloader architecture depends on the processor family, the chipsets present on the hardware platform, the boot device, and the operating system running on the device. To illustrate the effects of the processor family on the boot suite, consider the following:</P>
<UL>
<LI>
<P class=docList><A name="the StrongARM"></A>A bootloader for a device designed around the StrongARM processor has to know whether it's booting the system or waking it up from sleep, because the processor starts execution from the top of its address space (the bootloader) in both cases. The bootloader has to pass control to the kernel code that restores the system state if it's waking up from sleep or load the kernel from the boot device if the system is starting from reset.</P></LI>
<LI>
<P class=docList><A name="An x"></A>An x86 bootloader might need to switch to protected mode to load a kernel bigger than the 1MB real-mode limit.</P></LI>
<LI>
<P class=docList><A name="not based"></A>Embedded systems not based on x86 platforms cannot avail the services of a legacy BIOS. So, if you want your embedded device to boot, for example, from an external USB device, you have to build USB capabilities into your bootloader.</P></LI>
<LI>
<P class=docList><A name=iddle1306></A><A name=iddle1330></A><A name=iddle1455></A><A name=iddle1914></A><A name=iddle1947></A><A name=iddle1994></A><A name=iddle2509></A><A name="are based"></A>Even when two platforms are based on similar processor cores, the bootloader architecture may differ based on the SoC. For example, consider two ARM-based devices, the Compaq iPAQ H3900 PDA and the Darwin Jukebox. The former is built around the Intel PXA250 controller chip, which has an XScale CPU based on an ARMv5 core, and the latter is designed using the Cirrus Logic EP7312 controller that uses an ARMv3 core. Whereas XScale supports JTAG (named after the <SPAN class=docEmphasis>Joint Test Action Group</SPAN><A name="debugging standard"></A>, which developed this hardware-assisted debugging standard) to load a bootloader onto flash, the EP7312 has a bootstrap mode to accomplish the same task.</P></LI></UL>
<P class=docText><A name="image from"></A>The boot suite needs a mechanism to transfer a bootloader image from the host development system to the target's boot device. This is called <SPAN class=docEmphasis>bootstrapping.</SPAN><A name="systems where"></A> Bootstrapping is straightforward on PC-compatible systems where the BIOS flash is programmed using an external burner if it's corrupted or updated after booting into an operating system if it's healthy. Embedded devices, however, do not have a generic method for bootstrapping.</P>
<P class=docText><A name="the example"></A>To illustrate bootstrapping on an embedded system, take the example of the Cirrus Logic EP7211 controller (which is the predecessor of the EP7312 discussed in the previous section). The EP7211 executes code from a small internal 128-byte memory when it's powered on in a bootstrap mode. This 128-byte code downloads a bootstrap image from a host via the serial port to an on-board 2KB SRAM and transfers control to it. The boot suite has to be thus architected into three stages, each loaded at a different address:</P>
<UL>
<LI>
<P class=docList><A name="of processor"></A>The first stage (the 128-byte image) is part of processor firmware.</P></LI>
<LI>
<P class=docList><A name="can be"></A>The second stage lives in the on-chip SRAM, so it can be up to 2KB. This is the bootstrapper.</P></LI>
<LI>
<P class=docList><A name="from an"></A>The bootstrapper downloads the actual bootloader image from an external host to the top of flash memory. The bootloader gets control when the processor powers on in normal operation mode.</P></LI></UL>
<P class=docText><A name="Note that"></A>Note that the processor-resident microcode (the first stage) itself cannot function as the bootstrapper because a bootstrapper needs to have the capability to program flash memory. Because many types of flash chips can be used with a processor, the bootstrapper code needs to be board-specific.</P>
<P class=docText><A name="chips do"></A>Many controller chips do not support a bootstrap mode. Instead, the bootloader is written to flash via a JTAG interface. You can use your JTAG debugger's command <A name=iddle1124></A><A name=iddle1237></A><A name=iddle1302></A><A name=iddle1305></A><A name=iddle1308></A><A name=iddle1310></A><A name=iddle1312></A><A name=iddle1913></A><A name=iddle1916></A><A name=iddle1918></A><A name=iddle1920></A><A name=iddle1946></A><A name=iddle1949></A><A name=iddle1951></A><A name=iddle1953></A><A name=iddle2744></A><A name=iddle2790></A><A name=iddle2907></A><A name=iddle2915></A><A name=iddle3566></A><A name=iddle3624></A><A name=iddle3758></A><A name=iddle4024></A><A name=iddle4343></A><A name=iddle4664></A><A name="debug logic"></A>interface to access the processor's debug logic and burn the bootloader to the target device's flash memory. We will have a more detailed discussion on JTAG debugging in the section "<A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch21lev1sec1.html#ch21lev2sec5">JTAG Debuggers</A>" in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch21.html#ch21">Chapter 21</A>, "Debugging Device Drivers."</P>
<P class=docText><A name="that support"></A>There are controllers that support both bootstrap execution mode and JTAG. The Freescale i.MX21 (and its upgraded version i.MX27) based on an ARM9 core is one such controller.</P>
<P class=docText><A name="as well"></A>After a bootloader is resident on flash, it can update itself as well as other firmware components such as the kernel and the root filesystem. The bootloader can directly talk to a host machine and download firmware components via interfaces such as UART, USB, or Ethernet.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18lev1sec4.html#ch18tab01">Table 18.1</A><A name="example Linux"></A> looks at a few example Linux bootloaders for ARM, PowerPC, and x86.</P><A name=ch18tab01></A>
<P>
<TABLE cellSpacing=0 cellPadding=5 rules=groups frame=hsides>
<CAPTION>
<H5 class=docTableTitle>Table 18.1. Linux Bootloaders</H5></CAPTION>
<COLGROUP span=2 align=left>
<COL width=100>
<COL width=450></COLGROUP>
<THEAD>
<TR>
<TH class="docTableCell bottomBorder thead" style="TEXT-ALIGN: left" vAlign=bottom scope=col align=left>Processor Platform</TH>
<TH class="docTableCell bottomBorder thead" style="TEXT-ALIGN: left" vAlign=bottom scope=col align=left>Linux Bootloaders</TH></TR></THEAD>
<TBODY>
<TR>
<TD class=docTableCell vAlign=top align=left><SPAN class=docEmphStrong>ARM</SPAN></TD>
<TD class=docTableCell vAlign=top align=left>RedBoot (<A class=docLink href="http://www.cygwin.com/redboot" target=_blank>www.cygwin.com/redboot</A><A name="based on"></A>) is a bootloader popular on ARM-based hardware. Redboot is based on a hardware abstraction offered by the eCos operating system (<A class=docLink href="http://ecos.sourceware.org/" target=_blank>http://ecos.sourceware.org/</A>). The <SPAN class=docEmphasis>BootLoader Object</SPAN> or BLOB (<A class=docLink href="http://sourceforge.net/projects/blob/" target=_blank>http://sourceforge.net/projects/blob/</A><A name="is commonly"></A>), a bootloader originally developed for StrongARM-based boards, is commonly custom ported to other ARM-based platforms, too. BLOB is built as two images, one that performs minimal initializations, and the second that forms the bulk of the bootloader. The first image relocates the second to RAM, so the bootloader can easily upgrade itself.</TD></TR>
<TR>
<TD class=docTableCell vAlign=top align=left><SPAN class=docEmphStrong>PowerPC</SPAN></TD>
<TD class=docTableCell vAlign=top align=left><A name="such as"></A>PowerPC chips used on embedded devices include SoCs such as IBM's 405LP and the 440GP, and Motorola's MPC7xx and MPC8xx. Bootloaders such as U-Boot (<A class=docLink href="http://sourceforge.net/projects/u-boot/" target=_blank>http://sourceforge.net/projects/u-boot/</A>), SLOF, and PIBS boot Linux on PowerPC-based hardware.</TD></TR>
<TR>
<TD class=docTableCell vAlign=top align=left>x86</TD>
<TD class=docTableCell vAlign=top align=left><A name="may boot"></A>Most x86-based systems boot from disk drives. Embedded x86 boards may boot from solid-state disks rather than mechanical drives. The first stage of a disk-resident bootloader consists of a sector-sized chunk that is loaded by the BIOS. This is called the <SPAN class=docEmphasis><A name="Master Boot"></A>Master Boot Record</SPAN><A name="up to"></A> (MBR) and contains up to 446 bytes of code, four partition table entries consuming 16 bytes each, and a 2-byte signature (thus making up a 512-byte sector). The MBR is responsible for loading the second stage of the bootloader. Each intervening stage has its own tasks, but the final stage lets you choose the kernel image and command-line arguments, loads the kernel and any initial ramdisk to memory, and transfers control to the kernel. As an illustration, let's look at three bootloaders popularly used to boot Linux on x86-based hardware: 
<UL>
<LI>
<P class=docList>The <SPAN class=docEmphasis>Linux Loader</SPAN> or LILO (<A class=docLink href="http://freshmeat.net/projects/lilo/" target=_blank>http://freshmeat.net/projects/lilo/</A><A name="some Linux"></A>) is packaged along with some Linux distributions. When the first stage of the bootloader is written to the boot sector, LILO precalculates the disk locations of the second stage and the kernel. If you build a new kernel image, you have to rewrite the boot sector. The second stage allows the user to interactively select the kernel image and configure command-line arguments. It then loads the kernel to memory.</P></LI>
<LI>
<P class=docList>GRUB (<A class=docLink href="http://www.gnu.org/software/grub" target=_blank>www.gnu.org/software/grub</A><A name="LILO in"></A>) is different from LILO in that the kernel image can live in any supported filesystem, and the boot sector need not be rewritten if the kernel image changes. GRUB has an extra stage 1.5 that understands the filesystem holding the boot images. Currently supported filesystems are EXT2, DOS FAT, BSD FFS, IBM JFS, SGI XFS, Minix, and Reiserfs. GRUB complies with the Multiboot specification, which allows any complying operating system to boot via any complying bootloader. You looked at a sample GRUB configuration file in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch02.html#ch02">Chapter 2</A>, "A Peek Inside the Kernel."</P></LI>
<LI>
<P class=docList>SYSLINUX (<A class=docLink href="http://syslinux.zytor.com/" target=_blank>http://syslinux.zytor.com/</A><A name="store the"></A>) is a no-frills Linux bootloader. It understands the FAT filesystem, so you can store the kernel image and the second stage bootloader on a FAT partition.</P></LI></UL></TD></TR></TBODY></TABLE></P><BR>
<P class=docText><A name=iddle1307></A><A name=iddle1311></A><A name=iddle1915></A><A name=iddle1919></A><A name=iddle1948></A><A name=iddle1952></A><A name=iddle1974></A><A name=iddle2164></A><A name=iddle2940></A><A name=iddle4201></A><A name="the design"></A>Giving due thought to the design and architecture of the bootloader suite lays a solid foundation for embedded software development. The key is to choose the right bootloader as your starting point. The benefits range from a shorter software development cycle to a feature-rich and robust device.