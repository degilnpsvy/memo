# Documentation/memory-barriers.txt 
<P></P>
<P>&nbsp;&nbsp;&nbsp; ============================<BR>&nbsp;&nbsp;&nbsp; LINUX KERNEL MEMORY BARRIERS<BR>&nbsp;&nbsp;&nbsp; ============================</P>
<P></P>
<P>By: David Howells &lt;<A href="mailto:dhowells@redhat.com">dhowells@redhat.com</A>&gt;<BR>&nbsp;&nbsp;&nbsp; Paul E. McKenney &lt;<A href="mailto:paulmck@linux.vnet.ibm.com">paulmck@linux.vnet.ibm.com</A>&gt;</P>
<P>Contents:</P>
<P>&nbsp;(*) Abstract memory access model.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; - Device operations.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Guarantees.</P>
<P>&nbsp;(*) What are memory barriers?</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; - Varieties of memory barrier.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - What may not be assumed about memory barriers?<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Data dependency barriers.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Control dependencies.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - SMP barrier pairing.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Examples of memory barrier sequences.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Read memory barriers vs load speculation.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Transitivity</P>
<P>&nbsp;(*) Explicit kernel barriers.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; - Compiler barrier.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - CPU memory barriers.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - MMIO write barrier.</P>
<P>&nbsp;(*) Implicit kernel memory barriers.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; - Locking functions.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Interrupt disabling functions.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Sleep and wake-up functions.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Miscellaneous functions.</P>
<P>&nbsp;(*) Inter-CPU locking barrier effects.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; - Locks vs memory accesses.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Locks vs I/O accesses.</P>
<P>&nbsp;(*) Where are memory barriers needed?</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; - Interprocessor interaction.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Atomic operations.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Accessing devices.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Interrupts.</P>
<P>&nbsp;(*) Kernel I/O barrier effects.</P>
<P>&nbsp;(*) Assumed minimum execution ordering model.</P>
<P>&nbsp;(*) The effects of the cpu cache.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; - Cache coherency.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Cache coherency vs DMA.<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Cache coherency vs MMIO.</P>
<P>&nbsp;(*) The things CPUs get up to.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; - And then there's the Alpha.</P>
<P>&nbsp;(*) Example uses.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; - Circular buffers.</P>
<P>&nbsp;(*) References.</P>
<P><BR>============================<BR>ABSTRACT MEMORY ACCESS MODEL<BR>============================</P>
<P>Consider the following abstract model of the system:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;&nbsp;+-------+&nbsp;&nbsp; :&nbsp;&nbsp; +--------+&nbsp;&nbsp; :&nbsp;&nbsp; +-------+<BR>&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;| CPU 1 |&lt;-----&gt;| Memory |&lt;-----&gt;| CPU 2 |<BR>&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;+-------+&nbsp;&nbsp; :&nbsp;&nbsp; +--------+&nbsp;&nbsp; :&nbsp;&nbsp; +-------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; +--------+&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------&gt;| Device |&lt;----------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; :<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; :<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; +--------+&nbsp;&nbsp; :<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :</P>
<P>Each CPU executes a program that generates memory access operations.&nbsp; In the<BR>abstract CPU, memory operation ordering is very relaxed, and a CPU may actually<BR>perform the memory operations in any order it likes, provided program causality<BR>appears to be maintained.&nbsp; Similarly, the compiler may also arrange the<BR>instructions it emits in any order it likes, provided it doesn't affect the<BR>apparent operation of the program.</P>
<P>So in the above diagram, the effects of the memory operations performed by a<BR>CPU are perceived by the rest of the system as the operations cross the<BR>interface between the CPU and rest of the system (the dotted lines).</P>
<P><BR>For example, consider the following sequence of events:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;CPU 2<BR>&nbsp;===============&nbsp;===============<BR>&nbsp;{ A == 1; B == 2 }<BR>&nbsp;A = 3;&nbsp;&nbsp;x = A;<BR>&nbsp;B = 4;&nbsp;&nbsp;y = B;</P>
<P>The set of accesses as seen by the memory system in the middle can be arranged<BR>in 24 different combinations:</P>
<P>&nbsp;STORE A=3,&nbsp;STORE B=4,&nbsp;x=LOAD A-&gt;3,&nbsp;y=LOAD B-&gt;4<BR>&nbsp;STORE A=3,&nbsp;STORE B=4,&nbsp;y=LOAD B-&gt;4,&nbsp;x=LOAD A-&gt;3<BR>&nbsp;STORE A=3,&nbsp;x=LOAD A-&gt;3,&nbsp;STORE B=4,&nbsp;y=LOAD B-&gt;4<BR>&nbsp;STORE A=3,&nbsp;x=LOAD A-&gt;3,&nbsp;y=LOAD B-&gt;2,&nbsp;STORE B=4<BR>&nbsp;STORE A=3,&nbsp;y=LOAD B-&gt;2,&nbsp;STORE B=4,&nbsp;x=LOAD A-&gt;3<BR>&nbsp;STORE A=3,&nbsp;y=LOAD B-&gt;2,&nbsp;x=LOAD A-&gt;3,&nbsp;STORE B=4<BR>&nbsp;STORE B=4,&nbsp;STORE A=3,&nbsp;x=LOAD A-&gt;3,&nbsp;y=LOAD B-&gt;4<BR>&nbsp;STORE B=4, ...<BR>&nbsp;...</P>
<P>and can thus result in four different combinations of values:</P>
<P>&nbsp;x == 1, y == 2<BR>&nbsp;x == 1, y == 4<BR>&nbsp;x == 3, y == 2<BR>&nbsp;x == 3, y == 4</P>
<P><BR>Furthermore, the stores committed by a CPU to the memory system may not be<BR>perceived by the loads made by another CPU in the same order as the stores were<BR>committed.</P>
<P><BR>As a further example, consider this sequence of events:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;CPU 2<BR>&nbsp;===============&nbsp;===============<BR>&nbsp;{ A == 1, B == 2, C = 3, P == &amp;A, Q == &amp;C }<BR>&nbsp;B = 4;&nbsp;&nbsp;Q = P;<BR>&nbsp;P = &amp;B&nbsp;&nbsp;D = *Q;</P>
<P>There is an obvious data dependency here, as the value loaded into D depends on<BR>the address retrieved from P by CPU 2.&nbsp; At the end of the sequence, any of the<BR>following results are possible:</P>
<P>&nbsp;(Q == &amp;A) and (D == 1)<BR>&nbsp;(Q == &amp;B) and (D == 2)<BR>&nbsp;(Q == &amp;B) and (D == 4)</P>
<P>Note that CPU 2 will never try and load C into D because the CPU will load P<BR>into Q before issuing the load of *Q.</P>
<P><BR>DEVICE OPERATIONS<BR>-----------------</P>
<P>Some devices present their control interfaces as collections of memory<BR>locations, but the order in which the control registers are accessed is very<BR>important.&nbsp; For instance, imagine an ethernet card with a set of internal<BR>registers that are accessed through an address port register (A) and a data<BR>port register (D).&nbsp; To read internal register 5, the following code might then<BR>be used:</P>
<P>&nbsp;*A = 5;<BR>&nbsp;x = *D;</P>
<P>but this might show up as either of the following two sequences:</P>
<P>&nbsp;STORE *A = 5, x = LOAD *D<BR>&nbsp;x = LOAD *D, STORE *A = 5</P>
<P>the second of which will almost certainly result in a malfunction, since it set<BR>the address _after_ attempting to read the register.</P>
<P><BR>GUARANTEES<BR>----------</P>
<P>There are some minimal guarantees that may be expected of a CPU:</P>
<P>&nbsp;(*) On any given CPU, dependent memory accesses will be issued in order, with<BR>&nbsp;&nbsp;&nbsp;&nbsp; respect to itself.&nbsp; This means that for:</P>
<P>&nbsp;Q = P; D = *Q;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; the CPU will issue the following memory operations:</P>
<P>&nbsp;Q = LOAD P, D = LOAD *Q</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; and always in that order.</P>
<P>&nbsp;(*) Overlapping loads and stores within a particular CPU will appear to be<BR>&nbsp;&nbsp;&nbsp;&nbsp; ordered within that CPU.&nbsp; This means that for:</P>
<P>&nbsp;a = *X; *X = b;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; the CPU will only issue the following sequence of memory operations:</P>
<P>&nbsp;a = LOAD *X, STORE *X = b</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; And for:</P>
<P>&nbsp;*X = c; d = *X;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; the CPU will only issue:</P>
<P>&nbsp;STORE *X = c, d = LOAD *X</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; (Loads and stores overlap if they are targeted at overlapping pieces of<BR>&nbsp;&nbsp;&nbsp;&nbsp; memory).</P>
<P>And there are a number of things that _must_ or _must_not_ be assumed:</P>
<P>&nbsp;(*) It _must_not_ be assumed that independent loads and stores will be issued<BR>&nbsp;&nbsp;&nbsp;&nbsp; in the order given.&nbsp; This means that for:</P>
<P>&nbsp;X = *A; Y = *B; *D = Z;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; we may get any of the following sequences:</P>
<P>&nbsp;X = LOAD *A,&nbsp; Y = LOAD *B,&nbsp; STORE *D = Z<BR>&nbsp;X = LOAD *A,&nbsp; STORE *D = Z, Y = LOAD *B<BR>&nbsp;Y = LOAD *B,&nbsp; X = LOAD *A,&nbsp; STORE *D = Z<BR>&nbsp;Y = LOAD *B,&nbsp; STORE *D = Z, X = LOAD *A<BR>&nbsp;STORE *D = Z, X = LOAD *A,&nbsp; Y = LOAD *B<BR>&nbsp;STORE *D = Z, Y = LOAD *B,&nbsp; X = LOAD *A</P>
<P>&nbsp;(*) It _must_ be assumed that overlapping memory accesses may be merged or<BR>&nbsp;&nbsp;&nbsp;&nbsp; discarded.&nbsp; This means that for:</P>
<P>&nbsp;X = *A; Y = *(A + 4);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; we may get any one of the following sequences:</P>
<P>&nbsp;X = LOAD *A; Y = LOAD *(A + 4);<BR>&nbsp;Y = LOAD *(A + 4); X = LOAD *A;<BR>&nbsp;{X, Y} = LOAD {*A, *(A + 4) };</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; And for:</P>
<P>&nbsp;*A = X; *(A + 4) = Y;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; we may get any of:</P>
<P>&nbsp;STORE *A = X; STORE *(A + 4) = Y;<BR>&nbsp;STORE *(A + 4) = Y; STORE *A = X;<BR>&nbsp;STORE {*A, *(A + 4) } = {X, Y};</P>
<P><BR>=========================<BR>WHAT ARE MEMORY BARRIERS?<BR>=========================</P>
<P>As can be seen above, independent memory operations are effectively performed<BR>in random order, but this can be a problem for CPU-CPU interaction and for I/O.<BR>What is required is some way of intervening to instruct the compiler and the<BR>CPU to restrict the order.</P>
<P>Memory barriers are such interventions.&nbsp; They impose a perceived partial<BR>ordering over the memory operations on either side of the barrier.</P>
<P>Such enforcement is important because the CPUs and other devices in a system<BR>can use a variety of tricks to improve performance, including reordering,<BR>deferral and combination of memory operations; speculative loads; speculative<BR>branch prediction and various types of caching.&nbsp; Memory barriers are used to<BR>override or suppress these tricks, allowing the code to sanely control the<BR>interaction of multiple CPUs and/or devices.</P>
<P><BR>VARIETIES OF MEMORY BARRIER<BR>---------------------------</P>
<P>Memory barriers come in four basic varieties:</P>
<P>&nbsp;(1) Write (or store) memory barriers.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; A write memory barrier gives a guarantee that all the STORE operations<BR>&nbsp;&nbsp;&nbsp;&nbsp; specified before the barrier will appear to happen before all the STORE<BR>&nbsp;&nbsp;&nbsp;&nbsp; operations specified after the barrier with respect to the other<BR>&nbsp;&nbsp;&nbsp;&nbsp; components of the system.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; A write barrier is a partial ordering on stores only; it is not required<BR>&nbsp;&nbsp;&nbsp;&nbsp; to have any effect on loads.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; A CPU can be viewed as committing a sequence of store operations to the<BR>&nbsp;&nbsp;&nbsp;&nbsp; memory system as time progresses.&nbsp; All stores before a write barrier will<BR>&nbsp;&nbsp;&nbsp;&nbsp; occur in the sequence _before_ all the stores after the write barrier.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; [!] Note that write barriers should normally be paired with read or data<BR>&nbsp;&nbsp;&nbsp;&nbsp; dependency barriers; see the "SMP barrier pairing" subsection.</P>
<P><BR>&nbsp;(2) Data dependency barriers.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; A data dependency barrier is a weaker form of read barrier.&nbsp; In the case<BR>&nbsp;&nbsp;&nbsp;&nbsp; where two loads are performed such that the second depends on the result<BR>&nbsp;&nbsp;&nbsp;&nbsp; of the first (eg: the first load retrieves the address to which the second<BR>&nbsp;&nbsp;&nbsp;&nbsp; load will be directed), a data dependency barrier would be required to<BR>&nbsp;&nbsp;&nbsp;&nbsp; make sure that the target of the second load is updated before the address<BR>&nbsp;&nbsp;&nbsp;&nbsp; obtained by the first load is accessed.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; A data dependency barrier is a partial ordering on interdependent loads<BR>&nbsp;&nbsp;&nbsp;&nbsp; only; it is not required to have any effect on stores, independent loads<BR>&nbsp;&nbsp;&nbsp;&nbsp; or overlapping loads.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; As mentioned in (1), the other CPUs in the system can be viewed as<BR>&nbsp;&nbsp;&nbsp;&nbsp; committing sequences of stores to the memory system that the CPU being<BR>&nbsp;&nbsp;&nbsp;&nbsp; considered can then perceive.&nbsp; A data dependency barrier issued by the CPU<BR>&nbsp;&nbsp;&nbsp;&nbsp; under consideration guarantees that for any load preceding it, if that<BR>&nbsp;&nbsp;&nbsp;&nbsp; load touches one of a sequence of stores from another CPU, then by the<BR>&nbsp;&nbsp;&nbsp;&nbsp; time the barrier completes, the effects of all the stores prior to that<BR>&nbsp;&nbsp;&nbsp;&nbsp; touched by the load will be perceptible to any loads issued after the data<BR>&nbsp;&nbsp;&nbsp;&nbsp; dependency barrier.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; See the "Examples of memory barrier sequences" subsection for diagrams<BR>&nbsp;&nbsp;&nbsp;&nbsp; showing the ordering constraints.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; [!] Note that the first load really has to have a _data_ dependency and<BR>&nbsp;&nbsp;&nbsp;&nbsp; not a control dependency.&nbsp; If the address for the second load is dependent<BR>&nbsp;&nbsp;&nbsp;&nbsp; on the first load, but the dependency is through a conditional rather than<BR>&nbsp;&nbsp;&nbsp;&nbsp; actually loading the address itself, then it's a _control_ dependency and<BR>&nbsp;&nbsp;&nbsp;&nbsp; a full read barrier or better is required.&nbsp; See the "Control dependencies"<BR>&nbsp;&nbsp;&nbsp;&nbsp; subsection for more information.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; [!] Note that data dependency barriers should normally be paired with<BR>&nbsp;&nbsp;&nbsp;&nbsp; write barriers; see the "SMP barrier pairing" subsection.</P>
<P><BR>&nbsp;(3) Read (or load) memory barriers.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; A read barrier is a data dependency barrier plus a guarantee that all the<BR>&nbsp;&nbsp;&nbsp;&nbsp; LOAD operations specified before the barrier will appear to happen before<BR>&nbsp;&nbsp;&nbsp;&nbsp; all the LOAD operations specified after the barrier with respect to the<BR>&nbsp;&nbsp;&nbsp;&nbsp; other components of the system.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; A read barrier is a partial ordering on loads only; it is not required to<BR>&nbsp;&nbsp;&nbsp;&nbsp; have any effect on stores.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Read memory barriers imply data dependency barriers, and so can substitute<BR>&nbsp;&nbsp;&nbsp;&nbsp; for them.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; [!] Note that read barriers should normally be paired with write barriers;<BR>&nbsp;&nbsp;&nbsp;&nbsp; see the "SMP barrier pairing" subsection.</P>
<P><BR>&nbsp;(4) General memory barriers.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; A general memory barrier gives a guarantee that all the LOAD and STORE<BR>&nbsp;&nbsp;&nbsp;&nbsp; operations specified before the barrier will appear to happen before all<BR>&nbsp;&nbsp;&nbsp;&nbsp; the LOAD and STORE operations specified after the barrier with respect to<BR>&nbsp;&nbsp;&nbsp;&nbsp; the other components of the system.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; A general memory barrier is a partial ordering over both loads and stores.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; General memory barriers imply both read and write memory barriers, and so<BR>&nbsp;&nbsp;&nbsp;&nbsp; can substitute for either.</P>
<P><BR>And a couple of implicit varieties:</P>
<P>&nbsp;(5) LOCK operations.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; This acts as a one-way permeable barrier.&nbsp; It guarantees that all memory<BR>&nbsp;&nbsp;&nbsp;&nbsp; operations after the LOCK operation will appear to happen after the LOCK<BR>&nbsp;&nbsp;&nbsp;&nbsp; operation with respect to the other components of the system.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Memory operations that occur before a LOCK operation may appear to happen<BR>&nbsp;&nbsp;&nbsp;&nbsp; after it completes.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; A LOCK operation should almost always be paired with an UNLOCK operation.</P>
<P><BR>&nbsp;(6) UNLOCK operations.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; This also acts as a one-way permeable barrier.&nbsp; It guarantees that all<BR>&nbsp;&nbsp;&nbsp;&nbsp; memory operations before the UNLOCK operation will appear to happen before<BR>&nbsp;&nbsp;&nbsp;&nbsp; the UNLOCK operation with respect to the other components of the system.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Memory operations that occur after an UNLOCK operation may appear to<BR>&nbsp;&nbsp;&nbsp;&nbsp; happen before it completes.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; LOCK and UNLOCK operations are guaranteed to appear with respect to each<BR>&nbsp;&nbsp;&nbsp;&nbsp; other strictly in the order specified.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; The use of LOCK and UNLOCK operations generally precludes the need for<BR>&nbsp;&nbsp;&nbsp;&nbsp; other sorts of memory barrier (but note the exceptions mentioned in the<BR>&nbsp;&nbsp;&nbsp;&nbsp; subsection "MMIO write barrier").</P>
<P><BR>Memory barriers are only required where there's a possibility of interaction<BR>between two CPUs or between a CPU and a device.&nbsp; If it can be guaranteed that<BR>there won't be any such interaction in any particular piece of code, then<BR>memory barriers are unnecessary in that piece of code.</P>
<P><BR>Note that these are the _minimum_ guarantees.&nbsp; Different architectures may give<BR>more substantial guarantees, but they may _not_ be relied upon outside of arch<BR>specific code.</P>
<P><BR>WHAT MAY NOT BE ASSUMED ABOUT MEMORY BARRIERS?<BR>----------------------------------------------</P>
<P>There are certain things that the Linux kernel memory barriers do not guarantee:</P>
<P>&nbsp;(*) There is no guarantee that any of the memory accesses specified before a<BR>&nbsp;&nbsp;&nbsp;&nbsp; memory barrier will be _complete_ by the completion of a memory barrier<BR>&nbsp;&nbsp;&nbsp;&nbsp; instruction; the barrier can be considered to draw a line in that CPU's<BR>&nbsp;&nbsp;&nbsp;&nbsp; access queue that accesses of the appropriate type may not cross.</P>
<P>&nbsp;(*) There is no guarantee that issuing a memory barrier on one CPU will have<BR>&nbsp;&nbsp;&nbsp;&nbsp; any direct effect on another CPU or any other hardware in the system.&nbsp; The<BR>&nbsp;&nbsp;&nbsp;&nbsp; indirect effect will be the order in which the second CPU sees the effects<BR>&nbsp;&nbsp;&nbsp;&nbsp; of the first CPU's accesses occur, but see the next point:</P>
<P>&nbsp;(*) There is no guarantee that a CPU will see the correct order of effects<BR>&nbsp;&nbsp;&nbsp;&nbsp; from a second CPU's accesses, even _if_ the second CPU uses a memory<BR>&nbsp;&nbsp;&nbsp;&nbsp; barrier, unless the first CPU _also_ uses a matching memory barrier (see<BR>&nbsp;&nbsp;&nbsp;&nbsp; the subsection on "SMP Barrier Pairing").</P>
<P>&nbsp;(*) There is no guarantee that some intervening piece of off-the-CPU<BR>&nbsp;&nbsp;&nbsp;&nbsp; hardware[*] will not reorder the memory accesses.&nbsp; CPU cache coherency<BR>&nbsp;&nbsp;&nbsp;&nbsp; mechanisms should propagate the indirect effects of a memory barrier<BR>&nbsp;&nbsp;&nbsp;&nbsp; between CPUs, but might not do so in order.</P>
<P>&nbsp;[*] For information on bus mastering DMA and coherency please read:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Documentation/PCI/pci.txt<BR>&nbsp;&nbsp;&nbsp;&nbsp; Documentation/DMA-API-HOWTO.txt<BR>&nbsp;&nbsp;&nbsp;&nbsp; Documentation/DMA-API.txt</P>
<P><BR>DATA DEPENDENCY BARRIERS<BR>------------------------</P>
<P>The usage requirements of data dependency barriers are a little subtle, and<BR>it's not always obvious that they're needed.&nbsp; To illustrate, consider the<BR>following sequence of events:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;CPU 2<BR>&nbsp;===============&nbsp;===============<BR>&nbsp;{ A == 1, B == 2, C = 3, P == &amp;A, Q == &amp;C }<BR>&nbsp;B = 4;<BR>&nbsp;&lt;write barrier&gt;<BR>&nbsp;P = &amp;B<BR>&nbsp;&nbsp;&nbsp;Q = P;<BR>&nbsp;&nbsp;&nbsp;D = *Q;</P>
<P>There's a clear data dependency here, and it would seem that by the end of the<BR>sequence, Q must be either &amp;A or &amp;B, and that:</P>
<P>&nbsp;(Q == &amp;A) implies (D == 1)<BR>&nbsp;(Q == &amp;B) implies (D == 4)</P>
<P>But!&nbsp; CPU 2's perception of P may be updated _before_ its perception of B, thus<BR>leading to the following situation:</P>
<P>&nbsp;(Q == &amp;B) and (D == 2) ????</P>
<P>Whilst this may seem like a failure of coherency or causality maintenance, it<BR>isn't, and this behaviour can be observed on certain real CPUs (such as the DEC<BR>Alpha).</P>
<P>To deal with this, a data dependency barrier or better must be inserted<BR>between the address load and the data load:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;CPU 2<BR>&nbsp;===============&nbsp;===============<BR>&nbsp;{ A == 1, B == 2, C = 3, P == &amp;A, Q == &amp;C }<BR>&nbsp;B = 4;<BR>&nbsp;&lt;write barrier&gt;<BR>&nbsp;P = &amp;B<BR>&nbsp;&nbsp;&nbsp;Q = P;<BR>&nbsp;&nbsp;&nbsp;&lt;data dependency barrier&gt;<BR>&nbsp;&nbsp;&nbsp;D = *Q;</P>
<P>This enforces the occurrence of one of the two implications, and prevents the<BR>third possibility from arising.</P>
<P>[!] Note that this extremely counterintuitive situation arises most easily on<BR>machines with split caches, so that, for example, one cache bank processes<BR>even-numbered cache lines and the other bank processes odd-numbered cache<BR>lines.&nbsp; The pointer P might be stored in an odd-numbered cache line, and the<BR>variable B might be stored in an even-numbered cache line.&nbsp; Then, if the<BR>even-numbered bank of the reading CPU's cache is extremely busy while the<BR>odd-numbered bank is idle, one can see the new value of the pointer P (&amp;B),<BR>but the old value of the variable B (2).</P>
<P><BR>Another example of where data dependency barriers might by required is where a<BR>number is read from memory and then used to calculate the index for an array<BR>access:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;CPU 2<BR>&nbsp;===============&nbsp;===============<BR>&nbsp;{ M[0] == 1, M[1] == 2, M[3] = 3, P == 0, Q == 3 }<BR>&nbsp;M[1] = 4;<BR>&nbsp;&lt;write barrier&gt;<BR>&nbsp;P = 1<BR>&nbsp;&nbsp;&nbsp;Q = P;<BR>&nbsp;&nbsp;&nbsp;&lt;data dependency barrier&gt;<BR>&nbsp;&nbsp;&nbsp;D = M[Q];</P>
<P><BR>The data dependency barrier is very important to the RCU system, for example.<BR>See rcu_dereference() in include/linux/rcupdate.h.&nbsp; This permits the current<BR>target of an RCU'd pointer to be replaced with a new modified target, without<BR>the replacement target appearing to be incompletely initialised.</P>
<P>See also the subsection on "Cache Coherency" for a more thorough example.</P>
<P><BR>CONTROL DEPENDENCIES<BR>--------------------</P>
<P>A control dependency requires a full read memory barrier, not simply a data<BR>dependency barrier to make it work correctly.&nbsp; Consider the following bit of<BR>code:</P>
<P>&nbsp;q = &amp;a;<BR>&nbsp;if (p)<BR>&nbsp;&nbsp;q = &amp;b;<BR>&nbsp;&lt;data dependency barrier&gt;<BR>&nbsp;x = *q;</P>
<P>This will not have the desired effect because there is no actual data<BR>dependency, but rather a control dependency that the CPU may short-circuit by<BR>attempting to predict the outcome in advance.&nbsp; In such a case what's actually<BR>required is:</P>
<P>&nbsp;q = &amp;a;<BR>&nbsp;if (p)<BR>&nbsp;&nbsp;q = &amp;b;<BR>&nbsp;&lt;read barrier&gt;<BR>&nbsp;x = *q;</P>
<P><BR>SMP BARRIER PAIRING<BR>-------------------</P>
<P>When dealing with CPU-CPU interactions, certain types of memory barrier should<BR>always be paired.&nbsp; A lack of appropriate pairing is almost certainly an error.</P>
<P>A write barrier should always be paired with a data dependency barrier or read<BR>barrier, though a general barrier would also be viable.&nbsp; Similarly a read<BR>barrier or a data dependency barrier should always be paired with at least an<BR>write barrier, though, again, a general barrier is viable:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;CPU 2<BR>&nbsp;===============&nbsp;===============<BR>&nbsp;a = 1;<BR>&nbsp;&lt;write barrier&gt;<BR>&nbsp;b = 2;&nbsp;&nbsp;x = b;<BR>&nbsp;&nbsp;&nbsp;&lt;read barrier&gt;<BR>&nbsp;&nbsp;&nbsp;y = a;</P>
<P>Or:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;CPU 2<BR>&nbsp;===============&nbsp;===============================<BR>&nbsp;a = 1;<BR>&nbsp;&lt;write barrier&gt;<BR>&nbsp;b = &amp;a;&nbsp;&nbsp;x = b;<BR>&nbsp;&nbsp;&nbsp;&lt;data dependency barrier&gt;<BR>&nbsp;&nbsp;&nbsp;y = *x;</P>
<P>Basically, the read barrier always has to be there, even though it can be of<BR>the "weaker" type.</P>
<P>[!] Note that the stores before the write barrier would normally be expected to<BR>match the loads after the read barrier or the data dependency barrier, and vice<BR>versa:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPU 2<BR>&nbsp;===============&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ===============<BR>&nbsp;a = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }----&nbsp;&nbsp; ---&gt;{&nbsp; v = c<BR>&nbsp;b = 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; \ /&nbsp;&nbsp;&nbsp; {&nbsp; w = d<BR>&nbsp;&lt;write barrier&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;read barrier&gt;<BR>&nbsp;c = 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp; {&nbsp; x = a;<BR>&nbsp;d = 4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }----&nbsp;&nbsp; ---&gt;{&nbsp; y = b;</P>
<P><BR>EXAMPLES OF MEMORY BARRIER SEQUENCES<BR>------------------------------------</P>
<P>Firstly, write barriers act as partial orderings on store operations.<BR>Consider the following sequence of events:</P>
<P>&nbsp;CPU 1<BR>&nbsp;=======================<BR>&nbsp;STORE A = 1<BR>&nbsp;STORE B = 2<BR>&nbsp;STORE C = 3<BR>&nbsp;&lt;write barrier&gt;<BR>&nbsp;STORE D = 4<BR>&nbsp;STORE E = 5</P>
<P>This sequence of events is committed to the memory coherence system in an order<BR>that the rest of the system might perceive as the unordered set of { STORE A,<BR>STORE B, STORE C } all occurring before the unordered set of { STORE D, STORE E<BR>}:</P>
<P>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| C=3&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp; /\<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp; }-----&nbsp; \&nbsp; -----&gt; Events perceptible to<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp;&nbsp; | A=1&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the rest of the system<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;| CPU 1 |&nbsp; :&nbsp;&nbsp;&nbsp; | B=2&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; wwwwwwwwwwwwwwww }&nbsp;&nbsp; &lt;--- At this point the write barrier<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requires all stores prior to the<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp;&nbsp; | E=5&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; barrier to be committed before<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; further stores may take place<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| D=4&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+<BR>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Sequence in which stores are committed to the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | memory system by CPU 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V</P>
<P><BR>Secondly, data dependency barriers act as partial orderings on data-dependent<BR>loads.&nbsp; Consider the following sequence of events:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;CPU 2<BR>&nbsp;=======================&nbsp;=======================<BR>&nbsp;&nbsp;{ B = 7; X = 9; Y = 8; C = &amp;Y }<BR>&nbsp;STORE A = 1<BR>&nbsp;STORE B = 2<BR>&nbsp;&lt;write barrier&gt;<BR>&nbsp;STORE C = &amp;B&nbsp;&nbsp;LOAD X<BR>&nbsp;STORE D = 4&nbsp;&nbsp;LOAD C (gets &amp;B)<BR>&nbsp;&nbsp;&nbsp;&nbsp;LOAD *C (reads B)</P>
<P>Without intervention, CPU 2 may perceive the events on CPU 1 in some<BR>effectively random order, despite the write barrier issued by CPU 1:</P>
<P>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp; | Sequence of update<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| B=2&nbsp; |-----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| Y-&gt;8&nbsp; |&nbsp; | of perception on<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp; | CPU 2<BR>&nbsp;| CPU 1 |&nbsp; :&nbsp;&nbsp;&nbsp; | A=1&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| C-&gt;&amp;Y |&nbsp; V<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; wwwwwwwwwwwwwwww&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp;&nbsp; | C=&amp;B |---&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp; \&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| D=4&nbsp; |&nbsp;&nbsp;&nbsp; -----------&gt;| C-&gt;&amp;B |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | CPU 2 |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp; Apparently incorrect ---&gt;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | B-&gt;7&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp; perception of B (!)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp; The load of X holds ---&gt;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | X-&gt;9&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp; up the maintenance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp; of coherence of B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -----&gt;| B-&gt;2&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :</P>
<P><BR>In the above example, CPU 2 perceives that B is 7, despite the load of *C<BR>(which would be B) coming after the LOAD of C.</P>
<P>If, however, a data dependency barrier were to be placed between the load of C<BR>and the load of *C (ie: B) on CPU 2:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;CPU 2<BR>&nbsp;=======================&nbsp;=======================<BR>&nbsp;&nbsp;{ B = 7; X = 9; Y = 8; C = &amp;Y }<BR>&nbsp;STORE A = 1<BR>&nbsp;STORE B = 2<BR>&nbsp;&lt;write barrier&gt;<BR>&nbsp;STORE C = &amp;B&nbsp;&nbsp;LOAD X<BR>&nbsp;STORE D = 4&nbsp;&nbsp;LOAD C (gets &amp;B)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&lt;data dependency barrier&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;LOAD *C (reads B)</P>
<P>then the following will occur:</P>
<P>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| B=2&nbsp; |-----&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| Y-&gt;8&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;| CPU 1 |&nbsp; :&nbsp;&nbsp;&nbsp; | A=1&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| C-&gt;&amp;Y |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; wwwwwwwwwwwwwwww&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp;&nbsp; | C=&amp;B |---&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp; \&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| D=4&nbsp; |&nbsp;&nbsp;&nbsp; -----------&gt;| C-&gt;&amp;B |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | CPU 2 |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | X-&gt;9&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp; Makes sure all effects ---&gt;&nbsp;&nbsp; \&nbsp;&nbsp; ddddddddddddddddd&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp; prior to the store of C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp; are perceptible to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -----&gt;| B-&gt;2&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp; subsequent loads&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+</P>
<P><BR>And thirdly, a read barrier acts as a partial order on loads.&nbsp; Consider the<BR>following sequence of events:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;CPU 2<BR>&nbsp;=======================&nbsp;=======================<BR>&nbsp;&nbsp;{ A = 0, B = 9 }<BR>&nbsp;STORE A=1<BR>&nbsp;&lt;write barrier&gt;<BR>&nbsp;STORE B=2<BR>&nbsp;&nbsp;&nbsp;&nbsp;LOAD B<BR>&nbsp;&nbsp;&nbsp;&nbsp;LOAD A</P>
<P>Without intervention, CPU 2 may then choose to perceive the events on CPU 1 in<BR>some effectively random order, despite the write barrier issued by CPU 1:</P>
<P>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| A=1&nbsp; |------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| A-&gt;0&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;| CPU 1 |&nbsp;&nbsp; wwwwwwwwwwwwwwww&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp; ---&gt;| B-&gt;9&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| B=2&nbsp; |---&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------&gt;| B-&gt;2&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | CPU 2 |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | A-&gt;0&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----&gt;| A-&gt;1&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :</P>
<P><BR>If, however, a read barrier were to be placed between the load of B and the<BR>load of A on CPU 2:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;CPU 2<BR>&nbsp;=======================&nbsp;=======================<BR>&nbsp;&nbsp;{ A = 0, B = 9 }<BR>&nbsp;STORE A=1<BR>&nbsp;&lt;write barrier&gt;<BR>&nbsp;STORE B=2<BR>&nbsp;&nbsp;&nbsp;&nbsp;LOAD B<BR>&nbsp;&nbsp;&nbsp;&nbsp;&lt;read barrier&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;LOAD A</P>
<P>then the partial ordering imposed by CPU 1 will be perceived correctly by CPU<BR>2:</P>
<P>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| A=1&nbsp; |------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| A-&gt;0&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;| CPU 1 |&nbsp;&nbsp; wwwwwwwwwwwwwwww&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp; ---&gt;| B-&gt;9&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| B=2&nbsp; |---&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------&gt;| B-&gt;2&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | CPU 2 |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp; At this point the read ----&gt;&nbsp;&nbsp; \&nbsp; rrrrrrrrrrrrrrrrr&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp; barrier causes all effects&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp; prior to the storage of B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----&gt;| A-&gt;1&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp; to be perceptible to CPU 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+</P>
<P><BR>To illustrate this more completely, consider what could happen if the code<BR>contained a load of A either side of the read barrier:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;CPU 2<BR>&nbsp;=======================&nbsp;=======================<BR>&nbsp;&nbsp;{ A = 0, B = 9 }<BR>&nbsp;STORE A=1<BR>&nbsp;&lt;write barrier&gt;<BR>&nbsp;STORE B=2<BR>&nbsp;&nbsp;&nbsp;&nbsp;LOAD B<BR>&nbsp;&nbsp;&nbsp;&nbsp;LOAD A [first load of A]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&lt;read barrier&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;LOAD A [second load of A]</P>
<P>Even though the two loads of A both occur after the load of B, they may both<BR>come up with different values:</P>
<P>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| A=1&nbsp; |------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| A-&gt;0&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;| CPU 1 |&nbsp;&nbsp; wwwwwwwwwwwwwwww&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp; ---&gt;| B-&gt;9&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| B=2&nbsp; |---&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------&gt;| B-&gt;2&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | CPU 2 |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | A-&gt;0&nbsp; |------&gt;| 1st&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp; At this point the read ----&gt;&nbsp;&nbsp; \&nbsp; rrrrrrrrrrrrrrrrr&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp; barrier causes all effects&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp; prior to the storage of B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----&gt;| A-&gt;1&nbsp; |------&gt;| 2nd&nbsp;&nbsp; |<BR>&nbsp;&nbsp; to be perceptible to CPU 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+</P>
<P><BR>But it may be that the update to A from CPU 1 becomes perceptible to CPU 2<BR>before the read barrier completes anyway:</P>
<P>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| A=1&nbsp; |------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| A-&gt;0&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;| CPU 1 |&nbsp;&nbsp; wwwwwwwwwwwwwwww&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp; ---&gt;| B-&gt;9&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------&gt;| B=2&nbsp; |---&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;+-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----------&gt;| B-&gt;2&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | CPU 2 |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----&gt;| A-&gt;1&nbsp; |------&gt;| 1st&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rrrrrrrrrrrrrrrrr&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | A-&gt;1&nbsp; |------&gt;| 2nd&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+</P>
<P><BR>The guarantee is that the second load will always come up with A == 1 if the<BR>load of B came up with B == 2.&nbsp; No such guarantee exists for the first load of<BR>A; that may come up with either A == 0 or A == 1.</P>
<P><BR>READ MEMORY BARRIERS VS LOAD SPECULATION<BR>----------------------------------------</P>
<P>Many CPUs speculate with loads: that is they see that they will need to load an<BR>item from memory, and they find a time where they're not using the bus for any<BR>other loads, and so do the load in advance - even though they haven't actually<BR>got to that point in the instruction execution flow yet.&nbsp; This permits the<BR>actual load instruction to potentially complete immediately because the CPU<BR>already has the value to hand.</P>
<P>It may turn out that the CPU didn't actually need the value - perhaps because a<BR>branch circumvented the load - in which case it can discard the value or just<BR>cache it for later use.</P>
<P>Consider:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;CPU 2<BR>&nbsp;=======================&nbsp;=======================<BR>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;LOAD B<BR>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;DIVIDE&nbsp;&nbsp;} Divide instructions generally<BR>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;DIVIDE&nbsp;&nbsp;} take a long time to perform<BR>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;LOAD A</P>
<P>Which might appear as this:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| B-&gt;2&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | CPU 2 |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :DIVIDE |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;The CPU being busy doing a ---&gt;&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| A-&gt;0&nbsp; |~~~~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;division speculates on the&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp; ~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;LOAD of A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; ~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :DIVIDE |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; ~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;Once the divisions are complete --&gt;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; ~--&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;the CPU can then perform the&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;LOAD with immediate effect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+</P>
<P><BR>Placing a read barrier or a data dependency barrier just before the second<BR>load:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;CPU 2<BR>&nbsp;=======================&nbsp;=======================<BR>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;LOAD B<BR>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;DIVIDE<BR>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;DIVIDE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&lt;read barrier&gt;<BR>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;LOAD A</P>
<P>will force any value speculatively obtained to be reconsidered to an extent<BR>dependent on the type of barrier used.&nbsp; If there was no change made to the<BR>speculated memory location, then the speculated value will just be used:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| B-&gt;2&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | CPU 2 |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :DIVIDE |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;The CPU being busy doing a ---&gt;&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| A-&gt;0&nbsp; |~~~~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;division speculates on the&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp; ~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;LOAD of A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; ~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :DIVIDE |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; ~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; ~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rrrrrrrrrrrrrrrr~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; ~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; ~--&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+</P>
<P><BR>but if there was an update or an invalidation from another CPU pending, then<BR>the speculation will be cancelled and the value reloaded:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| B-&gt;2&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | CPU 2 |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :DIVIDE |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;The CPU being busy doing a ---&gt;&nbsp;&nbsp;&nbsp;&nbsp; ---&gt;| A-&gt;0&nbsp; |~~~~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;division speculates on the&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp; ~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;LOAD of A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; ~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :DIVIDE |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; ~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp; ~&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rrrrrrrrrrrrrrrrr&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;The speculation is discarded ---&gt;&nbsp;&nbsp; ---&gt;| A-&gt;1&nbsp; |------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;and an updated value is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;retrieved&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+</P>
<P><BR>TRANSITIVITY<BR>------------</P>
<P>Transitivity is a deeply intuitive notion about ordering that is not<BR>always provided by real computer systems.&nbsp; The following example<BR>demonstrates transitivity (also called "cumulativity"):</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;CPU 2&nbsp;&nbsp;&nbsp;CPU 3<BR>&nbsp;=======================&nbsp;=======================&nbsp;=======================<BR>&nbsp;&nbsp;{ X = 0, Y = 0 }<BR>&nbsp;STORE X=1&nbsp;&nbsp;LOAD X&nbsp;&nbsp;&nbsp;STORE Y=1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&lt;general barrier&gt;&nbsp;&lt;general barrier&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;LOAD Y&nbsp;&nbsp;&nbsp;LOAD X</P>
<P>Suppose that CPU 2's load from X returns 1 and its load from Y returns 0.<BR>This indicates that CPU 2's load from X in some sense follows CPU 1's<BR>store to X and that CPU 2's load from Y in some sense preceded CPU 3's<BR>store to Y.&nbsp; The question is then "Can CPU 3's load from X return 0?"</P>
<P>Because CPU 2's load from X in some sense came after CPU 1's store, it<BR>is natural to expect that CPU 3's load from X must therefore return 1.<BR>This expectation is an example of transitivity: if a load executing on<BR>CPU A follows a load from the same variable executing on CPU B, then<BR>CPU A's load must either return the same value that CPU B's load did,<BR>or must return some later value.</P>
<P>In the Linux kernel, use of general memory barriers guarantees<BR>transitivity.&nbsp; Therefore, in the above example, if CPU 2's load from X<BR>returns 1 and its load from Y returns 0, then CPU 3's load from X must<BR>also return 1.</P>
<P>However, transitivity is -not- guaranteed for read or write barriers.<BR>For example, suppose that CPU 2's general barrier in the above example<BR>is changed to a read barrier as shown below:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;CPU 2&nbsp;&nbsp;&nbsp;CPU 3<BR>&nbsp;=======================&nbsp;=======================&nbsp;=======================<BR>&nbsp;&nbsp;{ X = 0, Y = 0 }<BR>&nbsp;STORE X=1&nbsp;&nbsp;LOAD X&nbsp;&nbsp;&nbsp;STORE Y=1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&lt;read barrier&gt;&nbsp;&nbsp;&lt;general barrier&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;LOAD Y&nbsp;&nbsp;&nbsp;LOAD X</P>
<P>This substitution destroys transitivity: in this example, it is perfectly<BR>legal for CPU 2's load from X to return 1, its load from Y to return 0,<BR>and CPU 3's load from X to return 0.</P>
<P>The key point is that although CPU 2's read barrier orders its pair<BR>of loads, it does not guarantee to order CPU 1's store.&nbsp; Therefore, if<BR>this example runs on a system where CPUs 1 and 2 share a store buffer<BR>or a level of cache, CPU 2 might have early access to CPU 1's writes.<BR>General barriers are therefore required to ensure that all CPUs agree<BR>on the combined order of CPU 1's and CPU 2's accesses.</P>
<P>To reiterate, if your code requires transitivity, use general barriers<BR>throughout.</P>
<P><BR>========================<BR>EXPLICIT KERNEL BARRIERS<BR>========================</P>
<P>The Linux kernel has a variety of different barriers that act at different<BR>levels:</P>
<P>&nbsp; (*) Compiler barrier.</P>
<P>&nbsp; (*) CPU memory barriers.</P>
<P>&nbsp; (*) MMIO write barrier.</P>
<P><BR>COMPILER BARRIER<BR>----------------</P>
<P>The Linux kernel has an explicit compiler barrier function that prevents the<BR>compiler from moving the memory accesses either side of it to the other side:</P>
<P>&nbsp;barrier();</P>
<P>This is a general barrier - lesser varieties of compiler barrier do not exist.</P>
<P>The compiler barrier has no direct effect on the CPU, which may then reorder<BR>things however it wishes.</P>
<P><BR>CPU MEMORY BARRIERS<BR>-------------------</P>
<P>The Linux kernel has eight basic CPU memory barriers:</P>
<P>&nbsp;TYPE&nbsp;&nbsp;MANDATORY&nbsp;&nbsp;SMP CONDITIONAL<BR>&nbsp;===============&nbsp;=======================&nbsp;===========================<BR>&nbsp;GENERAL&nbsp;&nbsp;mb()&nbsp;&nbsp;&nbsp;smp_mb()<BR>&nbsp;WRITE&nbsp;&nbsp;wmb()&nbsp;&nbsp;&nbsp;smp_wmb()<BR>&nbsp;READ&nbsp;&nbsp;rmb()&nbsp;&nbsp;&nbsp;smp_rmb()<BR>&nbsp;DATA DEPENDENCY&nbsp;read_barrier_depends()&nbsp;smp_read_barrier_depends()</P>
<P><BR>All memory barriers except the data dependency barriers imply a compiler<BR>barrier. Data dependencies do not impose any additional compiler ordering.</P>
<P>Aside: In the case of data dependencies, the compiler would be expected to<BR>issue the loads in the correct order (eg. `a[b]` would have to load the value<BR>of b before loading a[b]), however there is no guarantee in the C specification<BR>that the compiler may not speculate the value of b (eg. is equal to 1) and load<BR>a before b (eg. tmp = a[1]; if (b != 1) tmp = a[b]; ). There is also the<BR>problem of a compiler reloading b after having loaded a[b], thus having a newer<BR>copy of b than a[b]. A consensus has not yet been reached about these problems,<BR>however the ACCESS_ONCE macro is a good place to start looking.</P>
<P>SMP memory barriers are reduced to compiler barriers on uniprocessor compiled<BR>systems because it is assumed that a CPU will appear to be self-consistent,<BR>and will order overlapping accesses correctly with respect to itself.</P>
<P>[!] Note that SMP memory barriers _must_ be used to control the ordering of<BR>references to shared memory on SMP systems, though the use of locking instead<BR>is sufficient.</P>
<P>Mandatory barriers should not be used to control SMP effects, since mandatory<BR>barriers unnecessarily impose overhead on UP systems. They may, however, be<BR>used to control MMIO effects on accesses through relaxed memory I/O windows.<BR>These are required even on non-SMP systems as they affect the order in which<BR>memory operations appear to a device by prohibiting both the compiler and the<BR>CPU from reordering them.</P>
<P><BR>There are some more advanced barrier functions:</P>
<P>&nbsp;(*) set_mb(var, value)</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; This assigns the value to the variable and then inserts a full memory<BR>&nbsp;&nbsp;&nbsp;&nbsp; barrier after it, depending on the function.&nbsp; It isn't guaranteed to<BR>&nbsp;&nbsp;&nbsp;&nbsp; insert anything more than a compiler barrier in a UP compilation.</P>
<P><BR>&nbsp;(*) smp_mb__before_atomic_dec();<BR>&nbsp;(*) smp_mb__after_atomic_dec();<BR>&nbsp;(*) smp_mb__before_atomic_inc();<BR>&nbsp;(*) smp_mb__after_atomic_inc();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; These are for use with atomic add, subtract, increment and decrement<BR>&nbsp;&nbsp;&nbsp;&nbsp; functions that don't return a value, especially when used for reference<BR>&nbsp;&nbsp;&nbsp;&nbsp; counting.&nbsp; These functions do not imply memory barriers.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; As an example, consider a piece of code that marks an object as being dead<BR>&nbsp;&nbsp;&nbsp;&nbsp; and then decrements the object's reference count:</P>
<P>&nbsp;obj-&gt;dead = 1;<BR>&nbsp;smp_mb__before_atomic_dec();<BR>&nbsp;atomic_dec(&amp;obj-&gt;ref_count);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; This makes sure that the death mark on the object is perceived to be set<BR>&nbsp;&nbsp;&nbsp;&nbsp; *before* the reference counter is decremented.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; See Documentation/atomic_ops.txt for more information.&nbsp; See the "Atomic<BR>&nbsp;&nbsp;&nbsp;&nbsp; operations" subsection for information on where to use these.</P>
<P><BR>&nbsp;(*) smp_mb__before_clear_bit(void);<BR>&nbsp;(*) smp_mb__after_clear_bit(void);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; These are for use similar to the atomic inc/dec barriers.&nbsp; These are<BR>&nbsp;&nbsp;&nbsp;&nbsp; typically used for bitwise unlocking operations, so care must be taken as<BR>&nbsp;&nbsp;&nbsp;&nbsp; there are no implicit memory barriers here either.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Consider implementing an unlock operation of some nature by clearing a<BR>&nbsp;&nbsp;&nbsp;&nbsp; locking bit.&nbsp; The clear_bit() would then need to be barriered like this:</P>
<P>&nbsp;smp_mb__before_clear_bit();<BR>&nbsp;clear_bit( ... );</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; This prevents memory operations before the clear leaking to after it.&nbsp; See<BR>&nbsp;&nbsp;&nbsp;&nbsp; the subsection on "Locking Functions" with reference to UNLOCK operation<BR>&nbsp;&nbsp;&nbsp;&nbsp; implications.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; See Documentation/atomic_ops.txt for more information.&nbsp; See the "Atomic<BR>&nbsp;&nbsp;&nbsp;&nbsp; operations" subsection for information on where to use these.</P>
<P><BR>MMIO WRITE BARRIER<BR>------------------</P>
<P>The Linux kernel also has a special barrier for use with memory-mapped I/O<BR>writes:</P>
<P>&nbsp;mmiowb();</P>
<P>This is a variation on the mandatory write barrier that causes writes to weakly<BR>ordered I/O regions to be partially ordered.&nbsp; Its effects may go beyond the<BR>CPU-&gt;Hardware interface and actually affect the hardware at some level.</P>
<P>See the subsection "Locks vs I/O accesses" for more information.</P>
<P><BR>===============================<BR>IMPLICIT KERNEL MEMORY BARRIERS<BR>===============================</P>
<P>Some of the other functions in the linux kernel imply memory barriers, amongst<BR>which are locking and scheduling functions.</P>
<P>This specification is a _minimum_ guarantee; any particular architecture may<BR>provide more substantial guarantees, but these may not be relied upon outside<BR>of arch specific code.</P>
<P><BR>LOCKING FUNCTIONS<BR>-----------------</P>
<P>The Linux kernel has a number of locking constructs:</P>
<P>&nbsp;(*) spin locks<BR>&nbsp;(*) R/W spin locks<BR>&nbsp;(*) mutexes<BR>&nbsp;(*) semaphores<BR>&nbsp;(*) R/W semaphores<BR>&nbsp;(*) RCU</P>
<P>In all cases there are variants on "LOCK" operations and "UNLOCK" operations<BR>for each construct.&nbsp; These operations all imply certain barriers:</P>
<P>&nbsp;(1) LOCK operation implication:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Memory operations issued after the LOCK will be completed after the LOCK<BR>&nbsp;&nbsp;&nbsp;&nbsp; operation has completed.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Memory operations issued before the LOCK may be completed after the LOCK<BR>&nbsp;&nbsp;&nbsp;&nbsp; operation has completed.</P>
<P>&nbsp;(2) UNLOCK operation implication:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Memory operations issued before the UNLOCK will be completed before the<BR>&nbsp;&nbsp;&nbsp;&nbsp; UNLOCK operation has completed.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Memory operations issued after the UNLOCK may be completed before the<BR>&nbsp;&nbsp;&nbsp;&nbsp; UNLOCK operation has completed.</P>
<P>&nbsp;(3) LOCK vs LOCK implication:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; All LOCK operations issued before another LOCK operation will be completed<BR>&nbsp;&nbsp;&nbsp;&nbsp; before that LOCK operation.</P>
<P>&nbsp;(4) LOCK vs UNLOCK implication:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; All LOCK operations issued before an UNLOCK operation will be completed<BR>&nbsp;&nbsp;&nbsp;&nbsp; before the UNLOCK operation.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; All UNLOCK operations issued before a LOCK operation will be completed<BR>&nbsp;&nbsp;&nbsp;&nbsp; before the LOCK operation.</P>
<P>&nbsp;(5) Failed conditional LOCK implication:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Certain variants of the LOCK operation may fail, either due to being<BR>&nbsp;&nbsp;&nbsp;&nbsp; unable to get the lock immediately, or due to receiving an unblocked<BR>&nbsp;&nbsp;&nbsp;&nbsp; signal whilst asleep waiting for the lock to become available.&nbsp; Failed<BR>&nbsp;&nbsp;&nbsp;&nbsp; locks do not imply any sort of barrier.</P>
<P>Therefore, from (1), (2) and (4) an UNLOCK followed by an unconditional LOCK is<BR>equivalent to a full barrier, but a LOCK followed by an UNLOCK is not.</P>
<P>[!] Note: one of the consequences of LOCKs and UNLOCKs being only one-way<BR>&nbsp;&nbsp;&nbsp; barriers is that the effects of instructions outside of a critical section<BR>&nbsp;&nbsp;&nbsp; may seep into the inside of the critical section.</P>
<P>A LOCK followed by an UNLOCK may not be assumed to be full memory barrier<BR>because it is possible for an access preceding the LOCK to happen after the<BR>LOCK, and an access following the UNLOCK to happen before the UNLOCK, and the<BR>two accesses can themselves then cross:</P>
<P>&nbsp;*A = a;<BR>&nbsp;LOCK<BR>&nbsp;UNLOCK<BR>&nbsp;*B = b;</P>
<P>may occur as:</P>
<P>&nbsp;LOCK, STORE *B, STORE *A, UNLOCK</P>
<P>Locks and semaphores may not provide any guarantee of ordering on UP compiled<BR>systems, and so cannot be counted on in such a situation to actually achieve<BR>anything at all - especially with respect to I/O accesses - unless combined<BR>with interrupt disabling operations.</P>
<P>See also the section on "Inter-CPU locking barrier effects".</P>
<P><BR>As an example, consider the following:</P>
<P>&nbsp;*A = a;<BR>&nbsp;*B = b;<BR>&nbsp;LOCK<BR>&nbsp;*C = c;<BR>&nbsp;*D = d;<BR>&nbsp;UNLOCK<BR>&nbsp;*E = e;<BR>&nbsp;*F = f;</P>
<P>The following sequence of events is acceptable:</P>
<P>&nbsp;LOCK, {*F,*A}, *E, {*C,*D}, *B, UNLOCK</P>
<P>&nbsp;[+] Note that {*F,*A} indicates a combined access.</P>
<P>But none of the following are:</P>
<P>&nbsp;{*F,*A}, *B,&nbsp;LOCK, *C, *D,&nbsp;UNLOCK, *E<BR>&nbsp;*A, *B, *C,&nbsp;LOCK, *D,&nbsp;UNLOCK, *E, *F<BR>&nbsp;*A, *B,&nbsp;&nbsp;LOCK, *C,&nbsp;UNLOCK, *D, *E, *F<BR>&nbsp;*B,&nbsp;&nbsp;LOCK, *C, *D,&nbsp;UNLOCK, {*F,*A}, *E</P>
<P>&nbsp;</P>
<P>INTERRUPT DISABLING FUNCTIONS<BR>-----------------------------</P>
<P>Functions that disable interrupts (LOCK equivalent) and enable interrupts<BR>(UNLOCK equivalent) will act as compiler barriers only.&nbsp; So if memory or I/O<BR>barriers are required in such a situation, they must be provided from some<BR>other means.</P>
<P><BR>SLEEP AND WAKE-UP FUNCTIONS<BR>---------------------------</P>
<P>Sleeping and waking on an event flagged in global data can be viewed as an<BR>interaction between two pieces of data: the task state of the task waiting for<BR>the event and the global data used to indicate the event.&nbsp; To make sure that<BR>these appear to happen in the right order, the primitives to begin the process<BR>of going to sleep, and the primitives to initiate a wake up imply certain<BR>barriers.</P>
<P>Firstly, the sleeper normally follows something like this sequence of events:</P>
<P>&nbsp;for (;;) {<BR>&nbsp;&nbsp;set_current_state(TASK_UNINTERRUPTIBLE);<BR>&nbsp;&nbsp;if (event_indicated)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;schedule();<BR>&nbsp;}</P>
<P>A general memory barrier is interpolated automatically by set_current_state()<BR>after it has altered the task state:</P>
<P>&nbsp;CPU 1<BR>&nbsp;===============================<BR>&nbsp;set_current_state();<BR>&nbsp;&nbsp; set_mb();<BR>&nbsp;&nbsp;&nbsp;&nbsp; STORE current-&gt;state<BR>&nbsp;&nbsp;&nbsp;&nbsp; &lt;general barrier&gt;<BR>&nbsp;LOAD event_indicated</P>
<P>set_current_state() may be wrapped by:</P>
<P>&nbsp;prepare_to_wait();<BR>&nbsp;prepare_to_wait_exclusive();</P>
<P>which therefore also imply a general memory barrier after setting the state.<BR>The whole sequence above is available in various canned forms, all of which<BR>interpolate the memory barrier in the right place:</P>
<P>&nbsp;wait_event();<BR>&nbsp;wait_event_interruptible();<BR>&nbsp;wait_event_interruptible_exclusive();<BR>&nbsp;wait_event_interruptible_timeout();<BR>&nbsp;wait_event_killable();<BR>&nbsp;wait_event_timeout();<BR>&nbsp;wait_on_bit();<BR>&nbsp;wait_on_bit_lock();</P>
<P><BR>Secondly, code that performs a wake up normally follows something like this:</P>
<P>&nbsp;event_indicated = 1;<BR>&nbsp;wake_up(&amp;event_wait_queue);</P>
<P>or:</P>
<P>&nbsp;event_indicated = 1;<BR>&nbsp;wake_up_process(event_daemon);</P>
<P>A write memory barrier is implied by wake_up() and co. if and only if they wake<BR>something up.&nbsp; The barrier occurs before the task state is cleared, and so sits<BR>between the STORE to indicate the event and the STORE to set TASK_RUNNING:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;&nbsp;CPU 2<BR>&nbsp;===============================&nbsp;===============================<BR>&nbsp;set_current_state();&nbsp;&nbsp;STORE event_indicated<BR>&nbsp;&nbsp; set_mb();&nbsp;&nbsp;&nbsp;wake_up();<BR>&nbsp;&nbsp;&nbsp;&nbsp; STORE current-&gt;state&nbsp;&nbsp; &lt;write barrier&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp; &lt;general barrier&gt;&nbsp;&nbsp;&nbsp; STORE current-&gt;state<BR>&nbsp;LOAD event_indicated</P>
<P>The available waker functions include:</P>
<P>&nbsp;complete();<BR>&nbsp;wake_up();<BR>&nbsp;wake_up_all();<BR>&nbsp;wake_up_bit();<BR>&nbsp;wake_up_interruptible();<BR>&nbsp;wake_up_interruptible_all();<BR>&nbsp;wake_up_interruptible_nr();<BR>&nbsp;wake_up_interruptible_poll();<BR>&nbsp;wake_up_interruptible_sync();<BR>&nbsp;wake_up_interruptible_sync_poll();<BR>&nbsp;wake_up_locked();<BR>&nbsp;wake_up_locked_poll();<BR>&nbsp;wake_up_nr();<BR>&nbsp;wake_up_poll();<BR>&nbsp;wake_up_process();</P>
<P><BR>[!] Note that the memory barriers implied by the sleeper and the waker do _not_<BR>order multiple stores before the wake-up with respect to loads of those stored<BR>values after the sleeper has called set_current_state().&nbsp; For instance, if the<BR>sleeper does:</P>
<P>&nbsp;set_current_state(TASK_INTERRUPTIBLE);<BR>&nbsp;if (event_indicated)<BR>&nbsp;&nbsp;break;<BR>&nbsp;__set_current_state(TASK_RUNNING);<BR>&nbsp;do_something(my_data);</P>
<P>and the waker does:</P>
<P>&nbsp;my_data = value;<BR>&nbsp;event_indicated = 1;<BR>&nbsp;wake_up(&amp;event_wait_queue);</P>
<P>there's no guarantee that the change to event_indicated will be perceived by<BR>the sleeper as coming after the change to my_data.&nbsp; In such a circumstance, the<BR>code on both sides must interpolate its own memory barriers between the<BR>separate data accesses.&nbsp; Thus the above sleeper ought to do:</P>
<P>&nbsp;set_current_state(TASK_INTERRUPTIBLE);<BR>&nbsp;if (event_indicated) {<BR>&nbsp;&nbsp;smp_rmb();<BR>&nbsp;&nbsp;do_something(my_data);<BR>&nbsp;}</P>
<P>and the waker should do:</P>
<P>&nbsp;my_data = value;<BR>&nbsp;smp_wmb();<BR>&nbsp;event_indicated = 1;<BR>&nbsp;wake_up(&amp;event_wait_queue);</P>
<P><BR>MISCELLANEOUS FUNCTIONS<BR>-----------------------</P>
<P>Other functions that imply barriers:</P>
<P>&nbsp;(*) schedule() and similar imply full memory barriers.</P>
<P><BR>=================================<BR>INTER-CPU LOCKING BARRIER EFFECTS<BR>=================================</P>
<P>On SMP systems locking primitives give a more substantial form of barrier: one<BR>that does affect memory access ordering on other CPUs, within the context of<BR>conflict on any particular lock.</P>
<P><BR>LOCKS VS MEMORY ACCESSES<BR>------------------------</P>
<P>Consider the following: the system has a pair of spinlocks (M) and (Q), and<BR>three CPUs; then should the following sequence of events occur:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;&nbsp;CPU 2<BR>&nbsp;===============================&nbsp;===============================<BR>&nbsp;*A = a;&nbsp;&nbsp;&nbsp;&nbsp;*E = e;<BR>&nbsp;LOCK M&nbsp;&nbsp;&nbsp;&nbsp;LOCK Q<BR>&nbsp;*B = b;&nbsp;&nbsp;&nbsp;&nbsp;*F = f;<BR>&nbsp;*C = c;&nbsp;&nbsp;&nbsp;&nbsp;*G = g;<BR>&nbsp;UNLOCK M&nbsp;&nbsp;&nbsp;UNLOCK Q<BR>&nbsp;*D = d;&nbsp;&nbsp;&nbsp;&nbsp;*H = h;</P>
<P>Then there is no guarantee as to what order CPU 3 will see the accesses to *A<BR>through *H occur in, other than the constraints imposed by the separate locks<BR>on the separate CPUs. It might, for example, see:</P>
<P>&nbsp;*E, LOCK M, LOCK Q, *G, *C, *F, *A, *B, UNLOCK Q, *D, *H, UNLOCK M</P>
<P>But it won't see any of:</P>
<P>&nbsp;*B, *C or *D preceding LOCK M<BR>&nbsp;*A, *B or *C following UNLOCK M<BR>&nbsp;*F, *G or *H preceding LOCK Q<BR>&nbsp;*E, *F or *G following UNLOCK Q</P>
<P><BR>However, if the following occurs:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;&nbsp;CPU 2<BR>&nbsp;===============================&nbsp;===============================<BR>&nbsp;*A = a;<BR>&nbsp;LOCK M&nbsp;&nbsp;[1]<BR>&nbsp;*B = b;<BR>&nbsp;*C = c;<BR>&nbsp;UNLOCK M&nbsp;[1]<BR>&nbsp;*D = d;&nbsp;&nbsp;&nbsp;&nbsp;*E = e;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOCK M&nbsp;&nbsp;[2]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*F = f;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*G = g;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK M&nbsp;[2]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*H = h;</P>
<P>CPU 3 might see:</P>
<P>&nbsp;*E, LOCK M [1], *C, *B, *A, UNLOCK M [1],<BR>&nbsp;&nbsp;LOCK M [2], *H, *F, *G, UNLOCK M [2], *D</P>
<P>But assuming CPU 1 gets the lock first, CPU 3 won't see any of:</P>
<P>&nbsp;*B, *C, *D, *F, *G or *H preceding LOCK M [1]<BR>&nbsp;*A, *B or *C following UNLOCK M [1]<BR>&nbsp;*F, *G or *H preceding LOCK M [2]<BR>&nbsp;*A, *B, *C, *E, *F or *G following UNLOCK M [2]</P>
<P><BR>LOCKS VS I/O ACCESSES<BR>---------------------</P>
<P>Under certain circumstances (especially involving NUMA), I/O accesses within<BR>two spinlocked sections on two different CPUs may be seen as interleaved by the<BR>PCI bridge, because the PCI bridge does not necessarily participate in the<BR>cache-coherence protocol, and is therefore incapable of issuing the required<BR>read memory barriers.</P>
<P>For example:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;&nbsp;CPU 2<BR>&nbsp;===============================&nbsp;===============================<BR>&nbsp;spin_lock(Q)<BR>&nbsp;writel(0, ADDR)<BR>&nbsp;writel(1, DATA);<BR>&nbsp;spin_unlock(Q);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_lock(Q);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writel(4, ADDR);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writel(5, DATA);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_unlock(Q);</P>
<P>may be seen by the PCI bridge as follows:</P>
<P>&nbsp;STORE *ADDR = 0, STORE *ADDR = 4, STORE *DATA = 1, STORE *DATA = 5</P>
<P>which would probably cause the hardware to malfunction.</P>
<P><BR>What is necessary here is to intervene with an mmiowb() before dropping the<BR>spinlock, for example:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;&nbsp;CPU 2<BR>&nbsp;===============================&nbsp;===============================<BR>&nbsp;spin_lock(Q)<BR>&nbsp;writel(0, ADDR)<BR>&nbsp;writel(1, DATA);<BR>&nbsp;mmiowb();<BR>&nbsp;spin_unlock(Q);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_lock(Q);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writel(4, ADDR);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writel(5, DATA);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mmiowb();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_unlock(Q);</P>
<P>this will ensure that the two stores issued on CPU 1 appear at the PCI bridge<BR>before either of the stores issued on CPU 2.</P>
<P><BR>Furthermore, following a store by a load from the same device obviates the need<BR>for the mmiowb(), because the load forces the store to complete before the load<BR>is performed:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;&nbsp;CPU 2<BR>&nbsp;===============================&nbsp;===============================<BR>&nbsp;spin_lock(Q)<BR>&nbsp;writel(0, ADDR)<BR>&nbsp;a = readl(DATA);<BR>&nbsp;spin_unlock(Q);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_lock(Q);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writel(4, ADDR);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = readl(DATA);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_unlock(Q);</P>
<P><BR>See Documentation/DocBook/deviceiobook.tmpl for more information.</P>
<P><BR>=================================<BR>WHERE ARE MEMORY BARRIERS NEEDED?<BR>=================================</P>
<P>Under normal operation, memory operation reordering is generally not going to<BR>be a problem as a single-threaded linear piece of code will still appear to<BR>work correctly, even if it's in an SMP kernel.&nbsp; There are, however, four<BR>circumstances in which reordering definitely _could_ be a problem:</P>
<P>&nbsp;(*) Interprocessor interaction.</P>
<P>&nbsp;(*) Atomic operations.</P>
<P>&nbsp;(*) Accessing devices.</P>
<P>&nbsp;(*) Interrupts.</P>
<P><BR>INTERPROCESSOR INTERACTION<BR>--------------------------</P>
<P>When there's a system with more than one processor, more than one CPU in the<BR>system may be working on the same data set at the same time.&nbsp; This can cause<BR>synchronisation problems, and the usual way of dealing with them is to use<BR>locks.&nbsp; Locks, however, are quite expensive, and so it may be preferable to<BR>operate without the use of a lock if at all possible.&nbsp; In such a case<BR>operations that affect both CPUs may have to be carefully ordered to prevent<BR>a malfunction.</P>
<P>Consider, for example, the R/W semaphore slow path.&nbsp; Here a waiting process is<BR>queued on the semaphore, by virtue of it having a piece of its stack linked to<BR>the semaphore's list of waiting processes:</P>
<P>&nbsp;struct rw_semaphore {<BR>&nbsp;&nbsp;...<BR>&nbsp;&nbsp;spinlock_t lock;<BR>&nbsp;&nbsp;struct list_head waiters;<BR>&nbsp;};</P>
<P>&nbsp;struct rwsem_waiter {<BR>&nbsp;&nbsp;struct list_head list;<BR>&nbsp;&nbsp;struct task_struct *task;<BR>&nbsp;};</P>
<P>To wake up a particular waiter, the up_read() or up_write() functions have to:</P>
<P>&nbsp;(1) read the next pointer from this waiter's record to know as to where the<BR>&nbsp;&nbsp;&nbsp;&nbsp; next waiter record is;</P>
<P>&nbsp;(2) read the pointer to the waiter's task structure;</P>
<P>&nbsp;(3) clear the task pointer to tell the waiter it has been given the semaphore;</P>
<P>&nbsp;(4) call wake_up_process() on the task; and</P>
<P>&nbsp;(5) release the reference held on the waiter's task struct.</P>
<P>In other words, it has to perform this sequence of events:</P>
<P>&nbsp;LOAD waiter-&gt;list.next;<BR>&nbsp;LOAD waiter-&gt;task;<BR>&nbsp;STORE waiter-&gt;task;<BR>&nbsp;CALL wakeup<BR>&nbsp;RELEASE task</P>
<P>and if any of these steps occur out of order, then the whole thing may<BR>malfunction.</P>
<P>Once it has queued itself and dropped the semaphore lock, the waiter does not<BR>get the lock again; it instead just waits for its task pointer to be cleared<BR>before proceeding.&nbsp; Since the record is on the waiter's stack, this means that<BR>if the task pointer is cleared _before_ the next pointer in the list is read,<BR>another CPU might start processing the waiter and might clobber the waiter's<BR>stack before the up*() function has a chance to read the next pointer.</P>
<P>Consider then what might happen to the above sequence of events:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;&nbsp;&nbsp;CPU 2<BR>&nbsp;===============================&nbsp;===============================<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;down_xxx()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue waiter<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep<BR>&nbsp;up_yyy()<BR>&nbsp;LOAD waiter-&gt;task;<BR>&nbsp;STORE waiter-&gt;task;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Woken up by other event<BR>&nbsp;&lt;preempt&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resume processing<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;down_xxx() returns<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call foo()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foo() clobbers *waiter<BR>&nbsp;&lt;/preempt&gt;<BR>&nbsp;LOAD waiter-&gt;list.next;<BR>&nbsp;--- OOPS ---</P>
<P>This could be dealt with using the semaphore lock, but then the down_xxx()<BR>function has to needlessly get the spinlock again after being woken up.</P>
<P>The way to deal with this is to insert a general SMP memory barrier:</P>
<P>&nbsp;LOAD waiter-&gt;list.next;<BR>&nbsp;LOAD waiter-&gt;task;<BR>&nbsp;smp_mb();<BR>&nbsp;STORE waiter-&gt;task;<BR>&nbsp;CALL wakeup<BR>&nbsp;RELEASE task</P>
<P>In this case, the barrier makes a guarantee that all memory accesses before the<BR>barrier will appear to happen before all the memory accesses after the barrier<BR>with respect to the other CPUs on the system.&nbsp; It does _not_ guarantee that all<BR>the memory accesses before the barrier will be complete by the time the barrier<BR>instruction itself is complete.</P>
<P>On a UP system - where this wouldn't be a problem - the smp_mb() is just a<BR>compiler barrier, thus making sure the compiler emits the instructions in the<BR>right order without actually intervening in the CPU.&nbsp; Since there's only one<BR>CPU, that CPU's dependency ordering logic will take care of everything else.</P>
<P><BR>ATOMIC OPERATIONS<BR>-----------------</P>
<P>Whilst they are technically interprocessor interaction considerations, atomic<BR>operations are noted specially as some of them imply full memory barriers and<BR>some don't, but they're very heavily relied on as a group throughout the<BR>kernel.</P>
<P>Any atomic operation that modifies some state in memory and returns information<BR>about the state (old or new) implies an SMP-conditional general memory barrier<BR>(smp_mb()) on each side of the actual operation (with the exception of<BR>explicit lock operations, described later).&nbsp; These include:</P>
<P>&nbsp;xchg();<BR>&nbsp;cmpxchg();<BR>&nbsp;atomic_xchg();<BR>&nbsp;atomic_cmpxchg();<BR>&nbsp;atomic_inc_return();<BR>&nbsp;atomic_dec_return();<BR>&nbsp;atomic_add_return();<BR>&nbsp;atomic_sub_return();<BR>&nbsp;atomic_inc_and_test();<BR>&nbsp;atomic_dec_and_test();<BR>&nbsp;atomic_sub_and_test();<BR>&nbsp;atomic_add_negative();<BR>&nbsp;atomic_add_unless();&nbsp;/* when succeeds (returns 1) */<BR>&nbsp;test_and_set_bit();<BR>&nbsp;test_and_clear_bit();<BR>&nbsp;test_and_change_bit();</P>
<P>These are used for such things as implementing LOCK-class and UNLOCK-class<BR>operations and adjusting reference counters towards object destruction, and as<BR>such the implicit memory barrier effects are necessary.</P>
<P><BR>The following operations are potential problems as they do _not_ imply memory<BR>barriers, but might be used for implementing such things as UNLOCK-class<BR>operations:</P>
<P>&nbsp;atomic_set();<BR>&nbsp;set_bit();<BR>&nbsp;clear_bit();<BR>&nbsp;change_bit();</P>
<P>With these the appropriate explicit memory barrier should be used if necessary<BR>(smp_mb__before_clear_bit() for instance).</P>
<P><BR>The following also do _not_ imply memory barriers, and so may require explicit<BR>memory barriers under some circumstances (smp_mb__before_atomic_dec() for<BR>instance):</P>
<P>&nbsp;atomic_add();<BR>&nbsp;atomic_sub();<BR>&nbsp;atomic_inc();<BR>&nbsp;atomic_dec();</P>
<P>If they're used for statistics generation, then they probably don't need memory<BR>barriers, unless there's a coupling between statistical data.</P>
<P>If they're used for reference counting on an object to control its lifetime,<BR>they probably don't need memory barriers because either the reference count<BR>will be adjusted inside a locked section, or the caller will already hold<BR>sufficient references to make the lock, and thus a memory barrier unnecessary.</P>
<P>If they're used for constructing a lock of some description, then they probably<BR>do need memory barriers as a lock primitive generally has to do things in a<BR>specific order.</P>
<P>Basically, each usage case has to be carefully considered as to whether memory<BR>barriers are needed or not.</P>
<P>The following operations are special locking primitives:</P>
<P>&nbsp;test_and_set_bit_lock();<BR>&nbsp;clear_bit_unlock();<BR>&nbsp;__clear_bit_unlock();</P>
<P>These implement LOCK-class and UNLOCK-class operations. These should be used in<BR>preference to other operations when implementing locking primitives, because<BR>their implementations can be optimised on many architectures.</P>
<P>[!] Note that special memory barrier primitives are available for these<BR>situations because on some CPUs the atomic instructions used imply full memory<BR>barriers, and so barrier instructions are superfluous in conjunction with them,<BR>and in such cases the special barrier primitives will be no-ops.</P>
<P>See Documentation/atomic_ops.txt for more information.</P>
<P><BR>ACCESSING DEVICES<BR>-----------------</P>
<P>Many devices can be memory mapped, and so appear to the CPU as if they're just<BR>a set of memory locations.&nbsp; To control such a device, the driver usually has to<BR>make the right memory accesses in exactly the right order.</P>
<P>However, having a clever CPU or a clever compiler creates a potential problem<BR>in that the carefully sequenced accesses in the driver code won't reach the<BR>device in the requisite order if the CPU or the compiler thinks it is more<BR>efficient to reorder, combine or merge accesses - something that would cause<BR>the device to malfunction.</P>
<P>Inside of the Linux kernel, I/O should be done through the appropriate accessor<BR>routines - such as inb() or writel() - which know how to make such accesses<BR>appropriately sequential.&nbsp; Whilst this, for the most part, renders the explicit<BR>use of memory barriers unnecessary, there are a couple of situations where they<BR>might be needed:</P>
<P>&nbsp;(1) On some systems, I/O stores are not strongly ordered across all CPUs, and<BR>&nbsp;&nbsp;&nbsp;&nbsp; so for _all_ general drivers locks should be used and mmiowb() must be<BR>&nbsp;&nbsp;&nbsp;&nbsp; issued prior to unlocking the critical section.</P>
<P>&nbsp;(2) If the accessor functions are used to refer to an I/O memory window with<BR>&nbsp;&nbsp;&nbsp;&nbsp; relaxed memory access properties, then _mandatory_ memory barriers are<BR>&nbsp;&nbsp;&nbsp;&nbsp; required to enforce ordering.</P>
<P>See Documentation/DocBook/deviceiobook.tmpl for more information.</P>
<P><BR>INTERRUPTS<BR>----------</P>
<P>A driver may be interrupted by its own interrupt service routine, and thus the<BR>two parts of the driver may interfere with each other's attempts to control or<BR>access the device.</P>
<P>This may be alleviated - at least in part - by disabling local interrupts (a<BR>form of locking), such that the critical operations are all contained within<BR>the interrupt-disabled section in the driver.&nbsp; Whilst the driver's interrupt<BR>routine is executing, the driver's core may not run on the same CPU, and its<BR>interrupt is not permitted to happen again until the current interrupt has been<BR>handled, thus the interrupt handler does not need to lock against that.</P>
<P>However, consider a driver that was talking to an ethernet card that sports an<BR>address register and a data register.&nbsp; If that driver's core talks to the card<BR>under interrupt-disablement and then the driver's interrupt handler is invoked:</P>
<P>&nbsp;LOCAL IRQ DISABLE<BR>&nbsp;writew(ADDR, 3);<BR>&nbsp;writew(DATA, y);<BR>&nbsp;LOCAL IRQ ENABLE<BR>&nbsp;&lt;interrupt&gt;<BR>&nbsp;writew(ADDR, 4);<BR>&nbsp;q = readw(DATA);<BR>&nbsp;&lt;/interrupt&gt;</P>
<P>The store to the data register might happen after the second store to the<BR>address register if ordering rules are sufficiently relaxed:</P>
<P>&nbsp;STORE *ADDR = 3, STORE *ADDR = 4, STORE *DATA = y, q = LOAD *DATA</P>
<P><BR>If ordering rules are relaxed, it must be assumed that accesses done inside an<BR>interrupt disabled section may leak outside of it and may interleave with<BR>accesses performed in an interrupt - and vice versa - unless implicit or<BR>explicit barriers are used.</P>
<P>Normally this won't be a problem because the I/O accesses done inside such<BR>sections will include synchronous load operations on strictly ordered I/O<BR>registers that form implicit I/O barriers. If this isn't sufficient then an<BR>mmiowb() may need to be used explicitly.</P>
<P><BR>A similar situation may occur between an interrupt routine and two routines<BR>running on separate CPUs that communicate with each other. If such a case is<BR>likely, then interrupt-disabling locks should be used to guarantee ordering.</P>
<P><BR>==========================<BR>KERNEL I/O BARRIER EFFECTS<BR>==========================</P>
<P>When accessing I/O memory, drivers should use the appropriate accessor<BR>functions:</P>
<P>&nbsp;(*) inX(), outX():</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; These are intended to talk to I/O space rather than memory space, but<BR>&nbsp;&nbsp;&nbsp;&nbsp; that's primarily a CPU-specific concept. The i386 and x86_64 processors do<BR>&nbsp;&nbsp;&nbsp;&nbsp; indeed have special I/O space access cycles and instructions, but many<BR>&nbsp;&nbsp;&nbsp;&nbsp; CPUs don't have such a concept.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; The PCI bus, amongst others, defines an I/O space concept which - on such<BR>&nbsp;&nbsp;&nbsp;&nbsp; CPUs as i386 and x86_64 - readily maps to the CPU's concept of I/O<BR>&nbsp;&nbsp;&nbsp;&nbsp; space.&nbsp; However, it may also be mapped as a virtual I/O space in the CPU's<BR>&nbsp;&nbsp;&nbsp;&nbsp; memory map, particularly on those CPUs that don't support alternate I/O<BR>&nbsp;&nbsp;&nbsp;&nbsp; spaces.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Accesses to this space may be fully synchronous (as on i386), but<BR>&nbsp;&nbsp;&nbsp;&nbsp; intermediary bridges (such as the PCI host bridge) may not fully honour<BR>&nbsp;&nbsp;&nbsp;&nbsp; that.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; They are guaranteed to be fully ordered with respect to each other.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; They are not guaranteed to be fully ordered with respect to other types of<BR>&nbsp;&nbsp;&nbsp;&nbsp; memory and I/O operation.</P>
<P>&nbsp;(*) readX(), writeX():</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Whether these are guaranteed to be fully ordered and uncombined with<BR>&nbsp;&nbsp;&nbsp;&nbsp; respect to each other on the issuing CPU depends on the characteristics<BR>&nbsp;&nbsp;&nbsp;&nbsp; defined for the memory window through which they're accessing. On later<BR>&nbsp;&nbsp;&nbsp;&nbsp; i386 architecture machines, for example, this is controlled by way of the<BR>&nbsp;&nbsp;&nbsp;&nbsp; MTRR registers.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Ordinarily, these will be guaranteed to be fully ordered and uncombined,<BR>&nbsp;&nbsp;&nbsp;&nbsp; provided they're not accessing a prefetchable device.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; However, intermediary hardware (such as a PCI bridge) may indulge in<BR>&nbsp;&nbsp;&nbsp;&nbsp; deferral if it so wishes; to flush a store, a load from the same location<BR>&nbsp;&nbsp;&nbsp;&nbsp; is preferred[*], but a load from the same device or from configuration<BR>&nbsp;&nbsp;&nbsp;&nbsp; space should suffice for PCI.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; [*] NOTE! attempting to load from the same location as was written to may<BR>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; cause a malfunction - consider the 16550 Rx/Tx serial registers for<BR>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; example.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Used with prefetchable I/O memory, an mmiowb() barrier may be required to<BR>&nbsp;&nbsp;&nbsp;&nbsp; force stores to be ordered.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Please refer to the PCI specification for more information on interactions<BR>&nbsp;&nbsp;&nbsp;&nbsp; between PCI transactions.</P>
<P>&nbsp;(*) readX_relaxed()</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; These are similar to readX(), but are not guaranteed to be ordered in any<BR>&nbsp;&nbsp;&nbsp;&nbsp; way. Be aware that there is no I/O read barrier available.</P>
<P>&nbsp;(*) ioreadX(), iowriteX()</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; These will perform appropriately for the type of access they're actually<BR>&nbsp;&nbsp;&nbsp;&nbsp; doing, be it inX()/outX() or readX()/writeX().</P>
<P><BR>========================================<BR>ASSUMED MINIMUM EXECUTION ORDERING MODEL<BR>========================================</P>
<P>It has to be assumed that the conceptual CPU is weakly-ordered but that it will<BR>maintain the appearance of program causality with respect to itself.&nbsp; Some CPUs<BR>(such as i386 or x86_64) are more constrained than others (such as powerpc or<BR>frv), and so the most relaxed case (namely DEC Alpha) must be assumed outside<BR>of arch-specific code.</P>
<P>This means that it must be considered that the CPU will execute its instruction<BR>stream in any order it feels like - or even in parallel - provided that if an<BR>instruction in the stream depends on an earlier instruction, then that<BR>earlier instruction must be sufficiently complete[*] before the later<BR>instruction may proceed; in other words: provided that the appearance of<BR>causality is maintained.</P>
<P>&nbsp;[*] Some instructions have more than one effect - such as changing the<BR>&nbsp;&nbsp;&nbsp;&nbsp; condition codes, changing registers or changing memory - and different<BR>&nbsp;&nbsp;&nbsp;&nbsp; instructions may depend on different effects.</P>
<P>A CPU may also discard any instruction sequence that winds up having no<BR>ultimate effect.&nbsp; For example, if two adjacent instructions both load an<BR>immediate value into the same register, the first may be discarded.</P>
<P><BR>Similarly, it has to be assumed that compiler might reorder the instruction<BR>stream in any way it sees fit, again provided the appearance of causality is<BR>maintained.</P>
<P><BR>============================<BR>THE EFFECTS OF THE CPU CACHE<BR>============================</P>
<P>The way cached memory operations are perceived across the system is affected to<BR>a certain extent by the caches that lie between CPUs and memory, and by the<BR>memory coherence system that maintains the consistency of state in the system.</P>
<P>As far as the way a CPU interacts with another part of the system through the<BR>caches goes, the memory system has to include the CPU's caches, and memory<BR>barriers for the most part act at the interface between the CPU and its cache<BR>(memory barriers logically act on the dotted line in the following diagram):</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; &lt;--- CPU ---&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;----------- Memory -----------&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;+--------+&nbsp;&nbsp;&nbsp; +--------+&nbsp; :&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp; +-----------+<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; +--------+<BR>&nbsp;|&nbsp; CPU&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; | Memory |&nbsp; :&nbsp;&nbsp; | CPU&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp; Core&nbsp; |---&gt;| Access |-----&gt;| Cache&nbsp; |&lt;--&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; | Queue&nbsp; |&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |---&gt;| Memory |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;+--------+&nbsp;&nbsp;&nbsp; +--------+&nbsp; :&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Cache&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; +--------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Coherency |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Mechanism |&nbsp;&nbsp;&nbsp; +--------+<BR>&nbsp;+--------+&nbsp;&nbsp;&nbsp; +--------+&nbsp; :&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp; CPU&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; | Memory |&nbsp; :&nbsp;&nbsp; | CPU&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |---&gt;| Device |<BR>&nbsp;|&nbsp; Core&nbsp; |---&gt;| Access |-----&gt;| Cache&nbsp; |&lt;--&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; | Queue&nbsp; |&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; :&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; +--------+<BR>&nbsp;+--------+&nbsp;&nbsp;&nbsp; +--------+&nbsp; :&nbsp;&nbsp; +--------+&nbsp;&nbsp;&nbsp; +-----------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :</P>
<P>Although any particular load or store may not actually appear outside of the<BR>CPU that issued it since it may have been satisfied within the CPU's own cache,<BR>it will still appear as if the full memory access had taken place as far as the<BR>other CPUs are concerned since the cache coherency mechanisms will migrate the<BR>cacheline over to the accessing CPU and propagate the effects upon conflict.</P>
<P>The CPU core may execute instructions in any order it deems fit, provided the<BR>expected program causality appears to be maintained.&nbsp; Some of the instructions<BR>generate load and store operations which then go into the queue of memory<BR>accesses to be performed.&nbsp; The core may place these in the queue in any order<BR>it wishes, and continue execution until it is forced to wait for an instruction<BR>to complete.</P>
<P>What memory barriers are concerned with is controlling the order in which<BR>accesses cross from the CPU side of things to the memory side of things, and<BR>the order in which the effects are perceived to happen by the other observers<BR>in the system.</P>
<P>[!] Memory barriers are _not_ needed within a given CPU, as CPUs always see<BR>their own loads and stores as if they had happened in program order.</P>
<P>[!] MMIO or other device accesses may bypass the cache system.&nbsp; This depends on<BR>the properties of the memory window through which devices are accessed and/or<BR>the use of any special device communication instructions the CPU may have.</P>
<P><BR>CACHE COHERENCY<BR>---------------</P>
<P>Life isn't quite as simple as it may appear above, however: for while the<BR>caches are expected to be coherent, there's no guarantee that that coherency<BR>will be ordered.&nbsp; This means that whilst changes made on one CPU will<BR>eventually become visible on all CPUs, there's no guarantee that they will<BR>become apparent in the same order on those other CPUs.</P>
<P><BR>Consider dealing with a system that has a pair of CPUs (1 &amp; 2), each of which<BR>has a pair of parallel data caches (CPU 1 has A/B, and CPU 2 has C/D):</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +--------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +---------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;+--------+&nbsp; : +---&gt;| Cache A |&lt;-------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; : |&nbsp;&nbsp;&nbsp; +---------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp; CPU 1 |&lt;---+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; : |&nbsp;&nbsp;&nbsp; +---------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;+--------+&nbsp; : +---&gt;| Cache B |&lt;-------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +---------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Memory |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +---------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | System |<BR>&nbsp;+--------+&nbsp; : +---&gt;| Cache C |&lt;-------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; : |&nbsp;&nbsp;&nbsp; +---------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp; CPU 2 |&lt;---+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; : |&nbsp;&nbsp;&nbsp; +---------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;+--------+&nbsp; : +---&gt;| Cache D |&lt;-------&gt;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +---------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +--------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :</P>
<P>Imagine the system has the following properties:</P>
<P>&nbsp;(*) an odd-numbered cache line may be in cache A, cache C or it may still be<BR>&nbsp;&nbsp;&nbsp;&nbsp; resident in memory;</P>
<P>&nbsp;(*) an even-numbered cache line may be in cache B, cache D or it may still be<BR>&nbsp;&nbsp;&nbsp;&nbsp; resident in memory;</P>
<P>&nbsp;(*) whilst the CPU core is interrogating one cache, the other cache may be<BR>&nbsp;&nbsp;&nbsp;&nbsp; making use of the bus to access the rest of the system - perhaps to<BR>&nbsp;&nbsp;&nbsp;&nbsp; displace a dirty cacheline or to do a speculative load;</P>
<P>&nbsp;(*) each cache has a queue of operations that need to be applied to that cache<BR>&nbsp;&nbsp;&nbsp;&nbsp; to maintain coherency with the rest of the system;</P>
<P>&nbsp;(*) the coherency queue is not flushed by normal loads to lines already<BR>&nbsp;&nbsp;&nbsp;&nbsp; present in the cache, even though the contents of the queue may<BR>&nbsp;&nbsp;&nbsp;&nbsp; potentially affect those loads.</P>
<P>Imagine, then, that two writes are made on the first CPU, with a write barrier<BR>between them to guarantee that they will appear to reach that CPU's caches in<BR>the requisite order:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;CPU 2&nbsp;&nbsp;COMMENT<BR>&nbsp;===============&nbsp;===============&nbsp;=======================================<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u == 0, v == 1 and p == &amp;u, q == &amp;u<BR>&nbsp;v = 2;<BR>&nbsp;smp_wmb();&nbsp;&nbsp;&nbsp;Make sure change to v is visible before<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; change to p<BR>&nbsp;&lt;A:modify v=2&gt;&nbsp;&nbsp;&nbsp;v is now in cache A exclusively<BR>&nbsp;p = &amp;v;<BR>&nbsp;&lt;B:modify p=&amp;v&gt;&nbsp;&nbsp;&nbsp;p is now in cache B exclusively</P>
<P>The write memory barrier forces the other CPUs in the system to perceive that<BR>the local CPU's caches have apparently been updated in the correct order.&nbsp; But<BR>now imagine that the second CPU wants to read those values:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;CPU 2&nbsp;&nbsp;COMMENT<BR>&nbsp;===============&nbsp;===============&nbsp;=======================================<BR>&nbsp;...<BR>&nbsp;&nbsp;&nbsp;q = p;<BR>&nbsp;&nbsp;&nbsp;x = *q;</P>
<P>The above pair of reads may then fail to happen in the expected order, as the<BR>cacheline holding p may get updated in one of the second CPU's caches whilst<BR>the update to the cacheline holding v is delayed in the other of the second<BR>CPU's caches by some other cache event:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;CPU 2&nbsp;&nbsp;COMMENT<BR>&nbsp;===============&nbsp;===============&nbsp;=======================================<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u == 0, v == 1 and p == &amp;u, q == &amp;u<BR>&nbsp;v = 2;<BR>&nbsp;smp_wmb();<BR>&nbsp;&lt;A:modify v=2&gt;&nbsp;&lt;C:busy&gt;<BR>&nbsp;&nbsp;&nbsp;&lt;C:queue v=2&gt;<BR>&nbsp;p = &amp;v;&nbsp;&nbsp;q = p;<BR>&nbsp;&nbsp;&nbsp;&lt;D:request p&gt;<BR>&nbsp;&lt;B:modify p=&amp;v&gt;&nbsp;&lt;D:commit p=&amp;v&gt;<BR>&nbsp;&nbsp;&nbsp; &nbsp;&lt;D:read p&gt;<BR>&nbsp;&nbsp;&nbsp;x = *q;<BR>&nbsp;&nbsp;&nbsp;&lt;C:read *q&gt;&nbsp;Reads from v before v updated in cache<BR>&nbsp;&nbsp;&nbsp;&lt;C:unbusy&gt;<BR>&nbsp;&nbsp;&nbsp;&lt;C:commit v=2&gt;</P>
<P>Basically, whilst both cachelines will be updated on CPU 2 eventually, there's<BR>no guarantee that, without intervention, the order of update will be the same<BR>as that committed on CPU 1.</P>
<P><BR>To intervene, we need to interpolate a data dependency barrier or a read<BR>barrier between the loads.&nbsp; This will force the cache to commit its coherency<BR>queue before processing any further requests:</P>
<P>&nbsp;CPU 1&nbsp;&nbsp;CPU 2&nbsp;&nbsp;COMMENT<BR>&nbsp;===============&nbsp;===============&nbsp;=======================================<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u == 0, v == 1 and p == &amp;u, q == &amp;u<BR>&nbsp;v = 2;<BR>&nbsp;smp_wmb();<BR>&nbsp;&lt;A:modify v=2&gt;&nbsp;&lt;C:busy&gt;<BR>&nbsp;&nbsp;&nbsp;&lt;C:queue v=2&gt;<BR>&nbsp;p = &amp;v;&nbsp;&nbsp;q = p;<BR>&nbsp;&nbsp;&nbsp;&lt;D:request p&gt;<BR>&nbsp;&lt;B:modify p=&amp;v&gt;&nbsp;&lt;D:commit p=&amp;v&gt;<BR>&nbsp;&nbsp;&nbsp; &nbsp;&lt;D:read p&gt;<BR>&nbsp;&nbsp;&nbsp;smp_read_barrier_depends()<BR>&nbsp;&nbsp;&nbsp;&lt;C:unbusy&gt;<BR>&nbsp;&nbsp;&nbsp;&lt;C:commit v=2&gt;<BR>&nbsp;&nbsp;&nbsp;x = *q;<BR>&nbsp;&nbsp;&nbsp;&lt;C:read *q&gt;&nbsp;Reads from v after v updated in cache</P>
<P><BR>This sort of problem can be encountered on DEC Alpha processors as they have a<BR>split cache that improves performance by making better use of the data bus.<BR>Whilst most CPUs do imply a data dependency barrier on the read when a memory<BR>access depends on a read, not all do, so it may not be relied on.</P>
<P>Other CPUs may also have split caches, but must coordinate between the various<BR>cachelets for normal memory accesses.&nbsp; The semantics of the Alpha removes the<BR>need for coordination in the absence of memory barriers.</P>
<P><BR>CACHE COHERENCY VS DMA<BR>----------------------</P>
<P>Not all systems maintain cache coherency with respect to devices doing DMA.&nbsp; In<BR>such cases, a device attempting DMA may obtain stale data from RAM because<BR>dirty cache lines may be resident in the caches of various CPUs, and may not<BR>have been written back to RAM yet.&nbsp; To deal with this, the appropriate part of<BR>the kernel must flush the overlapping bits of cache on each CPU (and maybe<BR>invalidate them as well).</P>
<P>In addition, the data DMA'd to RAM by a device may be overwritten by dirty<BR>cache lines being written back to RAM from a CPU's cache after the device has<BR>installed its own data, or cache lines present in the CPU's cache may simply<BR>obscure the fact that RAM has been updated, until at such time as the cacheline<BR>is discarded from the CPU's cache and reloaded.&nbsp; To deal with this, the<BR>appropriate part of the kernel must invalidate the overlapping bits of the<BR>cache on each CPU.</P>
<P>See Documentation/cachetlb.txt for more information on cache management.</P>
<P><BR>CACHE COHERENCY VS MMIO<BR>-----------------------</P>
<P>Memory mapped I/O usually takes place through memory locations that are part of<BR>a window in the CPU's memory space that has different properties assigned than<BR>the usual RAM directed window.</P>
<P>Amongst these properties is usually the fact that such accesses bypass the<BR>caching entirely and go directly to the device buses.&nbsp; This means MMIO accesses<BR>may, in effect, overtake accesses to cached memory that were emitted earlier.<BR>A memory barrier isn't sufficient in such a case, but rather the cache must be<BR>flushed between the cached memory write and the MMIO access if the two are in<BR>any way dependent.</P>
<P><BR>=========================<BR>THE THINGS CPUS GET UP TO<BR>=========================</P>
<P>A programmer might take it for granted that the CPU will perform memory<BR>operations in exactly the order specified, so that if the CPU is, for example,<BR>given the following piece of code to execute:</P>
<P>&nbsp;a = *A;<BR>&nbsp;*B = b;<BR>&nbsp;c = *C;<BR>&nbsp;d = *D;<BR>&nbsp;*E = e;</P>
<P>they would then expect that the CPU will complete the memory operation for each<BR>instruction before moving on to the next one, leading to a definite sequence of<BR>operations as seen by external observers in the system:</P>
<P>&nbsp;LOAD *A, STORE *B, LOAD *C, LOAD *D, STORE *E.</P>
<P><BR>Reality is, of course, much messier.&nbsp; With many CPUs and compilers, the above<BR>assumption doesn't hold because:</P>
<P>&nbsp;(*) loads are more likely to need to be completed immediately to permit<BR>&nbsp;&nbsp;&nbsp;&nbsp; execution progress, whereas stores can often be deferred without a<BR>&nbsp;&nbsp;&nbsp;&nbsp; problem;</P>
<P>&nbsp;(*) loads may be done speculatively, and the result discarded should it prove<BR>&nbsp;&nbsp;&nbsp;&nbsp; to have been unnecessary;</P>
<P>&nbsp;(*) loads may be done speculatively, leading to the result having been fetched<BR>&nbsp;&nbsp;&nbsp;&nbsp; at the wrong time in the expected sequence of events;</P>
<P>&nbsp;(*) the order of the memory accesses may be rearranged to promote better use<BR>&nbsp;&nbsp;&nbsp;&nbsp; of the CPU buses and caches;</P>
<P>&nbsp;(*) loads and stores may be combined to improve performance when talking to<BR>&nbsp;&nbsp;&nbsp;&nbsp; memory or I/O hardware that can do batched accesses of adjacent locations,<BR>&nbsp;&nbsp;&nbsp;&nbsp; thus cutting down on transaction setup costs (memory and PCI devices may<BR>&nbsp;&nbsp;&nbsp;&nbsp; both be able to do this); and</P>
<P>&nbsp;(*) the CPU's data cache may affect the ordering, and whilst cache-coherency<BR>&nbsp;&nbsp;&nbsp;&nbsp; mechanisms may alleviate this - once the store has actually hit the cache<BR>&nbsp;&nbsp;&nbsp;&nbsp; - there's no guarantee that the coherency management will be propagated in<BR>&nbsp;&nbsp;&nbsp;&nbsp; order to other CPUs.</P>
<P>So what another CPU, say, might actually observe from the above piece of code<BR>is:</P>
<P>&nbsp;LOAD *A, ..., LOAD {*C,*D}, STORE *E, STORE *B</P>
<P>&nbsp;(Where "LOAD {*C,*D}" is a combined load)</P>
<P><BR>However, it is guaranteed that a CPU will be self-consistent: it will see its<BR>_own_ accesses appear to be correctly ordered, without the need for a memory<BR>barrier.&nbsp; For instance with the following code:</P>
<P>&nbsp;U = *A;<BR>&nbsp;*A = V;<BR>&nbsp;*A = W;<BR>&nbsp;X = *A;<BR>&nbsp;*A = Y;<BR>&nbsp;Z = *A;</P>
<P>and assuming no intervention by an external influence, it can be assumed that<BR>the final result will appear to be:</P>
<P>&nbsp;U == the original value of *A<BR>&nbsp;X == W<BR>&nbsp;Z == Y<BR>&nbsp;*A == Y</P>
<P>The code above may cause the CPU to generate the full sequence of memory<BR>accesses:</P>
<P>&nbsp;U=LOAD *A, STORE *A=V, STORE *A=W, X=LOAD *A, STORE *A=Y, Z=LOAD *A</P>
<P>in that order, but, without intervention, the sequence may have almost any<BR>combination of elements combined or discarded, provided the program's view of<BR>the world remains consistent.</P>
<P>The compiler may also combine, discard or defer elements of the sequence before<BR>the CPU even sees them.</P>
<P>For instance:</P>
<P>&nbsp;*A = V;<BR>&nbsp;*A = W;</P>
<P>may be reduced to:</P>
<P>&nbsp;*A = W;</P>
<P>since, without a write barrier, it can be assumed that the effect of the<BR>storage of V to *A is lost.&nbsp; Similarly:</P>
<P>&nbsp;*A = Y;<BR>&nbsp;Z = *A;</P>
<P>may, without a memory barrier, be reduced to:</P>
<P>&nbsp;*A = Y;<BR>&nbsp;Z = Y;</P>
<P>and the LOAD operation never appear outside of the CPU.</P>
<P><BR>AND THEN THERE'S THE ALPHA<BR>--------------------------</P>
<P>The DEC Alpha CPU is one of the most relaxed CPUs there is.&nbsp; Not only that,<BR>some versions of the Alpha CPU have a split data cache, permitting them to have<BR>two semantically-related cache lines updated at separate times.&nbsp; This is where<BR>the data dependency barrier really becomes necessary as this synchronises both<BR>caches with the memory coherence system, thus making it seem like pointer<BR>changes vs new data occur in the right order.</P>
<P>The Alpha defines the Linux kernel's memory barrier model.</P>
<P>See the subsection on "Cache Coherency" above.</P>
<P><BR>============<BR>EXAMPLE USES<BR>============</P>
<P>CIRCULAR BUFFERS<BR>----------------</P>
<P>Memory barriers can be used to implement circular buffering without the need<BR>of a lock to serialise the producer with the consumer.&nbsp; See:</P>
<P>&nbsp;Documentation/circular-buffers.txt</P>
<P>for details.</P>
<P><BR>==========<BR>REFERENCES<BR>==========</P>
<P>Alpha AXP Architecture Reference Manual, Second Edition (Sites &amp; Witek,<BR>Digital Press)<BR>&nbsp;Chapter 5.2: Physical Address Space Characteristics<BR>&nbsp;Chapter 5.4: Caches and Write Buffers<BR>&nbsp;Chapter 5.5: Data Sharing<BR>&nbsp;Chapter 5.6: Read/Write Ordering</P>
<P>AMD64 Architecture Programmer's Manual Volume 2: System Programming<BR>&nbsp;Chapter 7.1: Memory-Access Ordering<BR>&nbsp;Chapter 7.4: Buffering and Combining Memory Writes</P>
<P>IA-32 Intel Architecture Software Developer's Manual, Volume 3:<BR>System Programming Guide<BR>&nbsp;Chapter 7.1: Locked Atomic Operations<BR>&nbsp;Chapter 7.2: Memory Ordering<BR>&nbsp;Chapter 7.4: Serializing Instructions</P>
<P>The SPARC Architecture Manual, Version 9<BR>&nbsp;Chapter 8: Memory Models<BR>&nbsp;Appendix D: Formal Specification of the Memory Models<BR>&nbsp;Appendix J: Programming with the Memory Models</P>
<P>UltraSPARC Programmer Reference Manual<BR>&nbsp;Chapter 5: Memory Accesses and Cacheability<BR>&nbsp;Chapter 15: Sparc-V9 Memory Models</P>
<P>UltraSPARC III Cu User's Manual<BR>&nbsp;Chapter 9: Memory Models</P>
<P>UltraSPARC IIIi Processor User's Manual<BR>&nbsp;Chapter 8: Memory Models</P>
<P>UltraSPARC Architecture 2005<BR>&nbsp;Chapter 9: Memory<BR>&nbsp;Appendix D: Formal Specifications of the Memory Models</P>
<P>UltraSPARC T1 Supplement to the UltraSPARC Architecture 2005<BR>&nbsp;Chapter 8: Memory Models<BR>&nbsp;Appendix F: Caches and Cache Coherency</P>
<P>Solaris Internals, Core Kernel Architecture, p63-68:<BR>&nbsp;Chapter 3.3: Hardware Considerations for Locks and<BR>&nbsp;&nbsp;&nbsp;Synchronization</P>
<P>Unix Systems for Modern Architectures, Symmetric Multiprocessing and Caching<BR>for Kernel Programmers:<BR>&nbsp;Chapter 13: Other Memory Models</P>
<P>Intel Itanium Architecture Software Developer's Manual: Volume 1:<BR>&nbsp;Section 2.6: Speculation<BR>&nbsp;Section 4.4: Memory Access