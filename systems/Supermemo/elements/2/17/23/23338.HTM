# Documentation/rbtree.txt
<P></P>
<P>Red-black Trees (rbtree) in Linux<BR>January 18, 2007<BR>Rob Landley &lt;<A href="mailto:rob@landley.net">rob@landley.net</A>&gt;<BR>=============================</P>
<P></P>
<P>What are red-black trees, and what are they for?<BR>------------------------------------------------</P>
<P>Red-black trees are a type of self-balancing binary search tree, used for<BR>storing sortable key/value data pairs.&nbsp; This differs from radix trees (which<BR>are used to efficiently store sparse arrays and thus use long integer indexes<BR>to insert/access/delete nodes) and hash tables (which are not kept sorted to<BR>be easily traversed in order, and must be tuned for a specific size and<BR>hash function where rbtrees scale gracefully storing arbitrary keys).</P>
<P>Red-black trees are similar to AVL trees, but provide faster real-time bounded<BR>worst case performance for insertion and deletion (at most two rotations and<BR>three rotations, respectively, to balance the tree), with slightly slower<BR>(but still O(log n)) lookup time.</P>
<P>To quote Linux Weekly News:</P>
<P>&nbsp;&nbsp;&nbsp; There are a number of red-black trees in use in the kernel.<BR>&nbsp;&nbsp;&nbsp; The deadline and CFQ I/O schedulers employ rbtrees to<BR>&nbsp;&nbsp;&nbsp; track requests; the packet CD/DVD driver does the same.<BR>&nbsp;&nbsp;&nbsp; The high-resolution timer code uses an rbtree to organize outstanding<BR>&nbsp;&nbsp;&nbsp; timer requests.&nbsp; The ext3 filesystem tracks directory entries in a<BR>&nbsp;&nbsp;&nbsp; red-black tree.&nbsp; Virtual memory areas (VMAs) are tracked with red-black<BR>&nbsp;&nbsp;&nbsp; trees, as are epoll file descriptors, cryptographic keys, and network<BR>&nbsp;&nbsp;&nbsp; packets in the "hierarchical token bucket" scheduler.</P>
<P>This document covers use of the Linux rbtree implementation.&nbsp; For more<BR>information on the nature and implementation of Red Black Trees,&nbsp; see:</P>
<P>&nbsp; Linux Weekly News article on red-black trees<BR>&nbsp;&nbsp;&nbsp; <A href="http://lwn.net/Articles/184495/">http://lwn.net/Articles/184495/</A></P>
<P>&nbsp; Wikipedia entry on red-black trees<BR>&nbsp;&nbsp;&nbsp; <A href="http://en.wikipedia.org/wiki/Red-black_tree">http://en.wikipedia.org/wiki/Red-black_tree</A></P>
<P>Linux implementation of red-black trees<BR>---------------------------------------</P>
<P>Linux's rbtree implementation lives in the file "lib/rbtree.c".&nbsp; To use it,<BR>"#include &lt;linux/rbtree.h&gt;".</P>
<P>The Linux rbtree implementation is optimized for speed, and thus has one<BR>less layer of indirection (and better cache locality) than more traditional<BR>tree implementations.&nbsp; Instead of using pointers to separate rb_node and data<BR>structures, each instance of struct rb_node is embedded in the data structure<BR>it organizes.&nbsp; And instead of using a comparison callback function pointer,<BR>users are expected to write their own tree search and insert functions<BR>which call the provided rbtree functions.&nbsp; Locking is also left up to the<BR>user of the rbtree code.</P>
<P>Creating a new rbtree<BR>---------------------</P>
<P>Data nodes in an rbtree tree are structures containing a struct rb_node member:</P>
<P>&nbsp; struct mytype {<BR>&nbsp; &nbsp;struct rb_node node;<BR>&nbsp; &nbsp;char *keystring;<BR>&nbsp; };</P>
<P>When dealing with a pointer to the embedded struct rb_node, the containing data<BR>structure may be accessed with the standard container_of() macro.&nbsp; In addition,<BR>individual members may be accessed directly via rb_entry(node, type, member).</P>
<P>At the root of each rbtree is an rb_root structure, which is initialized to be<BR>empty via:</P>
<P>&nbsp; struct rb_root mytree = RB_ROOT;</P>
<P>Searching for a value in an rbtree<BR>----------------------------------</P>
<P>Writing a search function for your tree is fairly straightforward: start at the<BR>root, compare each value, and follow the left or right branch as necessary.</P>
<P>Example:</P>
<P>&nbsp; struct mytype *my_search(struct rb_root *root, char *string)<BR>&nbsp; {<BR>&nbsp; &nbsp;struct rb_node *node = root-&gt;rb_node;</P>
<P>&nbsp; &nbsp;while (node) {<BR>&nbsp; &nbsp;&nbsp;struct mytype *data = container_of(node, struct mytype, node);<BR>&nbsp;&nbsp;int result;</P>
<P>&nbsp;&nbsp;result = strcmp(string, data-&gt;keystring);</P>
<P>&nbsp;&nbsp;if (result &lt; 0)<BR>&nbsp; &nbsp;&nbsp;&nbsp;node = node-&gt;rb_left;<BR>&nbsp;&nbsp;else if (result &gt; 0)<BR>&nbsp; &nbsp;&nbsp;&nbsp;node = node-&gt;rb_right;<BR>&nbsp;&nbsp;else<BR>&nbsp; &nbsp;&nbsp;&nbsp;return data;<BR>&nbsp;}<BR>&nbsp;return NULL;<BR>&nbsp; }</P>
<P>Inserting data into an rbtree<BR>-----------------------------</P>
<P>Inserting data in the tree involves first searching for the place to insert the<BR>new node, then inserting the node and rebalancing ("recoloring") the tree.</P>
<P>The search for insertion differs from the previous search by finding the<BR>location of the pointer on which to graft the new node.&nbsp; The new node also<BR>needs a link to its parent node for rebalancing purposes.</P>
<P>Example:</P>
<P>&nbsp; int my_insert(struct rb_root *root, struct mytype *data)<BR>&nbsp; {<BR>&nbsp; &nbsp;struct rb_node **new = &amp;(root-&gt;rb_node), *parent = NULL;</P>
<P>&nbsp; &nbsp;/* Figure out where to put new node */<BR>&nbsp; &nbsp;while (*new) {<BR>&nbsp; &nbsp;&nbsp;struct mytype *this = container_of(*new, struct mytype, node);<BR>&nbsp; &nbsp;&nbsp;int result = strcmp(data-&gt;keystring, this-&gt;keystring);</P>
<P>&nbsp;&nbsp;parent = *new;<BR>&nbsp; &nbsp;&nbsp;if (result &lt; 0)<BR>&nbsp; &nbsp;&nbsp;&nbsp;new = &amp;((*new)-&gt;rb_left);<BR>&nbsp; &nbsp;&nbsp;else if (result &gt; 0)<BR>&nbsp; &nbsp;&nbsp;&nbsp;new = &amp;((*new)-&gt;rb_right);<BR>&nbsp; &nbsp;&nbsp;else<BR>&nbsp; &nbsp;&nbsp;&nbsp;return FALSE;<BR>&nbsp; &nbsp;}</P>
<P>&nbsp; &nbsp;/* Add new node and rebalance tree. */<BR>&nbsp; &nbsp;rb_link_node(&amp;data-&gt;node, parent, new);<BR>&nbsp; &nbsp;rb_insert_color(&amp;data-&gt;node, root);</P>
<P>&nbsp;return TRUE;<BR>&nbsp; }</P>
<P>Removing or replacing existing data in an rbtree<BR>------------------------------------------------</P>
<P>To remove an existing node from a tree, call:</P>
<P>&nbsp; void rb_erase(struct rb_node *victim, struct rb_root *tree);</P>
<P>Example:</P>
<P>&nbsp; struct mytype *data = mysearch(&amp;mytree, "walrus");</P>
<P>&nbsp; if (data) {<BR>&nbsp; &nbsp;rb_erase(&amp;data-&gt;node, &amp;mytree);<BR>&nbsp; &nbsp;myfree(data);<BR>&nbsp; }</P>
<P>To replace an existing node in a tree with a new one with the same key, call:</P>
<P>&nbsp; void rb_replace_node(struct rb_node *old, struct rb_node *new,<BR>&nbsp; &nbsp;&nbsp;&nbsp;struct rb_root *tree);</P>
<P>Replacing a node this way does not re-sort the tree: If the new node doesn't<BR>have the same key as the old node, the rbtree will probably become corrupted.</P>
<P>Iterating through the elements stored in an rbtree (in sort order)<BR>------------------------------------------------------------------</P>
<P>Four functions are provided for iterating through an rbtree's contents in<BR>sorted order.&nbsp; These work on arbitrary trees, and should not need to be<BR>modified or wrapped (except for locking purposes):</P>
<P>&nbsp; struct rb_node *rb_first(struct rb_root *tree);<BR>&nbsp; struct rb_node *rb_last(struct rb_root *tree);<BR>&nbsp; struct rb_node *rb_next(struct rb_node *node);<BR>&nbsp; struct rb_node *rb_prev(struct rb_node *node);</P>
<P>To start iterating, call rb_first() or rb_last() with a pointer to the root<BR>of the tree, which will return a pointer to the node structure contained in<BR>the first or last element in the tree.&nbsp; To continue, fetch the next or previous<BR>node by calling rb_next() or rb_prev() on the current node.&nbsp; This will return<BR>NULL when there are no more nodes left.</P>
<P>The iterator functions return a pointer to the embedded struct rb_node, from<BR>which the containing data structure may be accessed with the container_of()<BR>macro, and individual members may be accessed directly via<BR>rb_entry(node, type, member).</P>
<P>Example:</P>
<P>&nbsp; struct rb_node *node;<BR>&nbsp; for (node = rb_first(&amp;mytree); node; node = rb_next(node))<BR>&nbsp;printk("key=%s\n", rb_entry(node, struct mytype, node)-&gt;keystring);</P>
<P>Support for Augmented rbtrees<BR>-----------------------------</P>
<P>Augmented rbtree is an rbtree with "some" additional data stored in<BR>each node, where the additional data for node N must be a function of<BR>the contents of all nodes in the subtree rooted at N. This data can<BR>be used to augment some new functionality to rbtree. Augmented rbtree<BR>is an optional feature built on top of basic rbtree infrastructure.<BR>An rbtree user who wants this feature will have to call the augmentation<BR>functions with the user provided augmentation callback when inserting<BR>and erasing nodes.</P>
<P>C files implementing augmented rbtree manipulation must include<BR>&lt;linux/rbtree_augmented.h&gt; instead of &lt;linus/rbtree.h&gt;. Note that<BR>linux/rbtree_augmented.h exposes some rbtree implementations details<BR>you are not expected to rely on; please stick to the documented APIs<BR>there and do not include &lt;linux/rbtree_augmented.h&gt; from header files<BR>either so as to minimize chances of your users accidentally relying on<BR>such implementation details.</P>
<P>On insertion, the user must update the augmented information on the path<BR>leading to the inserted node, then call rb_link_node() as usual and<BR>rb_augment_inserted() instead of the usual rb_insert_color() call.<BR>If rb_augment_inserted() rebalances the rbtree, it will callback into<BR>a user provided function to update the augmented information on the<BR>affected subtrees.</P>
<P>When erasing a node, the user must call rb_erase_augmented() instead of<BR>rb_erase(). rb_erase_augmented() calls back into user provided functions<BR>to updated the augmented information on affected subtrees.</P>
<P>In both cases, the callbacks are provided through struct rb_augment_callbacks.<BR>3 callbacks must be defined:</P>
<P>- A propagation callback, which updates the augmented value for a given<BR>&nbsp; node and its ancestors, up to a given stop point (or NULL to update<BR>&nbsp; all the way to the root).</P>
<P>- A copy callback, which copies the augmented value for a given subtree<BR>&nbsp; to a newly assigned subtree root.</P>
<P>- A tree rotation callback, which copies the augmented value for a given<BR>&nbsp; subtree to a newly assigned subtree root AND recomputes the augmented<BR>&nbsp; information for the former subtree root.</P>
<P>The compiled code for rb_erase_augmented() may inline the propagation and<BR>copy callbacks, which results in a large function, so each augmented rbtree<BR>user should have a single rb_erase_augmented() call site in order to limit<BR>compiled code size.</P>
<P><BR>Sample usage:</P>
<P>Interval tree is an example of augmented rb tree. Reference -<BR>"Introduction to Algorithms" by Cormen, Leiserson, Rivest and Stein.<BR>More details about interval trees:</P>
<P>Classical rbtree has a single key and it cannot be directly used to store<BR>interval ranges like [lo:hi] and do a quick lookup for any overlap with a new<BR>lo:hi or to find whether there is an exact match for a new lo:hi.</P>
<P>However, rbtree can be augmented to store such interval ranges in a structured<BR>way making it possible to do efficient lookup and exact match.</P>
<P>This "extra information" stored in each node is the maximum hi<BR>(max_hi) value among all the nodes that are its descendents. This<BR>information can be maintained at each node just be looking at the node<BR>and its immediate children. And this will be used in O(log n) lookup<BR>for lowest match (lowest start address among all possible matches)<BR>with something like:</P>
<P>struct interval_tree_node *<BR>interval_tree_first_match(struct rb_root *root,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned long start, unsigned long last)<BR>{<BR>&nbsp;struct interval_tree_node *node;</P>
<P>&nbsp;if (!root-&gt;rb_node)<BR>&nbsp;&nbsp;return NULL;<BR>&nbsp;node = rb_entry(root-&gt;rb_node, struct interval_tree_node, rb);</P>
<P>&nbsp;while (true) {<BR>&nbsp;&nbsp;if (node-&gt;rb.rb_left) {<BR>&nbsp;&nbsp;&nbsp;struct interval_tree_node *left =<BR>&nbsp;&nbsp;&nbsp;&nbsp;rb_entry(node-&gt;rb.rb_left,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct interval_tree_node, rb);<BR>&nbsp;&nbsp;&nbsp;if (left-&gt;__subtree_last &gt;= start) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Some nodes in left subtree satisfy Cond2.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Iterate to find the leftmost such node N.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * If it also satisfies Cond1, that's the match<BR>&nbsp;&nbsp;&nbsp;&nbsp; * we are looking for. Otherwise, there is no<BR>&nbsp;&nbsp;&nbsp;&nbsp; * matching interval as nodes to the right of N<BR>&nbsp;&nbsp;&nbsp;&nbsp; * can't satisfy Cond1 either.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;node = left;<BR>&nbsp;&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;if (node-&gt;start &lt;= last) {&nbsp;&nbsp;/* Cond1 */<BR>&nbsp;&nbsp;&nbsp;if (node-&gt;last &gt;= start)&nbsp;/* Cond2 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;return node;&nbsp;/* node is leftmost match */<BR>&nbsp;&nbsp;&nbsp;if (node-&gt;rb.rb_right) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;node = rb_entry(node-&gt;rb.rb_right,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct interval_tree_node, rb);<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (node-&gt;__subtree_last &gt;= start)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;return NULL;&nbsp;/* No match */<BR>&nbsp;}<BR>}</P>
<P>Insertion/removal are defined using the following augmented callbacks:</P>
<P>static inline unsigned long<BR>compute_subtree_last(struct interval_tree_node *node)<BR>{<BR>&nbsp;unsigned long max = node-&gt;last, subtree_last;<BR>&nbsp;if (node-&gt;rb.rb_left) {<BR>&nbsp;&nbsp;subtree_last = rb_entry(node-&gt;rb.rb_left,<BR>&nbsp;&nbsp;&nbsp;struct interval_tree_node, rb)-&gt;__subtree_last;<BR>&nbsp;&nbsp;if (max &lt; subtree_last)<BR>&nbsp;&nbsp;&nbsp;max = subtree_last;<BR>&nbsp;}<BR>&nbsp;if (node-&gt;rb.rb_right) {<BR>&nbsp;&nbsp;subtree_last = rb_entry(node-&gt;rb.rb_right,<BR>&nbsp;&nbsp;&nbsp;struct interval_tree_node, rb)-&gt;__subtree_last;<BR>&nbsp;&nbsp;if (max &lt; subtree_last)<BR>&nbsp;&nbsp;&nbsp;max = subtree_last;<BR>&nbsp;}<BR>&nbsp;return max;<BR>}</P>
<P>static void augment_propagate(struct rb_node *rb, struct rb_node *stop)<BR>{<BR>&nbsp;while (rb != stop) {<BR>&nbsp;&nbsp;struct interval_tree_node *node =<BR>&nbsp;&nbsp;&nbsp;rb_entry(rb, struct interval_tree_node, rb);<BR>&nbsp;&nbsp;unsigned long subtree_last = compute_subtree_last(node);<BR>&nbsp;&nbsp;if (node-&gt;__subtree_last == subtree_last)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;node-&gt;__subtree_last = subtree_last;<BR>&nbsp;&nbsp;rb = rb_parent(&amp;node-&gt;rb);<BR>&nbsp;}<BR>}</P>
<P>static void augment_copy(struct rb_node *rb_old, struct rb_node *rb_new)<BR>{<BR>&nbsp;struct interval_tree_node *old =<BR>&nbsp;&nbsp;rb_entry(rb_old, struct interval_tree_node, rb);<BR>&nbsp;struct interval_tree_node *new =<BR>&nbsp;&nbsp;rb_entry(rb_new, struct interval_tree_node, rb);</P>
<P>&nbsp;new-&gt;__subtree_last = old-&gt;__subtree_last;<BR>}</P>
<P>static void augment_rotate(struct rb_node *rb_old, struct rb_node *rb_new)<BR>{<BR>&nbsp;struct interval_tree_node *old =<BR>&nbsp;&nbsp;rb_entry(rb_old, struct interval_tree_node, rb);<BR>&nbsp;struct interval_tree_node *new =<BR>&nbsp;&nbsp;rb_entry(rb_new, struct interval_tree_node, rb);</P>
<P>&nbsp;new-&gt;__subtree_last = old-&gt;__subtree_last;<BR>&nbsp;old-&gt;__subtree_last = compute_subtree_last(old);<BR>}</P>
<P>static const struct rb_augment_callbacks augment_callbacks = {<BR>&nbsp;augment_propagate, augment_copy, augment_rotate<BR>};</P>
<P>void interval_tree_insert(struct interval_tree_node *node,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct rb_root *root)<BR>{<BR>&nbsp;struct rb_node **link = &amp;root-&gt;rb_node, *rb_parent = NULL;<BR>&nbsp;unsigned long start = node-&gt;start, last = node-&gt;last;<BR>&nbsp;struct interval_tree_node *parent;</P>
<P>&nbsp;while (*link) {<BR>&nbsp;&nbsp;rb_parent = *link;<BR>&nbsp;&nbsp;parent = rb_entry(rb_parent, struct interval_tree_node, rb);<BR>&nbsp;&nbsp;if (parent-&gt;__subtree_last &lt; last)<BR>&nbsp;&nbsp;&nbsp;parent-&gt;__subtree_last = last;<BR>&nbsp;&nbsp;if (start &lt; parent-&gt;start)<BR>&nbsp;&nbsp;&nbsp;link = &amp;parent-&gt;rb.rb_left;<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;link = &amp;parent-&gt;rb.rb_right;<BR>&nbsp;}</P>
<P>&nbsp;node-&gt;__subtree_last = last;<BR>&nbsp;rb_link_node(&amp;node-&gt;rb, rb_parent, link);<BR>&nbsp;rb_insert_augmented(&amp;node-&gt;rb, root, &amp;augment_callbacks);<BR>}</P>
<P>void interval_tree_remove(struct interval_tree_node *node,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct rb_root *root)<BR>{<BR>&nbsp;rb_erase_augmented(&amp;node-&gt;rb, root, &amp;augment_callbacks);<BR>}