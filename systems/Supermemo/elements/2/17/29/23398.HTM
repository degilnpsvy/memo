# Documentation/kref.txt 
<P></P>
<P><FONT class=extract>krefs allow you to add reference counters to your objects.&nbsp; If you<BR>have objects that are used in multiple places and passed around, and<BR>you don't have refcounts, your code is almost certainly broken.&nbsp; If<BR>you want refcounts, krefs are the way to go.</FONT></P>
<P><FONT class=extract></FONT></P>
<P><FONT class=extract>To use a kref, add one to your data structures like:</FONT></P>
<P><FONT class=extract>struct my_data<BR>{<BR>&nbsp;.<BR>&nbsp;.<BR>&nbsp;struct kref refcount;<BR>&nbsp;.<BR>&nbsp;.<BR>};</FONT></P>
<P><FONT class=extract>The kref can occur anywhere within the data structure.</FONT></P>
<P><FONT class=extract>You must initialize the kref after you allocate it.&nbsp; To do this, call<BR>kref_init as so:</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp; struct my_data *data;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp; data = kmalloc(sizeof(*data), GFP_KERNEL);<BR>&nbsp;&nbsp;&nbsp;&nbsp; if (!data)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -ENOMEM;<BR>&nbsp;&nbsp;&nbsp;&nbsp; kref_init(&amp;data-&gt;refcount);</FONT></P>
<P><FONT class=extract>This sets the refcount in the kref to 1.</FONT></P>
<P><FONT class=extract>Once you have an initialized kref, you must follow the following<BR>rules:</FONT></P>
<P><FONT class=extract>1) If you make a non-temporary copy of a pointer, especially if<BR>&nbsp;&nbsp; it can be passed to another thread of execution, you must<BR>&nbsp;&nbsp; increment the refcount with kref_get() before passing it off:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kref_get(&amp;data-&gt;refcount);<BR>&nbsp;&nbsp; If you already have a valid pointer to a kref-ed structure (the<BR>&nbsp;&nbsp; refcount cannot go to zero) you may do this without a lock.</FONT></P>
<P><FONT class=extract>2) When you are done with a pointer, you must call kref_put():<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kref_put(&amp;data-&gt;refcount, data_release);<BR>&nbsp;&nbsp; If this is the last reference to the pointer, the release<BR>&nbsp;&nbsp; routine will be called.&nbsp; If the code never tries to get<BR>&nbsp;&nbsp; a valid pointer to a kref-ed structure without already<BR>&nbsp;&nbsp; holding a valid pointer, it is safe to do this without<BR>&nbsp;&nbsp; a lock.</FONT></P>
<P><FONT class=extract>3) If the code attempts to gain a reference to a kref-ed structure<BR>&nbsp;&nbsp; without already holding a valid pointer, it must serialize access<BR>&nbsp;&nbsp; where a kref_put() cannot occur during the kref_get(), and the<BR>&nbsp;&nbsp; structure must remain valid during the kref_get().</FONT></P>
<P><FONT class=extract>For example, if you allocate some data and then pass it to another<BR>thread to process:</FONT></P>
<P><FONT class=extract>void data_release(struct kref *ref)<BR>{<BR>&nbsp;struct my_data *data = container_of(ref, struct my_data, refcount);<BR>&nbsp;kfree(data);<BR>}</FONT></P>
<P><FONT class=extract>void more_data_handling(void *cb_data)<BR>{<BR>&nbsp;struct my_data *data = cb_data;<BR>&nbsp;.<BR>&nbsp;. do stuff with data here<BR>&nbsp;.<BR>&nbsp;kref_put(&amp;data-&gt;refcount, data_release);<BR>}</FONT></P>
<P><FONT class=extract>int my_data_handler(void)<BR>{<BR>&nbsp;int rv = 0;<BR>&nbsp;struct my_data *data;<BR>&nbsp;struct task_struct *task;<BR>&nbsp;data = kmalloc(sizeof(*data), GFP_KERNEL);<BR>&nbsp;if (!data)<BR>&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;kref_init(&amp;data-&gt;refcount);</FONT></P>
<P><FONT class=extract>&nbsp;kref_get(&amp;data-&gt;refcount);<BR>&nbsp;task = kthread_run(more_data_handling, data, "more_data_handling");<BR>&nbsp;if (task == ERR_PTR(-ENOMEM)) {<BR>&nbsp;&nbsp;rv = -ENOMEM;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;.<BR>&nbsp;. do stuff with data here<BR>&nbsp;.<BR>&nbsp;out:<BR>&nbsp;kref_put(&amp;data-&gt;refcount, data_release);<BR>&nbsp;return rv;<BR>}</FONT></P>
<P><FONT class=extract>This way, it doesn't matter what order the two threads handle the<BR>data, the kref_put() handles knowing when the data is not referenced<BR>any more and releasing it.&nbsp; The kref_get() does not require a lock,<BR>since we already have a valid pointer that we own a refcount for.&nbsp; The<BR>put needs no lock because nothing tries to get the data without<BR>already holding a pointer.</FONT></P>
<P><FONT class=extract>Note that the "before" in rule 1 is very important.&nbsp; You should never<BR>do something like:</FONT></P>
<P><FONT class=extract>&nbsp;task = kthread_run(more_data_handling, data, "more_data_handling");<BR>&nbsp;if (task == ERR_PTR(-ENOMEM)) {<BR>&nbsp;&nbsp;rv = -ENOMEM;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;} else<BR>&nbsp;&nbsp;/* BAD BAD BAD - get is after the handoff */<BR>&nbsp;&nbsp;kref_get(&amp;data-&gt;refcount);</FONT></P>
<P><FONT class=extract>Don't assume you know what you are doing and use the above construct.<BR>First of all, you may not know what you are doing.&nbsp; Second, you may<BR>know what you are doing (there are some situations where locking is<BR>involved where the above may be legal) but someone else who doesn't<BR>know what they are doing may change the code or copy the code.&nbsp; It's<BR>bad style.&nbsp; Don't do it.</FONT></P>
<P><FONT class=extract>There are some situations where you can optimize the gets and puts.<BR>For instance, if you are done with an object and enqueuing it for<BR>something else or passing it off to something else, there is no reason<BR>to do a get then a put:</FONT></P>
<P><FONT class=extract>&nbsp;/* Silly extra get and put */<BR>&nbsp;kref_get(&amp;obj-&gt;ref);<BR>&nbsp;enqueue(obj);<BR>&nbsp;kref_put(&amp;obj-&gt;ref, obj_cleanup);</FONT></P>
<P><FONT class=extract>Just do the enqueue.&nbsp; A comment about this is always welcome:</FONT></P>
<P><FONT class=extract>&nbsp;enqueue(obj);<BR>&nbsp;/* We are done with obj, so we pass our refcount off<BR>&nbsp;&nbsp;&nbsp; to the queue.&nbsp; DON'T TOUCH obj AFTER HERE! */</FONT></P>
<P><FONT class=extract>The last rule (rule 3) is the nastiest one to handle.&nbsp; Say, for<BR>instance, you have a list of items that are each kref-ed, and you wish<BR>to get the first one.&nbsp; You can't just pull the first item off the list<BR>and kref_get() it.&nbsp; That violates rule 3 because you are not already<BR>holding a valid pointer.&nbsp; You must add a mutex (or some other lock).<BR>For instance:</FONT></P>
<P><FONT class=extract>static DEFINE_MUTEX(mutex);<BR>static LIST_HEAD(q);<BR>struct my_data<BR>{<BR>&nbsp;struct kref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; refcount;<BR>&nbsp;struct list_head link;<BR>};</FONT></P>
<P><FONT class=extract>static struct my_data *get_entry()<BR>{<BR>&nbsp;struct my_data *entry = NULL;<BR>&nbsp;mutex_lock(&amp;mutex);<BR>&nbsp;if (!list_empty(&amp;q)) {<BR>&nbsp;&nbsp;entry = container_of(q.next, struct my_data, link);<BR>&nbsp;&nbsp;kref_get(&amp;entry-&gt;refcount);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;mutex);<BR>&nbsp;return entry;<BR>}</FONT></P>
<P><FONT class=extract>static void release_entry(struct kref *ref)<BR>{<BR>&nbsp;struct my_data *entry = container_of(ref, struct my_data, refcount);</FONT></P>
<P><FONT class=extract>&nbsp;list_del(&amp;entry-&gt;link);<BR>&nbsp;kfree(entry);<BR>}</FONT></P>
<P><FONT class=extract>static void put_entry(struct my_data *entry)<BR>{<BR>&nbsp;mutex_lock(&amp;mutex);<BR>&nbsp;kref_put(&amp;entry-&gt;refcount, release_entry);<BR>&nbsp;mutex_unlock(&amp;mutex);<BR>}</FONT></P>
<P><FONT class=extract>The kref_put() return value is useful if you do not want to hold the<BR>lock during the whole release operation.&nbsp; Say you didn't want to call<BR>kfree() with the lock held in the example above (since it is kind of<BR>pointless to do so).&nbsp; You could use kref_put() as follows:</FONT></P>
<P><FONT class=extract>static void release_entry(struct kref *ref)<BR>{<BR>&nbsp;/* All work is done after the return from kref_put(). */<BR>}</FONT></P>
<P><FONT class=extract>static void put_entry(struct my_data *entry)<BR>{<BR>&nbsp;mutex_lock(&amp;mutex);<BR>&nbsp;if (kref_put(&amp;entry-&gt;refcount, release_entry)) {<BR>&nbsp;&nbsp;list_del(&amp;entry-&gt;link);<BR>&nbsp;&nbsp;mutex_unlock(&amp;mutex);<BR>&nbsp;&nbsp;kfree(entry);<BR>&nbsp;} else<BR>&nbsp;&nbsp;mutex_unlock(&amp;mutex);<BR>}</FONT></P>
<P><FONT class=extract>This is really more useful if you have to call other routines as part<BR>of the free operations that could take a long time or might claim the<BR>same lock.&nbsp; Note that doing everything in the release routine is still<BR>preferred as it is a little neater.</FONT></P>
<P><BR>Corey Minyard &lt;<A href="mailto:minyard@acm.org">minyard@acm.org</A>&gt;</P>
<P>A lot of this was lifted from Greg Kroah-Hartman's 2004 OLS paper and<BR>presentation on krefs, which can be found at:<BR>&nbsp; <A href="http://www.kroah.com/linux/talks/ols_2004_kref_paper/Reprint-Kroah-Hartman-OLS2004.pdf">http://www.kroah.com/linux/talks/ols_2004_kref_paper/Reprint-Kroah-Hartman-OLS2004.pdf</A><BR>and:<BR>&nbsp; <A href="http://www.kroah.com/linux/talks/ols_2004_kref_talk/">http://www.kroah.com/linux/talks/ols_2004_kref_talk/</A></P>
<P><BR><FONT class=extract>The above example could also be optimized using kref_get_unless_zero() in<BR>the following way:</FONT></P>
<P><FONT class=extract>static struct my_data *get_entry()<BR>{<BR>&nbsp;struct my_data *entry = NULL;<BR>&nbsp;mutex_lock(&amp;mutex);<BR>&nbsp;if (!list_empty(&amp;q)) {<BR>&nbsp;&nbsp;entry = container_of(q.next, struct my_data, link);<BR>&nbsp;&nbsp;if (!kref_get_unless_zero(&amp;entry-&gt;refcount))<BR>&nbsp;&nbsp;&nbsp;entry = NULL;<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;mutex);<BR>&nbsp;return entry;<BR>}</FONT></P>
<P><FONT class=extract>static void release_entry(struct kref *ref)<BR>{<BR>&nbsp;struct my_data *entry = container_of(ref, struct my_data, refcount);</FONT></P>
<P><FONT class=extract>&nbsp;mutex_lock(&amp;mutex);<BR>&nbsp;list_del(&amp;entry-&gt;link);<BR>&nbsp;mutex_unlock(&amp;mutex);<BR>&nbsp;kfree(entry);<BR>}</FONT></P>
<P><FONT class=extract>static void put_entry(struct my_data *entry)<BR>{<BR>&nbsp;kref_put(&amp;entry-&gt;refcount, release_entry);<BR>}</FONT></P>
<P><FONT class=extract>Which is useful to remove the mutex lock around kref_put() in put_entry(), but<BR>it's important that kref_get_unless_zero is enclosed in the same critical<BR>section that finds the entry in the lookup table,<BR>otherwise kref_get_unless_zero may reference already freed memory.<BR>Note that it is illegal to use kref_get_unless_zero without checking its<BR>return value. If you are sure (by already having a valid pointer) that<BR>kref_get_unless_zero() will return true, then use kref_get() instead.</FONT></P>
<P><FONT class=extract>The function kref_get_unless_zero also makes it possible to use rcu<BR>locking for lookups in the above example:</FONT></P>
<P><FONT class=extract>struct my_data<BR>{<BR>&nbsp;struct rcu_head rhead;<BR>&nbsp;.<BR>&nbsp;struct kref refcount;<BR>&nbsp;.<BR>&nbsp;.<BR>};</FONT></P>
<P><FONT class=extract>static struct my_data *get_entry_rcu()<BR>{<BR>&nbsp;struct my_data *entry = NULL;<BR>&nbsp;rcu_read_lock();<BR>&nbsp;if (!list_empty(&amp;q)) {<BR>&nbsp;&nbsp;entry = container_of(q.next, struct my_data, link);<BR>&nbsp;&nbsp;if (!kref_get_unless_zero(&amp;entry-&gt;refcount))<BR>&nbsp;&nbsp;&nbsp;entry = NULL;<BR>&nbsp;}<BR>&nbsp;rcu_read_unlock();<BR>&nbsp;return entry;<BR>}</FONT></P>
<P><FONT class=extract>static void release_entry_rcu(struct kref *ref)<BR>{<BR>&nbsp;struct my_data *entry = container_of(ref, struct my_data, refcount);</FONT></P>
<P><FONT class=extract>&nbsp;mutex_lock(&amp;mutex);<BR>&nbsp;list_del_rcu(&amp;entry-&gt;link);<BR>&nbsp;mutex_unlock(&amp;mutex);<BR>&nbsp;kfree_rcu(entry, rhead);<BR>}</FONT></P>
<P><FONT class=extract>static void put_entry(struct my_data *entry)<BR>{<BR>&nbsp;kref_put(&amp;entry-&gt;refcount, release_entry_rcu);<BR>}</FONT></P>
<P><FONT class=extract>But note that the struct kref member needs to remain in valid memory for a<BR>rcu grace period after release_entry_rcu was called. That can be accomplished<BR>by using kfree_rcu(entry, rhead) as done above, or by calling synchronize_rcu()<BR>before using kfree, but note that synchronize_rcu() may sleep for a<BR>substantial amount of time.</FONT></P>
<P><BR>Thomas Hellstrom &lt;<A href="mailto:thellstrom@vmware.com">thellstrom@vmware.com</A>&gt;