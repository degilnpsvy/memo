<H3 id=title-IDAZ33PF class=docSection1Title>15.1. Target Debugging</H3>
<P class=docText>We already explored several important debugging tools in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch13.html#ch13">Chapter 13</A>, "Development Tools." <TT>strace</TT> and <TT>ltrace</TT> can be used to observe and characterize a process's behavior and often isolate problems. <TT>dmalloc</TT> can help isolate memory leaks and profile memory usage. <TT>ps</TT> and <TT>top</TT> are both useful for examining the state of processes. These relatively small tools are designed to run directly on the target hardware.</P>
<P class=docText>Debugging Linux application code on an embedded system has its own unique challenges. Resources on your embedded target are often limited. RAM and nonvolatile storage limitations might prevent you from running target-based development tools. You might not have an Ethernet port or other high-speed connection. Your target embedded system might not have a graphical display, keyboard, or mouse.</P>
<P class=docText>This is where your cross-development tools and an NFS root mount environment can yield large dividends. Many tools, especially GDB, have been architected to execute on your development host while actually debugging code on a remote target. GDB can be used to interactively debug your target code or to perform a postmortem analysis of a core file generated by an application crash. We covered the details of application core dump analysis in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch13.html#ch13">Chapter 13</A>.