# Documentation/kmemleak.txt
<P></P>
<P>Kernel Memory Leak Detector<BR>===========================</P>
<P></P>
<P>Introduction<BR>------------</P>
<P>Kmemleak provides a way of detecting possible kernel memory leaks in a<BR>way similar to a tracing garbage collector<BR>(<A href="http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29#Tracing_garbage_collectors">http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29#Tracing_garbage_collectors</A>),<BR>with the difference that the orphan objects are not freed but only<BR>reported via /sys/kernel/debug/kmemleak. A similar method is used by the<BR>Valgrind tool (memcheck --leak-check) to detect the memory leaks in<BR>user-space applications.</P>
<P>Please check DEBUG_KMEMLEAK dependencies in lib/Kconfig.debug for supported<BR>architectures.</P>
<P>Usage<BR>-----</P>
<P>CONFIG_DEBUG_KMEMLEAK in "Kernel hacking" has to be enabled. A kernel<BR>thread scans the memory every 10 minutes (by default) and prints the<BR>number of new unreferenced objects found. To display the details of all<BR>the possible memory leaks:</P>
<P>&nbsp; # mount -t debugfs nodev /sys/kernel/debug/<BR>&nbsp; # cat /sys/kernel/debug/kmemleak</P>
<P>To trigger an intermediate memory scan:</P>
<P>&nbsp; # echo scan &gt; /sys/kernel/debug/kmemleak</P>
<P>To clear the list of all current possible memory leaks:</P>
<P>&nbsp; # echo clear &gt; /sys/kernel/debug/kmemleak</P>
<P>New leaks will then come up upon reading /sys/kernel/debug/kmemleak<BR>again.</P>
<P>Note that the orphan objects are listed in the order they were allocated<BR>and one object at the beginning of the list may cause other subsequent<BR>objects to be reported as orphan.</P>
<P>Memory scanning parameters can be modified at run-time by writing to the<BR>/sys/kernel/debug/kmemleak file. The following parameters are supported:</P>
<P>&nbsp; off&nbsp;&nbsp;- disable kmemleak (irreversible)<BR>&nbsp; stack=on&nbsp;- enable the task stacks scanning (default)<BR>&nbsp; stack=off&nbsp;- disable the tasks stacks scanning<BR>&nbsp; scan=on&nbsp;- start the automatic memory scanning thread (default)<BR>&nbsp; scan=off&nbsp;- stop the automatic memory scanning thread<BR>&nbsp; scan=&lt;secs&gt;&nbsp;- set the automatic memory scanning period in seconds<BR>&nbsp;&nbsp;&nbsp; (default 600, 0 to stop the automatic scanning)<BR>&nbsp; scan&nbsp;&nbsp;- trigger a memory scan<BR>&nbsp; clear&nbsp;&nbsp;- clear list of current memory leak suspects, done by<BR>&nbsp;&nbsp;&nbsp; marking all current reported unreferenced objects grey<BR>&nbsp; dump=&lt;addr&gt;&nbsp;- dump information about the object found at &lt;addr&gt;</P>
<P>Kmemleak can also be disabled at boot-time by passing "kmemleak=off" on<BR>the kernel command line.</P>
<P>Memory may be allocated or freed before kmemleak is initialised and<BR>these actions are stored in an early log buffer. The size of this buffer<BR>is configured via the CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE option.</P>
<P>Basic Algorithm<BR>---------------</P>
<P>The memory allocations via kmalloc, vmalloc, kmem_cache_alloc and<BR>friends are traced and the pointers, together with additional<BR>information like size and stack trace, are stored in a prio search tree.<BR>The corresponding freeing function calls are tracked and the pointers<BR>removed from the kmemleak data structures.</P>
<P>An allocated block of memory is considered orphan if no pointer to its<BR>start address or to any location inside the block can be found by<BR>scanning the memory (including saved registers). This means that there<BR>might be no way for the kernel to pass the address of the allocated<BR>block to a freeing function and therefore the block is considered a<BR>memory leak.</P>
<P>The scanning algorithm steps:</P>
<P>&nbsp; 1. mark all objects as white (remaining white objects will later be<BR>&nbsp;&nbsp;&nbsp;&nbsp; considered orphan)<BR>&nbsp; 2. scan the memory starting with the data section and stacks, checking<BR>&nbsp;&nbsp;&nbsp;&nbsp; the values against the addresses stored in the prio search tree. If<BR>&nbsp;&nbsp;&nbsp;&nbsp; a pointer to a white object is found, the object is added to the<BR>&nbsp;&nbsp;&nbsp;&nbsp; gray list<BR>&nbsp; 3. scan the gray objects for matching addresses (some white objects<BR>&nbsp;&nbsp;&nbsp;&nbsp; can become gray and added at the end of the gray list) until the<BR>&nbsp;&nbsp;&nbsp;&nbsp; gray set is finished<BR>&nbsp; 4. the remaining white objects are considered orphan and reported via<BR>&nbsp;&nbsp;&nbsp;&nbsp; /sys/kernel/debug/kmemleak</P>
<P>Some allocated memory blocks have pointers stored in the kernel's<BR>internal data structures and they cannot be detected as orphans. To<BR>avoid this, kmemleak can also store the number of values pointing to an<BR>address inside the block address range that need to be found so that the<BR>block is not considered a leak. One example is __vmalloc().</P>
<P>Testing specific sections with kmemleak<BR>---------------------------------------</P>
<P>Upon initial bootup your /sys/kernel/debug/kmemleak output page may be<BR>quite extensive. This can also be the case if you have very buggy code<BR>when doing development. To work around these situations you can use the<BR>'clear' command to clear all reported unreferenced objects from the<BR>/sys/kernel/debug/kmemleak output. By issuing a 'scan' after a 'clear'<BR>you can find new unreferenced objects; this should help with testing<BR>specific sections of code.</P>
<P>To test a critical section on demand with a clean kmemleak do:</P>
<P>&nbsp; # echo clear &gt; /sys/kernel/debug/kmemleak<BR>&nbsp; ... test your kernel or modules ...<BR>&nbsp; # echo scan &gt; /sys/kernel/debug/kmemleak</P>
<P>Then as usual to get your report with:</P>
<P>&nbsp; # cat /sys/kernel/debug/kmemleak</P>
<P>Kmemleak API<BR>------------</P>
<P>See the include/linux/kmemleak.h header for the functions prototype.</P>
<P>kmemleak_init&nbsp;&nbsp; - initialize kmemleak<BR>kmemleak_alloc&nbsp;&nbsp; - notify of a memory block allocation<BR>kmemleak_alloc_percpu&nbsp; - notify of a percpu memory block allocation<BR>kmemleak_free&nbsp;&nbsp; - notify of a memory block freeing<BR>kmemleak_free_part&nbsp; - notify of a partial memory block freeing<BR>kmemleak_free_percpu&nbsp; - notify of a percpu memory block freeing<BR>kmemleak_not_leak&nbsp; - mark an object as not a leak<BR>kmemleak_ignore&nbsp;&nbsp; - do not scan or report an object as leak<BR>kmemleak_scan_area&nbsp; - add scan areas inside a memory block<BR>kmemleak_no_scan&nbsp; - do not scan a memory block<BR>kmemleak_erase&nbsp;&nbsp; - erase an old value in a pointer variable<BR>kmemleak_alloc_recursive - as kmemleak_alloc but checks the recursiveness<BR>kmemleak_free_recursive&nbsp; - as kmemleak_free but checks the recursiveness</P>
<P>Dealing with false positives/negatives<BR>--------------------------------------</P>
<P>The false negatives are real memory leaks (orphan objects) but not<BR>reported by kmemleak because values found during the memory scanning<BR>point to such objects. To reduce the number of false negatives, kmemleak<BR>provides the kmemleak_ignore, kmemleak_scan_area, kmemleak_no_scan and<BR>kmemleak_erase functions (see above). The task stacks also increase the<BR>amount of false negatives and their scanning is not enabled by default.</P>
<P>The false positives are objects wrongly reported as being memory leaks<BR>(orphan). For objects known not to be leaks, kmemleak provides the<BR>kmemleak_not_leak function. The kmemleak_ignore could also be used if<BR>the memory block is known not to contain other pointers and it will no<BR>longer be scanned.</P>
<P>Some of the reported leaks are only transient, especially on SMP<BR>systems, because of pointers temporarily stored in CPU registers or<BR>stacks. Kmemleak defines MSECS_MIN_AGE (defaulting to 1000) representing<BR>the minimum age of an object to be reported as a memory leak.</P>
<P>Limitations and Drawbacks<BR>-------------------------</P>
<P>The main drawback is the reduced performance of memory allocation and<BR>freeing. To avoid other penalties, the memory scanning is only performed<BR>when the /sys/kernel/debug/kmemleak file is read. Anyway, this tool is<BR>intended for debugging purposes where the performance might not be the<BR>most important requirement.</P>
<P>To keep the algorithm simple, kmemleak scans for values pointing to any<BR>address inside a block's address range. This may lead to an increased<BR>number of false negatives. However, it is likely that a real memory leak<BR>will eventually become visible.</P>
<P>Another source of false negatives is the data stored in non-pointer<BR>values. In a future version, kmemleak could only scan the pointer<BR>members in the allocated structures. This feature would solve many of<BR>the false negative cases described above.</P>
<P>The tool can report false positives. These are cases where an allocated<BR>block doesn't need to be freed (some cases in the init_call functions),<BR>the pointer is calculated by other methods than the usual container_of<BR>macro or the pointer is stored in a location not scanned by kmemleak.</P>
<P>Page allocations and ioremap are not tracked.