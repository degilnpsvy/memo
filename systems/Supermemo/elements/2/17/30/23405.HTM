# Documentation/kprobes.txt
<P></P>
<P>Title&nbsp;: Kernel Probes (Kprobes)<BR>Authors&nbsp;: Jim Keniston &lt;<A href="mailto:jkenisto@us.ibm.com">jkenisto@us.ibm.com</A>&gt;<BR>&nbsp;: Prasanna S Panchamukhi &lt;<A href="mailto:prasanna.panchamukhi@gmail.com">prasanna.panchamukhi@gmail.com</A>&gt;<BR>&nbsp;: Masami Hiramatsu &lt;<A href="mailto:mhiramat@redhat.com">mhiramat@redhat.com</A>&gt;</P>
<P></P>
<P>CONTENTS</P>
<P>1. Concepts: Kprobes, Jprobes, Return Probes<BR>2. Architectures Supported<BR>3. Configuring Kprobes<BR>4. API Reference<BR>5. Kprobes Features and Limitations<BR>6. Probe Overhead<BR>7. TODO<BR>8. Kprobes Example<BR>9. Jprobes Example<BR>10. Kretprobes Example<BR>Appendix A: The kprobes debugfs interface<BR>Appendix B: The kprobes sysctl interface</P>
<P>1. Concepts: Kprobes, Jprobes, Return Probes</P>
<P>Kprobes enables you to dynamically break into any kernel routine and<BR>collect debugging and performance information non-disruptively. You<BR>can trap at almost any kernel code address, specifying a handler<BR>routine to be invoked when the breakpoint is hit.</P>
<P>There are currently three types of probes: kprobes, jprobes, and<BR>kretprobes (also called return probes).&nbsp; A kprobe can be inserted<BR>on virtually any instruction in the kernel.&nbsp; A jprobe is inserted at<BR>the entry to a kernel function, and provides convenient access to the<BR>function's arguments.&nbsp; A return probe fires when a specified function<BR>returns.</P>
<P>In the typical case, Kprobes-based instrumentation is packaged as<BR>a kernel module.&nbsp; The module's init function installs ("registers")<BR>one or more probes, and the exit function unregisters them.&nbsp; A<BR>registration function such as register_kprobe() specifies where<BR>the probe is to be inserted and what handler is to be called when<BR>the probe is hit.</P>
<P>There are also register_/unregister_*probes() functions for batch<BR>registration/unregistration of a group of *probes. These functions<BR>can speed up unregistration process when you have to unregister<BR>a lot of probes at once.</P>
<P>The next four subsections explain how the different types of<BR>probes work and how jump optimization works.&nbsp; They explain certain<BR>things that you'll need to know in order to make the best use of<BR>Kprobes -- e.g., the difference between a pre_handler and<BR>a post_handler, and how to use the maxactive and nmissed fields of<BR>a kretprobe.&nbsp; But if you're in a hurry to start using Kprobes, you<BR>can skip ahead to section 2.</P>
<P>1.1 How Does a Kprobe Work?</P>
<P>When a kprobe is registered, Kprobes makes a copy of the probed<BR>instruction and replaces the first byte(s) of the probed instruction<BR>with a breakpoint instruction (e.g., int3 on i386 and x86_64).</P>
<P>When a CPU hits the breakpoint instruction, a trap occurs, the CPU's<BR>registers are saved, and control passes to Kprobes via the<BR>notifier_call_chain mechanism.&nbsp; Kprobes executes the "pre_handler"<BR>associated with the kprobe, passing the handler the addresses of the<BR>kprobe struct and the saved registers.</P>
<P>Next, Kprobes single-steps its copy of the probed instruction.<BR>(It would be simpler to single-step the actual instruction in place,<BR>but then Kprobes would have to temporarily remove the breakpoint<BR>instruction.&nbsp; This would open a small time window when another CPU<BR>could sail right past the probepoint.)</P>
<P>After the instruction is single-stepped, Kprobes executes the<BR>"post_handler," if any, that is associated with the kprobe.<BR>Execution then continues with the instruction following the probepoint.</P>
<P>1.2 How Does a Jprobe Work?</P>
<P>A jprobe is implemented using a kprobe that is placed on a function's<BR>entry point.&nbsp; It employs a simple mirroring principle to allow<BR>seamless access to the probed function's arguments.&nbsp; The jprobe<BR>handler routine should have the same signature (arg list and return<BR>type) as the function being probed, and must always end by calling<BR>the Kprobes function jprobe_return().</P>
<P>Here's how it works.&nbsp; When the probe is hit, Kprobes makes a copy of<BR>the saved registers and a generous portion of the stack (see below).<BR>Kprobes then points the saved instruction pointer at the jprobe's<BR>handler routine, and returns from the trap.&nbsp; As a result, control<BR>passes to the handler, which is presented with the same register and<BR>stack contents as the probed function.&nbsp; When it is done, the handler<BR>calls jprobe_return(), which traps again to restore the original stack<BR>contents and processor state and switch to the probed function.</P>
<P>By convention, the callee owns its arguments, so gcc may produce code<BR>that unexpectedly modifies that portion of the stack.&nbsp; This is why<BR>Kprobes saves a copy of the stack and restores it after the jprobe<BR>handler has run.&nbsp; Up to MAX_STACK_SIZE bytes are copied -- e.g.,<BR>64 bytes on i386.</P>
<P>Note that the probed function's args may be passed on the stack<BR>or in registers.&nbsp; The jprobe will work in either case, so long as the<BR>handler's prototype matches that of the probed function.</P>
<P>1.3 Return Probes</P>
<P>1.3.1 How Does a Return Probe Work?</P>
<P>When you call register_kretprobe(), Kprobes establishes a kprobe at<BR>the entry to the function.&nbsp; When the probed function is called and this<BR>probe is hit, Kprobes saves a copy of the return address, and replaces<BR>the return address with the address of a "trampoline."&nbsp; The trampoline<BR>is an arbitrary piece of code -- typically just a nop instruction.<BR>At boot time, Kprobes registers a kprobe at the trampoline.</P>
<P>When the probed function executes its return instruction, control<BR>passes to the trampoline and that probe is hit.&nbsp; Kprobes' trampoline<BR>handler calls the user-specified return handler associated with the<BR>kretprobe, then sets the saved instruction pointer to the saved return<BR>address, and that's where execution resumes upon return from the trap.</P>
<P>While the probed function is executing, its return address is<BR>stored in an object of type kretprobe_instance.&nbsp; Before calling<BR>register_kretprobe(), the user sets the maxactive field of the<BR>kretprobe struct to specify how many instances of the specified<BR>function can be probed simultaneously.&nbsp; register_kretprobe()<BR>pre-allocates the indicated number of kretprobe_instance objects.</P>
<P>For example, if the function is non-recursive and is called with a<BR>spinlock held, maxactive = 1 should be enough.&nbsp; If the function is<BR>non-recursive and can never relinquish the CPU (e.g., via a semaphore<BR>or preemption), NR_CPUS should be enough.&nbsp; If maxactive &lt;= 0, it is<BR>set to a default value.&nbsp; If CONFIG_PREEMPT is enabled, the default<BR>is max(10, 2*NR_CPUS).&nbsp; Otherwise, the default is NR_CPUS.</P>
<P>It's not a disaster if you set maxactive too low; you'll just miss<BR>some probes.&nbsp; In the kretprobe struct, the nmissed field is set to<BR>zero when the return probe is registered, and is incremented every<BR>time the probed function is entered but there is no kretprobe_instance<BR>object available for establishing the return probe.</P>
<P>1.3.2 Kretprobe entry-handler</P>
<P>Kretprobes also provides an optional user-specified handler which runs<BR>on function entry. This handler is specified by setting the entry_handler<BR>field of the kretprobe struct. Whenever the kprobe placed by kretprobe at the<BR>function entry is hit, the user-defined entry_handler, if any, is invoked.<BR>If the entry_handler returns 0 (success) then a corresponding return handler<BR>is guaranteed to be called upon function return. If the entry_handler<BR>returns a non-zero error then Kprobes leaves the return address as is, and<BR>the kretprobe has no further effect for that particular function instance.</P>
<P>Multiple entry and return handler invocations are matched using the unique<BR>kretprobe_instance object associated with them. Additionally, a user<BR>may also specify per return-instance private data to be part of each<BR>kretprobe_instance object. This is especially useful when sharing private<BR>data between corresponding user entry and return handlers. The size of each<BR>private data object can be specified at kretprobe registration time by<BR>setting the data_size field of the kretprobe struct. This data can be<BR>accessed through the data field of each kretprobe_instance object.</P>
<P>In case probed function is entered but there is no kretprobe_instance<BR>object available, then in addition to incrementing the nmissed count,<BR>the user entry_handler invocation is also skipped.</P>
<P>1.4 How Does Jump Optimization Work?</P>
<P>If your kernel is built with CONFIG_OPTPROBES=y (currently this flag<BR>is automatically set 'y' on x86/x86-64, non-preemptive kernel) and<BR>the "debug.kprobes_optimization" kernel parameter is set to 1 (see<BR>sysctl(8)), Kprobes tries to reduce probe-hit overhead by using a jump<BR>instruction instead of a breakpoint instruction at each probepoint.</P>
<P>1.4.1 Init a Kprobe</P>
<P>When a probe is registered, before attempting this optimization,<BR>Kprobes inserts an ordinary, breakpoint-based kprobe at the specified<BR>address. So, even if it's not possible to optimize this particular<BR>probepoint, there'll be a probe there.</P>
<P>1.4.2 Safety Check</P>
<P>Before optimizing a probe, Kprobes performs the following safety checks:</P>
<P>- Kprobes verifies that the region that will be replaced by the jump<BR>instruction (the "optimized region") lies entirely within one function.<BR>(A jump instruction is multiple bytes, and so may overlay multiple<BR>instructions.)</P>
<P>- Kprobes analyzes the entire function and verifies that there is no<BR>jump into the optimized region.&nbsp; Specifically:<BR>&nbsp; - the function contains no indirect jump;<BR>&nbsp; - the function contains no instruction that causes an exception (since<BR>&nbsp; the fixup code triggered by the exception could jump back into the<BR>&nbsp; optimized region -- Kprobes checks the exception tables to verify this);<BR>&nbsp; and<BR>&nbsp; - there is no near jump to the optimized region (other than to the first<BR>&nbsp; byte).</P>
<P>- For each instruction in the optimized region, Kprobes verifies that<BR>the instruction can be executed out of line.</P>
<P>1.4.3 Preparing Detour Buffer</P>
<P>Next, Kprobes prepares a "detour" buffer, which contains the following<BR>instruction sequence:<BR>- code to push the CPU's registers (emulating a breakpoint trap)<BR>- a call to the trampoline code which calls user's probe handlers.<BR>- code to restore registers<BR>- the instructions from the optimized region<BR>- a jump back to the original execution path.</P>
<P>1.4.4 Pre-optimization</P>
<P>After preparing the detour buffer, Kprobes verifies that none of the<BR>following situations exist:<BR>- The probe has either a break_handler (i.e., it's a jprobe) or a<BR>post_handler.<BR>- Other instructions in the optimized region are probed.<BR>- The probe is disabled.<BR>In any of the above cases, Kprobes won't start optimizing the probe.<BR>Since these are temporary situations, Kprobes tries to start<BR>optimizing it again if the situation is changed.</P>
<P>If the kprobe can be optimized, Kprobes enqueues the kprobe to an<BR>optimizing list, and kicks the kprobe-optimizer workqueue to optimize<BR>it.&nbsp; If the to-be-optimized probepoint is hit before being optimized,<BR>Kprobes returns control to the original instruction path by setting<BR>the CPU's instruction pointer to the copied code in the detour buffer<BR>-- thus at least avoiding the single-step.</P>
<P>1.4.5 Optimization</P>
<P>The Kprobe-optimizer doesn't insert the jump instruction immediately;<BR>rather, it calls synchronize_sched() for safety first, because it's<BR>possible for a CPU to be interrupted in the middle of executing the<BR>optimized region(*).&nbsp; As you know, synchronize_sched() can ensure<BR>that all interruptions that were active when synchronize_sched()<BR>was called are done, but only if CONFIG_PREEMPT=n.&nbsp; So, this version<BR>of kprobe optimization supports only kernels with CONFIG_PREEMPT=n.(**)</P>
<P>After that, the Kprobe-optimizer calls stop_machine() to replace<BR>the optimized region with a jump instruction to the detour buffer,<BR>using text_poke_smp().</P>
<P>1.4.6 Unoptimization</P>
<P>When an optimized kprobe is unregistered, disabled, or blocked by<BR>another kprobe, it will be unoptimized.&nbsp; If this happens before<BR>the optimization is complete, the kprobe is just dequeued from the<BR>optimized list.&nbsp; If the optimization has been done, the jump is<BR>replaced with the original code (except for an int3 breakpoint in<BR>the first byte) by using text_poke_smp().</P>
<P>(*)Please imagine that the 2nd instruction is interrupted and then<BR>the optimizer replaces the 2nd instruction with the jump *address*<BR>while the interrupt handler is running. When the interrupt<BR>returns to original address, there is no valid instruction,<BR>and it causes an unexpected result.</P>
<P>(**)This optimization-safety checking may be replaced with the<BR>stop-machine method that ksplice uses for supporting a CONFIG_PREEMPT=y<BR>kernel.</P>
<P>NOTE for geeks:<BR>The jump optimization changes the kprobe's pre_handler behavior.<BR>Without optimization, the pre_handler can change the kernel's execution<BR>path by changing regs-&gt;ip and returning 1.&nbsp; However, when the probe<BR>is optimized, that modification is ignored.&nbsp; Thus, if you want to<BR>tweak the kernel's execution path, you need to suppress optimization,<BR>using one of the following techniques:<BR>- Specify an empty function for the kprobe's post_handler or break_handler.<BR>&nbsp;or<BR>- Execute 'sysctl -w debug.kprobes_optimization=n'</P>
<P>2. Architectures Supported</P>
<P>Kprobes, jprobes, and return probes are implemented on the following<BR>architectures:</P>
<P>- i386 (Supports jump optimization)<BR>- x86_64 (AMD-64, EM64T) (Supports jump optimization)<BR>- ppc64<BR>- ia64 (Does not support probes on instruction slot1.)<BR>- sparc64 (Return probes not yet implemented.)<BR>- arm<BR>- ppc<BR>- mips</P>
<P>3. Configuring Kprobes</P>
<P>When configuring the kernel using make menuconfig/xconfig/oldconfig,<BR>ensure that CONFIG_KPROBES is set to "y".&nbsp; Under "Instrumentation<BR>Support", look for "Kprobes".</P>
<P>So that you can load and unload Kprobes-based instrumentation modules,<BR>make sure "Loadable module support" (CONFIG_MODULES) and "Module<BR>unloading" (CONFIG_MODULE_UNLOAD) are set to "y".</P>
<P>Also make sure that CONFIG_KALLSYMS and perhaps even CONFIG_KALLSYMS_ALL<BR>are set to "y", since kallsyms_lookup_name() is used by the in-kernel<BR>kprobe address resolution code.</P>
<P>If you need to insert a probe in the middle of a function, you may find<BR>it useful to "Compile the kernel with debug info" (CONFIG_DEBUG_INFO),<BR>so you can use "objdump -d -l vmlinux" to see the source-to-object<BR>code mapping.</P>
<P>4. API Reference</P>
<P>The Kprobes API includes a "register" function and an "unregister"<BR>function for each type of probe. The API also includes "register_*probes"<BR>and "unregister_*probes" functions for (un)registering arrays of probes.<BR>Here are terse, mini-man-page specifications for these functions and<BR>the associated probe handlers that you'll write. See the files in the<BR>samples/kprobes/ sub-directory for examples.</P>
<P>4.1 register_kprobe</P>
<P>#include &lt;linux/kprobes.h&gt;<BR>int register_kprobe(struct kprobe *kp);</P>
<P>Sets a breakpoint at the address kp-&gt;addr.&nbsp; When the breakpoint is<BR>hit, Kprobes calls kp-&gt;pre_handler.&nbsp; After the probed instruction<BR>is single-stepped, Kprobe calls kp-&gt;post_handler.&nbsp; If a fault<BR>occurs during execution of kp-&gt;pre_handler or kp-&gt;post_handler,<BR>or during single-stepping of the probed instruction, Kprobes calls<BR>kp-&gt;fault_handler.&nbsp; Any or all handlers can be NULL. If kp-&gt;flags<BR>is set KPROBE_FLAG_DISABLED, that kp will be registered but disabled,<BR>so, its handlers aren't hit until calling enable_kprobe(kp).</P>
<P>NOTE:<BR>1. With the introduction of the "symbol_name" field to struct kprobe,<BR>the probepoint address resolution will now be taken care of by the kernel.<BR>The following will now work:</P>
<P>&nbsp;kp.symbol_name = "symbol_name";</P>
<P>(64-bit powerpc intricacies such as function descriptors are handled<BR>transparently)</P>
<P>2. Use the "offset" field of struct kprobe if the offset into the symbol<BR>to install a probepoint is known. This field is used to calculate the<BR>probepoint.</P>
<P>3. Specify either the kprobe "symbol_name" OR the "addr". If both are<BR>specified, kprobe registration will fail with -EINVAL.</P>
<P>4. With CISC architectures (such as i386 and x86_64), the kprobes code<BR>does not validate if the kprobe.addr is at an instruction boundary.<BR>Use "offset" with caution.</P>
<P>register_kprobe() returns 0 on success, or a negative errno otherwise.</P>
<P>User's pre-handler (kp-&gt;pre_handler):<BR>#include &lt;linux/kprobes.h&gt;<BR>#include &lt;linux/ptrace.h&gt;<BR>int pre_handler(struct kprobe *p, struct pt_regs *regs);</P>
<P>Called with p pointing to the kprobe associated with the breakpoint,<BR>and regs pointing to the struct containing the registers saved when<BR>the breakpoint was hit.&nbsp; Return 0 here unless you're a Kprobes geek.</P>
<P>User's post-handler (kp-&gt;post_handler):<BR>#include &lt;linux/kprobes.h&gt;<BR>#include &lt;linux/ptrace.h&gt;<BR>void post_handler(struct kprobe *p, struct pt_regs *regs,<BR>&nbsp;unsigned long flags);</P>
<P>p and regs are as described for the pre_handler.&nbsp; flags always seems<BR>to be zero.</P>
<P>User's fault-handler (kp-&gt;fault_handler):<BR>#include &lt;linux/kprobes.h&gt;<BR>#include &lt;linux/ptrace.h&gt;<BR>int fault_handler(struct kprobe *p, struct pt_regs *regs, int trapnr);</P>
<P>p and regs are as described for the pre_handler.&nbsp; trapnr is the<BR>architecture-specific trap number associated with the fault (e.g.,<BR>on i386, 13 for a general protection fault or 14 for a page fault).<BR>Returns 1 if it successfully handled the exception.</P>
<P>4.2 register_jprobe</P>
<P>#include &lt;linux/kprobes.h&gt;<BR>int register_jprobe(struct jprobe *jp)</P>
<P>Sets a breakpoint at the address jp-&gt;kp.addr, which must be the address<BR>of the first instruction of a function.&nbsp; When the breakpoint is hit,<BR>Kprobes runs the handler whose address is jp-&gt;entry.</P>
<P>The handler should have the same arg list and return type as the probed<BR>function; and just before it returns, it must call jprobe_return().<BR>(The handler never actually returns, since jprobe_return() returns<BR>control to Kprobes.)&nbsp; If the probed function is declared asmlinkage<BR>or anything else that affects how args are passed, the handler's<BR>declaration must match.</P>
<P>register_jprobe() returns 0 on success, or a negative errno otherwise.</P>
<P>4.3 register_kretprobe</P>
<P>#include &lt;linux/kprobes.h&gt;<BR>int register_kretprobe(struct kretprobe *rp);</P>
<P>Establishes a return probe for the function whose address is<BR>rp-&gt;kp.addr.&nbsp; When that function returns, Kprobes calls rp-&gt;handler.<BR>You must set rp-&gt;maxactive appropriately before you call<BR>register_kretprobe(); see "How Does a Return Probe Work?" for details.</P>
<P>register_kretprobe() returns 0 on success, or a negative errno<BR>otherwise.</P>
<P>User's return-probe handler (rp-&gt;handler):<BR>#include &lt;linux/kprobes.h&gt;<BR>#include &lt;linux/ptrace.h&gt;<BR>int kretprobe_handler(struct kretprobe_instance *ri, struct pt_regs *regs);</P>
<P>regs is as described for kprobe.pre_handler.&nbsp; ri points to the<BR>kretprobe_instance object, of which the following fields may be<BR>of interest:<BR>- ret_addr: the return address<BR>- rp: points to the corresponding kretprobe object<BR>- task: points to the corresponding task struct<BR>- data: points to per return-instance private data; see "Kretprobe<BR>&nbsp;entry-handler" for details.</P>
<P>The regs_return_value(regs) macro provides a simple abstraction to<BR>extract the return value from the appropriate register as defined by<BR>the architecture's ABI.</P>
<P>The handler's return value is currently ignored.</P>
<P>4.4 unregister_*probe</P>
<P>#include &lt;linux/kprobes.h&gt;<BR>void unregister_kprobe(struct kprobe *kp);<BR>void unregister_jprobe(struct jprobe *jp);<BR>void unregister_kretprobe(struct kretprobe *rp);</P>
<P>Removes the specified probe.&nbsp; The unregister function can be called<BR>at any time after the probe has been registered.</P>
<P>NOTE:<BR>If the functions find an incorrect probe (ex. an unregistered probe),<BR>they clear the addr field of the probe.</P>
<P>4.5 register_*probes</P>
<P>#include &lt;linux/kprobes.h&gt;<BR>int register_kprobes(struct kprobe **kps, int num);<BR>int register_kretprobes(struct kretprobe **rps, int num);<BR>int register_jprobes(struct jprobe **jps, int num);</P>
<P>Registers each of the num probes in the specified array.&nbsp; If any<BR>error occurs during registration, all probes in the array, up to<BR>the bad probe, are safely unregistered before the register_*probes<BR>function returns.<BR>- kps/rps/jps: an array of pointers to *probe data structures<BR>- num: the number of the array entries.</P>
<P>NOTE:<BR>You have to allocate(or define) an array of pointers and set all<BR>of the array entries before using these functions.</P>
<P>4.6 unregister_*probes</P>
<P>#include &lt;linux/kprobes.h&gt;<BR>void unregister_kprobes(struct kprobe **kps, int num);<BR>void unregister_kretprobes(struct kretprobe **rps, int num);<BR>void unregister_jprobes(struct jprobe **jps, int num);</P>
<P>Removes each of the num probes in the specified array at once.</P>
<P>NOTE:<BR>If the functions find some incorrect probes (ex. unregistered<BR>probes) in the specified array, they clear the addr field of those<BR>incorrect probes. However, other probes in the array are<BR>unregistered correctly.</P>
<P>4.7 disable_*probe</P>
<P>#include &lt;linux/kprobes.h&gt;<BR>int disable_kprobe(struct kprobe *kp);<BR>int disable_kretprobe(struct kretprobe *rp);<BR>int disable_jprobe(struct jprobe *jp);</P>
<P>Temporarily disables the specified *probe. You can enable it again by using<BR>enable_*probe(). You must specify the probe which has been registered.</P>
<P>4.8 enable_*probe</P>
<P>#include &lt;linux/kprobes.h&gt;<BR>int enable_kprobe(struct kprobe *kp);<BR>int enable_kretprobe(struct kretprobe *rp);<BR>int enable_jprobe(struct jprobe *jp);</P>
<P>Enables *probe which has been disabled by disable_*probe(). You must specify<BR>the probe which has been registered.</P>
<P>5. Kprobes Features and Limitations</P>
<P>Kprobes allows multiple probes at the same address.&nbsp; Currently,<BR>however, there cannot be multiple jprobes on the same function at<BR>the same time.&nbsp; Also, a probepoint for which there is a jprobe or<BR>a post_handler cannot be optimized.&nbsp; So if you install a jprobe,<BR>or a kprobe with a post_handler, at an optimized probepoint, the<BR>probepoint will be unoptimized automatically.</P>
<P>In general, you can install a probe anywhere in the kernel.<BR>In particular, you can probe interrupt handlers.&nbsp; Known exceptions<BR>are discussed in this section.</P>
<P>The register_*probe functions will return -EINVAL if you attempt<BR>to install a probe in the code that implements Kprobes (mostly<BR>kernel/kprobes.c and arch/*/kernel/kprobes.c, but also functions such<BR>as do_page_fault and notifier_call_chain).</P>
<P>If you install a probe in an inline-able function, Kprobes makes<BR>no attempt to chase down all inline instances of the function and<BR>install probes there.&nbsp; gcc may inline a function without being asked,<BR>so keep this in mind if you're not seeing the probe hits you expect.</P>
<P>A probe handler can modify the environment of the probed function<BR>-- e.g., by modifying kernel data structures, or by modifying the<BR>contents of the pt_regs struct (which are restored to the registers<BR>upon return from the breakpoint).&nbsp; So Kprobes can be used, for example,<BR>to install a bug fix or to inject faults for testing.&nbsp; Kprobes, of<BR>course, has no way to distinguish the deliberately injected faults<BR>from the accidental ones.&nbsp; Don't drink and probe.</P>
<P>Kprobes makes no attempt to prevent probe handlers from stepping on<BR>each other -- e.g., probing printk() and then calling printk() from a<BR>probe handler.&nbsp; If a probe handler hits a probe, that second probe's<BR>handlers won't be run in that instance, and the kprobe.nmissed member<BR>of the second probe will be incremented.</P>
<P>As of Linux v2.6.15-rc1, multiple handlers (or multiple instances of<BR>the same handler) may run concurrently on different CPUs.</P>
<P>Kprobes does not use mutexes or allocate memory except during<BR>registration and unregistration.</P>
<P>Probe handlers are run with preemption disabled.&nbsp; Depending on the<BR>architecture and optimization state, handlers may also run with<BR>interrupts disabled (e.g., kretprobe handlers and optimized kprobe<BR>handlers run without interrupt disabled on x86/x86-64).&nbsp; In any case,<BR>your handler should not yield the CPU (e.g., by attempting to acquire<BR>a semaphore).</P>
<P>Since a return probe is implemented by replacing the return<BR>address with the trampoline's address, stack backtraces and calls<BR>to __builtin_return_address() will typically yield the trampoline's<BR>address instead of the real return address for kretprobed functions.<BR>(As far as we can tell, __builtin_return_address() is used only<BR>for instrumentation and error reporting.)</P>
<P>If the number of times a function is called does not match the number<BR>of times it returns, registering a return probe on that function may<BR>produce undesirable results. In such a case, a line:<BR>kretprobe BUG!: Processing kretprobe d000000000041aa8 @ c00000000004f48c<BR>gets printed. With this information, one will be able to correlate the<BR>exact instance of the kretprobe that caused the problem. We have the<BR>do_exit() case covered. do_execve() and do_fork() are not an issue.<BR>We're unaware of other specific cases where this could be a problem.</P>
<P>If, upon entry to or exit from a function, the CPU is running on<BR>a stack other than that of the current task, registering a return<BR>probe on that function may produce undesirable results.&nbsp; For this<BR>reason, Kprobes doesn't support return probes (or kprobes or jprobes)<BR>on the x86_64 version of __switch_to(); the registration functions<BR>return -EINVAL.</P>
<P>On x86/x86-64, since the Jump Optimization of Kprobes modifies<BR>instructions widely, there are some limitations to optimization. To<BR>explain it, we introduce some terminology. Imagine a 3-instruction<BR>sequence consisting of a two 2-byte instructions and one 3-byte<BR>instruction.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IA<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>[-2][-1][0][1][2][3][4][5][6][7]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ins1][ins2][&nbsp; ins3 ]<BR>&nbsp;[&lt;-&nbsp;&nbsp;&nbsp;&nbsp; DCR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt;]<BR>&nbsp;&nbsp;&nbsp; [&lt;- JTPR -&gt;]</P>
<P>ins1: 1st Instruction<BR>ins2: 2nd Instruction<BR>ins3: 3rd Instruction<BR>IA:&nbsp; Insertion Address<BR>JTPR: Jump Target Prohibition Region<BR>DCR: Detoured Code Region</P>
<P>The instructions in DCR are copied to the out-of-line buffer<BR>of the kprobe, because the bytes in DCR are replaced by<BR>a 5-byte jump instruction. So there are several limitations.</P>
<P>a) The instructions in DCR must be relocatable.<BR>b) The instructions in DCR must not include a call instruction.<BR>c) JTPR must not be targeted by any jump or call instruction.<BR>d) DCR must not straddle the border between functions.</P>
<P>Anyway, these limitations are checked by the in-kernel instruction<BR>decoder, so you don't need to worry about that.</P>
<P>6. Probe Overhead</P>
<P>On a typical CPU in use in 2005, a kprobe hit takes 0.5 to 1.0<BR>microseconds to process.&nbsp; Specifically, a benchmark that hits the same<BR>probepoint repeatedly, firing a simple handler each time, reports 1-2<BR>million hits per second, depending on the architecture.&nbsp; A jprobe or<BR>return-probe hit typically takes 50-75% longer than a kprobe hit.<BR>When you have a return probe set on a function, adding a kprobe at<BR>the entry to that function adds essentially no overhead.</P>
<P>Here are sample overhead figures (in usec) for different architectures.<BR>k = kprobe; j = jprobe; r = return probe; kr = kprobe + return probe<BR>on same function; jr = jprobe + return probe on same function</P>
<P>i386: Intel Pentium M, 1495 MHz, 2957.31 bogomips<BR>k = 0.57 usec; j = 1.00; r = 0.92; kr = 0.99; jr = 1.40</P>
<P>x86_64: AMD Opteron 246, 1994 MHz, 3971.48 bogomips<BR>k = 0.49 usec; j = 0.76; r = 0.80; kr = 0.82; jr = 1.07</P>
<P>ppc64: POWER5 (gr), 1656 MHz (SMT disabled, 1 virtual CPU per physical CPU)<BR>k = 0.77 usec; j = 1.31; r = 1.26; kr = 1.45; jr = 1.99</P>
<P>6.1 Optimized Probe Overhead</P>
<P>Typically, an optimized kprobe hit takes 0.07 to 0.1 microseconds to<BR>process. Here are sample overhead figures (in usec) for x86 architectures.<BR>k = unoptimized kprobe, b = boosted (single-step skipped), o = optimized kprobe,<BR>r = unoptimized kretprobe, rb = boosted kretprobe, ro = optimized kretprobe.</P>
<P>i386: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips<BR>k = 0.80 usec; b = 0.33; o = 0.05; r = 1.10; rb = 0.61; ro = 0.33</P>
<P>x86-64: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips<BR>k = 0.99 usec; b = 0.43; o = 0.06; r = 1.24; rb = 0.68; ro = 0.30</P>
<P>7. TODO</P>
<P>a. SystemTap (<A href="http://sourceware.org/systemtap">http://sourceware.org/systemtap</A>): Provides a simplified<BR>programming interface for probe-based instrumentation.&nbsp; Try it out.<BR>b. Kernel return probes for sparc64.<BR>c. Support for other architectures.<BR>d. User-space probes.<BR>e. Watchpoint probes (which fire on data references).</P>
<P>8. Kprobes Example</P>
<P>See samples/kprobes/kprobe_example.c</P>
<P>9. Jprobes Example</P>
<P>See samples/kprobes/jprobe_example.c</P>
<P>10. Kretprobes Example</P>
<P>See samples/kprobes/kretprobe_example.c</P>
<P>For additional information on Kprobes, refer to the following URLs:<BR><A href="http://www-106.ibm.com/developerworks/library/l-kprobes.html?ca=dgr-lnxw42Kprobe">http://www-106.ibm.com/developerworks/library/l-kprobes.html?ca=dgr-lnxw42Kprobe</A><BR><A href="http://www.redhat.com/magazine/005mar05/features/kprobes/">http://www.redhat.com/magazine/005mar05/features/kprobes/</A><BR><A href="http://www-users.cs.umn.edu/~boutcher/kprobes/">http://www-users.cs.umn.edu/~boutcher/kprobes/</A><BR><A href="http://www.linuxsymposium.org/2006/linuxsymposium_procv2.pdf">http://www.linuxsymposium.org/2006/linuxsymposium_procv2.pdf</A> (pages 101-115)</P>
<P><BR>Appendix A: The kprobes debugfs interface</P>
<P>With recent kernels (&gt; 2.6.20) the list of registered kprobes is visible<BR>under the /sys/kernel/debug/kprobes/ directory (assuming debugfs is mounted at //sys/kernel/debug).</P>
<P>/sys/kernel/debug/kprobes/list: Lists all registered probes on the system</P>
<P>c015d71a&nbsp; k&nbsp; vfs_read+0x0<BR>c011a316&nbsp; j&nbsp; do_fork+0x0<BR>c03dedc5&nbsp; r&nbsp; tcp_v4_rcv+0x0</P>
<P>The first column provides the kernel address where the probe is inserted.<BR>The second column identifies the type of probe (k - kprobe, r - kretprobe<BR>and j - jprobe), while the third column specifies the symbol+offset of<BR>the probe. If the probed function belongs to a module, the module name<BR>is also specified. Following columns show probe status. If the probe is on<BR>a virtual address that is no longer valid (module init sections, module<BR>virtual addresses that correspond to modules that've been unloaded),<BR>such probes are marked with [GONE]. If the probe is temporarily disabled,<BR>such probes are marked with [DISABLED]. If the probe is optimized, it is<BR>marked with [OPTIMIZED].</P>
<P>/sys/kernel/debug/kprobes/enabled: Turn kprobes ON/OFF forcibly.</P>
<P>Provides a knob to globally and forcibly turn registered kprobes ON or OFF.<BR>By default, all kprobes are enabled. By echoing "0" to this file, all<BR>registered probes will be disarmed, till such time a "1" is echoed to this<BR>file. Note that this knob just disarms and arms all kprobes and doesn't<BR>change each probe's disabling state. This means that disabled kprobes (marked<BR>[DISABLED]) will be not enabled if you turn ON all kprobes by this knob.</P>
<P><BR>Appendix B: The kprobes sysctl interface</P>
<P>/proc/sys/debug/kprobes-optimization: Turn kprobes optimization ON/OFF.</P>
<P>When CONFIG_OPTPROBES=y, this sysctl interface appears and it provides<BR>a knob to globally and forcibly turn jump optimization (see section<BR>1.4) ON or OFF. By default, jump optimization is allowed (ON).<BR>If you echo "0" to this file or set "debug.kprobes_optimization" to<BR>0 via sysctl, all optimized probes will be unoptimized, and any new<BR>probes registered after that will not be optimized.&nbsp; Note that this<BR>knob *changes* the optimized state. This means that optimized probes<BR>(marked [OPTIMIZED]) will be unoptimized ([OPTIMIZED] tag will be<BR>removed). If the knob is turned on, they will be optimized again.</P>
<P>&nbsp;