# Documentation/init.txt 
<P></P>
<P>Explaining the dreaded "No init found." boot hang message<BR>=========================================================</P>
<P></P>
<P>OK, so you've got this pretty unintuitive message (currently located<BR>in init/main.c) and are wondering what the H*** went wrong.<BR>Some high-level reasons for failure (listed roughly in order of execution)<BR>to load the init binary are:<BR>A) Unable to mount root FS<BR>B) init binary doesn't exist on rootfs<BR>C) broken console device<BR>D) binary exists but dependencies not available<BR>E) binary cannot be loaded</P>
<P>Detailed explanations:<BR>0) Set "debug" kernel parameter (in bootloader config file or CONFIG_CMDLINE)<BR>&nbsp;&nbsp; to get more detailed kernel messages.<BR>A) make sure you have the correct root FS type<BR>&nbsp;&nbsp; (and root= kernel parameter points to the correct partition),<BR>&nbsp;&nbsp; required drivers such as storage hardware (such as SCSI or USB!)<BR>&nbsp;&nbsp; and filesystem (ext3, jffs2 etc.) are builtin (alternatively as modules,<BR>&nbsp;&nbsp; to be pre-loaded by an initrd)<BR>C) Possibly a conflict in console= setup --&gt; initial console unavailable.<BR>&nbsp;&nbsp; E.g. some serial consoles are unreliable due to serial IRQ issues (e.g.<BR>&nbsp;&nbsp; missing interrupt-based configuration).<BR>&nbsp;&nbsp; Try using a different console= device or e.g. netconsole= .<BR>D) e.g. required library dependencies of the init binary such as<BR>&nbsp;&nbsp; /lib/ld-linux.so.2 missing or broken. Use readelf -d &lt;INIT&gt;|grep NEEDED<BR>&nbsp;&nbsp; to find out which libraries are required.<BR>E) make sure the binary's architecture matches your hardware.<BR>&nbsp;&nbsp; E.g. i386 vs. x86_64 mismatch, or trying to load x86 on ARM hardware.<BR>&nbsp;&nbsp; In case you tried loading a non-binary file here (shell script?),<BR>&nbsp;&nbsp; you should make sure that the script specifies an interpreter in its shebang<BR>&nbsp;&nbsp; header line (#!/...) that is fully working (including its library<BR>&nbsp;&nbsp; dependencies). And before tackling scripts, better first test a simple<BR>&nbsp;&nbsp; non-script binary such as /bin/sh and confirm its successful execution.<BR>&nbsp;&nbsp; To find out more, add code to init/main.c to display kernel_execve()s<BR>&nbsp;&nbsp; return values.</P>
<P>Please extend this explanation whenever you find new failure causes<BR>(after all loading the init binary is a CRITICAL and hard transition step<BR>which needs to be made as painless as possible), then submit patch to LKML.<BR>Further TODOs:<BR>- Implement the various run_init_process() invocations via a struct array<BR>&nbsp; which can then store the kernel_execve() result value and on failure<BR>&nbsp; log it all by iterating over _all_ results (very important usability fix).<BR>- try to make the implementation itself more helpful in general,<BR>&nbsp; e.g. by providing additional error messages at affected places.</P>
<P>Andreas Mohr &lt;andi at lisas period de&gt;