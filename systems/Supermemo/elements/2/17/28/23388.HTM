# Documentation/kdump/gdbmacros.txt 
<P></P>
<P>#<BR># This file contains a few gdb macros (user defined commands) to extract<BR># useful information from kernel crashdump (kdump) like stack traces of<BR># all the processes or a particular process and trapinfo.<BR>#<BR># These macros can be used by copying this file in .gdbinit (put in home<BR># directory or current directory) or by invoking gdb command with<BR># --command=&lt;command-file-name&gt; option<BR>#<BR># Credits:<BR># Alexander Nyberg &lt;<A href="mailto:alexn@telia.com">alexn@telia.com</A>&gt;<BR># V Srivatsa &lt;<A href="mailto:vatsa@in.ibm.com">vatsa@in.ibm.com</A>&gt;<BR># Maneesh Soni &lt;<A href="mailto:maneesh@in.ibm.com">maneesh@in.ibm.com</A>&gt;<BR>#</P>
<P></P>
<P>define bttnobp<BR>&nbsp;set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)<BR>&nbsp;set $pid_off=((size_t)&amp;((struct task_struct *)0)-&gt;pids[1].pid_list.next)<BR>&nbsp;set $init_t=&amp;init_task<BR>&nbsp;set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)<BR>&nbsp;while ($next_t != $init_t)<BR>&nbsp;&nbsp;set $next_t=(struct task_struct *)$next_t<BR>&nbsp;&nbsp;printf "\npid %d; comm %s:\n", $next_t.pid, $next_t.comm<BR>&nbsp;&nbsp;printf "===================\n"<BR>&nbsp;&nbsp;set var $stackp = $next_t.thread.esp<BR>&nbsp;&nbsp;set var $stack_top = ($stackp &amp; ~4095) + 4096</P>
<P>&nbsp;&nbsp;while ($stackp &lt; $stack_top)<BR>&nbsp;&nbsp;&nbsp;if (*($stackp) &gt; _stext &amp;&amp; *($stackp) &lt; _sinittext)<BR>&nbsp;&nbsp;&nbsp;&nbsp;info symbol *($stackp)<BR>&nbsp;&nbsp;&nbsp;end<BR>&nbsp;&nbsp;&nbsp;set $stackp += 4<BR>&nbsp;&nbsp;end<BR>&nbsp;&nbsp;set $next_th=(((char *)$next_t-&gt;pids[1].pid_list.next) - $pid_off)<BR>&nbsp;&nbsp;while ($next_th != $next_t)<BR>&nbsp;&nbsp;&nbsp;set $next_th=(struct task_struct *)$next_th<BR>&nbsp;&nbsp;&nbsp;printf "\npid %d; comm %s:\n", $next_t.pid, $next_t.comm<BR>&nbsp;&nbsp;&nbsp;printf "===================\n"<BR>&nbsp;&nbsp;&nbsp;set var $stackp = $next_t.thread.esp<BR>&nbsp;&nbsp;&nbsp;set var $stack_top = ($stackp &amp; ~4095) + 4096</P>
<P>&nbsp;&nbsp;&nbsp;while ($stackp &lt; $stack_top)<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (*($stackp) &gt; _stext &amp;&amp; *($stackp) &lt; _sinittext)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info symbol *($stackp)<BR>&nbsp;&nbsp;&nbsp;&nbsp;end<BR>&nbsp;&nbsp;&nbsp;&nbsp;set $stackp += 4<BR>&nbsp;&nbsp;&nbsp;end<BR>&nbsp;&nbsp;&nbsp;set $next_th=(((char *)$next_th-&gt;pids[1].pid_list.next) - $pid_off)<BR>&nbsp;&nbsp;end<BR>&nbsp;&nbsp;set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off<BR>&nbsp;end<BR>end<BR>document bttnobp<BR>&nbsp;dump all thread stack traces on a kernel compiled with !CONFIG_FRAME_POINTER<BR>end</P>
<P>define btt<BR>&nbsp;set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)<BR>&nbsp;set $pid_off=((size_t)&amp;((struct task_struct *)0)-&gt;pids[1].pid_list.next)<BR>&nbsp;set $init_t=&amp;init_task<BR>&nbsp;set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)<BR>&nbsp;while ($next_t != $init_t)<BR>&nbsp;&nbsp;set $next_t=(struct task_struct *)$next_t<BR>&nbsp;&nbsp;printf "\npid %d; comm %s:\n", $next_t.pid, $next_t.comm<BR>&nbsp;&nbsp;printf "===================\n"<BR>&nbsp;&nbsp;set var $stackp = $next_t.thread.esp<BR>&nbsp;&nbsp;set var $stack_top = ($stackp &amp; ~4095) + 4096<BR>&nbsp;&nbsp;set var $stack_bot = ($stackp &amp; ~4095)</P>
<P>&nbsp;&nbsp;set $stackp = *($stackp)<BR>&nbsp;&nbsp;while (($stackp &lt; $stack_top) &amp;&amp; ($stackp &gt; $stack_bot))<BR>&nbsp;&nbsp;&nbsp;set var $addr = *($stackp + 4)<BR>&nbsp;&nbsp;&nbsp;info symbol $addr<BR>&nbsp;&nbsp;&nbsp;set $stackp = *($stackp)<BR>&nbsp;&nbsp;end</P>
<P>&nbsp;&nbsp;set $next_th=(((char *)$next_t-&gt;pids[1].pid_list.next) - $pid_off)<BR>&nbsp;&nbsp;while ($next_th != $next_t)<BR>&nbsp;&nbsp;&nbsp;set $next_th=(struct task_struct *)$next_th<BR>&nbsp;&nbsp;&nbsp;printf "\npid %d; comm %s:\n", $next_t.pid, $next_t.comm<BR>&nbsp;&nbsp;&nbsp;printf "===================\n"<BR>&nbsp;&nbsp;&nbsp;set var $stackp = $next_t.thread.esp<BR>&nbsp;&nbsp;&nbsp;set var $stack_top = ($stackp &amp; ~4095) + 4096<BR>&nbsp;&nbsp;&nbsp;set var $stack_bot = ($stackp &amp; ~4095)</P>
<P>&nbsp;&nbsp;&nbsp;set $stackp = *($stackp)<BR>&nbsp;&nbsp;&nbsp;while (($stackp &lt; $stack_top) &amp;&amp; ($stackp &gt; $stack_bot))<BR>&nbsp;&nbsp;&nbsp;&nbsp;set var $addr = *($stackp + 4)<BR>&nbsp;&nbsp;&nbsp;&nbsp;info symbol $addr<BR>&nbsp;&nbsp;&nbsp;&nbsp;set $stackp = *($stackp)<BR>&nbsp;&nbsp;&nbsp;end<BR>&nbsp;&nbsp;&nbsp;set $next_th=(((char *)$next_th-&gt;pids[1].pid_list.next) - $pid_off)<BR>&nbsp;&nbsp;end<BR>&nbsp;&nbsp;set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off<BR>&nbsp;end<BR>end<BR>document btt<BR>&nbsp;dump all thread stack traces on a kernel compiled with CONFIG_FRAME_POINTER<BR>end</P>
<P>define btpid<BR>&nbsp;set var $pid = $arg0<BR>&nbsp;set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)<BR>&nbsp;set $pid_off=((size_t)&amp;((struct task_struct *)0)-&gt;pids[1].pid_list.next)<BR>&nbsp;set $init_t=&amp;init_task<BR>&nbsp;set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)<BR>&nbsp;set var $pid_task = 0</P>
<P>&nbsp;while ($next_t != $init_t)<BR>&nbsp;&nbsp;set $next_t=(struct task_struct *)$next_t</P>
<P>&nbsp;&nbsp;if ($next_t.pid == $pid)<BR>&nbsp;&nbsp;&nbsp;set $pid_task = $next_t<BR>&nbsp;&nbsp;end</P>
<P>&nbsp;&nbsp;set $next_th=(((char *)$next_t-&gt;pids[1].pid_list.next) - $pid_off)<BR>&nbsp;&nbsp;while ($next_th != $next_t)<BR>&nbsp;&nbsp;&nbsp;set $next_th=(struct task_struct *)$next_th<BR>&nbsp;&nbsp;&nbsp;if ($next_th.pid == $pid)<BR>&nbsp;&nbsp;&nbsp;&nbsp;set $pid_task = $next_th<BR>&nbsp;&nbsp;&nbsp;end<BR>&nbsp;&nbsp;&nbsp;set $next_th=(((char *)$next_th-&gt;pids[1].pid_list.next) - $pid_off)<BR>&nbsp;&nbsp;end<BR>&nbsp;&nbsp;set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off<BR>&nbsp;end</P>
<P>&nbsp;printf "\npid %d; comm %s:\n", $pid_task.pid, $pid_task.comm<BR>&nbsp;printf "===================\n"<BR>&nbsp;set var $stackp = $pid_task.thread.esp<BR>&nbsp;set var $stack_top = ($stackp &amp; ~4095) + 4096<BR>&nbsp;set var $stack_bot = ($stackp &amp; ~4095)</P>
<P>&nbsp;set $stackp = *($stackp)<BR>&nbsp;while (($stackp &lt; $stack_top) &amp;&amp; ($stackp &gt; $stack_bot))<BR>&nbsp;&nbsp;set var $addr = *($stackp + 4)<BR>&nbsp;&nbsp;info symbol $addr<BR>&nbsp;&nbsp;set $stackp = *($stackp)<BR>&nbsp;end<BR>end<BR>document btpid<BR>&nbsp;backtrace of pid<BR>end</P>
<P><BR>define trapinfo<BR>&nbsp;set var $pid = $arg0<BR>&nbsp;set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)<BR>&nbsp;set $pid_off=((size_t)&amp;((struct task_struct *)0)-&gt;pids[1].pid_list.next)<BR>&nbsp;set $init_t=&amp;init_task<BR>&nbsp;set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)<BR>&nbsp;set var $pid_task = 0</P>
<P>&nbsp;while ($next_t != $init_t)<BR>&nbsp;&nbsp;set $next_t=(struct task_struct *)$next_t</P>
<P>&nbsp;&nbsp;if ($next_t.pid == $pid)<BR>&nbsp;&nbsp;&nbsp;set $pid_task = $next_t<BR>&nbsp;&nbsp;end</P>
<P>&nbsp;&nbsp;set $next_th=(((char *)$next_t-&gt;pids[1].pid_list.next) - $pid_off)<BR>&nbsp;&nbsp;while ($next_th != $next_t)<BR>&nbsp;&nbsp;&nbsp;set $next_th=(struct task_struct *)$next_th<BR>&nbsp;&nbsp;&nbsp;if ($next_th.pid == $pid)<BR>&nbsp;&nbsp;&nbsp;&nbsp;set $pid_task = $next_th<BR>&nbsp;&nbsp;&nbsp;end<BR>&nbsp;&nbsp;&nbsp;set $next_th=(((char *)$next_th-&gt;pids[1].pid_list.next) - $pid_off)<BR>&nbsp;&nbsp;end<BR>&nbsp;&nbsp;set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off<BR>&nbsp;end</P>
<P>&nbsp;printf "Trapno %ld, cr2 0x%lx, error_code %ld\n", $pid_task.thread.trap_no, \<BR>&nbsp;&nbsp;&nbsp;&nbsp;$pid_task.thread.cr2, $pid_task.thread.error_code</P>
<P>end<BR>document trapinfo<BR>&nbsp;Run info threads and lookup pid of thread #1<BR>&nbsp;'trapinfo &lt;pid&gt;' will tell you by which trap &amp; possibly<BR>&nbsp;address the kernel panicked.<BR>end</P>
<P><BR>define dmesg<BR>&nbsp;set $i = 0<BR>&nbsp;set $end_idx = (log_end - 1) &amp; (log_buf_len - 1)</P>
<P>&nbsp;while ($i &lt; logged_chars)<BR>&nbsp;&nbsp;set $idx = (log_end - 1 - logged_chars + $i) &amp; (log_buf_len - 1)</P>
<P>&nbsp;&nbsp;if ($idx + 100 &lt;= $end_idx) || \<BR>&nbsp;&nbsp;&nbsp;&nbsp; ($end_idx &lt;= $idx &amp;&amp; $idx + 100 &lt; log_buf_len)<BR>&nbsp;&nbsp;&nbsp;printf "%.100s", &amp;log_buf[$idx]<BR>&nbsp;&nbsp;&nbsp;set $i = $i + 100<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;printf "%c", log_buf[$idx]<BR>&nbsp;&nbsp;&nbsp;set $i = $i + 1<BR>&nbsp;&nbsp;end<BR>&nbsp;end<BR>end<BR>document dmesg<BR>&nbsp;print the kernel ring buffer<BR>end