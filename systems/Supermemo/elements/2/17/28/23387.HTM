# Documentation/crypto/descore-readme.txt
<P></P>
<P>Below is the original README file from the descore.shar package.<BR>------------------------------------------------------------------------------</P>
<P></P>
<P>des - fast &amp; portable DES encryption &amp; decryption.<BR>Copyright (C) 1992&nbsp; Dana L. How</P>
<P>This program is free software; you can redistribute it and/or modify<BR>it under the terms of the GNU Library General Public License as published by<BR>the Free Software Foundation; either version 2 of the License, or<BR>(at your option) any later version.</P>
<P>This program is distributed in the hope that it will be useful,<BR>but WITHOUT ANY WARRANTY; without even the implied warranty of<BR>MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp; See the<BR>GNU Library General Public License for more details.</P>
<P>You should have received a copy of the GNU Library General Public License<BR>along with this program; if not, write to the Free Software<BR>Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</P>
<P>Author's address: <A href="mailto:how@isl.stanford.edu">how@isl.stanford.edu</A></P>
<P>$Id: README,v 1.15 1992/05/20 00:25:32 how E $</P>
<P><BR>==&gt;&gt; To compile after untarring/unsharring, just `make' &lt;&lt;==</P>
<P><BR>This package was designed with the following goals:<BR>1.&nbsp;Highest possible encryption/decryption PERFORMANCE.<BR>2.&nbsp;PORTABILITY to any byte-addressable host with a 32bit unsigned C type<BR>3.&nbsp;Plug-compatible replacement for KERBEROS's low-level routines.</P>
<P>This second release includes a number of performance enhancements for<BR>register-starved machines.&nbsp; My discussions with Richard Outerbridge,<BR><A href="mailto:71755.204@compuserve.com">71755.204@compuserve.com</A>, sparked a number of these enhancements.</P>
<P>To more rapidly understand the code in this package, inspect desSmallFips.i<BR>(created by typing `make') BEFORE you tackle desCode.h.&nbsp; The latter is set<BR>up in a parameterized fashion so it can easily be modified by speed-daemon<BR>hackers in pursuit of that last microsecond.&nbsp; You will find it more<BR>illuminating to inspect one specific implementation,<BR>and then move on to the common abstract skeleton with this one in mind.</P>
<P><BR>performance comparison to other available des code which i could<BR>compile on a SPARCStation 1 (cc -O4, gcc -O2):</P>
<P>this code (byte-order independent):<BR>&nbsp;&nbsp; 30us per encryption (options: 64k tables, no IP/FP)<BR>&nbsp;&nbsp; 33us per encryption (options: 64k tables, FIPS standard bit ordering)<BR>&nbsp;&nbsp; 45us per encryption (options:&nbsp; 2k tables, no IP/FP)<BR>&nbsp;&nbsp; 48us per encryption (options:&nbsp; 2k tables, FIPS standard bit ordering)<BR>&nbsp; 275us to set a new key (uses 1k of key tables)<BR>&nbsp;this has the quickest encryption/decryption routines i've seen.<BR>&nbsp;since i was interested in fast des filters rather than crypt(3)<BR>&nbsp;and password cracking, i haven't really bothered yet to speed up<BR>&nbsp;the key setting routine. also, i have no interest in re-implementing<BR>&nbsp;all the other junk in the mit kerberos des library, so i've just<BR>&nbsp;provided my routines with little stub interfaces so they can be<BR>&nbsp;used as drop-in replacements with mit's code or any of the mit-<BR>&nbsp;compatible packages below. (note that the first two timings above<BR>&nbsp;are highly variable because of cache effects).</P>
<P>kerberos des replacement from australia (version 1.95):<BR>&nbsp;&nbsp; 53us per encryption (uses 2k of tables)<BR>&nbsp;&nbsp; 96us to set a new key (uses 2.25k of key tables)<BR>&nbsp;so despite the author's inclusion of some of the performance<BR>&nbsp;improvements i had suggested to him, this package's<BR>&nbsp;encryption/decryption is still slower on the sparc and 68000.<BR>&nbsp;more specifically, 19-40% slower on the 68020 and 11-35% slower<BR>&nbsp;on the sparc,&nbsp; depending on the compiler;<BR>&nbsp;in full gory detail (ALT_ECB is a libdes variant):<BR>&nbsp;compiler&nbsp;&nbsp; &nbsp;machine&nbsp;&nbsp;desCore&nbsp;libdes&nbsp;ALT_ECB&nbsp;slower by<BR>&nbsp;gcc 2.1 -O2&nbsp;Sun 3/110&nbsp;304&nbsp; uS&nbsp;369.5uS&nbsp;461.8uS&nbsp; 22%<BR>&nbsp;cc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -O1&nbsp;Sun 3/110&nbsp;336&nbsp; uS&nbsp;436.6uS&nbsp;399.3uS&nbsp; 19%<BR>&nbsp;cc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -O2&nbsp;Sun 3/110&nbsp;360&nbsp; uS&nbsp;532.4uS&nbsp;505.1uS&nbsp; 40%<BR>&nbsp;cc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -O4&nbsp;Sun 3/110&nbsp;365&nbsp; uS&nbsp;532.3uS&nbsp;505.3uS&nbsp; 38%<BR>&nbsp;gcc 2.1 -O2&nbsp;Sun 4/50&nbsp; 48&nbsp; uS&nbsp; 53.4uS&nbsp; 57.5uS&nbsp; 11%<BR>&nbsp;cc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -O2&nbsp;Sun 4/50&nbsp; 48&nbsp; uS&nbsp; 64.6uS&nbsp; 64.7uS&nbsp; 35%<BR>&nbsp;cc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -O4&nbsp;Sun 4/50&nbsp; 48&nbsp; uS&nbsp; 64.7uS&nbsp; 64.9uS&nbsp; 35%<BR>&nbsp;(my time measurements are not as accurate as his).<BR>&nbsp;&nbsp; the comments in my first release of desCore on version 1.92:<BR>&nbsp;&nbsp; 68us per encryption (uses 2k of tables)<BR>&nbsp;&nbsp; 96us to set a new key (uses 2.25k of key tables)<BR>&nbsp;this is a very nice package which implements the most important<BR>&nbsp;of the optimizations which i did in my encryption routines.<BR>&nbsp;it's a bit weak on common low-level optimizations which is why<BR>&nbsp;it's 39%-106% slower.&nbsp; because he was interested in fast crypt(3) and<BR>&nbsp;password-cracking applications,&nbsp; he also used the same ideas to<BR>&nbsp;speed up the key-setting routines with impressive results.<BR>&nbsp;(at some point i may do the same in my package).&nbsp; he also implements<BR>&nbsp;the rest of the mit des library.<BR>&nbsp;(code from <A href="mailto:eay@psych.psy.uq.oz.au">eay@psych.psy.uq.oz.au</A> via comp.sources.misc)</P>
<P>fast crypt(3) package from denmark:<BR>&nbsp;the des routine here is buried inside a loop to do the<BR>&nbsp;crypt function and i didn't feel like ripping it out and measuring<BR>&nbsp;performance. his code takes 26 sparc instructions to compute one<BR>&nbsp;des iteration; above, Quick (64k) takes 21 and Small (2k) takes 37.<BR>&nbsp;he claims to use 280k of tables but the iteration calculation seems<BR>&nbsp;to use only 128k.&nbsp; his tables and code are machine independent.<BR>&nbsp;(code from <A href="mailto:glad@daimi.aau.dk">glad@daimi.aau.dk</A> via alt.sources or comp.sources.misc)</P>
<P>swedish reimplementation of Kerberos des library<BR>&nbsp; 108us per encryption (uses 34k worth of tables)<BR>&nbsp; 134us to set a new key (uses 32k of key tables to get this speed!)<BR>&nbsp;the tables used seem to be machine-independent;<BR>&nbsp;he seems to have included a lot of special case code<BR>&nbsp;so that, e.g., `long' loads can be used instead of 4 `char' loads<BR>&nbsp;when the machine's architecture allows it.<BR>&nbsp;(code obtained from chalmers.se:pub/des)</P>
<P>crack 3.3c package from england:<BR>&nbsp;as in crypt above, the des routine is buried in a loop. it's<BR>&nbsp;also very modified for crypt.&nbsp; his iteration code uses 16k<BR>&nbsp;of tables and appears to be slow.<BR>&nbsp;(code obtained from <A href="mailto:aem@aber.ac.uk">aem@aber.ac.uk</A> via alt.sources or comp.sources.misc)</P>
<P>``highly optimized'' and tweaked Kerberos/Athena code (byte-order dependent):<BR>&nbsp; 165us per encryption (uses 6k worth of tables)<BR>&nbsp; 478us to set a new key (uses &lt;1k of key tables)<BR>&nbsp;so despite the comments in this code, it was possible to get<BR>&nbsp;faster code AND smaller tables, as well as making the tables<BR>&nbsp;machine-independent.<BR>&nbsp;(code obtained from prep.ai.mit.edu)</P>
<P>UC Berkeley code (depends on machine-endedness):<BR>&nbsp; 226us per encryption<BR>10848us to set a new key<BR>&nbsp;table sizes are unclear, but they don't look very small<BR>&nbsp;(code obtained from wuarchive.wustl.edu)</P>
<P><BR>motivation and history</P>
<P>a while ago i wanted some des routines and the routines documented on sun's<BR>man pages either didn't exist or dumped core.&nbsp; i had heard of kerberos,<BR>and knew that it used des,&nbsp; so i figured i'd use its routines.&nbsp; but once<BR>i got it and looked at the code,&nbsp; it really set off a lot of pet peeves -<BR>it was too convoluted, the code had been written without taking<BR>advantage of the regular structure of operations such as IP, E, and FP<BR>(i.e. the author didn't sit down and think before coding),<BR>it was excessively slow,&nbsp; the author had attempted to clarify the code<BR>by adding MORE statements to make the data movement more `consistent'<BR>instead of simplifying his implementation and cutting down on all data<BR>movement (in particular, his use of L1, R1, L2, R2), and it was full of<BR>idiotic `tweaks' for particular machines which failed to deliver significant<BR>speedups but which did obfuscate everything.&nbsp; so i took the test data<BR>from his verification program and rewrote everything else.</P>
<P>a while later i ran across the great crypt(3) package mentioned above.<BR>the fact that this guy was computing 2 sboxes per table lookup rather<BR>than one (and using a MUCH larger table in the process) emboldened me to<BR>do the same - it was a trivial change from which i had been scared away<BR>by the larger table size.&nbsp; in his case he didn't realize you don't need to keep<BR>the working data in TWO forms, one for easy use of half the sboxes in<BR>indexing, the other for easy use of the other half; instead you can keep<BR>it in the form for the first half and use a simple rotate to get the other<BR>half.&nbsp; this means i have (almost) half the data manipulation and half<BR>the table size.&nbsp; in fairness though he might be encoding something particular<BR>to crypt(3) in his tables - i didn't check.</P>
<P>i'm glad that i implemented it the way i did, because this C version is<BR>portable (the ifdef's are performance enhancements) and it is faster<BR>than versions hand-written in assembly for the sparc!</P>
<P><BR>porting notes</P>
<P>one thing i did not want to do was write an enormous mess<BR>which depended on endedness and other machine quirks,<BR>and which necessarily produced different code and different lookup tables<BR>for different machines.&nbsp; see the kerberos code for an example<BR>of what i didn't want to do; all their endedness-specific `optimizations'<BR>obfuscate the code and in the end were slower than a simpler machine<BR>independent approach.&nbsp; however, there are always some portability<BR>considerations of some kind, and i have included some options<BR>for varying numbers of register variables.<BR>perhaps some will still regard the result as a mess!</P>
<P>1) i assume everything is byte addressable, although i don't actually<BR>&nbsp;&nbsp; depend on the byte order, and that bytes are 8 bits.<BR>&nbsp;&nbsp; i assume word pointers can be freely cast to and from char pointers.<BR>&nbsp;&nbsp; note that 99% of C programs make these assumptions.<BR>&nbsp;&nbsp; i always use unsigned char's if the high bit could be set.<BR>2) the typedef `word' means a 32 bit unsigned integral type.<BR>&nbsp;&nbsp; if `unsigned long' is not 32 bits, change the typedef in desCore.h.<BR>&nbsp;&nbsp; i assume sizeof(word) == 4 EVERYWHERE.</P>
<P>the (worst-case) cost of my NOT doing endedness-specific optimizations<BR>in the data loading and storing code surrounding the key iterations<BR>is less than 12%.&nbsp; also, there is the added benefit that<BR>the input and output work areas do not need to be word-aligned.</P>
<P><BR>OPTIONAL performance optimizations</P>
<P>1) you should define one of `i386,' `vax,' `mc68000,' or `sparc,'<BR>&nbsp;&nbsp; whichever one is closest to the capabilities of your machine.<BR>&nbsp;&nbsp; see the start of desCode.h to see exactly what this selection implies.<BR>&nbsp;&nbsp; note that if you select the wrong one, the des code will still work;<BR>&nbsp;&nbsp; these are just performance tweaks.<BR>2) for those with functional `asm' keywords: you should change the<BR>&nbsp;&nbsp; ROR and ROL macros to use machine rotate instructions if you have them.<BR>&nbsp;&nbsp; this will save 2 instructions and a temporary per use,<BR>&nbsp;&nbsp; or about 32 to 40 instructions per en/decryption.<BR>&nbsp;&nbsp; note that gcc is smart enough to translate the ROL/R macros into<BR>&nbsp;&nbsp; machine rotates!</P>
<P>these optimizations are all rather persnickety, yet with them you should<BR>be able to get performance equal to assembly-coding, except that:<BR>1) with the lack of a bit rotate operator in C, rotates have to be synthesized<BR>&nbsp;&nbsp; from shifts.&nbsp; so access to `asm' will speed things up if your machine<BR>&nbsp;&nbsp; has rotates, as explained above in (3) (not necessary if you use gcc).<BR>2) if your machine has less than 12 32-bit registers i doubt your compiler will<BR>&nbsp;&nbsp; generate good code.<BR>&nbsp;&nbsp; `i386' tries to configure the code for a 386 by only declaring 3 registers<BR>&nbsp;&nbsp; (it appears that gcc can use ebx, esi and edi to hold register variables).<BR>&nbsp;&nbsp; however, if you like assembly coding, the 386 does have 7 32-bit registers,<BR>&nbsp;&nbsp; and if you use ALL of them, use `scaled by 8' address modes with displacement<BR>&nbsp;&nbsp; and other tricks, you can get reasonable routines for DesQuickCore... with<BR>&nbsp;&nbsp; about 250 instructions apiece.&nbsp; For DesSmall... it will help to rearrange<BR>&nbsp;&nbsp; des_keymap, i.e., now the sbox # is the high part of the index and<BR>&nbsp;&nbsp; the 6 bits of data is the low part; it helps to exchange these.<BR>&nbsp;&nbsp; since i have no way to conveniently test it i have not provided my<BR>&nbsp;&nbsp; shoehorned 386 version.&nbsp; note that with this release of desCore, gcc is able<BR>&nbsp;&nbsp; to put everything in registers(!), and generate about 370 instructions apiece<BR>&nbsp;&nbsp; for the DesQuickCore... routines!</P>
<P>coding notes</P>
<P>the en/decryption routines each use 6 necessary register variables,<BR>with 4 being actively used at once during the inner iterations.<BR>if you don't have 4 register variables get a new machine.<BR>up to 8 more registers are used to hold constants in some configurations.</P>
<P>i assume that the use of a constant is more expensive than using a register:<BR>a) additionally, i have tried to put the larger constants in registers.<BR>&nbsp;&nbsp; registering priority was by the following:<BR>&nbsp;anything more than 12 bits (bad for RISC and CISC)<BR>&nbsp;greater than 127 in value (can't use movq or byte immediate on CISC)<BR>&nbsp;9-127 (may not be able to use CISC shift immediate or add/sub quick),<BR>&nbsp;1-8 were never registered, being the cheapest constants.<BR>b) the compiler may be too stupid to realize table and table+256 should<BR>&nbsp;&nbsp; be assigned to different constant registers and instead repetitively<BR>&nbsp;&nbsp; do the arithmetic, so i assign these to explicit `m' register variables<BR>&nbsp;&nbsp; when possible and helpful.</P>
<P>i assume that indexing is cheaper or equivalent to auto increment/decrement,<BR>where the index is 7 bits unsigned or smaller.<BR>this assumption is reversed for 68k and vax.</P>
<P>i assume that addresses can be cheaply formed from two registers,<BR>or from a register and a small constant.<BR>for the 68000, the `two registers and small offset' form is used sparingly.<BR>all index scaling is done explicitly - no hidden shifts by log2(sizeof).</P>
<P>the code is written so that even a dumb compiler<BR>should never need more than one hidden temporary,<BR>increasing the chance that everything will fit in the registers.<BR>KEEP THIS MORE SUBTLE POINT IN MIND IF YOU REWRITE ANYTHING.<BR>(actually, there are some code fragments now which do require two temps,<BR>but fixing it would either break the structure of the macros or<BR>require declaring another temporary).</P>
<P><BR>special efficient data format</P>
<P>bits are manipulated in this arrangement most of the time (S7 S5 S3 S1):<BR>&nbsp;003130292827xxxx242322212019xxxx161514131211xxxx080706050403xxxx<BR>(the x bits are still there, i'm just emphasizing where the S boxes are).<BR>bits are rotated left 4 when computing S6 S4 S2 S0:<BR>&nbsp;282726252423xxxx201918171615xxxx121110090807xxxx040302010031xxxx<BR>the rightmost two bits are usually cleared so the lower byte can be used<BR>as an index into an sbox mapping table. the next two x'd bits are set<BR>to various values to access different parts of the tables.</P>
<P><BR>how to use the routines</P>
<P>datatypes:<BR>&nbsp;pointer to 8 byte area of type DesData<BR>&nbsp;used to hold keys and input/output blocks to des.</P>
<P>&nbsp;pointer to 128 byte area of type DesKeys<BR>&nbsp;used to hold full 768-bit key.<BR>&nbsp;must be long-aligned.</P>
<P>DesQuickInit()<BR>&nbsp;call this before using any other routine with `Quick' in its name.<BR>&nbsp;it generates the special 64k table these routines need.<BR>DesQuickDone()<BR>&nbsp;frees this table</P>
<P>DesMethod(m, k)<BR>&nbsp;m points to a 128byte block, k points to an 8 byte des key<BR>&nbsp;which must have odd parity (or -1 is returned) and which must<BR>&nbsp;not be a (semi-)weak key (or -2 is returned).<BR>&nbsp;normally DesMethod() returns 0.<BR>&nbsp;m is filled in from k so that when one of the routines below<BR>&nbsp;is called with m, the routine will act like standard des<BR>&nbsp;en/decryption with the key k. if you use DesMethod,<BR>&nbsp;you supply a standard 56bit key; however, if you fill in<BR>&nbsp;m yourself, you will get a 768bit key - but then it won't<BR>&nbsp;be standard.&nbsp; it's 768bits not 1024 because the least significant<BR>&nbsp;two bits of each byte are not used.&nbsp; note that these two bits<BR>&nbsp;will be set to magic constants which speed up the encryption/decryption<BR>&nbsp;on some machines.&nbsp; and yes, each byte controls<BR>&nbsp;a specific sbox during a specific iteration.<BR>&nbsp;you really shouldn't use the 768bit format directly;&nbsp; i should<BR>&nbsp;provide a routine that converts 128 6-bit bytes (specified in<BR>&nbsp;S-box mapping order or something) into the right format for you.<BR>&nbsp;this would entail some byte concatenation and rotation.</P>
<P>Des{Small|Quick}{Fips|Core}{Encrypt|Decrypt}(d, m, s)<BR>&nbsp;performs des on the 8 bytes at s into the 8 bytes at d. (d,s: char *).<BR>&nbsp;uses m as a 768bit key as explained above.<BR>&nbsp;the Encrypt|Decrypt choice is obvious.<BR>&nbsp;Fips|Core determines whether a completely standard FIPS initial<BR>&nbsp;and final permutation is done; if not, then the data is loaded<BR>&nbsp;and stored in a nonstandard bit order (FIPS w/o IP/FP).<BR>&nbsp;Fips slows down Quick by 10%, Small by 9%.<BR>&nbsp;Small|Quick determines whether you use the normal routine<BR>&nbsp;or the crazy quick one which gobbles up 64k more of memory.<BR>&nbsp;Small is 50% slower then Quick, but Quick needs 32 times as much<BR>&nbsp;memory.&nbsp; Quick is included for programs that do nothing but DES,<BR>&nbsp;e.g., encryption filters, etc.</P>
<P><BR>Getting it to compile on your machine</P>
<P>there are no machine-dependencies in the code (see porting),<BR>except perhaps the `now()' macro in desTest.c.<BR>ALL generated tables are machine independent.<BR>you should edit the Makefile with the appropriate optimization flags<BR>for your compiler (MAX optimization).</P>
<P><BR>Speeding up kerberos (and/or its des library)</P>
<P>note that i have included a kerberos-compatible interface in desUtil.c<BR>through the functions des_key_sched() and des_ecb_encrypt().<BR>to use these with kerberos or kerberos-compatible code put desCore.a<BR>ahead of the kerberos-compatible library on your linker's command line.<BR>you should not need to #include desCore.h;&nbsp; just include the header<BR>file provided with the kerberos library.</P>
<P>Other uses</P>
<P>the macros in desCode.h would be very useful for putting inline des<BR>functions in more complicated encryption routines.