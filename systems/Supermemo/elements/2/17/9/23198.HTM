<H3 id=-100000 class=docSection1Title>The Seq File Advantage</H3>
<P class=docText><A name="of an"></A>Let's discover the advantages offered by seq files with the help of an example. As is common with many device drivers, assume that you have a linked list of data structures and that each node in the list contains a string field (called <TT>info</TT>). The example code in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app03.html#app03ex01">Listing C.1</A><A name=named></A> uses a procfs file named <SPAN class=docEmphasis>/proc/readme</SPAN><A name="a user"></A> to export these strings to user space. When a user reads this file, the procfs <TT>read()</TT> method, <TT>readme_proc()</TT><A name="linked list"></A>, gets invoked. This routine traverses the linked list and appends the <TT>info</TT><A name="passed down"></A> field of each node to the filesystem buffer passed down to it.</P><A name=app03ex01></A>
<H5 id=title-ID0EEDBO class=docExampleTitle>Listing C.1. Reading via Procfs</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 border=1>
<TBODY>
<TR>
<TD>
<DIV class=codeSegmentsExpansionLinks>Code View:</DIV><PRE>/* Private Data structure */
struct _mydrv_struct {
  /* ... */
  struct list_head list;  /* Link to the next node */
  char info[10];          /* Info to pass via the procfs file */
  /* ... */
};

static LIST_HEAD(mydrv_list);  /* List Head */

/* Initialization */
static int __init
mydrv_init(void)
{
  int i;
  static struct proc_dir_entry *entry = NULL ;
  struct _mydrv_struct *mydrv_new;

  /* ... */
  /* Create <SPAN class=docEmphasis>/proc/readme</SPAN> */
  entry = create_proc_entry("readme", S_IWUSR, NULL);

  /* Attach it to readme_proc() */
  if (entry) {
    entry-&gt;read_proc = readme_proc;
  }

  /* Handcraft mydrv_list for testing purpose.
     In the real world, device driver logic
     maintains the list and populates the 'info' field */
  for (i=0;i&lt;100;i++) {
    mydrv_new = kmalloc(sizeof(mydrv_struct), GFP_ATOMIC);
    sprintf(mydrv_new-&gt;info, "Node No: %d\n", i);
    list_add_tail(&amp;mydrv_new-&gt;list, &amp;mydrv_list);
  }
  return 0;
}

/* The procfs read entry point */
static int
readme_proc(char *page, char **start, off_t offset,
            int count, int *eof, void *data)
{
  int i = 0;
  off_t thischunk_len = 0;
  struct _mydrv_struct *p;

  /* Traverse the list and copy info into the supplied buffer */
  list_for_each_entry(p, &amp;mydrv_list, list) {
    thischunk_len += sprintf(page+thischunk_len, p-&gt;info);
  }
  *eof = 1; /* Indicate completion */
  return thischunk_len;
}

					  </PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText><A name=iddle2719></A><A name=iddle3664></A><A name=iddle3738></A><A name=iddle3740></A><A name=iddle3743></A><A name="peek inside"></A>Boot the kernel with these changes and peek inside <SPAN class=docEmphasis>/proc/readme:</SPAN></P>
<DIV class=docText><PRE><SPAN class=docEmphStrong>bash&gt; cat /proc/readme</SPAN>
Node No: 0
Node No: 1
...
Node No: 99</PRE></DIV><BR>
<P class=docText><A name="When procfs"></A>When procfs <TT>read()</TT><A name="they are"></A> methods are invoked, they are supplied one page of memory that they can use to pass information to user space. As you can see in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app03.html#app03ex01">Listing C.1</A><A name=to></A>, the first argument passed to <TT>readme_proc()</TT><A name="to this"></A> is a pointer to this page-sized buffer. The second argument, <TT>start</TT><A name="than a"></A>, is used to aid the implementation of procfs files larger than a page. The use of this parameter will get clear when we look at the example in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app03.html#app03ex02">Listing C.2</A><A name="respectively specify"></A>. The next two arguments respectively specify the offset from where the read operation is requested and the number of bytes to be read. The <TT>eof</TT><A name="whether there"></A> argument is used to tell the caller whether there is more data to be read. If <TT>*eof</TT><A name="procfs read"></A> is not set before returning, the procfs read entry point is called again for more data. In <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app03.html#app03ex01">Listing C.1</A>, if you comment out the line that sets <TT>*eof</TT>, <TT>readme_proc()</TT><A name="to "></A> gets called again with the offset argument set to 1190 (which is the number of ASCII bytes contained in the strings, Node No: 0 to Node No: 99). <TT>readme_proc()</TT><A name="the supplied"></A> returns the number of bytes copied to the supplied buffer.</P>
<P class=docText><A name="The size"></A>The size of data generated by the procfs read routine in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app03.html#app03ex01">Listing C.1</A><A name="the one"></A> falls within the one-page limit. However, if you increase the number of nodes in the linked list from 100 to 500 in <TT>mydrv_init()</TT><A name="generated while"></A>, the amount of data generated while reading <SPAN class=docEmphasis>/proc/readme</SPAN><A name="and triggers"></A> crosses a page and triggers the following output:</P>
<DIV class=docText><PRE><SPAN class=docEmphStrong>bash&gt; cat /proc/readme</SPAN>
Node No: 0
Node No: 1
...
Node No: 322
proc_file_read: Apparent buffer overflow!</PRE></DIV><BR>
<P class=docText><A name="this case"></A>As you can see, an overflow occurs after one page (4,096 in this case) worth of ASCII characters have been produced.</P>
<P class=docText><A name="procfs files"></A>To handle such large procfs files, you need to refashion the code in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app03.html#app03ex01">Listing C.1</A> using the <TT>start</TT><A name=somewhat></A> parameter alluded to earlier. This makes the function somewhat <A name=iddle3742></A>complicated and is shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app03.html#app03ex02">Listing C.2</A><A name="implementation is"></A>. The semantics of this modified implementation is as follows:</P>
<UL>
<LI>
<P class=docList><TT>readme_proc()</TT><A name=of></A> is called multiple times, each invocation yielding a maximum of <TT>count</TT> bytes starting at <TT>offset</TT>. The <TT>count</TT><A name="the size"></A> requested during each call is less than the size of a page.</P></LI>
<LI>
<P class=docList><A name="During each"></A>During each invocation, the kernel increments <TT>offset</TT><A name="number of"></A> by the number of bytes returned by the previous invocation.</P></LI>
<LI>
<P class=docList><TT>readme_proc()</TT> signals <TT>eof</TT><A name="of data"></A> only if the amount of data produced is less than or equal to the requested <TT>count</TT> plus the current <TT>offset</TT>. If <TT>eof</TT><A name="function is"></A> is not set, the function is called again with <TT>offset</TT> advanced by the number of bytes returned previously.</P></LI>
<LI>
<P class=docList>After each invocation, only those bytes starting from <TT>*start</TT> are collected and returned to the caller.</P></LI></UL>
<P class=docText>Print the values of <TT>*start</TT>, <TT>offset</TT>, <TT>count</TT>, and <TT>page</TT><A name="better understand"></A>, and look at the output generated during each invocation to better understand the operation sequence.</P>
<P class=docText><A name="file can"></A>With this hack, your procfs file can supply large amounts of data to user space without size limitations:</P>
<DIV class=docText><PRE><SPAN class=docEmphStrong>bash&gt; cat /proc/readme</SPAN>
Node No: 0
Node No: 1
...
Node No: 499</PRE></DIV><BR><A name=app03ex02></A>
<H5 id=title-ID0EZKBO class=docExampleTitle>Listing C.2. Large Procfs Reads</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 border=1>
<TBODY>
<TR>
<TD>
<DIV class=codeSegmentsExpansionLinks>Code View:</DIV><PRE>static int
readme_proc(char *page, char **start, off_t offset,
               int count, int *eof, void *data)

{
  int i = 0;
  off_t thischunk_start = 0;
  off_t thischunk_len = 0;
  struct _mydrv_struct *p;
  /* Loop thru the list collecting device info */
  list_for_each_entry(p, &amp;mydrv_list, list) {
    thischunk_len += sprintf(page+thischunk_len, p-&gt;info);

    /* Advance thischunk_start only to the extent that the next
     * read will not result in total bytes more than (offset+count)
     */
    if (thischunk_start + thischunk_len &lt; offset) {
      thischunk_start += thischunk_len;
      thischunk_len = 0;
    } else if (thischunk_start + thischunk_len &gt; offset+count) {
      break;
    } else {
      continue;
    }
  }

  /* Actual start */
  *start = page + (offset - thischunk_start);

  /* Calculate number of written bytes */
  thischunk_len -= (offset - thischunk_start);
  if (thischunk_len &gt; count) {
    thischunk_len = count;
  } else {
    *eof = 1;
  }

  return thischunk_len;
}

					  </PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText><A name=iddle2498></A><A name=iddle2500></A><A name=iddle3261></A><A name=iddle3665></A><A name=iddle3739></A><A name=iddle3744></A><A name=iddle3928></A><A name=iddle4144></A><A name="rescue when"></A>The seq file interface comes to the rescue when you are faced with the prospect of awkwardly implementing large procfs files as in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app03.html#app03ex02">Listing C.2</A><A name="file interface"></A>. As the name implies, the seq file interface views the contents of procfs files as a sequence of objects. Programming interfaces are provided to iterate through this object sequence. Your code has to supply the following <SPAN class=docEmphasis>iterator</SPAN> methods expected by the seq interface:</P>
<DIV style="FONT-WEIGHT: bold">
<OL class=docList type=1>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><TT>start()</TT><A name="initializes the"></A>, which is called first by the seq interface. This initializes the position within the iterator sequence and returns the first iterator object of interest.</P></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><TT>next</TT><TT>()</TT><A name="a pointer"></A>, which increments the iterator position and returns a pointer to the next iterator. This function is agnostic to the internal structure of the iterator and considers it an opaque object.</P></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name=iddle2499></A><A name=iddle2501></A><A name=iddle4152></A><TT>show()</TT><A name="which interprets"></A>, which interprets the iterator passed to it and generates output strings to be displayed when a user reads the corresponding procfs file. This method makes use of helpers such as <TT>seq_printf()</TT>, <TT>seq_putc()</TT>, and <TT>seq_puts()</TT><A name="the output"></A> to format the output.</P></DIV></LI>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><TT>stop</TT><TT>()</TT><A name="the end"></A>, which is called at the end for cleanup.</P></DIV></LI></OL></DIV>
<P class=docText><A name="interface automatically"></A>The seq file interface automatically invokes these iterator methods to produce output in response to user operations on related procfs files. You no longer need to worry about page-sized buffers and signaling the end of data.</P>
<P class=docText>Let's rewrite <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app03.html#app03ex02">Listing C.2</A> making use of seq files. This is done in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app03.html#app03ex03">Listing C.3</A><A name="basic iterator"></A> by viewing the linked list as a sequence of nodes. The basic iterator object is the node, and each invocation of the <TT>next()</TT><A name="node in"></A> method returns the next node in the list.</P><A name=app03ex03></A>
<H5 id=title-ID0E3QBO class=docExampleTitle>Listing C.3. Using Seq Files to Simplify <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/app03.html#app03ex02">Listing C.2</A></H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 border=1>
<TBODY>
<TR>
<TD>
<DIV class=codeSegmentsExpansionLinks>Code View:</DIV><PRE>#include <LINUX seq_file.h="">

/* start() method */
static void *
mydrv_seq_start(struct seq_file *seq, loff_t *pos)
{
  struct _mydrv_struct *p;
  loff_t off = 0;

  /* The iterator at the requested offset */
  list_for_each_entry(p, &amp;mydrv_list, list) {
    if (*pos == off++) return p;
  }
  return NULL;
}

/* next() method */
static void *
mydrv_seq_next(struct seq_file *seq, void *v, loff_t *pos)
{
  /* 'v' is a pointer to the iterator returned by start() or
     by the previous invocation of next() */
  struct list_head *n = ((struct _mydrv_struct *)v)-&gt;list.next;

  ++*pos; /* Advance position */
  /* Return the next iterator, which is the next node in the list */
  return(n != &amp;mydrv_list) ?
        list_entry(n, struct _mydrv_struct, list) : NULL;
}

/* show() method */
static int
mydrv_seq_show(struct seq_file *seq, void *v)
{
  const struct _mydrv_struct *p = v;

  /* Interpret the iterator, 'v' */
  seq_printf(seq, p-&gt;info);
  return 0;
}

/* stop() method */
static void
mydrv_seq_stop(struct seq_file *seq, void *v)
{
  /* No cleanup needed in this example */
}

/* Define iterator operations */
static struct seq_operations mydrv_seq_ops = {
  .start = mydrv_seq_start,
  .next  = mydrv_seq_next,
  .stop  = mydrv_seq_stop,
  .show  = mydrv_seq_show,
};

static int
mydrv_seq_open(struct inode *inode, struct file *file)
{
  /* Register the operators */
  return seq_open(file, &amp;mydrv_seq_ops);
}

static struct file_operations mydrv_proc_fops = {
  .owner   = THIS_MODULE,
  .open    = mydrv_seq_open, /* User supplied */
  .read    = seq_read,       /* Built-in helper function */
  .llseek  = seq_lseek,      /* Built-in helper function */
  .release = seq_release,    /* Built-in helper funciton */
};

static int __init
mydrv_init(void)
{
  /* ... */

  /* Replace the assignment to entry-&gt;read_proc in Listing C.1,
     with a more fundamental assignment to entry-&gt;proc_fops. So
     instead of doing "entry-&gt;read_proc = readme_proc;", do the
     following: */
  entry-&gt;proc_fops = &amp;mydrv_proc_fops;

  /* ... */
}

					  </LINUX></PRE></TD></TR></TBODY></TABLE>