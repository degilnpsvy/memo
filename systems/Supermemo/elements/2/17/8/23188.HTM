<H3 id=-100000 class=docSection1Title>Portable Code</H3>
<P class=docText><A name="Portability directly"></A>Portability directly translates to code reusability and easier maintenance. This is significant in today's marketplace, where there are an assortment of processors and innumerable peripheral chipsets. Things will fast spin out of control if you have to code separate bus drivers for each processor and different client device drivers for each host controller. Here are some hints for writing portable drivers:</P>
<UL>
<LI>
<P class=docList><A name="a design"></A>Make portability a design goal while architecting your driver.</P></LI>
<LI>
<P class=docList><A name="automatically injects"></A>Using appropriate kernel APIs automatically injects a degree of portability. A USB driver using the services of the USB core is rendered independent of the USB host controller. It will work unchanged on different systems, irrespective on whether they use UHCI, OHCI, or something else.</P></LI>
<LI>
<P class=docList>Write SMP-safe code.</P></LI>
<LI>
<P class=docList><A name="is "></A>Write code that is 64-bit clean. Do not, for example, assign a pointer to an integer, even with valid typecasts.</P></LI>
<LI>
<P class=docList><A name="other similar"></A>Write drivers such that they can be easily adapted for other similar devices.</P></LI>
<LI>
<P class=docList><A name=iddle2325></A><A name=iddle3354></A><A name="calls to"></A>Use architecture-independent APIs wherever available. For example, calls to <TT>outb()</TT> or <TT>inb()</TT><A name="uses I"></A> will work irrespective of whether the processor uses I/O-mapped or memory-mapped addressing. If you do need to use architecture-specific code such as inline assembly, stow it away inside the appropriate <SPAN class=docEmphasis>arch/your-arch/</SPAN> directory.</P></LI>
<LI>
<P class=docList><A name="and user"></A>Push policy to header files and user space. Use macros and definitions wherever suitable.</P></LI></UL>