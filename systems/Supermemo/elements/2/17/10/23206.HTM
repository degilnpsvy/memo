<H2 id=title-IDAZCKFI class=docPrefaceTitle>Preface</H2>
<P class=docText>Although many good books cover Linux, none brings together so many dimensions of information and advice specifically targeted to the embedded Linux developer. Indeed, there are some very good books written about the Linux kernel, Linux system administration, and so on. You will find references right here in this book to many of the ones that I consider to be at the top of their categories.</P>
<P class=docText>Much of the material presented in this book is motivated by questions I've received over the years from development engineers, in my capacity as an embedded Linux consultant and my present role as a Field Application Engineer for Monta Vista Software, the leading vendor of embedded Linux distributions.</P>
<P class=docText>Embedded Linux presents the experienced software engineer with several unique challenges. First, those with many years of experience with legacy real-time operating systems (RTOSes) find it difficult to transition their thinking from those environments to Linux. Second, experienced application developers often have difficulty understanding the relative complexities of a cross-development environment.</P>
<P class=docText>Although this is a primer, intended for developers new to embedded Linux, I am confident that even developers who are experienced in embedded Linux will find some useful tips and techniques that I have learned over the years.</P><A name=pref02lev1sec1></A>
<H3 id=title-IDAODKFI class=docSection1Title>Practical Advice for the Practicing Embedded Developer</H3>
<P class=docText>This book contains my view of what an embedded engineer needs to know to get up to speed fast in an embedded Linux environment. Instead of focusing on Linux kernel internals, the kernel chapter in this book focuses on the project nature of the kernel and leaves the internals to the other excellent texts on the subject. You will learn the organization and layout of the kernel source tree. You will discover the binary components that make up a kernel image, and how they are loaded and what purpose they serve on an embedded system. One of my favorite figures in the book is <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch05lev1sec1.html#ch05fig01">Figure 5-1</A>, which schematically illustrates the build process of a composite kernel image.</P>
<P class=docText>In the pages of this book, you will learn how the build system works and how to incorporate into the Linux kernel your own custom changes that are required for your own projects. You will discover the mechanism used to drive the configuration of different architectures and features within the Linux kernel source tree and, more important, how to modify this system to customize it to your own requirements. We also cover in detail the kernel command-line mechanism. You will learn how it works, how to configure the kernel's runtime behavior for your requirements, and how to extend this functionality to your own project. You will learn how to navigate the kernel source code and how to configure the kernel for specific tasks related to an embedded system. You will learn many useful tips and tricks for your embedded project, from bootloaders, system initialization, file systems, and Flash memory to advanced kernel- and application-debugging techniques.</P><A name=pref02lev1sec2></A>
<H3 id=title-IDAIEKFI class=docSection1Title>Intended Audience</H3>
<P class=docText>This book is intended for programmers with a working knowledge of programming in C. I assume that you have a rudimentary understanding of local area networks and the Internet. You should understand and recognize an IP address and how it is used on a simple local area network. I also assume that you have an understanding of hexadecimal and octal numbering systems, and their common usage in a text such as this.</P>
<P class=docText>Several advanced concepts related to C compiling and linking are explored, so you will benefit from having at least a cursory understanding of the role of the linker in ordinary C programming. Knowledge of the GNU <TT>make</TT> operation and semantics will also prove beneficial.</P><A name=pref02lev1sec3></A>
<H3 id=title-IDA1EKFI class=docSection1Title>What This Book Is Not</H3>
<P class=docText>This book is not a detailed hardware tutorial. One of the difficulties the embedded developer faces is the huge variety of hardware devices in use today. The user manual for a modern 32-bit processor with some integrated peripherals can easily exceed 1,000 pages. There are no shortcuts. If you need to understand a hardware device from a programmer's point of view, you will need to spend plenty of hours in your favorite reading chair with hardware data sheets and reference guides, and many more hours writing and testing code for these hardware devices!</P>
<P class=docText>This is also not a book about the Linux kernel or kernel internals. In this book, you won't learn about the intricacies of the Memory Management Unit (MMU) used to implement Linux's virtual memory-management policies and procedures; there are already several good books on this subject. You are encouraged to take advantage of the "Suggestions for Additional Reading" section found at the end of every chapter.</P><A name=pref02lev1sec4></A>
<H3 id=title-IDAOFKFI class=docSection1Title>Conventions Used</H3>
<P class=docText>Filenames and code statements are presented in <TT>Courier</TT>. Commands issued by the reader are indicated in <SPAN class=docEmphStrong><TT>bold Courier</TT></SPAN>. New terms or important concepts are presented in <SPAN class=docEmphasis>italics</SPAN>.</P>
<P class=docText>When you see a pathname preceded with three dots, this references a well-known but unspecified top-level directory. The top-level directory is context dependent but almost universally refers to a top-level Linux source directory. For example, <TT>.../arch/ppc/kernel/setup.c</TT> refers to the <TT>setup.c</TT> file located in the architecture branch of a Linux source tree. The actual path might be something like <TT>~/sandbox/linux.2.6.14/arch/ppc/kernel/setup.c.</TT></P><A name=pref02lev1sec5></A>
<H3 id=title-IDANGKFI class=docSection1Title>Organization of the Book</H3>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch01.html#ch01">Chapter 1</A>, "Introduction," provides a brief look at the factors driving the rapid adoption of Linux in the embedded environment. Several important standards and organizations relevant to embedded Linux are introduced.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02.html#ch02">Chapter 2</A>, "Your First Embedded Experience," introduces the reader to many concepts related to embedded Linux upon which we build in later chapters.</P>
<P class=docText>In <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch03.html#ch03">Chapter 3</A>, "Processor Basics," we present a high-level look at the more popular processors and platforms that are being used to build embedded Linux systems. We examine selected products from many of the major processor manufacturers. All of the major architecture families are represented.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch04.html#ch04">Chapter 4</A>, "The Linux Kernel: A Different Perspective," examines the Linux kernel from a slightly different perspective. Instead of kernel theory or internals, we look at its structure, layout, and build construction so you can begin to learn your way around this large software project and, more important, learn where your own customization efforts must be focused. This includes detailed coverage of the kernel build system.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch05.html#ch05">Chapter 5</A>, "Kernel Initialization," details the Linux kernel's initialization process. You will learn how the architecture- and bootloader-specific image components are concatenated to the image of the kernel proper for downloading to Flash and booting by an embedded bootloader. The knowledge gained here will help you customize the Linux kernel to your own embedded application requirements.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch06.html#ch06">Chapter 6</A>, "System Initialization," continues the detailed examination of the initialization process. When the Linux kernel has completed its own initialization, application programs continue the initialization process in a predetermined manner. Upon completing <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch06.html#ch06">Chapter 6</A>, you will have the necessary knowledge to customize your own userland application startup sequence.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch07.html#ch07">Chapter 7</A>, "Bootloaders," is dedicated to the booloader and its role in an embedded Linux system. We examine the popular open-source bootloader U-Boot and present a porting example. We briefly introduce additional bootloaders in use today so you can make an informed choice about your particular requirements.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch08.html#ch08">Chapter 8</A>, "Device Driver Basics," introduces the Linux device driver model and provides enough background to launch into one of the great texts on device drivers, listed as "<A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch08lev1sec6.html#ch08lev2sec16">Suggestions for Additional Reading</A>" at the end of the chapter.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch09.html#ch09">Chapter 9</A>, "File Systems," presents the more popular file systems being used in embedded systems today. We include coverage of the JFFS2, an important embedded file system used on Flash memory devices. This chapter includes a brief introduction on building your own file system image, one of the more difficult tasks the embedded Linux developer faces.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch10.html#ch10">Chapter 10</A>, "MTD Subsystem," explores the Memory Technology Devices (MTD) subsystem. MTD is an extremely useful abstraction layer between the Linux file system and hardware memory devices, primarily Flash memory.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch11.html#ch11">Chapter 11</A>, "BusyBox," introduces BusyBox, one of the most useful utilities for building small embedded systems. We describe how to configure and build BusyBox for your particular requirements, along with detailed coverage of system initialization unique to a BusyBox environment. <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/app03.html#app03">Appendix C</A>, "BusyBox Commands," lists the available BusyBox commands from a recent BusyBox release.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch12.html#ch12">Chapter 12</A>, "Embedded Development Environment," takes a detailed look at the unique requirements of a typical cross-development environment. Several techniques are presented to enhance your productivity as an embedded developer, including the powerful NFS root mount development configuration.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch13.html#ch13">Chapter 13</A>, "Development Tools," examines many useful development tools. Debugging with gdb is introduced, including coverage of core dump analysis. Many more tools are presented and explained, with examples including <TT>strace</TT>, <TT>ltrace</TT>, <TT>top</TT>, and <TT>ps</TT>, and <TT>the memory profilers mtrace</TT> and <TT>dmalloc</TT>. The chapter concludes with an introduction to the more important binary utilities, including the powerful <TT>readelf</TT> utility.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch14.html#ch14">Chapter 14</A>, "Kernel Debugging Techniques," provides a detailed examination of many debugging techniques useful for debugging inside the Linux kernel. We introduce the use of the kernel debugger KGDB, and present many useful debugging techniques using the combination of <TT>gdb</TT> and KGDB as debugging tools. Included is an introduction to using hardware JTAG debuggers and some tips for analyzing failures when the kernel won't boot.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch15.html#ch15">Chapter 15</A>, "Debugging Embedded Linux Applications," moves the debugging context from the kernel to your application programs. We continue to build on the gdb examples from the previous two chapters, and we present techniques for multithreaded and multiprocess debugging.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch16.html#ch16">Chapter 16</A>, "Porting Linux," introduces the issues related to porting Linux to your custom board. We walk through a simple example and highlight the steps taken to produce a working Linux kernel on a custom PowerPC board. Several important concepts are presented that have trapped many newcomers to Linux kernel porting. Together with the techniques presented in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch13.html#ch13">Chapters 13</A> and <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch14.html#ch14">14</A>, you should be ready to tackle your own custom board port after reading this chapter.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch17.html#ch17">Chapter 17</A>, "Linux and Real Time," provides an introduction to one of the more exciting developments in embedded Linux: configuring for real time via the <TT>CONFIG_RT</TT> option. We cover the features available with RT and how they can be used in a design. We also present techniques for measuring latency in your application configuration.</P>
<P class=docText>The appendixes cover the GNU Public License, U-Boot Configurable Commands, BusyBox Commands, SDRAM Interface Considerations, resources for the open source developer, and a sample configuration file for one of the more popular hardware JTAG debuggers, the BDI-2000.</P><A name=pref02lev2sec1></A>
<H4 id=title-IDAQVKFI class=docSection2Title>Follow Along</H4>
<P class=docText>You will benefit most from this book if you can divide your time between the pages of this book and your favorite Linux workstation. Grab an old x86 computer to experiment on an embedded system. Even better, if you have access to a single-board computer based on another architecture, use that. You will benefit from learning the layout and organization of a very large code base (the Linux kernel), and you will gain significant knowledge and experience as you poke around the kernel and learn by doing.</P>
<P class=docText>Look at the code and try to understand the examples produced in this book. Experiment with different settings, configuration options, and hardware devices. Much can be gained in terms of knowledge, and besides, it's loads of fun!</P><A name=pref02lev2sec2></A>
<H4 id=title-IDA4VKFI class=docSection2Title>GPL Copyright Notice</H4>
<P class=docText>Portions of open-source code reproduced in this book are copyrighted by a large number of individual and corporate contributors. The code reproduced here has been licensed under the terms of the GNU Public License or GPL.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/app01.html#app01">Appendix A</A> contains the text of the GNU General Public License.