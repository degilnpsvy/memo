<H3 id=title-IDAD3HYD class=docSection1Title>5.2. Initialization Flow of Control</H3>
<P class=docText>Now that we have an understanding of the structure and components of the composite kernel image, let's examine the flow of control from the bootloader to the kernel in a complete boot cycle. As we discussed in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch02.html#ch02">Chapter 2</A>, "Your First Embedded Experience," the bootloader is the low-level component resident in system nonvolatile memory (Flash or ROM) that takes control immediately after the power has been applied. It is typically a small, simple set of routines designed primarily to do low-level initialization, boot image loading, and system diagnostics. It might contain memory dump and fill routines for examining and modifying the contents of memory. It might also contain low-level board self-test routines, including memory and I/O tests. Finally, a bootloader contains logic for loading and passing control to another program, usually an operating system such as Linux.</P>
<P class=docText>The ARM XScale platform used as a basis for the examples in this chapter contains the Redboot bootloader. When power is first applied, this bootloader is invoked and proceeds to load the operating system (OS). When the bootloader locates and loads the OS image (which could be resident locally in Flash, on a hard drive, or via a local area network or other device), control is passed to that image.</P>
<P class=docText>On this particular XScale platform, the bootloader passes control to our <TT>head.o</TT> module at the label <TT>Start</TT> in the bootstrap loader. This is illustrated in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch05lev1sec2.html#ch05fig03">Figure 5-3</A>.</P><A name=ch05fig03></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 5-3. ARM boot control flow</H5>
<P class=docText><IMG id=195131084202 border=0 alt="" src="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/images/05elp03.jpg" width=500 height=203></P></CENTER>
<P></P><BR>
<P class=docText>As detailed earlier, the bootstrap loader prepended to the kernel image has a single primary responsibility: to create the proper environment to decompress and relocate the kernel, and pass control to it. Control is passed from the bootstrap loader directly to the kernel proper, to a module called <TT>head.o</TT> for most architectures. It is an unfortunate historical artifact that both the bootstrap loader and the kernel proper contain a module called <TT>head.o</TT> because it is a source of confusion to the new embedded Linux developer. The <TT>head.o</TT> module in the bootstrap loader might be more appropriately called <TT>kernel_bootstrap_loader_head.o</TT>, although I doubt that the kernel developers would accept this patch. In fact, a recent Linux 2.6 source tree contains no fewer than <TT>37</TT> source files named <TT>head.S</TT>. This is another reason why you need to know your way around the kernel source tree.</P>
<P class=docText>Refer back to <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch05lev1sec2.html#ch05fig03">Figure 5-3</A> for a graphical view of the flow of control. When the bootstraploader has completed its job, control is passed to the kernel proper's <TT>head.o</TT>, and from there to <TT>start_kernel() in main.c</TT>.</P><A name=ch05lev2sec5></A>
<H4 id=title-IDA35HYD class=docSection2Title>5.2.1. Kernel Entry Point: head.o</H4>
<P class=docText><A name=iddle1103></A><A name=iddle1515></A><A name=iddle1589></A><A name=iddle1638></A><A name=iddle1756></A>The intention of the kernel developers was to keep the architecture-specific <TT>head.o</TT> module very generic, without any specific machine<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch05lev1sec2.html#ch054">[4]</A></SUP> dependencies. This module, derived from the assembly language file <TT>head.S</TT>, is located at <TT>.../arch/&lt;ARCH&gt;/kernel/head.S</TT>, where <TT>&lt;ARCH&gt;</TT> is replaced by the given architecture. The examples in this chapter are based on the ARM/XScale, as you have seen, with <TT>&lt;ARCH&gt;=arm</TT>.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch054>[4]</A></SUP> The term <SPAN class=docEmphasis>machine</SPAN> as used here refers to a specific hardware reference platform.</P></BLOCKQUOTE>
<P class=docText>The <TT>head.o</TT> module performs architecture- and often CPU-specific initialization in preparation for the main body of the kernel. CPU-specific tasks are kept as generic as possible across processor families. Machine-specific initialization is performed elsewhere, as you will discover shortly. Among other low-level tasks, <TT>head.o</TT> performs the following tasks:</P>
<UL>
<LI>
<P class=docList>Checks for valid processor and architecture</P></LI>
<LI>
<P class=docList>Creates initial page table entries</P></LI>
<LI>
<P class=docList>Enables the processor's memory management unit (MMU)</P></LI>
<LI>
<P class=docList>Establishes limited error detection and reporting</P></LI>
<LI>
<P class=docList>Jumps to the start of the kernel proper, <TT>main.c</TT></P></LI></UL>
<P class=docText>These functions contain some hidden complexities. Many novice embedded developers have tried to single-step through parts of this code, only to find that the debugger becomes hopelessly lost. Although a discussion of the complexities of assembly language and the hardware details of virtual memory is beyond the scope of this book, a few things are worth noting about this complicated module.</P>
<P class=docText>When control is first passed to the kernel's <TT>head.o</TT> from the bootstrap loader, the processor is operating in what we used to call real mode in x86 terminology. In effect, the logical address contained in the processor's <SPAN class=docEmphasis>program counter</SPAN><SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch05lev1sec2.html#ch055">[5]</A></SUP> (or any other register, for that matter) is the actual physical address driven onto the processor's electrical memory address pins. Soon after the processor's registers and kernel data structures are initialized to enable memory translation, the processor's memory management unit (MMU) is turned on. Suddenly, the address space as seen by the processor is yanked from beneath it and replaced by an arbitrary virtual addressing scheme determined by the kernel developers. This creates a complexity that can really be understood only by a detailed analysis of both the assembly language constructs and logical flow, as well as a detailed knowledge of the CPU and its hardware address translation mechanism. In short, physical addresses are replaced by logical addresses the moment the MMU is enabled. That's why a debugger can't single-step through this portion of code as with ordinary code.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch055>[5]</A></SUP> Often called Instruction Pointer, the register which holds the address of the next machine instruction in memory.</P></BLOCKQUOTE>
<P class=docText>The second point worth noting is the limited available mapping at this early stage of the kernel boot process. Many developers have stumbled into this limitation while trying to modify <TT>head.o</TT> for their particular platform.<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch05lev1sec2.html#ch056">[6]</A></SUP> One such scenario might go like this. Let's say you have a hardware device that needs a firmware load very early in the boot cycle. One possible solution is to compile the necessary firmware statically into the kernel image and then reference it via a pointer to download it to your device. However, because of the limited memory mapping done at this point, it is quite possible that your firmware image will exist beyond the range that has been mapped at this early stage in the boot cycle. When your code executes, it generates a page fault because you have attempted to access a memory region for which no valid mapping has been created inside the processor. Worse yet, a page fault handler has not yet been installed at this early stage, so all you get is an unexplained system crash. At this early stage in the boot cycle, you are pretty much guaranteed <TT>not</TT> to have any error messages to help you figure out what's wrong.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch056>[6]</A></SUP> Modifying <TT>head.S</TT> for your custom platform is highly discouraged. There is almost always a better way. See <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch16.html#ch16">Chapter 16</A>, "Porting Linux," for additional information.</P></BLOCKQUOTE>
<P class=docText>You are wise to consider delaying any custom hardware initialization until after the kernel has booted, if at all possible. In this manner, you can rely on the well-known device driver model for access to custom hardware instead of trying to customize the much more complicated assembly language startup code. Numerous undocumented techniques are used at this level. One common example of this is to work around hardware errata that may or may not be documented. A much higher price will be paid in development time, cost, and complexity if you must make changes to the early startup assembly language code. Hardware and software engineers should discuss these facts during early stages of hardware development, when often a minor hardware change can lead to significant savings in software development time.</P>
<P class=docText>It is important to recognize the constraints placed upon the developer in a virtual memory environment. Many experienced embedded developers have little or no experience in this environment, and the scenario presented earlier is but one small example of the pitfalls that await the developer new to virtual memory <A name=iddle1104></A><A name=iddle1516></A><A name=iddle1639></A><A name=iddle1757></A><A name=iddle2064></A>architectures. Nearly all modern 32-bit and larger microprocessors have memory-management hardware used to implement virtual memory architectures. One of the most significant advantages of virtual memory machines is that they help separate teams of developers write large complex applications, while protecting other software modules, and the kernel itself, from programming errors.</P><A name=ch05lev2sec6></A>
<H4 id=title-IDAUGIYD class=docSection2Title>5.2.2. Kernel Startup: main.c</H4>
<P class=docText>The final task performed by the kernel's own <TT>head.o</TT> module is to pass control to the primary kernel startup file written in C. We spend a good portion of the rest of this chapter on this important file.</P>
<P class=docText>For each architecture, there is a different syntax and methodology, but every architecture's <TT>head.o</TT> module has a similar construct for passing control to the kernel proper. For the ARM architecture it looks as simple as this:</P>
<DIV class=docText><PRE>    b    start_kernel</PRE></DIV><BR>
<P class=docText>For PowerPC, it looks similar to this:</P>
<DIV class=docText><PRE>    lis    r4,start_kernel@h
    ori    r4,r4,start_kernel@l
    lis    r3,MSR_KERNEL@h
    ori    r3,r3,MSR_KERNEL@l
    mtspr  SRR0,r4
    mtspr  SRR1,r3
    rfi</PRE></DIV><BR>
<P class=docText>Without going into details of the specific assembly language syntax, both of these examples result in the same thing. Control is passed from the kernel's first object module (<TT>head.o</TT>) to the C language routine <TT>start_kernel()</TT> located in <TT>.../init/main.c</TT>. Here the kernel begins to develop a life of its own.</P>
<P class=docText>The file <TT>main.c</TT> should be studied carefully by anyone seeking a deeper understanding of the Linux kernel, what components make it up, and how they are initialized and/or instantiated. <TT>main.c</TT> does all the startup work for the Linux kernel, from initializing the first kernel thread all the way to mounting a root file system and executing the very first <SPAN class=docEmphasis>user space</SPAN> Linux application program.</P>
<P class=docText>The function <TT>start_kernel()</TT> is by far the largest function in <TT>main.c</TT>. Most of the Linux kernel initialization takes place in this routine. Our purpose here is to highlight those particular elements that will prove useful in the context of embedded systems development. It is worth repeating: Studying <TT>main.c</TT> is a great way to spend your time if you want to develop a better understanding of the Linux kernel as a system.</P><A name=ch05lev2sec7></A>
<H4 id=title-IDA1IIYD class=docSection2Title>5.2.3. Architecture Setup</H4>
<P class=docText><A name=iddle1047></A><A name=iddle1102></A><A name=iddle1182></A><A name=iddle1514></A><A name=iddle1637></A><A name=iddle1755></A><A name=iddle1787></A><A name=iddle2180></A>Among the first few things that happen in <TT>.../init/main.c</TT> in the <TT>start_kernel()</TT> function is the call to <TT>setup_arch()</TT>. This function takes a single parameter, a pointer to the <SPAN class=docEmphasis>kernel command line</SPAN> introduced earlier and detailed in the next section.</P>
<DIV class=docText><PRE>    setup_arch(&amp;command_line);</PRE></DIV><BR>
<P class=docText>This statement calls an architecture-specific setup routine responsible for performing initialization tasks common across each major architecture. Among other functions, <TT>setup_arch()</TT> calls functions that identify the specific CPU and provides a mechanism for calling high-level CPU-specific initialization routines. One such function, called directly by <TT>setup_arch()</TT>, is <TT>setup_processor()</TT>, found in <TT>.../arch/arm/kernel/setup.c</TT>. This function verifies the CPU ID and revision, calls CPU-specific initialization functions, and displays several lines of information on the console during boot.</P>
<P class=docText>An example of this output can be found in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch05lev1sec1.html#ch05list03">Listing 5-3</A>, lines 3 through 8. Here you can see the CPU type, ID string, and revision read directly from the processor core. This is followed by details of the processor cache type and size. In this example, the IXP425 has a 32KB I (instruction) cache and 32KB D (data) cache, along with other implementation details of the internal processor cache.</P>
<P class=docText>One of the final actions of the architecture setup routines is to perform any machine-dependent initialization. The exact mechanism for this varies across different architectures. For ARM, you will find machine-specific initialization in the <TT>.../arch/arm/mach-*</TT> series of directories, depending on your machine type. MIPS architecture also contains directories specific to supported reference platforms. For PowerPC, there is a machine-dependent structure that contains pointers to many common setup functions. We examine this in more detail in <A class=docLink href="http://www.embeddedlinux.org.cn/EmbeddedLinuxPrimer/0136130550/ch16.html#ch16">Chapter 16</A>, "Porting Linux."