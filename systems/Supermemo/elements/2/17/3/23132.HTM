<H3 id=-100000 class=docSection1Title>NAND Chip Drivers</H3>
<P class=docText><A name=iddle1579></A><A name=iddle1608></A><A name=iddle3096></A><A name=iddle3097></A><A name=iddle3100></A><A name=iddle3102></A><A name=iddle3181></A><A name=iddle3182></A><A name=iddle3183></A><A name=iddle3186></A><A name=iddle3188></A><A name=iddle3191></A><A name=iddle4210></A><A name="NAND technology"></A>NAND technology users such as USB pen drives, DOMs, Compact Flash memory, and SD/MMC cards emulate standard storage interfaces such as SCSI or IDE over NAND flash, so you don't need to develop NAND drivers to communicate with them.<SUP class=docFootnote><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec5.html#ch17fn05">[5]</A></SUP><A name="chips need"></A> On-board NAND flash chips need special drivers, however, and are the topic of this section.</P>
<BLOCKQUOTE>
<P class=docFootnote><SUP><A name=ch17fn05>[5]</A></SUP><A name="drivers for"></A> Unless you are writing drivers for the storage media itself. If you are embedding Linux on a device that will export part of its NAND partition to the outside world as a USB mass storage device, you do have to contend with NAND drivers.</P></BLOCKQUOTE>
<P class=docText><A name="previously in"></A>As you learned previously in this chapter, NAND flash chips, unlike their NOR counterparts, are not connected to the CPU via data and address lines. They interface to the CPU through special electronics called a <SPAN class=docEmphasis>NAND flash controller</SPAN><A name="NAND flash"></A> that is part of many embedded processors. To read data from NAND flash, the CPU issues an appropriate <SPAN class=docEmphasis>read</SPAN><A name="The controller"></A> command to the NAND controller. The controller transfers data from the requested flash location to an internal RAM memory, also part of the controller. The data transfer is done in units of the flash chip's <SPAN class=docEmphasis>page size</SPAN><A name="is its"></A> (for example, 2KB). In general, the denser the flash chip, the larger is its page size. Note that the page size is different from the flash chip's <SPAN class=docEmphasis>block size</SPAN><A name="flash memory"></A>, which is the minimum erasable flash memory unit (for example, 16KB). After the transfer operation completes, the CPU reads the requested NAND contents from the internal RAM. Writes to NAND flash are done similarly, except that the controller transfers data from the internal RAM to flash. The connection diagram of NAND flash memory on an embedded device is shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec5.html#ch17fig03">Figure 17.3</A>.</P><A name=ch17fig03></A>
<P>
<CENTER>
<H5 class=docFigureTitle>Figure 17.3. NAND flash connection.</H5>
<P class=docText><IMG border=0 alt="" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/MjltNHJhaS9kNy8zY3JncDA4dHMvOTMxZTZhZzU1LjdpMWYvcGdoaWZjaXMwM2c-.jpg" width=300 height=268></P></CENTER>
<P></P><BR>
<P class=docText><A name="special drivers"></A>Because of this unconventional mode of addressing, you need special drivers to work with NAND storage. MTD provides such drivers to manage NAND-resident data. If you are using a supported chip, you have to enable only the appropriate low-level MTD NAND driver. If you are writing a NAND flash driver, however, you need to explore two datasheets: the NAND flash controller and the NAND flash chip.</P>
<P class=docText><A name="configuration using"></A>NAND flash chips do not support automatic configuration using protocols such as CFI. You have to manually inform MTD about the properties of your NAND chip by adding an entry to the <TT>nand_flash_ids[]</TT><A name="table defined"></A> table defined in <SPAN class=docEmphasis>drivers/mtd/nand/nand_ids.c</SPAN><A name="in the"></A>. Each entry in the table consists of an identifier name, the device ID, page size, erase block size, chip size, and options such as the bus width.</P>
<P class=docText><A name=iddle1481></A><A name=iddle1679></A><A name=iddle1867></A><A name=iddle1879></A><A name=iddle1998></A><A name=iddle1999></A><A name=iddle2904></A><A name=iddle3101></A><A name=iddle3103></A><A name=iddle3179></A><A name=iddle3187></A><A name=iddle3189></A><A name=iddle3321></A><A name=iddle3351></A><A name=iddle3796></A><A name=iddle4108></A><A name="that goes"></A>There is another characteristic that goes hand in hand with NAND memory. NAND flash chips, unlike NOR chips, are not faultless. It's normal to have some problem bits and bad blocks scattered across NAND flash regions. To handle this, NAND devices associate a <SPAN class=docEmphasis>spare area</SPAN><A name="page "></A> with each flash page (for example, 64 bytes of spare area for each 2KB data page). The spare area contains <SPAN class=docEmphasis>out-of-band</SPAN><A name="OOB area"></A> (OOB) information to help perform bad block management and error correction. The OOB area includes <SPAN class=docEmphasis>error correcting codes</SPAN><A name="and detection"></A> (ECCs) to implement error correction and detection. ECC algorithms correct single-bit errors and detect multibit errors. The <TT>nand_ecclayout</TT> structure defined in <SPAN class=docEmphasis>include/mtd/mtd-abi.h</SPAN> specifies the layout of the OOB spare area:</P>
<DIV class=docText><PRE>struct nand_ecclayout {
  uint 32_t eccbytes;
  uint32_t  eccpos[64];
  uint32_t  oobavail;
  struct    nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES];
};</PRE></DIV><BR>
<P class=docText>In this structure, <TT>eccbytes</TT><A name="store ECC"></A> holds the number of OOB bytes that store ECC data, and <TT>eccpos</TT><A name="into the"></A> is an array of offsets into the OOB area that contains the ECC data. <TT>oobfree</TT><A name="available to"></A> records the unused bytes in the OOB area available to flash filesystems for storing flags such as <SPAN class=docEmphasis>clean markers</SPAN> that signal successful completion of erase operations.</P>
<P class=docText>Individual NAND drivers initialize their <TT>nand_ecclayout</TT> according to the chip's properties. <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec5.html#ch17fig04">Figure 17.4</A><A name="chip having"></A> illustrates the layout of a NAND flash chip having a page size of 2KB. The OOB semantics used by the figure is the default for 2KB page-sized chips as defined in the generic NAND driver, <SPAN class=docEmphasis>drivers/mtd/nand/nand_base.c</SPAN>.</P><A name=ch17fig04></A>
<P>
<CENTER>
<H5 class=docFigureTitle><A name="Figure "></A>Figure 17.4. Layout of a NAND flash chip.</H5>
<P class=docText>
<DIV class=st1><A href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/MjltNHJhaS9kNy8zY3JncDA4dHMvOTMxZTZhZzU1aV83aTFmL3BhZmhpdGNsMDRzZy5n.jpg" target=_blank>[View full size image]</A></DIV><IMG border=0 alt="" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/MjltNHJhaS9kNy8zY3JncDA4dHMvOTMxZTZhZzU1LjdpMWYvcGdoaWZjaXMwNGc-.jpg" width=500 height=412>
<P></P></CENTER>
<P></P><BR>
<P class=docText><A name=iddle3099></A><A name=iddle3185></A><A name="controller performs"></A>Often, the NAND controller performs error correction and detection in hardware by operating on the ECC fields in the OOB area. If your NAND controller does not support error management, however, you will need to get MTD to do that for you in software. The MTD <SPAN class=docEmphasis>nand_ecc</SPAN> driver (<SPAN class=docEmphasis>drivers/mtd/nand/nand_ecc.c</SPAN>) implements software ECC.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec5.html#ch17fig04">Figure 17.4</A><A name="bytes that"></A> also shows OOB memory bytes that contain bad block markers. These markers are used to flag faulty flash blocks and are usually present in the OOB region belonging to the first page of each block. The position of the marker inside the OOB area depends on the properties of the chip. Bad block markers are either set at the factory during manufacture, or by software when it detects wear in a block. MTD implements bad block management in <SPAN class=docEmphasis>drivers/mtd/nand/nand_bbt.c</SPAN>.</P>
<P class=docText>The <TT>mtd_partition</TT> structure used in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec3.html#ch17ex01">Listing 17.1</A><A name="flash in"></A> for the NOR flash in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec3.html#ch17fig02">Figure 17.2</A><A name="the constituent"></A> works for NAND memory, too. After you MTD-enable your NAND flash, you can access the constituent partitions using standard device nodes such as <SPAN class=docEmphasis>/dev/mtd/X</SPAN> and <SPAN class=docEmphasis>/dev/mtdblock/X</SPAN><A name="mix of"></A>. If you have a mix of NOR and NAND memories on your hardware, <SPAN class=docEmphasis>X</SPAN><A name="NAND partition"></A> can be either a NOR or a NAND partition. If you have a total of more than 32 flash partitions, accordingly change the value of <TT>MAX_MTD_DEVICES</TT> in <SPAN class=docEmphasis>include/linux/mtd/mtd.h</SPAN>.</P>
<P class=docText><A name=iddle1238></A><A name=iddle1982></A><A name=iddle2074></A><A name=iddle2116></A><A name=iddle3108></A><A name=iddle3113></A><A name=iddle3120></A><A name=iddle3121></A><A name=iddle3190></A><A name=iddle3266></A><A name=iddle4553></A><A name=iddle4558></A><A name=iddle4630></A><A name="NAND storage"></A>To effectively make use of NAND storage, you need to use a filesystem tuned for NAND access, such as JFFS2 or YAFFS2, in tandem with the low-level NAND driver. We discuss these filesystems in the next section.