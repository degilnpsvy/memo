<H3 id=-100000 class=docSection1Title>User Modules</H3>
<P class=docText><A name="After you"></A>After you have added a map driver and chosen the right chip driver, you're all set to let higher layers use the flash. User-space applications that perform file I/O need to view the flash device as if it were a disk, whereas programs that desire to accomplish raw I/O access the flash as if it were a character device. The MTD layer that achieves these and more is called <SPAN class=docEmphasis>User Modules</SPAN><A name=in></A>, as shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec2.html#ch17fig01">Figure 17.1</A><A name="constituting this"></A>. Let's look at the components constituting this layer.</P><A name=ch17lev2sec2></A>
<H4 id=title-ID0ESBAO class=docSection2Title>Block Device Emulation</H4>
<P class=docText><A name="provides a"></A>The MTD subsystem provides a block driver called <SPAN class=docEmphasis>mtdblock</SPAN><A name="any filesystem"></A> that emulates a hard disk over flash memory. You can put any filesystem, say EXT2, over the emulated flash disk. Mtdblock hides complicated flash access procedures (such as preceding a write with an erase of the corresponding sector) from the filesystem. Device nodes created by mtdblock are named <SPAN class=docEmphasis>/dev/mtdblock/X</SPAN>, where <SPAN class=docEmphasis>X</SPAN><A name="create an"></A> is the partition number. To create an EXT2 filesystem on the pda_fs partition of the handheld, as shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec3.html#ch17fig02">Figure 17.2</A>, do the following:</P>
<DIV class=docText><PRE><SPAN class=docEmphStrong>bash&gt; mkfs.ext2 /dev/mtdblock/2</SPAN>    <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF">  Create an EXT2 filesystem
                                         on the second partition
<SPAN class=docEmphStrong>bash&gt; mount /dev/mtdblock/2 /mnt</SPAN>   <IMG alt="rightwards double arrow" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/U2192.GIF">  Mount the partition</PRE></DIV><BR>
<P class=docText><A name="idea to"></A>As you will soon see, it's a much better idea to use JFFS2 rather than EXT2 to hold files on flash filesystem partitions.</P>
<P class=docText>The <SPAN class=docEmphasis>File Translation Layer</SPAN> (FTL) and the <SPAN class=docEmphasis>NAND File Translation Layer</SPAN> (NFTL) perform a transformation called <SPAN class=docEmphasis>wear leveling.</SPAN><A name="only a"></A> Flash memory sectors can withstand only a finite number of erase operations (in the order of 100,000). Wear leveling prolongs flash life by distributing memory usage across the chip. Both FTL and NFTL provide device interfaces similar to <SPAN class=docEmphasis>mtdblock</SPAN><A name="device nodes"></A> over which you can put normal filesystems. The corresponding device nodes are named <SPAN class=docEmphasis>/dev/nftl/X</SPAN>, where <SPAN class=docEmphasis>X</SPAN><A name="these modules"></A> is the partition number. Certain algorithms used in these modules are patented, so there could be restrictions on usage.</P><A name=ch17lev2sec3></A>
<H4 id=title-ID0ELDAO class=docSection2Title>Char Device Emulation</H4>
<P class=docText><A name=iddle1419></A><A name=iddle1422></A><A name=iddle1983></A><A name=iddle2062></A><A name=iddle2502></A><A name=iddle2505></A><A name=iddle3109></A><A name=iddle3111></A><A name=iddle4554></A><A name=iddle4556></A><A name=iddle4600></A><A name=iddle4609></A><A name="The mtdchar"></A>The mtdchar driver presents a linear view of the underlying flash device, rather than the block-oriented view required by filesystems. Device nodes created by mtdchar are named <SPAN class=docEmphasis>/dev/mtd/X</SPAN>, where <SPAN class=docEmphasis>X</SPAN><A name="partition number"></A> is the partition number. You may update the bootloader partition of the handheld as shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec3.html#ch17fig02">Figure 17.2</A><A name="the corresponding"></A>, by using dd over the corresponding mtdchar interface:</P>
<DIV class=docText><PRE><SPAN class=docEmphStrong>bash&gt; dd if=bootloader.bin of=/dev/mtd/0</SPAN></PRE></DIV><BR>
<P class=docText><A name="of a"></A>An example use of a raw mtdchar partition is to hold POST error logs generated by the bootloader on an embedded device. Another use of a char flash partition on an embedded system is to store information similar to that present in the CMOS or the EEPROM on PC-compatible systems. This includes the boot order, power-on password, and <SPAN class=docEmphasis>Vital Product Data</SPAN> (VPD) such as the device serial number and model number.</P><A name=ch17lev2sec4></A>
<H4 id=title-ID0EDIAO class=docSection2Title>JFFS2</H4>
<P class=docText><SPAN class=docEmphasis>Journaling Flash File System</SPAN><A name="is under"></A> (JFFS) is considered the best-suited filesystem for flash memory. Currently, version 2 (JFFS2) is in use, and JFFS3 is under development. JFFS was originally written for NOR flash chips, but support for NAND devices is merged with the 2.6 kernel.</P>
<P class=docText><A name="designed for"></A>Normal Linux filesystems are designed for desktop computers that are shut down gracefully. JFFS2 is designed for embedded systems where power failure can occur abruptly, and where the storage device can tolerate only a finite number of erases. During flash erase operations, current sector contents are saved in RAM. If there is a power loss during the slow erase process, entire contents of that sector can get lost. JFFS2 circumvents this problem using a log-structured design. New data is appended to a log that lives in an erased region. Each JFFS2 node contains metadata to track disjoint file locations. Memory is periodically reclaimed using garbage collection. Because of this design, flash writes do not have to go through a save-erase-write cycle, and this improves power-down reliability. The log-structure also increases flash life span by spreading out writes.</P>
<P class=docText><A name="living under"></A>To create a JFFS2 image of a tree living under <SPAN class=docEmphasis>/path/to/filesystem/</SPAN><A name="an erase"></A> on a flash chip having an erase size of 256KB, use <SPAN class=docEmphasis>mkfs.jffs2</SPAN> as follows:</P>
<DIV class=docText><PRE><SPAN class=docEmphStrong>bash&gt; mkfs.jffs2 -e 256KiB &#37413;&#25617; /path/to/filesystem/ -o jffs2.img</SPAN></PRE></DIV><BR>
<P class=docText><A name=iddle2073></A><A name=iddle2123></A><A name=iddle2125></A><A name=iddle3112></A><A name=iddle3114></A><A name=iddle3119></A><A name=iddle3364></A><A name=iddle4557></A><A name=iddle4559></A><A name=iddle4671></A>JFFS2 includes a <SPAN class=docEmphasis>garbage collector</SPAN><A name="in use"></A> (GC) that reclaims flash regions that are no longer in use. The garbage collection algorithm depends on the erase size, so supplying an accurate value makes it more efficient. To obtain the erase size of your flash partitions, you may seek the help of <SPAN class=docEmphasis>/proc/mtd.</SPAN><A name=in></A> The output for the Linux handheld shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch17lev1sec3.html#ch17fig02">Figure 17.2</A><A name="is as"></A> is as follows:</P>
<DIV class=docText><PRE><SPAN class=docEmphStrong>bash&gt; cat /proc/mtd</SPAN>
dev:    size    erasesize   name
mtd0: 00100000  00040000  "pda_btldr"
mtd1: 00200000  00040000  "pda_krnl"
mtd2: 01400000  00040000  "pda_fs"</PRE></DIV><BR>
<P class=docText><A name="appropriate options"></A>JFFS2 supports compression. Enable appropriate options under <TT>CONFIG_JFFS2_COMPRESSION_OPTIONS</TT><A name="look at"></A> to choose available compressors, and look at <SPAN class=docEmphasis>fs/jffs2/compr*.c</SPAN> for their implementations.</P>
<P class=docText><A name="images are"></A>Note that JFFS2 filesystem images are usually created on the host machine where you do cross-development and then transferred to the desired flash partition on the target device via a suitable download mechanism such as serial port, USB, or NFS. More on this in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch18.html#ch18">Chapter 18</A>, "Embedding Linux."</P><A name=ch17lev2sec5></A>
<H4 id=title-ID0ENNAO class=docSection2Title>YAFFS2</H4>
<P class=docText><A name="with the"></A>The implementation of JFFS2 in the 2.6 kernel includes features to work with the limitations of NAND flash, but <SPAN class=docEmphasis>Yet Another Flash File System</SPAN><A name="is designed"></A> (YAFFS) is a filesystem that is designed to function under constraints specific to NAND memory. YAFFS is not part of the mainline kernel, but some embedded distributions prepatch their kernels with support for YAFFS2, the current version of YAFFS.</P>
<P class=docText><A name=from></A>You can download YAFFS2 source code and documentation from <A class=docLink href="http://www.yaffs.net/" target=_blank>www.yaffs.net</A>.