This notification is done through a kobject's release() method. Usually<BR>such a method has a form like: 
<P></P>
<P><FONT class=clozed>&nbsp;&nbsp;&nbsp; void my_object_release(struct kobject *kobj)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct my_object *mine = container_of(kobj, struct my_object, kobj);</FONT></P>
<P><FONT class=clozed>&nbsp;&nbsp;&nbsp;&nbsp; /* Perform any additional cleanup on this object, then... */<BR>&nbsp;&nbsp;&nbsp;&nbsp; kfree(mine);<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=clozed>One important point cannot be overstated: every kobject must have a<BR>release() method, and the kobject must persist (in a consistent state)<BR>until that method is called. If these constraints are not met, the code is<BR>flawed.&nbsp; Note that the kernel will warn you if you forget to provide a<BR>release() method.&nbsp; Do not try to get rid of this warning by providing an<BR>"empty" release function; you will be mocked mercilessly by the kobject<BR>maintainer if you attempt this.</FONT>