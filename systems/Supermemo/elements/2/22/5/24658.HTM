ksets 
<P></P>
<P>A kset is merely a collection of kobjects that want to be associated with<BR>each other.&nbsp; There is no restriction that they be of the same ktype, but be<BR>very careful if they are not.</P>
<P>A kset serves these functions:</P>
<P>&nbsp;- It serves as a bag containing a group of objects. A kset can be used by<BR>&nbsp;&nbsp; the kernel to track "all block devices" or "all PCI device drivers."</P>
<P>&nbsp;- <FONT class=extract>A kset is also a subdirectory in sysfs, where the associated kobjects<BR>&nbsp;&nbsp; with the kset can show up.&nbsp; Every kset contains a kobject which can be<BR>&nbsp;&nbsp; set up to be the parent of other kobjects; the top-level directories of<BR>&nbsp;&nbsp; the sysfs hierarchy are constructed in this way.</FONT></P>
<P>&nbsp;- Ksets can support the "hotplugging" of kobjects and influence how<BR>&nbsp;&nbsp; uevent events are reported to user space.</P>
<P><FONT class=extract>In object-oriented terms, "kset" is the top-level container class; ksets<BR>contain their own kobject, but that kobject is managed by the kset code and<BR>should not be manipulated by any other user.</FONT></P>
<P><FONT class=extract>A kset keeps its children in a standard kernel linked list.&nbsp; Kobjects point<BR>back to their containing kset via their kset field. In almost all cases,<BR>the kobjects belonging to a kset have that kset (or, strictly, its embedded<BR>kobject) in their parent.</FONT></P>
<P><FONT class=extract>As a kset contains a kobject within it, it should always be dynamically<BR>created and never declared statically or on the stack.&nbsp; To create a new<BR>kset use:<BR>&nbsp; struct kset *kset_create_and_add(const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct kset_uevent_ops *u,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct kobject *parent);</FONT></P>
<P><FONT class=extract>When you are finished with the kset, call:<BR>&nbsp; void kset_unregister(struct kset *kset);<BR>to destroy it.</FONT></P>
<P>An example of using a kset can be seen in the<BR>samples/kobject/kset-example.c file in the kernel tree.</P>
<P>If a kset wishes to control the uevent operations of the kobjects<BR>associated with it, it can use the struct kset_uevent_ops to handle it:</P>
<P>struct kset_uevent_ops {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*filter)(struct kset *kset, struct kobject *kobj);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *(*name)(struct kset *kset, struct kobject *kobj);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*uevent)(struct kset *kset, struct kobject *kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct kobj_uevent_env *env);<BR>};</P>
<P><BR>The filter function allows a kset to prevent a uevent from being emitted to<BR>userspace for a specific kobject.&nbsp; If the function returns 0, the uevent<BR>will not be emitted.</P>
<P>The name function will be called to override the default name of the kset<BR>that the uevent sends to userspace.&nbsp; By default, the name will be the same<BR>as the kset itself, but this function, if present, can override that name.</P>
<P>The uevent function will be called when the uevent is about to be sent to<BR>userspace to allow more environment variables to be added to the uevent.</P>
<P>One might ask how, exactly, a kobject is added to a kset, given that no<BR>functions which perform that function have been presented.&nbsp; The answer is<BR>that this task is handled by kobject_add().&nbsp; When a kobject is passed to<BR>kobject_add(), its kset member should point to the kset to which the<BR>kobject will belong.&nbsp; kobject_add() will handle the rest.</P>
<P>If the kobject belonging to a kset has no parent kobject set, it will be<BR>added to the kset's directory.&nbsp; Not all members of a kset do necessarily<BR>live in the kset directory.&nbsp; If an explicit parent kobject is assigned<BR>before the kobject is added, the kobject is registered with the kset, but<BR>added below the parent kobject.