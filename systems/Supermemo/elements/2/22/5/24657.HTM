ktypes and release methods 
<P></P>
<P>One important thing still missing from the discussion is what happens to a<BR>kobject when its reference count reaches zero. The code which created the<BR>kobject generally does not know when that will happen; if it did, there<BR>would be little point in using a kobject in the first place. Even<BR>predictable object lifecycles become more complicated when sysfs is brought<BR>in as other portions of the kernel can get a reference on any kobject that<BR>is registered in the system.</P>
<P>The end result is that a structure protected by a kobject cannot be freed<BR>before its reference count goes to zero. The reference count is not under<BR>the direct control of the code which created the kobject. So that code must<BR>be notified asynchronously whenever the last reference to one of its<BR>kobjects goes away.</P>
<P><FONT class=extract>Once you registered your kobject via kobject_add(), you must never use<BR>kfree() to free it directly. The only safe way is to use kobject_put(). It<BR>is good practice to always use kobject_put() after kobject_init() to avoid<BR>errors creeping in.</FONT></P>
<P><FONT class=extract>This notification is done through a kobject's release() method. Usually<BR>such a method has a form like:</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; void my_object_release(struct kobject *kobj)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; struct my_object *mine = container_of(kobj, struct my_object, kobj);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;&nbsp; /* Perform any additional cleanup on this object, then... */<BR>&nbsp;&nbsp;&nbsp;&nbsp; kfree(mine);<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>One important point cannot be overstated: every kobject must have a<BR>release() method, and the kobject must persist (in a consistent state)<BR>until that method is called. If these constraints are not met, the code is<BR>flawed.&nbsp; Note that the kernel will warn you if you forget to provide a<BR>release() method.&nbsp; Do not try to get rid of this warning by providing an<BR>"empty" release function; you will be mocked mercilessly by the kobject<BR>maintainer if you attempt this.</FONT></P>
<P><FONT class=extract>Note, the name of the kobject is available in the release function, but it<BR>must NOT be changed within this callback.&nbsp; Otherwise there will be a memory<BR>leak in the kobject core, which makes people unhappy.</FONT></P>
<P><FONT class=extract>Interestingly, the release() method is not stored in the kobject itself;<BR>instead, it is associated with the ktype.</FONT> So <FONT class=extract>let us introduce struct<BR>kobj_type:</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; struct kobj_type {<BR>&nbsp;&nbsp;&nbsp;&nbsp; void (*release)(struct kobject *kobj);<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct sysfs_ops *sysfs_ops;<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct attribute **default_attrs;<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj);<BR>&nbsp;&nbsp;&nbsp;&nbsp; const void *(*namespace)(struct kobject *kobj);<BR>&nbsp;&nbsp;&nbsp; };</FONT></P>
<P><FONT class=extract>This structure is used to describe a particular type of kobject (or, more<BR>correctly, of containing object). Every kobject needs to have an associated<BR>kobj_type structure; a pointer to that structure must be specified when you<BR>call kobject_init() or kobject_init_and_add().</FONT></P>
<P><FONT class=extract>The release field in struct kobj_type is, of course, a pointer to the<BR>release() method for this type of kobject. The other two fields (sysfs_ops<BR>and default_attrs) control how objects of this type are represented in<BR>sysfs; they are beyond the scope of this document.</FONT></P>
<P><FONT class=extract>The default_attrs pointer is a list of default attributes that will be<BR>automatically created for any kobject that is registered with this ktype.</FONT>