<FONT class=extract>Reference counts</FONT> 
<P></P>
<P><FONT class=extract>One of the key functions of a kobject is to serve as a reference counter<BR>for the object in which it is embedded. As long as references to the object<BR>exist, the object (and the code which supports it) must continue to exist.<BR>The low-level functions for manipulating a kobject's reference counts are:</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; struct kobject *kobject_get(struct kobject *kobj);<BR>&nbsp;&nbsp;&nbsp; void kobject_put(struct kobject *kobj);</FONT></P>
<P><FONT class=extract>A successful call to kobject_get() will increment the kobject's reference<BR>counter and return the pointer to the kobject.</FONT></P>
<P><FONT class=extract>When a reference is released, the call to kobject_put() will decrement the<BR>reference count and, possibly, free the object.</FONT> <FONT class=extract>Note that kobject_init()<BR>sets the reference count to one, so the code which sets up the kobject will<BR>need to do a kobject_put() eventually to release that reference.</FONT></P>
<P><FONT class=extract>Because kobjects are dynamic, they must not be declared statically or on<BR>the stack, but instead, always allocated dynamically.&nbsp; Future versions of<BR>the kernel will contain a run-time check for kobjects that are created<BR>statically and will warn the developer of this improper usage.</FONT></P>
<P><FONT class=extract>If all that you want to use a kobject for is to provide a reference counter<BR>for your structure, please use the struct kref instead; a kobject would be<BR>overkill.&nbsp; For more information on how to use struct kref, please see the<BR>file Documentation/kref.txt in the Linux kernel source tree.</FONT>