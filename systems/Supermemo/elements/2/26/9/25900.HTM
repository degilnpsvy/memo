<H2>Device Tree&#65288;&#19977;&#65289;&#65306;&#20195;&#30721;&#20998;&#26512;</H2>
<P class=date>&#20316;&#32773;&#65306;<A href="http://www.wowotech.net/author/3">linuxer</A> &#21457;&#24067;&#20110;&#65306;2014-6-6 16:03 &#20998;&#31867;&#65306;<A href="http://www.wowotech.net/sort/device_model">&#32479;&#19968;&#35774;&#22791;&#27169;&#22411;</A> </P>
<P>&#19968;&#12289;&#21069;&#35328; </P>
<P>Device Tree&#24635;&#20849;&#26377;&#19977;&#31687;&#65292;&#20998;&#21035;&#26159;&#65306; </P>
<P>1&#12289;&#20026;&#20309;&#35201;&#24341;&#20837;Device Tree&#65292;&#36825;&#20010;&#26426;&#21046;&#26159;&#29992;&#26469;&#35299;&#20915;&#20160;&#20040;&#38382;&#39064;&#30340;&#65311;&#65288;&#35831;&#21442;&#32771;<A href="http://www.wowotech.net/linux_kenrel/why-dt.html">&#24341;&#20837;Device Tree&#30340;&#21407;&#22240;</A>&#65289; </P>
<P>2&#12289;Device Tree&#30340;&#22522;&#30784;&#27010;&#24565;&#65288;&#35831;&#21442;&#32771;<A href="http://www.wowotech.net/linux_kenrel/dt_basic_concept.html">DT&#22522;&#30784;&#27010;&#24565;</A>&#65289; </P>
<P>3&#12289;ARM linux&#20013;&#21644;Device Tree&#30456;&#20851;&#30340;&#20195;&#30721;&#20998;&#26512;&#65288;&#36825;&#26159;&#26412;&#25991;&#30340;&#20027;&#39064;&#65289; </P>
<P>&#26412;&#25991;&#20027;&#35201;&#20869;&#23481;&#26159;&#65306;&#20197;Device Tree&#30456;&#20851;&#30340;&#25968;&#25454;&#27969;&#20998;&#26512;&#20026;&#32034;&#24341;&#65292;&#23545;ARM linux kernel&#30340;&#20195;&#30721;&#36827;&#34892;&#35299;&#26512;&#12290;&#20027;&#35201;&#30340;&#25968;&#25454;&#27969;&#21253;&#25324;&#65306; </P>
<P>1&#12289;&#21021;&#22987;&#21270;&#27969;&#31243;&#12290;&#20063;&#23601;&#26159;&#25195;&#25551;dtb&#24182;&#23558;&#20854;&#36716;&#25442;&#25104;Device Tree Structure&#12290; </P>
<P>2&#12289;&#20256;&#36882;&#36816;&#34892;&#26102;&#21442;&#25968;&#20256;&#36882;&#20197;&#21450;platform&#30340;&#35782;&#21035;&#27969;&#31243;&#20998;&#26512; </P>
<P>3&#12289;&#22914;&#20309;&#23558;Device Tree Structure&#24182;&#20837;linux kernel&#30340;&#35774;&#22791;&#39537;&#21160;&#27169;&#22411;&#12290; </P>
<P>&#27880;&#65306;&#26412;&#25991;&#20013;&#30340;linux kernel&#20351;&#29992;&#30340;&#26159;3.14&#29256;&#26412;&#12290; </P>
<P>&nbsp; </P>
<P>&#20108;&#12289;&#22914;&#20309;&#36890;&#36807;Device Tree&#23436;&#25104;&#36816;&#34892;&#26102;&#21442;&#25968;&#20256;&#36882;&#20197;&#21450;platform&#30340;&#35782;&#21035;&#21151;&#33021;&#65311; </P>
<P>1&#12289;&#27719;&#32534;&#37096;&#20998;&#30340;&#20195;&#30721;&#20998;&#26512; </P>
<P>linux/arch/arm/kernel/head.S&#25991;&#20214;&#23450;&#20041;&#20102;bootloader&#21644;kernel&#30340;&#21442;&#25968;&#20256;&#36882;&#35201;&#27714;&#65306; </P>
<BLOCKQUOTE>
<P>MMU = off, D-cache = off, I-cache = dont care, r0 = 0, r1 = machine nr, r2 = atags or dtb pointer. </P></BLOCKQUOTE>
<P>&#30446;&#21069;&#30340;kernel&#25903;&#25345;&#26087;&#30340;tag list&#30340;&#26041;&#24335;&#65292;&#21516;&#26102;&#20063;&#25903;&#25345;device tree&#30340;&#26041;&#24335;&#12290;r2&#21487;&#33021;&#26159;device tree binary file&#30340;&#25351;&#38024;&#65288;bootloader&#35201;&#20256;&#36882;&#32473;&#20869;&#26680;&#20043;&#21069;&#35201;copy&#21040;memory&#20013;&#65289;&#65292;&#20063;&#21487;&#20197;&#33021;&#26159;tag list&#30340;&#25351;&#38024;&#12290;&#22312;ARM&#30340;&#27719;&#32534;&#37096;&#20998;&#30340;&#21551;&#21160;&#20195;&#30721;&#20013;&#65288;&#20027;&#35201;&#26159;head.S&#21644;head-common.S&#65289;&#65292;machine type ID&#21644;&#25351;&#21521;DTB&#25110;&#32773;atags&#30340;&#25351;&#38024;&#34987;&#20445;&#23384;&#22312;&#21464;&#37327;__machine_arch_type&#21644;__atags_pointer&#20013;&#65292;&#36825;&#20040;&#20570;&#26159;&#20026;&#20102;&#21518;&#32493;c&#20195;&#30721;&#36827;&#34892;&#22788;&#29702;&#12290; </P>
<P>2&#12289;&#21644;device tree&#30456;&#20851;&#30340;setup_arch&#20195;&#30721;&#20998;&#26512; </P>
<P>&#20855;&#20307;&#30340;c&#20195;&#30721;&#37117;&#26159;&#22312;setup_arch&#20013;&#22788;&#29702;&#65292;&#36825;&#20010;&#20989;&#25968;&#26159;&#19968;&#20010;&#24635;&#30340;&#20837;&#21475;&#28857;&#12290;&#20855;&#20307;&#20195;&#30721;&#22914;&#19979;&#65288;&#21024;&#38500;&#20102;&#37096;&#20998;&#26080;&#20851;&#20195;&#30721;&#65289;&#65306; </P>
<BLOCKQUOTE>
<P>void __init setup_arch(char **cmdline_p) <BR>{ <BR>&nbsp;&nbsp;&nbsp; const struct machine_desc *mdesc; </P>
<P>&#8230;&#8230; </P>
<P>&nbsp;&nbsp;&nbsp; mdesc = setup_machine_fdt(__atags_pointer); <BR>&nbsp;&nbsp;&nbsp; if (!mdesc) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type); <BR>&nbsp;&nbsp;&nbsp; machine_desc = mdesc; <BR>&nbsp;&nbsp;&nbsp; machine_name = mdesc-&gt;name; </P>
<P>&#8230;&#8230; <BR>} </P></BLOCKQUOTE>
<P>&#23545;&#20110;&#22914;&#20309;&#30830;&#23450;HW platform&#36825;&#20010;&#38382;&#39064;&#65292;&#26087;&#30340;&#26041;&#27861;&#26159;&#38745;&#24577;&#23450;&#20041;&#33509;&#24178;&#30340;machine&#25551;&#36848;&#31526;&#65288;struct machine_desc &#65289;&#65292;&#22312;&#21551;&#21160;&#36807;&#31243;&#20013;&#65292;&#36890;&#36807;machine type ID&#20316;&#20026;&#32034;&#24341;&#65292;&#22312;&#36825;&#20123;&#38745;&#24577;&#23450;&#20041;&#30340;machine&#25551;&#36848;&#31526;&#20013;&#25195;&#25551;&#65292;&#25214;&#21040;&#37027;&#20010;ID&#21305;&#37197;&#30340;&#25551;&#36848;&#31526;&#12290;&#22312;&#26032;&#30340;&#20869;&#26680;&#20013;&#65292;&#39318;&#20808;&#20351;&#29992;setup_machine_fdt&#26469;setup machine&#25551;&#36848;&#31526;&#65292;&#22914;&#26524;&#36820;&#22238;NULL&#65292;&#25165;&#20351;&#29992;&#20256;&#32479;&#30340;&#26041;&#27861;setup_machine_tags&#26469;setup machine&#25551;&#36848;&#31526;&#12290;&#20256;&#32479;&#30340;&#26041;&#27861;&#38656;&#35201;&#32473;&#20986;__machine_arch_type&#65288;bootloader&#36890;&#36807;r1&#23492;&#23384;&#22120;&#20256;&#36882;&#32473;kernel&#30340;&#65289;&#21644;tag list&#30340;&#22320;&#22336;&#65288;&#29992;&#26469;&#36827;&#34892;tag parse&#65289;&#12290;__machine_arch_type&#29992;&#26469;&#23547;&#25214;machine&#25551;&#36848;&#31526;&#65307;tag list&#29992;&#20110;&#36816;&#34892;&#26102;&#21442;&#25968;&#30340;&#20256;&#36882;&#12290;&#38543;&#30528;&#20869;&#26680;&#30340;&#19981;&#26029;&#21457;&#23637;&#65292;&#30456;&#20449;&#26377;&#19968;&#22825;linux kernel&#20250;&#23436;&#20840;&#25243;&#24323;tag list&#30340;&#26426;&#21046;&#12290; </P>
<P>3&#12289;&#21305;&#37197;platform&#65288;machine&#25551;&#36848;&#31526;&#65289; </P>
<P>setup_machine_fdt&#20989;&#25968;&#30340;&#21151;&#33021;&#23601;&#26159;&#26681;&#25454;Device Tree&#30340;&#20449;&#24687;&#65292;&#25214;&#21040;&#26368;&#36866;&#21512;&#30340;machine&#25551;&#36848;&#31526;&#12290;&#20855;&#20307;&#20195;&#30721;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys) <BR>{ <BR>&nbsp;&nbsp;&nbsp; const struct machine_desc *mdesc, *mdesc_best = NULL; </P>
<P>&nbsp;&nbsp;&nbsp; if (!dt_phys || !early_init_dt_scan(phys_to_virt(dt_phys))) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL; </P>
<P>&nbsp;&nbsp;&nbsp; mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach); </P>
<P>&nbsp;&nbsp;&nbsp; if (!mdesc) {&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#20986;&#38169;&#22788;&#29702; <BR>&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp; /* Change machine number to match the mdesc we're using */ <BR>&nbsp;&nbsp;&nbsp; __machine_arch_type = mdesc-&gt;nr; </P>
<P>&nbsp;&nbsp;&nbsp; return mdesc; <BR>} </P></BLOCKQUOTE>
<P>early_init_dt_scan&#20989;&#25968;&#26377;&#20004;&#20010;&#21151;&#33021;&#65292;&#19968;&#20010;&#26159;&#20026;&#21518;&#32493;&#30340;DTB scan&#36827;&#34892;&#20934;&#22791;&#24037;&#20316;&#65292;&#21478;&#22806;&#19968;&#20010;&#26159;&#36816;&#34892;&#26102;&#21442;&#25968;&#20256;&#36882;&#12290;&#20855;&#20307;&#35831;&#21442;&#32771;&#19979;&#38754;&#19968;&#20010;section&#30340;&#25551;&#36848;&#12290; </P>
<P>of_flat_dt_match_machine&#26159;&#22312;machine&#25551;&#36848;&#31526;&#30340;&#21015;&#34920;&#20013;scan&#65292;&#25214;&#21040;&#26368;&#21512;&#36866;&#30340;&#37027;&#20010;machine&#25551;&#36848;&#31526;&#12290;&#25105;&#20204;&#39318;&#20808;&#30475;&#22914;&#20309;&#32452;&#25104;machine&#25551;&#36848;&#31526;&#30340;&#21015;&#34920;&#12290;&#21644;&#20256;&#32479;&#30340;&#26041;&#27861;&#31867;&#20284;&#65292;&#20063;&#26159;&#38745;&#24577;&#23450;&#20041;&#30340;&#12290;DT_MACHINE_START&#21644;MACHINE_END&#29992;&#26469;&#23450;&#20041;&#19968;&#20010;machine&#25551;&#36848;&#31526;&#12290;&#32534;&#35793;&#30340;&#26102;&#20505;&#65292;compiler&#20250;&#25226;&#36825;&#20123;machine descriptor&#25918;&#21040;&#19968;&#20010;&#29305;&#27530;&#30340;&#27573;&#20013;&#65288;.arch.info.init&#65289;&#65292;&#24418;&#25104;machine&#25551;&#36848;&#31526;&#30340;&#21015;&#34920;&#12290;machine&#25551;&#36848;&#31526;&#29992;&#19979;&#38754;&#30340;&#25968;&#25454;&#32467;&#26500;&#26469;&#26631;&#35782;&#65288;&#21024;&#38500;&#20102;&#19981;&#30456;&#20851;&#30340;member&#65289;&#65306; </P>
<BLOCKQUOTE>
<P>struct machine_desc { <BR>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* architecture number&nbsp;&nbsp;&nbsp; */ <BR>&nbsp;&nbsp;&nbsp; const char *const&nbsp;&nbsp;&nbsp;&nbsp; *dt_compat;&nbsp;&nbsp;&nbsp; /* array of device tree 'compatible' strings&nbsp;&nbsp;&nbsp; */ </P>
<P>&#8230;&#8230; </P>
<P>&nbsp;&nbsp; }; </P></BLOCKQUOTE>
<P>nr&#25104;&#21592;&#23601;&#26159;&#36807;&#21435;&#20351;&#29992;&#30340;machine type ID&#12290;&#20869;&#26680;machine&#25551;&#36848;&#31526;&#30340;table&#26377;&#33509;&#24178;&#20010;entry&#65292;&#27599;&#20010;&#37117;&#26377;&#33258;&#24049;&#30340;ID&#12290;bootloader&#20256;&#36882;&#20102;machine type ID&#65292;&#25351;&#26126;&#20351;&#29992;&#21738;&#19968;&#20010;machine&#25551;&#36848;&#31526;&#12290;&#30446;&#21069;&#21305;&#37197;machine&#25551;&#36848;&#31526;&#20351;&#29992;compatible strings&#65292;&#20063;&#23601;&#26159;dt_compat&#25104;&#21592;&#65292;&#36825;&#26159;&#19968;&#20010;string list&#65292;&#23450;&#20041;&#20102;&#36825;&#20010;machine&#25152;&#25903;&#25345;&#30340;&#21015;&#34920;&#12290;&#22312;&#25195;&#25551;machine&#25551;&#36848;&#31526;&#21015;&#34920;&#30340;&#26102;&#20505;&#38656;&#35201;&#19981;&#26029;&#30340;&#33719;&#21462;&#19979;&#19968;&#20010;machine&#25551;&#36848;&#31526;&#30340;compatible&#23383;&#31526;&#20018;&#30340;&#20449;&#24687;&#65292;&#20855;&#20307;&#30340;&#20195;&#30721;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>static const void * __init arch_get_next_mach(const char *const **match) <BR>{ <BR>&nbsp;&nbsp;&nbsp; static const struct machine_desc *mdesc = __arch_info_begin; <BR>&nbsp;&nbsp;&nbsp; const struct machine_desc *m = mdesc; </P>
<P>&nbsp;&nbsp;&nbsp; if (m &gt;= __arch_info_end) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL; </P>
<P>&nbsp;&nbsp;&nbsp; mdesc++; <BR>&nbsp;&nbsp;&nbsp; *match = m-&gt;dt_compat; <BR>&nbsp;&nbsp;&nbsp; return m; <BR>} </P></BLOCKQUOTE>
<P>__arch_info_begin&#25351;&#21521;machine&#25551;&#36848;&#31526;&#21015;&#34920;&#31532;&#19968;&#20010;entry&#12290;&#36890;&#36807;mdesc++&#19981;&#26029;&#30340;&#31227;&#21160;machine&#25551;&#36848;&#31526;&#25351;&#38024;&#65288;Note&#65306;mdesc&#26159;static&#30340;&#65289;&#12290;match&#36820;&#22238;&#20102;&#35813;machine&#25551;&#36848;&#31526;&#30340;compatible string list&#12290;&#20855;&#20307;&#21305;&#37197;&#30340;&#31639;&#27861;&#20498;&#26159;&#24456;&#31616;&#21333;&#65292;&#23601;&#26159;&#27604;&#36739;&#23383;&#31526;&#20018;&#32780;&#24050;&#65292;&#19968;&#20010;&#26159;root node&#30340;compatible&#23383;&#31526;&#20018;&#21015;&#34920;&#65292;&#19968;&#20010;&#26159;machine&#25551;&#36848;&#31526;&#30340;compatible&#23383;&#31526;&#20018;&#21015;&#34920;&#65292;&#24471;&#20998;&#26368;&#20302;&#30340;&#65288;&#26368;&#21305;&#37197;&#30340;&#65289;&#23601;&#26159;&#25105;&#20204;&#26368;&#32456;&#36873;&#23450;&#30340;machine type&#12290; </P>
<P>4&#12289;&#36816;&#34892;&#26102;&#21442;&#25968;&#20256;&#36882; </P>
<P>&#36816;&#34892;&#26102;&#21442;&#25968;&#26159;&#22312;&#25195;&#25551;DTB&#30340;chosen node&#26102;&#20505;&#23436;&#25104;&#30340;&#65292;&#20855;&#20307;&#30340;&#21160;&#20316;&#23601;&#26159;&#33719;&#21462;chosen node&#30340;bootargs&#12289;initrd&#31561;&#23646;&#24615;&#30340;value&#65292;&#24182;&#23558;&#20854;&#20445;&#23384;&#22312;&#20840;&#23616;&#21464;&#37327;&#65288;boot_command_line&#65292;initrd_start&#12289;initrd_end&#65289;&#20013;&#12290;&#20351;&#29992;tag list&#26041;&#27861;&#26159;&#31867;&#20284;&#30340;&#65292;&#36890;&#36807;&#20998;&#26512;tag list&#65292;&#33719;&#21462;&#30456;&#20851;&#20449;&#24687;&#65292;&#20445;&#23384;&#22312;&#21516;&#26679;&#30340;&#20840;&#23616;&#21464;&#37327;&#20013;&#12290;&#20855;&#20307;&#20195;&#30721;&#20301;&#20110;early_init_dt_scan&#20989;&#25968;&#20013;&#65306; </P>
<BLOCKQUOTE>
<P>bool __init early_init_dt_scan(void *params) <BR>{ <BR>&nbsp;&nbsp;&nbsp; if (!params) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; </P>
<P>&nbsp;&nbsp;&nbsp; /* &#20840;&#23616;&#21464;&#37327;initial_boot_params&#25351;&#21521;&#20102;DTB&#30340;header*/ <BR>&nbsp;&nbsp;&nbsp; initial_boot_params = params; </P>
<P>&nbsp;&nbsp;&nbsp; /* &#26816;&#26597;DTB&#30340;magic&#65292;&#30830;&#35748;&#26159;&#19968;&#20010;&#26377;&#25928;&#30340;DTB */ <BR>&nbsp;&nbsp;&nbsp; if (be32_to_cpu(initial_boot_params-&gt;magic) != OF_DT_HEADER) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initial_boot_params = NULL; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false; <BR>&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp; /* &#25195;&#25551; /chosen node&#65292;&#20445;&#23384;&#36816;&#34892;&#26102;&#21442;&#25968;&#65288;bootargs&#65289;&#21040;boot_command_line&#65292;&#27492;&#22806;&#65292;&#36824;&#22788;&#29702;initrd&#30456;&#20851;&#30340;property&#65292;&#24182;&#20445;&#23384;&#22312;initrd_start&#21644;initrd_end&#36825;&#20004;&#20010;&#20840;&#23616;&#21464;&#37327;&#20013; */ <BR>&nbsp;&nbsp;&nbsp; of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line); </P>
<P>&nbsp;&nbsp;&nbsp; /* &#25195;&#25551;&#26681;&#33410;&#28857;&#65292;&#33719;&#21462; {size,address}-cells&#20449;&#24687;&#65292;&#24182;&#20445;&#23384;&#22312;dt_root_size_cells&#21644;dt_root_addr_cells&#20840;&#23616;&#21464;&#37327;&#20013; */ <BR>&nbsp;&nbsp;&nbsp; of_scan_flat_dt(early_init_dt_scan_root, NULL); </P>
<P>&nbsp;&nbsp;&nbsp; /* &#25195;&#25551;DTB&#20013;&#30340;memory node&#65292;&#24182;&#25226;&#30456;&#20851;&#20449;&#24687;&#20445;&#23384;&#22312;meminfo&#20013;&#65292;&#20840;&#23616;&#21464;&#37327;meminfo&#20445;&#23384;&#20102;&#31995;&#32479;&#20869;&#23384;&#30456;&#20851;&#30340;&#20449;&#24687;&#12290;*/ <BR>&nbsp;&nbsp;&nbsp; of_scan_flat_dt(early_init_dt_scan_memory, NULL); </P>
<P>&nbsp;&nbsp;&nbsp; return true; <BR>} </P></BLOCKQUOTE>
<P>&#35774;&#23450;meminfo&#65288;&#35813;&#20840;&#23616;&#21464;&#37327;&#30830;&#23450;&#20102;&#29289;&#29702;&#20869;&#23384;&#30340;&#24067;&#23616;&#65289;&#26377;&#33509;&#24178;&#31181;&#36884;&#24452;&#65306; </P>
<P>1&#12289;&#36890;&#36807;tag list&#65288;tag&#26159;ATAG_MEM&#65289;&#20256;&#36882;memory bank&#30340;&#20449;&#24687;&#12290; </P>
<P>2&#12289;&#36890;&#36807;command line&#65288;&#21487;&#20197;&#29992;tag list&#65292;&#20063;&#21487;&#20197;&#36890;&#36807;DTB&#65289;&#20256;&#36882;memory bank&#30340;&#20449;&#24687;&#12290; </P>
<P>3&#12289;&#36890;&#36807;DTB&#30340;memory node&#20256;&#36882;memory bank&#30340;&#20449;&#24687;&#12290; </P>
<P>&#30446;&#21069;&#24403;&#28982;&#26159;&#25512;&#33616;&#20351;&#29992;Device Tree&#30340;&#26041;&#24335;&#26469;&#20256;&#36882;&#29289;&#29702;&#20869;&#23384;&#24067;&#23616;&#20449;&#24687;&#12290; </P>
<P>&nbsp; </P>
<P>&#19977;&#12289;&#21021;&#22987;&#21270;&#27969;&#31243; </P>
<P>&#22312;&#31995;&#32479;&#21021;&#22987;&#21270;&#30340;&#36807;&#31243;&#20013;&#65292;&#25105;&#20204;&#38656;&#35201;&#23558;DTB&#36716;&#25442;&#25104;&#33410;&#28857;&#26159;device_node&#30340;&#26641;&#29366;&#32467;&#26500;&#65292;&#20197;&#20415;&#21518;&#32493;&#26041;&#20415;&#25805;&#20316;&#12290;&#20855;&#20307;&#30340;&#20195;&#30721;&#20301;&#20110;setup_arch-&gt;unflatten_device_tree&#20013;&#12290; </P>
<BLOCKQUOTE>
<P>void __init unflatten_device_tree(void) <BR>{ <BR>&nbsp;&nbsp;&nbsp; __unflatten_device_tree(initial_boot_params, &amp;of_allnodes, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; early_init_dt_alloc_memory_arch); </P>
<P>&nbsp;&nbsp;&nbsp; /* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */ <BR>&nbsp;&nbsp;&nbsp; of_alias_scan(early_init_dt_alloc_memory_arch); <BR>} </P></BLOCKQUOTE>
<P>&#25105;&#20204;&#29992;struct device_node &#26469;&#25277;&#35937;&#35774;&#22791;&#26641;&#20013;&#30340;&#19968;&#20010;&#33410;&#28857;&#65292;&#20855;&#20307;&#35299;&#37322;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>struct device_node { <BR>&nbsp;&nbsp;&nbsp; const char *name;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;device node name <BR>&nbsp;&nbsp;&nbsp; const char *type;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#23545;&#24212;device_type&#30340;&#23646;&#24615; <BR>&nbsp;&nbsp;&nbsp; phandle phandle;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#23545;&#24212;&#35813;&#33410;&#28857;&#30340;phandle&#23646;&#24615; <BR>&nbsp;&nbsp;&nbsp; const char *full_name; &#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#20174;&#8220;/&#8221;&#24320;&#22987;&#30340;&#65292;&#34920;&#31034;&#35813;node&#30340;full path </P>
<P>&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; property *properties;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#35813;&#33410;&#28857;&#30340;&#23646;&#24615;&#21015;&#34920; <BR>&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; property *deadprops; &#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#22914;&#26524;&#38656;&#35201;&#21024;&#38500;&#26576;&#20123;&#23646;&#24615;&#65292;kernel&#24182;&#38750;&#30495;&#30340;&#21024;&#38500;&#65292;&#32780;&#26159;&#25346;&#20837;&#21040;deadprops&#30340;&#21015;&#34920; <BR>&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; device_node *parent;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;parent&#12289;child&#20197;&#21450;sibling&#23558;&#25152;&#26377;&#30340;device node&#36830;&#25509;&#36215;&#26469; <BR>&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; device_node *child; <BR>&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; device_node *sibling; <BR>&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; device_node *next;&nbsp; &#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#36890;&#36807;&#35813;&#25351;&#38024;&#21487;&#20197;&#33719;&#21462;&#30456;&#21516;&#31867;&#22411;&#30340;&#19979;&#19968;&#20010;node <BR>&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; device_node *allnext;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#36890;&#36807;&#35813;&#25351;&#38024;&#21487;&#20197;&#33719;&#21462;node global list&#19979;&#19968;&#20010;node <BR>&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; proc_dir_entry *pde;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#24320;&#25918;&#21040;userspace&#30340;proc&#25509;&#21475;&#20449;&#24687; <BR>&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; kref kref;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#35813;node&#30340;reference count <BR>&nbsp;&nbsp;&nbsp; unsigned long _flags; <BR>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; *data; <BR>}; </P></BLOCKQUOTE>
<P>unflatten_device_tree&#20989;&#25968;&#30340;&#20027;&#35201;&#21151;&#33021;&#23601;&#26159;&#25195;&#25551;DTB&#65292;&#23558;device node&#34987;&#32452;&#32455;&#25104;&#65306; </P>
<P>1&#12289;global list&#12290;&#20840;&#23616;&#21464;&#37327;struct device_node *of_allnodes&#23601;&#26159;&#25351;&#21521;&#35774;&#22791;&#26641;&#30340;global list </P>
<P>2&#12289;tree&#12290; </P>
<P>&#36825;&#20123;&#21151;&#33021;&#20027;&#35201;&#26159;&#22312;__unflatten_device_tree&#20989;&#25968;&#20013;&#23454;&#29616;&#65292;&#20855;&#20307;&#20195;&#30721;&#22914;&#19979;&#65288;&#21435;&#25481;&#19968;&#20123;&#26080;&#20851;&#32039;&#35201;&#30340;&#20195;&#30721;&#65289;&#65306; </P>
<BLOCKQUOTE>
<P>static void __unflatten_device_tree(struct boot_param_header *blob,&#65293;&#65293;&#65293;&#38656;&#35201;&#25195;&#25551;&#30340;DTB <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device_node **mynodes,&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;global list&#25351;&#38024; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void * (*dt_alloc)(u64 size, u64 align))&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#20869;&#23384;&#20998;&#37197;&#20989;&#25968; <BR>{ <BR>&nbsp;&nbsp;&nbsp; unsigned long size; <BR>&nbsp;&nbsp;&nbsp; void *start, *mem; <BR>&nbsp;&nbsp;&nbsp; struct device_node **allnextp = mynodes; </P>
<P>&nbsp;&nbsp;&nbsp; &#27492;&#22788;&#21024;&#38500;&#20102;health check&#20195;&#30721;&#65292;&#20363;&#22914;&#26816;&#26597;DTB header&#30340;magic&#65292;&#30830;&#35748;blob&#30340;&#30830;&#25351;&#21521;&#19968;&#20010;DTB&#12290; </P>
<P>&nbsp;&nbsp;&nbsp; /* scan&#36807;&#31243;&#20998;&#25104;&#20004;&#36718;&#65292;&#31532;&#19968;&#36718;&#20027;&#35201;&#26159;&#30830;&#23450;device-tree structure&#30340;&#38271;&#24230;&#65292;&#20445;&#23384;&#22312;size&#21464;&#37327;&#20013; */ <BR>&nbsp;&nbsp;&nbsp; start = ((void *)blob) + be32_to_cpu(blob-&gt;off_dt_struct); <BR>&nbsp;&nbsp;&nbsp; size = (unsigned long)unflatten_dt_node(blob, 0, &amp;start, NULL, NULL, 0); <BR>&nbsp;&nbsp;&nbsp; size = ALIGN(size, 4); </P>
<P>&nbsp;&nbsp;&nbsp; /* &#21021;&#22987;&#21270;&#30340;&#26102;&#20505;&#65292;&#24182;&#19981;&#26159;&#25195;&#25551;&#21040;&#19968;&#20010;node&#25110;&#32773;property&#23601;&#20998;&#37197;&#30456;&#24212;&#30340;&#20869;&#23384;&#65292;&#23454;&#38469;&#19978;&#20869;&#26680;&#26159;&#19968;&#27425;&#24615;&#30340;&#20998;&#37197;&#20102;&#19968;&#22823;&#29255;&#20869;&#23384;&#65292;&#36825;&#20123;&#20869;&#23384;&#21253;&#25324;&#20102;&#25152;&#26377;&#30340;struct device_node&#12289;node name&#12289;struct property&#25152;&#38656;&#35201;&#30340;&#20869;&#23384;&#12290;*/ <BR>&nbsp;&nbsp;&nbsp; mem = dt_alloc(size + 4, __alignof__(struct device_node)); <BR>&nbsp;&nbsp;&nbsp; memset(mem, 0, size); </P>
<P>&nbsp;&nbsp;&nbsp; *(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);&nbsp;&nbsp; //&#29992;&#26469;&#26816;&#39564;&#21518;&#38754;unflattening&#26159;&#21542;&#28322;&#20986; </P>
<P>&nbsp;&nbsp;&nbsp; /* &#36825;&#26159;&#31532;&#20108;&#36718;&#30340;scan&#65292;&#31532;&#19968;&#27425;scan&#26159;&#20026;&#20102;&#24471;&#21040;&#20445;&#23384;&#25152;&#26377;node&#21644;property&#25152;&#38656;&#35201;&#30340;&#20869;&#23384;size&#65292;&#31532;&#20108;&#27425;&#23601;&#26159;&#23454;&#25171;&#23454;&#30340;&#35201;&#26500;&#24314;device node tree&#20102; */ <BR>&nbsp;&nbsp;&nbsp; start = ((void *)blob) + be32_to_cpu(blob-&gt;off_dt_struct); <BR>&nbsp;&nbsp;&nbsp; unflatten_dt_node(blob, mem, &amp;start, NULL, &amp;allnextp, 0);&nbsp; <BR>&nbsp;&nbsp;&nbsp; </P>
<P>&nbsp;&nbsp;&nbsp; &#27492;&#22788;&#30053;&#21435;&#26657;&#39564;&#28322;&#20986;&#21644;&#26657;&#39564;OF_DT_END&#12290; <BR>} </P></BLOCKQUOTE>
<P>&#20855;&#20307;&#30340;scan&#26159;&#22312;unflatten_dt_node&#20989;&#25968;&#20013;&#65292;&#22914;&#26524;&#24050;&#32463;&#28165;&#26970;&#22320;&#20102;&#35299;DTB&#30340;&#32467;&#26500;&#65292;&#20854;&#23454;&#20195;&#30721;&#24456;&#31616;&#21333;&#65292;&#36825;&#37324;&#23601;&#19981;&#20877;&#32454;&#36848;&#20102;&#12290; </P>
<P>&#22235;&#12289;&#22914;&#20309;&#24182;&#20837;linux kernel&#30340;&#35774;&#22791;&#39537;&#21160;&#27169;&#22411; </P>
<P>&#22312;linux kernel&#24341;&#20837;&#32479;&#19968;&#35774;&#22791;&#27169;&#22411;&#20043;&#21518;&#65292;bus&#12289;driver&#21644;device&#24418;&#25104;&#20102;&#35774;&#22791;&#27169;&#22411;&#20013;&#30340;&#38081;&#19977;&#35282;&#12290;&#22312;&#39537;&#21160;&#21021;&#22987;&#21270;&#30340;&#26102;&#20505;&#20250;&#23558;&#20195;&#34920;&#35813;driver&#30340;&#19968;&#20010;&#25968;&#25454;&#32467;&#26500;&#65288;&#19968;&#33324;&#26159;xxx_driver&#65289;&#25346;&#20837;bus&#19978;&#30340;driver&#38142;&#34920;&#12290;device&#25346;&#20837;&#38142;&#34920;&#20998;&#25104;&#20004;&#31181;&#24773;&#20917;&#65292;&#19968;&#31181;&#26159;&#21363;&#25554;&#21363;&#29992;&#31867;&#22411;&#30340;bus&#65292;&#22312;&#25554;&#20837;&#19968;&#20010;&#35774;&#22791;&#21518;&#65292;&#24635;&#32447;&#21487;&#20197;&#26816;&#27979;&#21040;&#36825;&#20010;&#34892;&#20026;&#24182;&#21160;&#24577;&#20998;&#37197;&#19968;&#20010;device&#25968;&#25454;&#32467;&#26500;&#65288;&#19968;&#33324;&#26159;xxx_device&#65292;&#20363;&#22914;usb_device&#65289;&#65292;&#20043;&#21518;&#65292;&#23558;&#35813;&#25968;&#25454;&#32467;&#26500;&#25346;&#20837;bus&#19978;&#30340;device&#38142;&#34920;&#12290;bus&#19978;&#25346;&#28385;&#20102;driver&#21644;device&#65292;&#37027;&#20040;&#22914;&#20309;&#35753;device&#36935;&#21040;&#8220;&#23545;&#8221;&#30340;&#37027;&#20010;driver&#21602;&#65311;&#37027;&#20040;&#23601;&#35201;&#38752;&#32536;&#20998;&#20102;&#65292;&#20063;&#23601;&#26159;bus&#30340;match&#20989;&#25968;&#12290; </P>
<P>&#19978;&#38754;&#26159;&#19968;&#27573;&#23548;&#35770;&#65292;&#25105;&#20204;&#36824;&#26159;&#22238;&#21040;Device Tree&#12290;&#23548;&#33268;Device Tree&#30340;&#24341;&#20837;ARM&#20307;&#31995;&#32467;&#26500;&#30340;&#20195;&#30721;&#20854;&#20013;&#19968;&#20010;&#26368;&#37325;&#35201;&#30340;&#21407;&#22240;&#30340;&#22826;&#22810;&#30340;&#38745;&#24577;&#23450;&#20041;&#30340;&#34920;&#26684;&#12290;&#20363;&#22914;&#65306;&#19968;&#33324;&#20195;&#30721;&#20013;&#20250;&#23450;&#20041;&#19968;&#20010;static struct platform_device *xxx_devices&#30340;&#38745;&#24577;&#25968;&#32452;&#65292;&#22312;&#21021;&#22987;&#21270;&#30340;&#26102;&#20505;&#35843;&#29992;platform_add_devices&#12290;&#36825;&#20123;&#38745;&#24577;&#23450;&#20041;&#30340;platform_device&#24448;&#24448;&#21448;&#38656;&#35201;&#38745;&#24577;&#23450;&#20041;&#21508;&#31181;resource&#65292;&#36825;&#23548;&#33268;&#38745;&#24577;&#34920;&#26684;&#36827;&#19968;&#27493;&#22686;&#22823;&#12290;&#22914;&#26524;ARM linux&#20013;&#19981;&#20877;&#23450;&#20041;&#36825;&#20123;&#34920;&#26684;&#65292;&#37027;&#20040;&#19968;&#23450;&#38656;&#35201;&#19968;&#20010;&#36716;&#25442;&#30340;&#36807;&#31243;&#65292;&#20063;&#23601;&#26159;&#35828;&#65292;&#31995;&#32479;&#24212;&#35813;&#20250;&#26681;&#25454;Device tree&#26469;&#21160;&#24577;&#30340;&#22686;&#21152;&#31995;&#32479;&#20013;&#30340;platform_device&#12290;&#24403;&#28982;&#65292;&#36825;&#20010;&#36807;&#31243;&#24182;&#38750;&#21482;&#26159;&#21457;&#29983;&#22312;platform bus&#19978;&#65288;&#20855;&#20307;&#21487;&#20197;&#21442;&#32771;<A href="http://www.wowotech.net/linux_kenrel/platform_device.html">&#8220;Platform Device&#8221;&#30340;&#35774;&#22791;</A>&#65289;&#65292;&#20063;&#21487;&#33021;&#21457;&#29983;&#22312;&#20854;&#20182;&#30340;&#38750;&#21363;&#25554;&#21363;&#29992;&#30340;bus&#19978;&#65292;&#20363;&#22914;AMBA&#24635;&#32447;&#12289;PCI&#24635;&#32447;&#12290;&#19968;&#35328;&#20197;&#34109;&#20043;&#65292;&#22914;&#26524;&#35201;&#24182;&#20837;linux kernel&#30340;&#35774;&#22791;&#39537;&#21160;&#27169;&#22411;&#65292;&#37027;&#20040;&#23601;&#38656;&#35201;&#26681;&#25454;device_node&#30340;&#26641;&#29366;&#32467;&#26500;&#65288;root&#26159;of_allnodes&#65289;&#23558;&#19968;&#20010;&#20010;&#30340;device node&#25346;&#20837;&#21040;&#30456;&#24212;&#30340;&#24635;&#32447;device&#38142;&#34920;&#20013;&#12290;&#21482;&#35201;&#20570;&#21040;&#36825;&#19968;&#28857;&#65292;&#24635;&#32447;&#26426;&#21046;&#23601;&#20250;&#23433;&#25490;device&#21644;driver&#30340;&#32422;&#20250;&#12290; </P>
<P>&#24403;&#28982;&#65292;&#20063;&#19981;&#26159;&#25152;&#26377;&#30340;device node&#37117;&#20250;&#25346;&#20837;bus&#19978;&#30340;&#35774;&#22791;&#38142;&#34920;&#65292;&#27604;&#22914;cpus node&#65292;memory node&#65292;choose node&#31561;&#12290; </P>
<P>1&#12289;cpus node&#30340;&#22788;&#29702; </P>
<P>&#36825;&#37096;&#20998;&#30340;&#22788;&#29702;&#21487;&#20197;&#21442;&#32771;setup_arch-&gt;arm_dt_init_cpu_maps&#20013;&#30340;&#20195;&#30721;&#65292;&#20855;&#20307;&#30340;&#20195;&#30721;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>void __init arm_dt_init_cpu_maps(void) <BR>{ <BR>&nbsp;&nbsp;&nbsp; scan device node global list&#65292;&#23547;&#25214;full path&#26159;&#8220;/cpus&#8221;&#30340;&#37027;&#20010;device node&#12290;cpus&#36825;&#20010;device node&#21482;&#26159;&#19968;&#20010;&#23481;&#22120;&#65292;&#20854;&#20013;&#21253;&#25324;&#20102;&#21508;&#20010;cpu node&#30340;&#23450;&#20041;&#20197;&#21450;&#25152;&#26377;cpu node&#20849;&#20139;&#30340;property&#12290; <BR>&nbsp;&nbsp;&nbsp; cpus = of_find_node_by_path("/cpus"); </P>
<P>&nbsp; </P>
<P>&nbsp;&nbsp;&nbsp; for_each_child_of_node(cpus, cpu) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#36941;&#21382;cpus&#30340;&#25152;&#26377;&#30340;child node <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u32 hwid; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (of_node_cmp(cpu-&gt;type, "cpu"))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#25105;&#20204;&#21482;&#20851;&#24515;&#37027;&#20123;device_type&#26159;cpu&#30340;node <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue; </P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (of_property_read_u32(cpu, "reg", &amp;hwid)) {&nbsp;&nbsp;&nbsp; &#35835;&#21462;reg&#23646;&#24615;&#30340;&#20540;&#24182;&#36171;&#20540;&#32473;hwid <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reg&#30340;&#23646;&#24615;&#20540;&#30340;8 MSBs&#24517;&#39035;&#35774;&#32622;&#20026;0&#65292;&#36825;&#26159;ARM CPU binding&#23450;&#20041;&#30340;&#12290; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hwid &amp; ~MPIDR_HWID_BITMASK)&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#19981;&#20801;&#35768;&#37325;&#22797;&#30340;CPU id&#65292;&#37027;&#26159;&#19968;&#20010;&#28798;&#38590;&#24615;&#30340;&#35774;&#23450; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j = 0; j &lt; cpuidx; j++) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (WARN(tmp_map[j] == hwid, "Duplicate /cpu reg " <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "properties in the DT\n")) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; </P>
<P>&#25968;&#32452;tmp_map&#20445;&#23384;&#20102;&#31995;&#32479;&#20013;&#25152;&#26377;CPU&#30340;MPIDR&#20540;&#65288;CPU ID&#20540;&#65289;&#65292;&#20855;&#20307;&#30340;index&#30340;&#32534;&#30721;&#35268;&#21017;&#26159;&#65306; tmp_map[0]&#20445;&#23384;&#20102;booting CPU&#30340;id&#20540;&#65292;&#20854;&#20313;&#30340;CPU&#30340;ID&#20540;&#20445;&#23384;&#22312;1&#65374;NR_CPUS&#30340;&#20301;&#32622;&#12290; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hwid == mpidr) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 0; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bootcpu_valid = true; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = cpuidx++; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp_map[i] = hwid; <BR>&nbsp;&nbsp;&nbsp; } </P>
<P>&#26681;&#25454;DTB&#20013;&#30340;&#20449;&#24687;&#35774;&#23450;cpu logical map&#25968;&#32452;&#12290; </P>
<P>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; cpuidx; i++) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_cpu_possible(i, true); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_logical_map(i) = tmp_map[i]; <BR>&nbsp;&nbsp;&nbsp; } <BR>} </P></BLOCKQUOTE>
<P>&#35201;&#29702;&#35299;&#36825;&#37096;&#20998;&#30340;&#20869;&#23481;&#65292;&#38656;&#35201;&#29702;&#35299;ARM CUPs binding&#30340;&#27010;&#24565;&#65292;&#21487;&#20197;&#21442;&#32771;linux/Documentation/devicetree/bindings/arm&#30446;&#24405;&#19979;&#30340;CPU.txt&#25991;&#20214;&#30340;&#25551;&#36848;&#12290; </P>
<P>2&#12289;memory&#30340;&#22788;&#29702; </P>
<P>&#36825;&#37096;&#20998;&#30340;&#22788;&#29702;&#21487;&#20197;&#21442;&#32771;setup_arch-&gt;setup_machine_fdt-&gt;early_init_dt_scan-&gt;early_init_dt_scan_memory&#20013;&#30340;&#20195;&#30721;&#12290;&#20855;&#20307;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>int __init early_init_dt_scan_memory(unsigned long node, const char *uname, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int depth, void *data) <BR>{ <BR>&nbsp;&nbsp;&nbsp; char *type = of_get_flat_dt_prop(node, "device_type", NULL); &#33719;&#21462;device_type&#23646;&#24615;&#20540; <BR>&nbsp;&nbsp;&nbsp; __be32 *reg, *endp; <BR>&nbsp;&nbsp;&nbsp; unsigned long l; </P>
<P>&nbsp;&nbsp;&nbsp; &#22312;&#21021;&#22987;&#21270;&#30340;&#26102;&#20505;&#65292;&#25105;&#20204;&#20250;&#23545;&#27599;&#19968;&#20010;device node&#37117;&#35201;&#35843;&#29992;&#35813;call back&#20989;&#25968;&#65292;&#22240;&#27492;&#65292;&#25105;&#20204;&#35201;&#36807;&#28388;&#25481;&#37027;&#20123;&#21644;memory block&#23450;&#20041;&#26080;&#20851;&#30340;node&#12290;&#21644;memory block&#23450;&#20041;&#26377;&#30340;&#33410;&#28857;&#26377;&#20004;&#31181;&#65292;&#19968;&#31181;&#26159;node name&#26159;memory@&#24418;&#24577;&#30340;&#65292;&#21478;&#22806;&#19968;&#31181;&#26159;node&#20013;&#23450;&#20041;&#20102;device_type&#23646;&#24615;&#24182;&#19988;&#20854;&#20540;&#26159;memory&#12290; <BR>&nbsp;&nbsp;&nbsp; if (type == NULL) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (depth != 1 || strcmp(uname, "memory@0") != 0) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; <BR>&nbsp;&nbsp;&nbsp; } else if (strcmp(type, "memory") != 0) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; </P>
<P>&nbsp;&nbsp;&nbsp; &#33719;&#21462;memory&#30340;&#36215;&#22987;&#22320;&#22336;&#21644;length&#30340;&#20449;&#24687;&#12290;&#26377;&#20004;&#31181;&#23646;&#24615;&#21644;&#35813;&#20449;&#24687;&#26377;&#20851;&#65292;&#19968;&#20010;&#26159;linux,usable-memory&#65292;&#19981;&#36807;&#26368;&#26032;&#30340;&#26041;&#24335;&#36824;&#26159;&#20351;&#29992;reg&#23646;&#24615;&#12290; </P>
<P>reg = of_get_flat_dt_prop(node, "linux,usable-memory", &amp;l); <BR>&nbsp;&nbsp;&nbsp; if (reg == NULL) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reg = of_get_flat_dt_prop(node, "reg", &amp;l); <BR>&nbsp;&nbsp;&nbsp; if (reg == NULL) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; </P>
<P>&nbsp;&nbsp;&nbsp; endp = reg + (l / sizeof(__be32)); </P>
<P>reg&#23646;&#24615;&#30340;&#20540;&#26159;address&#65292;size&#25968;&#32452;&#65292;&#37027;&#20040;&#22914;&#20309;&#26469;&#21462;&#20986;&#19968;&#20010;&#20010;&#30340;address/size&#21602;&#65311;&#30001;&#20110;memory node&#19968;&#23450;&#26159;root node&#30340;child&#65292;&#22240;&#27492;dt_root_addr_cells&#65288;root node&#30340;#address-cells&#23646;&#24615;&#20540;&#65289;&#21644;dt_root_size_cells&#65288;root node&#30340;#size-cells&#23646;&#24615;&#20540;&#65289;&#20043;&#21644;&#23601;&#26159;address&#65292;size&#25968;&#32452;&#30340;entry size&#12290; </P>
<P>&nbsp;&nbsp;&nbsp; while ((endp - reg) &gt;= (dt_root_addr_cells + dt_root_size_cells)) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u64 base, size; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base = dt_mem_next_cell(dt_root_addr_cells, &#174;); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = dt_mem_next_cell(dt_root_size_cells, &#174;); </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; early_init_dt_add_memory_arch(base, size);&nbsp; &#23558;&#20855;&#20307;&#30340;memory block&#20449;&#24687;&#21152;&#20837;&#21040;&#20869;&#26680;&#20013;&#12290; <BR>&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp; return 0; <BR>} </P></BLOCKQUOTE>
<P>&nbsp; </P>
<P>3&#12289;interrupt controller&#30340;&#22788;&#29702; </P>
<P>&#21021;&#22987;&#21270;&#26159;&#36890;&#36807;start_kernel-&gt;init_IRQ-&gt;machine_desc-&gt;init_irq()&#23454;&#29616;&#30340;&#12290;&#25105;&#20204;&#29992;S3C2416&#20026;&#20363;&#26469;&#25551;&#36848;interrupt controller&#30340;&#22788;&#29702;&#36807;&#31243;&#12290;&#19979;&#38754;&#26159;machine&#25551;&#36848;&#31526;&#30340;&#23450;&#20041;&#12290; </P>
<BLOCKQUOTE>
<P>DT_MACHINE_START(S3C2416_DT, "Samsung S3C2416 (Flattened Device Tree)") <BR>&#8230;&#8230; <BR>&nbsp;&nbsp;&nbsp; .init_irq&nbsp;&nbsp;&nbsp; = irqchip_init, <BR>&#8230;&#8230; <BR>MACHINE_END </P></BLOCKQUOTE>
<P>&#22312;driver/irqchip/irq-s3c24xx.c&#25991;&#20214;&#20013;&#23450;&#20041;&#20102;&#20004;&#20010;interrupt controller&#65292;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>IRQCHIP_DECLARE(s3c2416_irq, "samsung,s3c2416-irq", s3c2416_init_intc_of); </P>
<P>IRQCHIP_DECLARE(s3c2410_irq, "samsung,s3c2410-irq", s3c2410_init_intc_of); </P></BLOCKQUOTE>
<P>&#24403;&#28982;&#65292;&#31995;&#32479;&#20013;&#21487;&#20197;&#23450;&#20041;&#26356;&#22810;&#30340;irqchip&#65292;&#19981;&#36807;&#20855;&#20307;&#29992;&#21738;&#19968;&#20010;&#26159;&#26681;&#25454;DTB&#20013;&#30340;interrupt controller node&#20013;&#30340;compatible&#23646;&#24615;&#30830;&#23450;&#30340;&#12290;&#22312;driver/irqchip/irqchip.c&#25991;&#20214;&#20013;&#23450;&#20041;&#20102;irqchip_init&#20989;&#25968;&#65292;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>void __init irqchip_init(void) <BR>{ <BR>&nbsp;&nbsp;&nbsp; of_irq_init(__irqchip_begin); <BR>} </P></BLOCKQUOTE>
<P>__irqchip_begin&#23601;&#26159;&#25152;&#26377;&#30340;irqchip&#30340;&#19968;&#20010;&#21015;&#34920;&#65292;of_irq_init&#20989;&#25968;&#26159;&#36941;&#21382;Device Tree&#65292;&#25214;&#21040;&#21305;&#37197;&#30340;irqchip&#12290;&#20855;&#20307;&#30340;&#20195;&#30721;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>void __init of_irq_init(const struct of_device_id *matches) <BR>{ <BR>&nbsp;&nbsp;&nbsp; struct device_node *np, *parent = NULL; <BR>&nbsp;&nbsp;&nbsp; struct intc_desc *desc, *temp_desc; <BR>&nbsp;&nbsp;&nbsp; struct list_head intc_desc_list, intc_parent_list; </P>
<P>&nbsp;&nbsp;&nbsp; INIT_LIST_HEAD(&amp;intc_desc_list); <BR>&nbsp;&nbsp;&nbsp; INIT_LIST_HEAD(&amp;intc_parent_list); </P>
<P>&nbsp;&nbsp;&nbsp; &#36941;&#21382;&#25152;&#26377;&#30340;node&#65292;&#23547;&#25214;&#23450;&#20041;&#20102;interrupt-controller&#23646;&#24615;&#30340;node&#65292;&#22914;&#26524;&#23450;&#20041;&#20102;interrupt-controller&#23646;&#24615;&#21017;&#35828;&#26126;&#35813;node&#23601;&#26159;&#19968;&#20010;&#20013;&#26029;&#25511;&#21046;&#22120;&#12290; </P>
<P>&nbsp;&nbsp;&nbsp; for_each_matching_node(np, matches) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!of_find_property(np, "interrupt-controller", NULL) || <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !of_device_is_available(np)) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P>&#20998;&#37197;&#20869;&#23384;&#24182;&#25346;&#20837;&#38142;&#34920;&#65292;&#24403;&#28982;&#36824;&#26377;&#26681;&#25454;interrupt-parent&#24314;&#31435;controller&#20043;&#38388;&#30340;&#29238;&#23376;&#20851;&#31995;&#12290;&#23545;&#20110;interrupt controller&#65292;&#23427;&#20063;&#21487;&#33021;&#26159;&#19968;&#20010;&#26641;&#29366;&#30340;&#32467;&#26500;&#12290; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc = kzalloc(sizeof(*desc), GFP_KERNEL); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (WARN_ON(!desc)) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc-&gt;dev = np; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc-&gt;interrupt_parent = of_irq_find_parent(np); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (desc-&gt;interrupt_parent == np) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc-&gt;interrupt_parent = NULL; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_add_tail(&amp;desc-&gt;list, &amp;intc_desc_list); <BR>&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp; &#27491;&#22240;&#20026;interrupt controller&#34987;&#32452;&#32455;&#25104;&#26641;&#29366;&#30340;&#32467;&#26500;&#65292;&#22240;&#27492;&#21021;&#22987;&#21270;&#30340;&#39034;&#24207;&#23601;&#38656;&#35201;&#25511;&#21046;&#65292;&#24212;&#35813;&#20174;&#26681;&#33410;&#28857;&#24320;&#22987;&#65292;&#20381;&#27425;&#36882;&#36827;&#21040;&#19979;&#19968;&#20010;level&#30340;interrupt controller&#12290; <BR>&nbsp;&nbsp;&nbsp; while (!list_empty(&amp;intc_desc_list)) {&nbsp; intc_desc_list&#38142;&#34920;&#20013;&#30340;&#33410;&#28857;&#20250;&#34987;&#19968;&#20010;&#20010;&#30340;&#22788;&#29702;&#65292;&#27599;&#22788;&#29702;&#23436;&#19968;&#20010;&#33410;&#28857;&#23601;&#20250;&#23558;&#35813;&#33410;&#28857;&#21024;&#38500;&#65292;&#24403;&#25152;&#26377;&#30340;&#33410;&#28857;&#34987;&#21024;&#38500;&#65292;&#25972;&#20010;&#22788;&#29702;&#36807;&#31243;&#20063;&#23601;&#26159;&#32467;&#26463;&#20102;&#12290; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, list) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct of_device_id *match; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ret; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of_irq_init_cb_t irq_init_cb; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#26368;&#24320;&#22987;&#30340;&#26102;&#20505;parent&#21464;&#37327;&#26159;NULL&#65292;&#30830;&#20445;&#31532;&#19968;&#20010;&#34987;&#22788;&#29702;&#30340;&#26159;root interrupt controller&#12290;&#22312;&#22788;&#29702;&#23436;root node&#20043;&#21518;&#65292;parent&#21464;&#37327;&#34987;&#35774;&#23450;&#20026;root interrupt controller&#65292;&#22240;&#27492;&#65292;&#31532;&#20108;&#20010;&#24490;&#29615;&#20013;&#22788;&#29702;&#30340;&#26159;&#25152;&#26377;parent&#26159;root interrupt controller&#30340;child interrupt controller&#12290;&#20063;&#23601;&#26159;level 1&#65288;&#22914;&#26524;root&#26159;level 0&#30340;&#35805;&#65289;&#30340;&#33410;&#28857;&#12290; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (desc-&gt;interrupt_parent != parent) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_del(&amp;desc-&gt;list);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#65293;&#65293;&#65293;&#65293;&#65293;&#20174;&#38142;&#34920;&#20013;&#21024;&#38500; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match = of_match_node(matches, desc-&gt;dev);&#65293;&#65293;&#65293;&#65293;&#65293;&#21305;&#37197;&#24182;&#21021;&#22987;&#21270; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (WARN(!match-&gt;data,&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;match-&gt;data&#26159;&#21021;&#22987;&#21270;&#20989;&#25968; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "of_irq_init: no init function for %s\n", <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match-&gt;compatible)) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(desc); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_init_cb = (of_irq_init_cb_t)match-&gt;data; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = irq_init_cb(desc-&gt;dev, desc-&gt;interrupt_parent);&#65293;&#65293;&#65293;&#65293;&#65293;&#25191;&#34892;&#21021;&#22987;&#21270;&#20989;&#25968; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ret) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(desc); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#22788;&#29702;&#23436;&#30340;&#33410;&#28857;&#25918;&#20837;intc_parent_list&#38142;&#34920;&#65292;&#21518;&#38754;&#20250;&#29992;&#21040; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_add_tail(&amp;desc-&gt;list, &amp;intc_parent_list); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#23545;&#20110;level 0&#65292;&#21482;&#26377;&#19968;&#20010;root interrupt controller&#65292;&#23545;&#20110;level 1&#65292;&#21487;&#33021;&#26377;&#33509;&#24178;&#20010;interrupt controller&#65292;&#22240;&#27492;&#35201;&#36941;&#21382;&#36825;&#20123;parent interrupt controller&#65292;&#20197;&#20415;&#22788;&#29702;&#19979;&#19968;&#20010;level&#30340;child node&#12290; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc = list_first_entry_or_null(&amp;intc_parent_list, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typeof(*desc), list); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!desc) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr_err("of_irq_init: children remain, but no parents\n"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_del(&amp;desc-&gt;list); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent = desc-&gt;dev; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(desc); <BR>&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp; list_for_each_entry_safe(desc, temp_desc, &amp;intc_parent_list, list) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_del(&amp;desc-&gt;list); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(desc); <BR>&nbsp;&nbsp;&nbsp; } <BR>err: <BR>&nbsp;&nbsp;&nbsp; list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, list) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_del(&amp;desc-&gt;list); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(desc); <BR>&nbsp;&nbsp;&nbsp; } <BR>} </P></BLOCKQUOTE>
<P>&#21482;&#26377;&#35813;node&#20013;&#26377;interrupt-controller&#36825;&#20010;&#23646;&#24615;&#23450;&#20041;&#65292;&#37027;&#20040;linux kernel&#23601;&#20250;&#20998;&#37197;&#19968;&#20010;interrupt controller&#30340;&#25551;&#36848;&#31526;&#65288;struct intc_desc&#65289;&#24182;&#25346;&#20837;&#38431;&#21015;&#12290;&#36890;&#36807;interrupt-parent&#23646;&#24615;&#65292;&#21487;&#20197;&#30830;&#23450;&#21508;&#20010;interrupt controller&#30340;&#23618;&#27425;&#20851;&#31995;&#12290;&#22312;scan&#20102;&#25152;&#26377;&#30340;Device Tree&#20013;&#30340;interrupt controller&#30340;&#23450;&#20041;&#20043;&#21518;&#65292;&#31995;&#32479;&#24320;&#22987;&#21305;&#37197;&#36807;&#31243;&#12290;&#19968;&#26086;&#21305;&#37197;&#21040;&#20102;interrupt chip&#21015;&#34920;&#20013;&#30340;&#39033;&#27425;&#21518;&#65292;&#23601;&#20250;&#35843;&#29992;&#30456;&#24212;&#30340;&#21021;&#22987;&#21270;&#20989;&#25968;&#12290;&#22914;&#26524;CPU&#26159;S3C2416&#30340;&#35805;&#65292;&#21305;&#37197;&#21040;&#30340;&#26159;irqchip&#30340;&#21021;&#22987;&#21270;&#20989;&#25968;&#26159;s3c2416_init_intc_of&#12290; </P>
<P>OK&#65292;&#25105;&#20204;&#24050;&#32463;&#36890;&#36807;compatible&#23646;&#24615;&#25214;&#21040;&#20102;&#36866;&#21512;&#30340;interrupt controller&#65292;&#37027;&#20040;&#22914;&#20309;&#35299;&#26512;reg&#23646;&#24615;&#21602;&#65311;&#25105;&#20204;&#30693;&#36947;&#65292;&#23545;&#20110;s3c2416&#30340;interrupt controller&#32780;&#35328;&#65292;&#20854;#interrupt-cells&#30340;&#23646;&#24615;&#20540;&#26159;4&#65292;&#23450;&#20041;&#20026;<CTRL_NUM type="" ctrl_irq="" parent_irq="">&#12290;&#27599;&#20010;&#22495;&#30340;&#35299;&#37322;&#22914;&#19979;&#65306;</CTRL_NUM> </P>
<P>&#65288;1&#65289;ctrl_num&#34920;&#31034;&#20351;&#29992;&#21738;&#19968;&#31181;&#31867;&#22411;&#30340;interrupt controller&#65292;&#20854;&#20540;&#30340;&#35299;&#37322;&#22914;&#19979;&#65306; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 0 ... main controller <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 1 ... sub controller <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 2 ... second main controller </P>
<P>&#65288;2&#65289;parent_irq&#12290;&#23545;&#20110;sub controller&#65292;parent_irq&#26631;&#35782;&#20102;&#20854;&#22312;main controller&#30340;bit position&#12290; </P>
<P>&#65288;3&#65289;ctrl_irq&#26631;&#35782;&#20102;&#22312;controller&#20013;&#30340;bit&#20301;&#32622;&#12290; </P>
<P>&#65288;4&#65289;type&#26631;&#35782;&#20102;&#35813;&#20013;&#26029;&#30340;trigger type&#65292;&#20363;&#22914;&#65306;&#19978;&#21319;&#27839;&#35302;&#21457;&#36824;&#26159;&#30005;&#24179;&#35302;&#21457;&#12290; </P>
<P>&#20026;&#20102;&#26356;&#39034;&#30021;&#30340;&#25551;&#36848;&#21518;&#32493;&#30340;&#20195;&#30721;&#65292;&#25105;&#38656;&#35201;&#31616;&#21333;&#30340;&#20171;&#32461;2416&#30340;&#20013;&#26029;&#25511;&#21046;&#22120;&#65292;&#20854;block diagram&#22914;&#19979;&#65306; </P>
<P><A href="http://www.wowotech.net/content/uploadfile/201406/1fae6636c0a85be88e3177559936bad420140606080337.gif"><IMG title=2416intc style="BORDER-LEFT-WIDTH: 0px; BORDER-RIGHT-WIDTH: 0px; BORDER-BOTTOM-WIDTH: 0px; DISPLAY: inline; BORDER-TOP-WIDTH: 0px" border=0 alt=2416intc src="http://www.wowotech.net/content/uploadfile/201406/af17f85d8a8d3d689caf5c62fcb8ea1420140606080340.gif" width=821 height=376></A> </P>
<P>53&#20010;Samsung2416&#30340;&#20013;&#26029;&#28304;&#34987;&#20998;&#25104;&#20004;&#31181;&#31867;&#22411;&#65292;&#19968;&#31181;&#26159;&#38656;&#35201;sub&#23492;&#23384;&#22120;&#36827;&#34892;&#25511;&#21046;&#30340;&#65292;&#20363;&#22914;DMA&#65292;&#31995;&#32479;&#20013;&#30340;8&#20010;DMA&#20013;&#26029;&#26159;&#36890;&#36807;&#20004;&#32423;&#35782;&#21035;&#30340;&#65292;&#20808;&#22312;SRCPND&#23492;&#23384;&#22120;&#20013;&#24471;&#21040;&#26159;DMA&#20013;&#26029;&#30340;&#20449;&#24687;&#65292;&#20855;&#20307;&#26159;&#21738;&#19968;&#20010;channel&#30340;DMA&#20013;&#26029;&#38656;&#35201;&#32487;&#32493;&#26597;&#35810;SUBSRC&#23492;&#23384;&#22120;&#12290;&#37027;&#20123;&#19981;&#38656;&#35201;sub&#23492;&#23384;&#22120;&#36827;&#34892;&#25511;&#21046;&#30340;&#65292;&#20363;&#22914;timer&#65292;5&#20010;timer&#30340;&#20013;&#26029;&#21487;&#20197;&#30452;&#25509;&#20174;SRCPND&#20013;&#24471;&#21040;&#12290; <BR>&#20013;&#26029;MASK&#23492;&#23384;&#22120;&#21487;&#20197;&#25511;&#21046;&#20135;&#29983;&#30340;&#20013;&#26029;&#26159;&#21542;&#35201;&#25253;&#21578;&#32473;CPU&#65292;&#24403;&#19968;&#20010;&#20013;&#26029;&#34987;mask&#30340;&#26102;&#20505;&#65292;&#34429;&#28982;SRCPND&#23492;&#23384;&#22120;&#20013;&#65292;&#30828;&#20214;&#20250;set&#35813;bit&#65292;&#20294;&#26159;&#19981;&#20250;&#24433;&#21709;&#21040;INTPND&#23492;&#23384;&#22120;&#65292;&#20174;&#32780;&#19981;&#20250;&#21521;CPU&#25253;&#21578;&#35813;&#20013;&#26029;&#12290;&#23545;&#20110;SUBMASK&#23492;&#23384;&#22120;&#65292;&#22914;&#26524;&#35813;bit&#34987;set&#65292;&#20063;&#23601;&#26159;&#35813;sub&#20013;&#26029;&#34987;mask&#20102;&#65292;&#37027;&#20040;&#21363;&#20415;&#20135;&#29983;&#20102;&#23545;&#24212;&#30340;sub&#20013;&#26029;&#65292;&#20063;&#19981;&#20250;&#20462;&#25913;SRCPND&#23492;&#23384;&#22120;&#30340;&#20869;&#23481;&#65292;&#21482;&#26159;&#20462;&#25913;SUBSRCPND&#20013;&#23492;&#23384;&#22120;&#30340;&#20869;&#23481;&#12290; </P>
<P>&#19981;&#36807;&#38543;&#30528;&#30828;&#20214;&#30340;&#28436;&#21270;&#65292;&#26356;&#22810;&#30340;HW block&#21152;&#20837;&#21040;SOC&#20013;&#65292;&#36825;&#20351;&#24471;&#20013;&#26029;&#28304;&#19981;&#22815;&#29992;&#20102;&#65292;&#22240;&#27492;&#20013;&#26029;&#23492;&#23384;&#22120;&#21448;&#34987;&#20998;&#25104;&#20004;&#20010;group&#65292;&#19968;&#20010;&#26159;group 1&#65288;&#24320;&#22987;&#22320;&#22336;&#26159;0X4A000000&#65292;&#20063;&#23601;&#26159;main controller&#20102;&#65289;&#65292;&#21478;&#22806;&#19968;&#20010;&#26159;group2&#65288;&#24320;&#22987;&#22320;&#22336;&#26159;0X4A000040&#65292;&#21483;&#20570;second main controller&#65289;&#12290;group 1&#20013;&#30340;sub&#23492;&#23384;&#22120;&#30340;&#36215;&#22987;&#22320;&#22336;&#26159;0X4A000018&#65288;&#20063;&#23601;&#26159;sub controller&#65289;&#12290; </P>
<P>&#20102;&#35299;&#20102;&#19978;&#38754;&#30340;&#20869;&#23481;&#21518;&#65292;&#19979;&#38754;&#30340;&#23450;&#20041;&#23601;&#27604;&#36739;&#22909;&#29702;&#35299;&#20102;&#65306; </P>
<BLOCKQUOTE>
<P>static struct s3c24xx_irq_of_ctrl s3c2416_ctrl[] = { <BR>&nbsp;&nbsp;&nbsp; { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "intc", &#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;main controller <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .offset = 0, <BR>&nbsp;&nbsp;&nbsp; }, { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "subintc", &#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;sub controller <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .offset = 0x18, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .parent = &amp;s3c_intc[0], <BR>&nbsp;&nbsp;&nbsp; }, { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "intc2", &#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;second main controller <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .offset = 0x40, <BR>&nbsp;&nbsp;&nbsp; } <BR>}; </P></BLOCKQUOTE>
<P>&#23545;&#20110;s3c2416&#32780;&#35328;&#65292;irqchip&#30340;&#21021;&#22987;&#21270;&#20989;&#25968;&#26159;s3c2416_init_intc_of&#65292;s3c2416_ctrl&#20316;&#20026;&#21442;&#25968;&#20256;&#36882;&#32473;&#20102;s3c_init_intc_of&#65292;&#22823;&#37096;&#20998;&#30340;&#22788;&#29702;&#37117;&#26159;&#22312;s3c_init_intc_of&#20989;&#25968;&#20013;&#23436;&#25104;&#30340;&#65292;&#30001;&#20110;&#36825;&#20010;&#20989;&#25968;&#21644;&#20013;&#26029;&#23376;&#31995;&#32479;&#38750;&#24120;&#30456;&#20851;&#65292;&#36825;&#37324;&#23601;&#19981;&#35814;&#36848;&#20102;&#65292;&#21518;&#32493;&#20250;&#26377;&#19968;&#20221;&#19987;&#38376;&#30340;&#25991;&#26723;&#25551;&#36848;&#20043;&#12290; </P>
<P>4&#12289;GPIO controller&#30340;&#22788;&#29702; </P>
<P>&#26242;&#19981;&#25551;&#36848;&#65292;&#21518;&#32493;&#20250;&#26377;&#19968;&#20221;&#19987;&#38376;&#30340;&#25991;&#26723;&#25551;&#36848;GPIO sub system&#12290; </P>
<P>5&#12289;machine&#21021;&#22987;&#21270; </P>
<P>machine&#21021;&#22987;&#21270;&#30340;&#20195;&#30721;&#21487;&#20197;&#27839;&#30528;start_kernel-&gt;rest_init-&gt;kernel_init-&gt;kernel_init_freeable-&gt;do_basic_setup-&gt;do_initcalls&#36335;&#24452;&#23547;&#25214;&#12290;&#22312;do_initcalls&#20989;&#25968;&#20013;&#65292;kernel&#20250;&#20381;&#27425;&#25191;&#34892;&#21508;&#20010;initcall&#20989;&#25968;&#65292;&#22312;&#36825;&#20010;&#36807;&#31243;&#20013;&#65292;&#20250;&#35843;&#29992;customize_machine&#65292;&#20855;&#20307;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>static int __init customize_machine(void) <BR>{ <BR><BR>&nbsp;&nbsp;&nbsp; if (machine_desc-&gt;init_machine) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; machine_desc-&gt;init_machine(); <BR>&nbsp;&nbsp;&nbsp; else <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL); <BR><BR>&nbsp;&nbsp;&nbsp; return 0; <BR>} <BR>arch_initcall(customize_machine); </P></BLOCKQUOTE>
<P>&#22312;&#36825;&#20010;&#20989;&#25968;&#20013;&#65292;&#19968;&#33324;&#20250;&#35843;&#29992;machine&#25551;&#36848;&#31526;&#20013;&#30340;init_machine callback&#20989;&#25968;&#26469;&#25226;&#21508;&#31181;Device Tree&#20013;&#23450;&#20041;&#21508;&#20010;&#35774;&#22791;&#33410;&#28857;&#21152;&#20837;&#21040;&#31995;&#32479;&#12290;&#22914;&#26524;machine&#25551;&#36848;&#31526;&#20013;&#27809;&#26377;&#23450;&#20041;init_machine&#20989;&#25968;&#65292;&#37027;&#20040;&#30452;&#25509;&#35843;&#29992;of_platform_populate&#25226;&#25152;&#26377;&#30340;platform device&#21152;&#20837;&#21040;kernel&#20013;&#12290;&#23545;&#20110;s3c2416&#65292;&#20854;machine&#25551;&#36848;&#31526;&#20013;&#30340;init_machine callback&#20989;&#25968;&#23601;&#26159;s3c2416_dt_machine_init&#65292;&#20195;&#30721;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>static void __init s3c2416_dt_machine_init(void) <BR>{ <BR>&nbsp;&nbsp;&nbsp; of_platform_populate(NULL, --------&#20256;&#20837;NULL&#21442;&#25968;&#34920;&#31034;&#20174;root node&#24320;&#22987;scan </P>
<P>of_default_bus_match_table, s3c2416_auxdata_lookup, NULL); </P>
<P>&nbsp;&nbsp;&nbsp; s3c_pm_init(); &#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;power management&#30456;&#20851;&#30340;&#21021;&#22987;&#21270; <BR>} </P></BLOCKQUOTE>
<P>&#30001;&#27492;&#21487;&#35265;&#65292;&#26368;&#32456;&#29983;&#25104;platform device&#30340;&#20195;&#30721;&#26469;&#33258;of_platform_populate&#20989;&#25968;&#12290;&#35813;&#20989;&#25968;&#30340;&#36923;&#36753;&#27604;&#36739;&#31616;&#21333;&#65292;&#36941;&#21382;device node global list&#20013;&#25152;&#26377;&#30340;node&#65292;&#24182;&#35843;&#29992;of_platform_bus_create&#22788;&#29702;&#65292;of_platform_bus_create&#20989;&#25968;&#20195;&#30721;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>static int of_platform_bus_create(struct device_node *bus,-------------&#35201;&#21019;&#24314;&#30340;&#37027;&#20010;device node <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct of_device_id *matches,-------&#35201;&#21305;&#37197;&#30340;list <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct of_dev_auxdata *lookup,------&#38468;&#23646;&#25968;&#25454; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *parent, bool strict)---------------parent&#25351;&#21521;&#29238;&#33410;&#28857;&#12290;strict&#26159;&#21542;&#35201;&#27714;&#23436;&#20840;&#21305;&#37197; <BR>{ <BR>&nbsp;&nbsp;&nbsp; const struct of_dev_auxdata *auxdata; <BR>&nbsp;&nbsp;&nbsp; struct device_node *child; <BR>&nbsp;&nbsp;&nbsp; struct platform_device *dev; <BR>&nbsp;&nbsp;&nbsp; const char *bus_id = NULL; <BR>&nbsp;&nbsp;&nbsp; void *platform_data = NULL; <BR>&nbsp;&nbsp;&nbsp; int rc = 0; </P>
<P>&#21024;&#38500;&#30830;&#20445;device node&#26377;compatible&#23646;&#24615;&#30340;&#20195;&#30721;&#12290; </P>
<P>&nbsp;&nbsp;&nbsp; auxdata = of_dev_lookup(lookup, bus);&nbsp; &#22312;&#20256;&#20837;&#30340;lookup table&#23547;&#25214;&#21644;&#35813;device node&#21305;&#37197;&#30340;&#38468;&#21152;&#25968;&#25454; <BR>&nbsp;&nbsp;&nbsp; if (auxdata) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bus_id = auxdata-&gt;name;-----------------&#22914;&#26524;&#25214;&#21040;&#65292;&#37027;&#20040;&#23601;&#29992;&#38468;&#21152;&#25968;&#25454;&#20013;&#30340;&#38745;&#24577;&#23450;&#20041;&#30340;&#20869;&#23481; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; platform_data = auxdata-&gt;platform_data; <BR>&nbsp;&nbsp;&nbsp; } </P>
<P>ARM&#20844;&#21496;&#25552;&#20379;&#20102;CPU core&#65292;&#38500;&#27492;&#20043;&#22806;&#65292;&#23427;&#35774;&#35745;&#20102;AMBA&#30340;&#24635;&#32447;&#26469;&#36830;&#25509;SOC&#20869;&#30340;&#21508;&#20010;block&#12290;&#31526;&#21512;&#36825;&#20010;&#24635;&#32447;&#26631;&#20934;&#30340;SOC&#19978;&#30340;&#22806;&#35774;&#21483;&#20570;ARM Primecell Peripherals&#12290;&#22914;&#26524;&#19968;&#20010;device node&#30340;compatible&#23646;&#24615;&#20540;&#26159;arm,primecell&#30340;&#35805;&#65292;&#21487;&#20197;&#35843;&#29992;of_amba_device_create&#26469;&#21521;amba&#24635;&#32447;&#19978;&#22686;&#21152;&#19968;&#20010;amba device&#12290; </P>
<P>&nbsp;&nbsp;&nbsp; if (of_device_is_compatible(bus, "arm,primecell")) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of_amba_device_create(bus, bus_id, platform_data, parent); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; <BR>&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp; &#22914;&#26524;&#19981;&#26159;ARM Primecell Peripherals&#65292;&#37027;&#20040;&#25105;&#20204;&#23601;&#38656;&#35201;&#21521;platform bus&#19978;&#22686;&#21152;&#19968;&#20010;platform device&#20102; </P>
<P>&nbsp;&nbsp;&nbsp; dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent); <BR>&nbsp;&nbsp;&nbsp; if (!dev || !of_match_node(matches, bus)) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; </P>
<P>&nbsp;&nbsp;&nbsp; &#19968;&#20010;device node&#21487;&#33021;&#26159;&#19968;&#20010;&#26725;&#35774;&#22791;&#65292;&#22240;&#27492;&#35201;&#37325;&#22797;&#35843;&#29992;of_platform_bus_create&#26469;&#25226;&#25152;&#26377;&#30340;device node&#22788;&#29702;&#25481;&#12290; </P>
<P>&nbsp;&nbsp;&nbsp; for_each_child_of_node(bus, child) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr_debug("&nbsp;&nbsp; create child: %s\n", child-&gt;full_name); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rc) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of_node_put(child); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp; return rc; <BR>} </P></BLOCKQUOTE>
<P>&#20855;&#20307;&#22686;&#21152;platform device&#30340;&#20195;&#30721;&#22312;of_platform_device_create_pdata&#20013;&#65292;&#20195;&#30721;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>static struct platform_device *of_platform_device_create_pdata( <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device_node *np, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *bus_id, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *platform_data, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *parent) <BR>{ <BR>&nbsp;&nbsp;&nbsp; struct platform_device *dev; </P>
<P>&nbsp;&nbsp;&nbsp; if (!of_device_is_available(np))---------check status&#23646;&#24615;&#65292;&#30830;&#20445;&#26159;enable&#25110;&#32773;OK&#30340;&#12290; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL; </P>
<P>&nbsp;&nbsp;&nbsp; of_device_alloc&#38500;&#20102;&#20998;&#37197;struct platform_device&#30340;&#20869;&#23384;&#65292;&#36824;&#20998;&#37197;&#20102;&#35813;platform device&#38656;&#35201;&#30340;resource&#30340;&#20869;&#23384;&#65288;&#21442;&#32771;struct platform_device &#20013;&#30340;resource&#25104;&#21592;&#65289;&#12290;&#24403;&#28982;&#65292;&#36825;&#23601;&#38656;&#35201;&#35299;&#26512;&#35813;device node&#30340;interrupt&#36164;&#28304;&#20197;&#21450;memory address&#36164;&#28304;&#12290; </P>
<P>&nbsp;&nbsp;&nbsp; dev = of_device_alloc(np, bus_id, parent); <BR>&nbsp;&nbsp;&nbsp; if (!dev) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL; </P>
<P>&#35774;&#23450;platform_device &#20013;&#30340;&#20854;&#20182;&#25104;&#21592; <BR>&nbsp;&nbsp;&nbsp; dev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(32); <BR>&nbsp;&nbsp;&nbsp; if (!dev-&gt;dev.dma_mask) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;dev.dma_mask = &amp;dev-&gt;dev.coherent_dma_mask; <BR>&nbsp;&nbsp;&nbsp; dev-&gt;dev.bus = &amp;platform_bus_type; <BR>&nbsp;&nbsp;&nbsp; dev-&gt;dev.platform_data = platform_data; </P>
<P>&nbsp;&nbsp;&nbsp; if (of_device_add(dev) != 0) {------------------&#25226;&#36825;&#20010;platform device&#21152;&#20837;&#32479;&#19968;&#35774;&#22791;&#27169;&#22411;&#31995;&#32479;&#20013; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; platform_device_put(dev); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL; <BR>&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp; return dev; <BR>} </P></BLOCKQUOTE>
<P><EM>&#21407;&#21019;&#25991;&#31456;&#65292;&#36716;&#21457;&#35831;&#27880;&#26126;&#20986;&#22788;&#12290;&#34583;&#31389;&#31185;&#25216;</EM>&#65292;<A href="http://www.wowotech.net/linux_kenrel/dt-code-analysis.html">www.wowotech.net&#12290;</A>