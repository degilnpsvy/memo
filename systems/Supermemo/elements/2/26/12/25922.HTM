<H2>Linux kernel&#30340;&#20013;&#26029;&#23376;&#31995;&#32479;&#20043;&#65288;&#20108;&#65289;&#65306;IRQ Domain&#20171;&#32461;</H2>
<P class=date>&#20316;&#32773;&#65306;<A href="http://www.wowotech.net/author/3">linuxer</A> &#21457;&#24067;&#20110;&#65306;2014-8-19 18:46 &#20998;&#31867;&#65306;<A href="http://www.wowotech.net/sort/irq_subsystem">&#20013;&#26029;&#23376;&#31995;&#32479;</A> </P>
<P>&#19968;&#12289;&#27010;&#36848; </P>
<P>&#22312;linux kernel&#20013;&#65292;&#25105;&#20204;&#20351;&#29992;&#19979;&#38754;&#20004;&#20010;ID&#26469;&#26631;&#35782;&#19968;&#20010;&#26469;&#33258;&#22806;&#35774;&#30340;&#20013;&#26029;&#65306; </P>
<P>1&#12289;IRQ number&#12290;CPU&#38656;&#35201;&#20026;&#27599;&#19968;&#20010;&#22806;&#35774;&#20013;&#26029;&#32534;&#21495;&#65292;&#25105;&#20204;&#31216;&#20043;IRQ Number&#12290;&#36825;&#20010;IRQ number&#26159;&#19968;&#20010;&#34394;&#25311;&#30340;interrupt ID&#65292;&#21644;&#30828;&#20214;&#26080;&#20851;&#65292;&#20165;&#20165;&#26159;&#34987;CPU&#29992;&#26469;&#26631;&#35782;&#19968;&#20010;&#22806;&#35774;&#20013;&#26029;&#12290; </P>
<P>2&#12289;HW interrupt ID&#12290;&#23545;&#20110;interrupt controller&#32780;&#35328;&#65292;&#23427;&#25910;&#38598;&#20102;&#22810;&#20010;&#22806;&#35774;&#30340;interrupt request line&#24182;&#21521;&#19978;&#20256;&#36882;&#65292;&#22240;&#27492;&#65292;interrupt controller&#38656;&#35201;&#23545;&#22806;&#35774;&#20013;&#26029;&#36827;&#34892;&#32534;&#30721;&#12290;Interrupt controller&#29992;HW interrupt ID&#26469;&#26631;&#35782;&#22806;&#35774;&#30340;&#20013;&#26029;&#12290;&#22312;interrupt controller&#32423;&#32852;&#30340;&#24773;&#20917;&#19979;&#65292;&#20165;&#20165;&#29992;HW interrupt ID&#24050;&#32463;&#19981;&#33021;&#21807;&#19968;&#26631;&#35782;&#19968;&#20010;&#22806;&#35774;&#20013;&#26029;&#65292;&#36824;&#38656;&#35201;&#30693;&#36947;&#35813;HW interrupt ID&#25152;&#23646;&#30340;interrupt controller&#65288;HW interrupt ID&#22312;&#19981;&#21516;&#30340;Interrupt controller&#19978;&#26159;&#20250;&#37325;&#22797;&#32534;&#30721;&#30340;&#65289;&#12290; </P>
<P>&#36825;&#26679;&#65292;CPU&#21644;interrupt controller&#22312;&#26631;&#35782;&#20013;&#26029;&#19978;&#23601;&#26377;&#20102;&#19968;&#20123;&#19981;&#21516;&#30340;&#27010;&#24565;&#65292;&#20294;&#26159;&#65292;&#23545;&#20110;&#39537;&#21160;&#24037;&#31243;&#24072;&#32780;&#35328;&#65292;&#25105;&#20204;&#21644;CPU&#35270;&#35282;&#26159;&#19968;&#26679;&#30340;&#65292;&#25105;&#20204;&#21482;&#24076;&#26395;&#24471;&#21040;&#19968;&#20010;IRQ number&#65292;&#32780;&#19981;&#20851;&#31995;&#20855;&#20307;&#26159;&#37027;&#20010;interrupt controller&#19978;&#30340;&#37027;&#20010;HW interrupt ID&#12290;&#36825;&#26679;&#19968;&#20010;&#22909;&#22788;&#26159;&#22312;&#20013;&#26029;&#30456;&#20851;&#30340;&#30828;&#20214;&#21457;&#29983;&#21464;&#21270;&#30340;&#26102;&#20505;&#65292;&#39537;&#21160;&#36719;&#20214;&#19981;&#38656;&#35201;&#20462;&#25913;&#12290;&#22240;&#27492;&#65292;linux kernel&#20013;&#30340;&#20013;&#26029;&#23376;&#31995;&#32479;&#38656;&#35201;&#25552;&#20379;&#19968;&#20010;&#23558;HW interrupt ID&#26144;&#23556;&#21040;IRQ number&#19978;&#26469;&#30340;&#26426;&#21046;&#65292;&#36825;&#23601;&#26159;&#26412;&#25991;&#20027;&#35201;&#30340;&#20869;&#23481;&#12290; </P>
<P>&nbsp; </P>
<P>&#20108;&#12289;&#21382;&#21490; </P>
<P>&#20851;&#20110;HW interrupt ID&#26144;&#23556;&#21040;IRQ number&#19978; &#36825;&#20107;&#65292;&#22312;&#36807;&#21435;&#31995;&#32479;&#21482;&#26377;&#19968;&#20010;interrupt controller&#30340;&#26102;&#20505;&#36824;&#26159;&#24456;&#31616;&#21333;&#30340;&#65292;&#20013;&#26029;&#25511;&#21046;&#22120;&#19978;&#23454;&#38469;&#30340;HW interrupt line&#30340;&#32534;&#21495;&#21487;&#20197;&#30452;&#25509;&#21464;&#25104;IRQ number&#12290;&#20363;&#22914;&#25105;&#20204;&#22823;&#23478;&#37117;&#29087;&#24713;&#30340;SOC&#20869;&#23884;&#30340;interrupt controller&#65292;&#36825;&#31181;controller&#22810;&#21322;&#26377;&#20013;&#26029;&#29366;&#24577;&#23492;&#23384;&#22120;&#65292;&#36825;&#20010;&#23492;&#23384;&#22120;&#21487;&#33021;&#26377;64&#20010;bit&#65288;&#20063;&#21487;&#33021;&#26356;&#22810;&#65289;&#65292;&#27599;&#20010;bit&#23601;&#26159;&#19968;&#20010;IRQ number&#65292;&#21487;&#20197;&#30452;&#25509;&#36827;&#34892;&#26144;&#23556;&#12290;&#36825;&#26102;&#20505;&#65292;GPIO&#30340;&#20013;&#26029;&#22312;&#20013;&#26029;&#25511;&#21046;&#22120;&#30340;&#29366;&#24577;&#23492;&#23384;&#22120;&#20013;&#21482;&#26377;&#19968;&#20010;bit&#65292;&#22240;&#27492;&#25152;&#26377;&#30340;GPIO&#20013;&#26029;&#21482;&#26377;&#19968;&#20010;IRQ number&#65292;&#22312;&#35813;&#36890;&#29992;GPIO&#20013;&#26029;&#30340;irq handler&#20013;&#36827;&#34892;deduplex&#65292;&#23558;&#21508;&#20010;&#20855;&#20307;&#30340;GPIO&#20013;&#26029;&#26144;&#23556;&#21040;&#20854;&#30456;&#24212;&#30340;IRQ number&#19978;&#12290;&#22914;&#26524;&#20320;&#26159;&#19968;&#20010;&#36275;&#22815;&#32769;&#30340;&#24037;&#31243;&#24072;&#65292;&#24212;&#35813;&#26159;&#32463;&#21382;&#36807;&#36825;&#20010;&#38454;&#27573;&#30340;&#12290; </P>
<P>&#38543;&#30528;linux kernel&#30340;&#21457;&#23637;&#65292;&#23558;interrupt controller&#25277;&#35937;&#25104;irqchip&#36825;&#20010;&#27010;&#24565;&#36234;&#26469;&#36234;&#27969;&#34892;&#65292;&#29978;&#33267;GPIO controller&#20063;&#21487;&#20197;&#34987;&#30475;&#20986;&#19968;&#20010;interrupt controller chip&#65292;&#36825;&#26679;&#65292;&#31995;&#32479;&#20013;&#33267;&#23569;&#26377;&#20004;&#20010;&#20013;&#26029;&#25511;&#21046;&#22120;&#20102;&#65292;&#19968;&#20010;&#20256;&#32479;&#24847;&#20041;&#30340;&#20013;&#26029;&#25511;&#21046;&#22120;&#65292;&#19968;&#20010;&#26159;GPIO controller type&#30340;&#20013;&#26029;&#25511;&#21046;&#22120;&#12290;&#38543;&#30528;&#31995;&#32479;&#22797;&#26434;&#24230;&#21152;&#22823;&#65292;&#22806;&#35774;&#20013;&#26029;&#25968;&#25454;&#22686;&#21152;&#65292;&#23454;&#38469;&#19978;&#31995;&#32479;&#21487;&#20197;&#38656;&#35201;&#22810;&#20010;&#20013;&#26029;&#25511;&#21046;&#22120;&#36827;&#34892;&#32423;&#32852;&#65292;&#38754;&#23545;&#36825;&#26679;&#30340;&#36235;&#21183;&#65292;linux kernel&#24037;&#31243;&#24072;&#22914;&#20309;&#24212;&#23545;&#65311;&#31572;&#26696;&#23601;&#26159;irq domain&#36825;&#20010;&#27010;&#24565;&#12290; </P>
<P>&#25105;&#20204;&#21548;&#35828;&#36807;&#24456;&#22810;&#30340;domain&#65292;power domain&#65292;clock domain&#31561;&#31561;&#65292;&#25152;&#35859;domain&#65292;&#23601;&#26159;&#39046;&#22495;&#65292;&#33539;&#22260;&#30340;&#24847;&#24605;&#65292;&#20063;&#23601;&#26159;&#35828;&#65292;&#20219;&#20309;&#30340;&#23450;&#20041;&#20986;&#20102;&#36825;&#20010;&#33539;&#22260;&#23601;&#27809;&#26377;&#24847;&#20041;&#20102;&#12290;&#31995;&#32479;&#20013;&#25152;&#26377;&#30340;interrupt controller&#20250;&#24418;&#25104;&#26641;&#29366;&#32467;&#26500;&#65292;&#23545;&#20110;&#27599;&#20010;interrupt controller&#37117;&#21487;&#20197;&#36830;&#25509;&#33509;&#24178;&#20010;&#22806;&#35774;&#30340;&#20013;&#26029;&#35831;&#27714;&#65288;&#25105;&#20204;&#31216;&#20043;interrupt source&#65289;&#65292;interrupt controller&#20250;&#23545;&#36830;&#25509;&#20854;&#19978;&#30340;interrupt source&#65288;&#26681;&#25454;&#20854;&#22312;Interrupt controller&#20013;&#29289;&#29702;&#29305;&#24615;&#65289;&#36827;&#34892;&#32534;&#21495;&#65288;&#20063;&#23601;&#26159;HW interrupt ID&#20102;&#65289;&#12290;&#20294;&#36825;&#20010;&#32534;&#21495;&#20165;&#20165;&#38480;&#21046;&#22312;&#26412;interrupt controller&#33539;&#22260;&#20869;&#12290; </P>
<P>&nbsp; </P>
<P>&#19977;&#12289;&#25509;&#21475; </P>
<P>1&#12289;&#21521;&#31995;&#32479;&#27880;&#20876;irq domain </P>
<P>&#20855;&#20307;&#22914;&#20309;&#36827;&#34892;&#26144;&#23556;&#26159;interrupt controller&#33258;&#24049;&#30340;&#20107;&#24773;&#65292;&#19981;&#36807;&#65292;&#26377;&#36719;&#20214;&#26550;&#26500;&#24605;&#24819;&#30340;&#24037;&#31243;&#24072;&#26356;&#24895;&#24847;&#23545;&#24418;&#24418;&#33394;&#33394;&#30340;interrupt controller&#36827;&#34892;&#25277;&#35937;&#65292;&#23545;&#22914;&#20309;&#36827;&#34892;HW interrupt ID&#21040;IRQ number&#26144;&#23556;&#20851;&#31995;&#19978;&#36827;&#34892;&#36827;&#19968;&#27493;&#30340;&#25277;&#35937;&#12290;&#22240;&#27492;&#65292;&#36890;&#29992;&#20013;&#26029;&#22788;&#29702;&#27169;&#22359;&#20013;&#26377;&#19968;&#20010;irq domain&#30340;&#23376;&#27169;&#22359;&#65292;&#35813;&#27169;&#22359;&#23558;&#36825;&#31181;&#26144;&#23556;&#20851;&#31995;&#20998;&#25104;&#20102;&#19977;&#31867;&#65306; </P>
<P>&#65288;1&#65289;&#32447;&#24615;&#26144;&#23556;&#12290;&#20854;&#23454;&#23601;&#26159;&#19968;&#20010;lookup table&#65292;HW interrupt ID&#20316;&#20026;index&#65292;&#36890;&#36807;&#26597;&#34920;&#21487;&#20197;&#33719;&#21462;&#23545;&#24212;&#30340;IRQ number&#12290;&#23545;&#20110;Linear map&#32780;&#35328;&#65292;interrupt controller&#23545;&#20854;HW interrupt ID&#36827;&#34892;&#32534;&#30721;&#30340;&#26102;&#20505;&#35201;&#28385;&#36275;&#19968;&#23450;&#30340;&#26465;&#20214;&#65306;hw ID&#19981;&#33021;&#36807;&#22823;&#65292;&#32780;&#19988;ID&#25490;&#21015;&#26368;&#22909;&#26159;&#32039;&#23494;&#30340;&#12290;&#23545;&#20110;&#32447;&#24615;&#26144;&#23556;&#65292;&#20854;&#25509;&#21475;API&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>static inline struct irq_domain *irq_domain_add_linear(struct device_node *of_node, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int size,&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#35813;interrupt domain&#25903;&#25345;&#22810;&#23569;IRQ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct irq_domain_ops *ops,&#65293;&#65293;&#65293;callback&#20989;&#25968; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *host_data)&#65293;&#65293;&#65293;&#65293;&#65293;driver&#31169;&#26377;&#25968;&#25454; <BR>{ <BR>&nbsp;&nbsp;&nbsp; return __irq_domain_add(of_node, size, size, 0, ops, host_data); <BR>} </P></BLOCKQUOTE>
<P>&#65288;2&#65289;Radix Tree map&#12290;&#24314;&#31435;&#19968;&#20010;Radix Tree&#26469;&#32500;&#25252;HW interrupt ID&#21040;IRQ number&#26144;&#23556;&#20851;&#31995;&#12290;HW interrupt ID&#20316;&#20026;lookup key&#65292;&#22312;Radix Tree&#26816;&#32034;&#21040;IRQ number&#12290;&#22914;&#26524;&#30340;&#30830;&#19981;&#33021;&#28385;&#36275;&#32447;&#24615;&#26144;&#23556;&#30340;&#26465;&#20214;&#65292;&#21487;&#20197;&#32771;&#34385;Radix Tree map&#12290;&#23454;&#38469;&#19978;&#65292;&#20869;&#26680;&#20013;&#20351;&#29992;Radix Tree map&#30340;&#21482;&#26377;powerPC&#21644;MIPS&#30340;&#30828;&#20214;&#24179;&#21488;&#12290;&#23545;&#20110;Radix Tree map&#65292;&#20854;&#25509;&#21475;API&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>static inline struct irq_domain *irq_domain_add_tree(struct device_node *of_node, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct irq_domain_ops *ops, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *host_data) <BR>{ <BR>&nbsp;&nbsp;&nbsp; return __irq_domain_add(of_node, 0, ~0, 0, ops, host_data); <BR>} </P></BLOCKQUOTE>
<P>&#65288;3&#65289;no map&#12290;&#26377;&#20123;&#20013;&#26029;&#25511;&#21046;&#22120;&#24456;&#24378;&#65292;&#21487;&#20197;&#36890;&#36807;&#23492;&#23384;&#22120;&#37197;&#32622;HW interrupt ID&#32780;&#19981;&#26159;&#30001;&#29289;&#29702;&#36830;&#25509;&#20915;&#23450;&#30340;&#12290;&#20363;&#22914;PowerPC &#31995;&#32479;&#20351;&#29992;&#30340;MPIC (Multi-Processor Interrupt Controller)&#12290;&#22312;&#36825;&#31181;&#24773;&#20917;&#19979;&#65292;&#19981;&#38656;&#35201;&#36827;&#34892;&#26144;&#23556;&#65292;&#25105;&#20204;&#30452;&#25509;&#25226;IRQ number&#20889;&#20837;HW interrupt ID&#37197;&#32622;&#23492;&#23384;&#22120;&#23601;OK&#20102;&#65292;&#36825;&#26102;&#20505;&#65292;&#29983;&#25104;&#30340;HW interrupt ID&#23601;&#26159;IRQ number&#65292;&#20063;&#23601;&#19981;&#38656;&#35201;&#36827;&#34892;mapping&#20102;&#12290;&#23545;&#20110;&#36825;&#31181;&#31867;&#22411;&#30340;&#26144;&#23556;&#65292;&#20854;&#25509;&#21475;API&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>static inline struct irq_domain *irq_domain_add_nomap(struct device_node *of_node, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int max_irq, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct irq_domain_ops *ops, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *host_data) <BR>{ <BR>&nbsp;&nbsp;&nbsp; return __irq_domain_add(of_node, 0, max_irq, max_irq, ops, host_data); <BR>} </P></BLOCKQUOTE>
<P>&#36825;&#31867;&#25509;&#21475;&#30340;&#36923;&#36753;&#24456;&#31616;&#21333;&#65292;&#26681;&#25454;&#33258;&#24049;&#30340;&#26144;&#23556;&#31867;&#22411;&#65292;&#21021;&#22987;&#21270;struct irq_domain&#20013;&#30340;&#21508;&#20010;&#25104;&#21592;&#65292;&#35843;&#29992;__irq_domain_add&#23558;&#35813;irq domain&#25346;&#20837;irq_domain_list&#30340;&#20840;&#23616;&#21015;&#34920;&#12290; </P>
<P>2&#12289;&#20026;irq domain&#21019;&#24314;&#26144;&#23556; </P>
<P>&#19978;&#33410;&#30340;&#20869;&#23481;&#20027;&#35201;&#26159;&#21521;&#31995;&#32479;&#27880;&#20876;&#19968;&#20010;irq domain&#65292;&#20855;&#20307;HW interrupt ID&#21644;IRQ number&#30340;&#26144;&#23556;&#20851;&#31995;&#37117;&#26159;&#31354;&#30340;&#65292;&#22240;&#27492;&#65292;&#20855;&#20307;&#21508;&#20010;irq domain&#22914;&#20309;&#31649;&#29702;&#26144;&#23556;&#25152;&#38656;&#35201;&#30340;database&#36824;&#26159;&#38656;&#35201;&#24314;&#31435;&#30340;&#12290;&#20363;&#22914;&#65306;&#23545;&#20110;&#32447;&#24615;&#26144;&#23556;&#30340;irq domain&#65292;&#25105;&#20204;&#38656;&#35201;&#24314;&#31435;&#32447;&#24615;&#26144;&#23556;&#30340;lookup table&#65292;&#23545;&#20110;Radix Tree map&#65292;&#25105;&#20204;&#35201;&#25226;&#37027;&#20010;&#21453;&#24212;IRQ number&#21644;HW interrupt ID&#30340;Radix tree&#24314;&#31435;&#36215;&#26469;&#12290;&#21019;&#24314;&#26144;&#23556;&#26377;&#22235;&#20010;&#25509;&#21475;&#20989;&#25968;&#65306; </P>
<P>&#65288;1&#65289;&#35843;&#29992;irq_create_mapping&#20989;&#25968;&#24314;&#31435;HW interrupt ID&#21644;IRQ number&#30340;&#26144;&#23556;&#20851;&#31995;&#12290;&#35813;&#25509;&#21475;&#20989;&#25968;&#20197;irq domain&#21644;HW interrupt ID&#20026;&#21442;&#25968;&#65292;&#36820;&#22238;IRQ number&#65288;&#36825;&#20010;IRQ number&#26159;&#21160;&#24577;&#20998;&#37197;&#30340;&#65289;&#12290;&#35813;&#20989;&#25968;&#30340;&#21407;&#22411;&#23450;&#20041;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>extern unsigned int irq_create_mapping(struct irq_domain *host, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq); </P></BLOCKQUOTE>
<P>&#39537;&#21160;&#35843;&#29992;&#35813;&#20989;&#25968;&#30340;&#26102;&#20505;&#24517;&#39035;&#25552;&#20379;HW interrupt ID&#65292;&#20063;&#23601;&#26159;&#24847;&#21619;&#30528;driver&#30693;&#36947;&#33258;&#24049;&#20351;&#29992;&#30340;HW interrupt ID&#65292;&#32780;&#19968;&#33324;&#24773;&#20917;&#19979;&#65292;HW interrupt ID&#20854;&#23454;&#23545;&#20855;&#20307;&#30340;driver&#24212;&#35813;&#26159;&#19981;&#21487;&#35265;&#30340;&#65292;&#19981;&#36807;&#26377;&#20123;&#22330;&#26223;&#27604;&#36739;&#29305;&#27530;&#65292;&#20363;&#22914;GPIO&#31867;&#22411;&#30340;&#20013;&#26029;&#65292;&#23427;&#30340;HW interrupt ID&#21644;GPIO&#26377;&#30528;&#29305;&#23450;&#30340;&#20851;&#31995;&#65292;driver&#30693;&#36947;&#33258;&#24049;&#20351;&#29992;&#37027;&#20010;GPIO&#65292;&#20063;&#23601;&#26159;&#30693;&#36947;&#20351;&#29992;&#21738;&#19968;&#20010;HW interrupt ID&#20102;&#12290; </P>
<P>&#65288;2&#65289;irq_create_strict_mappings&#12290;&#36825;&#20010;&#25509;&#21475;&#20989;&#25968;&#29992;&#26469;&#20026;&#19968;&#32452;HW interrupt ID&#24314;&#31435;&#26144;&#23556;&#12290;&#20855;&#20307;&#20989;&#25968;&#30340;&#21407;&#22411;&#23450;&#20041;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>extern int irq_create_strict_mappings(struct irq_domain *domain, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int irq_base, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq_base, int count); </P></BLOCKQUOTE>
<P>&#65288;3&#65289;irq_create_of_mapping&#12290;&#30475;&#21040;&#20989;&#25968;&#21517;&#23383;&#20013;&#30340;of&#65288;open firmware&#65289;&#65292;&#25105;&#24819;&#20320;&#20063;&#21487;&#20197;&#29468;&#21040;&#20102;&#20960;&#20998;&#65292;&#36825;&#20010;&#25509;&#21475;&#24403;&#28982;&#26159;&#21033;&#29992;device tree&#36827;&#34892;&#26144;&#23556;&#20851;&#31995;&#30340;&#24314;&#31435;&#12290;&#20855;&#20307;&#20989;&#25968;&#30340;&#21407;&#22411;&#23450;&#20041;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>extern unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data); </P></BLOCKQUOTE>
<P>&#36890;&#24120;&#65292;&#19968;&#20010;&#26222;&#36890;&#35774;&#22791;&#30340;device tree node&#24050;&#32463;&#25551;&#36848;&#20102;&#36275;&#22815;&#30340;&#20013;&#26029;&#20449;&#24687;&#65292;&#22312;&#36825;&#31181;&#24773;&#20917;&#19979;&#65292;&#35813;&#35774;&#22791;&#30340;&#39537;&#21160;&#22312;&#21021;&#22987;&#21270;&#30340;&#26102;&#20505;&#21487;&#20197;&#35843;&#29992;irq_of_parse_and_map&#36825;&#20010;&#25509;&#21475;&#20989;&#25968;&#36827;&#34892;&#35813;device node&#20013;&#21644;&#20013;&#26029;&#30456;&#20851;&#30340;&#20869;&#23481;&#65288;interrupts&#21644;interrupt-parent&#23646;&#24615;&#65289;&#36827;&#34892;&#20998;&#26512;&#65292;&#24182;&#24314;&#31435;&#26144;&#23556;&#20851;&#31995;&#65292;&#20855;&#20307;&#20195;&#30721;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>unsigned int irq_of_parse_and_map(struct device_node *dev, int index) <BR>{ <BR>&nbsp;&nbsp;&nbsp; struct of_phandle_args oirq; </P>
<P>&nbsp;&nbsp;&nbsp; if (of_irq_parse_one(dev, index, &amp;oirq))&#65293;&#65293;&#65293;&#65293;&#20998;&#26512;device node&#20013;&#30340;interrupt&#30456;&#20851;&#23646;&#24615; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; </P>
<P>&nbsp;&nbsp;&nbsp; return irq_create_of_mapping(&amp;oirq);&#65293;&#65293;&#65293;&#65293;&#65293;&#21019;&#24314;&#26144;&#23556;&#65292;&#24182;&#36820;&#22238;&#23545;&#24212;&#30340;IRQ number <BR>} </P></BLOCKQUOTE>
<P>&#23545;&#20110;&#19968;&#20010;&#20351;&#29992;Device tree&#30340;&#26222;&#36890;&#39537;&#21160;&#31243;&#24207;&#65288;&#25105;&#20204;&#25512;&#33616;&#36825;&#26679;&#20570;&#65289;&#65292;&#22522;&#26412;&#19978;&#21021;&#22987;&#21270;&#38656;&#35201;&#35843;&#29992;irq_of_parse_and_map&#33719;&#21462;IRQ number&#65292;&#28982;&#21518;&#35843;&#29992;request_threaded_irq&#30003;&#35831;&#20013;&#26029;handler&#12290; </P>
<P>&#65288;4&#65289;irq_create_direct_mapping&#12290;&#36825;&#26159;&#32473;no map&#37027;&#31181;&#31867;&#22411;&#30340;interrupt controller&#20351;&#29992;&#30340;&#65292;&#36825;&#37324;&#19981;&#20877;&#36184;&#36848;&#12290; </P>
<P>&nbsp; </P>
<P>&#22235;&#12289;&#25968;&#25454;&#32467;&#26500;&#25551;&#36848; </P>
<P>1&#12289;irq domain&#30340;callback&#25509;&#21475; </P>
<P>struct irq_domain_ops&#25277;&#35937;&#20102;&#19968;&#20010;irq domain&#30340;callback&#20989;&#25968;&#65292;&#23450;&#20041;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>struct irq_domain_ops { <BR>&nbsp;&nbsp;&nbsp; int (*match)(struct irq_domain *d, struct device_node *node); <BR>&nbsp;&nbsp;&nbsp; int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw); <BR>&nbsp;&nbsp;&nbsp; void (*unmap)(struct irq_domain *d, unsigned int virq); <BR>&nbsp;&nbsp;&nbsp; int (*xlate)(struct irq_domain *d, struct device_node *node, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const u32 *intspec, unsigned int intsize, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long *out_hwirq, unsigned int *out_type); <BR>}; </P></BLOCKQUOTE>
<P>&#25105;&#20204;&#20808;&#30475;xlate&#20989;&#25968;&#65292;&#35821;&#20041;&#26159;&#32763;&#35793;&#65288;translate&#65289;&#30340;&#24847;&#24605;&#65292;&#37027;&#20040;&#21040;&#24213;&#32763;&#35793;&#20160;&#20040;&#21602;&#65311;&#22312;DTS&#25991;&#20214;&#20013;&#65292;&#21508;&#20010;&#20351;&#29992;&#20013;&#26029;&#30340;device node&#20250;&#36890;&#36807;&#19968;&#20123;&#23646;&#24615;&#65288;&#20363;&#22914;interrupts&#21644;interrupt-parent&#23646;&#24615;&#65289;&#26469;&#25552;&#20379;&#20013;&#26029;&#20449;&#24687;&#32473;kernel&#20197;&#20415;kernel&#21487;&#20197;&#27491;&#30830;&#30340;&#36827;&#34892;driver&#30340;&#21021;&#22987;&#21270;&#21160;&#20316;&#12290;&#36825;&#37324;&#65292;interrupts&#23646;&#24615;&#25152;&#34920;&#31034;&#30340;interrupt specifier&#21482;&#33021;&#30001;&#20855;&#20307;&#30340;interrupt controller&#65288;&#20063;&#23601;&#26159;irq domain&#65289;&#26469;&#35299;&#26512;&#12290;&#32780;xlate&#20989;&#25968;&#23601;&#26159;&#23558;&#25351;&#23450;&#30340;&#35774;&#22791;&#65288;node&#21442;&#25968;&#65289;&#19978;&#33509;&#24178;&#20010;&#65288;intsize&#21442;&#25968;&#65289;&#20013;&#26029;&#23646;&#24615;&#65288;intspec&#21442;&#25968;&#65289;&#32763;&#35793;&#25104;HW interrupt ID&#65288;out_hwirq&#21442;&#25968;&#65289;&#21644;trigger&#31867;&#22411;&#65288;out_type&#65289;&#12290; </P>
<P>match&#26159;&#21028;&#26029;&#19968;&#20010;&#25351;&#23450;&#30340;interrupt controller&#65288;node&#21442;&#25968;&#65289;&#26159;&#21542;&#21644;&#19968;&#20010;irq domain&#21305;&#37197;&#65288;d&#21442;&#25968;&#65289;&#65292;&#22914;&#26524;&#21305;&#37197;&#30340;&#35805;&#65292;&#36820;&#22238;1&#12290;&#23454;&#38469;&#19978;&#65292;&#20869;&#26680;&#20013;&#24456;&#23569;&#23450;&#20041;&#36825;&#20010;callback&#20989;&#25968;&#65292;&#23454;&#38469;&#19978;struct irq_domain&#20013;&#26377;&#19968;&#20010;of_node&#25351;&#21521;&#20102;&#23545;&#24212;&#30340;interrupt controller&#30340;device node&#65292;&#22240;&#27492;&#65292;&#22914;&#26524;&#19981;&#25552;&#20379;&#35813;&#20989;&#25968;&#65292;&#37027;&#20040;default&#30340;&#21305;&#37197;&#20989;&#25968;&#20854;&#23454;&#23601;&#26159;&#21028;&#26029;irq domain&#30340;of_node&#25104;&#21592;&#26159;&#21542;&#31561;&#20110;&#20256;&#20837;&#30340;node&#21442;&#25968;&#12290; </P>
<P>map&#21644;unmap&#26159;&#25805;&#20316;&#30456;&#21453;&#30340;&#20989;&#25968;&#65292;&#25105;&#20204;&#25551;&#36848;&#20854;&#20013;&#20043;&#19968;&#23601;OK&#20102;&#12290;&#35843;&#29992;map&#20989;&#25968;&#30340;&#26102;&#26426;&#26159;&#22312;&#21019;&#24314;&#65288;&#25110;&#32773;&#26356;&#26032;&#65289;HW interrupt ID&#65288;hw&#21442;&#25968;&#65289;&#21644;IRQ number&#65288;virq&#21442;&#25968;&#65289;&#20851;&#31995;&#30340;&#26102;&#20505;&#12290;&#20854;&#23454;&#65292;&#20174;&#21457;&#29983;&#19968;&#20010;&#20013;&#26029;&#21040;&#35843;&#29992;&#35813;&#20013;&#26029;&#30340;handler&#20165;&#20165;&#35843;&#29992;&#19968;&#20010;request_threaded_irq&#26159;&#19981;&#22815;&#30340;&#65292;&#36824;&#38656;&#35201;&#38024;&#23545;&#35813;irq number&#35774;&#23450;&#65306; </P>
<P>&#65288;1&#65289;&#35774;&#23450;&#35813;IRQ number&#23545;&#24212;&#30340;&#20013;&#26029;&#25551;&#36848;&#31526;&#65288;struct irq_desc&#65289;&#30340;irq chip </P>
<P>&#65288;2&#65289;&#35774;&#23450;&#35813;IRQ number&#23545;&#24212;&#30340;&#20013;&#26029;&#25551;&#36848;&#31526;&#30340;highlevel irq-events handler </P>
<P>&#65288;3&#65289;&#35774;&#23450;&#35813;IRQ number&#23545;&#24212;&#30340;&#20013;&#26029;&#25551;&#36848;&#31526;&#30340; irq chip data </P>
<P>&#36825;&#20123;&#35774;&#23450;&#19981;&#36866;&#21512;&#30001;&#20855;&#20307;&#30340;&#30828;&#20214;&#39537;&#21160;&#26469;&#35774;&#23450;&#65292;&#22240;&#27492;&#22312;Interrupt controller&#65292;&#20063;&#23601;&#26159;irq domain&#30340;callback&#20989;&#25968;&#20013;&#35774;&#23450;&#12290; </P>
<P>2&#12289;irq domain </P>
<P>&#22312;&#20869;&#26680;&#20013;&#65292;irq domain&#30340;&#27010;&#24565;&#30001;struct irq_domain&#34920;&#31034;&#65306; </P>
<BLOCKQUOTE>
<P>struct irq_domain { <BR>&nbsp;&nbsp;&nbsp; struct list_head link; <BR>&nbsp;&nbsp;&nbsp; const char *name; <BR>&nbsp;&nbsp;&nbsp; const struct irq_domain_ops *ops; &#65293;&#65293;&#65293;&#65293;callback&#20989;&#25968; <BR>&nbsp;&nbsp;&nbsp; void *host_data; </P>
<P>&nbsp;&nbsp;&nbsp; /* Optional data */ <BR>&nbsp;&nbsp;&nbsp; struct device_node *of_node; &#65293;&#65293;&#65293;&#65293;&#35813;interrupt domain&#23545;&#24212;&#30340;interrupt controller&#30340;device node <BR>&nbsp;&nbsp;&nbsp; struct irq_domain_chip_generic *gc; &#65293;&#65293;&#65293;generic irq chip&#30340;&#27010;&#24565;&#65292;&#26412;&#25991;&#26242;&#19981;&#25551;&#36848; </P>
<P>&nbsp;&nbsp;&nbsp; /* reverse map data. The linear map gets appended to the irq_domain */ <BR>&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq_max; &#65293;&#65293;&#65293;&#65293;&#35813;domain&#20013;&#26368;&#22823;&#30340;&#37027;&#20010;HW interrupt ID <BR>&nbsp;&nbsp;&nbsp; unsigned int revmap_direct_max_irq; &#65293;&#65293;&#65293;&#65293; <BR>&nbsp;&nbsp;&nbsp; unsigned int revmap_size; &#65293;&#65293;&#65293;&#32447;&#24615;&#26144;&#23556;&#30340;size&#65292;for Radix Tree map&#21644;no map&#65292;&#35813;&#20540;&#31561;&#20110;0 <BR>&nbsp;&nbsp;&nbsp; struct radix_tree_root revmap_tree; &#65293;&#65293;&#65293;&#65293;Radix Tree map&#20351;&#29992;&#21040;&#30340;radix tree root node <BR>&nbsp;&nbsp;&nbsp; unsigned int linear_revmap[]; &#65293;&#65293;&#65293;&#65293;&#65293;&#32447;&#24615;&#26144;&#23556;&#20351;&#29992;&#30340;lookup table <BR>}; </P></BLOCKQUOTE>
<P>linux&#20869;&#26680;&#20013;&#65292;&#25152;&#26377;&#30340;irq domain&#34987;&#25346;&#20837;&#19968;&#20010;&#20840;&#23616;&#38142;&#34920;&#65292;&#38142;&#34920;&#22836;&#23450;&#20041;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>static LIST_HEAD(irq_domain_list); </P></BLOCKQUOTE>
<P>struct irq_domain&#20013;&#30340;link&#25104;&#21592;&#23601;&#26159;&#25346;&#20837;&#36825;&#20010;&#38431;&#21015;&#30340;&#33410;&#28857;&#12290;&#36890;&#36807;irq_domain_list&#36825;&#20010;&#25351;&#38024;&#65292;&#21487;&#20197;&#33719;&#21462;&#25972;&#20010;&#31995;&#32479;&#20013;HW interrupt ID&#21644;IRQ number&#30340;mapping DB&#12290;host_data&#23450;&#20041;&#20102;&#24213;&#23618;interrupt controller&#20351;&#29992;&#30340;&#31169;&#26377;&#25968;&#25454;&#65292;&#21644;&#20855;&#20307;&#30340;interrupt controller&#30456;&#20851;&#65288;&#23545;&#20110;GIC&#65292;&#35813;&#25351;&#38024;&#25351;&#21521;&#19968;&#20010;struct gic_chip_data&#25968;&#25454;&#32467;&#26500;&#65289;&#12290; </P>
<P>&#23545;&#20110;&#32447;&#24615;&#26144;&#23556;&#65306; </P>
<P>&#65288;1&#65289;linear_revmap&#20445;&#23384;&#20102;&#19968;&#20010;&#32447;&#24615;&#30340;lookup table&#65292;index&#26159;HW interrupt ID&#65292;table&#20013;&#20445;&#23384;&#20102;IRQ number&#20540; </P>
<P>&#65288;2&#65289;revmap_size&#31561;&#20110;&#32447;&#24615;&#30340;lookup table&#30340;size&#12290; </P>
<P>&#65288;3&#65289;hwirq_max&#20445;&#23384;&#20102;&#26368;&#22823;&#30340;HW interrupt ID </P>
<P>&#65288;4&#65289;revmap_direct_max_irq&#27809;&#26377;&#29992;&#65292;&#35774;&#23450;&#20026;0&#12290;revmap_tree&#27809;&#26377;&#29992;&#12290; </P>
<P>&#23545;&#20110;Radix Tree map&#65306; </P>
<P>&#65288;1&#65289;linear_revmap&#27809;&#26377;&#29992;&#65292;revmap_size&#31561;&#20110;0&#12290; </P>
<P>&#65288;2&#65289;hwirq_max&#27809;&#26377;&#29992;&#65292;&#35774;&#23450;&#20026;&#19968;&#20010;&#26368;&#22823;&#20540;&#12290; </P>
<P>&#65288;3&#65289;revmap_direct_max_irq&#27809;&#26377;&#29992;&#65292;&#35774;&#23450;&#20026;0&#12290; </P>
<P>&#65288;4&#65289;revmap_tree&#25351;&#21521;Radix tree&#30340;root node&#12290; </P>
<P>&nbsp; </P>
<P>&#20116;&#12289;&#20013;&#26029;&#30456;&#20851;&#30340;Device Tree&#30693;&#35782;&#22238;&#39038; </P>
<P>&#24819;&#35201;&#36827;&#34892;&#26144;&#23556;&#65292;&#39318;&#20808;&#35201;&#20102;&#35299;interrupt controller&#30340;&#25299;&#25169;&#32467;&#26500;&#12290;&#31995;&#32479;&#20013;&#30340;interrupt controller&#30340;&#25299;&#25169;&#32467;&#26500;&#20197;&#21450;&#20854;interrupt request line&#30340;&#20998;&#37197;&#24773;&#20917;&#65288;&#20998;&#37197;&#32473;&#21738;&#19968;&#20010;&#20855;&#20307;&#30340;&#22806;&#35774;&#65289;&#37117;&#22312;Device Tree Source&#25991;&#20214;&#20013;&#36890;&#36807;&#19979;&#38754;&#30340;&#23646;&#24615;&#32473;&#20986;&#20102;&#25551;&#36848;&#12290;&#36825;&#20123;&#20869;&#23481;&#22312;Device Tree&#30340;&#19977;&#20221;&#25991;&#26723;&#20013;&#32473;&#20986;&#20102;&#19968;&#20123;&#25551;&#36848;&#65292;&#36825;&#37324;&#31616;&#21333;&#24635;&#32467;&#19968;&#19979;&#65306; </P>
<P>&#23545;&#20110;&#37027;&#20123;&#20135;&#29983;&#20013;&#26029;&#30340;&#22806;&#35774;&#65292;&#25105;&#20204;&#38656;&#35201;&#23450;&#20041;interrupt-parent&#21644;interrupts&#23646;&#24615;&#65306; </P>
<P>&#65288;1&#65289;interrupt-parent&#12290;&#34920;&#26126;&#35813;&#22806;&#35774;&#30340;interrupt request line&#29289;&#29702;&#30340;&#36830;&#25509;&#21040;&#20102;&#21738;&#19968;&#20010;&#20013;&#26029;&#25511;&#21046;&#22120;&#19978; </P>
<P>&#65288;2&#65289;interrupts&#12290;&#36825;&#20010;&#23646;&#24615;&#25551;&#36848;&#20102;&#20855;&#20307;&#35813;&#22806;&#35774;&#20135;&#29983;&#30340;interrupt&#30340;&#32454;&#33410;&#20449;&#24687;&#65288;&#20063;&#23601;&#26159;&#20256;&#35828;&#20013;&#30340;interrupt specifier&#65289;&#12290;&#20363;&#22914;&#65306;HW interrupt ID&#65288;&#30001;&#35813;&#22806;&#35774;&#30340;device node&#20013;&#30340;interrupt-parent&#25351;&#21521;&#30340;interrupt controller&#35299;&#26512;&#65289;&#12289;interrupt&#35302;&#21457;&#31867;&#22411;&#31561;&#12290; </P>
<P>&#23545;&#20110;Interrupt controller&#65292;&#25105;&#20204;&#38656;&#35201;&#23450;&#20041;interrupt-controller&#21644;#interrupt-cells&#30340;&#23646;&#24615;&#65306; </P>
<P>&#65288;1&#65289;interrupt-controller&#12290;&#34920;&#26126;&#35813;device node&#23601;&#26159;&#19968;&#20010;&#20013;&#26029;&#25511;&#21046;&#22120; </P>
<P>&#65288;2&#65289;#interrupt-cells&#12290;&#35813;&#20013;&#26029;&#25511;&#21046;&#22120;&#29992;&#22810;&#23569;&#20010;cell&#65288;&#19968;&#20010;cell&#23601;&#26159;&#19968;&#20010;32-bit&#30340;&#21333;&#20803;&#65289;&#25551;&#36848;&#19968;&#20010;&#22806;&#35774;&#30340;interrupt request line&#12290;&#65311;&#20855;&#20307;&#27599;&#20010;cell&#34920;&#31034;&#20160;&#20040;&#26679;&#30340;&#21547;&#20041;&#30001;interrupt controller&#33258;&#24049;&#23450;&#20041;&#12290; </P>
<P>&#65288;3&#65289;interrupts&#21644;interrupt-parent&#12290;&#23545;&#20110;&#37027;&#20123;&#19981;&#26159;root &#30340;interrupt controller&#65292;&#20854;&#26412;&#36523;&#20063;&#26159;&#20316;&#20026;&#19968;&#20010;&#20135;&#29983;&#20013;&#26029;&#30340;&#22806;&#35774;&#36830;&#25509;&#21040;&#20854;&#20182;&#30340;interrupt controller&#19978;&#65292;&#22240;&#27492;&#20063;&#38656;&#35201;&#23450;&#20041;interrupts&#21644;interrupt-parent&#30340;&#23646;&#24615;&#12290; </P>
<P>&nbsp; </P>
<P>&#20845;&#12289;Mapping DB&#30340;&#24314;&#31435; </P>
<P>1&#12289;&#27010;&#36848; </P>
<P>&#31995;&#32479;&#20013;HW interrupt ID&#21644;IRQ number&#30340;mapping DB&#26159;&#22312;&#25972;&#20010;&#31995;&#32479;&#21021;&#22987;&#21270;&#30340;&#36807;&#31243;&#20013;&#24314;&#31435;&#36215;&#26469;&#30340;&#65292;&#36807;&#31243;&#22914;&#19979;&#65306; </P>
<P>&#65288;1&#65289;DTS&#25991;&#20214;&#25551;&#36848;&#20102;&#31995;&#32479;&#20013;&#30340;interrupt controller&#20197;&#21450;&#22806;&#35774;IRQ&#30340;&#25299;&#25169;&#32467;&#26500;&#65292;&#22312;linux kernel&#21551;&#21160;&#30340;&#26102;&#20505;&#65292;&#30001;bootloader&#20256;&#36882;&#32473;kernel&#65288;&#23454;&#38469;&#20256;&#36882;&#30340;&#26159;DTB&#65289;&#12290; </P>
<P>&#65288;2&#65289;&#22312;Device Tree&#21021;&#22987;&#21270;&#30340;&#26102;&#20505;&#65292;&#24418;&#25104;&#20102;&#31995;&#32479;&#20869;&#25152;&#26377;&#30340;device node&#30340;&#26641;&#29366;&#32467;&#26500;&#65292;&#24403;&#28982;&#20854;&#20013;&#21253;&#25324;&#25152;&#26377;&#21644;&#20013;&#26029;&#25299;&#25169;&#30456;&#20851;&#30340;&#25968;&#25454;&#32467;&#26500;&#65288;&#25152;&#26377;&#30340;interrupt controller&#30340;node&#21644;&#20351;&#29992;&#20013;&#26029;&#30340;&#22806;&#35774;node&#65289; </P>
<P>&#65288;3&#65289;&#22312;machine driver&#21021;&#22987;&#21270;&#30340;&#26102;&#20505;&#20250;&#35843;&#29992;of_irq_init&#20989;&#25968;&#65292;&#22312;&#35813;&#20989;&#25968;&#20013;&#20250;&#25195;&#25551;&#25152;&#26377;interrupt controller&#30340;&#33410;&#28857;&#65292;&#24182;&#35843;&#29992;&#36866;&#21512;&#30340;interrupt controller driver&#36827;&#34892;&#21021;&#22987;&#21270;&#12290;&#27627;&#26080;&#30097;&#38382;&#65292;&#21021;&#22987;&#21270;&#38656;&#35201;&#27880;&#24847;&#39034;&#24207;&#65292;&#39318;&#20808;&#21021;&#22987;&#21270;root&#65292;&#28982;&#21518;first level&#65292;second level&#65292;&#26368;&#22909;&#26159;leaf node&#12290;&#22312;&#21021;&#22987;&#21270;&#30340;&#36807;&#31243;&#20013;&#65292;&#19968;&#33324;&#20250;&#35843;&#29992;&#19978;&#33410;&#20013;&#30340;&#25509;&#21475;&#20989;&#25968;&#21521;&#31995;&#32479;&#22686;&#21152;irq domain&#12290;&#26377;&#20123;interrupt controller&#20250;&#22312;&#20854;driver&#21021;&#22987;&#21270;&#30340;&#36807;&#31243;&#20013;&#21019;&#24314;&#26144;&#23556; </P>
<P>&#65288;4&#65289;&#22312;&#21508;&#20010;driver&#21021;&#22987;&#21270;&#30340;&#36807;&#31243;&#20013;&#65292;&#21019;&#24314;&#26144;&#23556; </P>
<P>&nbsp; </P>
<P>2&#12289; interrupt controller&#21021;&#22987;&#21270;&#30340;&#36807;&#31243;&#20013;&#65292;&#27880;&#20876;irq domain </P>
<P>&#25105;&#20204;&#20197;GIC&#30340;&#20195;&#30721;&#20026;&#20363;&#12290;&#20855;&#20307;&#20195;&#30721;&#22312;gic_of_init-&gt;gic_init_bases&#20013;&#65292;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>void __init gic_init_bases(unsigned int gic_nr, int irq_start, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void __iomem *dist_base, void __iomem *cpu_base, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u32 percpu_offset, struct device_node *node) <BR>{ <BR>&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq_base; <BR>&nbsp;&nbsp;&nbsp; struct gic_chip_data *gic; <BR>&nbsp;&nbsp;&nbsp; int gic_irqs, irq_base, i; </P>
<P>&#8230;&#8230; <BR>&#23545;&#20110;root GIC <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwirq_base = 16; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gic_irqs = &#31995;&#32479;&#25903;&#25345;&#30340;&#25152;&#26377;&#30340;&#20013;&#26029;&#25968;&#30446;&#65293;16&#12290;&#20043;&#25152;&#20197;&#20943;&#21435;16&#20027;&#35201;&#26159;&#22240;&#20026;root GIC&#30340;0&#65374;15&#21495;HW interrupt &#26159;for IPI&#30340;&#65292;&#22240;&#27492;&#35201;&#21435;&#25481;&#12290;&#20063;&#27491;&#22240;&#20026;&#22914;&#27492;hwirq_base&#20174;16&#24320;&#22987; </P>
<P><BR>&nbsp;&nbsp;&nbsp; irq_base = irq_alloc_descs(irq_start, 16, gic_irqs, numa_node_id());&#30003;&#35831;gic_irqs&#20010;IRQ&#36164;&#28304;&#65292;&#20174;16&#21495;&#24320;&#22987;&#25628;&#32034;IRQ number&#12290;&#30001;&#20110;&#26159;root GIC&#65292;&#30003;&#35831;&#30340;IRQ&#22522;&#26412;&#19978;&#20250;&#20174;16&#21495;&#24320;&#22987; </P>
<P><BR>&nbsp;&nbsp;&nbsp; gic-&gt;domain = irq_domain_add_legacy(node, gic_irqs, irq_base, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwirq_base, &amp;gic_irq_domain_ops, gic);&#65293;&#65293;&#65293;&#21521;&#31995;&#32479;&#27880;&#20876;irq domain&#24182;&#21019;&#24314;&#26144;&#23556; </P>
<P>&#8230;&#8230; <BR>} </P></BLOCKQUOTE>
<P>&#24456;&#36951;&#25022;&#65292;&#22312;GIC&#30340;&#20195;&#30721;&#20013;&#27809;&#26377;&#35843;&#29992;&#26631;&#20934;&#30340;&#27880;&#20876;irq domain&#30340;&#25509;&#21475;&#20989;&#25968;&#12290;&#35201;&#20102;&#35299;&#20854;&#32972;&#21518;&#30340;&#21407;&#22240;&#65292;&#25105;&#20204;&#38656;&#35201;&#22238;&#21040;&#36807;&#21435;&#12290;&#22312;&#26087;&#30340;linux kernel&#20013;&#65292;ARM&#20307;&#31995;&#32467;&#26500;&#30340;&#20195;&#30721;&#19981;&#29978;&#29702;&#24819;&#12290;&#22312;arch/arm&#30446;&#24405;&#20805;&#26021;&#20102;&#24456;&#22810;board specific&#30340;&#20195;&#30721;&#65292;&#20854;&#20013;&#23450;&#20041;&#20102;&#24456;&#22810;&#20855;&#20307;&#35774;&#22791;&#30456;&#20851;&#30340;&#38745;&#24577;&#34920;&#26684;&#65292;&#36825;&#20123;&#34920;&#26684;&#35268;&#23450;&#20102;&#21508;&#20010;device&#20351;&#29992;&#30340;&#36164;&#28304;&#65292;&#24403;&#28982;&#65292;&#20854;&#20013;&#21253;&#25324;IRQ&#36164;&#28304;&#12290;&#22312;&#36825;&#31181;&#24773;&#20917;&#19979;&#65292;&#21508;&#20010;&#22806;&#35774;&#30340;IRQ&#26159;&#22266;&#23450;&#30340;&#65288;&#22914;&#26524;&#20316;&#20026;&#39537;&#21160;&#31243;&#24207;&#21592;&#30340;&#20320;&#36275;&#22815;&#32769;&#30340;&#35805;&#65292;&#24212;&#35813;&#35760;&#24471;&#24456;&#38271;&#31687;&#24133;&#30340;&#38024;&#23545;IRQ number&#30340;&#23439;&#23450;&#20041;&#65289;&#65292;&#20063;&#23601;&#26159;&#35828;&#65292;HW interrupt ID&#21644;IRQ number&#30340;&#20851;&#31995;&#26159;&#22266;&#23450;&#30340;&#12290;&#19968;&#26086;&#20851;&#31995;&#22266;&#23450;&#65292;&#25105;&#20204;&#23601;&#21487;&#20197;&#22312;interupt controller&#30340;&#20195;&#30721;&#20013;&#21019;&#24314;&#36825;&#20123;&#26144;&#23556;&#20851;&#31995;&#12290;&#20855;&#20307;&#20195;&#30721;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>struct irq_domain *irq_domain_add_legacy(struct device_node *of_node, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int size, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int first_irq, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_hw_number_t first_hwirq, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct irq_domain_ops *ops, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *host_data) <BR>{ <BR>&nbsp;&nbsp;&nbsp; struct irq_domain *domain; </P>
<P>&nbsp;&nbsp;&nbsp; domain = __irq_domain_add(of_node, first_hwirq + size,&#65293;&#65293;&#65293;&#65293;&#27880;&#20876;irq domain <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first_hwirq + size, 0, ops, host_data); <BR>&nbsp;&nbsp;&nbsp; if (!domain) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL; </P>
<P>&nbsp;&nbsp;&nbsp; irq_domain_associate_many(domain, first_irq, first_hwirq, size); &#65293;&#65293;&#65293;&#21019;&#24314;&#26144;&#23556; </P>
<P>&nbsp;&nbsp;&nbsp; return domain; <BR>} </P></BLOCKQUOTE>
<P>&#36825;&#26102;&#20505;&#65292;&#23545;&#20110;&#36825;&#20010;&#29256;&#26412;&#30340;GIC driver&#32780;&#35328;&#65292;&#21021;&#22987;&#21270;&#20043;&#21518;&#65292;HW interrupt ID&#21644;IRQ number&#30340;&#26144;&#23556;&#20851;&#31995;&#24050;&#32463;&#24314;&#31435;&#65292;&#20445;&#23384;&#22312;&#32447;&#24615;lookup table&#20013;&#65292;size&#31561;&#20110;GIC&#25903;&#25345;&#30340;&#20013;&#26029;&#25968;&#30446;&#65292;&#20855;&#20307;&#22914;&#19979;&#65306; </P>
<P>index 0&#65374;15&#23545;&#24212;&#30340;IRQ&#26080;&#25928; </P>
<P>16&#21495;IRQ&nbsp; &lt;------------------&gt;16&#21495;HW interrupt ID </P>
<P>17&#21495;IRQ&nbsp; &lt;------------------&gt;17&#21495;HW interrupt ID </P>
<P>&#8230;&#8230; </P>
<P>&#22914;&#26524;&#24819;&#20805;&#20998;&#21457;&#25381;Device Tree&#30340;&#23041;&#21147;&#65292;3.14&#29256;&#26412;&#20013;&#30340;GIC &#20195;&#30721;&#38656;&#35201;&#20462;&#25913;&#12290; </P>
<P>&nbsp; </P>
<P>3&#12289;&#22312;&#21508;&#20010;&#30828;&#20214;&#22806;&#35774;&#30340;&#39537;&#21160;&#21021;&#22987;&#21270;&#36807;&#31243;&#20013;&#65292;&#21019;&#24314;HW interrupt ID&#21644;IRQ number&#30340;&#26144;&#23556;&#20851;&#31995; </P>
<P>&#25105;&#20204;&#19978;&#38754;&#30340;&#25551;&#36848;&#36807;&#31243;&#20013;&#65292;&#24050;&#32463;&#25552;&#21450;&#65306;&#35774;&#22791;&#30340;&#39537;&#21160;&#22312;&#21021;&#22987;&#21270;&#30340;&#26102;&#20505;&#21487;&#20197;&#35843;&#29992;irq_of_parse_and_map&#36825;&#20010;&#25509;&#21475;&#20989;&#25968;&#36827;&#34892;&#35813;device node&#20013;&#21644;&#20013;&#26029;&#30456;&#20851;&#30340;&#20869;&#23481;&#65288;interrupts&#21644;interrupt-parent&#23646;&#24615;&#65289;&#36827;&#34892;&#20998;&#26512;&#65292;&#24182;&#24314;&#31435;&#26144;&#23556;&#20851;&#31995;&#65292;&#20855;&#20307;&#20195;&#30721;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>unsigned int irq_of_parse_and_map(struct device_node *dev, int index) <BR>{ <BR>&nbsp;&nbsp;&nbsp; struct of_phandle_args oirq; </P>
<P>&nbsp;&nbsp;&nbsp; if (of_irq_parse_one(dev, index, &amp;oirq))&#65293;&#65293;&#65293;&#65293;&#20998;&#26512;device node&#20013;&#30340;interrupt&#30456;&#20851;&#23646;&#24615; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; </P>
<P>&nbsp;&nbsp;&nbsp; return irq_create_of_mapping(&amp;oirq);&#65293;&#65293;&#65293;&#65293;&#65293;&#21019;&#24314;&#26144;&#23556; <BR>} </P></BLOCKQUOTE>
<P>&#25105;&#20204;&#20877;&#26469;&#30475;&#30475;irq_create_of_mapping&#20989;&#25968;&#22914;&#20309;&#21019;&#24314;&#26144;&#23556;&#65306; </P>
<BLOCKQUOTE>
<P>unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data) <BR>{ <BR>&nbsp;&nbsp;&nbsp; struct irq_domain *domain; <BR>&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq; <BR>&nbsp;&nbsp;&nbsp; unsigned int type = IRQ_TYPE_NONE; <BR>&nbsp;&nbsp;&nbsp; unsigned int virq; </P>
<P>&nbsp;&nbsp;&nbsp; domain = irq_data-&gt;np ? irq_find_host(irq_data-&gt;np) : irq_default_domain;&#65293;&#65293;A <BR>&nbsp;&nbsp;&nbsp; if (!domain) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; <BR>&nbsp;&nbsp;&nbsp; } </P>
<P><BR>&nbsp;&nbsp;&nbsp; if (domain-&gt;ops-&gt;xlate == NULL)&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;B <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwirq = irq_data-&gt;args[0]; <BR>&nbsp;&nbsp;&nbsp; else { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (domain-&gt;ops-&gt;xlate(domain, irq_data-&gt;np, irq_data-&gt;args,&#65293;&#65293;&#65293;&#65293;C <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_data-&gt;args_count, &amp;hwirq, &amp;type)) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; <BR>&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp; /* Create mapping */ <BR>&nbsp;&nbsp;&nbsp; virq = irq_create_mapping(domain, hwirq);&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;D <BR>&nbsp;&nbsp;&nbsp; if (!virq) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return virq; </P>
<P>&nbsp;&nbsp;&nbsp; /* Set type if specified and different than the current one */ <BR>&nbsp;&nbsp;&nbsp; if (type != IRQ_TYPE_NONE &amp;&amp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type != irq_get_trigger_type(virq)) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_set_irq_type(virq, type);&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;E <BR>&nbsp;&nbsp;&nbsp; return virq; <BR>} </P></BLOCKQUOTE>
<P>A&#65306;&#36825;&#37324;&#30340;&#20195;&#30721;&#20027;&#35201;&#26159;&#25214;&#21040;irq domain&#12290;&#36825;&#26159;&#26681;&#25454;&#20256;&#36882;&#36827;&#26469;&#30340;&#21442;&#25968;irq_data&#30340;np&#25104;&#21592;&#26469;&#23547;&#25214;&#30340;&#65292;&#20855;&#20307;&#23450;&#20041;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>struct of_phandle_args { <BR>&nbsp;&nbsp;&nbsp; struct device_node *np;&#65293;&#65293;&#65293;&#25351;&#21521;&#20102;&#22806;&#35774;&#23545;&#24212;&#30340;interrupt controller&#30340;device node <BR>&nbsp;&nbsp;&nbsp; int args_count;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#35813;&#22806;&#35774;&#23450;&#20041;&#30340;interrupt&#30456;&#20851;&#23646;&#24615;&#30340;&#20010;&#25968; <BR>&nbsp;&nbsp;&nbsp; uint32_t args[MAX_PHANDLE_ARGS];&#65293;&#65293;&#65293;&#65293;&#20855;&#20307;&#30340;interrupt&#30456;&#24403;&#23646;&#24615;&#30340;&#23450;&#20041; <BR>}; </P></BLOCKQUOTE>
<P>B&#65306;&#22914;&#26524;&#27809;&#26377;&#23450;&#20041;xlate&#20989;&#25968;&#65292;&#37027;&#20040;&#21462;interrupts&#23646;&#24615;&#30340;&#31532;&#19968;&#20010;cell&#20316;&#20026;HW interrupt ID&#12290; </P>
<P>C&#65306;&#35299;&#38083;&#36824;&#38656;&#31995;&#38083;&#20154;&#65292;interrupts&#23646;&#24615;&#26368;&#22909;&#30001;interrupt controller&#65288;&#20063;&#23601;&#26159;irq domain&#65289;&#35299;&#37322;&#12290;&#22914;&#26524;xlate&#20989;&#25968;&#33021;&#22815;&#23436;&#25104;&#23646;&#24615;&#35299;&#26512;&#65292;&#37027;&#20040;&#23558;&#36755;&#20986;&#21442;&#25968;hwirq&#21644;type&#65292;&#20998;&#21035;&#34920;&#31034;HW interrupt ID&#21644;interupt type&#65288;&#35302;&#21457;&#26041;&#24335;&#31561;&#65289;&#12290; </P>
<P>D&#65306;&#35299;&#26512;&#23436;&#20102;&#65292;&#26368;&#32456;&#36824;&#26159;&#35201;&#35843;&#29992;irq_create_mapping&#20989;&#25968;&#26469;&#21019;&#24314;HW interrupt ID&#21644;IRQ number&#30340;&#26144;&#23556;&#20851;&#31995;&#12290; </P>
<P>E&#65306;&#22914;&#26524;&#26377;&#38656;&#35201;&#65292;&#35843;&#29992;irq_set_irq_type&#20989;&#25968;&#35774;&#23450;trigger type </P>
<P>irq_create_mapping&#20989;&#25968;&#24314;&#31435;HW interrupt ID&#21644;IRQ number&#30340;&#26144;&#23556;&#20851;&#31995;&#12290;&#35813;&#25509;&#21475;&#20989;&#25968;&#20197;irq domain&#21644;HW interrupt ID&#20026;&#21442;&#25968;&#65292;&#36820;&#22238;IRQ number&#12290;&#20855;&#20307;&#30340;&#20195;&#30721;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>unsigned int irq_create_mapping(struct irq_domain *domain, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq) <BR>{ <BR>&nbsp;&nbsp;&nbsp; unsigned int hint; <BR>&nbsp;&nbsp;&nbsp; int virq; </P>
<P>&#22914;&#26524;&#26144;&#23556;&#24050;&#32463;&#23384;&#22312;&#65292;&#37027;&#20040;&#19981;&#38656;&#35201;&#26144;&#23556;&#65292;&#30452;&#25509;&#36820;&#22238; <BR>&nbsp;&nbsp;&nbsp; virq = irq_find_mapping(domain, hwirq); <BR>&nbsp;&nbsp;&nbsp; if (virq) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return virq; <BR>&nbsp;&nbsp;&nbsp; } </P>
<P><BR>&nbsp;&nbsp;&nbsp; hint = hwirq % nr_irqs;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#65293;&#20998;&#37197;&#19968;&#20010;IRQ &#25551;&#36848;&#31526;&#20197;&#21450;&#23545;&#24212;&#30340;irq number <BR>&nbsp;&nbsp;&nbsp; if (hint == 0) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hint++; <BR>&nbsp;&nbsp;&nbsp; virq = irq_alloc_desc_from(hint, of_node_to_nid(domain-&gt;of_node)); <BR>&nbsp;&nbsp;&nbsp; if (virq &lt;= 0) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virq = irq_alloc_desc_from(1, of_node_to_nid(domain-&gt;of_node)); <BR>&nbsp;&nbsp;&nbsp; if (virq &lt;= 0) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr_debug("-&gt; virq allocation failed\n"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; <BR>&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp; if (irq_domain_associate(domain, virq, hwirq)) {&#65293;&#65293;&#65293;&#24314;&#31435;mapping <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_free_desc(virq); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; <BR>&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp; return virq; <BR>} </P></BLOCKQUOTE>
<P>&#23545;&#20110;&#20998;&#37197;&#20013;&#26029;&#25551;&#36848;&#31526;&#36825;&#27573;&#20195;&#30721;&#65292;&#21518;&#32493;&#30340;&#25991;&#31456;&#20250;&#35814;&#32454;&#25551;&#36848;&#12290;&#36825;&#37324;&#31616;&#21333;&#30053;&#36807;&#65292;&#21453;&#27491;&#65292;&#25351;&#21521;&#23436;&#36825;&#27573;&#20195;&#30721;&#65292;&#25105;&#20204;&#23601;&#21487;&#20197;&#25110;&#32773;&#19968;&#20010;IRQ number&#20197;&#21450;&#20854;&#23545;&#24212;&#30340;&#20013;&#26029;&#25551;&#36848;&#31526;&#20102;&#12290;&#31243;&#24207;&#27880;&#37322;&#20013;&#27809;&#26377;&#20351;&#29992;IRQ number&#32780;&#26159;&#20351;&#29992;&#20102;virtual interrupt number&#36825;&#20010;&#26415;&#35821;&#12290;virtual interrupt number&#36824;&#26159;&#37325;&#28857;&#29702;&#35299;&#8220;virtual&#8221;&#36825;&#20010;&#35789;&#65292;&#25152;&#35859;virtual&#65292;&#20854;&#23454;&#23601;&#26159;&#35828;&#21644;&#20855;&#20307;&#30340;&#30828;&#20214;&#36830;&#25509;&#27809;&#26377;&#20851;&#31995;&#20102;&#65292;&#20165;&#20165;&#26159;&#19968;&#20010;number&#32780;&#24050;&#12290;&#20855;&#20307;&#24314;&#31435;&#26144;&#23556;&#30340;&#20989;&#25968;&#26159;irq_domain_associate&#20989;&#25968;&#65292;&#20195;&#30721;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>int irq_domain_associate(struct irq_domain *domain, unsigned int virq, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq) <BR>{ <BR>&nbsp;&nbsp;&nbsp; struct irq_data *irq_data = irq_get_irq_data(virq); <BR>&nbsp;&nbsp;&nbsp; int ret; </P>
<P>&nbsp;&nbsp;&nbsp; mutex_lock(&amp;irq_domain_mutex); <BR>&nbsp;&nbsp;&nbsp; irq_data-&gt;hwirq = hwirq; <BR>&nbsp;&nbsp;&nbsp; irq_data-&gt;domain = domain; <BR>&nbsp;&nbsp;&nbsp; if (domain-&gt;ops-&gt;map) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = domain-&gt;ops-&gt;map(domain, virq, hwirq);&#65293;&#65293;&#65293;&#35843;&#29992;irq domain&#30340;map callback&#20989;&#25968; <BR>&nbsp;&nbsp;&nbsp; } </P>
<P>&nbsp;&nbsp;&nbsp; if (hwirq &lt; domain-&gt;revmap_size) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; domain-&gt;linear_revmap[hwirq] = virq;&#65293;&#65293;&#65293;&#65293;&#22635;&#20889;&#32447;&#24615;&#26144;&#23556;lookup table&#30340;&#25968;&#25454; <BR>&nbsp;&nbsp;&nbsp; } else { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutex_lock(&amp;revmap_trees_mutex); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radix_tree_insert(&amp;domain-&gt;revmap_tree, hwirq, irq_data);&#65293;&#65293;&#21521;radix tree&#25554;&#20837;&#19968;&#20010;node <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutex_unlock(&amp;revmap_trees_mutex); <BR>&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp; mutex_unlock(&amp;irq_domain_mutex); </P>
<P>&nbsp;&nbsp;&nbsp; irq_clear_status_flags(virq, IRQ_NOREQUEST); &#65293;&#65293;&#65293;&#35813;IRQ&#24050;&#32463;&#21487;&#20197;&#30003;&#35831;&#20102;&#65292;&#22240;&#27492;clear&#30456;&#20851;flag </P>
<P>&nbsp;&nbsp;&nbsp; return 0; <BR>} </P></BLOCKQUOTE>
<P>&nbsp; </P>
<P>&#19971;&#12289;&#23558;HW interrupt ID&#36716;&#25104;IRQ number </P>
<P>&#21019;&#24314;&#20102;&#24222;&#22823;&#30340;HW interrupt ID&#21040;IRQ number&#30340;mapping DB&#65292;&#26368;&#32456;&#36824;&#26159;&#35201;&#20351;&#29992;&#12290;&#20855;&#20307;&#30340;&#20351;&#29992;&#22330;&#26223;&#26159;&#22312;CPU&#30456;&#20851;&#30340;&#22788;&#29702;&#20989;&#25968;&#20013;&#65292;&#31243;&#24207;&#20250;&#35835;&#21462;&#30828;&#20214;interrupt ID&#65292;&#24182;&#36716;&#25104;IRQ number&#65292;&#35843;&#29992;&#23545;&#24212;&#30340;irq event handler&#12290;&#22312;&#26412;&#31456;&#20013;&#65292;&#25105;&#20204;&#20197;&#19968;&#20010;&#32423;&#32852;&#30340;GIC&#31995;&#32479;&#20026;&#20363;&#65292;&#25551;&#36848;&#36716;&#25442;&#36807;&#31243; </P>
<P>1&#12289;GIC driver&#21021;&#22987;&#21270; </P>
<P>&#19978;&#38754;&#24050;&#32463;&#25551;&#36848;&#20102;root GIC&#30340;&#30340;&#21021;&#22987;&#21270;&#65292;&#25105;&#20204;&#20877;&#26469;&#30475;&#30475;second GIC&#30340;&#21021;&#22987;&#21270;&#12290;&#20855;&#20307;&#20195;&#30721;&#22312;gic_of_init-&gt;gic_init_bases&#20013;&#65292;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>void __init gic_init_bases(unsigned int gic_nr, int irq_start, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void __iomem *dist_base, void __iomem *cpu_base, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u32 percpu_offset, struct device_node *node) <BR>{ <BR>&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq_base; <BR>&nbsp;&nbsp;&nbsp; struct gic_chip_data *gic; <BR>&nbsp;&nbsp;&nbsp; int gic_irqs, irq_base, i; </P>
<P>&#8230;&#8230; <BR>&#23545;&#20110;second GIC <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwirq_base = 32;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gic_irqs = &#31995;&#32479;&#25903;&#25345;&#30340;&#25152;&#26377;&#30340;&#20013;&#26029;&#25968;&#30446;&#65293;32&#12290;&#20043;&#25152;&#20197;&#20943;&#21435;32&#20027;&#35201;&#26159;&#22240;&#20026;&#23545;&#20110;second GIC&#65292;&#20854;0&#65374;15&#21495;HW interrupt &#26159;for IPI&#30340;&#65292;&#22240;&#27492;&#35201;&#21435;&#25481;&#12290;&#32780;16&#65374;31&#21495;HW interrupt &#26159;for PPI&#30340;&#65292;&#20063;&#35201;&#21435;&#25481;&#12290;&#20063;&#27491;&#22240;&#20026;&#22914;&#27492;hwirq_base&#20174;32&#24320;&#22987; </P>
<P><BR>&nbsp;&nbsp;&nbsp; irq_base = irq_alloc_descs(irq_start, 16, gic_irqs, numa_node_id());&#30003;&#35831;gic_irqs&#20010;IRQ&#36164;&#28304;&#65292;&#20174;16&#21495;&#24320;&#22987;&#25628;&#32034;IRQ number&#12290;&#30001;&#20110;&#26159;second GIC&#65292;&#30003;&#35831;&#30340;IRQ&#22522;&#26412;&#19978;&#20250;&#20174;root GIC&#30003;&#35831;&#30340;&#26368;&#21518;&#19968;&#20010;IRQ&#21495;&#65291;1&#24320;&#22987; </P>
<P><BR>&nbsp;&nbsp;&nbsp; gic-&gt;domain = irq_domain_add_legacy(node, gic_irqs, irq_base, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwirq_base, &amp;gic_irq_domain_ops, gic);&#65293;&#65293;&#65293;&#21521;&#31995;&#32479;&#27880;&#20876;irq domain&#24182;&#21019;&#24314;&#26144;&#23556; </P>
<P>&#8230;&#8230; <BR>} </P></BLOCKQUOTE>
<P>second GIC&#21021;&#22987;&#21270;&#20043;&#21518;&#65292;&#35813;irq domain&#30340;HW interrupt ID&#21644;IRQ number&#30340;&#26144;&#23556;&#20851;&#31995;&#24050;&#32463;&#24314;&#31435;&#65292;&#20445;&#23384;&#22312;&#32447;&#24615;lookup table&#20013;&#65292;size&#31561;&#20110;GIC&#25903;&#25345;&#30340;&#20013;&#26029;&#25968;&#30446;&#65292;&#20855;&#20307;&#22914;&#19979;&#65306; </P>
<P>index 0&#65374;32&#23545;&#24212;&#30340;IRQ&#26080;&#25928; </P>
<P>root GIC&#30003;&#35831;&#30340;&#26368;&#21518;&#19968;&#20010;IRQ&#21495;&#65291;1&nbsp; &lt;------------------&gt;32&#21495;HW interrupt ID </P>
<P>root GIC&#30003;&#35831;&#30340;&#26368;&#21518;&#19968;&#20010;IRQ&#21495;&#65291;2&nbsp; &lt;------------------&gt;33&#21495;HW interrupt ID </P>
<P>&#8230;&#8230; </P>
<P>OK&#65292;&#25105;&#20204;&#22238;&#21040;gic&#30340;&#21021;&#22987;&#21270;&#20989;&#25968;&#65292;&#23545;&#20110;second GIC&#65292;&#36824;&#26377;&#20854;&#20182;&#37096;&#20998;&#30340;&#21021;&#22987;&#21270;&#20869;&#23481;&#65306; </P>
<BLOCKQUOTE>
<P>int __init gic_of_init(struct device_node *node, struct device_node *parent) <BR>{ </P>
<P>&#8230;&#8230; </P>
<P>&nbsp;&nbsp;&nbsp; if (parent) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq = irq_of_parse_and_map(node, 0);&#65293;&#65293;&#35299;&#26512;second GIC&#30340;interrupts&#23646;&#24615;&#65292;&#24182;&#36827;&#34892;mapping&#65292;&#36820;&#22238;IRQ number <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gic_cascade_irq(gic_cnt, irq);&#65293;&#65293;&#65293;&#35774;&#32622;handler <BR>&nbsp;&nbsp;&nbsp; } <BR>&#8230;&#8230; <BR>} </P></BLOCKQUOTE>
<P>&#19978;&#38754;&#30340;&#21021;&#22987;&#21270;&#20989;&#25968;&#21435;&#25481;&#21644;&#32423;&#32852;&#26080;&#20851;&#30340;&#20195;&#30721;&#12290;&#23545;&#20110;root GIC&#65292;&#20854;&#20256;&#20837;&#30340;parent&#26159;NULL&#65292;&#22240;&#27492;&#19981;&#20250;&#25191;&#34892;&#32423;&#32852;&#37096;&#20998;&#30340;&#20195;&#30721;&#12290;&#23545;&#20110;second GIC&#65292;&#23427;&#26159;&#20316;&#20026;&#20854;parent&#65288;root GIC&#65289;&#30340;&#19968;&#20010;&#26222;&#36890;&#30340;irq source&#65292;&#22240;&#27492;&#65292;&#20063;&#38656;&#35201;&#27880;&#20876;&#35813;IRQ&#30340;handler&#12290;&#30001;&#27492;&#21487;&#35265;&#65292;&#38750;root&#30340;GIC&#30340;&#21021;&#22987;&#21270;&#20998;&#25104;&#20102;&#20004;&#20010;&#37096;&#20998;&#65306;&#19968;&#37096;&#20998;&#26159;&#20316;&#20026;&#19968;&#20010;interrupt controller&#65292;&#25191;&#34892;&#21644;root GIC&#19968;&#26679;&#30340;&#21021;&#22987;&#21270;&#20195;&#30721;&#12290;&#21478;&#22806;&#19968;&#26041;&#38754;&#65292;GIC&#21448;&#20316;&#20026;&#19968;&#20010;&#26222;&#36890;&#30340;interrupt generating device&#65292;&#38656;&#35201;&#35937;&#19968;&#20010;&#26222;&#36890;&#30340;&#35774;&#22791;&#39537;&#21160;&#19968;&#26679;&#65292;&#27880;&#20876;&#20854;&#20013;&#26029;handler&#12290; </P>
<P>irq_of_parse_and_map&#20989;&#25968;&#30456;&#20449;&#22823;&#23478;&#24050;&#32463;&#29087;&#24713;&#20102;&#65292;&#36825;&#37324;&#19981;&#20877;&#25551;&#36848;&#12290;gic_cascade_irq&#20989;&#25968;&#22914;&#19979;&#65306; </P>
<BLOCKQUOTE>
<P>void __init gic_cascade_irq(unsigned int gic_nr, unsigned int irq) <BR>{ <BR>&nbsp;&nbsp;&nbsp; if (irq_set_handler_data(irq, &amp;gic_data[gic_nr]) != 0)&#65293;&#65293;&#65293;&#35774;&#32622;handler data <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUG(); <BR>&nbsp;&nbsp;&nbsp; irq_set_chained_handler(irq, gic_handle_cascade_irq);&#65293;&#65293;&#65293;&#35774;&#32622;handler <BR>} </P></BLOCKQUOTE>
<P>2&#12289;&#20855;&#20307;&#22914;&#20309;&#22312;&#20013;&#26029;&#22788;&#29702;&#36807;&#31243;&#20013;&#65292;&#23558;HW interrupt ID&#36716;&#25104;IRQ number </P>
<P>&#22312;&#31995;&#32479;&#30340;&#21551;&#21160;&#36807;&#31243;&#20013;&#65292;&#32463;&#36807;&#20102;&#21508;&#20010;interrupt controller&#20197;&#21450;&#21508;&#20010;&#22806;&#35774;&#39537;&#21160;&#30340;&#21162;&#21147;&#65292;&#25972;&#20010;interrupt&#31995;&#32479;&#30340;database&#65288;&#23558;HW interrupt ID&#36716;&#25104;IRQ number&#30340;&#25968;&#25454;&#24211;&#65292;&#36825;&#37324;&#30340;&#25968;&#25454;&#24211;&#19981;&#26159;&#25351;SQL lite&#25110;&#32773;oracle&#36825;&#26679;&#36890;&#29992;&#25968;&#25454;&#24211;&#36719;&#20214;&#65289;&#24050;&#32463;&#24314;&#31435;&#12290;&#19968;&#26086;&#21457;&#29983;&#30828;&#20214;&#20013;&#26029;&#65292;&#32463;&#36807;CPU architecture&#30456;&#20851;&#30340;&#20013;&#26029;&#20195;&#30721;&#20043;&#21518;&#65292;&#20250;&#35843;&#29992;irq handler&#65292;&#35813;&#20989;&#25968;&#30340;&#19968;&#33324;&#36807;&#31243;&#22914;&#19979;&#65306; </P>
<P>&#65288;1&#65289;&#39318;&#20808;&#25214;&#21040;root interrupt controller&#23545;&#24212;&#30340;irq domain&#12290; </P>
<P>&#65288;2&#65289;&#26681;&#25454;HW &#23492;&#23384;&#22120;&#20449;&#24687;&#21644;irq domain&#20449;&#24687;&#33719;&#21462;HW interrupt ID </P>
<P>&#65288;3&#65289;&#35843;&#29992;irq_find_mapping&#25214;&#21040;HW interrupt ID&#23545;&#24212;&#30340;irq number </P>
<P>&#65288;4&#65289;&#35843;&#29992;handle_IRQ&#65288;&#23545;&#20110;ARM&#24179;&#21488;&#65289;&#26469;&#22788;&#29702;&#35813;irq number </P>
<P>&#23545;&#20110;&#32423;&#32852;&#30340;&#24773;&#20917;&#65292;&#36807;&#31243;&#31867;&#20284;&#19978;&#38754;&#30340;&#25551;&#36848;&#65292;&#20294;&#26159;&#38656;&#35201;&#27880;&#24847;&#30340;&#26159;&#22312;&#27493;&#39588;4&#20013;&#19981;&#26159;&#30452;&#25509;&#35843;&#29992;&#35813;IRQ&#30340;hander&#26469;&#22788;&#29702;&#35813;irq number&#22240;&#20026;&#65292;&#36825;&#20010;irq&#38656;&#35201;&#21508;&#20010;interrupt controller level&#19978;&#30340;&#35299;&#26512;&#12290;&#20030;&#19968;&#20010;&#31616;&#21333;&#30340;&#20108;&#38454;&#32423;&#32852;&#24773;&#20917;&#65306;&#20551;&#35774;&#31995;&#32479;&#20013;&#26377;&#20004;&#20010;interrupt controller&#65292;A&#21644;B&#65292;A&#26159;root interrupt controller&#65292;B&#36830;&#25509;&#21040;A&#30340;13&#21495;HW interrupt ID&#19978;&#12290;&#22312;B interrupt controller&#21021;&#22987;&#21270;&#30340;&#26102;&#20505;&#65292;&#38500;&#20102;&#21021;&#22987;&#21270;&#23427;&#20316;&#20026;interrupt controller&#30340;&#37027;&#37096;&#20998;&#20869;&#23481;&#65292;&#36824;&#26377;&#21021;&#22987;&#21270;&#23427;&#20316;&#20026;root interrupt controller A&#19978;&#30340;&#19968;&#20010;&#26222;&#36890;&#22806;&#35774;&#36825;&#37096;&#20998;&#30340;&#20869;&#23481;&#12290;&#26368;&#37325;&#35201;&#30340;&#26159;&#35843;&#29992;irq_set_chained_handler&#35774;&#23450;handler&#12290;&#36825;&#26679;&#65292;&#22312;&#19978;&#38754;&#30340;&#27493;&#39588;4&#30340;&#26102;&#20505;&#65292;&#23601;&#20250;&#35843;&#29992;13&#21495;HW interrupt ID&#23545;&#24212;&#30340;handler&#65288;&#20063;&#23601;&#26159;B&#30340;handler&#65289;&#65292;&#22312;&#35813;handler&#20013;&#65292;&#20250;&#37325;&#22797;&#19978;&#38754;&#30340;&#65288;1&#65289;&#65374;&#65288;4&#65289;&#12290;