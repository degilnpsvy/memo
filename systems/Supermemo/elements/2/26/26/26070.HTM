#ifdef __KERNEL__ 
<P></P>
<P>#include &lt;linux/vmalloc.h&gt;<BR><FONT class=extract>#define __io_virt(x) ((void __force *)(x))</FONT></P>
<P><FONT class=extract>#ifndef CONFIG_GENERIC_IOMAP<BR>struct pci_dev;<BR>extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);</FONT></P>
<P><FONT class=extract>#ifndef pci_iounmap<BR>#define pci_iounmap pci_iounmap<BR>static inline void pci_iounmap(struct pci_dev *dev, void __iomem *p)<BR>{<BR>}<BR>#endif<BR>#endif /* CONFIG_GENERIC_IOMAP */</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Change virtual addresses to physical addresses and vv.<BR>&nbsp;* These are pretty trivial<BR>&nbsp;*/<BR>#ifndef virt_to_phys<BR>#define virt_to_phys virt_to_phys<BR>static inline unsigned long virt_to_phys(volatile void *address)<BR>{<BR>&nbsp;return __pa((unsigned long)address);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef phys_to_virt<BR>#define phys_to_virt phys_to_virt<BR>static inline void *phys_to_virt(unsigned long address)<BR>{<BR>&nbsp;return __va(address);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Change "struct page" to physical address.<BR>&nbsp;*<BR>&nbsp;* This implementation is for the no-MMU case only... if you have an MMU<BR>&nbsp;* you'll need to provide your own definitions.<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>#ifndef CONFIG_MMU<BR>#ifndef ioremap<BR>#define ioremap ioremap<BR>static inline void __iomem *ioremap(phys_addr_t offset, size_t size)<BR>{<BR>&nbsp;return (void __iomem *)(unsigned long)offset;<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef __ioremap<BR>#define __ioremap __ioremap<BR>static inline void __iomem *__ioremap(phys_addr_t offset, size_t size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long flags)<BR>{<BR>&nbsp;return ioremap(offset, size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioremap_nocache<BR>#define ioremap_nocache ioremap_nocache<BR>static inline void __iomem *ioremap_nocache(phys_addr_t offset, size_t size)<BR>{<BR>&nbsp;return ioremap(offset, size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioremap_uc<BR>#define ioremap_uc ioremap_uc<BR>static inline void __iomem *ioremap_uc(phys_addr_t offset, size_t size)<BR>{<BR>&nbsp;return ioremap_nocache(offset, size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioremap_wc<BR>#define ioremap_wc ioremap_wc<BR>static inline void __iomem *ioremap_wc(phys_addr_t offset, size_t size)<BR>{<BR>&nbsp;return ioremap_nocache(offset, size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioremap_wt<BR>#define ioremap_wt ioremap_wt<BR>static inline void __iomem *ioremap_wt(phys_addr_t offset, size_t size)<BR>{<BR>&nbsp;return ioremap_nocache(offset, size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef iounmap<BR>#define iounmap iounmap</FONT></P>
<P><FONT class=extract>static inline void iounmap(void __iomem *addr)<BR>{<BR>}<BR>#endif<BR>#endif /* CONFIG_MMU */</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_HAS_IOPORT_MAP<BR>#ifndef CONFIG_GENERIC_IOMAP<BR>#ifndef ioport_map<BR>#define ioport_map ioport_map<BR>static inline void __iomem *ioport_map(unsigned long port, unsigned int nr)<BR>{<BR>&nbsp;return PCI_IOBASE + (port &amp; IO_SPACE_LIMIT);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioport_unmap<BR>#define ioport_unmap ioport_unmap<BR>static inline void ioport_unmap(void __iomem *p)<BR>{<BR>}<BR>#endif<BR>#else /* CONFIG_GENERIC_IOMAP */<BR>extern void __iomem *ioport_map(unsigned long port, unsigned int nr);<BR>extern void ioport_unmap(void __iomem *p);<BR>#endif /* CONFIG_GENERIC_IOMAP */<BR>#endif /* CONFIG_HAS_IOPORT_MAP */</FONT></P>
<P><FONT class=extract>#ifndef xlate_dev_kmem_ptr<BR>#define xlate_dev_kmem_ptr xlate_dev_kmem_ptr<BR>static inline void *xlate_dev_kmem_ptr(void *addr)<BR>{<BR>&nbsp;return addr;<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef xlate_dev_mem_ptr<BR>#define xlate_dev_mem_ptr xlate_dev_mem_ptr<BR>static inline void *xlate_dev_mem_ptr(phys_addr_t addr)<BR>{<BR>&nbsp;return __va(addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef unxlate_dev_mem_ptr<BR>#define unxlate_dev_mem_ptr unxlate_dev_mem_ptr<BR>static inline void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr)<BR>{<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_VIRT_TO_BUS<BR>#ifndef virt_to_bus<BR>static inline unsigned long virt_to_bus(void *address)<BR>{<BR>&nbsp;return (unsigned long)address;<BR>}</FONT></P>
<P><FONT class=extract>static inline void *bus_to_virt(unsigned long address)<BR>{<BR>&nbsp;return (void *)address;<BR>}<BR>#endif<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef memset_io<BR>#define memset_io memset_io<BR>static inline void memset_io(volatile void __iomem *addr, int value,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size)<BR>{<BR>&nbsp;memset(__io_virt(addr), value, size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef memcpy_fromio<BR>#define memcpy_fromio memcpy_fromio<BR>static inline void memcpy_fromio(void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const volatile void __iomem *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp; size_t size)<BR>{<BR>&nbsp;memcpy(buffer, __io_virt(addr), size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef memcpy_toio<BR>#define memcpy_toio memcpy_toio<BR>static inline void memcpy_toio(volatile void __iomem *addr, const void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size)<BR>{<BR>&nbsp;memcpy(__io_virt(addr), buffer, size);<BR>}<BR>#endif</FONT></P>
<P>#endif /* __KERNEL__ */