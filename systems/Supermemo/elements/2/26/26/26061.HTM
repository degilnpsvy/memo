# /linux-4.1/include/asm-generic/io.h 
<P></P>
<P>/* Generic I/O port emulation, based on MN10300 code<BR>&nbsp;*<BR>&nbsp;* Copyright (C) 2007 Red Hat, Inc. All Rights Reserved.<BR>&nbsp;* Written by David Howells (<A href="mailto:dhowells@redhat.com">dhowells@redhat.com</A>)<BR>&nbsp;*<BR>&nbsp;* This program is free software; you can redistribute it and/or<BR>&nbsp;* modify it under the terms of the GNU General Public Licence<BR>&nbsp;* as published by the Free Software Foundation; either version<BR>&nbsp;* 2 of the Licence, or (at your option) any later version.<BR>&nbsp;*/<BR>#ifndef __ASM_GENERIC_IO_H<BR>#define __ASM_GENERIC_IO_H</P>
<P></P>
<P>#include &lt;asm/page.h&gt; /* I/O is all done through memory accesses */<BR>#include &lt;linux/string.h&gt; /* for memset() and memcpy() */<BR>#include &lt;linux/types.h&gt;</P>
<P>#ifdef CONFIG_GENERIC_IOMAP<BR>#include &lt;asm-generic/iomap.h&gt;<BR>#endif</P>
<P>#include &lt;asm-generic/pci_iomap.h&gt;</P>
<P><FONT class=extract>#ifndef mmiowb<BR>#define mmiowb() do {} while (0)<BR>#endif</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* __raw_{read,write}{b,w,l,q}() access memory in native endianness.<BR>&nbsp;*<BR>&nbsp;* On some architectures memory mapped IO needs to be accessed differently.<BR>&nbsp;* On the simple architectures, we just read/write the memory location<BR>&nbsp;* directly.<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>#ifndef __raw_readb<BR>#define __raw_readb __raw_readb<BR>static inline u8 __raw_readb(const volatile void __iomem *addr)<BR>{<BR>&nbsp;return *(const volatile u8 __force *)addr;<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef __raw_readw<BR>#define __raw_readw __raw_readw<BR>static inline u16 __raw_readw(const volatile void __iomem *addr)<BR>{<BR>&nbsp;return *(const volatile u16 __force *)addr;<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef __raw_readl<BR>#define __raw_readl __raw_readl<BR>static inline u32 __raw_readl(const volatile void __iomem *addr)<BR>{<BR>&nbsp;return *(const volatile u32 __force *)addr;<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_64BIT<BR>#ifndef __raw_readq<BR>#define __raw_readq __raw_readq<BR>static inline u64 __raw_readq(const volatile void __iomem *addr)<BR>{<BR>&nbsp;return *(const volatile u64 __force *)addr;<BR>}<BR>#endif<BR>#endif /* CONFIG_64BIT */</FONT></P>
<P><FONT class=extract>#ifndef __raw_writeb<BR>#define __raw_writeb __raw_writeb<BR>static inline void __raw_writeb(u8 value, volatile void __iomem *addr)<BR>{<BR>&nbsp;*(volatile u8 __force *)addr = value;<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef __raw_writew<BR>#define __raw_writew __raw_writew<BR>static inline void __raw_writew(u16 value, volatile void __iomem *addr)<BR>{<BR>&nbsp;*(volatile u16 __force *)addr = value;<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef __raw_writel<BR>#define __raw_writel __raw_writel<BR>static inline void __raw_writel(u32 value, volatile void __iomem *addr)<BR>{<BR>&nbsp;*(volatile u32 __force *)addr = value;<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_64BIT<BR>#ifndef __raw_writeq<BR>#define __raw_writeq __raw_writeq<BR>static inline void __raw_writeq(u64 value, volatile void __iomem *addr)<BR>{<BR>&nbsp;*(volatile u64 __force *)addr = value;<BR>}<BR>#endif<BR>#endif /* CONFIG_64BIT */</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* {read,write}{b,w,l,q}() access little endian memory and return result in<BR>&nbsp;* native endianness.<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>#ifndef readb<BR>#define readb readb<BR>static inline u8 readb(const volatile void __iomem *addr)<BR>{<BR>&nbsp;return __raw_readb(addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef readw<BR>#define readw readw<BR>static inline u16 readw(const volatile void __iomem *addr)<BR>{<BR>&nbsp;return __le16_to_cpu(__raw_readw(addr));<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef readl<BR>#define readl readl<BR>static inline u32 readl(const volatile void __iomem *addr)<BR>{<BR>&nbsp;return __le32_to_cpu(__raw_readl(addr));<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_64BIT<BR>#ifndef readq<BR>#define readq readq<BR>static inline u64 readq(const volatile void __iomem *addr)<BR>{<BR>&nbsp;return __le64_to_cpu(__raw_readq(addr));<BR>}<BR>#endif<BR>#endif /* CONFIG_64BIT */</FONT></P>
<P><FONT class=extract>#ifndef writeb<BR>#define writeb writeb<BR>static inline void writeb(u8 value, volatile void __iomem *addr)<BR>{<BR>&nbsp;__raw_writeb(value, addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef writew<BR>#define writew writew<BR>static inline void writew(u16 value, volatile void __iomem *addr)<BR>{<BR>&nbsp;__raw_writew(cpu_to_le16(value), addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef writel<BR>#define writel writel<BR>static inline void writel(u32 value, volatile void __iomem *addr)<BR>{<BR>&nbsp;__raw_writel(__cpu_to_le32(value), addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_64BIT<BR>#ifndef writeq<BR>#define writeq writeq<BR>static inline void writeq(u64 value, volatile void __iomem *addr)<BR>{<BR>&nbsp;__raw_writeq(__cpu_to_le64(value), addr);<BR>}<BR>#endif<BR>#endif /* CONFIG_64BIT */</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* {read,write}{b,w,l,q}_relaxed() are like the regular version, but<BR>&nbsp;* are not guaranteed to provide ordering against spinlocks or memory<BR>&nbsp;* accesses.<BR>&nbsp;*/<BR>#ifndef readb_relaxed<BR>#define readb_relaxed readb<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef readw_relaxed<BR>#define readw_relaxed readw<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef readl_relaxed<BR>#define readl_relaxed readl<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef readq_relaxed<BR>#define readq_relaxed readq<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef writeb_relaxed<BR>#define writeb_relaxed writeb<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef writew_relaxed<BR>#define writew_relaxed writew<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef writel_relaxed<BR>#define writel_relaxed writel<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef writeq_relaxed<BR>#define writeq_relaxed writeq<BR>#endif</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* {read,write}s{b,w,l,q}() repeatedly access the same memory address in<BR>&nbsp;* native endianness in 8-, 16-, 32- or 64-bit chunks (@count times).<BR>&nbsp;*/<BR>#ifndef readsb<BR>#define readsb readsb<BR>static inline void readsb(const volatile void __iomem *addr, void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;if (count) {<BR>&nbsp;&nbsp;u8 *buf = buffer;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;do {<BR>&nbsp;&nbsp;&nbsp;u8 x = __raw_readb(addr);<BR>&nbsp;&nbsp;&nbsp;*buf++ = x;<BR>&nbsp;&nbsp;} while (--count);<BR>&nbsp;}<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef readsw<BR>#define readsw readsw<BR>static inline void readsw(const volatile void __iomem *addr, void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;if (count) {<BR>&nbsp;&nbsp;u16 *buf = buffer;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;do {<BR>&nbsp;&nbsp;&nbsp;u16 x = __raw_readw(addr);<BR>&nbsp;&nbsp;&nbsp;*buf++ = x;<BR>&nbsp;&nbsp;} while (--count);<BR>&nbsp;}<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef readsl<BR>#define readsl readsl<BR>static inline void readsl(const volatile void __iomem *addr, void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;if (count) {<BR>&nbsp;&nbsp;u32 *buf = buffer;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;do {<BR>&nbsp;&nbsp;&nbsp;u32 x = __raw_readl(addr);<BR>&nbsp;&nbsp;&nbsp;*buf++ = x;<BR>&nbsp;&nbsp;} while (--count);<BR>&nbsp;}<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_64BIT<BR>#ifndef readsq<BR>#define readsq readsq<BR>static inline void readsq(const volatile void __iomem *addr, void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;if (count) {<BR>&nbsp;&nbsp;u64 *buf = buffer;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;do {<BR>&nbsp;&nbsp;&nbsp;u64 x = __raw_readq(addr);<BR>&nbsp;&nbsp;&nbsp;*buf++ = x;<BR>&nbsp;&nbsp;} while (--count);<BR>&nbsp;}<BR>}<BR>#endif<BR>#endif /* CONFIG_64BIT */</FONT></P>
<P><FONT class=extract>#ifndef writesb<BR>#define writesb writesb<BR>static inline void writesb(volatile void __iomem *addr, const void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;if (count) {<BR>&nbsp;&nbsp;const u8 *buf = buffer;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;do {<BR>&nbsp;&nbsp;&nbsp;__raw_writeb(*buf++, addr);<BR>&nbsp;&nbsp;} while (--count);<BR>&nbsp;}<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef writesw<BR>#define writesw writesw<BR>static inline void writesw(volatile void __iomem *addr, const void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;if (count) {<BR>&nbsp;&nbsp;const u16 *buf = buffer;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;do {<BR>&nbsp;&nbsp;&nbsp;__raw_writew(*buf++, addr);<BR>&nbsp;&nbsp;} while (--count);<BR>&nbsp;}<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef writesl<BR>#define writesl writesl<BR>static inline void writesl(volatile void __iomem *addr, const void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;if (count) {<BR>&nbsp;&nbsp;const u32 *buf = buffer;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;do {<BR>&nbsp;&nbsp;&nbsp;__raw_writel(*buf++, addr);<BR>&nbsp;&nbsp;} while (--count);<BR>&nbsp;}<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_64BIT<BR>#ifndef writesq<BR>#define writesq writesq<BR>static inline void writesq(volatile void __iomem *addr, const void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;if (count) {<BR>&nbsp;&nbsp;const u64 *buf = buffer;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;do {<BR>&nbsp;&nbsp;&nbsp;__raw_writeq(*buf++, addr);<BR>&nbsp;&nbsp;} while (--count);<BR>&nbsp;}<BR>}<BR>#endif<BR>#endif /* CONFIG_64BIT */</FONT></P>
<P><FONT class=extract>#ifndef PCI_IOBASE<BR>#define PCI_IOBASE ((void __iomem *)0)<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef IO_SPACE_LIMIT<BR>#define IO_SPACE_LIMIT 0xffff<BR>#endif</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* {in,out}{b,w,l}() access little endian I/O. {in,out}{b,w,l}_p() can be<BR>&nbsp;* implemented on hardware that needs an additional delay for I/O accesses to<BR>&nbsp;* take effect.<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>#ifndef inb<BR>#define inb inb<BR>static inline u8 inb(unsigned long addr)<BR>{<BR>&nbsp;return readb(PCI_IOBASE + addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef inw<BR>#define inw inw<BR>static inline u16 inw(unsigned long addr)<BR>{<BR>&nbsp;return readw(PCI_IOBASE + addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef inl<BR>#define inl inl<BR>static inline u32 inl(unsigned long addr)<BR>{<BR>&nbsp;return readl(PCI_IOBASE + addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef outb<BR>#define outb outb<BR>static inline void outb(u8 value, unsigned long addr)<BR>{<BR>&nbsp;writeb(value, PCI_IOBASE + addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef outw<BR>#define outw outw<BR>static inline void outw(u16 value, unsigned long addr)<BR>{<BR>&nbsp;writew(value, PCI_IOBASE + addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef outl<BR>#define outl outl<BR>static inline void outl(u32 value, unsigned long addr)<BR>{<BR>&nbsp;writel(value, PCI_IOBASE + addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef inb_p<BR>#define inb_p inb_p<BR>static inline u8 inb_p(unsigned long addr)<BR>{<BR>&nbsp;return inb(addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef inw_p<BR>#define inw_p inw_p<BR>static inline u16 inw_p(unsigned long addr)<BR>{<BR>&nbsp;return inw(addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef inl_p<BR>#define inl_p inl_p<BR>static inline u32 inl_p(unsigned long addr)<BR>{<BR>&nbsp;return inl(addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef outb_p<BR>#define outb_p outb_p<BR>static inline void outb_p(u8 value, unsigned long addr)<BR>{<BR>&nbsp;outb(value, addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef outw_p<BR>#define outw_p outw_p<BR>static inline void outw_p(u16 value, unsigned long addr)<BR>{<BR>&nbsp;outw(value, addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef outl_p<BR>#define outl_p outl_p<BR>static inline void outl_p(u32 value, unsigned long addr)<BR>{<BR>&nbsp;outl(value, addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* {in,out}s{b,w,l}{,_p}() are variants of the above that repeatedly access a<BR>&nbsp;* single I/O port multiple times.<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>#ifndef insb<BR>#define insb insb<BR>static inline void insb(unsigned long addr, void *buffer, unsigned int count)<BR>{<BR>&nbsp;readsb(PCI_IOBASE + addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef insw<BR>#define insw insw<BR>static inline void insw(unsigned long addr, void *buffer, unsigned int count)<BR>{<BR>&nbsp;readsw(PCI_IOBASE + addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef insl<BR>#define insl insl<BR>static inline void insl(unsigned long addr, void *buffer, unsigned int count)<BR>{<BR>&nbsp;readsl(PCI_IOBASE + addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef outsb<BR>#define outsb outsb<BR>static inline void outsb(unsigned long addr, const void *buffer,<BR>&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;writesb(PCI_IOBASE + addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef outsw<BR>#define outsw outsw<BR>static inline void outsw(unsigned long addr, const void *buffer,<BR>&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;writesw(PCI_IOBASE + addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef outsl<BR>#define outsl outsl<BR>static inline void outsl(unsigned long addr, const void *buffer,<BR>&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;writesl(PCI_IOBASE + addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef insb_p<BR>#define insb_p insb_p<BR>static inline void insb_p(unsigned long addr, void *buffer, unsigned int count)<BR>{<BR>&nbsp;insb(addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef insw_p<BR>#define insw_p insw_p<BR>static inline void insw_p(unsigned long addr, void *buffer, unsigned int count)<BR>{<BR>&nbsp;insw(addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef insl_p<BR>#define insl_p insl_p<BR>static inline void insl_p(unsigned long addr, void *buffer, unsigned int count)<BR>{<BR>&nbsp;insl(addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef outsb_p<BR>#define outsb_p outsb_p<BR>static inline void outsb_p(unsigned long addr, const void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;outsb(addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef outsw_p<BR>#define outsw_p outsw_p<BR>static inline void outsw_p(unsigned long addr, const void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;outsw(addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef outsl_p<BR>#define outsl_p outsl_p<BR>static inline void outsl_p(unsigned long addr, const void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;outsl(addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef CONFIG_GENERIC_IOMAP<BR>#ifndef ioread8<BR>#define ioread8 ioread8<BR>static inline u8 ioread8(const volatile void __iomem *addr)<BR>{<BR>&nbsp;return readb(addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioread16<BR>#define ioread16 ioread16<BR>static inline u16 ioread16(const volatile void __iomem *addr)<BR>{<BR>&nbsp;return readw(addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioread32<BR>#define ioread32 ioread32<BR>static inline u32 ioread32(const volatile void __iomem *addr)<BR>{<BR>&nbsp;return readl(addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef iowrite8<BR>#define iowrite8 iowrite8<BR>static inline void iowrite8(u8 value, volatile void __iomem *addr)<BR>{<BR>&nbsp;writeb(value, addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef iowrite16<BR>#define iowrite16 iowrite16<BR>static inline void iowrite16(u16 value, volatile void __iomem *addr)<BR>{<BR>&nbsp;writew(value, addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef iowrite32<BR>#define iowrite32 iowrite32<BR>static inline void iowrite32(u32 value, volatile void __iomem *addr)<BR>{<BR>&nbsp;writel(value, addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioread16be<BR>#define ioread16be ioread16be<BR>static inline u16 ioread16be(const volatile void __iomem *addr)<BR>{<BR>&nbsp;return __be16_to_cpu(__raw_readw(addr));<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioread32be<BR>#define ioread32be ioread32be<BR>static inline u32 ioread32be(const volatile void __iomem *addr)<BR>{<BR>&nbsp;return __be32_to_cpu(__raw_readl(addr));<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef iowrite16be<BR>#define iowrite16be iowrite16be<BR>static inline void iowrite16be(u16 value, void volatile __iomem *addr)<BR>{<BR>&nbsp;__raw_writew(__cpu_to_be16(value), addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef iowrite32be<BR>#define iowrite32be iowrite32be<BR>static inline void iowrite32be(u32 value, volatile void __iomem *addr)<BR>{<BR>&nbsp;__raw_writel(__cpu_to_be32(value), addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioread8_rep<BR>#define ioread8_rep ioread8_rep<BR>static inline void ioread8_rep(const volatile void __iomem *addr, void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;readsb(addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioread16_rep<BR>#define ioread16_rep ioread16_rep<BR>static inline void ioread16_rep(const volatile void __iomem *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;void *buffer, unsigned int count)<BR>{<BR>&nbsp;readsw(addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioread32_rep<BR>#define ioread32_rep ioread32_rep<BR>static inline void ioread32_rep(const volatile void __iomem *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;void *buffer, unsigned int count)<BR>{<BR>&nbsp;readsl(addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef iowrite8_rep<BR>#define iowrite8_rep iowrite8_rep<BR>static inline void iowrite8_rep(volatile void __iomem *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned int count)<BR>{<BR>&nbsp;writesb(addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef iowrite16_rep<BR>#define iowrite16_rep iowrite16_rep<BR>static inline void iowrite16_rep(volatile void __iomem *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;writesw(addr, buffer, count);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef iowrite32_rep<BR>#define iowrite32_rep iowrite32_rep<BR>static inline void iowrite32_rep(volatile void __iomem *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int count)<BR>{<BR>&nbsp;writesl(addr, buffer, count);<BR>}<BR>#endif<BR>#endif /* CONFIG_GENERIC_IOMAP */</FONT></P>
<P><FONT class=extract>#ifdef __KERNEL__</FONT></P>
<P><FONT class=extract>#include &lt;linux/vmalloc.h&gt;<BR>#define __io_virt(x) ((void __force *)(x))</FONT></P>
<P><FONT class=extract>#ifndef CONFIG_GENERIC_IOMAP<BR>struct pci_dev;<BR>extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);</FONT></P>
<P><FONT class=extract>#ifndef pci_iounmap<BR>#define pci_iounmap pci_iounmap<BR>static inline void pci_iounmap(struct pci_dev *dev, void __iomem *p)<BR>{<BR>}<BR>#endif<BR>#endif /* CONFIG_GENERIC_IOMAP */</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Change virtual addresses to physical addresses and vv.<BR>&nbsp;* These are pretty trivial<BR>&nbsp;*/<BR>#ifndef virt_to_phys<BR>#define virt_to_phys virt_to_phys<BR>static inline unsigned long virt_to_phys(volatile void *address)<BR>{<BR>&nbsp;return __pa((unsigned long)address);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef phys_to_virt<BR>#define phys_to_virt phys_to_virt<BR>static inline void *phys_to_virt(unsigned long address)<BR>{<BR>&nbsp;return __va(address);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Change "struct page" to physical address.<BR>&nbsp;*<BR>&nbsp;* This implementation is for the no-MMU case only... if you have an MMU<BR>&nbsp;* you'll need to provide your own definitions.<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>#ifndef CONFIG_MMU<BR>#ifndef ioremap<BR>#define ioremap ioremap<BR>static inline void __iomem *ioremap(phys_addr_t offset, size_t size)<BR>{<BR>&nbsp;return (void __iomem *)(unsigned long)offset;<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef __ioremap<BR>#define __ioremap __ioremap<BR>static inline void __iomem *__ioremap(phys_addr_t offset, size_t size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long flags)<BR>{<BR>&nbsp;return ioremap(offset, size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioremap_nocache<BR>#define ioremap_nocache ioremap_nocache<BR>static inline void __iomem *ioremap_nocache(phys_addr_t offset, size_t size)<BR>{<BR>&nbsp;return ioremap(offset, size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioremap_uc<BR>#define ioremap_uc ioremap_uc<BR>static inline void __iomem *ioremap_uc(phys_addr_t offset, size_t size)<BR>{<BR>&nbsp;return ioremap_nocache(offset, size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioremap_wc<BR>#define ioremap_wc ioremap_wc<BR>static inline void __iomem *ioremap_wc(phys_addr_t offset, size_t size)<BR>{<BR>&nbsp;return ioremap_nocache(offset, size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioremap_wt<BR>#define ioremap_wt ioremap_wt<BR>static inline void __iomem *ioremap_wt(phys_addr_t offset, size_t size)<BR>{<BR>&nbsp;return ioremap_nocache(offset, size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef iounmap<BR>#define iounmap iounmap</FONT></P>
<P><FONT class=extract>static inline void iounmap(void __iomem *addr)<BR>{<BR>}<BR>#endif<BR>#endif /* CONFIG_MMU */</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_HAS_IOPORT_MAP<BR>#ifndef CONFIG_GENERIC_IOMAP<BR>#ifndef ioport_map<BR>#define ioport_map ioport_map<BR>static inline void __iomem *ioport_map(unsigned long port, unsigned int nr)<BR>{<BR>&nbsp;return PCI_IOBASE + (port &amp; IO_SPACE_LIMIT);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef ioport_unmap<BR>#define ioport_unmap ioport_unmap<BR>static inline void ioport_unmap(void __iomem *p)<BR>{<BR>}<BR>#endif<BR>#else /* CONFIG_GENERIC_IOMAP */<BR>extern void __iomem *ioport_map(unsigned long port, unsigned int nr);<BR>extern void ioport_unmap(void __iomem *p);<BR>#endif /* CONFIG_GENERIC_IOMAP */<BR>#endif /* CONFIG_HAS_IOPORT_MAP */</FONT></P>
<P><FONT class=extract>#ifndef xlate_dev_kmem_ptr<BR>#define xlate_dev_kmem_ptr xlate_dev_kmem_ptr<BR>static inline void *xlate_dev_kmem_ptr(void *addr)<BR>{<BR>&nbsp;return addr;<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef xlate_dev_mem_ptr<BR>#define xlate_dev_mem_ptr xlate_dev_mem_ptr<BR>static inline void *xlate_dev_mem_ptr(phys_addr_t addr)<BR>{<BR>&nbsp;return __va(addr);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef unxlate_dev_mem_ptr<BR>#define unxlate_dev_mem_ptr unxlate_dev_mem_ptr<BR>static inline void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr)<BR>{<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_VIRT_TO_BUS<BR>#ifndef virt_to_bus<BR>static inline unsigned long virt_to_bus(void *address)<BR>{<BR>&nbsp;return (unsigned long)address;<BR>}</FONT></P>
<P><FONT class=extract>static inline void *bus_to_virt(unsigned long address)<BR>{<BR>&nbsp;return (void *)address;<BR>}<BR>#endif<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef memset_io<BR>#define memset_io memset_io<BR>static inline void memset_io(volatile void __iomem *addr, int value,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size)<BR>{<BR>&nbsp;memset(__io_virt(addr), value, size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef memcpy_fromio<BR>#define memcpy_fromio memcpy_fromio<BR>static inline void memcpy_fromio(void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const volatile void __iomem *addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp; size_t size)<BR>{<BR>&nbsp;memcpy(buffer, __io_virt(addr), size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#ifndef memcpy_toio<BR>#define memcpy_toio memcpy_toio<BR>static inline void memcpy_toio(volatile void __iomem *addr, const void *buffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size)<BR>{<BR>&nbsp;memcpy(__io_virt(addr), buffer, size);<BR>}<BR>#endif</FONT></P>
<P><FONT class=extract>#endif /* __KERNEL__ */</FONT></P>
<P>#endif /* __ASM_GENERIC_IO_H */