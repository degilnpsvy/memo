# /linux-4.1/kernel/irq/manage.c 
<P></P>
<P>/*<BR>&nbsp;* linux/kernel/irq/manage.c<BR>&nbsp;*<BR>&nbsp;* Copyright (C) 1992, 1998-2006 Linus Torvalds, Ingo Molnar<BR>&nbsp;* Copyright (C) 2005-2006 Thomas Gleixner<BR>&nbsp;*<BR>&nbsp;* This file contains driver APIs to the irq subsystem.<BR>&nbsp;*/</P>
<P></P>
<P>#define pr_fmt(fmt) "genirq: " fmt</P>
<P>#include &lt;linux/irq.h&gt;<BR>#include &lt;linux/kthread.h&gt;<BR>#include &lt;linux/module.h&gt;<BR>#include &lt;linux/random.h&gt;<BR>#include &lt;linux/interrupt.h&gt;<BR>#include &lt;linux/slab.h&gt;<BR>#include &lt;linux/sched.h&gt;<BR>#include &lt;linux/sched/rt.h&gt;<BR>#include &lt;linux/task_work.h&gt;</P>
<P>#include "internals.h"</P>
<P>#ifdef CONFIG_IRQ_FORCED_THREADING<BR>__read_mostly bool force_irqthreads;</P>
<P>static int __init setup_forced_irqthreads(char *arg)<BR>{<BR>&nbsp;force_irqthreads = true;<BR>&nbsp;return 0;<BR>}<BR>early_param("threadirqs", setup_forced_irqthreads);<BR>#endif</P>
<P>static void __synchronize_hardirq(struct irq_desc *desc)<BR>{<BR>&nbsp;bool inprogress;</P>
<P>&nbsp;do {<BR>&nbsp;&nbsp;unsigned long flags;</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Wait until we're out of the critical section.&nbsp; This might<BR>&nbsp;&nbsp; * give the wrong answer due to the lack of memory barriers.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;while (irqd_irq_inprogress(&amp;desc-&gt;irq_data))<BR>&nbsp;&nbsp;&nbsp;cpu_relax();</P>
<P>&nbsp;&nbsp;/* Ok, that indicated we're done: double-check carefully. */<BR>&nbsp;&nbsp;raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);<BR>&nbsp;&nbsp;inprogress = irqd_irq_inprogress(&amp;desc-&gt;irq_data);<BR>&nbsp;&nbsp;raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</P>
<P>&nbsp;&nbsp;/* Oops, that failed? */<BR>&nbsp;} while (inprogress);<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;synchronize_hardirq - wait for pending hard IRQ handlers (on other CPUs)<BR>&nbsp;*&nbsp;@irq: interrupt number to wait for<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function waits for any pending hard IRQ handlers for this<BR>&nbsp;*&nbsp;interrupt to complete before returning. If you use this<BR>&nbsp;*&nbsp;function while holding a resource the IRQ handler may need you<BR>&nbsp;*&nbsp;will deadlock. It does not take associated threaded handlers<BR>&nbsp;*&nbsp;into account.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Do not use this for shutdown scenarios where you must be sure<BR>&nbsp;*&nbsp;that all parts (hardirq and threaded handler) have completed.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Returns: false if a threaded handler is active.<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function may be called - with care - from IRQ context.<BR>&nbsp;*/<BR>bool synchronize_hardirq(unsigned int irq)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);</P>
<P>&nbsp;if (desc) {<BR>&nbsp;&nbsp;__synchronize_hardirq(desc);<BR>&nbsp;&nbsp;return !atomic_read(&amp;desc-&gt;threads_active);<BR>&nbsp;}</P>
<P>&nbsp;return true;<BR>}<BR>EXPORT_SYMBOL(synchronize_hardirq);</P>
<P>/**<BR>&nbsp;*&nbsp;synchronize_irq - wait for pending IRQ handlers (on other CPUs)<BR>&nbsp;*&nbsp;@irq: interrupt number to wait for<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function waits for any pending IRQ handlers for this interrupt<BR>&nbsp;*&nbsp;to complete before returning. If you use this function while<BR>&nbsp;*&nbsp;holding a resource the IRQ handler may need you will deadlock.<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function may be called - with care - from IRQ context.<BR>&nbsp;*/<BR>void synchronize_irq(unsigned int irq)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);</P>
<P>&nbsp;if (desc) {<BR>&nbsp;&nbsp;__synchronize_hardirq(desc);<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * We made sure that no hardirq handler is<BR>&nbsp;&nbsp; * running. Now verify that no threaded handlers are<BR>&nbsp;&nbsp; * active.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;wait_event(desc-&gt;wait_for_threads,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !atomic_read(&amp;desc-&gt;threads_active));<BR>&nbsp;}<BR>}<BR>EXPORT_SYMBOL(synchronize_irq);</P>
<P>#ifdef CONFIG_SMP<BR>cpumask_var_t irq_default_affinity;</P>
<P>/**<BR>&nbsp;*&nbsp;irq_can_set_affinity - Check if the affinity of a given irq can be set<BR>&nbsp;*&nbsp;@irq:&nbsp;&nbsp;Interrupt to check<BR>&nbsp;*<BR>&nbsp;*/<BR>int irq_can_set_affinity(unsigned int irq)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);</P>
<P>&nbsp;if (!desc || !irqd_can_balance(&amp;desc-&gt;irq_data) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; !desc-&gt;irq_data.chip || !desc-&gt;irq_data.chip-&gt;irq_set_affinity)<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;return 1;<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;irq_set_thread_affinity - Notify irq threads to adjust affinity<BR>&nbsp;*&nbsp;@desc:&nbsp;&nbsp;irq descriptor which has affitnity changed<BR>&nbsp;*<BR>&nbsp;*&nbsp;We just set IRQTF_AFFINITY and delegate the affinity setting<BR>&nbsp;*&nbsp;to the interrupt thread itself. We can not call<BR>&nbsp;*&nbsp;set_cpus_allowed_ptr() here as we hold desc-&gt;lock and this<BR>&nbsp;*&nbsp;code can be called from hard interrupt context.<BR>&nbsp;*/<BR>void irq_set_thread_affinity(struct irq_desc *desc)<BR>{<BR>&nbsp;struct irqaction *action = desc-&gt;action;</P>
<P>&nbsp;while (action) {<BR>&nbsp;&nbsp;if (action-&gt;thread)<BR>&nbsp;&nbsp;&nbsp;set_bit(IRQTF_AFFINITY, &amp;action-&gt;thread_flags);<BR>&nbsp;&nbsp;action = action-&gt;next;<BR>&nbsp;}<BR>}</P>
<P>#ifdef CONFIG_GENERIC_PENDING_IRQ<BR>static inline bool irq_can_move_pcntxt(struct irq_data *data)<BR>{<BR>&nbsp;return irqd_can_move_in_process_context(data);<BR>}<BR>static inline bool irq_move_pending(struct irq_data *data)<BR>{<BR>&nbsp;return irqd_is_setaffinity_pending(data);<BR>}<BR>static inline void<BR>irq_copy_pending(struct irq_desc *desc, const struct cpumask *mask)<BR>{<BR>&nbsp;cpumask_copy(desc-&gt;pending_mask, mask);<BR>}<BR>static inline void<BR>irq_get_pending(struct cpumask *mask, struct irq_desc *desc)<BR>{<BR>&nbsp;cpumask_copy(mask, desc-&gt;pending_mask);<BR>}<BR>#else<BR>static inline bool irq_can_move_pcntxt(struct irq_data *data) { return true; }<BR>static inline bool irq_move_pending(struct irq_data *data) { return false; }<BR>static inline void<BR>irq_copy_pending(struct irq_desc *desc, const struct cpumask *mask) { }<BR>static inline void<BR>irq_get_pending(struct cpumask *mask, struct irq_desc *desc) { }<BR>#endif</P>
<P>int irq_do_set_affinity(struct irq_data *data, const struct cpumask *mask,<BR>&nbsp;&nbsp;&nbsp;bool force)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_data_to_desc(data);<BR>&nbsp;struct irq_chip *chip = irq_data_get_irq_chip(data);<BR>&nbsp;int ret;</P>
<P>&nbsp;ret = chip-&gt;irq_set_affinity(data, mask, force);<BR>&nbsp;switch (ret) {<BR>&nbsp;case IRQ_SET_MASK_OK:<BR>&nbsp;case IRQ_SET_MASK_OK_DONE:<BR>&nbsp;&nbsp;cpumask_copy(data-&gt;affinity, mask);<BR>&nbsp;case IRQ_SET_MASK_OK_NOCOPY:<BR>&nbsp;&nbsp;irq_set_thread_affinity(desc);<BR>&nbsp;&nbsp;ret = 0;<BR>&nbsp;}</P>
<P>&nbsp;return ret;<BR>}</P>
<P>int irq_set_affinity_locked(struct irq_data *data, const struct cpumask *mask,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool force)<BR>{<BR>&nbsp;struct irq_chip *chip = irq_data_get_irq_chip(data);<BR>&nbsp;struct irq_desc *desc = irq_data_to_desc(data);<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;if (!chip || !chip-&gt;irq_set_affinity)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;if (irq_can_move_pcntxt(data)) {<BR>&nbsp;&nbsp;ret = irq_do_set_affinity(data, mask, force);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;irqd_set_move_pending(data);<BR>&nbsp;&nbsp;irq_copy_pending(desc, mask);<BR>&nbsp;}</P>
<P>&nbsp;if (desc-&gt;affinity_notify) {<BR>&nbsp;&nbsp;kref_get(&amp;desc-&gt;affinity_notify-&gt;kref);<BR>&nbsp;&nbsp;schedule_work(&amp;desc-&gt;affinity_notify-&gt;work);<BR>&nbsp;}<BR>&nbsp;irqd_set(data, IRQD_AFFINITY_SET);</P>
<P>&nbsp;return ret;<BR>}</P>
<P>int __irq_set_affinity(unsigned int irq, const struct cpumask *mask, bool force)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);<BR>&nbsp;unsigned long flags;<BR>&nbsp;int ret;</P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);<BR>&nbsp;ret = irq_set_affinity_locked(irq_desc_get_irq_data(desc), mask, force);<BR>&nbsp;raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);<BR>&nbsp;return ret;<BR>}</P>
<P>int irq_set_affinity_hint(unsigned int irq, const struct cpumask *m)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;struct irq_desc *desc = irq_get_desc_lock(irq, &amp;flags, IRQ_GET_DESC_CHECK_GLOBAL);</P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;desc-&gt;affinity_hint = m;<BR>&nbsp;irq_put_desc_unlock(desc, flags);<BR>&nbsp;/* set the initial affinity to prevent every interrupt being on CPU0 */<BR>&nbsp;if (m)<BR>&nbsp;&nbsp;__irq_set_affinity(irq, m, false);<BR>&nbsp;return 0;<BR>}<BR>EXPORT_SYMBOL_GPL(irq_set_affinity_hint);</P>
<P>/**<BR>&nbsp;*&nbsp;irq_set_vcpu_affinity - Set vcpu affinity for the interrupt<BR>&nbsp;*&nbsp;@irq: interrupt number to set affinity<BR>&nbsp;*&nbsp;@vcpu_info: vCPU specific data<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function uses the vCPU specific data to set the vCPU<BR>&nbsp;*&nbsp;affinity for an irq. The vCPU specific data is passed from<BR>&nbsp;*&nbsp;outside, such as KVM. One example code path is as below:<BR>&nbsp;*&nbsp;KVM -&gt; IOMMU -&gt; irq_set_vcpu_affinity().<BR>&nbsp;*/<BR>int irq_set_vcpu_affinity(unsigned int irq, void *vcpu_info)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;struct irq_desc *desc = irq_get_desc_lock(irq, &amp;flags, 0);<BR>&nbsp;struct irq_data *data;<BR>&nbsp;struct irq_chip *chip;<BR>&nbsp;int ret = -ENOSYS;</P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;data = irq_desc_get_irq_data(desc);<BR>&nbsp;chip = irq_data_get_irq_chip(data);<BR>&nbsp;if (chip &amp;&amp; chip-&gt;irq_set_vcpu_affinity)<BR>&nbsp;&nbsp;ret = chip-&gt;irq_set_vcpu_affinity(data, vcpu_info);<BR>&nbsp;irq_put_desc_unlock(desc, flags);</P>
<P>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL_GPL(irq_set_vcpu_affinity);</P>
<P>static void irq_affinity_notify(struct work_struct *work)<BR>{<BR>&nbsp;struct irq_affinity_notify *notify =<BR>&nbsp;&nbsp;container_of(work, struct irq_affinity_notify, work);<BR>&nbsp;struct irq_desc *desc = irq_to_desc(notify-&gt;irq);<BR>&nbsp;cpumask_var_t cpumask;<BR>&nbsp;unsigned long flags;</P>
<P>&nbsp;if (!desc || !alloc_cpumask_var(&amp;cpumask, GFP_KERNEL))<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);<BR>&nbsp;if (irq_move_pending(&amp;desc-&gt;irq_data))<BR>&nbsp;&nbsp;irq_get_pending(cpumask, desc);<BR>&nbsp;else<BR>&nbsp;&nbsp;cpumask_copy(cpumask, desc-&gt;irq_data.affinity);<BR>&nbsp;raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</P>
<P>&nbsp;notify-&gt;notify(notify, cpumask);</P>
<P>&nbsp;free_cpumask_var(cpumask);<BR>out:<BR>&nbsp;kref_put(&amp;notify-&gt;kref, notify-&gt;release);<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;irq_set_affinity_notifier - control notification of IRQ affinity changes<BR>&nbsp;*&nbsp;@irq:&nbsp;&nbsp;Interrupt for which to enable/disable notification<BR>&nbsp;*&nbsp;@notify:&nbsp;Context for notification, or %NULL to disable<BR>&nbsp;*&nbsp;&nbsp;&nbsp;notification.&nbsp; Function pointers must be initialised;<BR>&nbsp;*&nbsp;&nbsp;&nbsp;the other fields will be initialised by this function.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Must be called in process context.&nbsp; Notification may only be enabled<BR>&nbsp;*&nbsp;after the IRQ is allocated and must be disabled before the IRQ is<BR>&nbsp;*&nbsp;freed using free_irq().<BR>&nbsp;*/<BR>int<BR>irq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);<BR>&nbsp;struct irq_affinity_notify *old_notify;<BR>&nbsp;unsigned long flags;</P>
<P>&nbsp;/* The release function is promised process context */<BR>&nbsp;might_sleep();</P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;/* Complete initialisation of *notify */<BR>&nbsp;if (notify) {<BR>&nbsp;&nbsp;notify-&gt;irq = irq;<BR>&nbsp;&nbsp;kref_init(&amp;notify-&gt;kref);<BR>&nbsp;&nbsp;INIT_WORK(&amp;notify-&gt;work, irq_affinity_notify);<BR>&nbsp;}</P>
<P>&nbsp;raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);<BR>&nbsp;old_notify = desc-&gt;affinity_notify;<BR>&nbsp;desc-&gt;affinity_notify = notify;<BR>&nbsp;raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</P>
<P>&nbsp;if (old_notify)<BR>&nbsp;&nbsp;kref_put(&amp;old_notify-&gt;kref, old_notify-&gt;release);</P>
<P>&nbsp;return 0;<BR>}<BR>EXPORT_SYMBOL_GPL(irq_set_affinity_notifier);</P>
<P>#ifndef CONFIG_AUTO_IRQ_AFFINITY<BR>/*<BR>&nbsp;* Generic version of the affinity autoselector.<BR>&nbsp;*/<BR>static int<BR>setup_affinity(unsigned int irq, struct irq_desc *desc, struct cpumask *mask)<BR>{<BR>&nbsp;struct cpumask *set = irq_default_affinity;<BR>&nbsp;int node = irq_desc_get_node(desc);</P>
<P>&nbsp;/* Excludes PER_CPU and NO_BALANCE interrupts */<BR>&nbsp;if (!irq_can_set_affinity(irq))<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;/*<BR>&nbsp; * Preserve an userspace affinity setup, but make sure that<BR>&nbsp; * one of the targets is online.<BR>&nbsp; */<BR>&nbsp;if (irqd_has_set(&amp;desc-&gt;irq_data, IRQD_AFFINITY_SET)) {<BR>&nbsp;&nbsp;if (cpumask_intersects(desc-&gt;irq_data.affinity,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_online_mask))<BR>&nbsp;&nbsp;&nbsp;set = desc-&gt;irq_data.affinity;<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;irqd_clear(&amp;desc-&gt;irq_data, IRQD_AFFINITY_SET);<BR>&nbsp;}</P>
<P>&nbsp;cpumask_and(mask, cpu_online_mask, set);<BR>&nbsp;if (node != NUMA_NO_NODE) {<BR>&nbsp;&nbsp;const struct cpumask *nodemask = cpumask_of_node(node);</P>
<P>&nbsp;&nbsp;/* make sure at least one of the cpus in nodemask is online */<BR>&nbsp;&nbsp;if (cpumask_intersects(mask, nodemask))<BR>&nbsp;&nbsp;&nbsp;cpumask_and(mask, mask, nodemask);<BR>&nbsp;}<BR>&nbsp;irq_do_set_affinity(&amp;desc-&gt;irq_data, mask, false);<BR>&nbsp;return 0;<BR>}<BR>#else<BR>static inline int<BR>setup_affinity(unsigned int irq, struct irq_desc *d, struct cpumask *mask)<BR>{<BR>&nbsp;return irq_select_affinity(irq);<BR>}<BR>#endif</P>
<P>/*<BR>&nbsp;* Called when affinity is set via /proc/irq<BR>&nbsp;*/<BR>int irq_select_affinity_usr(unsigned int irq, struct cpumask *mask)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);<BR>&nbsp;unsigned long flags;<BR>&nbsp;int ret;</P>
<P>&nbsp;raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);<BR>&nbsp;ret = setup_affinity(irq, desc, mask);<BR>&nbsp;raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);<BR>&nbsp;return ret;<BR>}</P>
<P>#else<BR>static inline int<BR>setup_affinity(unsigned int irq, struct irq_desc *desc, struct cpumask *mask)<BR>{<BR>&nbsp;return 0;<BR>}<BR>#endif</P>
<P>void __disable_irq(struct irq_desc *desc, unsigned int irq)<BR>{<BR>&nbsp;if (!desc-&gt;depth++)<BR>&nbsp;&nbsp;irq_disable(desc);<BR>}</P>
<P>static int __disable_irq_nosync(unsigned int irq)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;struct irq_desc *desc = irq_get_desc_buslock(irq, &amp;flags, IRQ_GET_DESC_CHECK_GLOBAL);</P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;__disable_irq(desc, irq);<BR>&nbsp;irq_put_desc_busunlock(desc, flags);<BR>&nbsp;return 0;<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;disable_irq_nosync - disable an irq without waiting<BR>&nbsp;*&nbsp;@irq: Interrupt to disable<BR>&nbsp;*<BR>&nbsp;*&nbsp;Disable the selected interrupt line.&nbsp; Disables and Enables are<BR>&nbsp;*&nbsp;nested.<BR>&nbsp;*&nbsp;Unlike disable_irq(), this function does not ensure existing<BR>&nbsp;*&nbsp;instances of the IRQ handler have completed before returning.<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function may be called from IRQ context.<BR>&nbsp;*/<BR>void disable_irq_nosync(unsigned int irq)<BR>{<BR>&nbsp;__disable_irq_nosync(irq);<BR>}<BR>EXPORT_SYMBOL(disable_irq_nosync);</P>
<P><FONT class=extract>/**<BR>&nbsp;*&nbsp;disable_irq - disable an irq and wait for completion<BR>&nbsp;*&nbsp;@irq: Interrupt to disable<BR>&nbsp;*<BR>&nbsp;*&nbsp;Disable the selected interrupt line.&nbsp; Enables and Disables are<BR>&nbsp;*&nbsp;nested.<BR>&nbsp;*&nbsp;This function waits for any pending IRQ handlers for this interrupt<BR>&nbsp;*&nbsp;to complete before returning. If you use this function while<BR>&nbsp;*&nbsp;holding a resource the IRQ handler may need you will deadlock.<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function may be called - with care - from IRQ context.<BR>&nbsp;*/<BR>void disable_irq(unsigned int irq)<BR>{<BR>&nbsp;if (!__disable_irq_nosync(irq))<BR>&nbsp;&nbsp;synchronize_irq(irq);<BR>}<BR>EXPORT_SYMBOL(disable_irq);</FONT></P>
<P>/**<BR>&nbsp;*&nbsp;disable_hardirq - disables an irq and waits for hardirq completion<BR>&nbsp;*&nbsp;@irq: Interrupt to disable<BR>&nbsp;*<BR>&nbsp;*&nbsp;Disable the selected interrupt line.&nbsp; Enables and Disables are<BR>&nbsp;*&nbsp;nested.<BR>&nbsp;*&nbsp;This function waits for any pending hard IRQ handlers for this<BR>&nbsp;*&nbsp;interrupt to complete before returning. If you use this function while<BR>&nbsp;*&nbsp;holding a resource the hard IRQ handler may need you will deadlock.<BR>&nbsp;*<BR>&nbsp;*&nbsp;When used to optimistically disable an interrupt from atomic context<BR>&nbsp;*&nbsp;the return value must be checked.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Returns: false if a threaded handler is active.<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function may be called - with care - from IRQ context.<BR>&nbsp;*/<BR>bool disable_hardirq(unsigned int irq)<BR>{<BR>&nbsp;if (!__disable_irq_nosync(irq))<BR>&nbsp;&nbsp;return synchronize_hardirq(irq);</P>
<P>&nbsp;return false;<BR>}<BR>EXPORT_SYMBOL_GPL(disable_hardirq);</P>
<P>void __enable_irq(struct irq_desc *desc, unsigned int irq)<BR>{<BR>&nbsp;switch (desc-&gt;depth) {<BR>&nbsp;case 0:<BR>&nbsp;err_out:<BR>&nbsp;&nbsp;WARN(1, KERN_WARNING "Unbalanced enable for IRQ %d\n", irq);<BR>&nbsp;&nbsp;break;<BR>&nbsp;case 1: {<BR>&nbsp;&nbsp;if (desc-&gt;istate &amp; IRQS_SUSPENDED)<BR>&nbsp;&nbsp;&nbsp;goto err_out;<BR>&nbsp;&nbsp;/* Prevent probing on this irq: */<BR>&nbsp;&nbsp;irq_settings_set_noprobe(desc);<BR>&nbsp;&nbsp;irq_enable(desc);<BR>&nbsp;&nbsp;check_irq_resend(desc, irq);<BR>&nbsp;&nbsp;/* fall-through */<BR>&nbsp;}<BR>&nbsp;default:<BR>&nbsp;&nbsp;desc-&gt;depth--;<BR>&nbsp;}<BR>}</P>
<P><FONT class=extract>/**<BR>&nbsp;*&nbsp;enable_irq - enable handling of an irq<BR>&nbsp;*&nbsp;@irq: Interrupt to enable<BR>&nbsp;*<BR>&nbsp;*&nbsp;Undoes the effect of one call to disable_irq().&nbsp; If this<BR>&nbsp;*&nbsp;matches the last disable, processing of interrupts on this<BR>&nbsp;*&nbsp;IRQ line is re-enabled.<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function may be called from IRQ context only when<BR>&nbsp;*&nbsp;desc-&gt;irq_data.chip-&gt;bus_lock and desc-&gt;chip-&gt;bus_sync_unlock are NULL !<BR>&nbsp;*/<BR>void enable_irq(unsigned int irq)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;struct irq_desc *desc = irq_get_desc_buslock(irq, &amp;flags, IRQ_GET_DESC_CHECK_GLOBAL);</FONT></P>
<P><FONT class=extract>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return;<BR>&nbsp;if (WARN(!desc-&gt;irq_data.chip,<BR>&nbsp;&nbsp; KERN_ERR "enable_irq before setup/request_irq: irq %u\n", irq))<BR>&nbsp;&nbsp;goto out;</FONT></P>
<P><FONT class=extract>&nbsp;__enable_irq(desc, irq);<BR>out:<BR>&nbsp;irq_put_desc_busunlock(desc, flags);<BR>}<BR>EXPORT_SYMBOL(enable_irq);</FONT></P>
<P>static int set_irq_wake_real(unsigned int irq, unsigned int on)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);<BR>&nbsp;int ret = -ENXIO;</P>
<P>&nbsp;if (irq_desc_get_chip(desc)-&gt;flags &amp;&nbsp; IRQCHIP_SKIP_SET_WAKE)<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;if (desc-&gt;irq_data.chip-&gt;irq_set_wake)<BR>&nbsp;&nbsp;ret = desc-&gt;irq_data.chip-&gt;irq_set_wake(&amp;desc-&gt;irq_data, on);</P>
<P>&nbsp;return ret;<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;irq_set_irq_wake - control irq power management wakeup<BR>&nbsp;*&nbsp;@irq:&nbsp;interrupt to control<BR>&nbsp;*&nbsp;@on:&nbsp;enable/disable power management wakeup<BR>&nbsp;*<BR>&nbsp;*&nbsp;Enable/disable power management wakeup mode, which is<BR>&nbsp;*&nbsp;disabled by default.&nbsp; Enables and disables must match,<BR>&nbsp;*&nbsp;just as they match for non-wakeup mode support.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Wakeup mode lets this IRQ wake the system from sleep<BR>&nbsp;*&nbsp;states like "suspend to RAM".<BR>&nbsp;*/<BR>int irq_set_irq_wake(unsigned int irq, unsigned int on)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;struct irq_desc *desc = irq_get_desc_buslock(irq, &amp;flags, IRQ_GET_DESC_CHECK_GLOBAL);<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;/* wakeup-capable irqs can be shared between drivers that<BR>&nbsp; * don't need to have the same sleep mode behaviors.<BR>&nbsp; */<BR>&nbsp;if (on) {<BR>&nbsp;&nbsp;if (desc-&gt;wake_depth++ == 0) {<BR>&nbsp;&nbsp;&nbsp;ret = set_irq_wake_real(irq, on);<BR>&nbsp;&nbsp;&nbsp;if (ret)<BR>&nbsp;&nbsp;&nbsp;&nbsp;desc-&gt;wake_depth = 0;<BR>&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;irqd_set(&amp;desc-&gt;irq_data, IRQD_WAKEUP_STATE);<BR>&nbsp;&nbsp;}<BR>&nbsp;} else {<BR>&nbsp;&nbsp;if (desc-&gt;wake_depth == 0) {<BR>&nbsp;&nbsp;&nbsp;WARN(1, "Unbalanced IRQ %d wake disable\n", irq);<BR>&nbsp;&nbsp;} else if (--desc-&gt;wake_depth == 0) {<BR>&nbsp;&nbsp;&nbsp;ret = set_irq_wake_real(irq, on);<BR>&nbsp;&nbsp;&nbsp;if (ret)<BR>&nbsp;&nbsp;&nbsp;&nbsp;desc-&gt;wake_depth = 1;<BR>&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;irqd_clear(&amp;desc-&gt;irq_data, IRQD_WAKEUP_STATE);<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;irq_put_desc_busunlock(desc, flags);<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL(irq_set_irq_wake);</P>
<P><FONT class=extract>/*<BR>&nbsp;* Internal function that tells the architecture code whether a<BR>&nbsp;* particular irq has been exclusively allocated or is available<BR>&nbsp;* for driver use.<BR>&nbsp;*/<BR>int can_request_irq(unsigned int irq, unsigned long irqflags)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;struct irq_desc *desc = irq_get_desc_lock(irq, &amp;flags, 0);<BR>&nbsp;int canrequest = 0;</FONT></P>
<P><FONT class=extract>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return 0;</FONT></P>
<P><FONT class=extract>&nbsp;if (irq_settings_can_request(desc)) {<BR>&nbsp;&nbsp;if (!desc-&gt;action ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irqflags &amp; desc-&gt;action-&gt;flags &amp; IRQF_SHARED)<BR>&nbsp;&nbsp;&nbsp;canrequest = 1;<BR>&nbsp;}<BR>&nbsp;irq_put_desc_unlock(desc, flags);<BR>&nbsp;return canrequest;<BR>}</FONT></P>
<P>int __irq_set_trigger(struct irq_desc *desc, unsigned int irq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long flags)<BR>{<BR>&nbsp;struct irq_chip *chip = desc-&gt;irq_data.chip;<BR>&nbsp;int ret, unmask = 0;</P>
<P>&nbsp;if (!chip || !chip-&gt;irq_set_type) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * IRQF_TRIGGER_* but the PIC does not support multiple<BR>&nbsp;&nbsp; * flow-types?<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;pr_debug("No set_type function for IRQ %d (%s)\n", irq,<BR>&nbsp;&nbsp;&nbsp; chip ? (chip-&gt;name ? : "unknown") : "unknown");<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}</P>
<P>&nbsp;flags &amp;= IRQ_TYPE_SENSE_MASK;</P>
<P>&nbsp;if (chip-&gt;flags &amp; IRQCHIP_SET_TYPE_MASKED) {<BR>&nbsp;&nbsp;if (!irqd_irq_masked(&amp;desc-&gt;irq_data))<BR>&nbsp;&nbsp;&nbsp;mask_irq(desc);<BR>&nbsp;&nbsp;if (!irqd_irq_disabled(&amp;desc-&gt;irq_data))<BR>&nbsp;&nbsp;&nbsp;unmask = 1;<BR>&nbsp;}</P>
<P>&nbsp;/* caller masked out all except trigger mode flags */<BR>&nbsp;ret = chip-&gt;irq_set_type(&amp;desc-&gt;irq_data, flags);</P>
<P>&nbsp;switch (ret) {<BR>&nbsp;case IRQ_SET_MASK_OK:<BR>&nbsp;case IRQ_SET_MASK_OK_DONE:<BR>&nbsp;&nbsp;irqd_clear(&amp;desc-&gt;irq_data, IRQD_TRIGGER_MASK);<BR>&nbsp;&nbsp;irqd_set(&amp;desc-&gt;irq_data, flags);</P>
<P>&nbsp;case IRQ_SET_MASK_OK_NOCOPY:<BR>&nbsp;&nbsp;flags = irqd_get_trigger_type(&amp;desc-&gt;irq_data);<BR>&nbsp;&nbsp;irq_settings_set_trigger_mask(desc, flags);<BR>&nbsp;&nbsp;irqd_clear(&amp;desc-&gt;irq_data, IRQD_LEVEL);<BR>&nbsp;&nbsp;irq_settings_clr_level(desc);<BR>&nbsp;&nbsp;if (flags &amp; IRQ_TYPE_LEVEL_MASK) {<BR>&nbsp;&nbsp;&nbsp;irq_settings_set_level(desc);<BR>&nbsp;&nbsp;&nbsp;irqd_set(&amp;desc-&gt;irq_data, IRQD_LEVEL);<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;ret = 0;<BR>&nbsp;&nbsp;break;<BR>&nbsp;default:<BR>&nbsp;&nbsp;pr_err("Setting trigger mode %lu for irq %u failed (%pF)\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags, irq, chip-&gt;irq_set_type);<BR>&nbsp;}<BR>&nbsp;if (unmask)<BR>&nbsp;&nbsp;unmask_irq(desc);<BR>&nbsp;return ret;<BR>}</P>
<P>#ifdef CONFIG_HARDIRQS_SW_RESEND<BR>int irq_set_parent(int irq, int parent_irq)<BR>{<BR>&nbsp;unsigned long flags;<BR>&nbsp;struct irq_desc *desc = irq_get_desc_lock(irq, &amp;flags, 0);</P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;desc-&gt;parent_irq = parent_irq;</P>
<P>&nbsp;irq_put_desc_unlock(desc, flags);<BR>&nbsp;return 0;<BR>}<BR>#endif</P>
<P>/*<BR>&nbsp;* Default primary interrupt handler for threaded interrupts. Is<BR>&nbsp;* assigned as primary handler when request_threaded_irq is called<BR>&nbsp;* with handler == NULL. Useful for oneshot interrupts.<BR>&nbsp;*/<BR>static irqreturn_t irq_default_primary_handler(int irq, void *dev_id)<BR>{<BR>&nbsp;return IRQ_WAKE_THREAD;<BR>}</P>
<P>/*<BR>&nbsp;* Primary handler for nested threaded interrupts. Should never be<BR>&nbsp;* called.<BR>&nbsp;*/<BR>static irqreturn_t irq_nested_primary_handler(int irq, void *dev_id)<BR>{<BR>&nbsp;WARN(1, "Primary handler called for nested irq %d\n", irq);<BR>&nbsp;return IRQ_NONE;<BR>}</P>
<P>static int irq_wait_for_interrupt(struct irqaction *action)<BR>{<BR>&nbsp;set_current_state(TASK_INTERRUPTIBLE);</P>
<P>&nbsp;while (!kthread_should_stop()) {</P>
<P>&nbsp;&nbsp;if (test_and_clear_bit(IRQTF_RUNTHREAD,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;action-&gt;thread_flags)) {<BR>&nbsp;&nbsp;&nbsp;__set_current_state(TASK_RUNNING);<BR>&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;schedule();<BR>&nbsp;&nbsp;set_current_state(TASK_INTERRUPTIBLE);<BR>&nbsp;}<BR>&nbsp;__set_current_state(TASK_RUNNING);<BR>&nbsp;return -1;<BR>}</P>
<P>/*<BR>&nbsp;* Oneshot interrupts keep the irq line masked until the threaded<BR>&nbsp;* handler finished. unmask if the interrupt has not been disabled and<BR>&nbsp;* is marked MASKED.<BR>&nbsp;*/<BR>static void irq_finalize_oneshot(struct irq_desc *desc,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct irqaction *action)<BR>{<BR>&nbsp;if (!(desc-&gt;istate &amp; IRQS_ONESHOT))<BR>&nbsp;&nbsp;return;<BR>again:<BR>&nbsp;chip_bus_lock(desc);<BR>&nbsp;raw_spin_lock_irq(&amp;desc-&gt;lock);</P>
<P>&nbsp;/*<BR>&nbsp; * Implausible though it may be we need to protect us against<BR>&nbsp; * the following scenario:<BR>&nbsp; *<BR>&nbsp; * The thread is faster done than the hard interrupt handler<BR>&nbsp; * on the other CPU. If we unmask the irq line then the<BR>&nbsp; * interrupt can come in again and masks the line, leaves due<BR>&nbsp; * to IRQS_INPROGRESS and the irq line is masked forever.<BR>&nbsp; *<BR>&nbsp; * This also serializes the state of shared oneshot handlers<BR>&nbsp; * versus "desc-&gt;threads_onehsot |= action-&gt;thread_mask;" in<BR>&nbsp; * irq_wake_thread(). See the comment there which explains the<BR>&nbsp; * serialization.<BR>&nbsp; */<BR>&nbsp;if (unlikely(irqd_irq_inprogress(&amp;desc-&gt;irq_data))) {<BR>&nbsp;&nbsp;raw_spin_unlock_irq(&amp;desc-&gt;lock);<BR>&nbsp;&nbsp;chip_bus_sync_unlock(desc);<BR>&nbsp;&nbsp;cpu_relax();<BR>&nbsp;&nbsp;goto again;<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * Now check again, whether the thread should run. Otherwise<BR>&nbsp; * we would clear the threads_oneshot bit of this thread which<BR>&nbsp; * was just set.<BR>&nbsp; */<BR>&nbsp;if (test_bit(IRQTF_RUNTHREAD, &amp;action-&gt;thread_flags))<BR>&nbsp;&nbsp;goto out_unlock;</P>
<P>&nbsp;desc-&gt;threads_oneshot &amp;= ~action-&gt;thread_mask;</P>
<P>&nbsp;if (!desc-&gt;threads_oneshot &amp;&amp; !irqd_irq_disabled(&amp;desc-&gt;irq_data) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; irqd_irq_masked(&amp;desc-&gt;irq_data))<BR>&nbsp;&nbsp;unmask_threaded_irq(desc);</P>
<P>out_unlock:<BR>&nbsp;raw_spin_unlock_irq(&amp;desc-&gt;lock);<BR>&nbsp;chip_bus_sync_unlock(desc);<BR>}</P>
<P>#ifdef CONFIG_SMP<BR>/*<BR>&nbsp;* Check whether we need to change the affinity of the interrupt thread.<BR>&nbsp;*/<BR>static void<BR>irq_thread_check_affinity(struct irq_desc *desc, struct irqaction *action)<BR>{<BR>&nbsp;cpumask_var_t mask;<BR>&nbsp;bool valid = true;</P>
<P>&nbsp;if (!test_and_clear_bit(IRQTF_AFFINITY, &amp;action-&gt;thread_flags))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/*<BR>&nbsp; * In case we are out of memory we set IRQTF_AFFINITY again and<BR>&nbsp; * try again next time<BR>&nbsp; */<BR>&nbsp;if (!alloc_cpumask_var(&amp;mask, GFP_KERNEL)) {<BR>&nbsp;&nbsp;set_bit(IRQTF_AFFINITY, &amp;action-&gt;thread_flags);<BR>&nbsp;&nbsp;return;<BR>&nbsp;}</P>
<P>&nbsp;raw_spin_lock_irq(&amp;desc-&gt;lock);<BR>&nbsp;/*<BR>&nbsp; * This code is triggered unconditionally. Check the affinity<BR>&nbsp; * mask pointer. For CPU_MASK_OFFSTACK=n this is optimized out.<BR>&nbsp; */<BR>&nbsp;if (desc-&gt;irq_data.affinity)<BR>&nbsp;&nbsp;cpumask_copy(mask, desc-&gt;irq_data.affinity);<BR>&nbsp;else<BR>&nbsp;&nbsp;valid = false;<BR>&nbsp;raw_spin_unlock_irq(&amp;desc-&gt;lock);</P>
<P>&nbsp;if (valid)<BR>&nbsp;&nbsp;set_cpus_allowed_ptr(current, mask);<BR>&nbsp;free_cpumask_var(mask);<BR>}<BR>#else<BR>static inline void<BR>irq_thread_check_affinity(struct irq_desc *desc, struct irqaction *action) { }<BR>#endif</P>
<P>/*<BR>&nbsp;* Interrupts which are not explicitely requested as threaded<BR>&nbsp;* interrupts rely on the implicit bh/preempt disable of the hard irq<BR>&nbsp;* context. So we need to disable bh here to avoid deadlocks and other<BR>&nbsp;* side effects.<BR>&nbsp;*/<BR>static irqreturn_t<BR>irq_forced_thread_fn(struct irq_desc *desc, struct irqaction *action)<BR>{<BR>&nbsp;irqreturn_t ret;</P>
<P>&nbsp;local_bh_disable();<BR>&nbsp;ret = action-&gt;thread_fn(action-&gt;irq, action-&gt;dev_id);<BR>&nbsp;irq_finalize_oneshot(desc, action);<BR>&nbsp;local_bh_enable();<BR>&nbsp;return ret;<BR>}</P>
<P>/*<BR>&nbsp;* Interrupts explicitly requested as threaded interrupts want to be<BR>&nbsp;* preemtible - many of them need to sleep and wait for slow busses to<BR>&nbsp;* complete.<BR>&nbsp;*/<BR>static irqreturn_t irq_thread_fn(struct irq_desc *desc,<BR>&nbsp;&nbsp;struct irqaction *action)<BR>{<BR>&nbsp;irqreturn_t ret;</P>
<P>&nbsp;ret = action-&gt;thread_fn(action-&gt;irq, action-&gt;dev_id);<BR>&nbsp;irq_finalize_oneshot(desc, action);<BR>&nbsp;return ret;<BR>}</P>
<P>static void wake_threads_waitq(struct irq_desc *desc)<BR>{<BR>&nbsp;if (atomic_dec_and_test(&amp;desc-&gt;threads_active))<BR>&nbsp;&nbsp;wake_up(&amp;desc-&gt;wait_for_threads);<BR>}</P>
<P>static void irq_thread_dtor(struct callback_head *unused)<BR>{<BR>&nbsp;struct task_struct *tsk = current;<BR>&nbsp;struct irq_desc *desc;<BR>&nbsp;struct irqaction *action;</P>
<P>&nbsp;if (WARN_ON_ONCE(!(current-&gt;flags &amp; PF_EXITING)))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;action = kthread_data(tsk);</P>
<P>&nbsp;pr_err("exiting task \"%s\" (%d) is an active IRQ thread (irq %d)\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tsk-&gt;comm, tsk-&gt;pid, action-&gt;irq);</P>
<P><BR>&nbsp;desc = irq_to_desc(action-&gt;irq);<BR>&nbsp;/*<BR>&nbsp; * If IRQTF_RUNTHREAD is set, we need to decrement<BR>&nbsp; * desc-&gt;threads_active and wake possible waiters.<BR>&nbsp; */<BR>&nbsp;if (test_and_clear_bit(IRQTF_RUNTHREAD, &amp;action-&gt;thread_flags))<BR>&nbsp;&nbsp;wake_threads_waitq(desc);</P>
<P>&nbsp;/* Prevent a stale desc-&gt;threads_oneshot */<BR>&nbsp;irq_finalize_oneshot(desc, action);<BR>}</P>
<P>/*<BR>&nbsp;* Interrupt handler thread<BR>&nbsp;*/<BR>static int irq_thread(void *data)<BR>{<BR>&nbsp;struct callback_head on_exit_work;<BR>&nbsp;struct irqaction *action = data;<BR>&nbsp;struct irq_desc *desc = irq_to_desc(action-&gt;irq);<BR>&nbsp;irqreturn_t (*handler_fn)(struct irq_desc *desc,<BR>&nbsp;&nbsp;&nbsp;struct irqaction *action);</P>
<P>&nbsp;if (force_irqthreads &amp;&amp; test_bit(IRQTF_FORCED_THREAD,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;action-&gt;thread_flags))<BR>&nbsp;&nbsp;handler_fn = irq_forced_thread_fn;<BR>&nbsp;else<BR>&nbsp;&nbsp;handler_fn = irq_thread_fn;</P>
<P>&nbsp;init_task_work(&amp;on_exit_work, irq_thread_dtor);<BR>&nbsp;task_work_add(current, &amp;on_exit_work, false);</P>
<P>&nbsp;irq_thread_check_affinity(desc, action);</P>
<P>&nbsp;while (!irq_wait_for_interrupt(action)) {<BR>&nbsp;&nbsp;irqreturn_t action_ret;</P>
<P>&nbsp;&nbsp;irq_thread_check_affinity(desc, action);</P>
<P>&nbsp;&nbsp;action_ret = handler_fn(desc, action);<BR>&nbsp;&nbsp;if (action_ret == IRQ_HANDLED)<BR>&nbsp;&nbsp;&nbsp;atomic_inc(&amp;desc-&gt;threads_handled);</P>
<P>&nbsp;&nbsp;wake_threads_waitq(desc);<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * This is the regular exit path. __free_irq() is stopping the<BR>&nbsp; * thread via kthread_stop() after calling<BR>&nbsp; * synchronize_irq(). So neither IRQTF_RUNTHREAD nor the<BR>&nbsp; * oneshot mask bit can be set. We cannot verify that as we<BR>&nbsp; * cannot touch the oneshot mask at this point anymore as<BR>&nbsp; * __setup_irq() might have given out currents thread_mask<BR>&nbsp; * again.<BR>&nbsp; */<BR>&nbsp;task_work_cancel(current, irq_thread_dtor);<BR>&nbsp;return 0;<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;irq_wake_thread - wake the irq thread for the action identified by dev_id<BR>&nbsp;*&nbsp;@irq:&nbsp;&nbsp;Interrupt line<BR>&nbsp;*&nbsp;@dev_id:&nbsp;Device identity for which the thread should be woken<BR>&nbsp;*<BR>&nbsp;*/<BR>void irq_wake_thread(unsigned int irq, void *dev_id)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);<BR>&nbsp;struct irqaction *action;<BR>&nbsp;unsigned long flags;</P>
<P>&nbsp;if (!desc || WARN_ON(irq_settings_is_per_cpu_devid(desc)))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);<BR>&nbsp;for (action = desc-&gt;action; action; action = action-&gt;next) {<BR>&nbsp;&nbsp;if (action-&gt;dev_id == dev_id) {<BR>&nbsp;&nbsp;&nbsp;if (action-&gt;thread)<BR>&nbsp;&nbsp;&nbsp;&nbsp;__irq_wake_thread(desc, action);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);<BR>}<BR>EXPORT_SYMBOL_GPL(irq_wake_thread);</P>
<P>static void irq_setup_forced_threading(struct irqaction *new)<BR>{<BR>&nbsp;if (!force_irqthreads)<BR>&nbsp;&nbsp;return;<BR>&nbsp;if (new-&gt;flags &amp; (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;new-&gt;flags |= IRQF_ONESHOT;</P>
<P>&nbsp;if (!new-&gt;thread_fn) {<BR>&nbsp;&nbsp;set_bit(IRQTF_FORCED_THREAD, &amp;new-&gt;thread_flags);<BR>&nbsp;&nbsp;new-&gt;thread_fn = new-&gt;handler;<BR>&nbsp;&nbsp;new-&gt;handler = irq_default_primary_handler;<BR>&nbsp;}<BR>}</P>
<P>static int irq_request_resources(struct irq_desc *desc)<BR>{<BR>&nbsp;struct irq_data *d = &amp;desc-&gt;irq_data;<BR>&nbsp;struct irq_chip *c = d-&gt;chip;</P>
<P>&nbsp;return c-&gt;irq_request_resources ? c-&gt;irq_request_resources(d) : 0;<BR>}</P>
<P>static void irq_release_resources(struct irq_desc *desc)<BR>{<BR>&nbsp;struct irq_data *d = &amp;desc-&gt;irq_data;<BR>&nbsp;struct irq_chip *c = d-&gt;chip;</P>
<P>&nbsp;if (c-&gt;irq_release_resources)<BR>&nbsp;&nbsp;c-&gt;irq_release_resources(d);<BR>}</P>
<P>/*<BR>&nbsp;* Internal function to register an irqaction - typically used to<BR>&nbsp;* allocate special interrupts that are part of the architecture.<BR>&nbsp;*/<BR>static int<BR>__setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)<BR>{<BR>&nbsp;struct irqaction *old, **old_ptr;<BR>&nbsp;unsigned long flags, thread_mask = 0;<BR>&nbsp;int ret, nested, shared = 0;<BR>&nbsp;cpumask_var_t mask;</P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;if (desc-&gt;irq_data.chip == &amp;no_irq_chip)<BR>&nbsp;&nbsp;return -ENOSYS;<BR>&nbsp;if (!try_module_get(desc-&gt;owner))<BR>&nbsp;&nbsp;return -ENODEV;</P>
<P>&nbsp;/*<BR>&nbsp; * Check whether the interrupt nests into another interrupt<BR>&nbsp; * thread.<BR>&nbsp; */<BR>&nbsp;nested = irq_settings_is_nested_thread(desc);<BR>&nbsp;if (nested) {<BR>&nbsp;&nbsp;if (!new-&gt;thread_fn) {<BR>&nbsp;&nbsp;&nbsp;ret = -EINVAL;<BR>&nbsp;&nbsp;&nbsp;goto out_mput;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Replace the primary handler which was provided from<BR>&nbsp;&nbsp; * the driver for non nested interrupt handling by the<BR>&nbsp;&nbsp; * dummy function which warns when called.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;new-&gt;handler = irq_nested_primary_handler;<BR>&nbsp;} else {<BR>&nbsp;&nbsp;if (irq_settings_can_thread(desc))<BR>&nbsp;&nbsp;&nbsp;irq_setup_forced_threading(new);<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * Create a handler thread when a thread function is supplied<BR>&nbsp; * and the interrupt does not nest into another interrupt<BR>&nbsp; * thread.<BR>&nbsp; */<BR>&nbsp;if (new-&gt;thread_fn &amp;&amp; !nested) {<BR>&nbsp;&nbsp;struct task_struct *t;<BR>&nbsp;&nbsp;static const struct sched_param param = {<BR>&nbsp;&nbsp;&nbsp;.sched_priority = MAX_USER_RT_PRIO/2,<BR>&nbsp;&nbsp;};</P>
<P>&nbsp;&nbsp;t = kthread_create(irq_thread, new, "irq/%d-%s", irq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new-&gt;name);<BR>&nbsp;&nbsp;if (IS_ERR(t)) {<BR>&nbsp;&nbsp;&nbsp;ret = PTR_ERR(t);<BR>&nbsp;&nbsp;&nbsp;goto out_mput;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;sched_setscheduler_nocheck(t, SCHED_FIFO, &amp;param);</P>
<P>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * We keep the reference to the task struct even if<BR>&nbsp;&nbsp; * the thread dies to avoid that the interrupt code<BR>&nbsp;&nbsp; * references an already freed task_struct.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;get_task_struct(t);<BR>&nbsp;&nbsp;new-&gt;thread = t;<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Tell the thread to set its affinity. This is<BR>&nbsp;&nbsp; * important for shared interrupt handlers as we do<BR>&nbsp;&nbsp; * not invoke setup_affinity() for the secondary<BR>&nbsp;&nbsp; * handlers as everything is already set up. Even for<BR>&nbsp;&nbsp; * interrupts marked with IRQF_NO_BALANCE this is<BR>&nbsp;&nbsp; * correct as we want the thread to move to the cpu(s)<BR>&nbsp;&nbsp; * on which the requesting code placed the interrupt.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;set_bit(IRQTF_AFFINITY, &amp;new-&gt;thread_flags);<BR>&nbsp;}</P>
<P>&nbsp;if (!alloc_cpumask_var(&amp;mask, GFP_KERNEL)) {<BR>&nbsp;&nbsp;ret = -ENOMEM;<BR>&nbsp;&nbsp;goto out_thread;<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * Drivers are often written to work w/o knowledge about the<BR>&nbsp; * underlying irq chip implementation, so a request for a<BR>&nbsp; * threaded irq without a primary hard irq context handler<BR>&nbsp; * requires the ONESHOT flag to be set. Some irq chips like<BR>&nbsp; * MSI based interrupts are per se one shot safe. Check the<BR>&nbsp; * chip flags, so we can avoid the unmask dance at the end of<BR>&nbsp; * the threaded handler for those.<BR>&nbsp; */<BR>&nbsp;if (desc-&gt;irq_data.chip-&gt;flags &amp; IRQCHIP_ONESHOT_SAFE)<BR>&nbsp;&nbsp;new-&gt;flags &amp;= ~IRQF_ONESHOT;</P>
<P>&nbsp;/*<BR>&nbsp; * The following block of code has to be executed atomically<BR>&nbsp; */<BR>&nbsp;raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);<BR>&nbsp;old_ptr = &amp;desc-&gt;action;<BR>&nbsp;old = *old_ptr;<BR>&nbsp;if (old) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Can't share interrupts unless both agree to and are<BR>&nbsp;&nbsp; * the same type (level, edge, polarity). So both flag<BR>&nbsp;&nbsp; * fields must have IRQF_SHARED set and the bits which<BR>&nbsp;&nbsp; * set the trigger type must match. Also all must<BR>&nbsp;&nbsp; * agree on ONESHOT.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (!((old-&gt;flags &amp; new-&gt;flags) &amp; IRQF_SHARED) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((old-&gt;flags ^ new-&gt;flags) &amp; IRQF_TRIGGER_MASK) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((old-&gt;flags ^ new-&gt;flags) &amp; IRQF_ONESHOT))<BR>&nbsp;&nbsp;&nbsp;goto mismatch;</P>
<P>&nbsp;&nbsp;/* All handlers must agree on per-cpuness */<BR>&nbsp;&nbsp;if ((old-&gt;flags &amp; IRQF_PERCPU) !=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (new-&gt;flags &amp; IRQF_PERCPU))<BR>&nbsp;&nbsp;&nbsp;goto mismatch;</P>
<P>&nbsp;&nbsp;/* add new interrupt at end of irq queue */<BR>&nbsp;&nbsp;do {<BR>&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp; * Or all existing action-&gt;thread_mask bits,<BR>&nbsp;&nbsp;&nbsp; * so we can find the next zero bit for this<BR>&nbsp;&nbsp;&nbsp; * new action.<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;thread_mask |= old-&gt;thread_mask;<BR>&nbsp;&nbsp;&nbsp;old_ptr = &amp;old-&gt;next;<BR>&nbsp;&nbsp;&nbsp;old = *old_ptr;<BR>&nbsp;&nbsp;} while (old);<BR>&nbsp;&nbsp;shared = 1;<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * Setup the thread mask for this irqaction for ONESHOT. For<BR>&nbsp; * !ONESHOT irqs the thread mask is 0 so we can avoid a<BR>&nbsp; * conditional in irq_wake_thread().<BR>&nbsp; */<BR>&nbsp;if (new-&gt;flags &amp; IRQF_ONESHOT) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * Unlikely to have 32 resp 64 irqs sharing one line,<BR>&nbsp;&nbsp; * but who knows.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;if (thread_mask == ~0UL) {<BR>&nbsp;&nbsp;&nbsp;ret = -EBUSY;<BR>&nbsp;&nbsp;&nbsp;goto out_mask;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * The thread_mask for the action is or'ed to<BR>&nbsp;&nbsp; * desc-&gt;thread_active to indicate that the<BR>&nbsp;&nbsp; * IRQF_ONESHOT thread handler has been woken, but not<BR>&nbsp;&nbsp; * yet finished. The bit is cleared when a thread<BR>&nbsp;&nbsp; * completes. When all threads of a shared interrupt<BR>&nbsp;&nbsp; * line have completed desc-&gt;threads_active becomes<BR>&nbsp;&nbsp; * zero and the interrupt line is unmasked. See<BR>&nbsp;&nbsp; * handle.c:irq_wake_thread() for further information.<BR>&nbsp;&nbsp; *<BR>&nbsp;&nbsp; * If no thread is woken by primary (hard irq context)<BR>&nbsp;&nbsp; * interrupt handlers, then desc-&gt;threads_active is<BR>&nbsp;&nbsp; * also checked for zero to unmask the irq line in the<BR>&nbsp;&nbsp; * affected hard irq flow handlers<BR>&nbsp;&nbsp; * (handle_[fasteoi|level]_irq).<BR>&nbsp;&nbsp; *<BR>&nbsp;&nbsp; * The new action gets the first zero bit of<BR>&nbsp;&nbsp; * thread_mask assigned. See the loop above which or's<BR>&nbsp;&nbsp; * all existing action-&gt;thread_mask bits.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;new-&gt;thread_mask = 1 &lt;&lt; ffz(thread_mask);</P>
<P>&nbsp;} else if (new-&gt;handler == irq_default_primary_handler &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; !(desc-&gt;irq_data.chip-&gt;flags &amp; IRQCHIP_ONESHOT_SAFE)) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * The interrupt was requested with handler = NULL, so<BR>&nbsp;&nbsp; * we use the default primary handler for it. But it<BR>&nbsp;&nbsp; * does not have the oneshot flag set. In combination<BR>&nbsp;&nbsp; * with level interrupts this is deadly, because the<BR>&nbsp;&nbsp; * default primary handler just wakes the thread, then<BR>&nbsp;&nbsp; * the irq lines is reenabled, but the device still<BR>&nbsp;&nbsp; * has the level irq asserted. Rinse and repeat....<BR>&nbsp;&nbsp; *<BR>&nbsp;&nbsp; * While this works for edge type interrupts, we play<BR>&nbsp;&nbsp; * it safe and reject unconditionally because we can't<BR>&nbsp;&nbsp; * say for sure which type this interrupt really<BR>&nbsp;&nbsp; * has. The type flags are unreliable as the<BR>&nbsp;&nbsp; * underlying chip implementation can override them.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;pr_err("Threaded irq requested with handler=NULL and !ONESHOT for irq %d\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq);<BR>&nbsp;&nbsp;ret = -EINVAL;<BR>&nbsp;&nbsp;goto out_mask;<BR>&nbsp;}</P>
<P>&nbsp;if (!shared) {<BR>&nbsp;&nbsp;ret = irq_request_resources(desc);<BR>&nbsp;&nbsp;if (ret) {<BR>&nbsp;&nbsp;&nbsp;pr_err("Failed to request resources for %s (irq %d) on irqchip %s\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new-&gt;name, irq, desc-&gt;irq_data.chip-&gt;name);<BR>&nbsp;&nbsp;&nbsp;goto out_mask;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;init_waitqueue_head(&amp;desc-&gt;wait_for_threads);</P>
<P>&nbsp;&nbsp;/* Setup the type (level, edge polarity) if configured: */<BR>&nbsp;&nbsp;if (new-&gt;flags &amp; IRQF_TRIGGER_MASK) {<BR>&nbsp;&nbsp;&nbsp;ret = __irq_set_trigger(desc, irq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new-&gt;flags &amp; IRQF_TRIGGER_MASK);</P>
<P>&nbsp;&nbsp;&nbsp;if (ret)<BR>&nbsp;&nbsp;&nbsp;&nbsp;goto out_mask;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;desc-&gt;istate &amp;= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IRQS_ONESHOT | IRQS_WAITING);<BR>&nbsp;&nbsp;irqd_clear(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</P>
<P>&nbsp;&nbsp;if (new-&gt;flags &amp; IRQF_PERCPU) {<BR>&nbsp;&nbsp;&nbsp;irqd_set(&amp;desc-&gt;irq_data, IRQD_PER_CPU);<BR>&nbsp;&nbsp;&nbsp;irq_settings_set_per_cpu(desc);<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;if (new-&gt;flags &amp; IRQF_ONESHOT)<BR>&nbsp;&nbsp;&nbsp;desc-&gt;istate |= IRQS_ONESHOT;</P>
<P>&nbsp;&nbsp;if (irq_settings_can_autoenable(desc))<BR>&nbsp;&nbsp;&nbsp;irq_startup(desc, true);<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;/* Undo nested disables: */<BR>&nbsp;&nbsp;&nbsp;desc-&gt;depth = 1;</P>
<P>&nbsp;&nbsp;/* Exclude IRQ from balancing if requested */<BR>&nbsp;&nbsp;if (new-&gt;flags &amp; IRQF_NOBALANCING) {<BR>&nbsp;&nbsp;&nbsp;irq_settings_set_no_balancing(desc);<BR>&nbsp;&nbsp;&nbsp;irqd_set(&amp;desc-&gt;irq_data, IRQD_NO_BALANCING);<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;/* Set default affinity mask once everything is setup */<BR>&nbsp;&nbsp;setup_affinity(irq, desc, mask);</P>
<P>&nbsp;} else if (new-&gt;flags &amp; IRQF_TRIGGER_MASK) {<BR>&nbsp;&nbsp;unsigned int nmsk = new-&gt;flags &amp; IRQF_TRIGGER_MASK;<BR>&nbsp;&nbsp;unsigned int omsk = irq_settings_get_trigger_mask(desc);</P>
<P>&nbsp;&nbsp;if (nmsk != omsk)<BR>&nbsp;&nbsp;&nbsp;/* hope the handler works with current&nbsp; trigger mode */<BR>&nbsp;&nbsp;&nbsp;pr_warning("irq %d uses trigger mode %u; requested %u\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq, nmsk, omsk);<BR>&nbsp;}</P>
<P>&nbsp;new-&gt;irq = irq;<BR>&nbsp;*old_ptr = new;</P>
<P>&nbsp;irq_pm_install_action(desc, new);</P>
<P>&nbsp;/* Reset broken irq detection when installing new handler */<BR>&nbsp;desc-&gt;irq_count = 0;<BR>&nbsp;desc-&gt;irqs_unhandled = 0;</P>
<P>&nbsp;/*<BR>&nbsp; * Check whether we disabled the irq via the spurious handler<BR>&nbsp; * before. Reenable it and give it another chance.<BR>&nbsp; */<BR>&nbsp;if (shared &amp;&amp; (desc-&gt;istate &amp; IRQS_SPURIOUS_DISABLED)) {<BR>&nbsp;&nbsp;desc-&gt;istate &amp;= ~IRQS_SPURIOUS_DISABLED;<BR>&nbsp;&nbsp;__enable_irq(desc, irq);<BR>&nbsp;}</P>
<P>&nbsp;raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</P>
<P>&nbsp;/*<BR>&nbsp; * Strictly no need to wake it up, but hung_task complains<BR>&nbsp; * when no hard interrupt wakes the thread up.<BR>&nbsp; */<BR>&nbsp;if (new-&gt;thread)<BR>&nbsp;&nbsp;wake_up_process(new-&gt;thread);</P>
<P>&nbsp;register_irq_proc(irq, desc);<BR>&nbsp;new-&gt;dir = NULL;<BR>&nbsp;register_handler_proc(irq, new);<BR>&nbsp;free_cpumask_var(mask);</P>
<P>&nbsp;return 0;</P>
<P>mismatch:<BR>&nbsp;if (!(new-&gt;flags &amp; IRQF_PROBE_SHARED)) {<BR>&nbsp;&nbsp;pr_err("Flags mismatch irq %d. %08x (%s) vs. %08x (%s)\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq, new-&gt;flags, new-&gt;name, old-&gt;flags, old-&gt;name);<BR>#ifdef CONFIG_DEBUG_SHIRQ<BR>&nbsp;&nbsp;dump_stack();<BR>#endif<BR>&nbsp;}<BR>&nbsp;ret = -EBUSY;</P>
<P>out_mask:<BR>&nbsp;raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);<BR>&nbsp;free_cpumask_var(mask);</P>
<P>out_thread:<BR>&nbsp;if (new-&gt;thread) {<BR>&nbsp;&nbsp;struct task_struct *t = new-&gt;thread;</P>
<P>&nbsp;&nbsp;new-&gt;thread = NULL;<BR>&nbsp;&nbsp;kthread_stop(t);<BR>&nbsp;&nbsp;put_task_struct(t);<BR>&nbsp;}<BR>out_mput:<BR>&nbsp;module_put(desc-&gt;owner);<BR>&nbsp;return ret;<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;setup_irq - setup an interrupt<BR>&nbsp;*&nbsp;@irq: Interrupt line to setup<BR>&nbsp;*&nbsp;@act: irqaction for the interrupt<BR>&nbsp;*<BR>&nbsp;* Used to statically setup interrupts in the early boot process.<BR>&nbsp;*/<BR>int setup_irq(unsigned int irq, struct irqaction *act)<BR>{<BR>&nbsp;int retval;<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);</P>
<P>&nbsp;if (WARN_ON(irq_settings_is_per_cpu_devid(desc)))<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;chip_bus_lock(desc);<BR>&nbsp;retval = __setup_irq(irq, desc, act);<BR>&nbsp;chip_bus_sync_unlock(desc);</P>
<P>&nbsp;return retval;<BR>}<BR>EXPORT_SYMBOL_GPL(setup_irq);</P>
<P>/*<BR>&nbsp;* Internal function to unregister an irqaction - used to free<BR>&nbsp;* regular and special interrupts that are part of the architecture.<BR>&nbsp;*/<BR>static struct irqaction *__free_irq(unsigned int irq, void *dev_id)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);<BR>&nbsp;struct irqaction *action, **action_ptr;<BR>&nbsp;unsigned long flags;</P>
<P>&nbsp;WARN(in_interrupt(), "Trying to free IRQ %d from IRQ context!\n", irq);</P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return NULL;</P>
<P>&nbsp;raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);</P>
<P>&nbsp;/*<BR>&nbsp; * There can be multiple actions per IRQ descriptor, find the right<BR>&nbsp; * one based on the dev_id:<BR>&nbsp; */<BR>&nbsp;action_ptr = &amp;desc-&gt;action;<BR>&nbsp;for (;;) {<BR>&nbsp;&nbsp;action = *action_ptr;</P>
<P>&nbsp;&nbsp;if (!action) {<BR>&nbsp;&nbsp;&nbsp;WARN(1, "Trying to free already-free IRQ %d\n", irq);<BR>&nbsp;&nbsp;&nbsp;raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</P>
<P>&nbsp;&nbsp;&nbsp;return NULL;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;if (action-&gt;dev_id == dev_id)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;action_ptr = &amp;action-&gt;next;<BR>&nbsp;}</P>
<P>&nbsp;/* Found it - now remove it from the list of entries: */<BR>&nbsp;*action_ptr = action-&gt;next;</P>
<P>&nbsp;irq_pm_remove_action(desc, action);</P>
<P>&nbsp;/* If this was the last handler, shut down the IRQ line: */<BR>&nbsp;if (!desc-&gt;action) {<BR>&nbsp;&nbsp;irq_shutdown(desc);<BR>&nbsp;&nbsp;irq_release_resources(desc);<BR>&nbsp;}</P>
<P>#ifdef CONFIG_SMP<BR>&nbsp;/* make sure affinity_hint is cleaned up */<BR>&nbsp;if (WARN_ON_ONCE(desc-&gt;affinity_hint))<BR>&nbsp;&nbsp;desc-&gt;affinity_hint = NULL;<BR>#endif</P>
<P>&nbsp;raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</P>
<P>&nbsp;unregister_handler_proc(irq, action);</P>
<P>&nbsp;/* Make sure it's not being used on another CPU: */<BR>&nbsp;synchronize_irq(irq);</P>
<P>#ifdef CONFIG_DEBUG_SHIRQ<BR>&nbsp;/*<BR>&nbsp; * It's a shared IRQ -- the driver ought to be prepared for an IRQ<BR>&nbsp; * event to happen even now it's being freed, so let's make sure that<BR>&nbsp; * is so by doing an extra call to the handler ....<BR>&nbsp; *<BR>&nbsp; * ( We do this after actually deregistering it, to make sure that a<BR>&nbsp; *&nbsp;&nbsp; 'real' IRQ doesn't run in * parallel with our fake. )<BR>&nbsp; */<BR>&nbsp;if (action-&gt;flags &amp; IRQF_SHARED) {<BR>&nbsp;&nbsp;local_irq_save(flags);<BR>&nbsp;&nbsp;action-&gt;handler(irq, dev_id);<BR>&nbsp;&nbsp;local_irq_restore(flags);<BR>&nbsp;}<BR>#endif</P>
<P>&nbsp;if (action-&gt;thread) {<BR>&nbsp;&nbsp;kthread_stop(action-&gt;thread);<BR>&nbsp;&nbsp;put_task_struct(action-&gt;thread);<BR>&nbsp;}</P>
<P>&nbsp;module_put(desc-&gt;owner);<BR>&nbsp;return action;<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;remove_irq - free an interrupt<BR>&nbsp;*&nbsp;@irq: Interrupt line to free<BR>&nbsp;*&nbsp;@act: irqaction for the interrupt<BR>&nbsp;*<BR>&nbsp;* Used to remove interrupts statically setup by the early boot process.<BR>&nbsp;*/<BR>void remove_irq(unsigned int irq, struct irqaction *act)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);</P>
<P>&nbsp;if (desc &amp;&amp; !WARN_ON(irq_settings_is_per_cpu_devid(desc)))<BR>&nbsp;&nbsp;&nbsp;&nbsp; __free_irq(irq, act-&gt;dev_id);<BR>}<BR>EXPORT_SYMBOL_GPL(remove_irq);</P>
<P>/**<BR>&nbsp;*&nbsp;free_irq - free an interrupt allocated with request_irq<BR>&nbsp;*&nbsp;@irq: Interrupt line to free<BR>&nbsp;*&nbsp;@dev_id: Device identity to free<BR>&nbsp;*<BR>&nbsp;*&nbsp;Remove an interrupt handler. The handler is removed and if the<BR>&nbsp;*&nbsp;interrupt line is no longer in use by any driver it is disabled.<BR>&nbsp;*&nbsp;On a shared IRQ the caller must ensure the interrupt is disabled<BR>&nbsp;*&nbsp;on the card it drives before calling this function. The function<BR>&nbsp;*&nbsp;does not return until any executing interrupts for this IRQ<BR>&nbsp;*&nbsp;have completed.<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function must not be called from interrupt context.<BR>&nbsp;*/<BR>void free_irq(unsigned int irq, void *dev_id)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);</P>
<P>&nbsp;if (!desc || WARN_ON(irq_settings_is_per_cpu_devid(desc)))<BR>&nbsp;&nbsp;return;</P>
<P>#ifdef CONFIG_SMP<BR>&nbsp;if (WARN_ON(desc-&gt;affinity_notify))<BR>&nbsp;&nbsp;desc-&gt;affinity_notify = NULL;<BR>#endif</P>
<P>&nbsp;chip_bus_lock(desc);<BR>&nbsp;kfree(__free_irq(irq, dev_id));<BR>&nbsp;chip_bus_sync_unlock(desc);<BR>}<BR>EXPORT_SYMBOL(free_irq);</P>
<P>/**<BR>&nbsp;*&nbsp;request_threaded_irq - allocate an interrupt line<BR>&nbsp;*&nbsp;@irq: Interrupt line to allocate<BR>&nbsp;*&nbsp;@handler: Function to be called when the IRQ occurs.<BR>&nbsp;*&nbsp;&nbsp;&nbsp; Primary handler for threaded interrupts<BR>&nbsp;*&nbsp;&nbsp;&nbsp; If NULL and thread_fn != NULL the default<BR>&nbsp;*&nbsp;&nbsp;&nbsp; primary handler is installed<BR>&nbsp;*&nbsp;@thread_fn: Function called from the irq handler thread<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NULL, no irq thread is created<BR>&nbsp;*&nbsp;@irqflags: Interrupt type flags<BR>&nbsp;*&nbsp;@devname: An ascii name for the claiming device<BR>&nbsp;*&nbsp;@dev_id: A cookie passed back to the handler function<BR>&nbsp;*<BR>&nbsp;*&nbsp;This call allocates interrupt resources and enables the<BR>&nbsp;*&nbsp;interrupt line and IRQ handling. From the point this<BR>&nbsp;*&nbsp;call is made your handler function may be invoked. Since<BR>&nbsp;*&nbsp;your handler function must clear any interrupt the board<BR>&nbsp;*&nbsp;raises, you must take care both to initialise your hardware<BR>&nbsp;*&nbsp;and to set up the interrupt handler in the right order.<BR>&nbsp;*<BR>&nbsp;*&nbsp;If you want to set up a threaded irq handler for your device<BR>&nbsp;*&nbsp;then you need to supply @handler and @thread_fn. @handler is<BR>&nbsp;*&nbsp;still called in hard interrupt context and has to check<BR>&nbsp;*&nbsp;whether the interrupt originates from the device. If yes it<BR>&nbsp;*&nbsp;needs to disable the interrupt on the device and return<BR>&nbsp;*&nbsp;IRQ_WAKE_THREAD which will wake up the handler thread and run<BR>&nbsp;*&nbsp;@thread_fn. This split handler design is necessary to support<BR>&nbsp;*&nbsp;shared interrupts.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Dev_id must be globally unique. Normally the address of the<BR>&nbsp;*&nbsp;device data structure is used as the cookie. Since the handler<BR>&nbsp;*&nbsp;receives this value it makes sense to use it.<BR>&nbsp;*<BR>&nbsp;*&nbsp;If your interrupt is shared you must pass a non NULL dev_id<BR>&nbsp;*&nbsp;as this is required when freeing the interrupt.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Flags:<BR>&nbsp;*<BR>&nbsp;*&nbsp;IRQF_SHARED&nbsp;&nbsp;Interrupt is shared<BR>&nbsp;*&nbsp;IRQF_TRIGGER_*&nbsp;&nbsp;Specify active edge(s) or level<BR>&nbsp;*<BR>&nbsp;*/<BR>int request_threaded_irq(unsigned int irq, irq_handler_t handler,<BR>&nbsp;&nbsp;&nbsp; irq_handler_t thread_fn, unsigned long irqflags,<BR>&nbsp;&nbsp;&nbsp; const char *devname, void *dev_id)<BR>{<BR>&nbsp;struct irqaction *action;<BR>&nbsp;struct irq_desc *desc;<BR>&nbsp;int retval;</P>
<P>&nbsp;/*<BR>&nbsp; * Sanity-check: shared interrupts must pass in a real dev-ID,<BR>&nbsp; * otherwise we'll have trouble later trying to figure out<BR>&nbsp; * which interrupt is which (messes up the interrupt freeing<BR>&nbsp; * logic etc).<BR>&nbsp; *<BR>&nbsp; * Also IRQF_COND_SUSPEND only makes sense for shared interrupts and<BR>&nbsp; * it cannot be set along with IRQF_NO_SUSPEND.<BR>&nbsp; */<BR>&nbsp;if (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;desc = irq_to_desc(irq);<BR>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;if (!irq_settings_can_request(desc) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; WARN_ON(irq_settings_is_per_cpu_devid(desc)))<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;if (!handler) {<BR>&nbsp;&nbsp;if (!thread_fn)<BR>&nbsp;&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;&nbsp;handler = irq_default_primary_handler;<BR>&nbsp;}</P>
<P>&nbsp;action = kzalloc(sizeof(struct irqaction), GFP_KERNEL);<BR>&nbsp;if (!action)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;action-&gt;handler = handler;<BR>&nbsp;action-&gt;thread_fn = thread_fn;<BR>&nbsp;action-&gt;flags = irqflags;<BR>&nbsp;action-&gt;name = devname;<BR>&nbsp;action-&gt;dev_id = dev_id;</P>
<P>&nbsp;chip_bus_lock(desc);<BR>&nbsp;retval = __setup_irq(irq, desc, action);<BR>&nbsp;chip_bus_sync_unlock(desc);</P>
<P>&nbsp;if (retval)<BR>&nbsp;&nbsp;kfree(action);</P>
<P>#ifdef CONFIG_DEBUG_SHIRQ_FIXME<BR>&nbsp;if (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * It's a shared IRQ -- the driver ought to be prepared for it<BR>&nbsp;&nbsp; * to happen immediately, so let's make sure....<BR>&nbsp;&nbsp; * We disable the irq to make sure that a 'real' IRQ doesn't<BR>&nbsp;&nbsp; * run in parallel with our fake.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;unsigned long flags;</P>
<P>&nbsp;&nbsp;disable_irq(irq);<BR>&nbsp;&nbsp;local_irq_save(flags);</P>
<P>&nbsp;&nbsp;handler(irq, dev_id);</P>
<P>&nbsp;&nbsp;local_irq_restore(flags);<BR>&nbsp;&nbsp;enable_irq(irq);<BR>&nbsp;}<BR>#endif<BR>&nbsp;return retval;<BR>}<BR>EXPORT_SYMBOL(request_threaded_irq);</P>
<P>/**<BR>&nbsp;*&nbsp;request_any_context_irq - allocate an interrupt line<BR>&nbsp;*&nbsp;@irq: Interrupt line to allocate<BR>&nbsp;*&nbsp;@handler: Function to be called when the IRQ occurs.<BR>&nbsp;*&nbsp;&nbsp;&nbsp; Threaded handler for threaded interrupts.<BR>&nbsp;*&nbsp;@flags: Interrupt type flags<BR>&nbsp;*&nbsp;@name: An ascii name for the claiming device<BR>&nbsp;*&nbsp;@dev_id: A cookie passed back to the handler function<BR>&nbsp;*<BR>&nbsp;*&nbsp;This call allocates interrupt resources and enables the<BR>&nbsp;*&nbsp;interrupt line and IRQ handling. It selects either a<BR>&nbsp;*&nbsp;hardirq or threaded handling method depending on the<BR>&nbsp;*&nbsp;context.<BR>&nbsp;*<BR>&nbsp;*&nbsp;On failure, it returns a negative value. On success,<BR>&nbsp;*&nbsp;it returns either IRQC_IS_HARDIRQ or IRQC_IS_NESTED.<BR>&nbsp;*/<BR>int request_any_context_irq(unsigned int irq, irq_handler_t handler,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long flags, const char *name, void *dev_id)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);<BR>&nbsp;int ret;</P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;if (irq_settings_is_nested_thread(desc)) {<BR>&nbsp;&nbsp;ret = request_threaded_irq(irq, NULL, handler,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags, name, dev_id);<BR>&nbsp;&nbsp;return !ret ? IRQC_IS_NESTED : ret;<BR>&nbsp;}</P>
<P>&nbsp;ret = request_irq(irq, handler, flags, name, dev_id);<BR>&nbsp;return !ret ? IRQC_IS_HARDIRQ : ret;<BR>}<BR>EXPORT_SYMBOL_GPL(request_any_context_irq);</P>
<P>void enable_percpu_irq(unsigned int irq, unsigned int type)<BR>{<BR>&nbsp;unsigned int cpu = smp_processor_id();<BR>&nbsp;unsigned long flags;<BR>&nbsp;struct irq_desc *desc = irq_get_desc_lock(irq, &amp;flags, IRQ_GET_DESC_CHECK_PERCPU);</P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;type &amp;= IRQ_TYPE_SENSE_MASK;<BR>&nbsp;if (type != IRQ_TYPE_NONE) {<BR>&nbsp;&nbsp;int ret;</P>
<P>&nbsp;&nbsp;ret = __irq_set_trigger(desc, irq, type);</P>
<P>&nbsp;&nbsp;if (ret) {<BR>&nbsp;&nbsp;&nbsp;WARN(1, "failed to set type for IRQ%d\n", irq);<BR>&nbsp;&nbsp;&nbsp;goto out;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;irq_percpu_enable(desc, cpu);<BR>out:<BR>&nbsp;irq_put_desc_unlock(desc, flags);<BR>}<BR>EXPORT_SYMBOL_GPL(enable_percpu_irq);</P>
<P>void disable_percpu_irq(unsigned int irq)<BR>{<BR>&nbsp;unsigned int cpu = smp_processor_id();<BR>&nbsp;unsigned long flags;<BR>&nbsp;struct irq_desc *desc = irq_get_desc_lock(irq, &amp;flags, IRQ_GET_DESC_CHECK_PERCPU);</P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;irq_percpu_disable(desc, cpu);<BR>&nbsp;irq_put_desc_unlock(desc, flags);<BR>}<BR>EXPORT_SYMBOL_GPL(disable_percpu_irq);</P>
<P>/*<BR>&nbsp;* Internal function to unregister a percpu irqaction.<BR>&nbsp;*/<BR>static struct irqaction *__free_percpu_irq(unsigned int irq, void __percpu *dev_id)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);<BR>&nbsp;struct irqaction *action;<BR>&nbsp;unsigned long flags;</P>
<P>&nbsp;WARN(in_interrupt(), "Trying to free IRQ %d from IRQ context!\n", irq);</P>
<P>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return NULL;</P>
<P>&nbsp;raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);</P>
<P>&nbsp;action = desc-&gt;action;<BR>&nbsp;if (!action || action-&gt;percpu_dev_id != dev_id) {<BR>&nbsp;&nbsp;WARN(1, "Trying to free already-free IRQ %d\n", irq);<BR>&nbsp;&nbsp;goto bad;<BR>&nbsp;}</P>
<P>&nbsp;if (!cpumask_empty(desc-&gt;percpu_enabled)) {<BR>&nbsp;&nbsp;WARN(1, "percpu IRQ %d still enabled on CPU%d!\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq, cpumask_first(desc-&gt;percpu_enabled));<BR>&nbsp;&nbsp;goto bad;<BR>&nbsp;}</P>
<P>&nbsp;/* Found it - now remove it from the list of entries: */<BR>&nbsp;desc-&gt;action = NULL;</P>
<P>&nbsp;raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);</P>
<P>&nbsp;unregister_handler_proc(irq, action);</P>
<P>&nbsp;module_put(desc-&gt;owner);<BR>&nbsp;return action;</P>
<P>bad:<BR>&nbsp;raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);<BR>&nbsp;return NULL;<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;remove_percpu_irq - free a per-cpu interrupt<BR>&nbsp;*&nbsp;@irq: Interrupt line to free<BR>&nbsp;*&nbsp;@act: irqaction for the interrupt<BR>&nbsp;*<BR>&nbsp;* Used to remove interrupts statically setup by the early boot process.<BR>&nbsp;*/<BR>void remove_percpu_irq(unsigned int irq, struct irqaction *act)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);</P>
<P>&nbsp;if (desc &amp;&amp; irq_settings_is_per_cpu_devid(desc))<BR>&nbsp;&nbsp;&nbsp;&nbsp; __free_percpu_irq(irq, act-&gt;percpu_dev_id);<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;free_percpu_irq - free an interrupt allocated with request_percpu_irq<BR>&nbsp;*&nbsp;@irq: Interrupt line to free<BR>&nbsp;*&nbsp;@dev_id: Device identity to free<BR>&nbsp;*<BR>&nbsp;*&nbsp;Remove a percpu interrupt handler. The handler is removed, but<BR>&nbsp;*&nbsp;the interrupt line is not disabled. This must be done on each<BR>&nbsp;*&nbsp;CPU before calling this function. The function does not return<BR>&nbsp;*&nbsp;until any executing interrupts for this IRQ have completed.<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function must not be called from interrupt context.<BR>&nbsp;*/<BR>void free_percpu_irq(unsigned int irq, void __percpu *dev_id)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);</P>
<P>&nbsp;if (!desc || !irq_settings_is_per_cpu_devid(desc))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;chip_bus_lock(desc);<BR>&nbsp;kfree(__free_percpu_irq(irq, dev_id));<BR>&nbsp;chip_bus_sync_unlock(desc);<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;setup_percpu_irq - setup a per-cpu interrupt<BR>&nbsp;*&nbsp;@irq: Interrupt line to setup<BR>&nbsp;*&nbsp;@act: irqaction for the interrupt<BR>&nbsp;*<BR>&nbsp;* Used to statically setup per-cpu interrupts in the early boot process.<BR>&nbsp;*/<BR>int setup_percpu_irq(unsigned int irq, struct irqaction *act)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);<BR>&nbsp;int retval;</P>
<P>&nbsp;if (!desc || !irq_settings_is_per_cpu_devid(desc))<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;chip_bus_lock(desc);<BR>&nbsp;retval = __setup_irq(irq, desc, act);<BR>&nbsp;chip_bus_sync_unlock(desc);</P>
<P>&nbsp;return retval;<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;request_percpu_irq - allocate a percpu interrupt line<BR>&nbsp;*&nbsp;@irq: Interrupt line to allocate<BR>&nbsp;*&nbsp;@handler: Function to be called when the IRQ occurs.<BR>&nbsp;*&nbsp;@devname: An ascii name for the claiming device<BR>&nbsp;*&nbsp;@dev_id: A percpu cookie passed back to the handler function<BR>&nbsp;*<BR>&nbsp;*&nbsp;This call allocates interrupt resources, but doesn't<BR>&nbsp;*&nbsp;automatically enable the interrupt. It has to be done on each<BR>&nbsp;*&nbsp;CPU using enable_percpu_irq().<BR>&nbsp;*<BR>&nbsp;*&nbsp;Dev_id must be globally unique. It is a per-cpu variable, and<BR>&nbsp;*&nbsp;the handler gets called with the interrupted CPU's instance of<BR>&nbsp;*&nbsp;that variable.<BR>&nbsp;*/<BR>int request_percpu_irq(unsigned int irq, irq_handler_t handler,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *devname, void __percpu *dev_id)<BR>{<BR>&nbsp;struct irqaction *action;<BR>&nbsp;struct irq_desc *desc;<BR>&nbsp;int retval;</P>
<P>&nbsp;if (!dev_id)<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;desc = irq_to_desc(irq);<BR>&nbsp;if (!desc || !irq_settings_can_request(desc) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; !irq_settings_is_per_cpu_devid(desc))<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;action = kzalloc(sizeof(struct irqaction), GFP_KERNEL);<BR>&nbsp;if (!action)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;action-&gt;handler = handler;<BR>&nbsp;action-&gt;flags = IRQF_PERCPU | IRQF_NO_SUSPEND;<BR>&nbsp;action-&gt;name = devname;<BR>&nbsp;action-&gt;percpu_dev_id = dev_id;</P>
<P>&nbsp;chip_bus_lock(desc);<BR>&nbsp;retval = __setup_irq(irq, desc, action);<BR>&nbsp;chip_bus_sync_unlock(desc);</P>
<P>&nbsp;if (retval)<BR>&nbsp;&nbsp;kfree(action);</P>
<P>&nbsp;return retval;<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;irq_get_irqchip_state - returns the irqchip state of a interrupt.<BR>&nbsp;*&nbsp;@irq: Interrupt line that is forwarded to a VM<BR>&nbsp;*&nbsp;@which: One of IRQCHIP_STATE_* the caller wants to know about<BR>&nbsp;*&nbsp;@state: a pointer to a boolean where the state is to be storeed<BR>&nbsp;*<BR>&nbsp;*&nbsp;This call snapshots the internal irqchip state of an<BR>&nbsp;*&nbsp;interrupt, returning into @state the bit corresponding to<BR>&nbsp;*&nbsp;stage @which<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function should be called with preemption disabled if the<BR>&nbsp;*&nbsp;interrupt controller has per-cpu registers.<BR>&nbsp;*/<BR>int irq_get_irqchip_state(unsigned int irq, enum irqchip_irq_state which,<BR>&nbsp;&nbsp;&nbsp;&nbsp; bool *state)<BR>{<BR>&nbsp;struct irq_desc *desc;<BR>&nbsp;struct irq_data *data;<BR>&nbsp;struct irq_chip *chip;<BR>&nbsp;unsigned long flags;<BR>&nbsp;int err = -EINVAL;</P>
<P>&nbsp;desc = irq_get_desc_buslock(irq, &amp;flags, 0);<BR>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return err;</P>
<P>&nbsp;data = irq_desc_get_irq_data(desc);</P>
<P>&nbsp;do {<BR>&nbsp;&nbsp;chip = irq_data_get_irq_chip(data);<BR>&nbsp;&nbsp;if (chip-&gt;irq_get_irqchip_state)<BR>&nbsp;&nbsp;&nbsp;break;<BR>#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY<BR>&nbsp;&nbsp;data = data-&gt;parent_data;<BR>#else<BR>&nbsp;&nbsp;data = NULL;<BR>#endif<BR>&nbsp;} while (data);</P>
<P>&nbsp;if (data)<BR>&nbsp;&nbsp;err = chip-&gt;irq_get_irqchip_state(data, which, state);</P>
<P>&nbsp;irq_put_desc_busunlock(desc, flags);<BR>&nbsp;return err;<BR>}</P>
<P>/**<BR>&nbsp;*&nbsp;irq_set_irqchip_state - set the state of a forwarded interrupt.<BR>&nbsp;*&nbsp;@irq: Interrupt line that is forwarded to a VM<BR>&nbsp;*&nbsp;@which: State to be restored (one of IRQCHIP_STATE_*)<BR>&nbsp;*&nbsp;@val: Value corresponding to @which<BR>&nbsp;*<BR>&nbsp;*&nbsp;This call sets the internal irqchip state of an interrupt,<BR>&nbsp;*&nbsp;depending on the value of @which.<BR>&nbsp;*<BR>&nbsp;*&nbsp;This function should be called with preemption disabled if the<BR>&nbsp;*&nbsp;interrupt controller has per-cpu registers.<BR>&nbsp;*/<BR>int irq_set_irqchip_state(unsigned int irq, enum irqchip_irq_state which,<BR>&nbsp;&nbsp;&nbsp;&nbsp; bool val)<BR>{<BR>&nbsp;struct irq_desc *desc;<BR>&nbsp;struct irq_data *data;<BR>&nbsp;struct irq_chip *chip;<BR>&nbsp;unsigned long flags;<BR>&nbsp;int err = -EINVAL;</P>
<P>&nbsp;desc = irq_get_desc_buslock(irq, &amp;flags, 0);<BR>&nbsp;if (!desc)<BR>&nbsp;&nbsp;return err;</P>
<P>&nbsp;data = irq_desc_get_irq_data(desc);</P>
<P>&nbsp;do {<BR>&nbsp;&nbsp;chip = irq_data_get_irq_chip(data);<BR>&nbsp;&nbsp;if (chip-&gt;irq_set_irqchip_state)<BR>&nbsp;&nbsp;&nbsp;break;<BR>#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY<BR>&nbsp;&nbsp;data = data-&gt;parent_data;<BR>#else<BR>&nbsp;&nbsp;data = NULL;<BR>#endif<BR>&nbsp;} while (data);</P>
<P>&nbsp;if (data)<BR>&nbsp;&nbsp;err = chip-&gt;irq_set_irqchip_state(data, which, val);</P>
<P>&nbsp;irq_put_desc_busunlock(desc, flags);<BR>&nbsp;return err;<BR>}