# Documentation/input/event-codes.txt
<P></P>
<P>The input protocol uses a map of types and codes to express input device values<BR>to userspace. This document describes the types and codes and how and when they<BR>may be used.</P>
<P></P>
<P>A single hardware event generates multiple input events. Each input event<BR>contains the new value of a single data item. A special event type, EV_SYN, is<BR>used to separate input events into packets of input data changes occurring at<BR>the same moment in time. In the following, the term "event" refers to a single<BR>input event encompassing a type, code, and value.</P>
<P>The input protocol is a stateful protocol. Events are emitted only when values<BR>of event codes have changed. However, the state is maintained within the Linux<BR>input subsystem; drivers do not need to maintain the state and may attempt to<BR>emit unchanged values without harm. Userspace may obtain the current state of<BR>event code values using the EVIOCG* ioctls defined in linux/input.h. The event<BR>reports supported by a device are also provided by sysfs in<BR>class/input/event*/device/capabilities/, and the properties of a device are<BR>provided in class/input/event*/device/properties.</P>
<P>Event types:<BR>===========<BR>Event types are groupings of codes under a logical input construct. Each<BR>type has a set of applicable codes to be used in generating events. See the<BR>Codes section for details on valid codes for each type.</P>
<P>* EV_SYN:<BR>&nbsp; - Used as markers to separate events. Events may be separated in time or in<BR>&nbsp;&nbsp;&nbsp; space, such as with the multitouch protocol.</P>
<P>* EV_KEY:<BR>&nbsp; - Used to describe state changes of keyboards, buttons, or other key-like<BR>&nbsp;&nbsp;&nbsp; devices.</P>
<P>* EV_REL:<BR>&nbsp; - Used to describe relative axis value changes, e.g. moving the mouse 5 units<BR>&nbsp;&nbsp;&nbsp; to the left.</P>
<P>* EV_ABS:<BR>&nbsp; - Used to describe absolute axis value changes, e.g. describing the<BR>&nbsp;&nbsp;&nbsp; coordinates of a touch on a touchscreen.</P>
<P>* EV_MSC:<BR>&nbsp; - Used to describe miscellaneous input data that do not fit into other types.</P>
<P>* EV_SW:<BR>&nbsp; - Used to describe binary state input switches.</P>
<P>* EV_LED:<BR>&nbsp; - Used to turn LEDs on devices on and off.</P>
<P>* EV_SND:<BR>&nbsp; - Used to output sound to devices.</P>
<P>* EV_REP:<BR>&nbsp; - Used for autorepeating devices.</P>
<P>* EV_FF:<BR>&nbsp; - Used to send force feedback commands to an input device.</P>
<P>* EV_PWR:<BR>&nbsp; - A special type for power button and switch input.</P>
<P>* EV_FF_STATUS:<BR>&nbsp; - Used to receive force feedback device status.</P>
<P>Event codes:<BR>===========<BR>Event codes define the precise type of event.</P>
<P>EV_SYN:<BR>----------<BR>EV_SYN event values are undefined. Their usage is defined only by when they are<BR>sent in the evdev event stream.</P>
<P>* SYN_REPORT:<BR>&nbsp; - Used to synchronize and separate events into packets of input data changes<BR>&nbsp;&nbsp;&nbsp; occurring at the same moment in time. For example, motion of a mouse may set<BR>&nbsp;&nbsp;&nbsp; the REL_X and REL_Y values for one motion, then emit a SYN_REPORT. The next<BR>&nbsp;&nbsp;&nbsp; motion will emit more REL_X and REL_Y values and send another SYN_REPORT.</P>
<P>* SYN_CONFIG:<BR>&nbsp; - TBD</P>
<P>* SYN_MT_REPORT:<BR>&nbsp; - Used to synchronize and separate touch events. See the<BR>&nbsp;&nbsp;&nbsp; multi-touch-protocol.txt document for more information.</P>
<P>* SYN_DROPPED:<BR>&nbsp; - Used to indicate buffer overrun in the evdev client's event queue.<BR>&nbsp;&nbsp;&nbsp; Client should ignore all events up to and including next SYN_REPORT<BR>&nbsp;&nbsp;&nbsp; event and query the device (using EVIOCG* ioctls) to obtain its<BR>&nbsp;&nbsp;&nbsp; current state.</P>
<P>EV_KEY:<BR>----------<BR>EV_KEY events take the form KEY_&lt;name&gt; or BTN_&lt;name&gt;. For example, KEY_A is used<BR>to represent the 'A' key on a keyboard. When a key is depressed, an event with<BR>the key's code is emitted with value 1. When the key is released, an event is<BR>emitted with value 0. Some hardware send events when a key is repeated. These<BR>events have a value of 2. In general, KEY_&lt;name&gt; is used for keyboard keys, and<BR>BTN_&lt;name&gt; is used for other types of momentary switch events.</P>
<P>A few EV_KEY codes have special meanings:</P>
<P>* BTN_TOOL_&lt;name&gt;:<BR>&nbsp; - These codes are used in conjunction with input trackpads, tablets, and<BR>&nbsp;&nbsp;&nbsp; touchscreens. These devices may be used with fingers, pens, or other tools.<BR>&nbsp;&nbsp;&nbsp; When an event occurs and a tool is used, the corresponding BTN_TOOL_&lt;name&gt;<BR>&nbsp;&nbsp;&nbsp; code should be set to a value of 1. When the tool is no longer interacting<BR>&nbsp;&nbsp;&nbsp; with the input device, the BTN_TOOL_&lt;name&gt; code should be reset to 0. All<BR>&nbsp;&nbsp;&nbsp; trackpads, tablets, and touchscreens should use at least one BTN_TOOL_&lt;name&gt;<BR>&nbsp;&nbsp;&nbsp; code when events are generated.</P>
<P>* BTN_TOUCH:<BR>&nbsp;&nbsp;&nbsp; BTN_TOUCH is used for touch contact. While an input tool is determined to be<BR>&nbsp;&nbsp;&nbsp; within meaningful physical contact, the value of this property must be set<BR>&nbsp;&nbsp;&nbsp; to 1. Meaningful physical contact may mean any contact, or it may mean<BR>&nbsp;&nbsp;&nbsp; contact conditioned by an implementation defined property. For example, a<BR>&nbsp;&nbsp;&nbsp; touchpad may set the value to 1 only when the touch pressure rises above a<BR>&nbsp;&nbsp;&nbsp; certain value. BTN_TOUCH may be combined with BTN_TOOL_&lt;name&gt; codes. For<BR>&nbsp;&nbsp;&nbsp; example, a pen tablet may set BTN_TOOL_PEN to 1 and BTN_TOUCH to 0 while the<BR>&nbsp;&nbsp;&nbsp; pen is hovering over but not touching the tablet surface.</P>
<P>Note: For appropriate function of the legacy mousedev emulation driver,<BR>BTN_TOUCH must be the first evdev code emitted in a synchronization frame.</P>
<P>Note: Historically a touch device with BTN_TOOL_FINGER and BTN_TOUCH was<BR>interpreted as a touchpad by userspace, while a similar device without<BR>BTN_TOOL_FINGER was interpreted as a touchscreen. For backwards compatibility<BR>with current userspace it is recommended to follow this distinction. In the<BR>future, this distinction will be deprecated and the device properties ioctl<BR>EVIOCGPROP, defined in linux/input.h, will be used to convey the device type.</P>
<P>* BTN_TOOL_FINGER, BTN_TOOL_DOUBLETAP, BTN_TOOL_TRIPLETAP, BTN_TOOL_QUADTAP:<BR>&nbsp; - These codes denote one, two, three, and four finger interaction on a<BR>&nbsp;&nbsp;&nbsp; trackpad or touchscreen. For example, if the user uses two fingers and moves<BR>&nbsp;&nbsp;&nbsp; them on the touchpad in an effort to scroll content on screen,<BR>&nbsp;&nbsp;&nbsp; BTN_TOOL_DOUBLETAP should be set to value 1 for the duration of the motion.<BR>&nbsp;&nbsp;&nbsp; Note that all BTN_TOOL_&lt;name&gt; codes and the BTN_TOUCH code are orthogonal in<BR>&nbsp;&nbsp;&nbsp; purpose. A trackpad event generated by finger touches should generate events<BR>&nbsp;&nbsp;&nbsp; for one code from each group. At most only one of these BTN_TOOL_&lt;name&gt;<BR>&nbsp;&nbsp;&nbsp; codes should have a value of 1 during any synchronization frame.</P>
<P>Note: Historically some drivers emitted multiple of the finger count codes with<BR>a value of 1 in the same synchronization frame. This usage is deprecated.</P>
<P>Note: In multitouch drivers, the input_mt_report_finger_count() function should<BR>be used to emit these codes. Please see multi-touch-protocol.txt for details.</P>
<P>EV_REL:<BR>----------<BR>EV_REL events describe relative changes in a property. For example, a mouse may<BR>move to the left by a certain number of units, but its absolute position in<BR>space is unknown. If the absolute position is known, EV_ABS codes should be used<BR>instead of EV_REL codes.</P>
<P>A few EV_REL codes have special meanings:</P>
<P>* REL_WHEEL, REL_HWHEEL:<BR>&nbsp; - These codes are used for vertical and horizontal scroll wheels,<BR>&nbsp;&nbsp;&nbsp; respectively.</P>
<P>EV_ABS:<BR>----------<BR>EV_ABS events describe absolute changes in a property. For example, a touchpad<BR>may emit coordinates for a touch location.</P>
<P>A few EV_ABS codes have special meanings:</P>
<P>* ABS_DISTANCE:<BR>&nbsp; - Used to describe the distance of a tool from an interaction surface. This<BR>&nbsp;&nbsp;&nbsp; event should only be emitted while the tool is hovering, meaning in close<BR>&nbsp;&nbsp;&nbsp; proximity of the device and while the value of the BTN_TOUCH code is 0. If<BR>&nbsp;&nbsp;&nbsp; the input device may be used freely in three dimensions, consider ABS_Z<BR>&nbsp;&nbsp;&nbsp; instead.</P>
<P>* ABS_MT_&lt;name&gt;:<BR>&nbsp; - Used to describe multitouch input events. Please see<BR>&nbsp;&nbsp;&nbsp; multi-touch-protocol.txt for details.</P>
<P>EV_SW:<BR>----------<BR>EV_SW events describe stateful binary switches. For example, the SW_LID code is<BR>used to denote when a laptop lid is closed.</P>
<P>Upon binding to a device or resuming from suspend, a driver must report<BR>the current switch state. This ensures that the device, kernel, and userspace<BR>state is in sync.</P>
<P>Upon resume, if the switch state is the same as before suspend, then the input<BR>subsystem will filter out the duplicate switch state reports. The driver does<BR>not need to keep the state of the switch at any time.</P>
<P>EV_MSC:<BR>----------<BR>EV_MSC events are used for input and output events that do not fall under other<BR>categories.</P>
<P>A few EV_MSC codes have special meaning:</P>
<P>* MSC_TIMESTAMP:<BR>&nbsp; - Used to report the number of microseconds since the last reset. This event<BR>&nbsp;&nbsp;&nbsp; should be coded as an uint32 value, which is allowed to wrap around with<BR>&nbsp;&nbsp;&nbsp; no special consequence. It is assumed that the time difference between two<BR>&nbsp;&nbsp;&nbsp; consecutive events is reliable on a reasonable time scale (hours).<BR>&nbsp;&nbsp;&nbsp; A reset to zero can happen, in which case the time since the last event is<BR>&nbsp;&nbsp;&nbsp; unknown.&nbsp; If the device does not provide this information, the driver must<BR>&nbsp;&nbsp;&nbsp; not provide it to user space.</P>
<P>EV_LED:<BR>----------<BR>EV_LED events are used for input and output to set and query the state of<BR>various LEDs on devices.</P>
<P>EV_REP:<BR>----------<BR>EV_REP events are used for specifying autorepeating events.</P>
<P>EV_SND:<BR>----------<BR>EV_SND events are used for sending sound commands to simple sound output<BR>devices.</P>
<P>EV_FF:<BR>----------<BR>EV_FF events are used to initialize a force feedback capable device and to cause<BR>such device to feedback.</P>
<P>EV_PWR:<BR>----------<BR>EV_PWR events are a special type of event used specifically for power<BR>management. Its usage is not well defined. To be addressed later.</P>
<P>Device properties:<BR>=================<BR>Normally, userspace sets up an input device based on the data it emits,<BR>i.e., the event types. In the case of two devices emitting the same event<BR>types, additional information can be provided in the form of device<BR>properties.</P>
<P>INPUT_PROP_DIRECT + INPUT_PROP_POINTER:<BR>--------------------------------------<BR>The INPUT_PROP_DIRECT property indicates that device coordinates should be<BR>directly mapped to screen coordinates (not taking into account trivial<BR>transformations, such as scaling, flipping and rotating). Non-direct input<BR>devices require non-trivial transformation, such as absolute to relative<BR>transformation for touchpads. Typical direct input devices: touchscreens,<BR>drawing tablets; non-direct devices: touchpads, mice.</P>
<P>The INPUT_PROP_POINTER property indicates that the device is not transposed<BR>on the screen and thus requires use of an on-screen pointer to trace user's<BR>movements.&nbsp; Typical pointer devices: touchpads, tablets, mice; non-pointer<BR>device: touchscreen.</P>
<P>If neither INPUT_PROP_DIRECT or INPUT_PROP_POINTER are set, the property is<BR>considered undefined and the device type should be deduced in the<BR>traditional way, using emitted event types.</P>
<P>INPUT_PROP_BUTTONPAD:<BR>--------------------<BR>For touchpads where the button is placed beneath the surface, such that<BR>pressing down on the pad causes a button click, this property should be<BR>set. Common in clickpad notebooks and macbooks from 2009 and onwards.</P>
<P>Originally, the buttonpad property was coded into the bcm5974 driver<BR>version field under the name integrated button. For backwards<BR>compatibility, both methods need to be checked in userspace.</P>
<P>INPUT_PROP_SEMI_MT:<BR>------------------<BR>Some touchpads, most common between 2008 and 2011, can detect the presence<BR>of multiple contacts without resolving the individual positions; only the<BR>number of contacts and a rectangular shape is known. For such<BR>touchpads, the semi-mt property should be set.</P>
<P>Depending on the device, the rectangle may enclose all touches, like a<BR>bounding box, or just some of them, for instance the two most recent<BR>touches. The diversity makes the rectangle of limited use, but some<BR>gestures can normally be extracted from it.</P>
<P>If INPUT_PROP_SEMI_MT is not set, the device is assumed to be a true MT<BR>device.</P>
<P>INPUT_PROP_TOPBUTTONPAD:<BR>-----------------------<BR>Some laptops, most notably the Lenovo *40 series provide a trackstick<BR>device but do not have physical buttons associated with the trackstick<BR>device. Instead, the top area of the touchpad is marked to show<BR>visual/haptic areas for left, middle, right buttons intended to be used<BR>with the trackstick.</P>
<P>If INPUT_PROP_TOPBUTTONPAD is set, userspace should emulate buttons<BR>accordingly. This property does not affect kernel behavior.<BR>The kernel does not provide button emulation for such devices but treats<BR>them as any other INPUT_PROP_BUTTONPAD device.</P>
<P>INPUT_PROP_ACCELEROMETER<BR>-------------------------<BR>Directional axes on this device (absolute and/or relative x, y, z) represent<BR>accelerometer data. All other axes retain their meaning. A device must not mix<BR>regular directional axes and accelerometer axes on the same event node.</P>
<P>Guidelines:<BR>==========<BR>The guidelines below ensure proper single-touch and multi-finger functionality.<BR>For multi-touch functionality, see the multi-touch-protocol.txt document for<BR>more information.</P>
<P>Mice:<BR>----------<BR>REL_{X,Y} must be reported when the mouse moves. BTN_LEFT must be used to report<BR>the primary button press. BTN_{MIDDLE,RIGHT,4,5,etc.} should be used to report<BR>further buttons of the device. REL_WHEEL and REL_HWHEEL should be used to report<BR>scroll wheel events where available.</P>
<P>Touchscreens:<BR>----------<BR>ABS_{X,Y} must be reported with the location of the touch. BTN_TOUCH must be<BR>used to report when a touch is active on the screen.<BR>BTN_{MOUSE,LEFT,MIDDLE,RIGHT} must not be reported as the result of touch<BR>contact. BTN_TOOL_&lt;name&gt; events should be reported where possible.</P>
<P>For new hardware, INPUT_PROP_DIRECT should be set.</P>
<P>Trackpads:<BR>----------<BR>Legacy trackpads that only provide relative position information must report<BR>events like mice described above.</P>
<P>Trackpads that provide absolute touch position must report ABS_{X,Y} for the<BR>location of the touch. BTN_TOUCH should be used to report when a touch is active<BR>on the trackpad. Where multi-finger support is available, BTN_TOOL_&lt;name&gt; should<BR>be used to report the number of touches active on the trackpad.</P>
<P>For new hardware, INPUT_PROP_POINTER should be set.</P>
<P>Tablets:<BR>----------<BR>BTN_TOOL_&lt;name&gt; events must be reported when a stylus or other tool is active on<BR>the tablet. ABS_{X,Y} must be reported with the location of the tool. BTN_TOUCH<BR>should be used to report when the tool is in contact with the tablet.<BR>BTN_{STYLUS,STYLUS2} should be used to report buttons on the tool itself. Any<BR>button may be used for buttons on the tablet except BTN_{MOUSE,LEFT}.<BR>BTN_{0,1,2,etc} are good generic codes for unlabeled buttons. Do not use<BR>meaningful buttons, like BTN_FORWARD, unless the button is labeled for that<BR>purpose on the device.</P>
<P>For new hardware, both INPUT_PROP_DIRECT and INPUT_PROP_POINTER should be set.