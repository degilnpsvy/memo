/**<BR>&nbsp;* struct input_dev - represents an input device<BR>&nbsp;* @name: name of the device<BR>&nbsp;* @phys: physical path to the device in the system hierarchy<BR>&nbsp;* @uniq: unique identification code for the device (if device has it)<BR>&nbsp;* @id: id of the device (struct input_id)<BR>&nbsp;* @propbit: bitmap of device properties and quirks<BR>&nbsp;* @evbit: bitmap of types of events supported by the device (EV_KEY,<BR>&nbsp;*&nbsp;EV_REL, etc.)<BR>&nbsp;* @keybit: bitmap of keys/buttons this device has<BR>&nbsp;* @relbit: bitmap of relative axes for the device<BR>&nbsp;* @absbit: bitmap of absolute axes for the device<BR>&nbsp;* @mscbit: bitmap of miscellaneous events supported by the device<BR>&nbsp;* @ledbit: bitmap of leds present on the device<BR>&nbsp;* @sndbit: bitmap of sound effects supported by the device<BR>&nbsp;* @ffbit: bitmap of force feedback effects supported by the device<BR>&nbsp;* @swbit: bitmap of switches present on the device<BR>&nbsp;* @hint_events_per_packet: average number of events generated by the<BR>&nbsp;*&nbsp;device in a packet (between EV_SYN/SYN_REPORT events). Used by<BR>&nbsp;*&nbsp;event handlers to estimate size of the buffer needed to hold<BR>&nbsp;*&nbsp;events.<BR>&nbsp;* @keycodemax: size of keycode table<BR>&nbsp;* @keycodesize: size of elements in keycode table<BR>&nbsp;* @keycode: map of scancodes to keycodes for this device<BR>&nbsp;* @getkeycode: optional legacy method to retrieve current keymap.<BR>&nbsp;* @setkeycode: optional method to alter current keymap, used to implement<BR>&nbsp;*&nbsp;sparse keymaps. If not supplied default mechanism will be used.<BR>&nbsp;*&nbsp;The method is being called while holding event_lock and thus must<BR>&nbsp;*&nbsp;not sleep<BR>&nbsp;* @ff: force feedback structure associated with the device if device<BR>&nbsp;*&nbsp;supports force feedback effects<BR>&nbsp;* @repeat_key: stores key code of the last key pressed; used to implement<BR>&nbsp;*&nbsp;software autorepeat<BR>&nbsp;* @timer: timer for software autorepeat<BR>&nbsp;* @rep: current values for autorepeat parameters (delay, rate)<BR>&nbsp;* @mt: pointer to multitouch state<BR>&nbsp;* @absinfo: array of &amp;struct input_absinfo elements holding information<BR>&nbsp;*&nbsp;about absolute axes (current value, min, max, flat, fuzz,<BR>&nbsp;*&nbsp;resolution)<BR>&nbsp;* @key: reflects current state of device's keys/buttons<BR>&nbsp;* @led: reflects current state of device's LEDs<BR>&nbsp;* @snd: reflects current state of sound effects<BR>&nbsp;* @sw: reflects current state of device's switches<BR>&nbsp;* @open: this method is called when the very first user calls<BR>&nbsp;*&nbsp;input_open_device(). The driver must prepare the device<BR>&nbsp;*&nbsp;to start generating events (start polling thread,<BR>&nbsp;*&nbsp;request an IRQ, submit URB, etc.)<BR>&nbsp;* @close: this method is called when the very last user calls<BR>&nbsp;*&nbsp;input_close_device().<BR>&nbsp;* @flush: purges the device. Most commonly used to get rid of force<BR>&nbsp;*&nbsp;feedback effects loaded into the device when disconnecting<BR>&nbsp;*&nbsp;from it<BR>&nbsp;* @event: event handler for events sent _to_ the device, like EV_LED<BR>&nbsp;*&nbsp;or EV_SND. The device is expected to carry out the requested<BR>&nbsp;*&nbsp;action (turn on a LED, play sound, etc.) The call is protected<BR>&nbsp;*&nbsp;by @event_lock and must not sleep<BR>&nbsp;* @grab: input handle that currently has the device grabbed (via<BR>&nbsp;*&nbsp;EVIOCGRAB ioctl). When a handle grabs a device it becomes sole<BR>&nbsp;*&nbsp;recipient for all input events coming from the device<BR>&nbsp;* @event_lock: this spinlock is is taken when input core receives<BR>&nbsp;*&nbsp;and processes a new event for the device (in input_event()).<BR>&nbsp;*&nbsp;Code that accesses and/or modifies parameters of a device<BR>&nbsp;*&nbsp;(such as keymap or absmin, absmax, absfuzz, etc.) after device<BR>&nbsp;*&nbsp;has been registered with input core must take this lock.<BR>&nbsp;* @mutex: serializes calls to open(), close() and flush() methods<BR>&nbsp;* @users: stores number of users (input handlers) that opened this<BR>&nbsp;*&nbsp;device. It is used by input_open_device() and input_close_device()<BR>&nbsp;*&nbsp;to make sure that dev-&gt;open() is only called when the first<BR>&nbsp;*&nbsp;user opens device and dev-&gt;close() is called when the very<BR>&nbsp;*&nbsp;last user closes the device<BR>&nbsp;* @going_away: marks devices that are in a middle of unregistering and<BR>&nbsp;*&nbsp;causes input_open_device*() fail with -ENODEV.<BR>&nbsp;* @dev: driver model's view of this device<BR>&nbsp;* @h_list: list of input handles associated with the device. When<BR>&nbsp;*&nbsp;accessing the list dev-&gt;mutex must be held<BR>&nbsp;* @node: used to place the device onto input_dev_list<BR>&nbsp;* @num_vals: number of values queued in the current frame<BR>&nbsp;* @max_vals: maximum number of values queued in a frame<BR>&nbsp;* @vals: array of values queued in the current frame<BR>&nbsp;* @devres_managed: indicates that devices is managed with devres framework<BR>&nbsp;*&nbsp;and needs not be explicitly unregistered or freed.<BR>&nbsp;*/<BR>struct input_dev {<BR>&nbsp;const char *name;<BR>&nbsp;const char *phys;<BR>&nbsp;const char *uniq;<BR>&nbsp;struct input_id id; 
<P></P>
<P>&nbsp;unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</P>
<P>&nbsp;unsigned long evbit[BITS_TO_LONGS(EV_CNT)];<BR>&nbsp;unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];<BR>&nbsp;unsigned long relbit[BITS_TO_LONGS(REL_CNT)];<BR>&nbsp;unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];<BR>&nbsp;unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];<BR>&nbsp;unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];<BR>&nbsp;unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];<BR>&nbsp;unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];<BR>&nbsp;unsigned long swbit[BITS_TO_LONGS(SW_CNT)];</P>
<P>&nbsp;unsigned int hint_events_per_packet;</P>
<P>&nbsp;unsigned int keycodemax;<BR>&nbsp;unsigned int keycodesize;<BR>&nbsp;void *keycode;</P>
<P>&nbsp;int (*setkeycode)(struct input_dev *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct input_keymap_entry *ke,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int *old_keycode);<BR>&nbsp;int (*getkeycode)(struct input_dev *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct input_keymap_entry *ke);</P>
<P>&nbsp;struct ff_device *ff;</P>
<P>&nbsp;unsigned int repeat_key;<BR>&nbsp;struct timer_list timer;</P>
<P>&nbsp;int rep[REP_CNT];</P>
<P>&nbsp;struct input_mt *mt;</P>
<P>&nbsp;struct input_absinfo *absinfo;</P>
<P>&nbsp;unsigned long key[BITS_TO_LONGS(KEY_CNT)];<BR>&nbsp;unsigned long led[BITS_TO_LONGS(LED_CNT)];<BR>&nbsp;unsigned long snd[BITS_TO_LONGS(SND_CNT)];<BR>&nbsp;unsigned long sw[BITS_TO_LONGS(SW_CNT)];</P>
<P>&nbsp;int (*open)(struct input_dev *dev);<BR>&nbsp;void (*close)(struct input_dev *dev);<BR>&nbsp;int (*flush)(struct input_dev *dev, struct file *file);<BR>&nbsp;int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);</P>
<P>&nbsp;struct input_handle __rcu *grab;</P>
<P>&nbsp;spinlock_t event_lock;<BR>&nbsp;struct mutex mutex;</P>
<P>&nbsp;unsigned int users;<BR>&nbsp;bool going_away;</P>
<P>&nbsp;struct device dev;</P>
<P>&nbsp;struct list_head&nbsp;h_list;<BR>&nbsp;struct list_head&nbsp;node;</P>
<P>&nbsp;unsigned int num_vals;<BR>&nbsp;unsigned int max_vals;<BR>&nbsp;struct input_value *vals;</P>
<P>&nbsp;bool devres_managed;<BR>};<BR>#define to_input_dev(d) container_of(d, struct input_dev, dev)