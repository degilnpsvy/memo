/**<BR>&nbsp;* struct input_handler - implements one of interfaces for input devices<BR>&nbsp;* @private: driver-specific data<BR>&nbsp;* @event: event handler. This method is being called by input core with<BR>&nbsp;*&nbsp;interrupts disabled and dev-&gt;event_lock spinlock held and so<BR>&nbsp;*&nbsp;it may not sleep<BR>&nbsp;* @events: event sequence handler. This method is being called by<BR>&nbsp;*&nbsp;input core with interrupts disabled and dev-&gt;event_lock<BR>&nbsp;*&nbsp;spinlock held and so it may not sleep<BR>&nbsp;* @filter: similar to @event; separates normal event handlers from<BR>&nbsp;*&nbsp;"filters".<BR>&nbsp;* @match: called after comparing device's id with handler's id_table<BR>&nbsp;*&nbsp;to perform fine-grained matching between device and handler<BR>&nbsp;* @connect: called when attaching a handler to an input device<BR>&nbsp;* @disconnect: disconnects a handler from input device<BR>&nbsp;* @start: starts handler for given handle. This function is called by<BR>&nbsp;*&nbsp;input core right after connect() method and also when a process<BR>&nbsp;*&nbsp;that "grabbed" a device releases it<BR>&nbsp;* @legacy_minors: set to %true by drivers using legacy minor ranges<BR>&nbsp;* @minor: beginning of range of 32 legacy minors for devices this driver<BR>&nbsp;*&nbsp;can provide<BR>&nbsp;* @name: name of the handler, to be shown in /proc/bus/input/handlers<BR>&nbsp;* @id_table: pointer to a table of input_device_ids this driver can<BR>&nbsp;*&nbsp;handle<BR>&nbsp;* @h_list: list of input handles associated with the handler<BR>&nbsp;* @node: for placing the driver onto input_handler_list<BR>&nbsp;*<BR>&nbsp;* Input handlers attach to input devices and create input handles. There<BR>&nbsp;* are likely several handlers attached to any given input device at the<BR>&nbsp;* same time. All of them will get their copy of input event generated by<BR>&nbsp;* the device.<BR>&nbsp;*<BR>&nbsp;* The very same structure is used to implement input filters. Input core<BR>&nbsp;* allows filters to run first and will not pass event to regular handlers<BR>&nbsp;* if any of the filters indicate that the event should be filtered (by<BR>&nbsp;* returning %true from their filter() method).<BR>&nbsp;*<BR>&nbsp;* Note that input core serializes calls to connect() and disconnect()<BR>&nbsp;* methods.<BR>&nbsp;*/<BR>struct input_handler { 
<P></P>
<P>&nbsp;void *private;</P>
<P>&nbsp;void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);<BR>&nbsp;void (*events)(struct input_handle *handle,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct input_value *vals, unsigned int count);<BR>&nbsp;bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);<BR>&nbsp;bool (*match)(struct input_handler *handler, struct input_dev *dev);<BR>&nbsp;int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);<BR>&nbsp;void (*disconnect)(struct input_handle *handle);<BR>&nbsp;void (*start)(struct input_handle *handle);</P>
<P>&nbsp;bool legacy_minors;<BR>&nbsp;int minor;<BR>&nbsp;const char *name;</P>
<P>&nbsp;const struct input_device_id *id_table;</P>
<P>&nbsp;struct list_head&nbsp;h_list;<BR>&nbsp;struct list_head&nbsp;node;<BR>};