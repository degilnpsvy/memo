/**<BR>&nbsp;*&nbsp;probe_irq_on&nbsp;- begin an interrupt autodetect<BR>&nbsp;*<BR>&nbsp;*&nbsp;Commence probing for an interrupt. The interrupts are scanned<BR>&nbsp;*&nbsp;and a mask of potential interrupt lines is returned.<BR>&nbsp;*<BR>&nbsp;*/<BR>unsigned long probe_irq_on(void)<BR>{<BR>&nbsp;struct irq_desc *desc;<BR>&nbsp;unsigned long mask = 0;<BR>&nbsp;int i; 
<P></P>
<P>&nbsp;/*<BR>&nbsp; * quiesce the kernel, or at least the asynchronous portion<BR>&nbsp; */<BR>&nbsp;async_synchronize_full();<BR>&nbsp;mutex_lock(&amp;probing_active);<BR>&nbsp;/*<BR>&nbsp; * something may have generated an irq long ago and we want to<BR>&nbsp; * flush such a longstanding irq before considering it as spurious.<BR>&nbsp; */<BR>&nbsp;for_each_irq_desc_reverse(i, desc) {<BR>&nbsp;&nbsp;raw_spin_lock_irq(&amp;desc-&gt;lock);<BR>&nbsp;&nbsp;if (!desc-&gt;action &amp;&amp; irq_settings_can_probe(desc)) {<BR>&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp; * Some chips need to know about probing in<BR>&nbsp;&nbsp;&nbsp; * progress:<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;if (desc-&gt;irq_data.chip-&gt;irq_set_type)<BR>&nbsp;&nbsp;&nbsp;&nbsp;desc-&gt;irq_data.chip-&gt;irq_set_type(&amp;desc-&gt;irq_data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IRQ_TYPE_PROBE);<BR>&nbsp;&nbsp;&nbsp;irq_startup(desc, false);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;raw_spin_unlock_irq(&amp;desc-&gt;lock);<BR>&nbsp;}</P>
<P>&nbsp;/* Wait for longstanding interrupts to trigger. */<BR>&nbsp;msleep(20);</P>
<P>&nbsp;/*<BR>&nbsp; * enable any unassigned irqs<BR>&nbsp; * (we must startup again here because if a longstanding irq<BR>&nbsp; * happened in the previous stage, it may have masked itself)<BR>&nbsp; */<BR>&nbsp;for_each_irq_desc_reverse(i, desc) {<BR>&nbsp;&nbsp;raw_spin_lock_irq(&amp;desc-&gt;lock);<BR>&nbsp;&nbsp;if (!desc-&gt;action &amp;&amp; irq_settings_can_probe(desc)) {<BR>&nbsp;&nbsp;&nbsp;desc-&gt;istate |= IRQS_AUTODETECT | IRQS_WAITING;<BR>&nbsp;&nbsp;&nbsp;if (irq_startup(desc, false))<BR>&nbsp;&nbsp;&nbsp;&nbsp;desc-&gt;istate |= IRQS_PENDING;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;raw_spin_unlock_irq(&amp;desc-&gt;lock);<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * Wait for spurious interrupts to trigger<BR>&nbsp; */<BR>&nbsp;msleep(100);</P>
<P>&nbsp;/*<BR>&nbsp; * Now filter out any obviously spurious interrupts<BR>&nbsp; */<BR>&nbsp;for_each_irq_desc(i, desc) {<BR>&nbsp;&nbsp;raw_spin_lock_irq(&amp;desc-&gt;lock);</P>
<P>&nbsp;&nbsp;if (desc-&gt;istate &amp; IRQS_AUTODETECT) {<BR>&nbsp;&nbsp;&nbsp;/* It triggered already - consider it spurious. */<BR>&nbsp;&nbsp;&nbsp;if (!(desc-&gt;istate &amp; IRQS_WAITING)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;desc-&gt;istate &amp;= ~IRQS_AUTODETECT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;irq_shutdown(desc);<BR>&nbsp;&nbsp;&nbsp;} else<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (i &lt; 32)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask |= 1 &lt;&lt; i;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;raw_spin_unlock_irq(&amp;desc-&gt;lock);<BR>&nbsp;}</P>
<P>&nbsp;return mask;<BR>}<BR>EXPORT_SYMBOL(probe_irq_on);