/**<BR>&nbsp;*&nbsp;probe_irq_off&nbsp;- end an interrupt autodetect<BR>&nbsp;*&nbsp;@val: mask of potential interrupts (unused)<BR>&nbsp;*<BR>&nbsp;*&nbsp;Scans the unused interrupt lines and returns the line which<BR>&nbsp;*&nbsp;appears to have triggered the interrupt. If no interrupt was<BR>&nbsp;*&nbsp;found then zero is returned. If more than one interrupt is<BR>&nbsp;*&nbsp;found then minus the first candidate is returned to indicate<BR>&nbsp;*&nbsp;their is doubt.<BR>&nbsp;*<BR>&nbsp;*&nbsp;The interrupt probe logic state is returned to its previous<BR>&nbsp;*&nbsp;value.<BR>&nbsp;*<BR>&nbsp;*&nbsp;BUGS: When used in a module (which arguably shouldn't happen)<BR>&nbsp;*&nbsp;nothing prevents two IRQ probe callers from overlapping. The<BR>&nbsp;*&nbsp;results of this are non-optimal.<BR>&nbsp;*/<BR>int probe_irq_off(unsigned long val)<BR>{<BR>&nbsp;int i, irq_found = 0, nr_of_irqs = 0;<BR>&nbsp;struct irq_desc *desc; 
<P></P>
<P>&nbsp;for_each_irq_desc(i, desc) {<BR>&nbsp;&nbsp;raw_spin_lock_irq(&amp;desc-&gt;lock);</P>
<P>&nbsp;&nbsp;if (desc-&gt;istate &amp; IRQS_AUTODETECT) {<BR>&nbsp;&nbsp;&nbsp;if (!(desc-&gt;istate &amp; IRQS_WAITING)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (!nr_of_irqs)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irq_found = i;<BR>&nbsp;&nbsp;&nbsp;&nbsp;nr_of_irqs++;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;desc-&gt;istate &amp;= ~IRQS_AUTODETECT;<BR>&nbsp;&nbsp;&nbsp;irq_shutdown(desc);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;raw_spin_unlock_irq(&amp;desc-&gt;lock);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;probing_active);</P>
<P>&nbsp;if (nr_of_irqs &gt; 1)<BR>&nbsp;&nbsp;irq_found = -irq_found;</P>
<P>&nbsp;return irq_found;<BR>}<BR>EXPORT_SYMBOL(probe_irq_off);