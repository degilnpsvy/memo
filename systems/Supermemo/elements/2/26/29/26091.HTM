# /linux-4.1/kernel/irq/autoprobe.c 
<P></P>
<P>/*<BR>&nbsp;* linux/kernel/irq/autoprobe.c<BR>&nbsp;*<BR>&nbsp;* Copyright (C) 1992, 1998-2004 Linus Torvalds, Ingo Molnar<BR>&nbsp;*<BR>&nbsp;* This file contains the interrupt probing code and driver APIs.<BR>&nbsp;*/</P>
<P></P>
<P>#include &lt;linux/irq.h&gt;<BR>#include &lt;linux/module.h&gt;<BR>#include &lt;linux/interrupt.h&gt;<BR>#include &lt;linux/delay.h&gt;<BR>#include &lt;linux/async.h&gt;</P>
<P>#include "internals.h"</P>
<P>/*<BR>&nbsp;* Autodetection depends on the fact that any interrupt that<BR>&nbsp;* comes in on to an unassigned handler will get stuck with<BR>&nbsp;* "IRQS_WAITING" cleared and the interrupt disabled.<BR>&nbsp;*/<BR>static DEFINE_MUTEX(probing_active);</P>
<P><FONT class=extract>/**<BR>&nbsp;*&nbsp;probe_irq_on&nbsp;- begin an interrupt autodetect<BR>&nbsp;*<BR>&nbsp;*&nbsp;Commence probing for an interrupt. The interrupts are scanned<BR>&nbsp;*&nbsp;and a mask of potential interrupt lines is returned.<BR>&nbsp;*<BR>&nbsp;*/<BR>unsigned long probe_irq_on(void)<BR>{<BR>&nbsp;struct irq_desc *desc;<BR>&nbsp;unsigned long mask = 0;<BR>&nbsp;int i;</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * quiesce the kernel, or at least the asynchronous portion<BR>&nbsp; */<BR>&nbsp;async_synchronize_full();<BR>&nbsp;mutex_lock(&amp;probing_active);<BR>&nbsp;/*<BR>&nbsp; * something may have generated an irq long ago and we want to<BR>&nbsp; * flush such a longstanding irq before considering it as spurious.<BR>&nbsp; */<BR>&nbsp;for_each_irq_desc_reverse(i, desc) {<BR>&nbsp;&nbsp;raw_spin_lock_irq(&amp;desc-&gt;lock);<BR>&nbsp;&nbsp;if (!desc-&gt;action &amp;&amp; irq_settings_can_probe(desc)) {<BR>&nbsp;&nbsp;&nbsp;/*<BR>&nbsp;&nbsp;&nbsp; * Some chips need to know about probing in<BR>&nbsp;&nbsp;&nbsp; * progress:<BR>&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;if (desc-&gt;irq_data.chip-&gt;irq_set_type)<BR>&nbsp;&nbsp;&nbsp;&nbsp;desc-&gt;irq_data.chip-&gt;irq_set_type(&amp;desc-&gt;irq_data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IRQ_TYPE_PROBE);<BR>&nbsp;&nbsp;&nbsp;irq_startup(desc, false);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;raw_spin_unlock_irq(&amp;desc-&gt;lock);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/* Wait for longstanding interrupts to trigger. */<BR>&nbsp;msleep(20);</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * enable any unassigned irqs<BR>&nbsp; * (we must startup again here because if a longstanding irq<BR>&nbsp; * happened in the previous stage, it may have masked itself)<BR>&nbsp; */<BR>&nbsp;for_each_irq_desc_reverse(i, desc) {<BR>&nbsp;&nbsp;raw_spin_lock_irq(&amp;desc-&gt;lock);<BR>&nbsp;&nbsp;if (!desc-&gt;action &amp;&amp; irq_settings_can_probe(desc)) {<BR>&nbsp;&nbsp;&nbsp;desc-&gt;istate |= IRQS_AUTODETECT | IRQS_WAITING;<BR>&nbsp;&nbsp;&nbsp;if (irq_startup(desc, false))<BR>&nbsp;&nbsp;&nbsp;&nbsp;desc-&gt;istate |= IRQS_PENDING;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;raw_spin_unlock_irq(&amp;desc-&gt;lock);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * Wait for spurious interrupts to trigger<BR>&nbsp; */<BR>&nbsp;msleep(100);</FONT></P>
<P><FONT class=extract>&nbsp;/*<BR>&nbsp; * Now filter out any obviously spurious interrupts<BR>&nbsp; */<BR>&nbsp;for_each_irq_desc(i, desc) {<BR>&nbsp;&nbsp;raw_spin_lock_irq(&amp;desc-&gt;lock);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (desc-&gt;istate &amp; IRQS_AUTODETECT) {<BR>&nbsp;&nbsp;&nbsp;/* It triggered already - consider it spurious. */<BR>&nbsp;&nbsp;&nbsp;if (!(desc-&gt;istate &amp; IRQS_WAITING)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;desc-&gt;istate &amp;= ~IRQS_AUTODETECT;<BR>&nbsp;&nbsp;&nbsp;&nbsp;irq_shutdown(desc);<BR>&nbsp;&nbsp;&nbsp;} else<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (i &lt; 32)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask |= 1 &lt;&lt; i;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;raw_spin_unlock_irq(&amp;desc-&gt;lock);<BR>&nbsp;}</FONT></P>
<P><FONT class=extract>&nbsp;return mask;<BR>}<BR>EXPORT_SYMBOL(probe_irq_on);</FONT></P>
<P>/**<BR>&nbsp;*&nbsp;probe_irq_mask - scan a bitmap of interrupt lines<BR>&nbsp;*&nbsp;@val:&nbsp;mask of interrupts to consider<BR>&nbsp;*<BR>&nbsp;*&nbsp;Scan the interrupt lines and return a bitmap of active<BR>&nbsp;*&nbsp;autodetect interrupts. The interrupt probe logic state<BR>&nbsp;*&nbsp;is then returned to its previous value.<BR>&nbsp;*<BR>&nbsp;*&nbsp;Note: we need to scan all the irq's even though we will<BR>&nbsp;*&nbsp;only return autodetect irq numbers - just so that we reset<BR>&nbsp;*&nbsp;them all to a known state.<BR>&nbsp;*/<BR>unsigned int probe_irq_mask(unsigned long val)<BR>{<BR>&nbsp;unsigned int mask = 0;<BR>&nbsp;struct irq_desc *desc;<BR>&nbsp;int i;</P>
<P>&nbsp;for_each_irq_desc(i, desc) {<BR>&nbsp;&nbsp;raw_spin_lock_irq(&amp;desc-&gt;lock);<BR>&nbsp;&nbsp;if (desc-&gt;istate &amp; IRQS_AUTODETECT) {<BR>&nbsp;&nbsp;&nbsp;if (i &lt; 16 &amp;&amp; !(desc-&gt;istate &amp; IRQS_WAITING))<BR>&nbsp;&nbsp;&nbsp;&nbsp;mask |= 1 &lt;&lt; i;</P>
<P>&nbsp;&nbsp;&nbsp;desc-&gt;istate &amp;= ~IRQS_AUTODETECT;<BR>&nbsp;&nbsp;&nbsp;irq_shutdown(desc);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;raw_spin_unlock_irq(&amp;desc-&gt;lock);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;probing_active);</P>
<P>&nbsp;return mask &amp; val;<BR>}<BR>EXPORT_SYMBOL(probe_irq_mask);</P>
<P><FONT class=extract>/**<BR>&nbsp;*&nbsp;probe_irq_off&nbsp;- end an interrupt autodetect<BR>&nbsp;*&nbsp;@val: mask of potential interrupts (unused)<BR>&nbsp;*<BR>&nbsp;*&nbsp;Scans the unused interrupt lines and returns the line which<BR>&nbsp;*&nbsp;appears to have triggered the interrupt. If no interrupt was<BR>&nbsp;*&nbsp;found then zero is returned. If more than one interrupt is<BR>&nbsp;*&nbsp;found then minus the first candidate is returned to indicate<BR>&nbsp;*&nbsp;their is doubt.<BR>&nbsp;*<BR>&nbsp;*&nbsp;The interrupt probe logic state is returned to its previous<BR>&nbsp;*&nbsp;value.<BR>&nbsp;*<BR>&nbsp;*&nbsp;BUGS: When used in a module (which arguably shouldn't happen)<BR>&nbsp;*&nbsp;nothing prevents two IRQ probe callers from overlapping. The<BR>&nbsp;*&nbsp;results of this are non-optimal.<BR>&nbsp;*/<BR>int probe_irq_off(unsigned long val)<BR>{<BR>&nbsp;int i, irq_found = 0, nr_of_irqs = 0;<BR>&nbsp;struct irq_desc *desc;</FONT></P>
<P><FONT class=extract>&nbsp;for_each_irq_desc(i, desc) {<BR>&nbsp;&nbsp;raw_spin_lock_irq(&amp;desc-&gt;lock);</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;if (desc-&gt;istate &amp; IRQS_AUTODETECT) {<BR>&nbsp;&nbsp;&nbsp;if (!(desc-&gt;istate &amp; IRQS_WAITING)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (!nr_of_irqs)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;irq_found = i;<BR>&nbsp;&nbsp;&nbsp;&nbsp;nr_of_irqs++;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;desc-&gt;istate &amp;= ~IRQS_AUTODETECT;<BR>&nbsp;&nbsp;&nbsp;irq_shutdown(desc);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;raw_spin_unlock_irq(&amp;desc-&gt;lock);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;probing_active);</FONT></P>
<P><FONT class=extract>&nbsp;if (nr_of_irqs &gt; 1)<BR>&nbsp;&nbsp;irq_found = -irq_found;</FONT></P>
<P><FONT class=extract>&nbsp;return irq_found;<BR>}<BR>EXPORT_SYMBOL(probe_irq_off);</FONT></P>
<P>&nbsp;