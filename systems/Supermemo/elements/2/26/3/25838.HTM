/**<BR>&nbsp;* device_add - add device to device hierarchy.<BR>&nbsp;* @dev: device.<BR>&nbsp;*<BR>&nbsp;* This is part 2 of device_register(), though may be called<BR>&nbsp;* separately _iff_ device_initialize() has been called separately.<BR>&nbsp;*<BR>&nbsp;* This adds @dev to the kobject hierarchy via kobject_add(), adds it<BR>&nbsp;* to the global and sibling lists for the device, then<BR>&nbsp;* adds it to the other relevant subsystems of the driver model.<BR>&nbsp;*<BR><FONT class=extract>&nbsp;* Do not call this routine or device_register() more than once for<BR>&nbsp;* any device structure.&nbsp; The driver model core is not designed to work<BR>&nbsp;* with devices that get unregistered and then spring back to life.<BR>&nbsp;* (Among other things, it's very hard to guarantee that all references<BR>&nbsp;* to the previous incarnation of @dev have been dropped.)&nbsp; Allocate<BR>&nbsp;* and register a fresh new struct device instead.</FONT><BR>&nbsp;*<BR>&nbsp;* NOTE: _Never_ directly free @dev after calling this function, even<BR>&nbsp;* if it returned an error! Always use put_device() to give up your<BR>&nbsp;* reference instead.<BR>&nbsp;*/<BR>int device_add(struct device *dev)<BR>{<BR>&nbsp;struct device *parent = NULL;<BR>&nbsp;struct kobject *kobj;<BR>&nbsp;struct class_interface *class_intf;<BR>&nbsp;int error = -EINVAL; 
<P></P>
<P>&nbsp;dev = get_device(dev);<BR>&nbsp;if (!dev)<BR>&nbsp;&nbsp;goto done;</P>
<P>&nbsp;if (!dev-&gt;p) {<BR>&nbsp;&nbsp;error = device_private_init(dev);<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto done;<BR>&nbsp;}</P>
<P>&nbsp;/*<BR>&nbsp; * for statically allocated devices, which should all be converted<BR>&nbsp; * some day, we need to initialize the name. We prevent reading back<BR>&nbsp; * the name, and force the use of dev_name()<BR>&nbsp; */<BR>&nbsp;if (dev-&gt;init_name) {<BR>&nbsp;&nbsp;dev_set_name(dev, "%s", dev-&gt;init_name);<BR>&nbsp;&nbsp;dev-&gt;init_name = NULL;<BR>&nbsp;}</P>
<P>&nbsp;/* subsystems can specify simple device enumeration */<BR>&nbsp;if (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)<BR>&nbsp;&nbsp;dev_set_name(dev, "%s%u", dev-&gt;bus-&gt;dev_name, dev-&gt;id);</P>
<P>&nbsp;if (!dev_name(dev)) {<BR>&nbsp;&nbsp;error = -EINVAL;<BR>&nbsp;&nbsp;goto name_error;<BR>&nbsp;}</P>
<P>&nbsp;pr_debug("device: '%s': %s\n", dev_name(dev), __func__);</P>
<P>&nbsp;parent = get_device(dev-&gt;parent);<BR>&nbsp;kobj = get_device_parent(dev, parent);<BR>&nbsp;if (kobj)<BR>&nbsp;&nbsp;dev-&gt;kobj.parent = kobj;</P>
<P>&nbsp;/* use parent numa_node */<BR>&nbsp;if (parent)<BR>&nbsp;&nbsp;set_dev_node(dev, dev_to_node(parent));</P>
<P>&nbsp;/* first, register with generic layer. */<BR>&nbsp;/* we require the name to be set before, and pass NULL */<BR>&nbsp;error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, NULL);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto Error;</P>
<P>&nbsp;/* notify platform of device entry */<BR>&nbsp;if (platform_notify)<BR>&nbsp;&nbsp;platform_notify(dev);</P>
<P>&nbsp;error = device_create_file(dev, &amp;dev_attr_uevent);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto attrError;</P>
<P>&nbsp;error = device_add_class_symlinks(dev);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto SymlinkError;<BR>&nbsp;error = device_add_attrs(dev);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto AttrsError;<BR>&nbsp;error = bus_add_device(dev);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto BusError;<BR>&nbsp;error = dpm_sysfs_add(dev);<BR>&nbsp;if (error)<BR>&nbsp;&nbsp;goto DPMError;<BR>&nbsp;device_pm_add(dev);</P>
<P>&nbsp;if (MAJOR(dev-&gt;devt)) {<BR>&nbsp;&nbsp;error = device_create_file(dev, &amp;dev_attr_dev);<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto DevAttrError;</P>
<P>&nbsp;&nbsp;error = device_create_sys_dev_entry(dev);<BR>&nbsp;&nbsp;if (error)<BR>&nbsp;&nbsp;&nbsp;goto SysEntryError;</P>
<P>&nbsp;&nbsp;devtmpfs_create_node(dev);<BR>&nbsp;}</P>
<P>&nbsp;/* Notify clients of device addition.&nbsp; This call must come<BR>&nbsp; * after dpm_sysfs_add() and before kobject_uevent().<BR>&nbsp; */<BR>&nbsp;if (dev-&gt;bus)<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUS_NOTIFY_ADD_DEVICE, dev);</P>
<P>&nbsp;kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);<BR>&nbsp;bus_probe_device(dev);<BR>&nbsp;if (parent)<BR>&nbsp;&nbsp;klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;parent-&gt;p-&gt;klist_children);</P>
<P>&nbsp;if (dev-&gt;class) {<BR>&nbsp;&nbsp;mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);<BR>&nbsp;&nbsp;/* tie the class to the device */<BR>&nbsp;&nbsp;klist_add_tail(&amp;dev-&gt;knode_class,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dev-&gt;class-&gt;p-&gt;klist_devices);</P>
<P>&nbsp;&nbsp;/* notify any interfaces that the device is here */<BR>&nbsp;&nbsp;list_for_each_entry(class_intf,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)<BR>&nbsp;&nbsp;&nbsp;if (class_intf-&gt;add_dev)<BR>&nbsp;&nbsp;&nbsp;&nbsp;class_intf-&gt;add_dev(dev, class_intf);<BR>&nbsp;&nbsp;mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);<BR>&nbsp;}<BR>done:<BR>&nbsp;put_device(dev);<BR>&nbsp;return error;<BR>&nbsp;SysEntryError:<BR>&nbsp;if (MAJOR(dev-&gt;devt))<BR>&nbsp;&nbsp;device_remove_file(dev, &amp;dev_attr_dev);<BR>&nbsp;DevAttrError:<BR>&nbsp;device_pm_remove(dev);<BR>&nbsp;dpm_sysfs_remove(dev);<BR>&nbsp;DPMError:<BR>&nbsp;bus_remove_device(dev);<BR>&nbsp;BusError:<BR>&nbsp;device_remove_attrs(dev);<BR>&nbsp;AttrsError:<BR>&nbsp;device_remove_class_symlinks(dev);<BR>&nbsp;SymlinkError:<BR>&nbsp;device_remove_file(dev, &amp;dev_attr_uevent);<BR>&nbsp;attrError:<BR>&nbsp;kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);<BR>&nbsp;kobject_del(&amp;dev-&gt;kobj);<BR>&nbsp;Error:<BR>&nbsp;cleanup_device_parent(dev);<BR>&nbsp;put_device(parent);<BR>name_error:<BR>&nbsp;kfree(dev-&gt;p);<BR>&nbsp;dev-&gt;p = NULL;<BR>&nbsp;goto done;<BR>}<BR>EXPORT_SYMBOL_GPL(device_add);