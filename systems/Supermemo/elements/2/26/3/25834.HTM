/**<BR>&nbsp;* complete: - signals a single thread waiting on this completion<BR>&nbsp;* @x:&nbsp; holds the state of this particular completion<BR>&nbsp;*<BR>&nbsp;* This will wake up a single thread waiting on this completion. Threads will be<BR>&nbsp;* awakened in the same order in which they were queued.<BR>&nbsp;*<BR>&nbsp;* See also complete_all(), wait_for_completion() and related routines.<BR>&nbsp;*<BR>&nbsp;* It may be assumed that this function implies a write memory barrier before<BR>&nbsp;* changing the task state if and only if any tasks are woken up.<BR>&nbsp;*/<BR>void complete(struct completion *x)<BR>{<BR>&nbsp;unsigned long flags;
<P></P>
<P>&nbsp;spin_lock_irqsave(&amp;x-&gt;wait.lock, flags);<BR>&nbsp;x-&gt;done++;<BR>&nbsp;__wake_up_locked(&amp;x-&gt;wait, TASK_NORMAL, 1);<BR>&nbsp;spin_unlock_irqrestore(&amp;x-&gt;wait.lock, flags);<BR>}<BR>EXPORT_SYMBOL(complete);