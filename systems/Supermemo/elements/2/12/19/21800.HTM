# Documentation/driver-mode/platform.txt 
<P></P>
<P><FONT class=extract>Platform Devices and Drivers<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>See &lt;linux/platform_device.h&gt; for the driver model interface to the<BR>platform bus:&nbsp; platform_device, and platform_driver.&nbsp; This pseudo-bus<BR>is used to connect devices on busses with minimal infrastructure,<BR>like those used to integrate peripherals on many system-on-chip<BR>processors, or some "legacy" PC interconnects; as opposed to large<BR>formally specified ones like PCI or USB.</FONT></P>
<P></P>
<P><BR><FONT class=extract>Platform devices<BR>~~~~~~~~~~~~~~~~<BR>Platform devices are devices that typically appear as autonomous<BR>entities in the system. This includes legacy port-based devices and<BR>host bridges to peripheral buses, and most controllers integrated<BR>into system-on-chip platforms.&nbsp; What they usually have in common<BR>is direct addressing from a CPU bus.&nbsp; Rarely, a platform_device will<BR>be connected through a segment of some other kind of bus; but its<BR>registers will still be directly addressable.</FONT></P>
<P><FONT class=extract>Platform devices are given a name, used in driver binding, and a<BR>list of resources such as addresses and IRQs.</FONT></P>
<P><FONT class=extract>struct platform_device {<BR>&nbsp;const char&nbsp;*name;<BR>&nbsp;u32&nbsp;&nbsp;id;<BR>&nbsp;struct device&nbsp;dev;<BR>&nbsp;u32&nbsp;&nbsp;num_resources;<BR>&nbsp;struct resource&nbsp;*resource;<BR>};</FONT></P>
<P><BR><FONT class=extract>Platform drivers<BR>~~~~~~~~~~~~~~~~<BR>Platform drivers follow the standard driver model convention, where<BR>discovery/enumeration is handled outside the drivers, and drivers<BR>provide probe() and remove() methods.&nbsp; They support power management<BR>and shutdown notifications using the standard conventions.</FONT></P>
<P><FONT class=extract>struct platform_driver {<BR>&nbsp;int (*probe)(struct platform_device *);<BR>&nbsp;int (*remove)(struct platform_device *);<BR>&nbsp;void (*shutdown)(struct platform_device *);<BR>&nbsp;int (*suspend)(struct platform_device *, pm_message_t state);<BR>&nbsp;int (*suspend_late)(struct platform_device *, pm_message_t state);<BR>&nbsp;int (*resume_early)(struct platform_device *);<BR>&nbsp;int (*resume)(struct platform_device *);<BR>&nbsp;struct device_driver driver;<BR>};</FONT></P>
<P><FONT class=extract>Note that probe() should in general verify that the specified device hardware<BR>actually exists; sometimes platform setup code can't be sure.&nbsp; The probing<BR>can use device resources, including clocks, and device platform_data.</FONT></P>
<P><FONT class=extract>Platform drivers register themselves the normal way:</FONT></P>
<P><FONT class=extract>&nbsp;int platform_driver_register(struct platform_driver *drv);</FONT></P>
<P><FONT class=extract>Or, in common situations where the device is known not to be hot-pluggable,<BR>the probe() routine can live in an init section to reduce the driver's<BR>runtime memory footprint:</FONT></P>
<P><FONT class=extract>&nbsp;int platform_driver_probe(struct platform_driver *drv,<BR>&nbsp;&nbsp;&nbsp;&nbsp; int (*probe)(struct platform_device *))</FONT></P>
<P><BR><FONT class=extract>Device Enumeration<BR>~~~~~~~~~~~~~~~~~~<BR>As a rule, platform specific (and often board-specific) setup code will<BR>register platform devices:</FONT></P>
<P><FONT class=extract>&nbsp;int platform_device_register(struct platform_device *pdev);</FONT></P>
<P><FONT class=extract>&nbsp;int platform_add_devices(struct platform_device **pdevs, int ndev);</FONT></P>
<P><FONT class=extract>The general rule is to register only those devices that actually exist,<BR>but in some cases extra devices might be registered.&nbsp; For example, a kernel<BR>might be configured to work with an external network adapter that might not<BR>be populated on all boards, or likewise to work with an integrated controller<BR>that some boards might not hook up to any peripherals.</FONT></P>
<P><FONT class=extract>In some cases, boot firmware will export tables describing the devices<BR>that are populated on a given board.&nbsp;&nbsp; Without such tables, often the<BR>only way for system setup code to set up the correct devices is to build<BR>a kernel for a specific target board.&nbsp; Such board-specific kernels are<BR>common with embedded and custom systems development.</FONT></P>
<P><FONT class=extract>In many cases, the memory and IRQ resources associated with the platform<BR>device are not enough to let the device's driver work.&nbsp; Board setup code<BR>will often provide additional information using the device's platform_data<BR>field to hold additional information.</FONT></P>
<P><FONT class=extract>Embedded systems frequently need one or more clocks for platform devices,<BR>which are normally kept off until they're actively needed (to save power).<BR>System setup also associates those clocks with the device, so that that<BR>calls to clk_get(&amp;pdev-&gt;dev, clock_name) return them as needed.</FONT></P>
<P><BR><FONT class=extract>Legacy Drivers:&nbsp; Device Probing<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>Some drivers are not fully converted to the driver model, because they take<BR>on a non-driver role:&nbsp; the driver registers its platform device, rather than<BR>leaving that for system infrastructure.&nbsp; Such drivers can't be hotplugged<BR>or coldplugged, since those mechanisms require device creation to be in a<BR>different system component than the driver.</FONT></P>
<P><FONT class=extract>The only "good" reason for this is to handle older system designs which, like<BR>original IBM PCs, rely on error-prone "probe-the-hardware" models for hardware<BR>configuration.&nbsp; Newer systems have largely abandoned that model, in favor of<BR>bus-level support for dynamic configuration (PCI, USB), or device tables<BR>provided by the boot firmware (e.g. PNPACPI on x86).&nbsp; There are too many<BR>conflicting options about what might be where, and even educated guesses by<BR>an operating system will be wrong often enough to make trouble.</FONT></P>
<P><FONT class=extract>This style of driver is discouraged.&nbsp; If you're updating such a driver,<BR>please try to move the device enumeration to a more appropriate location,<BR>outside the driver.&nbsp; This will usually be cleanup, since such drivers<BR>tend to already have "normal" modes, such as ones using device nodes that<BR>were created by PNP or by platform device setup.</FONT></P>
<P><FONT class=extract>None the less, there are some APIs to support such legacy drivers.&nbsp; Avoid<BR>using these calls except with such hotplug-deficient drivers.</FONT></P>
<P><FONT class=extract>&nbsp;struct platform_device *platform_device_alloc(<BR>&nbsp;&nbsp;&nbsp;const char *name, int id);</FONT></P>
<P><FONT class=extract>You can use platform_device_alloc() to dynamically allocate a device, which<BR>you will then initialize with resources and platform_device_register().<BR>A better solution is usually:</FONT></P>
<P><FONT class=extract>&nbsp;struct platform_device *platform_device_register_simple(<BR>&nbsp;&nbsp;&nbsp;const char *name, int id,<BR>&nbsp;&nbsp;&nbsp;struct resource *res, unsigned int nres);</FONT></P>
<P><FONT class=extract>You can use platform_device_register_simple() as a one-step call to allocate<BR>and register a device.</FONT></P>
<P><BR><FONT class=extract>Device Naming and Driver Binding<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>The platform_device.dev.bus_id is the canonical name for the devices.<BR>It's built from two components:</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; * platform_device.name ... which is also used to for driver matching.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; * platform_device.id ... the device instance number, or else "-1"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to indicate there's only one.</FONT></P>
<P><FONT class=extract>These are concatenated, so name/id "serial"/0 indicates bus_id "serial.0", and<BR>"serial/3" indicates bus_id "serial.3"; both would use the platform_driver<BR>named "serial".&nbsp; While "my_rtc"/-1 would be bus_id "my_rtc" (no instance id)<BR>and use the platform_driver called "my_rtc".</FONT></P>
<P><FONT class=extract>Driver binding is performed automatically by the driver core, invoking<BR>driver probe() after finding a match between device and driver.&nbsp; If the<BR>probe() succeeds, the driver and device are bound as usual.&nbsp; There are<BR>three different ways to find such a match:</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; - Whenever a device is registered, the drivers for that bus are<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; checked for matches.&nbsp; Platform devices should be registered very<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; early during system boot.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; - When a driver is registered using platform_driver_register(), all<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unbound devices on that bus are checked for matches.&nbsp; Drivers<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usually register later during booting, or by module loading.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; - Registering a driver using platform_driver_probe() works just like<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using platform_driver_register(), except that the driver won't<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be probed later if another device registers.&nbsp; (Which is OK, since<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this interface is only for use with non-hotpluggable devices.)</FONT></P>
<P><BR><FONT class=extract>Early Platform Devices and Drivers<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>The early platform interfaces provide platform data to platform device<BR>drivers early on during the system boot. The code is built on top of the<BR>early_param() command line parsing and can be executed very early on.</FONT></P>
<P><FONT class=extract>Example: "earlyprintk" class early serial console in 6 steps</FONT></P>
<P><FONT class=extract>1. Registering early platform device data<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>The architecture code registers platform device data using the function<BR>early_platform_add_devices(). In the case of early serial console this<BR>should be hardware configuration for the serial port. Devices registered<BR>at this point will later on be matched against early platform drivers.</FONT></P>
<P><FONT class=extract>2. Parsing kernel command line<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>The architecture code calls parse_early_param() to parse the kernel<BR>command line. This will execute all matching early_param() callbacks.<BR>User specified early platform devices will be registered at this point.<BR>For the early serial console case the user can specify port on the<BR>kernel command line as "earlyprintk=serial.0" where "earlyprintk" is<BR>the class string, "serial" is the name of the platform driver and<BR>0 is the platform device id. If the id is -1 then the dot and the<BR>id can be omitted.</FONT></P>
<P><FONT class=extract>3. Installing early platform drivers belonging to a certain class<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>The architecture code may optionally force registration of all early<BR>platform drivers belonging to a certain class using the function<BR>early_platform_driver_register_all(). User specified devices from<BR>step 2 have priority over these. This step is omitted by the serial<BR>driver example since the early serial driver code should be disabled<BR>unless the user has specified port on the kernel command line.</FONT></P>
<P><FONT class=extract>4. Early platform driver registration<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>Compiled-in platform drivers making use of early_platform_init() are<BR>automatically registered during step 2 or 3. The serial driver example<BR>should use early_platform_init("earlyprintk", &amp;platform_driver).</FONT></P>
<P><FONT class=extract>5. Probing of early platform drivers belonging to a certain class<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>The architecture code calls early_platform_driver_probe() to match<BR>registered early platform devices associated with a certain class with<BR>registered early platform drivers. Matched devices will get probed().<BR>This step can be executed at any point during the early boot. As soon<BR>as possible may be good for the serial port case.</FONT></P>
<P><FONT class=extract>6. Inside the early platform driver probe()<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>The driver code needs to take special care during early boot, especially<BR>when it comes to memory allocation and interrupt registration. The code<BR>in the probe() function can use is_early_platform_device() to check if<BR>it is called at early platform device or at the regular platform device<BR>time. The early serial driver performs register_console() at this point.</FONT></P>
<P><FONT class=extract>For further information, see &lt;linux/platform_device.h&gt;.</FONT>