# Documentation/input/input.txt 
<P></P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Linux Input drivers v1.0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (c) 1999-2001 Vojtech Pavlik &lt;<A href="mailto:vojtech@ucw.cz">vojtech@ucw.cz</A>&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sponsored by SuSE<BR>----------------------------------------------------------------------------</P>
<P></P>
<P>0. Disclaimer<BR>~~~~~~~~~~~~~<BR>&nbsp; This program is free software; you can redistribute it and/or modify it<BR>under the terms of the GNU General Public License as published by the Free<BR>Software Foundation; either version 2 of the License, or (at your option)<BR>any later version.</P>
<P>&nbsp; This program is distributed in the hope that it will be useful, but<BR>WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY<BR>or FITNESS FOR A PARTICULAR PURPOSE.&nbsp; See the GNU General Public License for<BR>more details.</P>
<P>&nbsp; You should have received a copy of the GNU General Public License along<BR>with this program; if not, write to the Free Software Foundation, Inc., 59<BR>Temple Place, Suite 330, Boston, MA 02111-1307 USA</P>
<P>&nbsp; Should you need to contact me, the author, you can do so either by e-mail<BR>- mail your message to &lt;<A href="mailto:vojtech@ucw.cz">vojtech@ucw.cz</A>&gt;, or by paper mail: Vojtech Pavlik,<BR>Simunkova 1594, Prague 8, 182 00 Czech Republic</P>
<P>&nbsp; For your convenience, the GNU General Public License version 2 is included<BR>in the package: See the file COPYING.</P>
<P>1. Introduction<BR>~~~~~~~~~~~~~~~<BR>&nbsp; This is a collection of drivers that is designed to support all input<BR>devices under Linux. While it is currently used only on for USB input<BR>devices, future use (say 2.5/2.6) is expected to expand to replace<BR>most of the existing input system, which is why it lives in<BR>drivers/input/ instead of drivers/usb/.</P>
<P>&nbsp; The centre of the input drivers is the input module, which must be<BR>loaded before any other of the input modules - it serves as a way of<BR>communication between two groups of modules:</P>
<P>1.1 Device drivers<BR>~~~~~~~~~~~~~~~~~~<BR>&nbsp; These modules talk to the hardware (for example via USB), and provide<BR>events (keystrokes, mouse movements) to the input module.</P>
<P>1.2 Event handlers<BR>~~~~~~~~~~~~~~~~~~<BR>&nbsp; These modules get events from input and pass them where needed via<BR>various interfaces - keystrokes to the kernel, mouse movements via a<BR>simulated PS/2 interface to GPM and X and so on.</P>
<P>2. Simple Usage<BR>~~~~~~~~~~~~~~~<BR>&nbsp; For the most usual configuration, with one USB mouse and one USB keyboard,<BR>you'll have to load the following modules (or have them built in to the<BR>kernel):</P>
<P>&nbsp;input<BR>&nbsp;mousedev<BR>&nbsp;keybdev<BR>&nbsp;usbcore<BR>&nbsp;uhci_hcd or ohci_hcd or ehci_hcd<BR>&nbsp;usbhid</P>
<P>&nbsp; After this, the USB keyboard will work straight away, and the USB mouse<BR>will be available as a character device on major 13, minor 63:</P>
<P>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp; 63 Mar 28 22:45 mice</P>
<P>&nbsp; This device has to be created.<BR>&nbsp; The commands to create it by hand are:</P>
<P>&nbsp;cd /dev<BR>&nbsp;mkdir input<BR>&nbsp;mknod input/mice c 13 63</P>
<P>&nbsp; After that you have to point GPM (the textmode mouse cut&amp;paste tool) and<BR>XFree to this device to use it - GPM should be called like:</P>
<P>&nbsp;gpm -t ps2 -m /dev/input/mice</P>
<P>&nbsp; And in X:</P>
<P>&nbsp;Section "Pointer"<BR>&nbsp;&nbsp;&nbsp;&nbsp; Protocol&nbsp;&nbsp;&nbsp; "ImPS/2"<BR>&nbsp;&nbsp;&nbsp;&nbsp; Device&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "/dev/input/mice"<BR>&nbsp;&nbsp;&nbsp;&nbsp; ZAxisMapping 4 5<BR>&nbsp;EndSection</P>
<P>&nbsp; When you do all of the above, you can use your USB mouse and keyboard.</P>
<P>3. Detailed Description<BR>~~~~~~~~~~~~~~~~~~~~~~~<BR>3.1 Device drivers<BR>~~~~~~~~~~~~~~~~~~<BR>&nbsp; Device drivers are the modules that generate events. The events are<BR>however not useful without being handled, so you also will need to use some<BR>of the modules from section 3.2.</P>
<P>3.1.1 usbhid<BR>~~~~~~~~~~~~<BR>&nbsp; usbhid is the largest and most complex driver of the whole suite. It<BR>handles all HID devices, and because there is a very wide variety of them,<BR>and because the USB HID specification isn't simple, it needs to be this big.</P>
<P>&nbsp; Currently, it handles USB mice, joysticks, gamepads, steering wheels<BR>keyboards, trackballs and digitizers.</P>
<P>&nbsp;However, USB uses HID also for monitor controls, speaker controls, UPSs,<BR>LCDs and many other purposes.</P>
<P>&nbsp;The monitor and speaker controls should be easy to add to the hid/input<BR>interface, but for the UPSs and LCDs it doesn't make much sense. For this,<BR>the hiddev interface was designed. See Documentation/hid/hiddev.txt<BR>for more information about it.</P>
<P>&nbsp; The usage of the usbhid module is very simple, it takes no parameters,<BR>detects everything automatically and when a HID device is inserted, it<BR>detects it appropriately.</P>
<P>&nbsp; However, because the devices vary wildly, you might happen to have a<BR>device that doesn't work well. In that case #define DEBUG at the beginning<BR>of hid-core.c and send me the syslog traces.</P>
<P>3.1.2 usbmouse<BR>~~~~~~~~~~~~~~<BR>&nbsp; For embedded systems, for mice with broken HID descriptors and just any<BR>other use when the big usbhid wouldn't be a good choice, there is the<BR>usbmouse driver. It handles USB mice only. It uses a simpler HIDBP<BR>protocol. This also means the mice must support this simpler protocol. Not<BR>all do. If you don't have any strong reason to use this module, use usbhid<BR>instead.</P>
<P>3.1.3 usbkbd<BR>~~~~~~~~~~~~<BR>&nbsp; Much like usbmouse, this module talks to keyboards with a simplified<BR>HIDBP protocol. It's smaller, but doesn't support any extra special keys.<BR>Use usbhid instead if there isn't any special reason to use this.</P>
<P>3.1.4 wacom<BR>~~~~~~~~~~~<BR>&nbsp; This is a driver for Wacom Graphire and Intuos tablets. Not for Wacom<BR>PenPartner, that one is handled by the HID driver. Although the Intuos and<BR>Graphire tablets claim that they are HID tablets as well, they are not and<BR>thus need this specific driver.</P>
<P>3.1.5 iforce<BR>~~~~~~~~~~~~<BR>&nbsp; A driver for I-Force joysticks and wheels, both over USB and RS232. <BR>It includes ForceFeedback support now, even though Immersion<BR>Corp. considers the protocol a trade secret and won't disclose a word<BR>about it. </P>
<P>3.2 Event handlers<BR>~~~~~~~~~~~~~~~~~~<BR>&nbsp; Event handlers distribute the events from the devices to userland and<BR>kernel, as needed.</P>
<P>3.2.1 keybdev<BR>~~~~~~~~~~~~~<BR>&nbsp; keybdev is currently a rather ugly hack that translates the input<BR>events into architecture-specific keyboard raw mode (Xlated AT Set2 on<BR>x86), and passes them into the handle_scancode function of the<BR>keyboard.c module. This works well enough on all architectures that<BR>keybdev can generate rawmode on, other architectures can be added to<BR>it.</P>
<P>&nbsp; The right way would be to pass the events to keyboard.c directly,<BR>best if keyboard.c would itself be an event handler. This is done in<BR>the input patch, available on the webpage mentioned below. </P>
<P>3.2.2 mousedev<BR>~~~~~~~~~~~~~~<BR>&nbsp; mousedev is also a hack to make programs that use mouse input<BR>work. It takes events from either mice or digitizers/tablets and makes<BR>a PS/2-style (a la /dev/psaux) mouse device available to the<BR>userland. Ideally, the programs could use a more reasonable interface,<BR>for example evdev</P>
<P>&nbsp; Mousedev devices in /dev/input (as shown above) are:</P>
<P>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp; 32 Mar 28 22:45 mouse0<BR>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp; 33 Mar 29 00:41 mouse1<BR>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp; 34 Mar 29 00:41 mouse2<BR>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp; 35 Apr&nbsp; 1 10:50 mouse3<BR>&nbsp;...<BR>&nbsp;...<BR>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp; 62 Apr&nbsp; 1 10:50 mouse30<BR>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp; 63 Apr&nbsp; 1 10:50 mice</P>
<P>Each 'mouse' device is assigned to a single mouse or digitizer, except<BR>the last one - 'mice'. This single character device is shared by all<BR>mice and digitizers, and even if none are connected, the device is<BR>present.&nbsp; This is useful for hotplugging USB mice, so that programs<BR>can open the device even when no mice are present.</P>
<P>&nbsp; CONFIG_INPUT_MOUSEDEV_SCREEN_[XY] in the kernel configuration are<BR>the size of your screen (in pixels) in XFree86. This is needed if you<BR>want to use your digitizer in X, because its movement is sent to X<BR>via a virtual PS/2 mouse and thus needs to be scaled<BR>accordingly. These values won't be used if you use a mouse only.</P>
<P>&nbsp; Mousedev will generate either PS/2, ImPS/2 (Microsoft IntelliMouse) or<BR>ExplorerPS/2 (IntelliMouse Explorer) protocols, depending on what the<BR>program reading the data wishes. You can set GPM and X to any of<BR>these. You'll need ImPS/2 if you want to make use of a wheel on a USB<BR>mouse and ExplorerPS/2 if you want to use extra (up to 5) buttons. </P>
<P>3.2.3 joydev<BR>~~~~~~~~~~~~<BR>&nbsp; Joydev implements v0.x and v1.x Linux joystick api, much like<BR>drivers/char/joystick/joystick.c used to in earlier versions. See<BR>joystick-api.txt in the Documentation subdirectory for details.&nbsp; As<BR>soon as any joystick is connected, it can be accessed in /dev/input<BR>on: </P>
<P>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp;&nbsp; 0 Apr&nbsp; 1 10:50 js0<BR>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp;&nbsp; 1 Apr&nbsp; 1 10:50 js1<BR>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp;&nbsp; 2 Apr&nbsp; 1 10:50 js2<BR>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp;&nbsp; 3 Apr&nbsp; 1 10:50 js3<BR>&nbsp;...</P>
<P>And so on up to js31.</P>
<P>3.2.4 evdev<BR>~~~~~~~~~~~<BR>&nbsp; evdev is the generic input event interface. It passes the events<BR>generated in the kernel straight to the program, with timestamps. The<BR>API is still evolving, but should be useable now. It's described in<BR>section 5. </P>
<P>&nbsp; This should be the way for GPM and X to get keyboard and mouse<BR>events. It allows for multihead in X without any specific multihead<BR>kernel support. The event codes are the same on all architectures and<BR>are hardware independent.</P>
<P>&nbsp; The devices are in /dev/input:</P>
<P>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp; 64 Apr&nbsp; 1 10:49 event0<BR>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp; 65 Apr&nbsp; 1 10:50 event1<BR>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp; 66 Apr&nbsp; 1 10:50 event2<BR>&nbsp;crw-r--r--&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13,&nbsp; 67 Apr&nbsp; 1 10:50 event3<BR>&nbsp;...</P>
<P>And so on up to event31.</P>
<P>4. Verifying if it works<BR>~~~~~~~~~~~~~~~~~~~~~~~~<BR>&nbsp; Typing a couple keys on the keyboard should be enough to check that<BR>a USB keyboard works and is correctly connected to the kernel keyboard<BR>driver. </P>
<P>&nbsp; Doing a "cat /dev/input/mouse0" (c, 13, 32) will verify that a mouse<BR>is also emulated; characters should appear if you move it.</P>
<P>&nbsp; You can test the joystick emulation with the 'jstest' utility,<BR>available in the joystick package (see Documentation/input/joystick.txt).</P>
<P>&nbsp; You can test the event devices with the 'evtest' utility available<BR>in the LinuxConsole project CVS archive (see the URL below).</P>
<P>5. Event interface<BR>~~~~~~~~~~~~~~~~~~<BR>&nbsp; Should you want to add event device support into any application (X, gpm,<BR>svgalib ...) I &lt;<A href="mailto:vojtech@ucw.cz">vojtech@ucw.cz</A>&gt; will be happy to provide you any help I<BR>can. Here goes a description of the current state of things, which is going<BR>to be extended, but not changed incompatibly as time goes:</P>
<P>&nbsp; You can use blocking and nonblocking reads, also select() on the<BR>/dev/input/eventX devices, and you'll always get a whole number of input<BR>events on a read. Their layout is:</P>
<P>struct input_event {<BR>&nbsp;struct timeval time;<BR>&nbsp;unsigned short type;<BR>&nbsp;unsigned short code;<BR>&nbsp;unsigned int value;<BR>};</P>
<P>&nbsp; 'time' is the timestamp, it returns the time at which the event happened.<BR>Type is for example EV_REL for relative moment, EV_KEY for a keypress or<BR>release. More types are defined in include/linux/input.h.</P>
<P>&nbsp; 'code' is event code, for example REL_X or KEY_BACKSPACE, again a complete<BR>list is in include/linux/input.h.</P>
<P>&nbsp; 'value' is the value the event carries. Either a relative change for<BR>EV_REL, absolute new value for EV_ABS (joysticks ...), or 0 for EV_KEY for<BR>release, 1 for keypress and 2 for autorepeat.</P>
<P>&nbsp;