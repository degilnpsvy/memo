# Documentation/early-userspace/README 
<P></P>
<P>Early userspace support<BR>=======================</P>
<P></P>
<P>Last update: 2004-12-20 tlh</P>
<P><BR>"Early userspace" is a set of libraries and programs that provide<BR>various pieces of functionality that are important enough to be<BR>available while a Linux kernel is coming up, but that don't need to be<BR>run inside the kernel itself.</P>
<P>It consists of several major infrastructure components:</P>
<P>- gen_init_cpio, a program that builds a cpio-format archive<BR>&nbsp; containing a root filesystem image.&nbsp; This archive is compressed, and<BR>&nbsp; the compressed image is linked into the kernel image.<BR>- initramfs, a chunk of code that unpacks the compressed cpio image<BR>&nbsp; midway through the kernel boot process.<BR>- klibc, a userspace C library, currently packaged separately, that is<BR>&nbsp; optimized for correctness and small size.</P>
<P>The cpio file format used by initramfs is the "newc" (aka "cpio -H newc")<BR>format, and is documented in the file "buffer-format.txt".&nbsp; There are<BR>two ways to add an early userspace image: specify an existing cpio<BR>archive to be used as the image or have the kernel build process build<BR>the image from specifications.</P>
<P>CPIO ARCHIVE method</P>
<P>You can create a cpio archive that contains the early userspace image.<BR>Your cpio archive should be specified in CONFIG_INITRAMFS_SOURCE and it<BR>will be used directly.&nbsp; Only a single cpio file may be specified in<BR>CONFIG_INITRAMFS_SOURCE and directory and file names are not allowed in<BR>combination with a cpio archive.</P>
<P>IMAGE BUILDING method</P>
<P>The kernel build process can also build an early userspace image from<BR>source parts rather than supplying a cpio archive.&nbsp; This method provides<BR>a way to create images with root-owned files even though the image was<BR>built by an unprivileged user.</P>
<P>The image is specified as one or more sources in<BR>CONFIG_INITRAMFS_SOURCE.&nbsp; Sources can be either directories or files -<BR>cpio archives are *not* allowed when building from sources.</P>
<P>A source directory will have it and all of its contents packaged.&nbsp; The<BR>specified directory name will be mapped to '/'.&nbsp; When packaging a<BR>directory, limited user and group ID translation can be performed.<BR>INITRAMFS_ROOT_UID can be set to a user ID that needs to be mapped to<BR>user root (0).&nbsp; INITRAMFS_ROOT_GID can be set to a group ID that needs<BR>to be mapped to group root (0).</P>
<P>A source file must be directives in the format required by the<BR>usr/gen_init_cpio utility (run 'usr/gen_init_cpio --help' to get the<BR>file format).&nbsp; The directives in the file will be passed directly to<BR>usr/gen_init_cpio.</P>
<P>When a combination of directories and files are specified then the<BR>initramfs image will be an aggregate of all of them.&nbsp; In this way a user<BR>can create a 'root-image' directory and install all files into it.<BR>Because device-special files cannot be created by a unprivileged user,<BR>special files can be listed in a 'root-files' file.&nbsp; Both 'root-image'<BR>and 'root-files' can be listed in CONFIG_INITRAMFS_SOURCE and a complete<BR>early userspace image can be built by an unprivileged user.</P>
<P>As a technical note, when directories and files are specified, the<BR>entire CONFIG_INITRAMFS_SOURCE is passed to<BR>scripts/gen_initramfs_list.sh.&nbsp; This means that CONFIG_INITRAMFS_SOURCE<BR>can really be interpreted as any legal argument to<BR>gen_initramfs_list.sh.&nbsp; If a directory is specified as an argument then<BR>the contents are scanned, uid/gid translation is performed, and<BR>usr/gen_init_cpio file directives are output.&nbsp; If a directory is<BR>specified as an argument to scripts/gen_initramfs_list.sh then the<BR>contents of the file are simply copied to the output.&nbsp; All of the output<BR>directives from directory scanning and file contents copying are<BR>processed by usr/gen_init_cpio.</P>
<P>See also 'scripts/gen_initramfs_list.sh -h'.</P>
<P>Where's this all leading?<BR>=========================</P>
<P>The klibc distribution contains some of the necessary software to make<BR>early userspace useful.&nbsp; The klibc distribution is currently<BR>maintained separately from the kernel.</P>
<P>You can obtain somewhat infrequent snapshots of klibc from<BR><A href="ftp://ftp.kernel.org/pub/linux/libs/klibc/">ftp://ftp.kernel.org/pub/linux/libs/klibc/</A></P>
<P>For active users, you are better off using the klibc git<BR>repository, at <A href="http://git.kernel.org/?p=libs/klibc/klibc.git">http://git.kernel.org/?p=libs/klibc/klibc.git</A></P>
<P>The standalone klibc distribution currently provides three components,<BR>in addition to the klibc library:</P>
<P>- ipconfig, a program that configures network interfaces.&nbsp; It can<BR>&nbsp; configure them statically, or use DHCP to obtain information<BR>&nbsp; dynamically (aka "IP autoconfiguration").<BR>- nfsmount, a program that can mount an NFS filesystem.<BR>- kinit, the "glue" that uses ipconfig and nfsmount to replace the old<BR>&nbsp; support for IP autoconfig, mount a filesystem over NFS, and continue<BR>&nbsp; system boot using that filesystem as root.</P>
<P>kinit is built as a single statically linked binary to save space.</P>
<P>Eventually, several more chunks of kernel functionality will hopefully<BR>move to early userspace:</P>
<P>- Almost all of init/do_mounts* (the beginning of this is already in<BR>&nbsp; place)<BR>- ACPI table parsing<BR>- Insert unwieldy subsystem that doesn't really need to be in kernel<BR>&nbsp; space here</P>
<P>If kinit doesn't meet your current needs and you've got bytes to burn,<BR>the klibc distribution includes a small Bourne-compatible shell (ash)<BR>and a number of other utilities, so you can replace kinit and build<BR>custom initramfs images that meet your needs exactly.</P>
<P>For questions and help, you can sign up for the early userspace<BR>mailing list at <A href="http://www.zytor.com/mailman/listinfo/klibc">http://www.zytor.com/mailman/listinfo/klibc</A></P>
<P>How does it work?<BR>=================</P>
<P>The kernel has currently 3 ways to mount the root filesystem:</P>
<P>a) all required device and filesystem drivers compiled into the kernel, no<BR>&nbsp;&nbsp; initrd.&nbsp; init/main.c:init() will call prepare_namespace() to mount the<BR>&nbsp;&nbsp; final root filesystem, based on the root= option and optional init= to run<BR>&nbsp;&nbsp; some other init binary than listed at the end of init/main.c:init().</P>
<P>b) some device and filesystem drivers built as modules and stored in an<BR>&nbsp;&nbsp; initrd.&nbsp; The initrd must contain a binary '/linuxrc' which is supposed to<BR>&nbsp;&nbsp; load these driver modules.&nbsp; It is also possible to mount the final root<BR>&nbsp;&nbsp; filesystem via linuxrc and use the pivot_root syscall.&nbsp; The initrd is<BR>&nbsp;&nbsp; mounted and executed via prepare_namespace().</P>
<P>c) using initramfs.&nbsp; The call to prepare_namespace() must be skipped.<BR>&nbsp;&nbsp; This means that a binary must do all the work.&nbsp; Said binary can be stored<BR>&nbsp;&nbsp; into initramfs either via modifying usr/gen_init_cpio.c or via the new<BR>&nbsp;&nbsp; initrd format, an cpio archive.&nbsp; It must be called "/init".&nbsp; This binary<BR>&nbsp;&nbsp; is responsible to do all the things prepare_namespace() would do.</P>
<P>&nbsp;&nbsp; To maintain backwards compatibility, the /init binary will only run if it<BR>&nbsp;&nbsp; comes via an initramfs cpio archive.&nbsp; If this is not the case,<BR>&nbsp;&nbsp; init/main.c:init() will run prepare_namespace() to mount the final root<BR>&nbsp;&nbsp; and exec one of the predefined init binaries.</P>
<P>Bryan O'Sullivan &lt;<A href="mailto:bos@serpentine.com">bos@serpentine.com</A>&gt;