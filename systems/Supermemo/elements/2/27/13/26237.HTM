# include/uapi/linux/input.h 
<P></P>
<P>/*<BR>&nbsp;* Copyright (c) 1999-2002 Vojtech Pavlik<BR>&nbsp;*<BR>&nbsp;* This program is free software; you can redistribute it and/or modify it<BR>&nbsp;* under the terms of the GNU General Public License version 2 as published by<BR>&nbsp;* the Free Software Foundation.<BR>&nbsp;*/<BR>#ifndef _UAPI_INPUT_H<BR>#define _UAPI_INPUT_H</P>
<P></P>
<P><BR>#ifndef __KERNEL__<BR>#include &lt;sys/time.h&gt;<BR>#include &lt;sys/ioctl.h&gt;<BR>#include &lt;sys/types.h&gt;<BR>#include &lt;linux/types.h&gt;<BR>#endif</P>
<P>#include "input-event-codes.h"</P>
<P><FONT class=extract>/*<BR>&nbsp;* The event structure itself<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>struct input_event {<BR>&nbsp;struct timeval time;<BR>&nbsp;__u16 type;<BR>&nbsp;__u16 code;<BR>&nbsp;__s32 value;<BR>};</FONT></P>
<P>/*<BR>&nbsp;* Protocol version.<BR>&nbsp;*/</P>
<P>#define EV_VERSION&nbsp;&nbsp;0x010001</P>
<P>/*<BR>&nbsp;* IOCTLs (0x00 - 0x7f)<BR>&nbsp;*/</P>
<P><FONT class=extract>struct input_id {<BR>&nbsp;__u16 bustype;<BR>&nbsp;__u16 vendor;<BR>&nbsp;__u16 product;<BR>&nbsp;__u16 version;<BR>};</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* struct input_absinfo - used by EVIOCGABS/EVIOCSABS ioctls<BR>&nbsp;* @value: latest reported value for the axis.<BR>&nbsp;* @minimum: specifies minimum value for the axis.<BR>&nbsp;* @maximum: specifies maximum value for the axis.<BR>&nbsp;* @fuzz: specifies fuzz value that is used to filter noise from<BR>&nbsp;*&nbsp;the event stream.<BR>&nbsp;* @flat: values that are within this value will be discarded by<BR>&nbsp;*&nbsp;joydev interface and reported as 0 instead.<BR>&nbsp;* @resolution: specifies resolution for the values reported for<BR>&nbsp;*&nbsp;the axis.<BR>&nbsp;*<BR>&nbsp;* Note that input core does not clamp reported values to the<BR>&nbsp;* [minimum, maximum] limits, such task is left to userspace.<BR>&nbsp;*<BR>&nbsp;* Resolution for main axes (ABS_X, ABS_Y, ABS_Z) is reported in<BR>&nbsp;* units per millimeter (units/mm), resolution for rotational axes<BR>&nbsp;* (ABS_RX, ABS_RY, ABS_RZ) is reported in units per radian.<BR>&nbsp;*/<BR>struct input_absinfo {<BR>&nbsp;__s32 value;<BR>&nbsp;__s32 minimum;<BR>&nbsp;__s32 maximum;<BR>&nbsp;__s32 fuzz;<BR>&nbsp;__s32 flat;<BR>&nbsp;__s32 resolution;<BR>};</FONT></P>
<P>/**<BR>&nbsp;* struct input_keymap_entry - used by EVIOCGKEYCODE/EVIOCSKEYCODE ioctls<BR>&nbsp;* @scancode: scancode represented in machine-endian form.<BR>&nbsp;* @len: length of the scancode that resides in @scancode buffer.<BR>&nbsp;* @index: index in the keymap, may be used instead of scancode<BR>&nbsp;* @flags: allows to specify how kernel should handle the request. For<BR>&nbsp;*&nbsp;example, setting INPUT_KEYMAP_BY_INDEX flag indicates that kernel<BR>&nbsp;*&nbsp;should perform lookup in keymap by @index instead of @scancode<BR>&nbsp;* @keycode: key code assigned to this scancode<BR>&nbsp;*<BR>&nbsp;* The structure is used to retrieve and modify keymap data. Users have<BR>&nbsp;* option of performing lookup either by @scancode itself or by @index<BR>&nbsp;* in keymap entry. EVIOCGKEYCODE will also return scancode or index<BR>&nbsp;* (depending on which element was used to perform lookup).<BR>&nbsp;*/<BR>struct input_keymap_entry {<BR>#define INPUT_KEYMAP_BY_INDEX&nbsp;(1 &lt;&lt; 0)<BR>&nbsp;__u8&nbsp; flags;<BR>&nbsp;__u8&nbsp; len;<BR>&nbsp;__u16 index;<BR>&nbsp;__u32 keycode;<BR>&nbsp;__u8&nbsp; scancode[32];<BR>};</P>
<P>struct input_mask {<BR>&nbsp;__u32 type;<BR>&nbsp;__u32 codes_size;<BR>&nbsp;__u64 codes_ptr;<BR>};</P>
<P>#define EVIOCGVERSION&nbsp;&nbsp;_IOR('E', 0x01, int)&nbsp;&nbsp;&nbsp;/* get driver version */<BR>#define EVIOCGID&nbsp;&nbsp;_IOR('E', 0x02, struct input_id)&nbsp;/* get device ID */<BR>#define EVIOCGREP&nbsp;&nbsp;_IOR('E', 0x03, unsigned int[2])&nbsp;/* get repeat settings */<BR>#define EVIOCSREP&nbsp;&nbsp;_IOW('E', 0x03, unsigned int[2])&nbsp;/* set repeat settings */</P>
<P>#define EVIOCGKEYCODE&nbsp;&nbsp;_IOR('E', 0x04, unsigned int[2])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* get keycode */<BR>#define EVIOCGKEYCODE_V2&nbsp;_IOR('E', 0x04, struct input_keymap_entry)<BR>#define EVIOCSKEYCODE&nbsp;&nbsp;_IOW('E', 0x04, unsigned int[2])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* set keycode */<BR>#define EVIOCSKEYCODE_V2&nbsp;_IOW('E', 0x04, struct input_keymap_entry)</P>
<P>#define EVIOCGNAME(len)&nbsp;&nbsp;_IOC(_IOC_READ, 'E', 0x06, len)&nbsp;&nbsp;/* get device name */<BR>#define EVIOCGPHYS(len)&nbsp;&nbsp;_IOC(_IOC_READ, 'E', 0x07, len)&nbsp;&nbsp;/* get physical location */<BR>#define EVIOCGUNIQ(len)&nbsp;&nbsp;_IOC(_IOC_READ, 'E', 0x08, len)&nbsp;&nbsp;/* get unique identifier */<BR>#define EVIOCGPROP(len)&nbsp;&nbsp;_IOC(_IOC_READ, 'E', 0x09, len)&nbsp;&nbsp;/* get device properties */</P>
<P>/**<BR>&nbsp;* EVIOCGMTSLOTS(len) - get MT slot values<BR>&nbsp;* @len: size of the data buffer in bytes<BR>&nbsp;*<BR>&nbsp;* The ioctl buffer argument should be binary equivalent to<BR>&nbsp;*<BR>&nbsp;* struct input_mt_request_layout {<BR>&nbsp;*&nbsp;__u32 code;<BR>&nbsp;*&nbsp;__s32 values[num_slots];<BR>&nbsp;* };<BR>&nbsp;*<BR>&nbsp;* where num_slots is the (arbitrary) number of MT slots to extract.<BR>&nbsp;*<BR>&nbsp;* The ioctl size argument (len) is the size of the buffer, which<BR>&nbsp;* should satisfy len = (num_slots + 1) * sizeof(__s32).&nbsp; If len is<BR>&nbsp;* too small to fit all available slots, the first num_slots are<BR>&nbsp;* returned.<BR>&nbsp;*<BR>&nbsp;* Before the call, code is set to the wanted ABS_MT event type. On<BR>&nbsp;* return, values[] is filled with the slot values for the specified<BR>&nbsp;* ABS_MT code.<BR>&nbsp;*<BR>&nbsp;* If the request code is not an ABS_MT value, -EINVAL is returned.<BR>&nbsp;*/<BR>#define EVIOCGMTSLOTS(len)&nbsp;_IOC(_IOC_READ, 'E', 0x0a, len)</P>
<P>#define EVIOCGKEY(len)&nbsp;&nbsp;_IOC(_IOC_READ, 'E', 0x18, len)&nbsp;&nbsp;/* get global key state */<BR>#define EVIOCGLED(len)&nbsp;&nbsp;_IOC(_IOC_READ, 'E', 0x19, len)&nbsp;&nbsp;/* get all LEDs */<BR>#define EVIOCGSND(len)&nbsp;&nbsp;_IOC(_IOC_READ, 'E', 0x1a, len)&nbsp;&nbsp;/* get all sounds status */<BR>#define EVIOCGSW(len)&nbsp;&nbsp;_IOC(_IOC_READ, 'E', 0x1b, len)&nbsp;&nbsp;/* get all switch states */</P>
<P>#define EVIOCGBIT(ev,len)&nbsp;_IOC(_IOC_READ, 'E', 0x20 + (ev), len)&nbsp;/* get event bits */<BR>#define EVIOCGABS(abs)&nbsp;&nbsp;_IOR('E', 0x40 + (abs), struct input_absinfo)&nbsp;/* get abs value/limits */<BR>#define EVIOCSABS(abs)&nbsp;&nbsp;_IOW('E', 0xc0 + (abs), struct input_absinfo)&nbsp;/* set abs value/limits */</P>
<P>#define EVIOCSFF&nbsp;&nbsp;_IOW('E', 0x80, struct ff_effect)&nbsp;/* send a force effect to a force feedback device */<BR>#define EVIOCRMFF&nbsp;&nbsp;_IOW('E', 0x81, int)&nbsp;&nbsp;&nbsp;/* Erase a force effect */<BR>#define EVIOCGEFFECTS&nbsp;&nbsp;_IOR('E', 0x84, int)&nbsp;&nbsp;&nbsp;/* Report number of effects playable at the same time */</P>
<P>#define EVIOCGRAB&nbsp;&nbsp;_IOW('E', 0x90, int)&nbsp;&nbsp;&nbsp;/* Grab/Release device */<BR>#define EVIOCREVOKE&nbsp;&nbsp;_IOW('E', 0x91, int)&nbsp;&nbsp;&nbsp;/* Revoke device access */</P>
<P>/**<BR>&nbsp;* EVIOCGMASK - Retrieve current event mask<BR>&nbsp;*<BR>&nbsp;* This ioctl allows user to retrieve the current event mask for specific<BR>&nbsp;* event type. The argument must be of type "struct input_mask" and<BR>&nbsp;* specifies the event type to query, the address of the receive buffer and<BR>&nbsp;* the size of the receive buffer.<BR>&nbsp;*<BR>&nbsp;* The event mask is a per-client mask that specifies which events are<BR>&nbsp;* forwarded to the client. Each event code is represented by a single bit<BR>&nbsp;* in the event mask. If the bit is set, the event is passed to the client<BR>&nbsp;* normally. Otherwise, the event is filtered and will never be queued on<BR>&nbsp;* the client's receive buffer.<BR>&nbsp;*<BR>&nbsp;* Event masks do not affect global state of the input device. They only<BR>&nbsp;* affect the file descriptor they are applied to.<BR>&nbsp;*<BR>&nbsp;* The default event mask for a client has all bits set, i.e. all events<BR>&nbsp;* are forwarded to the client. If the kernel is queried for an unknown<BR>&nbsp;* event type or if the receive buffer is larger than the number of<BR>&nbsp;* event codes known to the kernel, the kernel returns all zeroes for those<BR>&nbsp;* codes.<BR>&nbsp;*<BR>&nbsp;* At maximum, codes_size bytes are copied.<BR>&nbsp;*<BR>&nbsp;* This ioctl may fail with ENODEV in case the file is revoked, EFAULT<BR>&nbsp;* if the receive-buffer points to invalid memory, or EINVAL if the kernel<BR>&nbsp;* does not implement the ioctl.<BR>&nbsp;*/<BR>#define EVIOCGMASK&nbsp;&nbsp;_IOR('E', 0x92, struct input_mask)&nbsp;/* Get event-masks */</P>
<P>/**<BR>&nbsp;* EVIOCSMASK - Set event mask<BR>&nbsp;*<BR>&nbsp;* This ioctl is the counterpart to EVIOCGMASK. Instead of receiving the<BR>&nbsp;* current event mask, this changes the client's event mask for a specific<BR>&nbsp;* type.&nbsp; See EVIOCGMASK for a description of event-masks and the<BR>&nbsp;* argument-type.<BR>&nbsp;*<BR>&nbsp;* This ioctl provides full forward compatibility. If the passed event type<BR>&nbsp;* is unknown to the kernel, or if the number of event codes specified in<BR>&nbsp;* the mask is bigger than what is known to the kernel, the ioctl is still<BR>&nbsp;* accepted and applied. However, any unknown codes are left untouched and<BR>&nbsp;* stay cleared. That means, the kernel always filters unknown codes<BR>&nbsp;* regardless of what the client requests.&nbsp; If the new mask doesn't cover<BR>&nbsp;* all known event-codes, all remaining codes are automatically cleared and<BR>&nbsp;* thus filtered.<BR>&nbsp;*<BR>&nbsp;* This ioctl may fail with ENODEV in case the file is revoked. EFAULT is<BR>&nbsp;* returned if the receive-buffer points to invalid memory. EINVAL is returned<BR>&nbsp;* if the kernel does not implement the ioctl.<BR>&nbsp;*/<BR>#define EVIOCSMASK&nbsp;&nbsp;_IOW('E', 0x93, struct input_mask)&nbsp;/* Set event-masks */</P>
<P>#define EVIOCSCLOCKID&nbsp;&nbsp;_IOW('E', 0xa0, int)&nbsp;&nbsp;&nbsp;/* Set clockid to be used for timestamps */</P>
<P>/*<BR>&nbsp;* IDs.<BR>&nbsp;*/</P>
<P>#define ID_BUS&nbsp;&nbsp;&nbsp;0<BR>#define ID_VENDOR&nbsp;&nbsp;1<BR>#define ID_PRODUCT&nbsp;&nbsp;2<BR>#define ID_VERSION&nbsp;&nbsp;3</P>
<P>#define BUS_PCI&nbsp;&nbsp;&nbsp;0x01<BR>#define BUS_ISAPNP&nbsp;&nbsp;0x02<BR>#define BUS_USB&nbsp;&nbsp;&nbsp;0x03<BR>#define BUS_HIL&nbsp;&nbsp;&nbsp;0x04<BR>#define BUS_BLUETOOTH&nbsp;&nbsp;0x05<BR>#define BUS_VIRTUAL&nbsp;&nbsp;0x06</P>
<P>#define BUS_ISA&nbsp;&nbsp;&nbsp;0x10<BR>#define BUS_I8042&nbsp;&nbsp;0x11<BR>#define BUS_XTKBD&nbsp;&nbsp;0x12<BR>#define BUS_RS232&nbsp;&nbsp;0x13<BR>#define BUS_GAMEPORT&nbsp;&nbsp;0x14<BR>#define BUS_PARPORT&nbsp;&nbsp;0x15<BR>#define BUS_AMIGA&nbsp;&nbsp;0x16<BR>#define BUS_ADB&nbsp;&nbsp;&nbsp;0x17<BR>#define BUS_I2C&nbsp;&nbsp;&nbsp;0x18<BR>#define BUS_HOST&nbsp;&nbsp;0x19<BR>#define BUS_GSC&nbsp;&nbsp;&nbsp;0x1A<BR>#define BUS_ATARI&nbsp;&nbsp;0x1B<BR>#define BUS_SPI&nbsp;&nbsp;&nbsp;0x1C</P>
<P>/*<BR>&nbsp;* MT_TOOL types<BR>&nbsp;*/<BR>#define MT_TOOL_FINGER&nbsp;&nbsp;0<BR>#define MT_TOOL_PEN&nbsp;&nbsp;1<BR>#define MT_TOOL_PALM&nbsp;&nbsp;2<BR>#define MT_TOOL_MAX&nbsp;&nbsp;2</P>
<P>/*<BR>&nbsp;* Values describing the status of a force-feedback effect<BR>&nbsp;*/<BR>#define FF_STATUS_STOPPED&nbsp;0x00<BR>#define FF_STATUS_PLAYING&nbsp;0x01<BR>#define FF_STATUS_MAX&nbsp;&nbsp;0x01</P>
<P>/*<BR>&nbsp;* Structures used in ioctls to upload effects to a device<BR>&nbsp;* They are pieces of a bigger structure (called ff_effect)<BR>&nbsp;*/</P>
<P><FONT class=extract>/*<BR>&nbsp;* All duration values are expressed in ms. Values above 32767 ms (0x7fff)<BR>&nbsp;* should not be used and have unspecified results.<BR>&nbsp;*/</FONT></P>
<P>/**<BR>&nbsp;* struct ff_replay - defines scheduling of the force-feedback effect<BR>&nbsp;* @length: duration of the effect<BR>&nbsp;* @delay: delay before effect should start playing<BR>&nbsp;*/<BR>struct ff_replay {<BR>&nbsp;__u16 length;<BR>&nbsp;__u16 delay;<BR>};</P>
<P>/**<BR>&nbsp;* struct ff_trigger - defines what triggers the force-feedback effect<BR>&nbsp;* @button: number of the button triggering the effect<BR>&nbsp;* @interval: controls how soon the effect can be re-triggered<BR>&nbsp;*/<BR>struct ff_trigger {<BR>&nbsp;__u16 button;<BR>&nbsp;__u16 interval;<BR>};</P>
<P>/**<BR>&nbsp;* struct ff_envelope - generic force-feedback effect envelope<BR>&nbsp;* @attack_length: duration of the attack (ms)<BR>&nbsp;* @attack_level: level at the beginning of the attack<BR>&nbsp;* @fade_length: duration of fade (ms)<BR>&nbsp;* @fade_level: level at the end of fade<BR>&nbsp;*<BR>&nbsp;* The @attack_level and @fade_level are absolute values; when applying<BR>&nbsp;* envelope force-feedback core will convert to positive/negative<BR>&nbsp;* value based on polarity of the default level of the effect.<BR>&nbsp;* Valid range for the attack and fade levels is 0x0000 - 0x7fff<BR>&nbsp;*/<BR>struct ff_envelope {<BR>&nbsp;__u16 attack_length;<BR>&nbsp;__u16 attack_level;<BR>&nbsp;__u16 fade_length;<BR>&nbsp;__u16 fade_level;<BR>};</P>
<P>/**<BR>&nbsp;* struct ff_constant_effect - defines parameters of a constant force-feedback effect<BR>&nbsp;* @level: strength of the effect; may be negative<BR>&nbsp;* @envelope: envelope data<BR>&nbsp;*/<BR>struct ff_constant_effect {<BR>&nbsp;__s16 level;<BR>&nbsp;struct ff_envelope envelope;<BR>};</P>
<P>/**<BR>&nbsp;* struct ff_ramp_effect - defines parameters of a ramp force-feedback effect<BR>&nbsp;* @start_level: beginning strength of the effect; may be negative<BR>&nbsp;* @end_level: final strength of the effect; may be negative<BR>&nbsp;* @envelope: envelope data<BR>&nbsp;*/<BR>struct ff_ramp_effect {<BR>&nbsp;__s16 start_level;<BR>&nbsp;__s16 end_level;<BR>&nbsp;struct ff_envelope envelope;<BR>};</P>
<P>/**<BR>&nbsp;* struct ff_condition_effect - defines a spring or friction force-feedback effect<BR>&nbsp;* @right_saturation: maximum level when joystick moved all way to the right<BR>&nbsp;* @left_saturation: same for the left side<BR>&nbsp;* @right_coeff: controls how fast the force grows when the joystick moves<BR>&nbsp;*&nbsp;to the right<BR>&nbsp;* @left_coeff: same for the left side<BR>&nbsp;* @deadband: size of the dead zone, where no force is produced<BR>&nbsp;* @center: position of the dead zone<BR>&nbsp;*/<BR>struct ff_condition_effect {<BR>&nbsp;__u16 right_saturation;<BR>&nbsp;__u16 left_saturation;</P>
<P>&nbsp;__s16 right_coeff;<BR>&nbsp;__s16 left_coeff;</P>
<P>&nbsp;__u16 deadband;<BR>&nbsp;__s16 center;<BR>};</P>
<P>/**<BR>&nbsp;* struct ff_periodic_effect - defines parameters of a periodic force-feedback effect<BR>&nbsp;* @waveform: kind of the effect (wave)<BR>&nbsp;* @period: period of the wave (ms)<BR>&nbsp;* @magnitude: peak value<BR>&nbsp;* @offset: mean value of the wave (roughly)<BR>&nbsp;* @phase: 'horizontal' shift<BR>&nbsp;* @envelope: envelope data<BR>&nbsp;* @custom_len: number of samples (FF_CUSTOM only)<BR>&nbsp;* @custom_data: buffer of samples (FF_CUSTOM only)<BR>&nbsp;*<BR>&nbsp;* Known waveforms - FF_SQUARE, FF_TRIANGLE, FF_SINE, FF_SAW_UP,<BR>&nbsp;* FF_SAW_DOWN, FF_CUSTOM. The exact syntax FF_CUSTOM is undefined<BR>&nbsp;* for the time being as no driver supports it yet.<BR>&nbsp;*<BR>&nbsp;* Note: the data pointed by custom_data is copied by the driver.<BR>&nbsp;* You can therefore dispose of the memory after the upload/update.<BR>&nbsp;*/<BR>struct ff_periodic_effect {<BR>&nbsp;__u16 waveform;<BR>&nbsp;__u16 period;<BR>&nbsp;__s16 magnitude;<BR>&nbsp;__s16 offset;<BR>&nbsp;__u16 phase;</P>
<P>&nbsp;struct ff_envelope envelope;</P>
<P>&nbsp;__u32 custom_len;<BR>&nbsp;__s16 __user *custom_data;<BR>};</P>
<P>/**<BR>&nbsp;* struct ff_rumble_effect - defines parameters of a periodic force-feedback effect<BR>&nbsp;* @strong_magnitude: magnitude of the heavy motor<BR>&nbsp;* @weak_magnitude: magnitude of the light one<BR>&nbsp;*<BR>&nbsp;* Some rumble pads have two motors of different weight. Strong_magnitude<BR>&nbsp;* represents the magnitude of the vibration generated by the heavy one.<BR>&nbsp;*/<BR>struct ff_rumble_effect {<BR>&nbsp;__u16 strong_magnitude;<BR>&nbsp;__u16 weak_magnitude;<BR>};</P>
<P>/**<BR>&nbsp;* struct ff_effect - defines force feedback effect<BR>&nbsp;* @type: type of the effect (FF_CONSTANT, FF_PERIODIC, FF_RAMP, FF_SPRING,<BR>&nbsp;*&nbsp;FF_FRICTION, FF_DAMPER, FF_RUMBLE, FF_INERTIA, or FF_CUSTOM)<BR>&nbsp;* @id: an unique id assigned to an effect<BR>&nbsp;* @direction: direction of the effect<BR>&nbsp;* @trigger: trigger conditions (struct ff_trigger)<BR>&nbsp;* @replay: scheduling of the effect (struct ff_replay)<BR>&nbsp;* @u: effect-specific structure (one of ff_constant_effect, ff_ramp_effect,<BR>&nbsp;*&nbsp;ff_periodic_effect, ff_condition_effect, ff_rumble_effect) further<BR>&nbsp;*&nbsp;defining effect parameters<BR>&nbsp;*<BR>&nbsp;* This structure is sent through ioctl from the application to the driver.<BR>&nbsp;* To create a new effect application should set its @id to -1; the kernel<BR>&nbsp;* will return assigned @id which can later be used to update or delete<BR>&nbsp;* this effect.<BR>&nbsp;*<BR>&nbsp;* Direction of the effect is encoded as follows:<BR>&nbsp;*&nbsp;0 deg -&gt; 0x0000 (down)<BR>&nbsp;*&nbsp;90 deg -&gt; 0x4000 (left)<BR>&nbsp;*&nbsp;180 deg -&gt; 0x8000 (up)<BR>&nbsp;*&nbsp;270 deg -&gt; 0xC000 (right)<BR>&nbsp;*/<BR>struct ff_effect {<BR>&nbsp;__u16 type;<BR>&nbsp;__s16 id;<BR>&nbsp;__u16 direction;<BR>&nbsp;struct ff_trigger trigger;<BR>&nbsp;struct ff_replay replay;</P>
<P>&nbsp;union {<BR>&nbsp;&nbsp;struct ff_constant_effect constant;<BR>&nbsp;&nbsp;struct ff_ramp_effect ramp;<BR>&nbsp;&nbsp;struct ff_periodic_effect periodic;<BR>&nbsp;&nbsp;struct ff_condition_effect condition[2]; /* One for each axis */<BR>&nbsp;&nbsp;struct ff_rumble_effect rumble;<BR>&nbsp;} u;<BR>};</P>
<P>/*<BR>&nbsp;* Force feedback effect types<BR>&nbsp;*/</P>
<P>#define FF_RUMBLE&nbsp;0x50<BR>#define FF_PERIODIC&nbsp;0x51<BR>#define FF_CONSTANT&nbsp;0x52<BR>#define FF_SPRING&nbsp;0x53<BR>#define FF_FRICTION&nbsp;0x54<BR>#define FF_DAMPER&nbsp;0x55<BR>#define FF_INERTIA&nbsp;0x56<BR>#define FF_RAMP&nbsp;&nbsp;0x57</P>
<P>#define FF_EFFECT_MIN&nbsp;FF_RUMBLE<BR>#define FF_EFFECT_MAX&nbsp;FF_RAMP</P>
<P>/*<BR>&nbsp;* Force feedback periodic effect types<BR>&nbsp;*/</P>
<P>#define FF_SQUARE&nbsp;0x58<BR>#define FF_TRIANGLE&nbsp;0x59<BR>#define FF_SINE&nbsp;&nbsp;0x5a<BR>#define FF_SAW_UP&nbsp;0x5b<BR>#define FF_SAW_DOWN&nbsp;0x5c<BR>#define FF_CUSTOM&nbsp;0x5d</P>
<P>#define FF_WAVEFORM_MIN&nbsp;FF_SQUARE<BR>#define FF_WAVEFORM_MAX&nbsp;FF_CUSTOM</P>
<P>/*<BR>&nbsp;* Set ff device properties<BR>&nbsp;*/</P>
<P>#define FF_GAIN&nbsp;&nbsp;0x60<BR>#define FF_AUTOCENTER&nbsp;0x61</P>
<P>/*<BR>&nbsp;* ff-&gt;playback(effect_id = FF_GAIN) is the first effect_id to<BR>&nbsp;* cause a collision with another ff method, in this case ff-&gt;set_gain().<BR>&nbsp;* Therefore the greatest safe value for effect_id is FF_GAIN - 1,<BR>&nbsp;* and thus the total number of effects should never exceed FF_GAIN.<BR>&nbsp;*/<BR>#define FF_MAX_EFFECTS&nbsp;FF_GAIN</P>
<P>#define FF_MAX&nbsp;&nbsp;0x7f<BR>#define FF_CNT&nbsp;&nbsp;(FF_MAX+1)</P>
<P>#endif /* _UAPI_INPUT_H */