struct TranslationBlock {<BR>&nbsp;&nbsp;&nbsp; target_ulong pc;&nbsp;&nbsp; /* simulated PC corresponding to this block (EIP + CS base) */<BR>&nbsp;&nbsp;&nbsp; target_ulong cs_base; /* CS base for this block */<BR>&nbsp;&nbsp;&nbsp; uint32_t flags; /* flags defining in which context the code was generated */<BR>&nbsp;&nbsp;&nbsp; uint16_t size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* size of target code for this block (1 &lt;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size &lt;= TARGET_PAGE_SIZE) */<BR>&nbsp;&nbsp;&nbsp; uint16_t icount;<BR>&nbsp;&nbsp;&nbsp; uint32_t cflags;&nbsp;&nbsp;&nbsp; /* compile flags */<BR>#define CF_COUNT_MASK&nbsp; 0x7fff<BR>#define CF_LAST_IO&nbsp;&nbsp;&nbsp;&nbsp; 0x8000 /* Last insn may be an IO access.&nbsp; */<BR>#define CF_NOCACHE&nbsp;&nbsp;&nbsp;&nbsp; 0x10000 /* To be freed after execution */<BR>#define CF_USE_ICOUNT&nbsp; 0x20000<BR>#define CF_IGNORE_ICOUNT 0x40000 /* Do not generate icount code */</P>
<P>&nbsp;&nbsp;&nbsp; uint16_t invalid;</P>
<P>&nbsp;&nbsp;&nbsp; void *tc_ptr;&nbsp;&nbsp;&nbsp; /* pointer to the translated code */<BR>&nbsp;&nbsp;&nbsp; uint8_t *tc_search;&nbsp; /* pointer to search data */<BR>&nbsp;&nbsp;&nbsp; /* original tb when cflags has CF_NOCACHE */<BR>&nbsp;&nbsp;&nbsp; struct TranslationBlock *orig_tb;<BR>&nbsp;&nbsp;&nbsp; /* first and second physical page containing code. The lower bit<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of the pointer tells the index in page_next[] */<BR>&nbsp;&nbsp;&nbsp; struct TranslationBlock *page_next[2];<BR>&nbsp;&nbsp;&nbsp; tb_page_addr_t page_addr[2];</P>
<P>&nbsp;&nbsp;&nbsp; /* The following data are used to directly call another TB from<BR>&nbsp;&nbsp;&nbsp;&nbsp; * the code of this one. This can be done either by emitting direct or<BR>&nbsp;&nbsp;&nbsp;&nbsp; * indirect native jump instructions. These jumps are reset so that the TB<BR>&nbsp;&nbsp;&nbsp;&nbsp; * just continue its execution. The TB can be linked to another one by<BR>&nbsp;&nbsp;&nbsp;&nbsp; * setting one of the jump targets (or patching the jump instruction). Only<BR>&nbsp;&nbsp;&nbsp;&nbsp; * two of such jumps are supported.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uint16_t jmp_reset_offset[2]; /* offset of original jump target */<BR>#define TB_JMP_RESET_OFFSET_INVALID 0xffff /* indicates no jump generated */<BR>#ifdef USE_DIRECT_JUMP<BR>&nbsp;&nbsp;&nbsp; uint16_t jmp_insn_offset[2]; /* offset of native jump instruction */<BR>#else<BR>&nbsp;&nbsp;&nbsp; uintptr_t jmp_target_addr[2]; /* target address for indirect jump */<BR>#endif<BR>&nbsp;&nbsp;&nbsp; /* Each TB has an assosiated circular list of TBs jumping to this one.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * jmp_list_first points to the first TB jumping to this one.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * jmp_list_next is used to point to the next TB in a list.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Since each TB can have two jumps, it can participate in two lists.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * jmp_list_first and jmp_list_next are 4-byte aligned pointers to a<BR>&nbsp;&nbsp;&nbsp;&nbsp; * TranslationBlock structure, but the two least significant bits of<BR>&nbsp;&nbsp;&nbsp;&nbsp; * them are used to encode which data field of the pointed TB should<BR>&nbsp;&nbsp;&nbsp;&nbsp; * be used to traverse the list further from that TB:<BR>&nbsp;&nbsp;&nbsp;&nbsp; * 0 =&gt; jmp_list_next[0], 1 =&gt; jmp_list_next[1], 2 =&gt; jmp_list_first.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * In other words, 0/1 tells which jump is used in the pointed TB,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * and 2 means that this is a pointer back to the target TB of this list.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; uintptr_t jmp_list_next[2];<BR>&nbsp;&nbsp;&nbsp; uintptr_t jmp_list_first;<BR>};