<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title>The GObject messaging system</H2></DIV></DIV></DIV>
<DIV class=toc>
<DL class=toc>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/chapter-signal.html#closure">Closures</A></SPAN></DT>
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/chapter-signal.html#id-1.3.5.2.5">C Closures</A></SPAN></DT>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/chapter-signal.html#id-1.3.5.2.6">Non-C closures (for the fearless)</A></SPAN></DT></DL></DD>
<DT><SPAN class=sect1><A href="https://developer.gnome.org/gobject/stable/signal.html">Signals</A></SPAN></DT>
<DD>
<DL>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/signal.html#signal-registration">Signal registration</A></SPAN></DT>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/signal.html#signal-connection">Signal connection</A></SPAN></DT>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/signal.html#signal-emission">Signal emission</A></SPAN></DT>
<DT><SPAN class=sect2><A href="https://developer.gnome.org/gobject/stable/signal.html#signal-detail">The <SPAN class=emphasis><EM>detail</EM></SPAN> argument</A></SPAN></DT></DL></DD></DL></DIV>
<DIV class=sect1>
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title style="CLEAR: both"><A name=closure></A>Closures</H2></DIV></DIV></DIV>
<P>Closures are central to the concept of asynchronous signal delivery which is widely used throughout GTK+ and GNOME applications. A closure is an abstraction, a generic representation of a callback. It is a small structure which contains three objects: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>a function pointer (the callback itself) whose prototype looks like: </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting>return_type <SPAN class=function>function_callback</SPAN> <SPAN class="gtkdoc opt">(</SPAN>&#8230; <SPAN class="gtkdoc opt">,</SPAN> gpointer user_data<SPAN class="gtkdoc opt">);</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P></LI>
<LI class=listitem>
<P>the <EM class=parameter><CODE>user_data</CODE></EM> pointer which is passed to the callback upon invocation of the closure </P></LI>
<LI class=listitem>
<P>a function pointer which represents the destructor of the closure: whenever the closure's refcount reaches zero, this function will be called before the closure structure is freed. </P></LI></UL></DIV>
<P></P>
<P>The <A title="struct GClosure" class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#GClosure"><SPAN class=type>GClosure</SPAN></A> structure represents the common functionality of all closure implementations: there exists a different closure implementation for each separate runtime which wants to use the GObject type system. <A class=footnote href="https://developer.gnome.org/gobject/stable/chapter-signal.html#ftn.id-1.3.5.2.3.2" name=id-1.3.5.2.3.2><SUP class=footnote>[4]</SUP></A> The GObject library provides a simple <A title="struct GCClosure" class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#GCClosure"><SPAN class=type>GCClosure</SPAN></A> type which is a specific implementation of closures to be used with C/C++ callbacks. </P>
<P>A <A title="struct GClosure" class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#GClosure"><SPAN class=type>GClosure</SPAN></A> provides simple services: </P>
<DIV class=itemizedlist>
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc">
<LI class=listitem>
<P>Invocation (<CODE class=function><A title=g_closure_invoke&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-closure-invoke">g_closure_invoke</A></CODE>): this is what closures were created for: they hide the details of callback invocation from the callback invoker.</P></LI>
<LI class=listitem>
<P>Notification: the closure notifies listeners of certain events such as closure invocation, closure invalidation and closure finalization. Listeners can be registered with <CODE class=function><A title=g_closure_add_finalize_notifier&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-closure-add-finalize-notifier">g_closure_add_finalize_notifier</A></CODE> (finalization notification), <CODE class=function><A title=g_closure_add_invalidate_notifier&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-closure-add-invalidate-notifier">g_closure_add_invalidate_notifier</A></CODE> (invalidation notification) and <CODE class=function><A title=g_closure_add_marshal_guards&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-closure-add-marshal-guards">g_closure_add_marshal_guards</A></CODE> (invocation notification). There exist symmetric deregistration functions for finalization and invalidation events (<CODE class=function><A title=g_closure_remove_finalize_notifier&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-closure-remove-finalize-notifier">g_closure_remove_finalize_notifier</A></CODE> and <CODE class=function><A title=g_closure_remove_invalidate_notifier&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-closure-remove-invalidate-notifier">g_closure_remove_invalidate_notifier</A></CODE>) but not for the invocation process. <A class=footnote href="https://developer.gnome.org/gobject/stable/chapter-signal.html#ftn.id-1.3.5.2.4.2.2.1.6" name=id-1.3.5.2.4.2.2.1.6><SUP class=footnote>[5]</SUP></A></P></LI></UL></DIV>
<P></P>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id-1.3.5.2.5></A>C Closures</H3></DIV></DIV></DIV>
<P>If you are using C or C++ to connect a callback to a given event, you will either use simple <A title="struct GCClosure" class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#GCClosure"><SPAN class=type>GCClosure</SPAN></A>s which have a pretty minimal API or the even simpler <CODE class=function><A title=g_signal_connect() class=link href="https://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-connect">g_signal_connect</A></CODE> functions (which will be presented a bit later). </P>
<P><CODE class=function><A title=g_cclosure_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-cclosure-new">g_cclosure_new</A></CODE> will create a new closure which can invoke the user-provided callback_func with the user-provided <EM class=parameter><CODE>user_data</CODE></EM> as its last parameter. When the closure is finalized (second stage of the destruction process), it will invoke the <EM class=parameter><CODE>destroy_data</CODE></EM> function if the user has supplied one. </P>
<P><CODE class=function><A title=g_cclosure_new_swap&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-cclosure-new-swap">g_cclosure_new_swap</A></CODE> will create a new closure which can invoke the user-provided <EM class=parameter><CODE>callback_func</CODE></EM> with the user-provided <EM class=parameter><CODE>user_data</CODE></EM> as its first parameter (instead of being the last parameter as with <CODE class=function><A title=g_cclosure_new&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-cclosure-new">g_cclosure_new</A></CODE>). When the closure is finalized (second stage of the destruction process), it will invoke the <EM class=parameter><CODE>destroy_data</CODE></EM> function if the user has supplied one. </P></DIV>
<DIV class=sect2>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=id-1.3.5.2.6></A>Non-C closures (for the fearless)</H3></DIV></DIV></DIV>
<P>As was explained above, closures hide the details of callback invocation. In C, callback invocation is just like function invocation: it is a matter of creating the correct stack frame for the called function and executing a <SPAN class=emphasis><EM>call</EM></SPAN> assembly instruction. </P>
<P>C closure marshallers transform the array of GValues which represent the parameters to the target function into a C-style function parameter list, invoke the user-supplied C function with this new parameter list, get the return value of the function, transform it into a GValue and return this GValue to the marshaller caller. </P>
<P>A generic C closure marshaller is available as <A title=g_cclosure_marshal_generic&nbsp;() class=link href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-cclosure-marshal-generic"><CODE class=function>g_cclosure_marshal_generic</CODE></A> which implements marshalling for all function types using libffi. Custom marshallers for different types are not needed apart from performance critical code where the libffi-based marshaller may be too slow. </P>
<P>An example of a custom marshaller is given below, illustrating how <SPAN class=type>GValue</SPAN>s can be converted to a C function call. The marshaller is for a C function which takes an integer as its first parameter and returns void. </P>
<DIV class=informalexample>
<TABLE class=listing_frame cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=listing_code><PRE class=programlisting><SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Closures.html#g-cclosure-marshal-VOID--INT">g_cclosure_marshal_VOID__INT</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>GClosure     <SPAN class="gtkdoc opt">*</SPAN>closure<SPAN class="gtkdoc opt">,</SPAN>
                              GValue       <SPAN class="gtkdoc opt">*</SPAN>return_value<SPAN class="gtkdoc opt">,</SPAN>
                              guint         n_param_values<SPAN class="gtkdoc opt">,</SPAN>
                              <SPAN class="gtkdoc kwb">const</SPAN> GValue <SPAN class="gtkdoc opt">*</SPAN>param_values<SPAN class="gtkdoc opt">,</SPAN>
                              gpointer      invocation_hint<SPAN class="gtkdoc opt">,</SPAN>
                              gpointer      marshal_data<SPAN class="gtkdoc opt">)</SPAN>
<SPAN class="gtkdoc opt">{</SPAN>
  <SPAN class="gtkdoc kwc">typedef</SPAN> <SPAN class="gtkdoc kwb">void</SPAN> <SPAN class="gtkdoc opt">(*</SPAN>GMarshalFunc_VOID__INT<SPAN class="gtkdoc opt">) (</SPAN>gpointer     data1<SPAN class="gtkdoc opt">,</SPAN>
                                          gint         arg_1<SPAN class="gtkdoc opt">,</SPAN>
                                          gpointer     data2<SPAN class="gtkdoc opt">);</SPAN>
  <SPAN class="gtkdoc kwc">register</SPAN> GMarshalFunc_VOID__INT callback<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc kwc">register</SPAN> GCClosure <SPAN class="gtkdoc opt">*</SPAN>cc <SPAN class="gtkdoc opt">= (</SPAN>GCClosure<SPAN class="gtkdoc opt">*)</SPAN> closure<SPAN class="gtkdoc opt">;</SPAN>
  <SPAN class="gtkdoc kwc">register</SPAN> gpointer data1<SPAN class="gtkdoc opt">,</SPAN> data2<SPAN class="gtkdoc opt">;</SPAN>

  <SPAN class=function><A href="https://developer.gnome.org/gobject/glib-Warnings-and-Assertions.html#g-return-if-fail">g_return_if_fail</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>n_param_values <SPAN class="gtkdoc opt">==</SPAN> <SPAN class=number>2</SPAN><SPAN class="gtkdoc opt">);</SPAN>

  data1 <SPAN class="gtkdoc opt">=</SPAN> <SPAN class=function><A href="https://developer.gnome.org/gobject/stable/gobject-Generic-values.html#g-value-peek-pointer">g_value_peek_pointer</A></SPAN> <SPAN class="gtkdoc opt">(</SPAN>param_values <SPAN class="gtkdoc opt">+</SPAN> <SPAN class=number>0</SPAN><SPAN class="gtkdoc opt">);</SPAN>
  data2 <SPAN class="gtkdoc opt">=</SPAN> closure<SPAN class="gtkdoc opt">-&gt;</SPAN>data<SPAN class="gtkdoc opt">;</SPAN>

  callback <SPAN class="gtkdoc opt">= (</SPAN>GMarshalFunc_VOID__INT<SPAN class="gtkdoc opt">) (</SPAN>marshal_data <SPAN class="gtkdoc opt">?</SPAN> marshal_data <SPAN class="gtkdoc opt">:</SPAN> cc<SPAN class="gtkdoc opt">-&gt;</SPAN>callback<SPAN class="gtkdoc opt">);</SPAN>

  <SPAN class=function>callback</SPAN> <SPAN class="gtkdoc opt">(</SPAN>data1<SPAN class="gtkdoc opt">,</SPAN>
            <SPAN class=function>g_marshal_value_peek_int</SPAN> <SPAN class="gtkdoc opt">(</SPAN>param_values <SPAN class="gtkdoc opt">+</SPAN> <SPAN class=number>1</SPAN><SPAN class="gtkdoc opt">),</SPAN>
            data2<SPAN class="gtkdoc opt">);</SPAN>
<SPAN class="gtkdoc opt">}</SPAN></PRE></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>There exist other kinds of marshallers, for example there is a generic Python marshaller which is used by all Python closures (a Python closure is used to invoke a callback written in Python). This Python marshaller transforms the input GValue list representing the function parameters into a Python tuple which is the equivalent structure in Python. </P></DIV></DIV>
<DIV class=footnotes><BR>
<HR style="WIDTH: 100px; TEXT-ALIGN: left; MARGIN-LEFT: 0px">

<DIV id=ftn.id-1.3.5.2.3.2 class=footnote>
<P><A class=para href="https://developer.gnome.org/gobject/stable/chapter-signal.html#id-1.3.5.2.3.2"><SUP class=para>[4] </SUP></A>In practice, closures sit at the boundary of language runtimes: if you are writing Python code and one of your Python callbacks receives a signal from a GTK+ widget, the C code in GTK+ needs to execute your Python code. The closure invoked by the GTK+ object invokes the Python callback: it behaves as a normal C object for GTK+ and as a normal Python object for Python code. </P></DIV>
<DIV id=ftn.id-1.3.5.2.4.2.2.1.6 class=footnote>
<P><A class=para href="https://developer.gnome.org/gobject/stable/chapter-signal.html#id-1.3.5.2.4.2.2.1.6"><SUP class=para>[5] </SUP></A>Closures are reference counted and notify listeners of their destruction in a two-stage process: the invalidation notifiers are invoked before the finalization notifiers. </P></DIV></DIV>