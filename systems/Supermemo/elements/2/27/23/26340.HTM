# qemu:hw/core/qdev.c 
<P></P>
<P>/*<BR>&nbsp;*&nbsp; Dynamic device configuration and creation.<BR>&nbsp;*<BR>&nbsp;*&nbsp; Copyright (c) 2009 CodeSourcery<BR>&nbsp;*<BR>&nbsp;* This library is free software; you can redistribute it and/or<BR>&nbsp;* modify it under the terms of the GNU Lesser General Public<BR>&nbsp;* License as published by the Free Software Foundation; either<BR>&nbsp;* version 2 of the License, or (at your option) any later version.<BR>&nbsp;*<BR>&nbsp;* This library is distributed in the hope that it will be useful,<BR>&nbsp;* but WITHOUT ANY WARRANTY; without even the implied warranty of<BR>&nbsp;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp; See the GNU<BR>&nbsp;* Lesser General Public License for more details.<BR>&nbsp;*<BR>&nbsp;* You should have received a copy of the GNU Lesser General Public<BR>&nbsp;* License along with this library; if not, see &lt;<A href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.<BR>&nbsp;*/</P>
<P></P>
<P>/* The theory here is that it should be possible to create a machine without<BR>&nbsp;&nbsp; knowledge of specific devices.&nbsp; Historically board init routines have<BR>&nbsp;&nbsp; passed a bunch of arguments to each device, requiring the board know<BR>&nbsp;&nbsp; exactly which device it is dealing with.&nbsp; This file provides an abstract<BR>&nbsp;&nbsp; API for device configuration and initialization.&nbsp; Devices will generally<BR>&nbsp;&nbsp; inherit from a particular bus (e.g. PCI or I2C) rather than<BR>&nbsp;&nbsp; this API directly.&nbsp; */</P>
<P>#include "qemu/osdep.h"<BR>#include "hw/qdev.h"<BR>#include "hw/fw-path-provider.h"<BR>#include "sysemu/sysemu.h"<BR>#include "qapi/qmp/qerror.h"<BR>#include "qapi/visitor.h"<BR>#include "qapi/qmp/qjson.h"<BR>#include "qemu/error-report.h"<BR>#include "hw/hotplug.h"<BR>#include "hw/boards.h"<BR>#include "hw/sysbus.h"<BR>#include "qapi-event.h"<BR>#include "migration/migration.h"</P>
<P>int qdev_hotplug = 0;<BR>static bool qdev_hot_added = false;<BR>static bool qdev_hot_removed = false;</P>
<P>const VMStateDescription *qdev_get_vmsd(DeviceState *dev)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceClass *dc = DEVICE_GET_CLASS(dev);<BR>&nbsp;&nbsp;&nbsp; return dc-&gt;vmsd;<BR>}</P>
<P>const char *qdev_fw_name(DeviceState *dev)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceClass *dc = DEVICE_GET_CLASS(dev);</P>
<P>&nbsp;&nbsp;&nbsp; if (dc-&gt;fw_name) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dc-&gt;fw_name;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return object_get_typename(OBJECT(dev));<BR>}</P>
<P>static void bus_remove_child(BusState *bus, DeviceState *child)<BR>{<BR>&nbsp;&nbsp;&nbsp; BusChild *kid;</P>
<P>&nbsp;&nbsp;&nbsp; QTAILQ_FOREACH(kid, &amp;bus-&gt;children, sibling) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (kid-&gt;child == child) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char name[32];</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; snprintf(name, sizeof(name), "child[%d]", kid-&gt;index);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QTAILQ_REMOVE(&amp;bus-&gt;children, kid, sibling);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* This gives back ownership of kid-&gt;child back to us.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_del(OBJECT(bus), name, NULL);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_unref(OBJECT(kid-&gt;child));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_free(kid);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void bus_add_child(BusState *bus, DeviceState *child)<BR>{<BR>&nbsp;&nbsp;&nbsp; char name[32];<BR>&nbsp;&nbsp;&nbsp; BusChild *kid = g_malloc0(sizeof(*kid));</P>
<P>&nbsp;&nbsp;&nbsp; kid-&gt;index = bus-&gt;max_index++;<BR>&nbsp;&nbsp;&nbsp; kid-&gt;child = child;<BR>&nbsp;&nbsp;&nbsp; object_ref(OBJECT(kid-&gt;child));</P>
<P>&nbsp;&nbsp;&nbsp; QTAILQ_INSERT_HEAD(&amp;bus-&gt;children, kid, sibling);</P>
<P>&nbsp;&nbsp;&nbsp; /* This transfers ownership of kid-&gt;child to the property.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; snprintf(name, sizeof(name), "child[%d]", kid-&gt;index);<BR>&nbsp;&nbsp;&nbsp; object_property_add_link(OBJECT(bus), name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_get_typename(OBJECT(child)),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Object **)&amp;kid-&gt;child,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, /* read-only property */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, /* return ownership on prop deletion */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);<BR>}</P>
<P>void qdev_set_parent_bus(DeviceState *dev, BusState *bus)<BR>{<BR>&nbsp;&nbsp;&nbsp; bool replugging = dev-&gt;parent_bus != NULL;</P>
<P>&nbsp;&nbsp;&nbsp; if (replugging) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Keep a reference to the device while it's not plugged into<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * any bus, to avoid it potentially evaporating when it is<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * dereffed in bus_remove_child().<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_ref(OBJECT(dev));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bus_remove_child(dev-&gt;parent_bus, dev);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_unref(OBJECT(dev-&gt;parent_bus));<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; dev-&gt;parent_bus = bus;<BR>&nbsp;&nbsp;&nbsp; object_ref(OBJECT(bus));<BR>&nbsp;&nbsp;&nbsp; bus_add_child(bus, dev);<BR>&nbsp;&nbsp;&nbsp; if (replugging) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_unref(OBJECT(dev));<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P><FONT class=extract>/* Create a new device.&nbsp; This only initializes the device state<BR>&nbsp;&nbsp; structure and allows properties to be set.&nbsp; The device still needs<BR>&nbsp;&nbsp; to be realized.&nbsp; See qdev-core.h.&nbsp; */<BR>DeviceState *qdev_create(BusState *bus, const char *name)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceState *dev;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; dev = qdev_try_create(bus, name);<BR>&nbsp;&nbsp;&nbsp; if (!dev) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bus) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_report("Unknown device '%s' for bus '%s'", name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_get_typename(OBJECT(bus)));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_report("Unknown device '%s' for default sysbus", name);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; return dev;<BR>}</FONT></P>
<P><FONT class=extract>DeviceState *qdev_try_create(BusState *bus, const char *type)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceState *dev;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (object_class_by_name(type) == NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; dev = DEVICE(object_new(type));<BR>&nbsp;&nbsp;&nbsp; if (!dev) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if (!bus) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Assert that the device really is a SysBusDevice before<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * we put it onto the sysbus. Non-sysbus devices which aren't<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * being put onto a bus should be created with object_new(TYPE_FOO),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * not qdev_create(NULL, TYPE_FOO).<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert(object_dynamic_cast(OBJECT(dev), TYPE_SYS_BUS_DEVICE));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bus = sysbus_get_default();<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; qdev_set_parent_bus(dev, bus);<BR>&nbsp;&nbsp;&nbsp; object_unref(OBJECT(dev));<BR>&nbsp;&nbsp;&nbsp; return dev;<BR>}</FONT></P>
<P>static QTAILQ_HEAD(device_listeners, DeviceListener) device_listeners<BR>&nbsp;&nbsp;&nbsp; = QTAILQ_HEAD_INITIALIZER(device_listeners);</P>
<P>enum ListenerDirection { Forward, Reverse };</P>
<P>#define DEVICE_LISTENER_CALL(_callback, _direction, _args...)&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeviceListener *_listener;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (_direction) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Forward:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QTAILQ_FOREACH(_listener, &amp;device_listeners, link) {&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_listener-&gt;_callback) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _listener-&gt;_callback(_listener, ##_args);&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case Reverse:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QTAILQ_FOREACH_REVERSE(_listener, &amp;device_listeners,&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; device_listeners, link) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_listener-&gt;_callback) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _listener-&gt;_callback(_listener, ##_args);&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; } while (0)</P>
<P>static int device_listener_add(DeviceState *dev, void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; DEVICE_LISTENER_CALL(realize, Forward, dev);</P>
<P>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>void device_listener_register(DeviceListener *listener)<BR>{<BR>&nbsp;&nbsp;&nbsp; QTAILQ_INSERT_TAIL(&amp;device_listeners, listener, link);</P>
<P>&nbsp;&nbsp;&nbsp; qbus_walk_children(sysbus_get_default(), NULL, NULL, device_listener_add,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, NULL);<BR>}</P>
<P>void device_listener_unregister(DeviceListener *listener)<BR>{<BR>&nbsp;&nbsp;&nbsp; QTAILQ_REMOVE(&amp;device_listeners, listener, link);<BR>}</P>
<P>static void device_realize(DeviceState *dev, Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceClass *dc = DEVICE_GET_CLASS(dev);</P>
<P>&nbsp;&nbsp;&nbsp; if (dc-&gt;init) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int rc = dc-&gt;init(dev);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rc &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "Device initialization failed.");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void device_unrealize(DeviceState *dev, Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceClass *dc = DEVICE_GET_CLASS(dev);</P>
<P>&nbsp;&nbsp;&nbsp; if (dc-&gt;exit) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int rc = dc-&gt;exit(dev);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rc &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, "Device exit failed.");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void qdev_set_legacy_instance_id(DeviceState *dev, int alias_id,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int required_for_version)<BR>{<BR>&nbsp;&nbsp;&nbsp; assert(!dev-&gt;realized);<BR>&nbsp;&nbsp;&nbsp; dev-&gt;instance_id_alias = alias_id;<BR>&nbsp;&nbsp;&nbsp; dev-&gt;alias_required_for_version = required_for_version;<BR>}</P>
<P>HotplugHandler *qdev_get_hotplug_handler(DeviceState *dev)<BR>{<BR>&nbsp;&nbsp;&nbsp; HotplugHandler *hotplug_ctrl = NULL;</P>
<P>&nbsp;&nbsp;&nbsp; if (dev-&gt;parent_bus &amp;&amp; dev-&gt;parent_bus-&gt;hotplug_handler) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hotplug_ctrl = dev-&gt;parent_bus-&gt;hotplug_handler;<BR>&nbsp;&nbsp;&nbsp; } else if (object_dynamic_cast(qdev_get_machine(), TYPE_MACHINE)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MachineState *machine = MACHINE(qdev_get_machine());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MachineClass *mc = MACHINE_GET_CLASS(machine);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mc-&gt;get_hotplug_handler) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hotplug_ctrl = mc-&gt;get_hotplug_handler(machine, dev);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return hotplug_ctrl;<BR>}</P>
<P>void qdev_unplug(DeviceState *dev, Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceClass *dc = DEVICE_GET_CLASS(dev);<BR>&nbsp;&nbsp;&nbsp; HotplugHandler *hotplug_ctrl;<BR>&nbsp;&nbsp;&nbsp; HotplugHandlerClass *hdc;</P>
<P>&nbsp;&nbsp;&nbsp; if (dev-&gt;parent_bus &amp;&amp; !qbus_is_hotpluggable(dev-&gt;parent_bus)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, QERR_BUS_NO_HOTPLUG, dev-&gt;parent_bus-&gt;name);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (!dc-&gt;hotpluggable) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, QERR_DEVICE_NO_HOTPLUG,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_get_typename(OBJECT(dev)));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; qdev_hot_removed = true;</P>
<P>&nbsp;&nbsp;&nbsp; hotplug_ctrl = qdev_get_hotplug_handler(dev);<BR>&nbsp;&nbsp;&nbsp; /* hotpluggable device MUST have HotplugHandler, if it doesn't<BR>&nbsp;&nbsp;&nbsp;&nbsp; * then something is very wrong with it */<BR>&nbsp;&nbsp;&nbsp; g_assert(hotplug_ctrl);</P>
<P>&nbsp;&nbsp;&nbsp; /* If device supports async unplug just request it to be done,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * otherwise just remove it synchronously */<BR>&nbsp;&nbsp;&nbsp; hdc = HOTPLUG_HANDLER_GET_CLASS(hotplug_ctrl);<BR>&nbsp;&nbsp;&nbsp; if (hdc-&gt;unplug_request) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hotplug_handler_unplug_request(hotplug_ctrl, dev, errp);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hotplug_handler_unplug(hotplug_ctrl, dev, errp);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static int qdev_reset_one(DeviceState *dev, void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; device_reset(dev);</P>
<P>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>static int qbus_reset_one(BusState *bus, void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; BusClass *bc = BUS_GET_CLASS(bus);<BR>&nbsp;&nbsp;&nbsp; if (bc-&gt;reset) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bc-&gt;reset(bus);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>void qdev_reset_all(DeviceState *dev)<BR>{<BR>&nbsp;&nbsp;&nbsp; qdev_walk_children(dev, NULL, NULL, qdev_reset_one, qbus_reset_one, NULL);<BR>}</P>
<P>void qdev_reset_all_fn(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; qdev_reset_all(DEVICE(opaque));<BR>}</P>
<P>void qbus_reset_all(BusState *bus)<BR>{<BR>&nbsp;&nbsp;&nbsp; qbus_walk_children(bus, NULL, NULL, qdev_reset_one, qbus_reset_one, NULL);<BR>}</P>
<P>void qbus_reset_all_fn(void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; BusState *bus = opaque;<BR>&nbsp;&nbsp;&nbsp; qbus_reset_all(bus);<BR>}</P>
<P>/* can be used as -&gt;unplug() callback for the simple cases */<BR>void qdev_simple_device_unplug_cb(HotplugHandler *hotplug_dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeviceState *dev, Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* just zap it */<BR>&nbsp;&nbsp;&nbsp; object_unparent(OBJECT(dev));<BR>}</P>
<P>/*<BR>&nbsp;* Realize @dev.<BR>&nbsp;* Device properties should be set before calling this function.&nbsp; IRQs<BR>&nbsp;* and MMIO regions should be connected/mapped after calling this<BR>&nbsp;* function.<BR>&nbsp;* On failure, report an error with error_report() and terminate the<BR>&nbsp;* program.&nbsp; This is okay during machine creation.&nbsp; Don't use for<BR>&nbsp;* hotplug, because there callers need to recover from failure.<BR>&nbsp;* Exception: if you know the device's init() callback can't fail,<BR>&nbsp;* then qdev_init_nofail() can't fail either, and is therefore usable<BR>&nbsp;* even then.&nbsp; But relying on the device implementation that way is<BR>&nbsp;* somewhat unclean, and best avoided.<BR>&nbsp;*/<BR>void qdev_init_nofail(DeviceState *dev)<BR>{<BR>&nbsp;&nbsp;&nbsp; Error *err = NULL;</P>
<P>&nbsp;&nbsp;&nbsp; assert(!dev-&gt;realized);</P>
<P>&nbsp;&nbsp;&nbsp; object_ref(OBJECT(dev));<BR>&nbsp;&nbsp;&nbsp; object_property_set_bool(OBJECT(dev), true, "realized", &amp;err);<BR>&nbsp;&nbsp;&nbsp; if (err) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_reportf_err(err, "Initialization of device %s failed: ",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_get_typename(OBJECT(dev)));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; object_unref(OBJECT(dev));<BR>}</P>
<P>void qdev_machine_creation_done(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp; * ok, initial machine setup is done, starting from now we can<BR>&nbsp;&nbsp;&nbsp;&nbsp; * only create hotpluggable devices<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; qdev_hotplug = 1;<BR>}</P>
<P>bool qdev_machine_modified(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; return qdev_hot_added || qdev_hot_removed;<BR>}</P>
<P>BusState *qdev_get_parent_bus(DeviceState *dev)<BR>{<BR>&nbsp;&nbsp;&nbsp; return dev-&gt;parent_bus;<BR>}</P>
<P>static NamedGPIOList *qdev_get_named_gpio_list(DeviceState *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name)<BR>{<BR>&nbsp;&nbsp;&nbsp; NamedGPIOList *ngl;</P>
<P>&nbsp;&nbsp;&nbsp; QLIST_FOREACH(ngl, &amp;dev-&gt;gpios, node) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* NULL is a valid and matchable name, otherwise do a normal<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * strcmp match.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((!ngl-&gt;name &amp;&amp; !name) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (name &amp;&amp; ngl-&gt;name &amp;&amp; strcmp(name, ngl-&gt;name) == 0)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ngl;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; ngl = g_malloc0(sizeof(*ngl));<BR>&nbsp;&nbsp;&nbsp; ngl-&gt;name = g_strdup(name);<BR>&nbsp;&nbsp;&nbsp; QLIST_INSERT_HEAD(&amp;dev-&gt;gpios, ngl, node);<BR>&nbsp;&nbsp;&nbsp; return ngl;<BR>}</P>
<P>void qdev_init_gpio_in_named(DeviceState *dev, qemu_irq_handler handler,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name, int n)<BR>{<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; NamedGPIOList *gpio_list = qdev_get_named_gpio_list(dev, name);</P>
<P>&nbsp;&nbsp;&nbsp; assert(gpio_list-&gt;num_out == 0 || !name);<BR>&nbsp;&nbsp;&nbsp; gpio_list-&gt;in = qemu_extend_irqs(gpio_list-&gt;in, gpio_list-&gt;num_in, handler,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev, n);</P>
<P>&nbsp;&nbsp;&nbsp; if (!name) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name = "unnamed-gpio-in";<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; for (i = gpio_list-&gt;num_in; i &lt; gpio_list-&gt;num_in + n; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gchar *propname = g_strdup_printf("%s[%u]", name, i);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_add_child(OBJECT(dev), propname,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT(gpio_list-&gt;in[i]), &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_free(propname);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; gpio_list-&gt;num_in += n;<BR>}</P>
<P>void qdev_init_gpio_in(DeviceState *dev, qemu_irq_handler handler, int n)<BR>{<BR>&nbsp;&nbsp;&nbsp; qdev_init_gpio_in_named(dev, handler, NULL, n);<BR>}</P>
<P>void qdev_init_gpio_out_named(DeviceState *dev, qemu_irq *pins,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name, int n)<BR>{<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; NamedGPIOList *gpio_list = qdev_get_named_gpio_list(dev, name);</P>
<P>&nbsp;&nbsp;&nbsp; assert(gpio_list-&gt;num_in == 0 || !name);</P>
<P>&nbsp;&nbsp;&nbsp; if (!name) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name = "unnamed-gpio-out";<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; memset(pins, 0, sizeof(*pins) * n);<BR>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; n; ++i) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gchar *propname = g_strdup_printf("%s[%u]", name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gpio_list-&gt;num_out + i);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_add_link(OBJECT(dev), propname, TYPE_IRQ,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Object **)&amp;pins[i],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_allow_set_link,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJ_PROP_LINK_UNREF_ON_RELEASE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_free(propname);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; gpio_list-&gt;num_out += n;<BR>}</P>
<P>void qdev_init_gpio_out(DeviceState *dev, qemu_irq *pins, int n)<BR>{<BR>&nbsp;&nbsp;&nbsp; qdev_init_gpio_out_named(dev, pins, NULL, n);<BR>}</P>
<P>qemu_irq qdev_get_gpio_in_named(DeviceState *dev, const char *name, int n)<BR>{<BR>&nbsp;&nbsp;&nbsp; NamedGPIOList *gpio_list = qdev_get_named_gpio_list(dev, name);</P>
<P>&nbsp;&nbsp;&nbsp; assert(n &gt;= 0 &amp;&amp; n &lt; gpio_list-&gt;num_in);<BR>&nbsp;&nbsp;&nbsp; return gpio_list-&gt;in[n];<BR>}</P>
<P>qemu_irq qdev_get_gpio_in(DeviceState *dev, int n)<BR>{<BR>&nbsp;&nbsp;&nbsp; return qdev_get_gpio_in_named(dev, NULL, n);<BR>}</P>
<P>void qdev_connect_gpio_out_named(DeviceState *dev, const char *name, int n,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_irq pin)<BR>{<BR>&nbsp;&nbsp;&nbsp; char *propname = g_strdup_printf("%s[%d]",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name ? name : "unnamed-gpio-out", n);<BR>&nbsp;&nbsp;&nbsp; if (pin) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We need a name for object_property_set_link to work.&nbsp; If the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * object has a parent, object_property_add_child will come back<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * with an error without doing anything.&nbsp; If it has none, it will<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * never fail.&nbsp; So we can just call it with a NULL Error pointer.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_add_child(container_get(qdev_get_machine(),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "/unattached"),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "non-qdev-gpio[*]", OBJECT(pin), NULL);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; object_property_set_link(OBJECT(dev), OBJECT(pin), propname, &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp; g_free(propname);<BR>}</P>
<P>qemu_irq qdev_get_gpio_out_connector(DeviceState *dev, const char *name, int n)<BR>{<BR>&nbsp;&nbsp;&nbsp; char *propname = g_strdup_printf("%s[%d]",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name ? name : "unnamed-gpio-out", n);</P>
<P>&nbsp;&nbsp;&nbsp; qemu_irq ret = (qemu_irq)object_property_get_link(OBJECT(dev), propname,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);</P>
<P>&nbsp;&nbsp;&nbsp; return ret;<BR>}</P>
<P>/* disconnect a GPIO output, returning the disconnected input (if any) */</P>
<P>static qemu_irq qdev_disconnect_gpio_out_named(DeviceState *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name, int n)<BR>{<BR>&nbsp;&nbsp;&nbsp; char *propname = g_strdup_printf("%s[%d]",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name ? name : "unnamed-gpio-out", n);</P>
<P>&nbsp;&nbsp;&nbsp; qemu_irq ret = (qemu_irq)object_property_get_link(OBJECT(dev), propname,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);<BR>&nbsp;&nbsp;&nbsp; if (ret) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_set_link(OBJECT(dev), NULL, propname, NULL);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; g_free(propname);<BR>&nbsp;&nbsp;&nbsp; return ret;<BR>}</P>
<P>qemu_irq qdev_intercept_gpio_out(DeviceState *dev, qemu_irq icpt,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name, int n)<BR>{<BR>&nbsp;&nbsp;&nbsp; qemu_irq disconnected = qdev_disconnect_gpio_out_named(dev, name, n);<BR>&nbsp;&nbsp;&nbsp; qdev_connect_gpio_out_named(dev, name, n, icpt);<BR>&nbsp;&nbsp;&nbsp; return disconnected;<BR>}</P>
<P>void qdev_connect_gpio_out(DeviceState * dev, int n, qemu_irq pin)<BR>{<BR>&nbsp;&nbsp;&nbsp; qdev_connect_gpio_out_named(dev, NULL, n, pin);<BR>}</P>
<P>void qdev_pass_gpios(DeviceState *dev, DeviceState *container,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name)<BR>{<BR>&nbsp;&nbsp;&nbsp; int i;<BR>&nbsp;&nbsp;&nbsp; NamedGPIOList *ngl = qdev_get_named_gpio_list(dev, name);</P>
<P>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; ngl-&gt;num_in; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *nm = ngl-&gt;name ? ngl-&gt;name : "unnamed-gpio-in";<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *propname = g_strdup_printf("%s[%d]", nm, i);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_add_alias(OBJECT(container), propname,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT(dev), propname,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_free(propname);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; ngl-&gt;num_out; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *nm = ngl-&gt;name ? ngl-&gt;name : "unnamed-gpio-out";<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *propname = g_strdup_printf("%s[%d]", nm, i);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_add_alias(OBJECT(container), propname,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT(dev), propname,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_free(propname);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; QLIST_REMOVE(ngl, node);<BR>&nbsp;&nbsp;&nbsp; QLIST_INSERT_HEAD(&amp;container-&gt;gpios, ngl, node);<BR>}</P>
<P>BusState *qdev_get_child_bus(DeviceState *dev, const char *name)<BR>{<BR>&nbsp;&nbsp;&nbsp; BusState *bus;<BR>&nbsp;&nbsp;&nbsp; Object *child = object_resolve_path_component(OBJECT(dev), name);</P>
<P>&nbsp;&nbsp;&nbsp; bus = (BusState *)object_dynamic_cast(child, TYPE_BUS);<BR>&nbsp;&nbsp;&nbsp; if (bus) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return bus;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; QLIST_FOREACH(bus, &amp;dev-&gt;child_bus, sibling) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (strcmp(name, bus-&gt;name) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return bus;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return NULL;<BR>}</P>
<P>int qdev_walk_children(DeviceState *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_walkerfn *pre_devfn, qbus_walkerfn *pre_busfn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_walkerfn *post_devfn, qbus_walkerfn *post_busfn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; BusState *bus;<BR>&nbsp;&nbsp;&nbsp; int err;</P>
<P>&nbsp;&nbsp;&nbsp; if (pre_devfn) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err = pre_devfn(dev, opaque);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (err) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return err;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; QLIST_FOREACH(bus, &amp;dev-&gt;child_bus, sibling) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err = qbus_walk_children(bus, pre_devfn, pre_busfn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; post_devfn, post_busfn, opaque);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (err &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return err;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (post_devfn) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err = post_devfn(dev, opaque);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (err) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return err;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>DeviceState *qdev_find_recursive(BusState *bus, const char *id)<BR>{<BR>&nbsp;&nbsp;&nbsp; BusChild *kid;<BR>&nbsp;&nbsp;&nbsp; DeviceState *ret;<BR>&nbsp;&nbsp;&nbsp; BusState *child;</P>
<P>&nbsp;&nbsp;&nbsp; QTAILQ_FOREACH(kid, &amp;bus-&gt;children, sibling) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeviceState *dev = kid-&gt;child;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dev-&gt;id &amp;&amp; strcmp(dev-&gt;id, id) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dev;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QLIST_FOREACH(child, &amp;dev-&gt;child_bus, sibling) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = qdev_find_recursive(child, id);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ret) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ret;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return NULL;<BR>}</P>
<P>static char *bus_get_fw_dev_path(BusState *bus, DeviceState *dev)<BR>{<BR>&nbsp;&nbsp;&nbsp; BusClass *bc = BUS_GET_CLASS(bus);</P>
<P>&nbsp;&nbsp;&nbsp; if (bc-&gt;get_fw_dev_path) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return bc-&gt;get_fw_dev_path(dev);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return NULL;<BR>}</P>
<P>static char *qdev_get_fw_dev_path_from_handler(BusState *bus, DeviceState *dev)<BR>{<BR>&nbsp;&nbsp;&nbsp; Object *obj = OBJECT(dev);<BR>&nbsp;&nbsp;&nbsp; char *d = NULL;</P>
<P>&nbsp;&nbsp;&nbsp; while (!d &amp;&amp; obj-&gt;parent) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj = obj-&gt;parent;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d = fw_path_provider_try_get_dev_path(obj, bus, dev);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return d;<BR>}</P>
<P>char *qdev_get_own_fw_dev_path_from_handler(BusState *bus, DeviceState *dev)<BR>{<BR>&nbsp;&nbsp;&nbsp; Object *obj = OBJECT(dev);</P>
<P>&nbsp;&nbsp;&nbsp; return fw_path_provider_try_get_dev_path(obj, bus, dev);<BR>}</P>
<P>static int qdev_get_fw_dev_path_helper(DeviceState *dev, char *p, int size)<BR>{<BR>&nbsp;&nbsp;&nbsp; int l = 0;</P>
<P>&nbsp;&nbsp;&nbsp; if (dev &amp;&amp; dev-&gt;parent_bus) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *d;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = qdev_get_fw_dev_path_helper(dev-&gt;parent_bus-&gt;parent, p, size);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d = qdev_get_fw_dev_path_from_handler(dev-&gt;parent_bus, dev);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!d) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d = bus_get_fw_dev_path(dev-&gt;parent_bus, dev);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (d) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l += snprintf(p + l, size - l, "%s", d);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_free(d);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return l;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; l += snprintf(p + l , size - l, "/");</P>
<P>&nbsp;&nbsp;&nbsp; return l;<BR>}</P>
<P>char* qdev_get_fw_dev_path(DeviceState *dev)<BR>{<BR>&nbsp;&nbsp;&nbsp; char path[128];<BR>&nbsp;&nbsp;&nbsp; int l;</P>
<P>&nbsp;&nbsp;&nbsp; l = qdev_get_fw_dev_path_helper(dev, path, 128);</P>
<P>&nbsp;&nbsp;&nbsp; path[l-1] = '\0';</P>
<P>&nbsp;&nbsp;&nbsp; return g_strdup(path);<BR>}</P>
<P>char *qdev_get_dev_path(DeviceState *dev)<BR>{<BR>&nbsp;&nbsp;&nbsp; BusClass *bc;</P>
<P>&nbsp;&nbsp;&nbsp; if (!dev || !dev-&gt;parent_bus) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; bc = BUS_GET_CLASS(dev-&gt;parent_bus);<BR>&nbsp;&nbsp;&nbsp; if (bc-&gt;get_dev_path) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return bc-&gt;get_dev_path(dev);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return NULL;<BR>}</P>
<P>/**<BR>&nbsp;* Legacy property handling<BR>&nbsp;*/</P>
<P>static void qdev_get_legacy_property(Object *obj, Visitor *v,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name, void *opaque,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceState *dev = DEVICE(obj);<BR>&nbsp;&nbsp;&nbsp; Property *prop = opaque;</P>
<P>&nbsp;&nbsp;&nbsp; char buffer[1024];<BR>&nbsp;&nbsp;&nbsp; char *ptr = buffer;</P>
<P>&nbsp;&nbsp;&nbsp; prop-&gt;info-&gt;print(dev, prop, buffer, sizeof(buffer));<BR>&nbsp;&nbsp;&nbsp; visit_type_str(v, name, &amp;ptr, errp);<BR>}</P>
<P>/**<BR>&nbsp;* qdev_property_add_legacy:<BR>&nbsp;* @dev: Device to add the property to.<BR>&nbsp;* @prop: The qdev property definition.<BR>&nbsp;* @errp: location to store error information.<BR>&nbsp;*<BR>&nbsp;* Add a legacy QOM property to @dev for qdev property @prop.<BR>&nbsp;* On error, store error in @errp.<BR>&nbsp;*<BR>&nbsp;* Legacy properties are string versions of QOM properties.&nbsp; The format of<BR>&nbsp;* the string depends on the property type.&nbsp; Legacy properties are only<BR>&nbsp;* needed for "info qtree".<BR>&nbsp;*<BR>&nbsp;* Do not use this is new code!&nbsp; QOM Properties added through this interface<BR>&nbsp;* will be given names in the "legacy" namespace.<BR>&nbsp;*/<BR>static void qdev_property_add_legacy(DeviceState *dev, Property *prop,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; gchar *name;</P>
<P>&nbsp;&nbsp;&nbsp; /* Register pointer properties as legacy properties */<BR>&nbsp;&nbsp;&nbsp; if (!prop-&gt;info-&gt;print &amp;&amp; prop-&gt;info-&gt;get) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; name = g_strdup_printf("legacy-%s", prop-&gt;name);<BR>&nbsp;&nbsp;&nbsp; object_property_add(OBJECT(dev), name, "str",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prop-&gt;info-&gt;print ? qdev_get_legacy_property : prop-&gt;info-&gt;get,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prop, errp);</P>
<P>&nbsp;&nbsp;&nbsp; g_free(name);<BR>}</P>
<P>/**<BR>&nbsp;* qdev_property_add_static:<BR>&nbsp;* @dev: Device to add the property to.<BR>&nbsp;* @prop: The qdev property definition.<BR>&nbsp;* @errp: location to store error information.<BR>&nbsp;*<BR>&nbsp;* Add a static QOM property to @dev for qdev property @prop.<BR>&nbsp;* On error, store error in @errp.&nbsp; Static properties access data in a struct.<BR>&nbsp;* The type of the QOM property is derived from prop-&gt;info.<BR>&nbsp;*/<BR>void qdev_property_add_static(DeviceState *dev, Property *prop,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; Error *local_err = NULL;<BR>&nbsp;&nbsp;&nbsp; Object *obj = OBJECT(dev);</P>
<P>&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp; * TODO qdev_prop_ptr does not have getters or setters.&nbsp; It must<BR>&nbsp;&nbsp;&nbsp;&nbsp; * go now that it can be replaced with links.&nbsp; The test should be<BR>&nbsp;&nbsp;&nbsp;&nbsp; * removed along with it: all static properties are read/write.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!prop-&gt;info-&gt;get &amp;&amp; !prop-&gt;info-&gt;set) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; object_property_add(obj, prop-&gt;name, prop-&gt;info-&gt;name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prop-&gt;info-&gt;get, prop-&gt;info-&gt;set,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prop-&gt;info-&gt;release,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prop, &amp;local_err);</P>
<P>&nbsp;&nbsp;&nbsp; if (local_err) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_propagate(errp, local_err);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; object_property_set_description(obj, prop-&gt;name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prop-&gt;info-&gt;description,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);</P>
<P>&nbsp;&nbsp;&nbsp; if (prop-&gt;qtype == QTYPE_NONE) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (prop-&gt;qtype == QTYPE_QBOOL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_set_bool(obj, prop-&gt;defval, prop-&gt;name, &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp; } else if (prop-&gt;info-&gt;enum_table) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_set_str(obj, prop-&gt;info-&gt;enum_table[prop-&gt;defval],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prop-&gt;name, &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp; } else if (prop-&gt;qtype == QTYPE_QINT) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_set_int(obj, prop-&gt;defval, prop-&gt;name, &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* @qdev_alias_all_properties - Add alias properties to the source object for<BR>&nbsp;* all qdev properties on the target DeviceState.<BR>&nbsp;*/<BR>void qdev_alias_all_properties(DeviceState *target, Object *source)<BR>{<BR>&nbsp;&nbsp;&nbsp; ObjectClass *class;<BR>&nbsp;&nbsp;&nbsp; Property *prop;</P>
<P>&nbsp;&nbsp;&nbsp; class = object_get_class(OBJECT(target));<BR>&nbsp;&nbsp;&nbsp; do {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeviceClass *dc = DEVICE_CLASS(class);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (prop = dc-&gt;props; prop &amp;&amp; prop-&gt;name; prop++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_add_alias(source, prop-&gt;name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT(target), prop-&gt;name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class = object_class_get_parent(class);<BR>&nbsp;&nbsp;&nbsp; } while (class != object_class_by_name(TYPE_DEVICE));<BR>}</P>
<P>static int qdev_add_hotpluggable_device(Object *obj, void *opaque)<BR>{<BR>&nbsp;&nbsp;&nbsp; GSList **list = opaque;<BR>&nbsp;&nbsp;&nbsp; DeviceState *dev = (DeviceState *)object_dynamic_cast(OBJECT(obj),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TYPE_DEVICE);</P>
<P>&nbsp;&nbsp;&nbsp; if (dev == NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (dev-&gt;realized &amp;&amp; object_property_get_bool(obj, "hotpluggable", NULL)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *list = g_slist_append(*list, dev);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>GSList *qdev_build_hotpluggable_device_list(Object *peripheral)<BR>{<BR>&nbsp;&nbsp;&nbsp; GSList *list = NULL;</P>
<P>&nbsp;&nbsp;&nbsp; object_child_foreach(peripheral, qdev_add_hotpluggable_device, &amp;list);</P>
<P>&nbsp;&nbsp;&nbsp; return list;<BR>}</P>
<P>static bool device_get_realized(Object *obj, Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceState *dev = DEVICE(obj);<BR>&nbsp;&nbsp;&nbsp; return dev-&gt;realized;<BR>}</P>
<P>static void device_set_realized(Object *obj, bool value, Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceState *dev = DEVICE(obj);<BR>&nbsp;&nbsp;&nbsp; DeviceClass *dc = DEVICE_GET_CLASS(dev);<BR>&nbsp;&nbsp;&nbsp; HotplugHandler *hotplug_ctrl;<BR>&nbsp;&nbsp;&nbsp; BusState *bus;<BR>&nbsp;&nbsp;&nbsp; Error *local_err = NULL;<BR>&nbsp;&nbsp;&nbsp; bool unattached_parent = false;<BR>&nbsp;&nbsp;&nbsp; static int unattached_count;<BR>&nbsp;&nbsp;&nbsp; int ret;</P>
<P>&nbsp;&nbsp;&nbsp; if (dev-&gt;hotplugged &amp;&amp; !dc-&gt;hotpluggable) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_setg(errp, QERR_DEVICE_NO_HOTPLUG, object_get_typename(obj));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (value &amp;&amp; !dev-&gt;realized) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = check_migratable(obj, &amp;local_err);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ret &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto fail;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!obj-&gt;parent) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gchar *name = g_strdup_printf("device[%d]", unattached_count++);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_add_child(container_get(qdev_get_machine(),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "/unattached"),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name, obj, &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unattached_parent = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_free(name);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hotplug_ctrl = qdev_get_hotplug_handler(dev);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hotplug_ctrl) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hotplug_handler_pre_plug(hotplug_ctrl, dev, &amp;local_err);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (local_err != NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto fail;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dc-&gt;realize) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc-&gt;realize(dev, &amp;local_err);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (local_err != NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto fail;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_LISTENER_CALL(realize, Forward, dev);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hotplug_ctrl) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hotplug_handler_plug(hotplug_ctrl, dev, &amp;local_err);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (local_err != NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto post_realize_fail;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (qdev_get_vmsd(dev)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (vmstate_register_with_alias_id(dev, -1, qdev_get_vmsd(dev), dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;instance_id_alias,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;alias_required_for_version,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;local_err) &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto post_realize_fail;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QLIST_FOREACH(bus, &amp;dev-&gt;child_bus, sibling) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_set_bool(OBJECT(bus), true, "realized",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;local_err);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (local_err != NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto child_realize_fail;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dev-&gt;hotplugged) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; device_reset(dev);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;pending_deleted_event = false;<BR>&nbsp;&nbsp;&nbsp; } else if (!value &amp;&amp; dev-&gt;realized) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Error **local_errp = NULL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QLIST_FOREACH(bus, &amp;dev-&gt;child_bus, sibling) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; local_errp = local_err ? NULL : &amp;local_err;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_set_bool(OBJECT(bus), false, "realized",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; local_errp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (qdev_get_vmsd(dev)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vmstate_unregister(dev, qdev_get_vmsd(dev), dev);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dc-&gt;unrealize) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; local_errp = local_err ? NULL : &amp;local_err;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc-&gt;unrealize(dev, local_errp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;pending_deleted_event = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE_LISTENER_CALL(unrealize, Reverse, dev);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (local_err != NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto fail;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; dev-&gt;realized = value;<BR>&nbsp;&nbsp;&nbsp; return;</P>
<P>child_realize_fail:<BR>&nbsp;&nbsp;&nbsp; QLIST_FOREACH(bus, &amp;dev-&gt;child_bus, sibling) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_set_bool(OBJECT(bus), false, "realized",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (qdev_get_vmsd(dev)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vmstate_unregister(dev, qdev_get_vmsd(dev), dev);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>post_realize_fail:<BR>&nbsp;&nbsp;&nbsp; if (dc-&gt;unrealize) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc-&gt;unrealize(dev, NULL);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>fail:<BR>&nbsp;&nbsp;&nbsp; error_propagate(errp, local_err);<BR>&nbsp;&nbsp;&nbsp; if (unattached_parent) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_unparent(OBJECT(dev));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unattached_count--;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static bool device_get_hotpluggable(Object *obj, Error **errp)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceClass *dc = DEVICE_GET_CLASS(obj);<BR>&nbsp;&nbsp;&nbsp; DeviceState *dev = DEVICE(obj);</P>
<P>&nbsp;&nbsp;&nbsp; return dc-&gt;hotpluggable &amp;&amp; (dev-&gt;parent_bus == NULL ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qbus_is_hotpluggable(dev-&gt;parent_bus));<BR>}</P>
<P>static bool device_get_hotplugged(Object *obj, Error **err)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceState *dev = DEVICE(obj);</P>
<P>&nbsp;&nbsp;&nbsp; return dev-&gt;hotplugged;<BR>}</P>
<P>static void device_set_hotplugged(Object *obj, bool value, Error **err)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceState *dev = DEVICE(obj);</P>
<P>&nbsp;&nbsp;&nbsp; dev-&gt;hotplugged = value;<BR>}</P>
<P>static void device_initfn(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceState *dev = DEVICE(obj);<BR>&nbsp;&nbsp;&nbsp; ObjectClass *class;<BR>&nbsp;&nbsp;&nbsp; Property *prop;</P>
<P>&nbsp;&nbsp;&nbsp; if (qdev_hotplug) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;hotplugged = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_hot_added = true;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; dev-&gt;instance_id_alias = -1;<BR>&nbsp;&nbsp;&nbsp; dev-&gt;realized = false;</P>
<P>&nbsp;&nbsp;&nbsp; object_property_add_bool(obj, "realized",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; device_get_realized, device_set_realized, NULL);<BR>&nbsp;&nbsp;&nbsp; object_property_add_bool(obj, "hotpluggable",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; device_get_hotpluggable, NULL, NULL);<BR>&nbsp;&nbsp;&nbsp; object_property_add_bool(obj, "hotplugged",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; device_get_hotplugged, device_set_hotplugged,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);</P>
<P>&nbsp;&nbsp;&nbsp; class = object_get_class(OBJECT(dev));<BR>&nbsp;&nbsp;&nbsp; do {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (prop = DEVICE_CLASS(class)-&gt;props; prop &amp;&amp; prop-&gt;name; prop++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_property_add_legacy(dev, prop, &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_property_add_static(dev, prop, &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class = object_class_get_parent(class);<BR>&nbsp;&nbsp;&nbsp; } while (class != object_class_by_name(TYPE_DEVICE));</P>
<P>&nbsp;&nbsp;&nbsp; object_property_add_link(OBJECT(dev), "parent_bus", TYPE_BUS,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Object **)&amp;dev-&gt;parent_bus, NULL, 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp; QLIST_INIT(&amp;dev-&gt;gpios);<BR>}</P>
<P>static void device_post_init(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; qdev_prop_set_globals(DEVICE(obj));<BR>}</P>
<P>/* Unlink device from bus and free the structure.&nbsp; */<BR>static void device_finalize(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; NamedGPIOList *ngl, *next;</P>
<P>&nbsp;&nbsp;&nbsp; DeviceState *dev = DEVICE(obj);</P>
<P>&nbsp;&nbsp;&nbsp; QLIST_FOREACH_SAFE(ngl, &amp;dev-&gt;gpios, node, next) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QLIST_REMOVE(ngl, node);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_free_irqs(ngl-&gt;in, ngl-&gt;num_in);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_free(ngl-&gt;name);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_free(ngl);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ngl-&gt;out irqs are owned by the other end and should not be freed<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * here<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void device_class_base_init(ObjectClass *class, void *data)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceClass *klass = DEVICE_CLASS(class);</P>
<P>&nbsp;&nbsp;&nbsp; /* We explicitly look up properties in the superclasses,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * so do not propagate them to the subclasses.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; klass-&gt;props = NULL;<BR>}</P>
<P>static void device_unparent(Object *obj)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceState *dev = DEVICE(obj);<BR>&nbsp;&nbsp;&nbsp; BusState *bus;</P>
<P>&nbsp;&nbsp;&nbsp; if (dev-&gt;realized) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_property_set_bool(obj, false, "realized", NULL);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; while (dev-&gt;num_child_bus) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bus = QLIST_FIRST(&amp;dev-&gt;child_bus);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_unparent(OBJECT(bus));<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (dev-&gt;parent_bus) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bus_remove_child(dev-&gt;parent_bus, dev);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object_unref(OBJECT(dev-&gt;parent_bus));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;parent_bus = NULL;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Only send event if the device had been completely realized */<BR>&nbsp;&nbsp;&nbsp; if (dev-&gt;pending_deleted_event) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gchar *path = object_get_canonical_path(OBJECT(dev));</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qapi_event_send_device_deleted(!!dev-&gt;id, dev-&gt;id, path, &amp;error_abort);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_free(path);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; qemu_opts_del(dev-&gt;opts);<BR>&nbsp;&nbsp;&nbsp; dev-&gt;opts = NULL;<BR>}</P>
<P>static void device_class_init(ObjectClass *class, void *data)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceClass *dc = DEVICE_CLASS(class);</P>
<P>&nbsp;&nbsp;&nbsp; class-&gt;unparent = device_unparent;<BR>&nbsp;&nbsp;&nbsp; dc-&gt;realize = device_realize;<BR>&nbsp;&nbsp;&nbsp; dc-&gt;unrealize = device_unrealize;</P>
<P>&nbsp;&nbsp;&nbsp; /* by default all devices were considered as hotpluggable,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * so with intent to check it in generic qdev_unplug() /<BR>&nbsp;&nbsp;&nbsp;&nbsp; * device_set_realized() functions make every device<BR>&nbsp;&nbsp;&nbsp;&nbsp; * hotpluggable. Devices that shouldn't be hotpluggable,<BR>&nbsp;&nbsp;&nbsp;&nbsp; * should override it in their class_init()<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; dc-&gt;hotpluggable = true;<BR>}</P>
<P>void device_reset(DeviceState *dev)<BR>{<BR>&nbsp;&nbsp;&nbsp; DeviceClass *klass = DEVICE_GET_CLASS(dev);</P>
<P>&nbsp;&nbsp;&nbsp; if (klass-&gt;reset) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; klass-&gt;reset(dev);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>Object *qdev_get_machine(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; static Object *dev;</P>
<P>&nbsp;&nbsp;&nbsp; if (dev == NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev = container_get(object_get_root(), "/machine");<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return dev;<BR>}</P>
<P>static const TypeInfo device_type_info = {<BR>&nbsp;&nbsp;&nbsp; .name = TYPE_DEVICE,<BR>&nbsp;&nbsp;&nbsp; .parent = TYPE_OBJECT,<BR>&nbsp;&nbsp;&nbsp; .instance_size = sizeof(DeviceState),<BR>&nbsp;&nbsp;&nbsp; .instance_init = device_initfn,<BR>&nbsp;&nbsp;&nbsp; .instance_post_init = device_post_init,<BR>&nbsp;&nbsp;&nbsp; .instance_finalize = device_finalize,<BR>&nbsp;&nbsp;&nbsp; .class_base_init = device_class_base_init,<BR>&nbsp;&nbsp;&nbsp; .class_init = device_class_init,<BR>&nbsp;&nbsp;&nbsp; .abstract = true,<BR>&nbsp;&nbsp;&nbsp; .class_size = sizeof(DeviceClass),<BR>};</P>
<P>static void qdev_register_types(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; type_register_static(&amp;device_type_info);<BR>}</P>
<P>type_init(qdev_register_types)