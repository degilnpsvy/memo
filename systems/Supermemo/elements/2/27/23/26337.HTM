# qemu:include/hw/qdev-core.h 
<P></P>
<P>&nbsp;</P>
<P>#ifndef QDEV_CORE_H<BR>#define QDEV_CORE_H</P>
<P></P>
<P>#include "qemu/queue.h"<BR>#include "qemu/option.h"<BR>#include "qemu/bitmap.h"<BR>#include "qom/object.h"<BR>#include "hw/irq.h"<BR>#include "hw/hotplug.h"</P>
<P>enum {<BR>&nbsp;&nbsp;&nbsp; DEV_NVECTORS_UNSPECIFIED = -1,<BR>};</P>
<P>#define TYPE_DEVICE "device"<BR>#define DEVICE(obj) OBJECT_CHECK(DeviceState, (obj), TYPE_DEVICE)<BR>#define DEVICE_CLASS(klass) OBJECT_CLASS_CHECK(DeviceClass, (klass), TYPE_DEVICE)<BR>#define DEVICE_GET_CLASS(obj) OBJECT_GET_CLASS(DeviceClass, (obj), TYPE_DEVICE)</P>
<P>typedef enum DeviceCategory {<BR>&nbsp;&nbsp;&nbsp; DEVICE_CATEGORY_BRIDGE,<BR>&nbsp;&nbsp;&nbsp; DEVICE_CATEGORY_USB,<BR>&nbsp;&nbsp;&nbsp; DEVICE_CATEGORY_STORAGE,<BR>&nbsp;&nbsp;&nbsp; DEVICE_CATEGORY_NETWORK,<BR>&nbsp;&nbsp;&nbsp; DEVICE_CATEGORY_INPUT,<BR>&nbsp;&nbsp;&nbsp; DEVICE_CATEGORY_DISPLAY,<BR>&nbsp;&nbsp;&nbsp; DEVICE_CATEGORY_SOUND,<BR>&nbsp;&nbsp;&nbsp; DEVICE_CATEGORY_MISC,<BR>&nbsp;&nbsp;&nbsp; DEVICE_CATEGORY_CPU,<BR>&nbsp;&nbsp;&nbsp; DEVICE_CATEGORY_MAX<BR>} DeviceCategory;</P>
<P>typedef int (*qdev_initfn)(DeviceState *dev);<BR>typedef int (*qdev_event)(DeviceState *dev);<BR>typedef void (*qdev_resetfn)(DeviceState *dev);<BR>typedef void (*DeviceRealize)(DeviceState *dev, Error **errp);<BR>typedef void (*DeviceUnrealize)(DeviceState *dev, Error **errp);<BR>typedef void (*BusRealize)(BusState *bus, Error **errp);<BR>typedef void (*BusUnrealize)(BusState *bus, Error **errp);</P>
<P>struct VMStateDescription;</P>
<P>/**<BR>&nbsp;* DeviceClass:<BR>&nbsp;* @props: Properties accessing state fields.<BR>&nbsp;* @realize: Callback function invoked when the #DeviceState:realized<BR>&nbsp;* property is changed to %true. The default invokes @init if not %NULL.<BR>&nbsp;* @unrealize: Callback function invoked when the #DeviceState:realized<BR>&nbsp;* property is changed to %false.<BR>&nbsp;* @init: Callback function invoked when the #DeviceState::realized property<BR>&nbsp;* is changed to %true. Deprecated, new types inheriting directly from<BR>&nbsp;* TYPE_DEVICE should use @realize instead, new leaf types should consult<BR>&nbsp;* their respective parent type.<BR>&nbsp;* @hotpluggable: indicates if #DeviceClass is hotpluggable, available<BR>&nbsp;* as readonly "hotpluggable" property of #DeviceState instance<BR>&nbsp;*<BR>&nbsp;* # Realization #<BR>&nbsp;* Devices are constructed in two stages,<BR>&nbsp;* 1) object instantiation via object_initialize() and<BR>&nbsp;* 2) device realization via #DeviceState:realized property.<BR>&nbsp;* The former may not fail (it might assert or exit), the latter may return<BR>&nbsp;* error information to the caller and must be re-entrant.<BR>&nbsp;* Trivial field initializations should go into #TypeInfo.instance_init.<BR>&nbsp;* Operations depending on @props static properties should go into @realize.<BR>&nbsp;* After successful realization, setting static properties will fail.<BR>&nbsp;*<BR>&nbsp;* As an interim step, the #DeviceState:realized property can also be<BR>&nbsp;* set with qdev_init_nofail().<BR>&nbsp;* In the future, devices will propagate this state change to their children<BR>&nbsp;* and along busses they expose.<BR>&nbsp;* The point in time will be deferred to machine creation, so that values<BR>&nbsp;* set in @realize will not be introspectable beforehand. Therefore devices<BR>&nbsp;* must not create children during @realize; they should initialize them via<BR>&nbsp;* object_initialize() in their own #TypeInfo.instance_init and forward the<BR>&nbsp;* realization events appropriately.<BR>&nbsp;*<BR>&nbsp;* The @init callback is considered private to a particular bus implementation<BR>&nbsp;* (immediate abstract child types of TYPE_DEVICE). Derived leaf types set an<BR>&nbsp;* "init" callback on their parent class instead.<BR>&nbsp;*<BR>&nbsp;* Any type may override the @realize and/or @unrealize callbacks but needs<BR>&nbsp;* to call the parent type's implementation if keeping their functionality<BR>&nbsp;* is desired. Refer to QOM documentation for further discussion and examples.<BR>&nbsp;*<BR>&nbsp;* &lt;note&gt;<BR>&nbsp;*&nbsp;&nbsp; &lt;para&gt;<BR>&nbsp;* If a type derived directly from TYPE_DEVICE implements @realize, it does<BR>&nbsp;* not need to implement @init and therefore does not need to store and call<BR>&nbsp;* #DeviceClass' default @realize callback.<BR>&nbsp;* For other types consult the documentation and implementation of the<BR>&nbsp;* respective parent types.<BR>&nbsp;*&nbsp;&nbsp; &lt;/para&gt;<BR>&nbsp;* &lt;/note&gt;<BR>&nbsp;*/<BR>typedef struct DeviceClass {<BR>&nbsp;&nbsp;&nbsp; /*&lt; private &gt;*/<BR>&nbsp;&nbsp;&nbsp; ObjectClass parent_class;<BR>&nbsp;&nbsp;&nbsp; /*&lt; public &gt;*/</P>
<P>&nbsp;&nbsp;&nbsp; DECLARE_BITMAP(categories, DEVICE_CATEGORY_MAX);<BR>&nbsp;&nbsp;&nbsp; const char *fw_name;<BR>&nbsp;&nbsp;&nbsp; const char *desc;<BR>&nbsp;&nbsp;&nbsp; Property *props;</P>
<P>&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Shall we hide this device model from -device / device_add?<BR>&nbsp;&nbsp;&nbsp;&nbsp; * All devices should support instantiation with device_add, and<BR>&nbsp;&nbsp;&nbsp;&nbsp; * this flag should not exist.&nbsp; But we're not there, yet.&nbsp; Some<BR>&nbsp;&nbsp;&nbsp;&nbsp; * devices fail to instantiate with cryptic error messages.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Others instantiate, but don't work.&nbsp; Exposing users to such<BR>&nbsp;&nbsp;&nbsp;&nbsp; * behavior would be cruel; this flag serves to protect them.&nbsp; It<BR>&nbsp;&nbsp;&nbsp;&nbsp; * should never be set without a comment explaining why it is set.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * TODO remove once we're there<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; bool cannot_instantiate_with_device_add_yet;<BR>&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp; * Does this device model survive object_unref(object_new(TNAME))?<BR>&nbsp;&nbsp;&nbsp;&nbsp; * All device models should, and this flag shouldn't exist.&nbsp; Some<BR>&nbsp;&nbsp;&nbsp;&nbsp; * devices crash in object_new(), some crash or hang in<BR>&nbsp;&nbsp;&nbsp;&nbsp; * object_unref().&nbsp; Makes introspecting properties with<BR>&nbsp;&nbsp;&nbsp;&nbsp; * qmp_device_list_properties() dangerous.&nbsp; Bad, because it's used<BR>&nbsp;&nbsp;&nbsp;&nbsp; * by -device FOO,help.&nbsp; This flag serves to protect that code.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * It should never be set without a comment explaining why it is<BR>&nbsp;&nbsp;&nbsp;&nbsp; * set.<BR>&nbsp;&nbsp;&nbsp;&nbsp; * TODO remove once we're there<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; bool cannot_destroy_with_object_finalize_yet;</P>
<P>&nbsp;&nbsp;&nbsp; bool hotpluggable;</P>
<P>&nbsp;&nbsp;&nbsp; /* callbacks */<BR>&nbsp;&nbsp;&nbsp; void (*reset)(DeviceState *dev);<BR>&nbsp;&nbsp;&nbsp; DeviceRealize realize;<BR>&nbsp;&nbsp;&nbsp; DeviceUnrealize unrealize;</P>
<P>&nbsp;&nbsp;&nbsp; /* device state */<BR>&nbsp;&nbsp;&nbsp; const struct VMStateDescription *vmsd;</P>
<P>&nbsp;&nbsp;&nbsp; /* Private to qdev / bus.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; qdev_initfn init; /* TODO remove, once users are converted to realize */<BR>&nbsp;&nbsp;&nbsp; qdev_event exit; /* TODO remove, once users are converted to unrealize */<BR>&nbsp;&nbsp;&nbsp; const char *bus_type;<BR>} DeviceClass;</P>
<P>typedef struct NamedGPIOList NamedGPIOList;</P>
<P>struct NamedGPIOList {<BR>&nbsp;&nbsp;&nbsp; char *name;<BR>&nbsp;&nbsp;&nbsp; qemu_irq *in;<BR>&nbsp;&nbsp;&nbsp; int num_in;<BR>&nbsp;&nbsp;&nbsp; int num_out;<BR>&nbsp;&nbsp;&nbsp; QLIST_ENTRY(NamedGPIOList) node;<BR>};</P>
<P><FONT class=extract>/**<BR>&nbsp;* DeviceState:<BR>&nbsp;* @realized: Indicates whether the device has been fully constructed.<BR>&nbsp;*<BR>&nbsp;* This structure should not be accessed directly.&nbsp; We declare it here<BR>&nbsp;* so that it can be embedded in individual device state structures.<BR>&nbsp;*/<BR>struct DeviceState {<BR>&nbsp;&nbsp;&nbsp; /*&lt; private &gt;*/<BR>&nbsp;&nbsp;&nbsp; Object parent_obj;<BR>&nbsp;&nbsp;&nbsp; /*&lt; public &gt;*/</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; const char *id;<BR>&nbsp;&nbsp;&nbsp; bool realized;<BR>&nbsp;&nbsp;&nbsp; bool pending_deleted_event;<BR>&nbsp;&nbsp;&nbsp; QemuOpts *opts;<BR>&nbsp;&nbsp;&nbsp; int hotplugged;<BR>&nbsp;&nbsp;&nbsp; BusState *parent_bus;<BR>&nbsp;&nbsp;&nbsp; QLIST_HEAD(, NamedGPIOList) gpios;<BR>&nbsp;&nbsp;&nbsp; QLIST_HEAD(, BusState) child_bus;<BR>&nbsp;&nbsp;&nbsp; int num_child_bus;<BR>&nbsp;&nbsp;&nbsp; int instance_id_alias;<BR>&nbsp;&nbsp;&nbsp; int alias_required_for_version;<BR>};</FONT></P>
<P>struct DeviceListener {<BR>&nbsp;&nbsp;&nbsp; void (*realize)(DeviceListener *listener, DeviceState *dev);<BR>&nbsp;&nbsp;&nbsp; void (*unrealize)(DeviceListener *listener, DeviceState *dev);<BR>&nbsp;&nbsp;&nbsp; QTAILQ_ENTRY(DeviceListener) link;<BR>};</P>
<P>#define TYPE_BUS "bus"<BR>#define BUS(obj) OBJECT_CHECK(BusState, (obj), TYPE_BUS)<BR>#define BUS_CLASS(klass) OBJECT_CLASS_CHECK(BusClass, (klass), TYPE_BUS)<BR>#define BUS_GET_CLASS(obj) OBJECT_GET_CLASS(BusClass, (obj), TYPE_BUS)</P>
<P>struct BusClass {<BR>&nbsp;&nbsp;&nbsp; ObjectClass parent_class;</P>
<P>&nbsp;&nbsp;&nbsp; /* FIXME first arg should be BusState */<BR>&nbsp;&nbsp;&nbsp; void (*print_dev)(Monitor *mon, DeviceState *dev, int indent);<BR>&nbsp;&nbsp;&nbsp; char *(*get_dev_path)(DeviceState *dev);<BR>&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp; * This callback is used to create Open Firmware device path in accordance<BR>&nbsp;&nbsp;&nbsp;&nbsp; * with OF spec <A href="http://forthworks.com/standards/of1275.pdf">http://forthworks.com/standards/of1275.pdf</A>. Individual bus<BR>&nbsp;&nbsp;&nbsp;&nbsp; * bindings can be found at <A href="http://playground.sun.com/1275/bindings/">http://playground.sun.com/1275/bindings/</A>.<BR>&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; char *(*get_fw_dev_path)(DeviceState *dev);<BR>&nbsp;&nbsp;&nbsp; void (*reset)(BusState *bus);<BR>&nbsp;&nbsp;&nbsp; BusRealize realize;<BR>&nbsp;&nbsp;&nbsp; BusUnrealize unrealize;</P>
<P>&nbsp;&nbsp;&nbsp; /* maximum devices allowed on the bus, 0: no limit. */<BR>&nbsp;&nbsp;&nbsp; int max_dev;<BR>&nbsp;&nbsp;&nbsp; /* number of automatically allocated bus ids (e.g. ide.0) */<BR>&nbsp;&nbsp;&nbsp; int automatic_ids;<BR>};</P>
<P>typedef struct BusChild {<BR>&nbsp;&nbsp;&nbsp; DeviceState *child;<BR>&nbsp;&nbsp;&nbsp; int index;<BR>&nbsp;&nbsp;&nbsp; QTAILQ_ENTRY(BusChild) sibling;<BR>} BusChild;</P>
<P>#define QDEV_HOTPLUG_HANDLER_PROPERTY "hotplug-handler"</P>
<P><FONT class=extract>/**<BR>&nbsp;* BusState:<BR>&nbsp;* @hotplug_device: link to a hotplug device associated with bus.<BR>&nbsp;*/<BR>struct BusState {<BR>&nbsp;&nbsp;&nbsp; Object obj;<BR>&nbsp;&nbsp;&nbsp; DeviceState *parent;<BR>&nbsp;&nbsp;&nbsp; char *name;<BR>&nbsp;&nbsp;&nbsp; HotplugHandler *hotplug_handler;<BR>&nbsp;&nbsp;&nbsp; int max_index;<BR>&nbsp;&nbsp;&nbsp; bool realized;<BR>&nbsp;&nbsp;&nbsp; QTAILQ_HEAD(ChildrenHead, BusChild) children;<BR>&nbsp;&nbsp;&nbsp; QLIST_ENTRY(BusState) sibling;<BR>};</FONT></P>
<P>struct Property {<BR>&nbsp;&nbsp;&nbsp; const char&nbsp;&nbsp; *name;<BR>&nbsp;&nbsp;&nbsp; PropertyInfo *info;<BR>&nbsp;&nbsp;&nbsp; ptrdiff_t&nbsp;&nbsp;&nbsp; offset;<BR>&nbsp;&nbsp;&nbsp; uint8_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bitnr;<BR>&nbsp;&nbsp;&nbsp; QType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qtype;<BR>&nbsp;&nbsp;&nbsp; int64_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defval;<BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arrayoffset;<BR>&nbsp;&nbsp;&nbsp; PropertyInfo *arrayinfo;<BR>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arrayfieldsize;<BR>};</P>
<P>struct PropertyInfo {<BR>&nbsp;&nbsp;&nbsp; const char *name;<BR>&nbsp;&nbsp;&nbsp; const char *description;<BR>&nbsp;&nbsp;&nbsp; const char * const *enum_table;<BR>&nbsp;&nbsp;&nbsp; int (*print)(DeviceState *dev, Property *prop, char *dest, size_t len);<BR>&nbsp;&nbsp;&nbsp; ObjectPropertyAccessor *get;<BR>&nbsp;&nbsp;&nbsp; ObjectPropertyAccessor *set;<BR>&nbsp;&nbsp;&nbsp; ObjectPropertyRelease *release;<BR>};</P>
<P>/**<BR>&nbsp;* GlobalProperty:<BR>&nbsp;* @user_provided: Set to true if property comes from user-provided config<BR>&nbsp;* (command-line or config file).<BR>&nbsp;* @used: Set to true if property was used when initializing a device.<BR>&nbsp;* @errp: Error destination, used like first argument of error_setg()<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in case property setting fails later. If @errp is NULL, we<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print warnings instead of ignoring errors silently. For<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hotplugged devices, errp is always ignored and warnings are<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printed instead.<BR>&nbsp;*/<BR>typedef struct GlobalProperty {<BR>&nbsp;&nbsp;&nbsp; const char *driver;<BR>&nbsp;&nbsp;&nbsp; const char *property;<BR>&nbsp;&nbsp;&nbsp; const char *value;<BR>&nbsp;&nbsp;&nbsp; bool user_provided;<BR>&nbsp;&nbsp;&nbsp; bool used;<BR>&nbsp;&nbsp;&nbsp; Error **errp;<BR>} GlobalProperty;</P>
<P>/*** Board API.&nbsp; This should go away once we have a machine config file.&nbsp; ***/</P>
<P>DeviceState *qdev_create(BusState *bus, const char *name);<BR>DeviceState *qdev_try_create(BusState *bus, const char *name);<BR>void qdev_init_nofail(DeviceState *dev);<BR>void qdev_set_legacy_instance_id(DeviceState *dev, int alias_id,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int required_for_version);<BR>HotplugHandler *qdev_get_hotplug_handler(DeviceState *dev);<BR>void qdev_unplug(DeviceState *dev, Error **errp);<BR>void qdev_simple_device_unplug_cb(HotplugHandler *hotplug_dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeviceState *dev, Error **errp);<BR>void qdev_machine_creation_done(void);<BR>bool qdev_machine_modified(void);</P>
<P>qemu_irq qdev_get_gpio_in(DeviceState *dev, int n);<BR>qemu_irq qdev_get_gpio_in_named(DeviceState *dev, const char *name, int n);</P>
<P>void qdev_connect_gpio_out(DeviceState *dev, int n, qemu_irq pin);<BR>void qdev_connect_gpio_out_named(DeviceState *dev, const char *name, int n,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_irq pin);<BR>qemu_irq qdev_get_gpio_out_connector(DeviceState *dev, const char *name, int n);<BR>qemu_irq qdev_intercept_gpio_out(DeviceState *dev, qemu_irq icpt,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name, int n);</P>
<P>BusState *qdev_get_child_bus(DeviceState *dev, const char *name);</P>
<P>/*** Device API.&nbsp; ***/</P>
<P>/* Register device properties.&nbsp; */<BR>/* GPIO inputs also double as IRQ sinks.&nbsp; */<BR>void qdev_init_gpio_in(DeviceState *dev, qemu_irq_handler handler, int n);<BR>void qdev_init_gpio_out(DeviceState *dev, qemu_irq *pins, int n);<BR>void qdev_init_gpio_in_named(DeviceState *dev, qemu_irq_handler handler,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name, int n);<BR>void qdev_init_gpio_out_named(DeviceState *dev, qemu_irq *pins,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name, int n);</P>
<P>void qdev_pass_gpios(DeviceState *dev, DeviceState *container,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name);</P>
<P>BusState *qdev_get_parent_bus(DeviceState *dev);</P>
<P>/*** BUS API. ***/</P>
<P>DeviceState *qdev_find_recursive(BusState *bus, const char *id);</P>
<P>/* Returns 0 to walk children, &gt; 0 to skip walk, &lt; 0 to terminate walk. */<BR>typedef int (qbus_walkerfn)(BusState *bus, void *opaque);<BR>typedef int (qdev_walkerfn)(DeviceState *dev, void *opaque);</P>
<P>void qbus_create_inplace(void *bus, size_t size, const char *typename,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeviceState *parent, const char *name);<BR>BusState *qbus_create(const char *typename, DeviceState *parent, const char *name);<BR>/* Returns &gt; 0 if either devfn or busfn skip walk somewhere in cursion,<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; 0 if either devfn or busfn terminate walk somewhere in cursion,<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 otherwise. */<BR>int qbus_walk_children(BusState *bus,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_walkerfn *pre_devfn, qbus_walkerfn *pre_busfn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_walkerfn *post_devfn, qbus_walkerfn *post_busfn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *opaque);<BR>int qdev_walk_children(DeviceState *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_walkerfn *pre_devfn, qbus_walkerfn *pre_busfn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qdev_walkerfn *post_devfn, qbus_walkerfn *post_busfn,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *opaque);</P>
<P>void qdev_reset_all(DeviceState *dev);<BR>void qdev_reset_all_fn(void *opaque);</P>
<P>/**<BR>&nbsp;* @qbus_reset_all:<BR>&nbsp;* @bus: Bus to be reset.<BR>&nbsp;*<BR>&nbsp;* Reset @bus and perform a bus-level ("hard") reset of all devices connected<BR>&nbsp;* to it, including recursive processing of all buses below @bus itself.&nbsp; A<BR>&nbsp;* hard reset means that qbus_reset_all will reset all state of the device.<BR>&nbsp;* For PCI devices, for example, this will include the base address registers<BR>&nbsp;* or configuration space.<BR>&nbsp;*/<BR>void qbus_reset_all(BusState *bus);<BR>void qbus_reset_all_fn(void *opaque);</P>
<P>/* This should go away once we get rid of the NULL bus hack */<BR>BusState *sysbus_get_default(void);</P>
<P>char *qdev_get_fw_dev_path(DeviceState *dev);<BR>char *qdev_get_own_fw_dev_path_from_handler(BusState *bus, DeviceState *dev);</P>
<P>/**<BR>&nbsp;* @qdev_machine_init<BR>&nbsp;*<BR>&nbsp;* Initialize platform devices before machine init.&nbsp; This is a hack until full<BR>&nbsp;* support for composition is added.<BR>&nbsp;*/<BR>void qdev_machine_init(void);</P>
<P>/**<BR>&nbsp;* @device_reset<BR>&nbsp;*<BR>&nbsp;* Reset a single device (by calling the reset method).<BR>&nbsp;*/<BR>void device_reset(DeviceState *dev);</P>
<P>const struct VMStateDescription *qdev_get_vmsd(DeviceState *dev);</P>
<P>const char *qdev_fw_name(DeviceState *dev);</P>
<P>Object *qdev_get_machine(void);</P>
<P>/* FIXME: make this a link&lt;&gt; */<BR>void qdev_set_parent_bus(DeviceState *dev, BusState *bus);</P>
<P>extern int qdev_hotplug;</P>
<P>char *qdev_get_dev_path(DeviceState *dev);</P>
<P>GSList *qdev_build_hotpluggable_device_list(Object *peripheral);</P>
<P>void qbus_set_hotplug_handler(BusState *bus, DeviceState *handler,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Error **errp);</P>
<P>void qbus_set_bus_hotplug_handler(BusState *bus, Error **errp);</P>
<P>static inline bool qbus_is_hotpluggable(BusState *bus)<BR>{<BR>&nbsp;&nbsp; return bus-&gt;hotplug_handler;<BR>}</P>
<P>void device_listener_register(DeviceListener *listener);<BR>void device_listener_unregister(DeviceListener *listener);</P>
<P>#endif