/**<BR>&nbsp;* <FONT class=extract>struct irq_desc - interrupt descriptor</FONT><BR>&nbsp;* @irq_common_data:&nbsp;per irq and chip data passed down to chip functions<BR>&nbsp;* @kstat_irqs:&nbsp;&nbsp;irq stats per cpu<BR>&nbsp;* @handle_irq:&nbsp;&nbsp;highlevel irq-events handler<BR>&nbsp;* @preflow_handler:&nbsp;handler called before the flow handler (currently used by sparc)<BR>&nbsp;* @action:&nbsp;&nbsp;the irq action chain<BR>&nbsp;* @status:&nbsp;&nbsp;status information<BR>&nbsp;* @core_internal_state__do_not_mess_with_it: core internal status information<BR>&nbsp;* @depth:&nbsp;&nbsp;disable-depth, for nested irq_disable() calls<BR>&nbsp;* @wake_depth:&nbsp;&nbsp;enable depth, for multiple irq_set_irq_wake() callers<BR>&nbsp;* @irq_count:&nbsp;&nbsp;stats field to detect stalled irqs<BR>&nbsp;* @last_unhandled:&nbsp;aging timer for unhandled count<BR>&nbsp;* @irqs_unhandled:&nbsp;stats field for spurious unhandled interrupts<BR>&nbsp;* @threads_handled:&nbsp;stats field for deferred spurious detection of threaded handlers<BR>&nbsp;* @threads_handled_last: comparator field for deferred spurious detection of theraded handlers<BR>&nbsp;* @lock:&nbsp;&nbsp;locking for SMP<BR>&nbsp;* @affinity_hint:&nbsp;hint to user space for preferred irq affinity<BR>&nbsp;* @affinity_notify:&nbsp;context for notification of affinity changes<BR>&nbsp;* @pending_mask:&nbsp;pending rebalanced interrupts<BR>&nbsp;* @threads_oneshot:&nbsp;bitfield to handle shared oneshot threads<BR>&nbsp;* @threads_active:&nbsp;number of irqaction threads currently running<BR>&nbsp;* @wait_for_threads:&nbsp;wait queue for sync_irq to wait for threaded handlers<BR>&nbsp;* @nr_actions:&nbsp;&nbsp;number of installed actions on this descriptor<BR>&nbsp;* @no_suspend_depth:&nbsp;number of irqactions on a irq descriptor with<BR>&nbsp;*&nbsp;&nbsp;&nbsp;IRQF_NO_SUSPEND set<BR>&nbsp;* @force_resume_depth:&nbsp;number of irqactions on a irq descriptor with<BR>&nbsp;*&nbsp;&nbsp;&nbsp;IRQF_FORCE_RESUME set<BR>&nbsp;* @dir:&nbsp;&nbsp;/proc/irq/ procfs entry<BR>&nbsp;* @name:&nbsp;&nbsp;flow handler name for /proc/interrupts output<BR>&nbsp;*/<BR>struct irq_desc {<BR>&nbsp;struct irq_common_data&nbsp;irq_common_data;<BR>&nbsp;struct irq_data&nbsp;&nbsp;irq_data;<BR>&nbsp;unsigned int __percpu&nbsp;*kstat_irqs;<BR>&nbsp;irq_flow_handler_t&nbsp;handle_irq;<BR>#ifdef CONFIG_IRQ_PREFLOW_FASTEOI<BR>&nbsp;irq_preflow_handler_t&nbsp;preflow_handler;<BR>#endif<BR>&nbsp;struct irqaction&nbsp;*action;&nbsp;/* IRQ action list */<BR>&nbsp;unsigned int&nbsp;&nbsp;status_use_accessors;<BR>&nbsp;unsigned int&nbsp;&nbsp;core_internal_state__do_not_mess_with_it;<BR>&nbsp;unsigned int&nbsp;&nbsp;depth;&nbsp;&nbsp;/* nested irq disables */<BR>&nbsp;unsigned int&nbsp;&nbsp;wake_depth;&nbsp;/* nested wake enables */<BR>&nbsp;unsigned int&nbsp;&nbsp;irq_count;&nbsp;/* For detecting broken IRQs */<BR>&nbsp;unsigned long&nbsp;&nbsp;last_unhandled;&nbsp;/* Aging timer for unhandled count */<BR>&nbsp;unsigned int&nbsp;&nbsp;irqs_unhandled;<BR>&nbsp;atomic_t&nbsp;&nbsp;threads_handled;<BR>&nbsp;int&nbsp;&nbsp;&nbsp;threads_handled_last;<BR>&nbsp;raw_spinlock_t&nbsp;&nbsp;lock;<BR>&nbsp;struct cpumask&nbsp;&nbsp;*percpu_enabled;<BR>#ifdef CONFIG_SMP<BR>&nbsp;const struct cpumask&nbsp;*affinity_hint;<BR>&nbsp;struct irq_affinity_notify *affinity_notify;<BR>#ifdef CONFIG_GENERIC_PENDING_IRQ<BR>&nbsp;cpumask_var_t&nbsp;&nbsp;pending_mask;<BR>#endif<BR>#endif<BR>&nbsp;unsigned long&nbsp;&nbsp;threads_oneshot;<BR>&nbsp;atomic_t&nbsp;&nbsp;threads_active;<BR>&nbsp;wait_queue_head_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wait_for_threads;<BR>#ifdef CONFIG_PM_SLEEP<BR>&nbsp;unsigned int&nbsp;&nbsp;nr_actions;<BR>&nbsp;unsigned int&nbsp;&nbsp;no_suspend_depth;<BR>&nbsp;unsigned int&nbsp;&nbsp;cond_suspend_depth;<BR>&nbsp;unsigned int&nbsp;&nbsp;force_resume_depth;<BR>#endif<BR>#ifdef CONFIG_PROC_FS<BR>&nbsp;struct proc_dir_entry&nbsp;*dir;<BR>#endif<BR>&nbsp;int&nbsp;&nbsp;&nbsp;parent_irq;<BR>&nbsp;struct module&nbsp;&nbsp;*owner;<BR>&nbsp;const char&nbsp;&nbsp;*name;<BR>} ____cacheline_internodealigned_in_smp;