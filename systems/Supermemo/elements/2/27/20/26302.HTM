#include/linux/irqdesc.h 
<P></P>
<P>#ifndef _LINUX_IRQDESC_H<BR>#define _LINUX_IRQDESC_H</P>
<P></P>
<P>/*<BR>&nbsp;* Core internal functions to deal with irq descriptors<BR>&nbsp;*/</P>
<P>struct irq_affinity_notify;<BR>struct proc_dir_entry;<BR>struct module;<BR>struct irq_desc;<BR>struct irq_domain;<BR>struct pt_regs;</P>
<P><FONT class=extract>/**<BR>&nbsp;* <FONT class=extract>struct irq_desc - interrupt descriptor</FONT><BR>&nbsp;* @irq_common_data:&nbsp;per irq and chip data passed down to chip functions<BR>&nbsp;* @kstat_irqs:&nbsp;&nbsp;irq stats per cpu<BR>&nbsp;* @handle_irq:&nbsp;&nbsp;highlevel irq-events handler<BR>&nbsp;* @preflow_handler:&nbsp;handler called before the flow handler (currently used by sparc)<BR>&nbsp;* @action:&nbsp;&nbsp;the irq action chain<BR>&nbsp;* @status:&nbsp;&nbsp;status information<BR>&nbsp;* @core_internal_state__do_not_mess_with_it: core internal status information<BR>&nbsp;* @depth:&nbsp;&nbsp;disable-depth, for nested irq_disable() calls<BR>&nbsp;* @wake_depth:&nbsp;&nbsp;enable depth, for multiple irq_set_irq_wake() callers<BR>&nbsp;* @irq_count:&nbsp;&nbsp;stats field to detect stalled irqs<BR>&nbsp;* @last_unhandled:&nbsp;aging timer for unhandled count<BR>&nbsp;* @irqs_unhandled:&nbsp;stats field for spurious unhandled interrupts<BR>&nbsp;* @threads_handled:&nbsp;stats field for deferred spurious detection of threaded handlers<BR>&nbsp;* @threads_handled_last: comparator field for deferred spurious detection of theraded handlers<BR>&nbsp;* @lock:&nbsp;&nbsp;locking for SMP<BR>&nbsp;* @affinity_hint:&nbsp;hint to user space for preferred irq affinity<BR>&nbsp;* @affinity_notify:&nbsp;context for notification of affinity changes<BR>&nbsp;* @pending_mask:&nbsp;pending rebalanced interrupts<BR>&nbsp;* @threads_oneshot:&nbsp;bitfield to handle shared oneshot threads<BR>&nbsp;* @threads_active:&nbsp;number of irqaction threads currently running<BR>&nbsp;* @wait_for_threads:&nbsp;wait queue for sync_irq to wait for threaded handlers<BR>&nbsp;* @nr_actions:&nbsp;&nbsp;number of installed actions on this descriptor<BR>&nbsp;* @no_suspend_depth:&nbsp;number of irqactions on a irq descriptor with<BR>&nbsp;*&nbsp;&nbsp;&nbsp;IRQF_NO_SUSPEND set<BR>&nbsp;* @force_resume_depth:&nbsp;number of irqactions on a irq descriptor with<BR>&nbsp;*&nbsp;&nbsp;&nbsp;IRQF_FORCE_RESUME set<BR>&nbsp;* @dir:&nbsp;&nbsp;/proc/irq/ procfs entry<BR>&nbsp;* @name:&nbsp;&nbsp;flow handler name for /proc/interrupts output<BR>&nbsp;*/<BR>struct irq_desc {<BR>&nbsp;struct irq_common_data&nbsp;irq_common_data;<BR>&nbsp;struct irq_data&nbsp;&nbsp;irq_data;<BR>&nbsp;unsigned int __percpu&nbsp;*kstat_irqs;<BR>&nbsp;irq_flow_handler_t&nbsp;handle_irq;<BR>#ifdef CONFIG_IRQ_PREFLOW_FASTEOI<BR>&nbsp;irq_preflow_handler_t&nbsp;preflow_handler;<BR>#endif<BR>&nbsp;struct irqaction&nbsp;*action;&nbsp;/* IRQ action list */<BR>&nbsp;unsigned int&nbsp;&nbsp;status_use_accessors;<BR>&nbsp;unsigned int&nbsp;&nbsp;core_internal_state__do_not_mess_with_it;<BR>&nbsp;unsigned int&nbsp;&nbsp;depth;&nbsp;&nbsp;/* nested irq disables */<BR>&nbsp;unsigned int&nbsp;&nbsp;wake_depth;&nbsp;/* nested wake enables */<BR>&nbsp;unsigned int&nbsp;&nbsp;irq_count;&nbsp;/* For detecting broken IRQs */<BR>&nbsp;unsigned long&nbsp;&nbsp;last_unhandled;&nbsp;/* Aging timer for unhandled count */<BR>&nbsp;unsigned int&nbsp;&nbsp;irqs_unhandled;<BR>&nbsp;atomic_t&nbsp;&nbsp;threads_handled;<BR>&nbsp;int&nbsp;&nbsp;&nbsp;threads_handled_last;<BR>&nbsp;raw_spinlock_t&nbsp;&nbsp;lock;<BR>&nbsp;struct cpumask&nbsp;&nbsp;*percpu_enabled;<BR>#ifdef CONFIG_SMP<BR>&nbsp;const struct cpumask&nbsp;*affinity_hint;<BR>&nbsp;struct irq_affinity_notify *affinity_notify;<BR>#ifdef CONFIG_GENERIC_PENDING_IRQ<BR>&nbsp;cpumask_var_t&nbsp;&nbsp;pending_mask;<BR>#endif<BR>#endif<BR>&nbsp;unsigned long&nbsp;&nbsp;threads_oneshot;<BR>&nbsp;atomic_t&nbsp;&nbsp;threads_active;<BR>&nbsp;wait_queue_head_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wait_for_threads;<BR>#ifdef CONFIG_PM_SLEEP<BR>&nbsp;unsigned int&nbsp;&nbsp;nr_actions;<BR>&nbsp;unsigned int&nbsp;&nbsp;no_suspend_depth;<BR>&nbsp;unsigned int&nbsp;&nbsp;cond_suspend_depth;<BR>&nbsp;unsigned int&nbsp;&nbsp;force_resume_depth;<BR>#endif<BR>#ifdef CONFIG_PROC_FS<BR>&nbsp;struct proc_dir_entry&nbsp;*dir;<BR>#endif<BR>&nbsp;int&nbsp;&nbsp;&nbsp;parent_irq;<BR>&nbsp;struct module&nbsp;&nbsp;*owner;<BR>&nbsp;const char&nbsp;&nbsp;*name;<BR>} ____cacheline_internodealigned_in_smp;</FONT></P>
<P>#ifdef CONFIG_SPARSE_IRQ<BR>extern void irq_lock_sparse(void);<BR>extern void irq_unlock_sparse(void);<BR>#else<BR>static inline void irq_lock_sparse(void) { }<BR>static inline void irq_unlock_sparse(void) { }<BR>extern struct irq_desc irq_desc[NR_IRQS];<BR>#endif</P>
<P>static inline struct irq_desc *irq_data_to_desc(struct irq_data *data)<BR>{<BR>&nbsp;return container_of(data-&gt;common, struct irq_desc, irq_common_data);<BR>}</P>
<P>static inline unsigned int irq_desc_get_irq(struct irq_desc *desc)<BR>{<BR>&nbsp;return desc-&gt;irq_data.irq;<BR>}</P>
<P>static inline struct irq_data *irq_desc_get_irq_data(struct irq_desc *desc)<BR>{<BR>&nbsp;return &amp;desc-&gt;irq_data;<BR>}</P>
<P>static inline struct irq_chip *irq_desc_get_chip(struct irq_desc *desc)<BR>{<BR>&nbsp;return desc-&gt;irq_data.chip;<BR>}</P>
<P>static inline void *irq_desc_get_chip_data(struct irq_desc *desc)<BR>{<BR>&nbsp;return desc-&gt;irq_data.chip_data;<BR>}</P>
<P>static inline void *irq_desc_get_handler_data(struct irq_desc *desc)<BR>{<BR>&nbsp;return desc-&gt;irq_common_data.handler_data;<BR>}</P>
<P>static inline struct msi_desc *irq_desc_get_msi_desc(struct irq_desc *desc)<BR>{<BR>&nbsp;return desc-&gt;irq_common_data.msi_desc;<BR>}</P>
<P>/*<BR>&nbsp;* Architectures call this to let the generic IRQ layer<BR>&nbsp;* handle an interrupt.<BR>&nbsp;*/<BR>static inline void generic_handle_irq_desc(struct irq_desc *desc)<BR>{<BR>&nbsp;desc-&gt;handle_irq(desc);<BR>}</P>
<P>int generic_handle_irq(unsigned int irq);</P>
<P>#ifdef CONFIG_HANDLE_DOMAIN_IRQ<BR>/*<BR>&nbsp;* Convert a HW interrupt number to a logical one using a IRQ domain,<BR>&nbsp;* and handle the result interrupt number. Return -EINVAL if<BR>&nbsp;* conversion failed. Providing a NULL domain indicates that the<BR>&nbsp;* conversion has already been done.<BR>&nbsp;*/<BR>int __handle_domain_irq(struct irq_domain *domain, unsigned int hwirq,<BR>&nbsp;&nbsp;&nbsp;bool lookup, struct pt_regs *regs);</P>
<P>static inline int handle_domain_irq(struct irq_domain *domain,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int hwirq, struct pt_regs *regs)<BR>{<BR>&nbsp;return __handle_domain_irq(domain, hwirq, true, regs);<BR>}<BR>#endif</P>
<P>/* Test to see if a driver has successfully requested an irq */<BR>static inline int irq_desc_has_action(struct irq_desc *desc)<BR>{<BR>&nbsp;return desc-&gt;action != NULL;<BR>}</P>
<P>static inline int irq_has_action(unsigned int irq)<BR>{<BR>&nbsp;return irq_desc_has_action(irq_to_desc(irq));<BR>}</P>
<P>/**<BR>&nbsp;* irq_set_handler_locked - Set irq handler from a locked region<BR>&nbsp;* @data:&nbsp;Pointer to the irq_data structure which identifies the irq<BR>&nbsp;* @handler:&nbsp;Flow control handler function for this interrupt<BR>&nbsp;*<BR>&nbsp;* Sets the handler in the irq descriptor associated to @data.<BR>&nbsp;*<BR>&nbsp;* Must be called with irq_desc locked and valid parameters. Typical<BR>&nbsp;* call site is the irq_set_type() callback.<BR>&nbsp;*/<BR>static inline void irq_set_handler_locked(struct irq_data *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_flow_handler_t handler)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_data_to_desc(data);</P>
<P>&nbsp;desc-&gt;handle_irq = handler;<BR>}</P>
<P>/**<BR>&nbsp;* irq_set_chip_handler_name_locked - Set chip, handler and name from a locked region<BR>&nbsp;* @data:&nbsp;Pointer to the irq_data structure for which the chip is set<BR>&nbsp;* @chip:&nbsp;Pointer to the new irq chip<BR>&nbsp;* @handler:&nbsp;Flow control handler function for this interrupt<BR>&nbsp;* @name:&nbsp;Name of the interrupt<BR>&nbsp;*<BR>&nbsp;* Replace the irq chip at the proper hierarchy level in @data and<BR>&nbsp;* sets the handler and name in the associated irq descriptor.<BR>&nbsp;*<BR>&nbsp;* Must be called with irq_desc locked and valid parameters.<BR>&nbsp;*/<BR>static inline void<BR>irq_set_chip_handler_name_locked(struct irq_data *data, struct irq_chip *chip,<BR>&nbsp;&nbsp;&nbsp;&nbsp; irq_flow_handler_t handler, const char *name)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_data_to_desc(data);</P>
<P>&nbsp;desc-&gt;handle_irq = handler;<BR>&nbsp;desc-&gt;name = name;<BR>&nbsp;data-&gt;chip = chip;<BR>}</P>
<P>static inline int irq_balancing_disabled(unsigned int irq)<BR>{<BR>&nbsp;struct irq_desc *desc;</P>
<P>&nbsp;desc = irq_to_desc(irq);<BR>&nbsp;return desc-&gt;status_use_accessors &amp; IRQ_NO_BALANCING_MASK;<BR>}</P>
<P>static inline int irq_is_percpu(unsigned int irq)<BR>{<BR>&nbsp;struct irq_desc *desc;</P>
<P>&nbsp;desc = irq_to_desc(irq);<BR>&nbsp;return desc-&gt;status_use_accessors &amp; IRQ_PER_CPU;<BR>}</P>
<P>static inline void<BR>irq_set_lockdep_class(unsigned int irq, struct lock_class_key *class)<BR>{<BR>&nbsp;struct irq_desc *desc = irq_to_desc(irq);</P>
<P>&nbsp;if (desc)<BR>&nbsp;&nbsp;lockdep_set_class(&amp;desc-&gt;lock, class);<BR>}</P>
<P>#ifdef CONFIG_IRQ_PREFLOW_FASTEOI<BR>static inline void<BR>__irq_set_preflow_handler(unsigned int irq, irq_preflow_handler_t handler)<BR>{<BR>&nbsp;struct irq_desc *desc;</P>
<P>&nbsp;desc = irq_to_desc(irq);<BR>&nbsp;desc-&gt;preflow_handler = handler;<BR>}<BR>#endif</P>
<P>#endif