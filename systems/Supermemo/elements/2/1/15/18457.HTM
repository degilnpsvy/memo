<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.17 Arrays of Length Zero</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-arrays-of-length-zero-2759></A><A name=index-zero-length-arrays-2760></A><A name=index-length-zero-arrays-2761></A><A name=index-flexible-array-members-2762></A>Zero-length arrays are allowed in GNU C. They are very useful as the last element of a structure that is really a header for a variable-length object:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     struct line {
       int length;
       char contents[0];
     };
     
     struct line *thisline = (struct line *)
       malloc (sizeof (struct line) + this_length);
     thisline-&gt;length = this_length;
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In ISO C90, you would have to give<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>contents</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>a length of 1, which means either you waste space or complicate the argument to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>malloc</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In ISO C99, you would use a<SPAN class=Apple-converted-space>&nbsp;</SPAN><DFN>flexible array member</DFN>, which is slightly different in syntax and semantics:</P>
<UL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<LI>Flexible array members are written as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>contents[]</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>without the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>0</CODE>.</LI>
<LI>Flexible array members have incomplete type, and so the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>sizeof</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>operator may not be applied. As a quirk of the original implementation of zero-length arrays,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>sizeof</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>evaluates to zero.</LI>
<LI>Flexible array members may only appear as the last member of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>that is otherwise non-empty.</LI>
<LI>A structure containing a flexible array member, or a union containing such a structure (possibly recursively), may not be a member of a structure or an element of an array. (However, these uses are permitted by GCC as extensions.)</LI></UL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">GCC versions before 3.0 allowed zero-length arrays to be statically initialized, as if they were flexible arrays. In addition to those cases that were useful, it also allowed initializations in situations that would corrupt later data. Non-empty initialization of zero-length arrays is now treated like any case where there are more initializer elements than the array holds, in that a suitable warning about &#8220;excess elements in array&#8221; is given, and the excess elements (all of them, in this case) are ignored.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Instead GCC allows static initialization of flexible array members. This is equivalent to defining a new structure containing the original structure followed by an array of sufficient size to contain the data. E.g. in the following,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>f1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is constructed as if it were declared like<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>f2</CODE>.</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     struct f1 {
       int x; int y[];
     } f1 = { 1, { 2, 3, 4 } };
     
     struct f2 {
       struct f1 f1; int data[3];
     } f2 = { { 1 }, { 2, 3, 4 } };
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=noindent>The convenience of this extension is that<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>f1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>has the desired type, eliminating the need to consistently refer to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>f2.f1</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">This has symmetry with normal static arrays, in that an array of unknown size is also written with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>[]</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Of course, this extension only makes sense if the extra data comes at the end of a top-level object, as otherwise we would be overwriting data at subsequent offsets. To avoid undue complication and confusion with initialization of deeply nested arrays, we simply disallow any non-empty initialization except when the structure is the top-level object. For example:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     struct foo { int x; int y[]; };
     struct bar { struct foo z; };
     
     struct foo a = { 1, { 2, 3, 4 } };        // <SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman>Valid.</SPAN>
     struct bar b = { { 1, { 2, 3, 4 } } };    // <SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman>Invalid.</SPAN>
     struct bar c = { { 1, { } } };            // <SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman>Valid.</SPAN>
     struct foo d[1] = { { 1 { 2, 3, 4 } } };  // <SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman>Invalid.</SPAN></PRE>