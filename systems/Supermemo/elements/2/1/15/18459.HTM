<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.19 Arrays of Variable Length</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-variable-length-arrays-2765></A><A name=index-arrays-of-variable-length-2766></A><A name=index-VLAs-2767></A>Variable-length automatic arrays are allowed in ISO C99, and as an extension GCC accepts them in C90 mode and in C++. These arrays are declared like any other automatic arrays, but with a length that is not a constant expression. The storage is allocated at the point of declaration and deallocated when the block scope containing the declaration exits. For example:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     FILE *
     concat_fopen (char *s1, char *s2, char *mode)
     {
       char str[strlen (s1) + strlen (s2) + 1];
       strcpy (str, s1);
       strcat (str, s2);
       return fopen (str, mode);
     }
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-scope-of-a-variable-length-array-2768></A><A name=index-variable-length-array-scope-2769></A><A name=index-deallocating-variable-length-arrays-2770></A>Jumping or breaking out of the scope of the array name deallocates the storage. Jumping into the scope is not allowed; you get an error message for it.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-variable-length-array-in-a-structure-2771></A>As an extension, GCC accepts variable-length arrays as a member of a structure or a union. For example:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     void
     foo (int n)
     {
       struct S { int x[n]; };
     }
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-g_t_0040code_007balloca_007d-vs-variable-length-arrays-2772></A>You can use the function<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>alloca</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to get an effect much like variable-length arrays. The function<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>alloca</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is available in many other C implementations (but not in all). On the other hand, variable-length arrays are more elegant.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">There are other differences between these two methods. Space allocated with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>alloca</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>exists until the containing<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>function</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>returns. The space for a variable-length array is deallocated as soon as the array name's scope ends. (If you use both variable-length arrays and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>alloca</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the same function, deallocation of a variable-length array also deallocates anything more recently allocated with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>alloca</CODE>.)</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">You can also use variable-length arrays as arguments to functions:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     struct entry
     tester (int len, char data[len][len])
     {
       /* <SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman>...</SPAN> */
     }
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The length of an array is computed once when the storage is allocated and is remembered for the scope of the array in case you access it with<CODE>sizeof</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">If you want to pass the array first and the length afterward, you can use a forward declaration in the parameter list&#8212;another GNU extension.</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     struct entry
     tester (int len; char data[len][len], int len)
     {
       /* <SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman>...</SPAN> */
     }
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-parameter-forward-declaration-2773></A>The &#8216;<SAMP><SPAN class=samp>int len</SPAN></SAMP>&#8217; before the semicolon is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><DFN>parameter forward declaration</DFN>, and it serves the purpose of making the name<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>len</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>known when the declaration of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>data</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is parsed.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">You can write any number of such parameter forward declarations in the parameter list. They can be separated by commas or semicolons, but the last one must end with a semicolon, which is followed by the &#8220;real&#8221; parameter declarations. Each forward declaration must match a &#8220;real&#8221; declaration in parameter name and data type. ISO C99 does not support parameter forward declarations.