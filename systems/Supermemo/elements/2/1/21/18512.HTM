<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.51 Legacy __sync Built-in Functions for Atomic Memory Access</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The following built-in functions are intended to be compatible with those described in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CITE>Intel Itanium Processor-specific Application Binary Interface</CITE>, section 7.4. As such, they depart from the normal GCC practice of using the &#8216;<SAMP><SPAN class=samp>__builtin_</SPAN></SAMP>&#8217; prefix, and further that they are overloaded such that they work on multiple types.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The definition given in the Intel documentation allows only for the use of the types<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>long</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>long long</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>as well as their unsigned counterparts. GCC allows any integral scalar or pointer type that is 1, 2, 4 or 8 bytes in length.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Not all operations are supported by all target processors. If a particular operation cannot be implemented on the target processor, a warning is generated and a call an external function is generated. The external function carries the same name as the built-in version, with an additional suffix &#8216;<SAMP><SPAN class=samp>_</SPAN><VAR>n</VAR></SAMP>&#8217; where<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the size of the data type.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In most cases, these built-in functions are considered a<SPAN class=Apple-converted-space>&nbsp;</SPAN><DFN>full barrier</DFN>. That is, no memory operand is moved across the operation, either forward or backward. Further, instructions are issued as necessary to prevent the processor from speculating loads across the operation and from queuing stores after the operation.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">All of the routines are described in the Intel documentation to take &#8220;an optional list of variables protected by the memory barrier&#8221;. It's not clear what is meant by that; it could mean that<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>only</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>the following variables are protected, or it could mean that these variables should in addition be protected. At present GCC ignores this list and protects all variables that are globally accessible. If in the future we make some use of this list, an empty list will continue to mean all globally accessible variables.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_fetch_and_add (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, ...)</CODE></DT>
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_fetch_and_sub (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, ...)</CODE></DT>
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_fetch_and_or (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, ...)</CODE></DT>
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_fetch_and_and (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, ...)</CODE></DT>
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_fetch_and_xor (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, ...)</CODE></DT>
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_fetch_and_nand (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, ...)</CODE></DT>
<DD><A name=index-g_t_005f_005fsync_005ffetch_005fand_005fadd-3160></A><A name=index-g_t_005f_005fsync_005ffetch_005fand_005fsub-3161></A><A name=index-g_t_005f_005fsync_005ffetch_005fand_005for-3162></A><A name=index-g_t_005f_005fsync_005ffetch_005fand_005fand-3163></A><A name=index-g_t_005f_005fsync_005ffetch_005fand_005fxor-3164></A><A name=index-g_t_005f_005fsync_005ffetch_005fand_005fnand-3165></A>These built-in functions perform the operation suggested by the name, and returns the value that had previously been in memory. That is,<PRE style="FONT-SIZE: smaller" class=smallexample>          { tmp = *ptr; *ptr <VAR>op</VAR>= value; return tmp; }
          { tmp = *ptr; *ptr = ~(tmp &amp; value); return tmp; }   // nand
</PRE>
<P><EM>Note:</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>GCC 4.4 and later implement<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__sync_fetch_and_nand</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*ptr = ~(tmp &amp; value)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*ptr = ~tmp &amp; value</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_add_and_fetch (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, ...)</CODE></DT>
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_sub_and_fetch (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, ...)</CODE></DT>
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_or_and_fetch (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, ...)</CODE></DT>
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_and_and_fetch (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, ...)</CODE></DT>
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_xor_and_fetch (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, ...)</CODE></DT>
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_nand_and_fetch (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, ...)</CODE></DT>
<DD><A name=index-g_t_005f_005fsync_005fadd_005fand_005ffetch-3166></A><A name=index-g_t_005f_005fsync_005fsub_005fand_005ffetch-3167></A><A name=index-g_t_005f_005fsync_005for_005fand_005ffetch-3168></A><A name=index-g_t_005f_005fsync_005fand_005fand_005ffetch-3169></A><A name=index-g_t_005f_005fsync_005fxor_005fand_005ffetch-3170></A><A name=index-g_t_005f_005fsync_005fnand_005fand_005ffetch-3171></A>These built-in functions perform the operation suggested by the name, and return the new value. That is,<PRE style="FONT-SIZE: smaller" class=smallexample>          { *ptr <VAR>op</VAR>= value; return *ptr; }
          { *ptr = ~(*ptr &amp; value); return *ptr; }   // nand
</PRE>
<P><EM>Note:</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>GCC 4.4 and later implement<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__sync_nand_and_fetch</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*ptr = ~(*ptr &amp; value)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*ptr = ~*ptr &amp; value</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>bool __sync_bool_compare_and_swap (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>oldval,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>newval, ...)</CODE></DT>
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_val_compare_and_swap (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>oldval,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>newval, ...)</CODE></DT>
<DD><A name=index-g_t_005f_005fsync_005fbool_005fcompare_005fand_005fswap-3172></A><A name=index-g_t_005f_005fsync_005fval_005fcompare_005fand_005fswap-3173></A>These built-in functions perform an atomic compare and swap. That is, if the current value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>oldval</VAR>, then write<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>newval</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>into<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>.
<P>The &#8220;bool&#8221; version returns true if the comparison is successful and<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>newval</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is written. The &#8220;val&#8221; version returns the contents of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>before the operation.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>__sync_synchronize (...)</CODE></DT>
<DD><A name=index-g_t_005f_005fsync_005fsynchronize-3174></A>This built-in function issues a full memory barrier.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>__sync_lock_test_and_set (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr,<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, ...)</CODE></DT>
<DD><A name=index-g_t_005f_005fsync_005flock_005ftest_005fand_005fset-3175></A>This built-in function, as described by Intel, is not a traditional test-and-set operation, but rather an atomic exchange operation. It writes<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>value</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>into<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>, and returns the previous contents of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>.
<P>Many targets have only minimal support for such locks, and do not support a full exchange operation. In this case, a target may support reduced functionality here by which the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>only</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>valid value to store is the immediate constant 1. The exact value actually stored in<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is implementation defined.</P>
<P>This built-in function is not a full barrier, but rather an<SPAN class=Apple-converted-space>&nbsp;</SPAN><DFN>acquire barrier</DFN>. This means that references after the operation cannot move to (or be speculated to) before the operation, but previous memory stores may not be globally visible yet, and previous memory loads may not yet be satisfied.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>void __sync_lock_release (</CODE><VAR>type</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>*ptr, ...)</CODE></DT>
<DD><A name=index-g_t_005f_005fsync_005flock_005frelease-3176></A>This built-in function releases the lock acquired by<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__sync_lock_test_and_set</CODE>. Normally this means writing the constant 0 to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>.
<P>This built-in function is not a full barrier, but rather a<SPAN class=Apple-converted-space>&nbsp;</SPAN><DFN>release barrier</DFN>. This means that all previous memory stores are globally visible, and all previous memory loads have been satisfied, but following memory reads are not prevented from being speculated to before the barrier.</P></DD></DL>