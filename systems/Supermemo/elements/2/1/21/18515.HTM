<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.54 Object Size Checking Built-in Functions</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-g_t_005f_005fbuiltin_005fobject_005fsize-3203></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fmemcpy_005fchk-3204></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fmempcpy_005fchk-3205></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fmemmove_005fchk-3206></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fmemset_005fchk-3207></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fstrcpy_005fchk-3208></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fstpcpy_005fchk-3209></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fstrncpy_005fchk-3210></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fstrcat_005fchk-3211></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fstrncat_005fchk-3212></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fsprintf_005fchk-3213></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fsnprintf_005fchk-3214></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fvsprintf_005fchk-3215></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fvsnprintf_005fchk-3216></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fprintf_005fchk-3217></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fvprintf_005fchk-3218></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005ffprintf_005fchk-3219></A><A name=index-g_t_005f_005fbuiltin_005f_005f_005fvfprintf_005fchk-3220></A>GCC implements a limited buffer overflow protection mechanism that can prevent some buffer overflow attacks.</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function: size_t<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__builtin_object_size</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>void * ptr, int type</VAR>)<VAR><A name=index-g_t_005f_005fbuiltin_005fobject_005fsize-3221></A></VAR><BR>
<BLOCKQUOTE>
<P>is a built-in construct that returns a constant number of bytes from<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the end of the object<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>pointer points to (if known at compile time).<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__builtin_object_size</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>never evaluates its arguments for side-effects. If there are any side-effects in them, it returns<CODE>(size_t) -1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>for<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>0 or 1 and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(size_t) 0</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>for<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>2 or 3. If there are multiple objects<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>can point to and all of them are known at compile time, the returned number is the maximum of remaining byte counts in those objects if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>&amp; 2 is 0 and minimum if nonzero. If it is not possible to determine which objects<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>points to at compile time,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__builtin_object_size</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>should return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(size_t) -1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>for<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>0 or 1 and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(size_t) 0</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>for<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>2 or 3.</P>
<P><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an integer constant from 0 to 3. If the least significant bit is clear, objects are whole variables, if it is set, a closest surrounding subobject is considered the object a pointer points to. The second bit determines if maximum or minimum of remaining bytes is computed.</P><PRE style="FONT-SIZE: smaller" class=smallexample>          struct V { char buf1[10]; int b; char buf2[10]; } var;
          char *p = &amp;var.buf1[1], *q = &amp;var.b;
          
          /* Here the object p points to is var.  */
          assert (__builtin_object_size (p, 0) == sizeof (var) - 1);
          /* The subobject p points to is var.buf1.  */
          assert (__builtin_object_size (p, 1) == sizeof (var.buf1) - 1);
          /* The object q points to is var.  */
          assert (__builtin_object_size (q, 0)
                  == (char *) (&amp;var + 1) - (char *) &amp;var.b);
          /* The subobject q points to is var.b.  */
          assert (__builtin_object_size (q, 1) == sizeof (var.b));
</PRE></BLOCKQUOTE></DIV>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">There are built-in functions added for many common string operation functions, e.g., for<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>memcpy</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__builtin___memcpy_chk</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>built-in is provided. This built-in has an additional last argument, which is the number of bytes remaining in object the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>dest</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument points to or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(size_t) -1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the size is not known.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The built-in functions are optimized into the normal string functions like<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>memcpy</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the last argument is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(size_t) -1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or if it is known at compile time that the destination object will not be overflown. If the compiler can determine at compile time the object will be always overflown, it issues a warning.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The intended use can be e.g.</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     #undef memcpy
     #define bos0(dest) __builtin_object_size (dest, 0)
     #define memcpy(dest, src, n) \
       __builtin___memcpy_chk (dest, src, n, bos0 (dest))
     
     char *volatile p;
     char buf[10];
     /* It is unknown what object p points to, so this is optimized
        into plain memcpy - no checking is possible.  */
     memcpy (p, "abcde", n);
     /* Destination is known and length too.  It is known at compile
        time there will be no overflow.  */
     memcpy (&amp;buf[5], "abcde", 5);
     /* Destination is known, but the length is not known at compile time.
        This will result in __memcpy_chk call that can check for overflow
        at run time.  */
     memcpy (&amp;buf[5], "abcde", n);
     /* Destination is known and it is known at compile time there will
        be overflow.  There will be a warning and __memcpy_chk call that
        will abort the program at run time.  */
     memcpy (&amp;buf[6], "abcde", 5);
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Such built-in functions are provided for<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>memcpy</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>mempcpy</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>memmove</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>memset</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>strcpy</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>stpcpy</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>strncpy</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>strcat</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>strncat</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">There are also checking built-in functions for formatted output functions.</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     int __builtin___sprintf_chk (char *s, int flag, size_t os, const char *fmt, ...);
     int __builtin___snprintf_chk (char *s, size_t maxlen, int flag, size_t os,
                                   const char *fmt, ...);
     int __builtin___vsprintf_chk (char *s, int flag, size_t os, const char *fmt,
                                   va_list ap);
     int __builtin___vsnprintf_chk (char *s, size_t maxlen, int flag, size_t os,
                                    const char *fmt, va_list ap);
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The added<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>flag</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument is passed unchanged to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__sprintf_chk</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>etc. functions and can contain implementation specific flags on what additional security measures the checking function might take, such as handling<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>%n</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>differently.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>os</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument is the object size<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>s</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>points to, like in the other built-in functions. There is a small difference in the behavior though, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>os</VAR>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(size_t) -1</CODE>, the built-in functions are optimized into the non-checking functions only if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>flag</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is 0, otherwise the checking function is called with<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>os</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument set to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(size_t) -1</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In addition to this, there are checking built-in functions<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__builtin___printf_chk</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__builtin___vprintf_chk</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__builtin___fprintf_chk</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__builtin___vfprintf_chk</CODE>. These have just one additional argument,<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>flag</VAR>, right before format string<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>fmt</VAR>. If the compiler is able to optimize them to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fputc</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>etc. functions, it does, otherwise the checking function is called and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>flag</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument passed to it.