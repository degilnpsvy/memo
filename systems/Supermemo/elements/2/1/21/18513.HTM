<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.52 Built-in functions for memory model aware atomic operations</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The following built-in functions approximately match the requirements for C++11 memory model. Many are similar to the &#8216;<SAMP><SPAN class=samp>__sync</SPAN></SAMP>&#8217; prefixed built-in functions, but all also have a memory model parameter. These are all identified by being prefixed with &#8216;<SAMP><SPAN class=samp>__atomic</SPAN></SAMP>&#8217;, and most are overloaded such that they work with multiple types.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">GCC allows any integral scalar or pointer type that is 1, 2, 4, or 8 bytes in length. 16-byte integral types are also allowed if &#8216;<SAMP><SPAN class=samp>__int128</SPAN></SAMP>&#8217; (see<A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/_005f_005fint128.html#g_t_005f_005fint128">__int128</A>) is supported by the architecture.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Target architectures are encouraged to provide their own patterns for each of these built-in functions. If no target is provided, the original non-memory model set of &#8216;<SAMP><SPAN class=samp>__sync</SPAN></SAMP>&#8217; atomic built-in functions are utilized, along with any required synchronization fences surrounding it in order to achieve the proper behavior. Execution in this case is subject to the same restrictions as those built-in functions.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">If there is no pattern or mechanism to provide a lock free instruction sequence, a call is made to an external routine with the same parameters to be resolved at run time.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The four non-arithmetic functions (load, store, exchange, and compare_exchange) all have a generic version as well. This generic version works on any data type. If the data type size maps to one of the integral sizes that may have lock free support, the generic version utilizes the lock free built-in function. Otherwise an external call is left to be resolved at run time. This external call is the same format with the addition of a &#8216;<SAMP><SPAN class=samp>size_t</SPAN></SAMP>&#8217; parameter inserted as the first parameter indicating the size of the object being pointed to. All objects must be the same size.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">There are 6 different memory models that can be specified. These map to the same names in the C++11 standard. Refer there or to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync">GCC wiki on atomic synchronization</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>for more detailed definitions. These memory models integrate both barriers to code motion as well as synchronization requirements with other threads. These are listed in approximately ascending order of strength. It is also possible to use target specific flags for memory model flags, like Hardware Lock Elision.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><CODE>__ATOMIC_RELAXED</CODE></DT>
<DD>No barriers or synchronization.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>__ATOMIC_CONSUME</CODE></DT>
<DD>Data dependency only for both barrier and synchronization with another thread.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>__ATOMIC_ACQUIRE</CODE></DT>
<DD>Barrier to hoisting of code and synchronizes with release (or stronger) semantic stores from another thread.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>__ATOMIC_RELEASE</CODE></DT>
<DD>Barrier to sinking of code and synchronizes with acquire (or stronger) semantic loads from another thread.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>__ATOMIC_ACQ_REL</CODE></DT>
<DD>Full barrier in both directions and synchronizes with acquire loads and release stores in another thread.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>__ATOMIC_SEQ_CST</CODE></DT>
<DD>Full barrier in both directions and synchronizes with acquire loads and release stores in all threads.</DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">When implementing patterns for these built-in functions, the memory model parameter can be ignored as long as the pattern implements the most restrictive<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_SEQ_CST</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>model. Any of the other memory models execute correctly with this memory model but they may not execute as efficiently as they could with a more appropriate implementation of the relaxed requirements.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Note that the C++11 standard allows for the memory model parameter to be determined at run time rather than at compile time. These built-in functions map any run-time value to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_SEQ_CST</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>rather than invoke a runtime library call or inline a switch statement. This is standard compliant, safe, and the simplest approach for now.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The memory model parameter is a signed int, but only the lower 8 bits are reserved for the memory model. The remainder of the signed int is reserved for future use and should be 0. Use of the predefined atomic values ensures proper usage.</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_load_n</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fload_005fn-3177></A></VAR><BR>
<BLOCKQUOTE>
<P>This built-in function implements an atomic load operation. It returns the contents of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>.</P>
<P>The valid memory model variants are<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_RELAXED</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_SEQ_CST</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_ACQUIRE</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_CONSUME</CODE>.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function: void<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_load</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type *ret, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fload-3178></A></VAR><BR>
<BLOCKQUOTE>
<P>This is the generic version of an atomic load. It returns the contents of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>in<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ret</VAR>.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function: void<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_store_n</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fstore_005fn-3179></A></VAR><BR>
<BLOCKQUOTE>
<P>This built-in function implements an atomic store operation. It writes<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>val</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>into<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>.</P>
<P>The valid memory model variants are<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_RELAXED</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_SEQ_CST</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_RELEASE</CODE>.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function: void<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_store</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type *val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fstore-3180></A></VAR><BR>
<BLOCKQUOTE>
<P>This is the generic version of an atomic store. It stores the value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>val</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>into<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_exchange_n</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fexchange_005fn-3181></A></VAR><BR>
<BLOCKQUOTE>
<P>This built-in function implements an atomic exchange operation. It writes<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>val</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>into<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>, and returns the previous contents of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>.</P>
<P>The valid memory model variants are<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_RELAXED</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_SEQ_CST</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_ACQUIRE</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_RELEASE</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_ACQ_REL</CODE>.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function: void<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_exchange</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type *val, type *ret, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fexchange-3182></A></VAR><BR>
<BLOCKQUOTE>
<P>This is the generic version of an atomic exchange. It stores the contents of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>val</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>into<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>. The original value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is copied into<CODE>*</CODE><VAR>ret</VAR>.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function: bool<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_compare_exchange_n</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type *expected, type desired, bool weak, int success_memmodel, int failure_memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fcompare_005fexchange_005fn-3183></A></VAR><BR>
<BLOCKQUOTE>
<P>This built-in function implements an atomic compare and exchange operation. This compares the contents of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>with the contents of<CODE>*</CODE><VAR>expected</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>and if equal, writes<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>desired</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>into<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>. If they are not equal, the current contents of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is written into<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>expected</VAR>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>weak</VAR>is true for weak compare_exchange, and false for the strong variation. Many targets only offer the strong variation and ignore the parameter. When in doubt, use the strong variation.</P>
<P>True is returned if<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>desired</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is written into<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the execution is considered to conform to the memory model specified by<VAR>success_memmodel</VAR>. There are no restrictions on what memory model can be used here.</P>
<P>False is returned otherwise, and the execution is considered to conform to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>failure_memmodel</VAR>. This memory model cannot be<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_RELEASE</CODE>nor<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_ACQ_REL</CODE>. It also cannot be a stronger model than that specified by<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>success_memmodel</VAR>.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function: bool<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_compare_exchange</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type *expected, type *desired, bool weak, int success_memmodel, int failure_memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fcompare_005fexchange-3184></A></VAR><BR>
<BLOCKQUOTE>
<P>This built-in function implements the generic version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__atomic_compare_exchange</CODE>. The function is virtually identical to<CODE>__atomic_compare_exchange_n</CODE>, except the desired value is also a pointer.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_add_fetch</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fadd_005ffetch-3185></A></VAR><BR>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_sub_fetch</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fsub_005ffetch-3186></A></VAR><BR>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_and_fetch</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fand_005ffetch-3187></A></VAR><BR>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_xor_fetch</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fxor_005ffetch-3188></A></VAR><BR>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_or_fetch</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005for_005ffetch-3189></A></VAR><BR>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_nand_fetch</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fnand_005ffetch-3190></A></VAR><BR>
<BLOCKQUOTE>
<P>These built-in functions perform the operation suggested by the name, and return the result of the operation. That is,</P><PRE style="FONT-SIZE: smaller" class=smallexample>          { *ptr <VAR>op</VAR>= val; return *ptr; }
</PRE>
<P>All memory models are valid.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_fetch_add</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005ffetch_005fadd-3191></A></VAR><BR>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_fetch_sub</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005ffetch_005fsub-3192></A></VAR><BR>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_fetch_and</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005ffetch_005fand-3193></A></VAR><BR>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_fetch_xor</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005ffetch_005fxor-3194></A></VAR><BR>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_fetch_or</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005ffetch_005for-3195></A></VAR><BR>&#8212; Built-in Function:<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_fetch_nand</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>type *ptr, type val, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005ffetch_005fnand-3196></A></VAR><BR>
<BLOCKQUOTE>
<P>These built-in functions perform the operation suggested by the name, and return the value that had previously been in<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>. That is,</P><PRE style="FONT-SIZE: smaller" class=smallexample>          { tmp = *ptr; *ptr <VAR>op</VAR>= val; return tmp; }
</PRE>
<P>All memory models are valid.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function: bool<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_test_and_set</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>void *ptr, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005ftest_005fand_005fset-3197></A></VAR><BR>
<BLOCKQUOTE>
<P>This built-in function performs an atomic test-and-set operation on the byte at<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>. The byte is set to some implementation defined nonzero &#8220;set&#8221; value and the return value is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>true</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if and only if the previous contents were &#8220;set&#8221;. It should be only used for operands of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>bool</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>char</CODE>. For other types only part of the value may be set.</P>
<P>All memory models are valid.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function: void<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_clear</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>bool *ptr, int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fclear-3198></A></VAR><BR>
<BLOCKQUOTE>
<P>This built-in function performs an atomic clear operation on<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR>. After the operation,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains 0. It should be only used for operands of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>bool</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>char</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and in conjunction with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__atomic_test_and_set</CODE>. For other types it may only clear partially. If the type is not<CODE>bool</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>prefer using<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__atomic_store</CODE>.</P>
<P>The valid memory model variants are<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_RELAXED</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_SEQ_CST</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ATOMIC_RELEASE</CODE>.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function: void<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_thread_fence</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fthread_005ffence-3199></A></VAR><BR>
<BLOCKQUOTE>
<P>This built-in function acts as a synchronization fence between threads based on the specified memory model.</P>
<P>All memory orders are valid.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function: void<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_signal_fence</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>int memmodel</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fsignal_005ffence-3200></A></VAR><BR>
<BLOCKQUOTE>
<P>This built-in function acts as a synchronization fence between a thread and signal handlers based in the same thread.</P>
<P>All memory orders are valid.</P></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function: bool<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_always_lock_free</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>size_t size, void *ptr</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005falways_005flock_005ffree-3201></A></VAR><BR>
<BLOCKQUOTE>
<P>This built-in function returns true if objects of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>size</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>bytes always generate lock free atomic instructions for the target architecture.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>size</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>must resolve to a compile-time constant and the result also resolves to a compile-time constant.</P>
<P><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an optional pointer to the object that may be used to determine alignment. A value of 0 indicates typical alignment should be used. The compiler may also ignore this parameter.</P><PRE style="FONT-SIZE: smaller" class=smallexample>          if (_atomic_always_lock_free (sizeof (long long), 0))
</PRE></BLOCKQUOTE></DIV>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=defun>&#8212; Built-in Function: bool<SPAN class=Apple-converted-space>&nbsp;</SPAN><B>__atomic_is_lock_free</B><SPAN class=Apple-converted-space>&nbsp;</SPAN>(<VAR>size_t size, void *ptr</VAR>)<VAR><A name=index-g_t_005f_005fatomic_005fis_005flock_005ffree-3202></A></VAR><BR>
<BLOCKQUOTE>
<P>This built-in function returns true if objects of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>size</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>bytes always generate lock free atomic instructions for the target architecture. If it is not known to be lock free a call is made to a runtime routine named<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__atomic_is_lock_free</CODE>.</P>
<P><VAR>ptr</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an optional pointer to the object that may be used to determine alignment. A value of 0 indicates typical alignment should be used. The compiler may also ignore this parameter.</P></BLOCKQUOTE></DIV>