<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>3.17.2 Adapteva Epiphany Options</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">These &#8216;<SAMP><SPAN class=samp>-m</SPAN></SAMP>&#8217; options are defined for Adapteva Epiphany:</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><CODE>-mhalf-reg-file</CODE></DT>
<DD><A name=index-mhalf-reg-file-1150></A>Don't allocate any register in the range<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>r32</CODE><SMALL class=dots>...</SMALL><CODE>r63</CODE>. That allows code to run on hardware variants that lack these registers.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mprefer-short-insn-regs</CODE></DT>
<DD><A name=index-mprefer-short-insn-regs-1151></A>Preferrentially allocate registers that allow short instruction generation. This can result in increased instruction count, so this may either reduce or increase overall code size.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mbranch-cost=</CODE><VAR>num</VAR></DT>
<DD><A name=index-mbranch-cost-1152></A>Set the cost of branches to roughly<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>num</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>&#8220;simple&#8221; instructions. This cost is only a heuristic and is not guaranteed to produce consistent results across releases.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mcmove</CODE></DT>
<DD><A name=index-mcmove-1153></A>Enable the generation of conditional moves.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mnops=</CODE><VAR>num</VAR></DT>
<DD><A name=index-mnops-1154></A>Emit<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>num</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>NOPs before every other generated instruction.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mno-soft-cmpsf</CODE></DT>
<DD><A name=index-mno-soft-cmpsf-1155></A>For single-precision floating-point comparisons, emit an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fsub</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction and test the flags. This is faster than a software comparison, but can get incorrect results in the presence of NaNs, or when two different small numbers are compared such that their difference is calculated as zero. The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-msoft-cmpsf</SPAN></SAMP>, which uses slower, but IEEE-compliant, software comparisons.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mstack-offset=</CODE><VAR>num</VAR></DT>
<DD><A name=index-mstack-offset-1156></A>Set the offset between the top of the stack and the stack pointer. E.g., a value of 8 means that the eight bytes in the range<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>sp+0...sp+7</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be used by leaf functions without stack allocation. Values other than &#8216;<SAMP><SPAN class=samp>8</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>16</SPAN></SAMP>&#8217; are untested and unlikely to work. Note also that this option changes the ABI; compiling a program with a different stack offset than the libraries have been compiled with generally does not work. This option can be useful if you want to evaluate if a different stack offset would give you better code, but to actually use a different stack offset to build working programs, it is recommended to configure the toolchain with the appropriate<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--with-stack-offset=</SPAN><VAR>num</VAR></SAMP>option.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mno-round-nearest</CODE></DT>
<DD><A name=index-mno-round-nearest-1157></A>Make the scheduler assume that the rounding mode has been set to truncating. The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mround-nearest</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mlong-calls</CODE></DT>
<DD><A name=index-mlong-calls-1158></A>If not otherwise specified by an attribute, assume all calls might be beyond the offset range of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>b</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>/<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>bl</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instructions, and therefore load the function address into a register before performing a (otherwise direct) call. This is the default.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mshort-calls</CODE></DT>
<DD><A name=index-short-calls-1159></A>If not otherwise specified by an attribute, assume all direct calls are in the range of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>b</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>/<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>bl</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instructions, so use these instructions for direct calls. The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mlong-calls</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-msmall16</CODE></DT>
<DD><A name=index-msmall16-1160></A>Assume addresses can be loaded as 16-bit unsigned values. This does not apply to function addresses for which<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mlong-calls</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>semantics are in effect.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mfp-mode=</CODE><VAR>mode</VAR></DT>
<DD><A name=index-mfp-mode-1161></A>Set the prevailing mode of the floating-point unit. This determines the floating-point mode that is provided and expected at function call and return time. Making this mode match the mode you predominantly need at function start can make your programs smaller and faster by avoiding unnecessary mode switches.
<P><VAR>mode</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be set to one the following values:</P>
<DL>
<DT>&#8216;<SAMP><SPAN class=samp>caller</SPAN></SAMP>&#8217;</DT>
<DD>Any mode at function entry is valid, and retained or restored when the function returns, and when it calls other functions. This mode is useful for compiling libraries or other compilation units you might want to incorporate into different programs with different prevailing FPU modes, and the convenience of being able to use a single object file outweighs the size and speed overhead for any extra mode switching that might be needed, compared with what would be needed with a more specific choice of prevailing FPU mode.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>&#8216;<SAMP><SPAN class=samp>truncate</SPAN></SAMP>&#8217;</DT>
<DD>This is the mode used for floating-point calculations with truncating (i.e. round towards zero) rounding mode. That includes conversion from floating point to integer.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>&#8216;<SAMP><SPAN class=samp>round-nearest</SPAN></SAMP>&#8217;</DT>
<DD>This is the mode used for floating-point calculations with round-to-nearest-or-even rounding mode.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>&#8216;<SAMP><SPAN class=samp>int</SPAN></SAMP>&#8217;</DT>
<DD>This is the mode used to perform integer calculations in the FPU, e.g. integer multiply, or integer multiply-and-accumulate.</DD></DL>
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mfp-mode=caller</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-mnosplit-lohi</CODE></DT>
<DT><CODE>-mno-postinc</CODE></DT>
<DT><CODE>-mno-postmodify</CODE></DT>
<DD><A name=index-mnosplit-lohi-1162></A><A name=index-mno-postinc-1163></A><A name=index-mno-postmodify-1164></A>Code generation tweaks that disable, respectively, splitting of 32-bit loads, generation of post-increment addresses, and generation of post-modify addresses. The defaults are<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>msplit-lohi</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mpost-inc</SPAN></SAMP>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mpost-modify</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mnovect-double</CODE></DT>
<DD><A name=index-mno-vect-double-1165></A>Change the preferred SIMD mode to SImode. The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mvect-double</SPAN></SAMP>, which uses DImode as preferred SIMD mode.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-max-vect-align=</CODE><VAR>num</VAR></DT>
<DD><A name=index-max-vect-align-1166></A>The maximum alignment for SIMD vector mode types.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>num</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>may be 4 or 8. The default is 8. Note that this is an ABI change, even though many library function interfaces are unaffected if they don't use SIMD vector modes in places that affect size and/or alignment of relevant types.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-msplit-vecmove-early</CODE></DT>
<DD><A name=index-msplit-vecmove-early-1167></A>Split vector moves into single word moves before reload. In theory this can give better register allocation, but so far the reverse seems to be generally the case.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-m1reg-</CODE><VAR>reg</VAR></DT>
<DD><A name=index-m1reg--1168></A>Specify a register to hold the constant &#8722;1, which makes loading small negative constants and certain bitmasks faster. Allowable values for<VAR>reg</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>are &#8216;<SAMP><SPAN class=samp>r43</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>r63</SPAN></SAMP>&#8217;, which specify use of that register as a fixed register, and &#8216;<SAMP><SPAN class=samp>none</SPAN></SAMP>&#8217;, which means that no register is used for this purpose. The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-m1reg-none</SPAN></SAMP>.</DD></DL>