<H3 class=section style="FONT-FAMILY: Simsun; FONT-VARIANT: normal; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">6.41 Assembler Instructions with C Expression Operands</H3>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><A name=index-extended-_0040code_007basm_007d-3073></A><A name=index-g_t_0040code_007basm_007d-expressions-3074></A><A name=index-assembler-instructions-3075></A><A name=index-registers-3076></A>In an assembler instruction using<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>, you can specify the operands of the instruction using C expressions. This means you need not guess which registers or memory locations contain the data you want to use.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">You must specify an assembler instruction template much like what appears in a machine description, plus an operand constraint string for each operand.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">For example, here is how to use the 68881's<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fsinx</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     asm ("fsinx %1,%0" : "=f" (result) : "f" (angle));
</PRE>
<P class=noindent style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Here<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>angle</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the C expression for the input operand while<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>result</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is that of the output operand. Each has &#8216;<SAMP><SPAN class=samp>"f"</SPAN></SAMP>&#8217; as its operand constraint, saying that a floating-point register is required. The &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217; in &#8216;<SAMP><SPAN class=samp>=f</SPAN></SAMP>&#8217; indicates that the operand is an output; all output operands' constraints must use &#8216;<SAMP><SPAN class=samp>=</SPAN></SAMP>&#8217;. The constraints use the same language used in the machine description (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Constraints.html#Constraints">Constraints</A>).</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Each operand is described by an operand-constraint string followed by the C expression in parentheses. A colon separates the assembler template from the first output operand and another separates the last output operand from the first input, if any. Commas separate the operands within each group. The total number of operands is currently limited to 30; this limitation may be lifted in some future version of GCC.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">If there are no output operands but there are input operands, you must place two consecutive colons surrounding the place where the output operands would go.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">As of GCC version 3.1, it is also possible to specify input and output operands using symbolic names which can be referenced within the assembler code. These names are specified inside square brackets preceding the constraint string, and can be referenced inside the assembler code using<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>%[</CODE><VAR>name</VAR><CODE>]</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of a percentage sign followed by the operand number. Using named operands the above example could look like:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     asm ("fsinx %[angle],%[output]"
          : [output] "=f" (result)
          : [angle] "f" (angle));
</PRE>
<P class=noindent style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Note that the symbolic operand names have no relation whatsoever to other C identifiers. You may use any name you like, even those of existing C symbols, but you must ensure that no two operands within the same assembler construct use the same symbolic name.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Output operand expressions must be lvalues; the compiler can check this. The input operands need not be lvalues. The compiler cannot check whether the operands have data types that are reasonable for the instruction being executed. It does not parse the assembler instruction template and does not know what it means or even whether it is valid assembler input. The extended<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>feature is most often used for machine instructions the compiler itself does not know exist. If the output expression cannot be directly addressed (for example, it is a bit-field), your constraint must allow a register. In that case, GCC uses the register as the output of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>, and then stores that register into the output.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">The ordinary output operands must be write-only; GCC assumes that the values in these operands before the instruction are dead and need not be generated. Extended asm supports input-output or read-write operands. Use the constraint character &#8216;<SAMP><SPAN class=samp>+</SPAN></SAMP>&#8217; to indicate such an operand and list it with the output operands.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">You may, as an alternative, logically split its function into two separate operands, one input operand and one write-only output operand. The connection between them is expressed by constraints that say they need to be in the same location when the instruction executes. You can use the same C expression for both operands, or different expressions. For example, here we write the (fictitious) &#8216;<SAMP><SPAN class=samp>combine</SPAN></SAMP>&#8217; instruction with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>bar</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>as its read-only source operand and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>as its read-write destination:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     asm ("combine %2,%0" : "=r" (foo) : "0" (foo), "g" (bar));
</PRE>
<P class=noindent style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">The constraint &#8216;<SAMP><SPAN class=samp>"0"</SPAN></SAMP>&#8217; for operand 1 says that it must occupy the same location as operand 0. A number in constraint is allowed only in an input operand and it must refer to an output operand.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Only a number in the constraint can guarantee that one operand is in the same place as another. The mere fact that<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the value of both operands is not enough to guarantee that they are in the same place in the generated assembler code. The following does not work reliably:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     asm ("combine %2,%0" : "=r" (foo) : "r" (foo), "g" (bar));
</PRE>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Various optimizations or reloading could cause operands 0 and 1 to be in different registers; GCC knows no reason not to do so. For example, the compiler might find a copy of the value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in one register and use it for operand 1, but generate the output operand 0 in a different register (copying it afterward to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE>'s own address). Of course, since the register for operand 1 is not even mentioned in the assembler code, the result will not work, but GCC can't tell that.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">As of GCC version 3.1, one may write<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>[</CODE><VAR>name</VAR><CODE>]</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of the operand number for a matching constraint. For example:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     asm ("cmoveq %1,%2,%[result]"
          : [result] "=r"(result)
          : "r" (test), "r"(new), "[result]"(old));
</PRE>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Sometimes you need to make an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>operand be a specific register, but there's no matching constraint letter for that register<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>by itself</EM>. To force the operand into that register, use a local variable for the operand and specify the register in the variable declaration. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Explicit-Reg-Vars.html#Explicit-Reg-Vars">Explicit Reg Vars</A>. Then for the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>operand, use any register constraint letter that matches the register:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     register int *p1 asm ("r0") = ...;
     register int *p2 asm ("r1") = ...;
     register int *result asm ("r0");
     asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));
</PRE>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><A name=Example-of-asm-with-clobbered-asm-reg></A>In the above example, beware that a register that is call-clobbered by the target ABI will be overwritten by any function call in the assignment, including library calls for arithmetic operators. Also a register may be clobbered when generating some operations, like variable shift, memory copy or memory move on x86. Assuming it is a call-clobbered register, this may happen to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>r0</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>above by the assignment to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>p2</CODE>. If you have to use such a register, use temporary variables for expressions between the register assignment and use:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     int t1 = ...;
     register int *p1 asm ("r0") = ...;
     register int *p2 asm ("r1") = t1;
     register int *result asm ("r0");
     asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));
</PRE>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Some instructions clobber specific hard registers. To describe this, write a third colon after the input operands, followed by the names of the clobbered hard registers (given as strings). Here is a realistic example for the VAX:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     asm volatile ("movc3 %0,%1,%2"
                   : /* <SPAN class=roman style="FONT-FAMILY: serif; FONT-WEIGHT: normal">no outputs</SPAN> */
                   : "g" (from), "g" (to), "g" (count)
                   : "r0", "r1", "r2", "r3", "r4", "r5");
</PRE>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">You may not write a clobber description in a way that overlaps with an input or output operand. For example, you may not have an operand describing a register class with one member if you mention that register in the clobber list. Variables declared to live in specific registers (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Explicit-Reg-Vars.html#Explicit-Reg-Vars">Explicit Reg Vars</A>), and used as asm input or output operands must have no part mentioned in the clobber description. There is no way for you to specify that an input operand is modified without also specifying it as an output operand. Note that if all the output operands you specify are for this purpose (and hence unused), you then also need to specify<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>volatile</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>for the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>construct, as described below, to prevent GCC from deleting the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>statement as unused.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">If you refer to a particular hardware register from the assembler code, you probably have to list the register after the third colon to tell the compiler the register's value is modified. In some assemblers, the register names begin with &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217;; to produce one &#8216;<SAMP><SPAN class=samp>%</SPAN></SAMP>&#8217; in the assembler code, you must write &#8216;<SAMP><SPAN class=samp>%%</SPAN></SAMP>&#8217; in the input.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">If your assembler instruction can alter the condition code register, add &#8216;<SAMP><SPAN class=samp>cc</SPAN></SAMP>&#8217; to the list of clobbered registers. GCC on some machines represents the condition codes as a specific hardware register; &#8216;<SAMP><SPAN class=samp>cc</SPAN></SAMP>&#8217; serves to name this register. On other machines, the condition code is handled differently, and specifying &#8216;<SAMP><SPAN class=samp>cc</SPAN></SAMP>&#8217; has no effect. But it is valid no matter what the machine.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">If your assembler instructions access memory in an unpredictable fashion, add &#8216;<SAMP><SPAN class=samp>memory</SPAN></SAMP>&#8217; to the list of clobbered registers. This causes GCC to not keep memory values cached in registers across the assembler instruction and not optimize stores or loads to that memory. You also should add the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>volatile</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword if the memory affected is not listed in the inputs or outputs of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>, as the &#8216;<SAMP><SPAN class=samp>memory</SPAN></SAMP>&#8217; clobber does not count as a side-effect of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>. If you know how large the accessed memory is, you can add it as input or output but if this is not known, you should add &#8216;<SAMP><SPAN class=samp>memory</SPAN></SAMP>&#8217;. As an example, if you access ten bytes of a string, you can use a memory input like:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     {"m"( ({ struct { char x[10]; } *p = (void *)ptr ; *p; }) )}.
</PRE>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Note that in the following example the memory input is necessary, otherwise GCC might optimize the store to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>x</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>away:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     int foo ()
     {
       int x = 42;
       int *y = &amp;x;
       int result;
       asm ("magic stuff accessing an 'int' pointed to by '%1'"
            : "=&amp;d" (result) : "a" (y), "m" (*y));
       return result;
     }
</PRE>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">You can put multiple assembler instructions together in a single<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>template, separated by the characters normally used in assembly code for the system. A combination that works in most places is a newline to break the line, plus a tab character to move to the instruction field (written as &#8216;<SAMP><SPAN class=samp>\n\t</SPAN></SAMP>&#8217;). Sometimes semicolons can be used, if the assembler allows semicolons as a line-breaking character. Note that some assembler dialects use semicolons to start a comment. The input operands are guaranteed not to use any of the clobbered registers, and neither do the output operands' addresses, so you can read and write the clobbered registers as many times as you like. Here is an example of multiple instructions in a template; it assumes the subroutine<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>_foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>accepts arguments in registers 9 and 10:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     asm ("movl %0,r9\n\tmovl %1,r10\n\tcall _foo"
          : /* no outputs */
          : "g" (from), "g" (to)
          : "r9", "r10");
</PRE>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Unless an output operand has the &#8216;<SAMP><SPAN class=samp>&amp;</SPAN></SAMP>&#8217; constraint modifier, GCC may allocate it in the same register as an unrelated input operand, on the assumption the inputs are consumed before the outputs are produced. This assumption may be false if the assembler code actually consists of more than one instruction. In such a case, use &#8216;<SAMP><SPAN class=samp>&amp;</SPAN></SAMP>&#8217; for each output operand that may not overlap an input. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Modifiers.html#Modifiers">Modifiers</A>.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">If you want to test the condition code produced by an assembler instruction, you must include a branch and a label in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>construct, as follows:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     asm ("clr %0\n\tfrob %1\n\tbeq 0f\n\tmov #1,%0\n0:"
          : "g" (result)
          : "g" (input));
</PRE>
<P class=noindent style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">This assumes your assembler supports local labels, as the GNU assembler and most Unix assemblers do.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Speaking of labels, jumps from one<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to another are not supported. The compiler's optimizers do not know about these jumps, and therefore they cannot take account of them when deciding how to optimize. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Extended-asm-with-goto.html#Extended-asm-with-goto">Extended asm with goto</A>.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><A name=index-macros-containing-_0040code_007basm_007d-3077></A>Usually the most convenient way to use these<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instructions is to encapsulate them in macros that look like functions. For example,</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     #define sin(x)       \
     ({ double __value, __arg = (x);   \
        asm ("fsinx %1,%0": "=f" (__value): "f" (__arg));  \
        __value; })
</PRE>
<P class=noindent style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Here the variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__arg</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used to make sure that the instruction operates on a proper<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>double</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>value, and to accept only those arguments<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>x</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>that can convert automatically to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>double</CODE>.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Another way to make sure the instruction operates on the correct data type is to use a cast in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>. This is different from using a variable<CODE>__arg</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in that it converts more different types. For example, if the desired type is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE>, casting the argument to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>accepts a pointer with no complaint, while assigning the argument to an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>variable named<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__arg</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>warns about using a pointer unless the caller explicitly casts it.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">If an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>has output operands, GCC assumes for optimization purposes the instruction has no side effects except to change the output operands. This does not mean instructions with a side effect cannot be used, but you must be careful, because the compiler may eliminate them if the output operands aren't used, or move them out of loops, or replace two with one if they constitute a common subexpression. Also, if your instruction does have a side effect on a variable that otherwise appears not to change, the old value of the variable may be reused later if it happens to be found in a register.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">You can prevent an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction from being deleted by writing the keyword<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>volatile</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>after the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>. For example:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     #define get_and_set_priority(new)              \
     ({ int __old;                                  \
        asm volatile ("get_and_set_priority %0, %1" \
                      : "=g" (__old) : "g" (new));  \
        __old; })
</PRE>
<P class=noindent style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>volatile</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword indicates that the instruction has important side-effects. GCC does not delete a volatile<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if it is reachable. (The instruction can still be deleted if GCC can prove that control flow never reaches the location of the instruction.) Note that even a volatile<CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction can be moved relative to other code, including across jump instructions. For example, on many targets there is a system register that can be set to control the rounding mode of floating-point operations. You might try setting it with a volatile<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>, like this PowerPC example:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">            asm volatile("mtfsf 255,%0" : : "f" (fpenv));
            sum = x + y;
</PRE>
<P class=noindent style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">This does not work reliably, as the compiler may move the addition back before the volatile<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>. To make it work you need to add an artificial dependency to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>referencing a variable in the code you don't want moved, for example:</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">         asm volatile ("mtfsf 255,%1" : "=X"(sum): "f"(fpenv));
         sum = x + y;
</PRE>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">Similarly, you can't expect a sequence of volatile<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instructions to remain perfectly consecutive. If you want consecutive output, use a single<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>. Also, GCC performs some optimizations across a volatile<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction; GCC does not &#8220;forget everything&#8221; when it encounters a volatile<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction the way some other compilers do.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">An<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction without any output operands is treated identically to a volatile<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">It is a natural idea to look for a way to give access to the condition code left by the assembler instruction. However, when we attempted to implement this, we found no way to make it work reliably. The problem is that output operands might need reloading, which result in additional following &#8220;store&#8221; instructions. On most machines, these instructions alter the condition code before there is time to test it. This problem doesn't arise for ordinary &#8220;test&#8221; and &#8220;compare&#8221; instructions because they don't have any output operands.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">For reasons similar to those described above, it is not possible to give an assembler instruction access to the condition code left by previous instructions.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><A name=Extended-asm-with-goto></A>As of GCC version 4.5,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm goto</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>may be used to have the assembly jump to one or more C labels. In this form, a fifth section after the clobber list contains a list of all C labels to which the assembly may jump. Each label operand is implicitly self-named. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is also assumed to fall through to the next statement.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">This form of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is restricted to not have outputs. This is due to a internal restriction in the compiler that control transfer instructions cannot have outputs. This restriction on<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm goto</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>may be lifted in some future version of the compiler. In the meantime,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm goto</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>may include a memory clobber, and so leave outputs in memory.</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     int frob(int x)
     {
       int y;
       asm goto ("frob %%r5, %1; jc %l[error]; mov (%2), %%r5"
                 : : "r"(x), "r"(&amp;y) : "r5", "memory" : error);
       return y;
      error:
       return -1;
     }
</PRE>
<P class=noindent style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">In this (inefficient) example, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>frob</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction sets the carry bit to indicate an error. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>jc</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction detects this and branches to the<CODE>error</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>label. Finally, the output of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>frob</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction (<CODE>%r5</CODE>) is stored into the memory for variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>y</CODE>, which is later read by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>return</CODE>statement.</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     void doit(void)
     {
       int i = 0;
       asm goto ("mfsr %%r1, 123; jmp %%r1;"
                 ".pushsection doit_table;"
                 ".long %l0, %l1, %l2, %l3;"
                 ".popsection"
                 : : : "r1" : label1, label2, label3, label4);
       __builtin_unreachable ();
     
      label1:
       f1();
       return;
      label2:
       f2();
       return;
      label3:
       i = 1;
      label4:
       f3(i);
     }
</PRE>
<P class=noindent style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">In this (also inefficient) example, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>mfsr</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction reads an address from some out-of-band machine register, and the following<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>jmp</CODE>instruction branches to that address. The address read by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>mfsr</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction is assumed to have been previously set via some application-specific mechanism to be one of the four values stored in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>doit_table</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>section. Finally, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is followed by a call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__builtin_unreachable</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to indicate that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not in fact fall through.</P><PRE class=smallexample style="FONT-SIZE: smaller; FONT-VARIANT: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(0,0,0); FONT-STYLE: normal; LETTER-SPACING: normal; LINE-HEIGHT: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">     #define TRACE1(NUM)                         \
       do {                                      \
         asm goto ("0: nop;"                     \
                   ".pushsection trace_table;"   \
                   ".long 0b, %l0;"              \
                   ".popsection"                 \
                   : : : : trace#NUM);           \
         if (0) { trace#NUM: trace(); }          \
       } while (0)
     #define TRACE  TRACE1(__COUNTER__)
</PRE>
<P class=noindent style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">In this example (which in fact inspired the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm goto</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>feature) we want on rare occasions to call the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>trace</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>function; on other occasions we'd like to keep the overhead to the absolute minimum. The normal code path consists of a single<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>nop</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction. However, we record the address of this<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>nop</CODE>together with the address of a label that calls the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>trace</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>function. This allows the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>nop</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction to be patched at run time to be an unconditional branch to the stored label. It is assumed that an optimizing compiler moves the labeled block out of line, to optimize the fall through path from the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>.</P>
<P style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">If you are writing a header file that should be includable in ISO C programs, write<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__asm__</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Alternate-Keywords.html#Alternate-Keywords">Alternate Keywords</A>.