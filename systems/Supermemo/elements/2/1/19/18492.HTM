<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.39 An Inline Function is As Fast As a Macro</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-inline-functions-3056></A><A name=index-integrating-function-code-3057></A><A name=index-open-coding-3058></A><A name=index-macros_002c-inline-alternative-3059></A>By declaring a function inline, you can direct GCC to make calls to that function faster. One way GCC can achieve this is to integrate that function's code into the code for its callers. This makes execution faster by eliminating the function-call overhead; in addition, if any of the actual argument values are constant, their known values may permit simplifications at compile time so that not all of the inline function's code needs to be included. The effect on code size is less predictable; object code may be larger or smaller with function inlining, depending on the particular case. You can also direct GCC to try to integrate all &#8220;simple enough&#8221; functions into their callers with the option<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-finline-functions</SPAN></SAMP>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">GCC implements three different semantics of declaring a function inline. One is available with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-std=gnu89</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fgnu89-inline</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or when<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>gnu_inline</CODE>attribute is present on all inline declarations, another when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-std=c99</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-std=c11</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-std=gnu99</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-std=gnu11</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>(without<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fgnu89-inline</SPAN></SAMP>), and the third is used when compiling C++.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">To declare a function inline, use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword in its declaration, like this:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     static inline int
     inc (int *a)
     {
       return (*a)++;
     }
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">If you are writing a header file to be included in ISO C90 programs, write<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__inline__</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE>. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Alternate-Keywords.html#Alternate-Keywords">Alternate Keywords</A>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The three types of inlining behave similarly in two important cases: when the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword is used on a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>static</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>function, like the example above, and when a function is first declared without using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword and then is defined with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE>, like this:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     extern int inc (int *a);
     inline int
     inc (int *a)
     {
       return (*a)++;
     }
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In both of these common cases, the program behaves the same as if you had not used the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword, except for its speed.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-inline-functions_002c-omission-of-3060></A><A name=index-fkeep-inline-functions-3061></A>When a function is both inline and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>static</CODE>, if all calls to the function are integrated into the caller, and the function's address is never used, then the function's own assembler code is never referenced. In this case, GCC does not actually output assembler code for the function, unless you specify the option<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fkeep-inline-functions</SPAN></SAMP>. Some calls cannot be integrated for various reasons (in particular, calls that precede the function's definition cannot be integrated, and neither can recursive calls within the definition). If there is a nonintegrated call, then the function is compiled to assembler code as usual. The function must also be compiled as usual if the program refers to its address, because that can't be inlined.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-Winline-3062></A>Note that certain usages in a function definition can make it unsuitable for inline substitution. Among these usages are: variadic functions, use of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>alloca</CODE>, use of variable-length data types (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Variable-Length.html#Variable-Length">Variable Length</A>), use of computed goto (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Labels-as-Values.html#Labels-as-Values">Labels as Values</A>), use of nonlocal goto, and nested functions (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Nested-Functions.html#Nested-Functions">Nested Functions</A>). Using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Winline</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>warns when a function marked<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>could not be substituted, and gives the reason for the failure.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-automatic-_0040code_007binline_007d-for-C_002b_002b-member-fns-3063></A><A name=index-g_t_0040code_007binline_007d-automatic-for-C_002b_002b-member-fns-3064></A><A name=index-member-fns_002c-automatically-_0040code_007binline_007d-3065></A><A name=index-C_002b_002b-member-fns_002c-automatically-_0040code_007binline_007d-3066></A><A name=index-fno-default-inline-3067></A>As required by ISO C++, GCC considers member functions defined within the body of a class to be marked inline even if they are not explicitly declared with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword. You can override this with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-default-inline</SPAN></SAMP>; see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/C_002b_002b-Dialect-Options.html#C_002b_002b-Dialect-Options">Options Controlling C++ Dialect</A>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">GCC does not inline any functions when not optimizing unless you specify the &#8216;<SAMP><SPAN class=samp>always_inline</SPAN></SAMP>&#8217; attribute for the function, like this:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     /* <SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman>Prototype.</SPAN>  */
     inline void foo (const char) __attribute__((always_inline));
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The remainder of this section is specific to GNU C90 inlining.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-non-static-inline-function-3068></A>When an inline function is not<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>static</CODE>, then the compiler must assume that there may be calls from other source files; since a global symbol can be defined only once in any program, the function must not be defined in the other source files, so the calls therein cannot be integrated. Therefore, a non-<CODE>static</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>inline function is always compiled on its own in the usual fashion.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">If you specify both<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>extern</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the function definition, then the definition is used only for inlining. In no case is the function compiled on its own, not even if you refer to its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">This combination of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>extern</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>has almost the effect of a macro. The way to use it is to put a function definition in a header file with these keywords, and put another copy of the definition (lacking<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>extern</CODE>) in a library file. The definition in the header file causes most calls to the function to be inlined. If any uses of the function remain, they refer to the single copy in the library.