<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>6.41.2 i386 floating-point asm operands</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">On i386 targets, there are several rules on the usage of stack-like registers in the operands of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>. These rules apply only to the operands that are stack-like registers:</P>
<OL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" type=1>
<LI>Given a set of input registers that die in an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>, it is necessary to know which are implicitly popped by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>, and which must be explicitly popped by GCC.
<P>An input register that is implicitly popped by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>must be explicitly clobbered, unless it is constrained to match an output operand.</P></LI>
<LI>For any input register that is implicitly popped by an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>, it is necessary to know how to adjust the stack to compensate for the pop. If any non-popped input is closer to the top of the reg-stack than the implicitly popped register, it would not be possible to know what the stack looked like&#8212;it's not clear how the rest of the stack &#8220;slides up&#8221;.
<P>All implicitly popped input registers must be closer to the top of the reg-stack than any input that is not implicitly popped.</P>
<P>It is possible that if an input dies in an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>, the compiler might use the input register for an output reload. Consider this example:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          asm ("foo" : "=t" (a) : "f" (b));
</PRE>
<P class=noindent>This code says that input<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>b</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not popped by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>, and that the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>pushes a result onto the reg-stack, i.e., the stack is one deeper after the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>than it was before. But, it is possible that reload may think that it can use the same register for both the input and the output.</P>
<P>To prevent this from happening, if any input operand uses the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>constraint, all output register constraints must use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>&amp;</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>early-clobber modifier.</P>
<P>The example above would be correctly written as:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          asm ("foo" : "=&amp;t" (a) : "f" (b));
</PRE></LI>
<LI>Some operands need to be in particular places on the stack. All output operands fall in this category&#8212;GCC has no other way to know which registers the outputs appear in unless you indicate this in the constraints.
<P>Output operands must specifically indicate which register an output appears in after an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>=f</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not allowed: the operand constraints must select a class with a single register.</P></LI>
<LI>Output operands may not be &#8220;inserted&#8221; between existing stack registers. Since no 387 opcode uses a read/write operand, all output operands are dead before the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>, and are pushed by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>. It makes no sense to push anywhere but the top of the reg-stack.
<P>Output operands must start at the top of the reg-stack: output operands may not &#8220;skip&#8221; a register.</P></LI>
<LI>Some<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>statements may need extra stack space for internal calculations. This can be guaranteed by clobbering stack registers unrelated to the inputs and outputs.</LI></OL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Here are a couple of reasonable<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE>s to want to write. This<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes one input, which is internally popped, and produces two outputs.</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     asm ("fsincos" : "=t" (cos), "=u" (sin) : "0" (inp));
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=noindent>This<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes two inputs, which are popped by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fyl2xp1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>opcode, and replaces them with one output. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>st(1)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>clobber is necessary for the compiler to know that<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fyl2xp1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>pops both inputs.</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     asm ("fyl2xp1" : "=t" (result) : "0" (x), "u" (y) : "st(1)");</PRE>