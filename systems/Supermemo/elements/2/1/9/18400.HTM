<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>3.17.44 SPARC Options</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-SPARC-options-2418></A>These &#8216;<SAMP><SPAN class=samp>-m</SPAN></SAMP>&#8217; options are supported on the SPARC:</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><CODE>-mno-app-regs</CODE></DT>
<DT><CODE>-mapp-regs</CODE></DT>
<DD><A name=index-mno-app-regs-2419></A><A name=index-mapp-regs-2420></A>Specify<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mapp-regs</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to generate output using the global registers 2 through 4, which the SPARC SVR4 ABI reserves for applications. Like the global register 1, each global register 2 through 4 is then treated as an allocable register that is clobbered by function calls. This is the default.
<P>To be fully SVR4 ABI-compliant at the cost of some performance loss, specify<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mno-app-regs</SPAN></SAMP>. You should compile libraries and system software with this option.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-mflat</CODE></DT>
<DT><CODE>-mno-flat</CODE></DT>
<DD><A name=index-mflat-2421></A><A name=index-mno-flat-2422></A>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mflat</SPAN></SAMP>, the compiler does not generate save/restore instructions and uses a &#8220;flat&#8221; or single register window model. This model is compatible with the regular register window model. The local registers and the input registers (0&#8211;5) are still treated as &#8220;call-saved&#8221; registers and are saved on the stack as needed.
<P>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mno-flat</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>(the default), the compiler generates save/restore instructions (except for leaf functions). This is the normal operating mode.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-mfpu</CODE></DT>
<DT><CODE>-mhard-float</CODE></DT>
<DD><A name=index-mfpu-2423></A><A name=index-mhard-float-2424></A>Generate output containing floating-point instructions. This is the default.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mno-fpu</CODE></DT>
<DT><CODE>-msoft-float</CODE></DT>
<DD><A name=index-mno-fpu-2425></A><A name=index-msoft-float-2426></A>Generate output containing library calls for floating point.<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>Warning:</STRONG><SPAN class=Apple-converted-space>&nbsp;</SPAN>the requisite libraries are not available for all SPARC targets. Normally the facilities of the machine's usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation. The embedded targets &#8216;<SAMP><SPAN class=samp>sparc-*-aout</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>sparclite-*-*</SPAN></SAMP>&#8217; do provide software floating-point support.
<P><SAMP><SPAN class=option>-msoft-float</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>changes the calling convention in the output file; therefore, it is only useful if you compile<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>all</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of a program with this option. In particular, you need to compile<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>libgcc.a</SPAN></SAMP>, the library that comes with GCC, with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-msoft-float</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>in order for this to work.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-mhard-quad-float</CODE></DT>
<DD><A name=index-mhard-quad-float-2427></A>Generate output containing quad-word (long double) floating-point instructions.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-msoft-quad-float</CODE></DT>
<DD><A name=index-msoft-quad-float-2428></A>Generate output containing library calls for quad-word (long double) floating-point instructions. The functions called are those specified in the SPARC ABI. This is the default.
<P>As of this writing, there are no SPARC implementations that have hardware support for the quad-word floating-point instructions. They all invoke a trap handler for one of these instructions, and then the trap handler emulates the effect of the instruction. Because of the trap handler overhead, this is much slower than calling the ABI library routines. Thus the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-msoft-quad-float</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option is the default.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-mno-unaligned-doubles</CODE></DT>
<DT><CODE>-munaligned-doubles</CODE></DT>
<DD><A name=index-mno-unaligned-doubles-2429></A><A name=index-munaligned-doubles-2430></A>Assume that doubles have 8-byte alignment. This is the default.
<P>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-munaligned-doubles</SPAN></SAMP>, GCC assumes that doubles have 8-byte alignment only if they are contained in another type, or if they have an absolute address. Otherwise, it assumes they have 4-byte alignment. Specifying this option avoids some rare compatibility problems with code generated by other compilers. It is not the default because it results in a performance loss, especially for floating-point code.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-muser-mode</CODE></DT>
<DT><CODE>-mno-user-mode</CODE></DT>
<DD><A name=index-muser-mode-2431></A><A name=index-mno-user-mode-2432></A>Do not generate code that can only run in supervisor mode. This is relevant only for the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>casa</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction emitted for the LEON3 processor. The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mno-user-mode</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mno-faster-structs</CODE></DT>
<DT><CODE>-mfaster-structs</CODE></DT>
<DD><A name=index-mno-faster-structs-2433></A><A name=index-mfaster-structs-2434></A>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mfaster-structs</SPAN></SAMP>, the compiler assumes that structures should have 8-byte alignment. This enables the use of pairs of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>ldd</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>std</CODE>instructions for copies in structure assignment, in place of twice as many<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>ld</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>st</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>pairs. However, the use of this changed alignment directly violates the SPARC ABI. Thus, it's intended only for use on targets where the developer acknowledges that their resulting code is not directly in line with the rules of the ABI.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mcpu=</CODE><VAR>cpu_type</VAR></DT>
<DD><A name=index-mcpu-2435></A>Set the instruction set, register set, and instruction scheduling parameters for machine type<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>cpu_type</VAR>. Supported values for<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>cpu_type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>are &#8216;<SAMP><SPAN class=samp>v7</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>cypress</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>v8</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>supersparc</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>hypersparc</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>leon</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>leon3</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>sparclite</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>f930</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>f934</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>sparclite86x</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>sparclet</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>tsc701</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>v9</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>ultrasparc</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>ultrasparc3</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>niagara</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>niagara2</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>niagara3</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>niagara4</SPAN></SAMP>&#8217;.
<P>Native Solaris and GNU/Linux toolchains also support the value &#8216;<SAMP><SPAN class=samp>native</SPAN></SAMP>&#8217;, which selects the best architecture option for the host processor.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=native</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>has no effect if GCC does not recognize the processor.</P>
<P>Default instruction scheduling parameters are used for values that select an architecture and not an implementation. These are &#8216;<SAMP><SPAN class=samp>v7</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>v8</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>sparclite</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>sparclet</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>v9</SPAN></SAMP>&#8217;.</P>
<P>Here is a list of each supported architecture and their supported implementations.</P>
<DL>
<DT>v7</DT>
<DD>cypress<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>v8</DT>
<DD>supersparc, hypersparc, leon, leon3<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>sparclite</DT>
<DD>f930, f934, sparclite86x<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>sparclet</DT>
<DD>tsc701<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>v9</DT>
<DD>ultrasparc, ultrasparc3, niagara, niagara2, niagara3, niagara4</DD></DL>
<P>By default (unless configured otherwise), GCC generates code for the V7 variant of the SPARC architecture. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=cypress</SPAN></SAMP>, the compiler additionally optimizes it for the Cypress CY7C602 chip, as used in the SPARCStation/SPARCServer 3xx series. This is also appropriate for the older SPARCStation 1, 2, IPX etc.</P>
<P>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=v8</SPAN></SAMP>, GCC generates code for the V8 variant of the SPARC architecture. The only difference from V7 code is that the compiler emits the integer multiply and integer divide instructions which exist in SPARC-V8 but not in SPARC-V7. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=supersparc</SPAN></SAMP>, the compiler additionally optimizes it for the SuperSPARC chip, as used in the SPARCStation 10, 1000 and 2000 series.</P>
<P>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=sparclite</SPAN></SAMP>, GCC generates code for the SPARClite variant of the SPARC architecture. This adds the integer multiply, integer divide step and scan (<CODE>ffs</CODE>) instructions which exist in SPARClite but not in SPARC-V7. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=f930</SPAN></SAMP>, the compiler additionally optimizes it for the Fujitsu MB86930 chip, which is the original SPARClite, with no FPU. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=f934</SPAN></SAMP>, the compiler additionally optimizes it for the Fujitsu MB86934 chip, which is the more recent SPARClite with FPU.</P>
<P>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=sparclet</SPAN></SAMP>, GCC generates code for the SPARClet variant of the SPARC architecture. This adds the integer multiply, multiply/accumulate, integer divide step and scan (<CODE>ffs</CODE>) instructions which exist in SPARClet but not in SPARC-V7. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=tsc701</SPAN></SAMP>, the compiler additionally optimizes it for the TEMIC SPARClet chip.</P>
<P>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=v9</SPAN></SAMP>, GCC generates code for the V9 variant of the SPARC architecture. This adds 64-bit integer and floating-point move instructions, 3 additional floating-point condition code registers and conditional move instructions. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=ultrasparc</SPAN></SAMP>, the compiler additionally optimizes it for the Sun UltraSPARC I/II/IIi chips. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=ultrasparc3</SPAN></SAMP>, the compiler additionally optimizes it for the Sun UltraSPARC III/III+/IIIi/IIIi+/IV/IV+ chips. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=niagara</SPAN></SAMP>, the compiler additionally optimizes it for Sun UltraSPARC T1 chips. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=niagara2</SPAN></SAMP>, the compiler additionally optimizes it for Sun UltraSPARC T2 chips. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=niagara3</SPAN></SAMP>, the compiler additionally optimizes it for Sun UltraSPARC T3 chips. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=niagara4</SPAN></SAMP>, the compiler additionally optimizes it for Sun UltraSPARC T4 chips.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-mtune=</CODE><VAR>cpu_type</VAR></DT>
<DD><A name=index-mtune-2436></A>Set the instruction scheduling parameters for machine type<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>cpu_type</VAR>, but do not set the instruction set or register set that the option<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=</SPAN><VAR>cpu_type</VAR></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>does.
<P>The same values for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcpu=</SPAN><VAR>cpu_type</VAR></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be used for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mtune=</SPAN><VAR>cpu_type</VAR></SAMP>, but the only useful values are those that select a particular CPU implementation. Those are &#8216;<SAMP><SPAN class=samp>cypress</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>supersparc</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>hypersparc</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>leon</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>leon3</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>f930</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>f934</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>sparclite86x</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>tsc701</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>ultrasparc</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>ultrasparc3</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>niagara</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>niagara2</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>niagara3</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>niagara4</SPAN></SAMP>&#8217;. With native Solaris and GNU/Linux toolchains, &#8216;<SAMP><SPAN class=samp>native</SPAN></SAMP>&#8217; can also be used.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-mv8plus</CODE></DT>
<DT><CODE>-mno-v8plus</CODE></DT>
<DD><A name=index-mv8plus-2437></A><A name=index-mno-v8plus-2438></A>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mv8plus</SPAN></SAMP>, GCC generates code for the SPARC-V8+ ABI. The difference from the V8 ABI is that the global and out registers are considered 64 bits wide. This is enabled by default on Solaris in 32-bit mode for all SPARC-V9 processors.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mvis</CODE></DT>
<DT><CODE>-mno-vis</CODE></DT>
<DD><A name=index-mvis-2439></A><A name=index-mno-vis-2440></A>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mvis</SPAN></SAMP>, GCC generates code that takes advantage of the UltraSPARC Visual Instruction Set extensions. The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mno-vis</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mvis2</CODE></DT>
<DT><CODE>-mno-vis2</CODE></DT>
<DD><A name=index-mvis2-2441></A><A name=index-mno-vis2-2442></A>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mvis2</SPAN></SAMP>, GCC generates code that takes advantage of version 2.0 of the UltraSPARC Visual Instruction Set extensions. The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mvis2</SPAN></SAMP>when targeting a cpu that supports such instructions, such as UltraSPARC-III and later. Setting<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mvis2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>also sets<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mvis</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mvis3</CODE></DT>
<DT><CODE>-mno-vis3</CODE></DT>
<DD><A name=index-mvis3-2443></A><A name=index-mno-vis3-2444></A>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mvis3</SPAN></SAMP>, GCC generates code that takes advantage of version 3.0 of the UltraSPARC Visual Instruction Set extensions. The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mvis3</SPAN></SAMP>when targeting a cpu that supports such instructions, such as niagara-3 and later. Setting<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mvis3</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>also sets<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mvis2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mvis</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mcbcond</CODE></DT>
<DT><CODE>-mno-cbcond</CODE></DT>
<DD><A name=index-mcbcond-2445></A><A name=index-mno-cbcond-2446></A>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcbcond</SPAN></SAMP>, GCC generates code that takes advantage of compare-and-branch instructions, as defined in the Sparc Architecture 2011. The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mcbcond</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>when targeting a cpu that supports such instructions, such as niagara-4 and later.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mpopc</CODE></DT>
<DT><CODE>-mno-popc</CODE></DT>
<DD><A name=index-mpopc-2447></A><A name=index-mno-popc-2448></A>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mpopc</SPAN></SAMP>, GCC generates code that takes advantage of the UltraSPARC population count instruction. The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mpopc</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>when targeting a cpu that supports such instructions, such as Niagara-2 and later.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mfmaf</CODE></DT>
<DT><CODE>-mno-fmaf</CODE></DT>
<DD><A name=index-mfmaf-2449></A><A name=index-mno-fmaf-2450></A>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mfmaf</SPAN></SAMP>, GCC generates code that takes advantage of the UltraSPARC Fused Multiply-Add Floating-point extensions. The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mfmaf</SPAN></SAMP>when targeting a cpu that supports such instructions, such as Niagara-3 and later.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mfix-at697f</CODE></DT>
<DD><A name=index-mfix-at697f-2451></A>Enable the documented workaround for the single erratum of the Atmel AT697F processor (which corresponds to erratum #13 of the AT697E processor).<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mfix-ut699</CODE></DT>
<DD><A name=index-mfix-ut699-2452></A>Enable the documented workarounds for the floating-point errata and the data cache nullify errata of the UT699 processor.</DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">These &#8216;<SAMP><SPAN class=samp>-m</SPAN></SAMP>&#8217; options are supported in addition to the above on SPARC-V9 processors in 64-bit environments:</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><CODE>-m32</CODE></DT>
<DT><CODE>-m64</CODE></DT>
<DD><A name=index-m32-2453></A><A name=index-m64-2454></A>Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mcmodel=</CODE><VAR>which</VAR></DT>
<DD><A name=index-mcmodel-2455></A>Set the code model to one of
<DL>
<DT>&#8216;<SAMP><SPAN class=samp>medlow</SPAN></SAMP>&#8217;</DT>
<DD>The Medium/Low code model: 64-bit addresses, programs must be linked in the low 32 bits of memory. Programs can be statically or dynamically linked.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>&#8216;<SAMP><SPAN class=samp>medmid</SPAN></SAMP>&#8217;</DT>
<DD>The Medium/Middle code model: 64-bit addresses, programs must be linked in the low 44 bits of memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>&#8216;<SAMP><SPAN class=samp>medany</SPAN></SAMP>&#8217;</DT>
<DD>The Medium/Anywhere code model: 64-bit addresses, programs may be linked anywhere in memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>&#8216;<SAMP><SPAN class=samp>embmedany</SPAN></SAMP>&#8217;</DT>
<DD>The Medium/Anywhere code model for embedded systems: 64-bit addresses, the text and data segments must be less than 2GB in size, both starting anywhere in memory (determined at link time). The global register %g4 points to the base of the data segment. Programs are statically linked and PIC is not supported.</DD></DL><BR></DD>
<DT><CODE>-mmemory-model=</CODE><VAR>mem-model</VAR></DT>
<DD><A name=index-mmemory-model-2456></A>Set the memory model in force on the processor to one of
<DL>
<DT>&#8216;<SAMP><SPAN class=samp>default</SPAN></SAMP>&#8217;</DT>
<DD>The default memory model for the processor and operating system.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>&#8216;<SAMP><SPAN class=samp>rmo</SPAN></SAMP>&#8217;</DT>
<DD>Relaxed Memory Order<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>&#8216;<SAMP><SPAN class=samp>pso</SPAN></SAMP>&#8217;</DT>
<DD>Partial Store Order<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>&#8216;<SAMP><SPAN class=samp>tso</SPAN></SAMP>&#8217;</DT>
<DD>Total Store Order<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>&#8216;<SAMP><SPAN class=samp>sc</SPAN></SAMP>&#8217;</DT>
<DD>Sequential Consistency</DD></DL>
<P>These memory models are formally defined in Appendix D of the Sparc V9 architecture manual, as set in the processor's<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>PSTATE.MM</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>field.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-mstack-bias</CODE></DT>
<DT><CODE>-mno-stack-bias</CODE></DT>
<DD><A name=index-mstack-bias-2457></A><A name=index-mno-stack-bias-2458></A>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mstack-bias</SPAN></SAMP>, GCC assumes that the stack pointer, and frame pointer if present, are offset by &#8722;2047 which must be added back when making stack frame references. This is the default in 64-bit mode. Otherwise, assume no such offset is present.</DD></DL>