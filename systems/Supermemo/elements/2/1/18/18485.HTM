<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.37 Specifying Attributes of Types</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-attribute-of-types-3047></A><A name=index-type-attributes-3048></A>The keyword<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__attribute__</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>allows you to specify special attributes of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>types when you define such types. This keyword is followed by an attribute specification inside double parentheses. Seven attributes are currently defined for types:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>aligned</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>packed</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>transparent_union</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>unused</CODE>,<CODE>deprecated</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>visibility</CODE>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>may_alias</CODE>. Other attributes are defined for functions (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Function-Attributes.html#Function-Attributes">Function Attributes</A>) and for variables (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Variable-Attributes.html#Variable-Attributes">Variable Attributes</A>).</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">You may also specify any one of these attributes with &#8216;<SAMP><SPAN class=samp>__</SPAN></SAMP>&#8217; preceding and following its keyword. This allows you to use these attributes in header files without being concerned about a possible macro of the same name. For example, you may use<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__aligned__</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>aligned</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">You may specify type attributes in an enum, struct or union type declaration or definition, or for other types in a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>typedef</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>declaration.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">For an enum, struct or union type, you may specify attributes either between the enum, struct or union tag and the name of the type, or just past the closing curly brace of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>definition</EM>. The former syntax is preferred.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Attribute-Syntax.html#Attribute-Syntax">Attribute Syntax</A>, for details of the exact syntax for using attributes.<A name=index-g_t_0040code_007baligned_007d-attribute-3049></A></P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><CODE>aligned (</CODE><VAR>alignment</VAR><CODE>)</CODE></DT>
<DD>This attribute specifies a minimum alignment (in bytes) for variables of the specified type. For example, the declarations:<PRE style="FONT-SIZE: smaller" class=smallexample>          struct S { short f[3]; } __attribute__ ((aligned (8)));
          typedef int more_aligned_int __attribute__ ((aligned (8)));
</PRE>
<P class=noindent>force the compiler to ensure (as far as it can) that each variable whose type is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct S</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>more_aligned_int</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is allocated and aligned<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>at least</EM>on a 8-byte boundary. On a SPARC, having all variables of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct S</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>aligned to 8-byte boundaries allows the compiler to use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>ldd</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<CODE>std</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(doubleword load and store) instructions when copying one variable of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct S</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to another, thus improving run-time efficiency.</P>
<P>Note that the alignment of any given<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>type is required by the ISO C standard to be at least a perfect multiple of the lowest common multiple of the alignments of all of the members of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in question. This means that you<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>can</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>effectively adjust the alignment of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>type by attaching an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>aligned</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute to any one of the members of such a type, but the notation illustrated in the example above is a more obvious, intuitive, and readable way to request the compiler to adjust the alignment of an entire<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union</CODE>type.</P>
<P>As in the preceding example, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<CODE>union</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>type. Alternatively, you can leave out the alignment factor and just ask the compiler to align a type to the maximum useful alignment for the target machine you are compiling for. For example, you could write:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          struct S { short f[3]; } __attribute__ ((aligned));
</PRE>
<P>Whenever you leave out the alignment factor in an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>aligned</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute specification, the compiler automatically sets the alignment for the type to the largest alignment that is ever used for any data type on the target machine you are compiling for. Doing this can often make copy operations more efficient, because the compiler can use whatever instructions copy the biggest chunks of memory when performing copies to or from the variables that have types that you have aligned this way.</P>
<P>In the example above, if the size of each<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>short</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is 2 bytes, then the size of the entire<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct S</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>type is 6 bytes. The smallest power of two that is greater than or equal to that is 8, so the compiler sets the alignment for the entire<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct S</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>type to 8 bytes.</P>
<P>Note that although you can ask the compiler to select a time-efficient alignment for a given type and then declare only individual stand-alone objects of that type, the compiler's ability to select a time-efficient alignment is primarily useful only when you plan to create arrays of variables having the relevant (efficiently aligned) type. If you declare or use arrays of variables of an efficiently-aligned type, then it is likely that your program also does pointer arithmetic (or subscripting, which amounts to the same thing) on pointers to the relevant type, and the code that the compiler generates for these pointer arithmetic operations is often more efficient for efficiently-aligned types than for other types.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>aligned</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute can only increase the alignment; but you can decrease it by specifying<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>packed</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>as well. See below.</P>
<P>Note that the effectiveness of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>aligned</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attributes may be limited by inherent limitations in your linker. On many systems, the linker is only able to arrange for variables to be aligned up to a certain maximum alignment. (For some linkers, the maximum supported alignment may be very very small.) If your linker is only able to align variables up to a maximum of 8-byte alignment, then specifying<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>aligned(16)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in an<CODE>__attribute__</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>still only provides you with 8-byte alignment. See your linker documentation for further information.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>packed</CODE></DT>
<DD>This attribute, attached to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>type definition, specifies that each member (other than zero-width bit-fields) of the structure or union is placed to minimize the memory required. When attached to an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>enum</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>definition, it indicates that the smallest integral type should be used.
<P><A name=index-fshort-enums-3050></A>Specifying this attribute for<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>types is equivalent to specifying the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>packed</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute on each of the structure or union members. Specifying the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fshort-enums</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>flag on the line is equivalent to specifying the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>packed</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute on all<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>enum</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>definitions.</P>
<P>In the following example<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct my_packed_struct</CODE>'s members are packed closely together, but the internal layout of its<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>s</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>member is not packed&#8212;to do that,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct my_unpacked_struct</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>needs to be packed too.</P><PRE style="FONT-SIZE: smaller" class=smallexample>          struct my_unpacked_struct
           {
              char c;
              int i;
           };
          
          struct __attribute__ ((__packed__)) my_packed_struct
            {
               char c;
               int  i;
               struct my_unpacked_struct s;
            };
</PRE>
<P>You may only specify this attribute on the definition of an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>enum</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union</CODE>, not on a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>typedef</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>that does not also define the enumerated type, structure or union.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>transparent_union</CODE></DT>
<DD>This attribute, attached to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>type definition, indicates that any function parameter having that union type causes calls to that function to be treated in a special way.
<P>First, the argument corresponding to a transparent union type can be of any type in the union; no cast is required. Also, if the union contains a pointer type, the corresponding argument can be a null pointer constant or a void pointer expression; and if the union contains a void pointer type, the corresponding argument can be any pointer expression. If the union member type is a pointer, qualifiers like<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>const</CODE>on the referenced type must be respected, just as with normal pointer conversions.</P>
<P>Second, the argument is passed to the function using the calling conventions of the first member of the transparent union, not the calling conventions of the union itself. All members of the union must have the same machine representation; this is necessary for this argument passing to work properly.</P>
<P>Transparent unions are designed for library functions that have multiple interfaces for compatibility reasons. For example, suppose the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wait</CODE>function must accept either a value of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int *</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to comply with POSIX, or a value of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union wait *</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to comply with the 4.1BSD interface. If<CODE>wait</CODE>'s parameter were<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>void *</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wait</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>would accept both kinds of arguments, but it would also accept any other pointer type and this would make argument type checking less useful. Instead,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>&lt;sys/wait.h&gt;</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>might define the interface as follows:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          typedef union __attribute__ ((__transparent_union__))
            {
              int *__ip;
              union wait *__up;
            } wait_status_ptr_t;
          
          pid_t wait (wait_status_ptr_t);
</PRE>
<P class=noindent>This interface allows either<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int *</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union wait *</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>arguments to be passed, using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int *</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>calling convention. The program can call<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wait</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>with arguments of either type:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          int w1 () { int w; return wait (&amp;w); }
          int w2 () { union wait w; return wait (&amp;w); }
</PRE>
<P class=noindent>With this interface,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>wait</CODE>'s implementation might look like this:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          pid_t wait (wait_status_ptr_t p)
          {
            return waitpid (-1, p.__ip, 0);
          }
</PRE><BR></DD>
<DT><CODE>unused</CODE></DT>
<DD>When attached to a type (including a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct</CODE>), this attribute means that variables of that type are meant to appear possibly unused. GCC does not produce a warning for any variables of that type, even if the variable appears to do nothing. This is often the case with lock or thread classes, which are usually defined and then not referenced, but contain constructors and destructors that have nontrivial bookkeeping functions.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>deprecated</CODE></DT>
<DT><CODE>deprecated (</CODE><VAR>msg</VAR><CODE>)</CODE></DT>
<DD>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>deprecated</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute results in a warning if the type is used anywhere in the source file. This is useful when identifying types that are expected to be removed in a future version of a program. If possible, the warning also includes the location of the declaration of the deprecated type, to enable users to easily find further information about why the type is deprecated, or what they should do instead. Note that the warnings only occur for uses and then only if the type is being applied to an identifier that itself is not being declared as deprecated.<PRE style="FONT-SIZE: smaller" class=smallexample>          typedef int T1 __attribute__ ((deprecated));
          T1 x;
          typedef T1 T2;
          T2 y;
          typedef T1 T3 __attribute__ ((deprecated));
          T3 z __attribute__ ((deprecated));
</PRE>
<P class=noindent>results in a warning on line 2 and 3 but not lines 4, 5, or 6. No warning is issued for line 4 because T2 is not explicitly deprecated. Line 5 has no warning because T3 is explicitly deprecated. Similarly for line 6. The optional<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>msg</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument, which must be a string, is printed in the warning if present.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>deprecated</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute can also be used for functions and variables (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Function-Attributes.html#Function-Attributes">Function Attributes</A>, see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Variable-Attributes.html#Variable-Attributes">Variable Attributes</A>.)<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>may_alias</CODE></DT>
<DD>Accesses through pointers to types with this attribute are not subject to type-based alias analysis, but are instead assumed to be able to alias any other type of objects. In the context of section 6.5 paragraph 7 of the C99 standard, an lvalue expression dereferencing such a pointer is treated like having a character type. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fstrict-aliasing</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>for more information on aliasing issues. This extension exists to support some vector APIs, in which pointers to one vector type are permitted to alias pointers to a different vector type.
<P>Note that an object of a type with this attribute does not have any special semantics.</P>
<P>Example of use:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          typedef short __attribute__((__may_alias__)) short_a;
          
          int
          main (void)
          {
            int a = 0x12345678;
            short_a *b = (short_a *) &amp;a;
          
            b[1] = 0;
          
            if (a == 0x12345678)
              abort();
          
            exit(0);
          }
</PRE>
<P class=noindent>If you replaced<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>short_a</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>short</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the variable declaration, the above program would abort when compiled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fstrict-aliasing</SPAN></SAMP>, which is on by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or above in recent GCC versions.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>visibility</CODE></DT>
<DD>In C++, attribute visibility (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Function-Attributes.html#Function-Attributes">Function Attributes</A>) can also be applied to class, struct, union and enum types. Unlike other type attributes, the attribute must appear between the initial keyword and the name of the type; it cannot appear after the body of the type.
<P>Note that the type visibility is applied to vague linkage entities associated with the class (vtable, typeinfo node, etc.). In particular, if a class is thrown as an exception in one shared object and caught in another, the class must have default visibility. Otherwise the two shared objects are unable to use the same typeinfo node and exception handling will break.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">To specify multiple attributes, separate them by commas within the double parentheses: for example, &#8216;<SAMP><SPAN class=samp>__attribute__ ((aligned (16), packed))</SPAN></SAMP>&#8217;.