<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.10 Complex Numbers</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-complex-numbers-2686></A><A name=index-g_t_0040code_007b_005fComplex_007d-keyword-2687></A><A name=index-g_t_0040code_007b_005f_005fcomplex_005f_005f_007d-keyword-2688></A>ISO C99 supports complex floating data types, and as an extension GCC supports them in C90 mode and in C++. GCC also supports complex integer data types which are not part of ISO C99. You can declare complex types using the keyword<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>_Complex</CODE>. As an extension, the older GNU keyword<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__complex__</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is also supported.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">For example, &#8216;<SAMP><SPAN class=samp>_Complex double x;</SPAN></SAMP>&#8217; declares<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>x</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a variable whose real part and imaginary part are both of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>double</CODE>. &#8216;<SAMP><SPAN class=samp>_Complex short int y;</SPAN></SAMP>&#8217; declares<CODE>y</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to have real and imaginary parts of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>short int</CODE>; this is not likely to be useful, but it shows that the set of complex types is complete.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">To write a constant with a complex data type, use the suffix &#8216;<SAMP><SPAN class=samp>i</SPAN></SAMP>&#8217; or &#8216;<SAMP><SPAN class=samp>j</SPAN></SAMP>&#8217; (either one; they are equivalent). For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>2.5fi</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>has type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>_Complex float</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>3i</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>has type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>_Complex int</CODE>. Such a constant always has a pure imaginary value, but you can form any complex value you like by adding one to a real constant. This is a GNU extension; if you have an ISO C99 conforming C library (such as the GNU C Library), and want to construct complex constants of floating type, you should include<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>&lt;complex.h&gt;</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and use the macros<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>I</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>_Complex_I</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-g_t_0040code_007b_005f_005freal_005f_005f_007d-keyword-2689></A><A name=index-g_t_0040code_007b_005f_005fimag_005f_005f_007d-keyword-2690></A>To extract the real part of a complex-valued expression<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>exp</VAR>, write<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__real__<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>exp</VAR>. Likewise, use<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__imag__</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to extract the imaginary part. This is a GNU extension; for values of floating type, you should use the ISO C99 functions<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>crealf</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>creal</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>creall</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>cimagf</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>cimag</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>cimagl</CODE>, declared in<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>&lt;complex.h&gt;</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and also provided as built-in functions by GCC.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-complex-conjugation-2691></A>The operator &#8216;<SAMP><SPAN class=samp>~</SPAN></SAMP>&#8217; performs complex conjugation when used on a value with a complex type. This is a GNU extension; for values of floating type, you should use the ISO C99 functions<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>conjf</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>conj</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>conjl</CODE>, declared in<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>&lt;complex.h&gt;</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and also provided as built-in functions by GCC.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">GCC can allocate complex automatic variables in a noncontiguous fashion; it's even possible for the real part to be in a register while the imaginary part is on the stack (or vice versa). Only the DWARF 2 debug info format can represent this, so use of DWARF 2 is recommended. If you are using the stabs debug info format, GCC describes a noncontiguous complex variable as if it were two separate variables of noncomplex type. If the variable's actual name is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE>, the two fictitious variables are named<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo$real</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo$imag</CODE>. You can examine and set these two fictitious variables with your debugger.