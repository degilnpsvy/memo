<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>3.10 Options That Control Optimization</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-optimize-options-773></A><A name=index-options_002c-optimization-774></A>These options control various sorts of optimizations.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Without any optimization option, the compiler's goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independent: if you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you expect from the source code.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Turning on optimization flags makes the compiler attempt to improve the performance and/or code size at the expense of compilation time and possibly the ability to debug the program.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The compiler performs optimization based on the knowledge it has of the program. Compiling multiple files at once to a single output file mode allows the compiler to use information gained from all of the files when compiling each of them.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Not all optimizations are controlled directly by a flag. Only optimizations that have a flag are listed in this section.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Most optimizations are only enabled if an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>level is set on the command line. Otherwise they are disabled, even if individual optimization flags are specified.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Depending on the target and how GCC was configured, a slightly different set of optimizations may be enabled at each<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>level than those listed here. You can invoke GCC with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Q --help=optimizers</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to find out the exact set of optimizations that are enabled at each level. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Overall-Options.html#Overall-Options">Overall Options</A>, for examples.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><CODE>-O</CODE></DT>
<DT><CODE>-O1</CODE></DT>
<DD><A name=index-O-775></A><A name=index-O1-776></A>Optimize. Optimizing compilation takes somewhat more time, and a lot more memory for a large function.
<P>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>, the compiler tries to reduce code size and execution time, without performing any optimizations that take a great deal of compilation time.</P>
<P><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>turns on the following optimization flags:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          -fauto-inc-dec 
          -fcompare-elim 
          -fcprop-registers 
          -fdce 
          -fdefer-pop 
          -fdelayed-branch 
          -fdse 
          -fguess-branch-probability 
          -fif-conversion2 
          -fif-conversion 
          -fipa-pure-const 
          -fipa-profile 
          -fipa-reference 
          -fmerge-constants
          -fsplit-wide-types 
          -ftree-bit-ccp 
          -ftree-builtin-call-dce 
          -ftree-ccp 
          -ftree-ch 
          -ftree-copyrename 
          -ftree-dce 
          -ftree-dominator-opts 
          -ftree-dse 
          -ftree-forwprop 
          -ftree-fre 
          -ftree-phiprop 
          -ftree-slsr 
          -ftree-sra 
          -ftree-pta 
          -ftree-ter 
          -funit-at-a-time
</PRE>
<P><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>also turns on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fomit-frame-pointer</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>on machines where doing so does not interfere with debugging.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-O2</CODE></DT>
<DD><A name=index-O2-777></A>Optimize even more. GCC performs nearly all supported optimizations that do not involve a space-speed tradeoff. As compared to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>, this option increases both compilation time and the performance of the generated code.
<P><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>turns on all optimization flags specified by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>. It also turns on the following optimization flags:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          -fthread-jumps 
          -falign-functions  -falign-jumps 
          -falign-loops  -falign-labels 
          -fcaller-saves 
          -fcrossjumping 
          -fcse-follow-jumps  -fcse-skip-blocks 
          -fdelete-null-pointer-checks 
          -fdevirtualize -fdevirtualize-speculatively 
          -fexpensive-optimizations 
          -fgcse  -fgcse-lm  
          -fhoist-adjacent-loads 
          -finline-small-functions 
          -findirect-inlining 
          -fipa-sra 
          -fisolate-erroneous-paths-dereference 
          -foptimize-sibling-calls 
          -fpartial-inlining 
          -fpeephole2 
          -freorder-blocks  -freorder-functions 
          -frerun-cse-after-loop  
          -fsched-interblock  -fsched-spec 
          -fschedule-insns  -fschedule-insns2 
          -fstrict-aliasing -fstrict-overflow 
          -ftree-switch-conversion -ftree-tail-merge 
          -ftree-pre 
          -ftree-vrp
</PRE>
<P>Please note the warning under<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fgcse</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>about invoking<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>on programs that use computed gotos.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-O3</CODE></DT>
<DD><A name=index-O3-778></A>Optimize yet more.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>turns on all optimizations specified by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and also turns on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-finline-functions</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-funswitch-loops</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fpredictive-commoning</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fgcse-after-reload</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftree-loop-vectorize</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftree-slp-vectorize</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fvect-cost-model</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftree-partial-pre</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fipa-cp-clone</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>options.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-O0</CODE></DT>
<DD><A name=index-O0-779></A>Reduce compilation time and make debugging produce the expected results. This is the default.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-Os</CODE></DT>
<DD><A name=index-Os-780></A>Optimize for size.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>enables all<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>optimizations that do not typically increase code size. It also performs further optimizations designed to reduce code size.
<P><SAMP><SPAN class=option>-Os</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>disables the following optimization flags:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          -falign-functions  -falign-jumps  -falign-loops 
          -falign-labels  -freorder-blocks  -freorder-blocks-and-partition 
          -fprefetch-loop-arrays
</PRE><BR></DD>
<DT><CODE>-Ofast</CODE></DT>
<DD><A name=index-Ofast-781></A>Disregard strict standards compliance.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Ofast</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>enables all<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>optimizations. It also enables optimizations that are not valid for all standard-compliant programs. It turns on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffast-math</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the Fortran-specific<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-protect-parens</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fstack-arrays</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-Og</CODE></DT>
<DD><A name=index-Og-782></A>Optimize debugging experience.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Og</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>enables optimizations that do not interfere with debugging. It should be the optimization level of choice for the standard edit-compile-debug cycle, offering a reasonable level of optimization while maintaining fast compilation and a good debugging experience.
<P>If you use multiple<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>options, with or without level numbers, the last such option is the one that is effective.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Options of the form<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-f</SPAN><VAR>flag</VAR></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>specify machine-independent flags. Most flags have both positive and negative forms; the negative form of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffoo</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-foo</SPAN></SAMP>. In the table below, only one of the forms is listed&#8212;the one you typically use. You can figure out the other form by either removing &#8216;<SAMP><SPAN class=samp>no-</SPAN></SAMP>&#8217; or adding it.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The following options control specific optimizations. They are either activated by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>options or are related to ones that are. You can use the following flags in the rare cases when &#8220;fine-tuning&#8221; of optimizations to be performed is desired.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><CODE>-fno-defer-pop</CODE></DT>
<DD><A name=index-fno-defer-pop-783></A>Always pop the arguments to each function call as soon as that function returns. For machines that must pop arguments after a function call, the compiler normally lets arguments accumulate on the stack for several function calls and pops them all at once.
<P>Disabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fforward-propagate</CODE></DT>
<DD><A name=index-fforward-propagate-784></A>Perform a forward propagation pass on RTL. The pass tries to combine two instructions and checks if the result can be simplified. If loop unrolling is active, two passes are performed and the second is scheduled after loop unrolling.
<P>This option is enabled by default at optimization levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-ffp-contract=</CODE><VAR>style</VAR></DT>
<DD><A name=index-ffp-contract-785></A><SAMP><SPAN class=option>-ffp-contract=off</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>disables floating-point expression contraction.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffp-contract=fast</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>enables floating-point expression contraction such as forming of fused multiply-add operations if the target has native support for them.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffp-contract=on</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>enables floating-point expression contraction if allowed by the language standard. This is currently not implemented and treated equal to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffp-contract=off</SPAN></SAMP>.
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffp-contract=fast</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fomit-frame-pointer</CODE></DT>
<DD><A name=index-fomit-frame-pointer-786></A>Don't keep the frame pointer in a register for functions that don't need one. This avoids the instructions to save, set up and restore frame pointers; it also makes an extra register available in many functions.<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG>It also makes debugging impossible on some machines.</STRONG>
<P>On some machines, such as the VAX, this flag has no effect, because the standard calling sequence automatically handles the frame pointer and nothing is saved by pretending it doesn't exist. The machine-description macro<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>FRAME_POINTER_REQUIRED</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>controls whether a target machine supports this flag. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gccint/Registers.html#Registers">Register Usage</A>.</P>
<P>Starting with GCC version 4.6, the default setting (when not optimizing for size) for 32-bit GNU/Linux x86 and 32-bit Darwin x86 targets has been changed to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fomit-frame-pointer</SPAN></SAMP>. The default can be reverted to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-omit-frame-pointer</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>by configuring GCC with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--enable-frame-pointer</SPAN></SAMP>configure option.</P>
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-foptimize-sibling-calls</CODE></DT>
<DD><A name=index-foptimize-sibling-calls-787></A>Optimize sibling and tail recursive calls.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fno-inline</CODE></DT>
<DD><A name=index-fno-inline-788></A>Do not expand any functions inline apart from those marked with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>always_inline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute. This is the default when not optimizing.
<P>Single functions can be exempted from inlining by marking them with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>noinline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-finline-small-functions</CODE></DT>
<DD><A name=index-finline-small-functions-789></A>Integrate functions into their callers when their body is smaller than expected function call code (so overall size of program gets smaller). The compiler heuristically decides which functions are simple enough to be worth integrating in this way. This inlining applies to all functions, even those not declared inline.
<P>Enabled at level<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-findirect-inlining</CODE></DT>
<DD><A name=index-findirect-inlining-790></A>Inline also indirect calls that are discovered to be known at compile time thanks to previous inlining. This option has any effect only when inlining itself is turned on by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-finline-functions</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-finline-small-functions</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>options.
<P>Enabled at level<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-finline-functions</CODE></DT>
<DD><A name=index-finline-functions-791></A>Consider all functions for inlining, even if they are not declared inline. The compiler heuristically decides which functions are worth integrating in this way.
<P>If all calls to a given function are integrated, and the function is declared<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>static</CODE>, then the function is normally not output as assembler code in its own right.</P>
<P>Enabled at level<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-finline-functions-called-once</CODE></DT>
<DD><A name=index-finline-functions-called-once-792></A>Consider all<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>static</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>functions called once for inlining into their caller even if they are not marked<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE>. If a call to a given function is integrated, then the function is not output as assembler code in its own right.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O1</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fearly-inlining</CODE></DT>
<DD><A name=index-fearly-inlining-793></A>Inline functions marked by<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>always_inline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and functions whose body seems smaller than the function call overhead early before doing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-generate</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>instrumentation and real inlining pass. Doing so makes profiling significantly cheaper and usually inlining faster on programs having large chains of nested wrapper functions.
<P>Enabled by default.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fipa-sra</CODE></DT>
<DD><A name=index-fipa-sra-794></A>Perform interprocedural scalar replacement of aggregates, removal of unused parameters and replacement of parameters passed by reference by parameters passed by value.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-finline-limit=</CODE><VAR>n</VAR></DT>
<DD><A name=index-finline-limit-795></A>By default, GCC limits the size of functions that can be inlined. This flag allows coarse control of this limit.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the size of functions that can be inlined in number of pseudo instructions.
<P>Inlining is actually controlled by a number of parameters, which may be specified individually by using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param<SPAN class=Apple-converted-space>&nbsp;</SPAN></SPAN><VAR>name</VAR><SPAN class=option>=</SPAN><VAR>value</VAR></SAMP>. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-finline-limit=</SPAN><VAR>n</VAR></SAMP>option sets some of these parameters as follows:</P>
<DL>
<DT><CODE>max-inline-insns-single</CODE></DT>
<DD>is set to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR>/2.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-inline-insns-auto</CODE></DT>
<DD>is set to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR>/2.</DD></DL>
<P>See below for a documentation of the individual parameters controlling inlining and for the defaults of these parameters.</P>
<P><EM>Note:</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>there may be no value to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-finline-limit</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>that results in default behavior.</P>
<P><EM>Note:</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>pseudo instruction represents, in this particular context, an abstract measurement of function's size. In no way does it represent a count of assembly instructions and as such its exact meaning might change from one release to an another.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fno-keep-inline-dllexport</CODE></DT>
<DD><A name=index-g_t-fno-keep-inline-dllexport-796></A>This is a more fine-grained version of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fkeep-inline-functions</SPAN></SAMP>, which applies only to functions that are declared using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>dllexport</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute or declspec (See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Function-Attributes.html#Function-Attributes">Declaring Attributes of Functions</A>.)<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fkeep-inline-functions</CODE></DT>
<DD><A name=index-fkeep-inline-functions-797></A>In C, emit<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>static</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>functions that are declared<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>into the object file, even if the function has been inlined into all of its callers. This switch does not affect functions using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>extern inline</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>extension in GNU C90. In C++, emit any and all inline functions into the object file.<BR></DD>
<DT><CODE>-fkeep-static-consts</CODE></DT>
<DD><A name=index-fkeep-static-consts-798></A>Emit variables declared<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>static const</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>when optimization isn't turned on, even if the variables aren't referenced.
<P>GCC enables this option by default. If you want to force the compiler to check if a variable is referenced, regardless of whether or not optimization is turned on, use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-keep-static-consts</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fmerge-constants</CODE></DT>
<DD><A name=index-fmerge-constants-799></A>Attempt to merge identical constants (string constants and floating-point constants) across compilation units.
<P>This option is the default for optimized compilation if the assembler and linker support it. Use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-merge-constants</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to inhibit this behavior.</P>
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fmerge-all-constants</CODE></DT>
<DD><A name=index-fmerge-all-constants-800></A>Attempt to merge identical constants and identical variables.
<P>This option implies<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fmerge-constants</SPAN></SAMP>. In addition to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fmerge-constants</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>this considers e.g. even constant initialized arrays or initialized constant variables with integral or floating-point types. Languages like C or C++ require each variable, including multiple instances of the same variable in recursive calls, to have distinct locations, so using this option results in non-conforming behavior.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fmodulo-sched</CODE></DT>
<DD><A name=index-fmodulo-sched-801></A>Perform swing modulo scheduling immediately before the first scheduling pass. This pass looks at innermost loops and reorders their instructions by overlapping different iterations.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fmodulo-sched-allow-regmoves</CODE></DT>
<DD><A name=index-fmodulo-sched-allow-regmoves-802></A>Perform more aggressive SMS-based modulo scheduling with register moves allowed. By setting this flag certain anti-dependences edges are deleted, which triggers the generation of reg-moves based on the life-range analysis. This option is effective only with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fmodulo-sched</SPAN></SAMP>enabled.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fno-branch-count-reg</CODE></DT>
<DD><A name=index-fno-branch-count-reg-803></A>Do not use &#8220;decrement and branch&#8221; instructions on a count register, but instead generate a sequence of instructions that decrement a register, compare it against zero, then branch based upon the result. This option is only meaningful on architectures that support such instructions, which include x86, PowerPC, IA-64 and S/390.
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fbranch-count-reg</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fno-function-cse</CODE></DT>
<DD><A name=index-fno-function-cse-804></A>Do not put function addresses in registers; make each instruction that calls a constant function contain the function's address explicitly.
<P>This option results in less efficient code, but some strange hacks that alter the assembler output may be confused by the optimizations performed when this option is not used.</P>
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffunction-cse</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fno-zero-initialized-in-bss</CODE></DT>
<DD><A name=index-fno-zero-initialized-in-bss-805></A>If the target supports a BSS section, GCC by default puts variables that are initialized to zero into BSS. This can save space in the resulting code.
<P>This option turns off this behavior because some programs explicitly rely on variables going to the data section&#8212;e.g., so that the resulting executable can find the beginning of that section and/or make assumptions based on that.</P>
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fzero-initialized-in-bss</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fthread-jumps</CODE></DT>
<DD><A name=index-fthread-jumps-806></A>Perform optimizations that check to see if a jump branches to a location where another comparison subsumed by the first is found. If so, the first branch is redirected to either the destination of the second branch or a point immediately following it, depending on whether the condition is known to be true or false.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fsplit-wide-types</CODE></DT>
<DD><A name=index-fsplit-wide-types-807></A>When using a type that occupies multiple registers, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>long long</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>on a 32-bit system, split the registers apart and allocate them independently. This normally generates better code for those types, but may make debugging more difficult.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fcse-follow-jumps</CODE></DT>
<DD><A name=index-fcse-follow-jumps-808></A>In common subexpression elimination (CSE), scan through jump instructions when the target of the jump is not reached by any other path. For example, when CSE encounters an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>if</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>statement with an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>else</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>clause, CSE follows the jump when the condition tested is false.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fcse-skip-blocks</CODE></DT>
<DD><A name=index-fcse-skip-blocks-809></A>This is similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fcse-follow-jumps</SPAN></SAMP>, but causes CSE to follow jumps that conditionally skip over blocks. When CSE encounters a simple<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>if</CODE>statement with no else clause,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fcse-skip-blocks</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>causes CSE to follow the jump around the body of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>if</CODE>.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-frerun-cse-after-loop</CODE></DT>
<DD><A name=index-frerun-cse-after-loop-810></A>Re-run common subexpression elimination after loop optimizations are performed.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fgcse</CODE></DT>
<DD><A name=index-fgcse-811></A>Perform a global common subexpression elimination pass. This pass also performs global constant and copy propagation.
<P><EM>Note:</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>When compiling a program using computed gotos, a GCC extension, you may get better run-time performance if you disable the global common subexpression elimination pass by adding<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-gcse</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the command line.</P>
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fgcse-lm</CODE></DT>
<DD><A name=index-fgcse-lm-812></A>When<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fgcse-lm</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is enabled, global common subexpression elimination attempts to move loads that are only killed by stores into themselves. This allows a loop containing a load/store sequence to be changed to a load outside the loop, and a copy/store within the loop.
<P>Enabled by default when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fgcse</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is enabled.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fgcse-sm</CODE></DT>
<DD><A name=index-fgcse-sm-813></A>When<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fgcse-sm</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is enabled, a store motion pass is run after global common subexpression elimination. This pass attempts to move stores out of loops. When used in conjunction with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fgcse-lm</SPAN></SAMP>, loops containing a load/store sequence can be changed to a load before the loop and a store after the loop.
<P>Not enabled at any optimization level.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fgcse-las</CODE></DT>
<DD><A name=index-fgcse-las-814></A>When<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fgcse-las</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is enabled, the global common subexpression elimination pass eliminates redundant loads that come after stores to the same memory location (both partial and full redundancies).
<P>Not enabled at any optimization level.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fgcse-after-reload</CODE></DT>
<DD><A name=index-fgcse-after-reload-815></A>When<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fgcse-after-reload</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is enabled, a redundant load elimination pass is performed after reload. The purpose of this pass is to clean up redundant spilling.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-faggressive-loop-optimizations</CODE></DT>
<DD><A name=index-faggressive-loop-optimizations-816></A>This option tells the loop optimizer to use language constraints to derive bounds for the number of iterations of a loop. This assumes that loop code does not invoke undefined behavior by for example causing signed integer overflows or out-of-bound array accesses. The bounds for the number of iterations of a loop are used to guide loop unrolling and peeling and loop exit test optimizations. This option is enabled by default.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-funsafe-loop-optimizations</CODE></DT>
<DD><A name=index-funsafe-loop-optimizations-817></A>This option tells the loop optimizer to assume that loop indices do not overflow, and that loops with nontrivial exit condition are not infinite. This enables a wider range of loop optimizations even if the loop optimizer itself cannot prove that these assumptions are valid. If you use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Wunsafe-loop-optimizations</SPAN></SAMP>, the compiler warns you if it finds this kind of loop.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fcrossjumping</CODE></DT>
<DD><A name=index-fcrossjumping-818></A>Perform cross-jumping transformation. This transformation unifies equivalent code and saves code size. The resulting code may or may not perform better than without cross-jumping.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fauto-inc-dec</CODE></DT>
<DD><A name=index-fauto-inc-dec-819></A>Combine increments or decrements of addresses with memory accesses. This pass is always skipped on architectures that do not have instructions to support this. Enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher on architectures that support this.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fdce</CODE></DT>
<DD><A name=index-fdce-820></A>Perform dead code elimination (DCE) on RTL. Enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fdse</CODE></DT>
<DD><A name=index-fdse-821></A>Perform dead store elimination (DSE) on RTL. Enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fif-conversion</CODE></DT>
<DD><A name=index-fif-conversion-822></A>Attempt to transform conditional jumps into branch-less equivalents. This includes use of conditional moves, min, max, set flags and abs instructions, and some tricks doable by standard arithmetics. The use of conditional execution on chips where it is available is controlled by<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>if-conversion2</CODE>.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fif-conversion2</CODE></DT>
<DD><A name=index-fif-conversion2-823></A>Use conditional execution (where available) to transform conditional jumps into branch-less equivalents.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fdeclone-ctor-dtor</CODE></DT>
<DD><A name=index-fdeclone-ctor-dtor-824></A>The C++ ABI requires multiple entry points for constructors and destructors: one for a base subobject, one for a complete object, and one for a virtual destructor that calls operator delete afterwards. For a hierarchy with virtual bases, the base and complete variants are clones, which means two copies of the function. With this option, the base and complete variants are changed to be thunks that call a common implementation.
<P>Enabled by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fdelete-null-pointer-checks</CODE></DT>
<DD><A name=index-fdelete-null-pointer-checks-825></A>Assume that programs cannot safely dereference null pointers, and that no code or data element resides there. This enables simple constant folding optimizations at all optimization levels. In addition, other optimization passes in GCC use this flag to control global dataflow analyses that eliminate useless checks for null pointers; these assume that if a pointer is checked after it has already been dereferenced, it cannot be null.
<P>Note however that in some environments this assumption is not true. Use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-delete-null-pointer-checks</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to disable this optimization for programs that depend on that behavior.</P>
<P>Some targets, especially embedded ones, disable this option at all levels. Otherwise it is enabled at all levels:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O0</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O1</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>. Passes that use the information are enabled independently at different optimization levels.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fdevirtualize</CODE></DT>
<DD><A name=index-fdevirtualize-826></A>Attempt to convert calls to virtual functions to direct calls. This is done both within a procedure and interprocedurally as part of indirect inlining (<CODE>-findirect-inlining</CODE>) and interprocedural constant propagation (<SAMP><SPAN class=option>-fipa-cp</SPAN></SAMP>). Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fdevirtualize-speculatively</CODE></DT>
<DD><A name=index-fdevirtualize-speculatively-827></A>Attempt to convert calls to virtual functions to speculative direct calls. Based on the analysis of the type inheritance graph, determine for a given call the set of likely targets. If the set is small, preferably of size 1, change the call into an conditional deciding on direct and indirect call. The speculative calls enable more optimizations, such as inlining. When they seem useless after further optimization, they are converted back into original form.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fexpensive-optimizations</CODE></DT>
<DD><A name=index-fexpensive-optimizations-828></A>Perform a number of minor optimizations that are relatively expensive.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-free</CODE></DT>
<DD><A name=index-free-829></A>Attempt to remove redundant extension instructions. This is especially helpful for the x86-64 architecture, which implicitly zero-extends in 64-bit registers after writing to their lower 32-bit half.
<P>Enabled for Alpha, AArch64 and x86 at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-flive-range-shrinkage</CODE></DT>
<DD><A name=index-flive-range-shrinkage-830></A>Attempt to decrease register pressure through register live range shrinkage. This is helpful for fast processors with small or moderate size register sets.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fira-algorithm=</CODE><VAR>algorithm</VAR></DT>
<DD>Use the specified coloring algorithm for the integrated register allocator. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>algorithm</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument can be &#8216;<SAMP><SPAN class=samp>priority</SPAN></SAMP>&#8217;, which specifies Chow's priority coloring, or &#8216;<SAMP><SPAN class=samp>CB</SPAN></SAMP>&#8217;, which specifies Chaitin-Briggs coloring. Chaitin-Briggs coloring is not implemented for all architectures, but for those targets that do support it, it is the default because it generates better code.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fira-region=</CODE><VAR>region</VAR></DT>
<DD>Use specified regions for the integrated register allocator. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>region</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument should be one of the following:
<DL>
<DT>&#8216;<SAMP><SPAN class=samp>all</SPAN></SAMP>&#8217;</DT>
<DD>Use all loops as register allocation regions. This can give the best results for machines with a small and/or irregular register set.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>&#8216;<SAMP><SPAN class=samp>mixed</SPAN></SAMP>&#8217;</DT>
<DD>Use all loops except for loops with small register pressure as the regions. This value usually gives the best results in most cases and for most architectures, and is enabled by default when compiling with optimization for speed (<SAMP><SPAN class=option>-O</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SMALL class=dots>...</SMALL>).<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>&#8216;<SAMP><SPAN class=samp>one</SPAN></SAMP>&#8217;</DT>
<DD>Use all functions as a single region. This typically results in the smallest code size, and is enabled by default for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O0</SPAN></SAMP>.</DD></DL><BR></DD>
<DT><CODE>-fira-hoist-pressure</CODE></DT>
<DD><A name=index-fira-hoist-pressure-831></A>Use IRA to evaluate register pressure in the code hoisting pass for decisions to hoist expressions. This option usually results in smaller code, but it can slow the compiler down.
<P>This option is enabled at level<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>for all targets.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fira-loop-pressure</CODE></DT>
<DD><A name=index-fira-loop-pressure-832></A>Use IRA to evaluate register pressure in loops for decisions to move loop invariants. This option usually results in generation of faster and smaller code on machines with large register files (&gt;= 32 registers), but it can slow the compiler down.
<P>This option is enabled at level<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>for some targets.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fno-ira-share-save-slots</CODE></DT>
<DD><A name=index-fno-ira-share-save-slots-833></A>Disable sharing of stack slots used for saving call-used hard registers living through a call. Each hard register gets a separate stack slot, and as a result function stack frames are larger.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fno-ira-share-spill-slots</CODE></DT>
<DD><A name=index-fno-ira-share-spill-slots-834></A>Disable sharing of stack slots allocated for pseudo-registers. Each pseudo-register that does not get a hard register gets a separate stack slot, and as a result function stack frames are larger.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fira-verbose=</CODE><VAR>n</VAR></DT>
<DD><A name=index-fira-verbose-835></A>Control the verbosity of the dump file for the integrated register allocator. The default value is 5. If the value<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is greater or equal to 10, the dump output is sent to stderr using the same format as<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>minus 10.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fdelayed-branch</CODE></DT>
<DD><A name=index-fdelayed-branch-836></A>If supported for the target machine, attempt to reorder instructions to exploit instruction slots available after delayed branch instructions.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fschedule-insns</CODE></DT>
<DD><A name=index-fschedule-insns-837></A>If supported for the target machine, attempt to reorder instructions to eliminate execution stalls due to required data being unavailable. This helps machines that have slow floating point or memory load instructions by allowing other instructions to be issued until the result of the load or floating-point instruction is required.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fschedule-insns2</CODE></DT>
<DD><A name=index-fschedule-insns2-838></A>Similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns</SPAN></SAMP>, but requests an additional pass of instruction scheduling after register allocation has been done. This is especially useful on machines with a relatively small number of registers and where memory load instructions take more than one cycle.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fno-sched-interblock</CODE></DT>
<DD><A name=index-fno-sched-interblock-839></A>Don't schedule instructions across basic blocks. This is normally enabled by default when scheduling before register allocation, i.e. with<SAMP><SPAN class=option>-fschedule-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fno-sched-spec</CODE></DT>
<DD><A name=index-fno-sched-spec-840></A>Don't allow speculative motion of non-load instructions. This is normally enabled by default when scheduling before register allocation, i.e. with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsched-pressure</CODE></DT>
<DD><A name=index-fsched-pressure-841></A>Enable register pressure sensitive insn scheduling before register allocation. This only makes sense when scheduling before register allocation is enabled, i.e. with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or higher. Usage of this option can improve the generated code and decrease its size by preventing register pressure increase above the number of available hard registers and subsequent spills in register allocation.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsched-spec-load</CODE></DT>
<DD><A name=index-fsched-spec-load-842></A>Allow speculative motion of some load instructions. This only makes sense when scheduling before register allocation, i.e. with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsched-spec-load-dangerous</CODE></DT>
<DD><A name=index-fsched-spec-load-dangerous-843></A>Allow speculative motion of more load instructions. This only makes sense when scheduling before register allocation, i.e. with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsched-stalled-insns</CODE></DT>
<DT><CODE>-fsched-stalled-insns=</CODE><VAR>n</VAR></DT>
<DD><A name=index-fsched-stalled-insns-844></A>Define how many insns (if any) can be moved prematurely from the queue of stalled insns into the ready list during the second scheduling pass.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-sched-stalled-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>means that no insns are moved prematurely,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsched-stalled-insns=0</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>means there is no limit on how many queued insns can be moved prematurely.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsched-stalled-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>without a value is equivalent to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsched-stalled-insns=1</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsched-stalled-insns-dep</CODE></DT>
<DT><CODE>-fsched-stalled-insns-dep=</CODE><VAR>n</VAR></DT>
<DD><A name=index-fsched-stalled-insns-dep-845></A>Define how many insn groups (cycles) are examined for a dependency on a stalled insn that is a candidate for premature removal from the queue of stalled insns. This has an effect only during the second scheduling pass, and only if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsched-stalled-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-sched-stalled-insns-dep</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is equivalent to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsched-stalled-insns-dep=0</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsched-stalled-insns-dep</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>without a value is equivalent to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsched-stalled-insns-dep=1</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsched2-use-superblocks</CODE></DT>
<DD><A name=index-fsched2-use-superblocks-846></A>When scheduling after register allocation, use superblock scheduling. This allows motion across basic block boundaries, resulting in faster schedules. This option is experimental, as not all machine descriptions used by GCC model the CPU closely enough to avoid unreliable results from the algorithm.
<P>This only makes sense when scheduling after register allocation, i.e. with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fsched-group-heuristic</CODE></DT>
<DD><A name=index-fsched-group-heuristic-847></A>Enable the group heuristic in the scheduler. This heuristic favors the instruction that belongs to a schedule group. This is enabled by default when scheduling is enabled, i.e. with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsched-critical-path-heuristic</CODE></DT>
<DD><A name=index-fsched-critical-path-heuristic-848></A>Enable the critical-path heuristic in the scheduler. This heuristic favors instructions on the critical path. This is enabled by default when scheduling is enabled, i.e. with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsched-spec-insn-heuristic</CODE></DT>
<DD><A name=index-fsched-spec-insn-heuristic-849></A>Enable the speculative instruction heuristic in the scheduler. This heuristic favors speculative instructions with greater dependency weakness. This is enabled by default when scheduling is enabled, i.e. with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsched-rank-heuristic</CODE></DT>
<DD><A name=index-fsched-rank-heuristic-850></A>Enable the rank heuristic in the scheduler. This heuristic favors the instruction belonging to a basic block with greater size or frequency. This is enabled by default when scheduling is enabled, i.e. with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsched-last-insn-heuristic</CODE></DT>
<DD><A name=index-fsched-last-insn-heuristic-851></A>Enable the last-instruction heuristic in the scheduler. This heuristic favors the instruction that is less dependent on the last instruction scheduled. This is enabled by default when scheduling is enabled, i.e. with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsched-dep-count-heuristic</CODE></DT>
<DD><A name=index-fsched-dep-count-heuristic-852></A>Enable the dependent-count heuristic in the scheduler. This heuristic favors the instruction that has more instructions depending on it. This is enabled by default when scheduling is enabled, i.e. with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fschedule-insns2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-freschedule-modulo-scheduled-loops</CODE></DT>
<DD><A name=index-freschedule-modulo-scheduled-loops-853></A>Modulo scheduling is performed before traditional scheduling. If a loop is modulo scheduled, later scheduling passes may change its schedule. Use this option to control that behavior.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fselective-scheduling</CODE></DT>
<DD><A name=index-fselective-scheduling-854></A>Schedule instructions using selective scheduling algorithm. Selective scheduling runs instead of the first scheduler pass.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fselective-scheduling2</CODE></DT>
<DD><A name=index-fselective-scheduling2-855></A>Schedule instructions using selective scheduling algorithm. Selective scheduling runs instead of the second scheduler pass.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsel-sched-pipelining</CODE></DT>
<DD><A name=index-fsel-sched-pipelining-856></A>Enable software pipelining of innermost loops during selective scheduling. This option has no effect unless one of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fselective-scheduling</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fselective-scheduling2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is turned on.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsel-sched-pipelining-outer-loops</CODE></DT>
<DD><A name=index-fsel-sched-pipelining-outer-loops-857></A>When pipelining loops during selective scheduling, also pipeline outer loops. This option has no effect unless<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsel-sched-pipelining</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is turned on.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fshrink-wrap</CODE></DT>
<DD><A name=index-fshrink-wrap-858></A>Emit function prologues only before parts of the function that need it, rather than at the top of the function. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fcaller-saves</CODE></DT>
<DD><A name=index-fcaller-saves-859></A>Enable allocation of values to registers that are clobbered by function calls, by emitting extra instructions to save and restore the registers around such calls. Such allocation is done only when it seems to result in better code.
<P>This option is always enabled by default on certain machines, usually those which have no call-preserved registers to use instead.</P>
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fcombine-stack-adjustments</CODE></DT>
<DD><A name=index-fcombine-stack-adjustments-860></A>Tracks stack adjustments (pushes and pops) and stack memory references and then tries to find ways to combine them.
<P>Enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O1</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fconserve-stack</CODE></DT>
<DD><A name=index-fconserve-stack-861></A>Attempt to minimize stack usage. The compiler attempts to use less stack space, even if that makes the program slower. This option implies setting the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>large-stack-frame</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter to 100 and the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>large-stack-frame-growth</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter to 400.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-reassoc</CODE></DT>
<DD><A name=index-ftree-reassoc-862></A>Perform reassociation on trees. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-pre</CODE></DT>
<DD><A name=index-ftree-pre-863></A>Perform partial redundancy elimination (PRE) on trees. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-partial-pre</CODE></DT>
<DD><A name=index-ftree-partial-pre-864></A>Make partial redundancy elimination (PRE) more aggressive. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-forwprop</CODE></DT>
<DD><A name=index-ftree-forwprop-865></A>Perform forward propagation on trees. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-fre</CODE></DT>
<DD><A name=index-ftree-fre-866></A>Perform full redundancy elimination (FRE) on trees. The difference between FRE and PRE is that FRE only considers expressions that are computed on all paths leading to the redundant computation. This analysis is faster than PRE, though it exposes fewer redundancies. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-phiprop</CODE></DT>
<DD><A name=index-ftree-phiprop-867></A>Perform hoisting of loads from conditional pointers on trees. This pass is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fhoist-adjacent-loads</CODE></DT>
<DD><A name=index-hoist-adjacent-loads-868></A>Speculatively hoist loads from both branches of an if-then-else if the loads are from adjacent locations in the same structure and the target architecture has a conditional move instruction. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-copy-prop</CODE></DT>
<DD><A name=index-ftree-copy-prop-869></A>Perform copy propagation on trees. This pass eliminates unnecessary copy operations. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fipa-pure-const</CODE></DT>
<DD><A name=index-fipa-pure-const-870></A>Discover which functions are pure or constant. Enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fipa-reference</CODE></DT>
<DD><A name=index-fipa-reference-871></A>Discover which static variables do not escape the compilation unit. Enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fipa-pta</CODE></DT>
<DD><A name=index-fipa-pta-872></A>Perform interprocedural pointer analysis and interprocedural modification and reference analysis. This option can cause excessive memory and compile-time usage on large compilation units. It is not enabled by default at any optimization level.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fipa-profile</CODE></DT>
<DD><A name=index-fipa-profile-873></A>Perform interprocedural profile propagation. The functions called only from cold functions are marked as cold. Also functions executed once (such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>cold</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>noreturn</CODE>, static constructors or destructors) are identified. Cold functions and loop less parts of functions executed once are then optimized for size. Enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fipa-cp</CODE></DT>
<DD><A name=index-fipa-cp-874></A>Perform interprocedural constant propagation. This optimization analyzes the program to determine when values passed to functions are constants and then optimizes accordingly. This optimization can substantially increase performance if the application has constants passed to functions. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fipa-cp-clone</CODE></DT>
<DD><A name=index-fipa-cp-clone-875></A>Perform function cloning to make interprocedural constant propagation stronger. When enabled, interprocedural constant propagation performs function cloning when externally visible function can be called with constant arguments. Because this optimization can create multiple copies of functions, it may significantly increase code size (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param ipcp-unit-growth=</SPAN><VAR>value</VAR></SAMP>). This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fisolate-erroneous-paths-dereference</CODE></DT>
<DD>Detect paths which trigger erroneous or undefined behaviour due to dereferencing a NULL pointer. Isolate those paths from the main control flow and turn the statement with erroneous or undefined behaviour into a trap.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fisolate-erroneous-paths-attribute</CODE></DT>
<DD>Detect paths which trigger erroneous or undefined behaviour due a NULL value being used in a way which is forbidden by a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>returns_nonnull</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<CODE>nonnull</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute. Isolate those paths from the main control flow and turn the statement with erroneous or undefined behaviour into a trap. This is not currently enabled, but may be enabled by<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-O2</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the future.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-sink</CODE></DT>
<DD><A name=index-ftree-sink-876></A>Perform forward store motion on trees. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-bit-ccp</CODE></DT>
<DD><A name=index-ftree-bit-ccp-877></A>Perform sparse conditional bit constant propagation on trees and propagate pointer alignment information. This pass only operates on local scalar variables and is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher. It requires that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftree-ccp</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is enabled.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-ccp</CODE></DT>
<DD><A name=index-ftree-ccp-878></A>Perform sparse conditional constant propagation (CCP) on trees. This pass only operates on local scalar variables and is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-switch-conversion</CODE></DT>
<DD>Perform conversion of simple initializations in a switch to initializations from a scalar array. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-tail-merge</CODE></DT>
<DD>Look for identical code sequences. When found, replace one with a jump to the other. This optimization is known as tail merging or cross jumping. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher. The compilation time in this pass can be limited using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>max-tail-merge-comparisons</SPAN></SAMP>parameter and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>max-tail-merge-iterations</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-dce</CODE></DT>
<DD><A name=index-ftree-dce-879></A>Perform dead code elimination (DCE) on trees. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-builtin-call-dce</CODE></DT>
<DD><A name=index-ftree-builtin-call-dce-880></A>Perform conditional dead code elimination (DCE) for calls to built-in functions that may set<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>errno</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>but are otherwise side-effect free. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not also specified.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-dominator-opts</CODE></DT>
<DD><A name=index-ftree-dominator-opts-881></A>Perform a variety of simple scalar cleanups (constant/copy propagation, redundancy elimination, range propagation and expression simplification) based on a dominator tree traversal. This also performs jump threading (to reduce jumps to jumps). This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-dse</CODE></DT>
<DD><A name=index-ftree-dse-882></A>Perform dead store elimination (DSE) on trees. A dead store is a store into a memory location that is later overwritten by another store without any intervening loads. In this case the earlier store can be deleted. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-ch</CODE></DT>
<DD><A name=index-ftree-ch-883></A>Perform loop header copying on trees. This is beneficial since it increases effectiveness of code motion optimizations. It also saves one jump. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher. It is not enabled for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>, since it usually increases code size.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-loop-optimize</CODE></DT>
<DD><A name=index-ftree-loop-optimize-884></A>Perform loop optimizations on trees. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-loop-linear</CODE></DT>
<DD><A name=index-ftree-loop-linear-885></A>Perform loop interchange transformations on tree. Same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-floop-interchange</SPAN></SAMP>. To use this code transformation, GCC has to be configured with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--with-ppl</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--with-cloog</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to enable the Graphite loop transformation infrastructure.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-floop-interchange</CODE></DT>
<DD><A name=index-floop-interchange-886></A>Perform loop interchange transformations on loops. Interchanging two nested loops switches the inner and outer loops. For example, given a loop like:<PRE style="FONT-SIZE: smaller" class=smallexample>          DO J = 1, M
            DO I = 1, N
              A(J, I) = A(J, I) * C
            ENDDO
          ENDDO
</PRE>
<P>loop interchange transforms the loop as if it were written:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          DO I = 1, N
            DO J = 1, M
              A(J, I) = A(J, I) * C
            ENDDO
          ENDDO
</PRE>
<P>which can be beneficial when<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>N</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is larger than the caches, because in Fortran, the elements of an array are stored in memory contiguously by column, and the original loop iterates over rows, potentially creating at each access a cache miss. This optimization applies to all the languages supported by GCC and is not limited to Fortran. To use this code transformation, GCC has to be configured with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--with-ppl</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--with-cloog</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to enable the Graphite loop transformation infrastructure.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-floop-strip-mine</CODE></DT>
<DD><A name=index-floop-strip-mine-887></A>Perform loop strip mining transformations on loops. Strip mining splits a loop into two nested loops. The outer loop has strides equal to the strip size and the inner loop has strides of the original loop within a strip. The strip length can be changed using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>loop-block-tile-size</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter. For example, given a loop like:<PRE style="FONT-SIZE: smaller" class=smallexample>          DO I = 1, N
            A(I) = A(I) + C
          ENDDO
</PRE>
<P>loop strip mining transforms the loop as if it were written:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          DO II = 1, N, 51
            DO I = II, min (II + 50, N)
              A(I) = A(I) + C
            ENDDO
          ENDDO
</PRE>
<P>This optimization applies to all the languages supported by GCC and is not limited to Fortran. To use this code transformation, GCC has to be configured with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--with-ppl</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--with-cloog</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to enable the Graphite loop transformation infrastructure.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-floop-block</CODE></DT>
<DD><A name=index-floop-block-888></A>Perform loop blocking transformations on loops. Blocking strip mines each loop in the loop nest such that the memory accesses of the element loops fit inside caches. The strip length can be changed using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>loop-block-tile-size</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter. For example, given a loop like:<PRE style="FONT-SIZE: smaller" class=smallexample>          DO I = 1, N
            DO J = 1, M
              A(J, I) = B(I) + C(J)
            ENDDO
          ENDDO
</PRE>
<P>loop blocking transforms the loop as if it were written:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          DO II = 1, N, 51
            DO JJ = 1, M, 51
              DO I = II, min (II + 50, N)
                DO J = JJ, min (JJ + 50, M)
                  A(J, I) = B(I) + C(J)
                ENDDO
              ENDDO
            ENDDO
          ENDDO
</PRE>
<P>which can be beneficial when<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>M</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is larger than the caches, because the innermost loop iterates over a smaller amount of data which can be kept in the caches. This optimization applies to all the languages supported by GCC and is not limited to Fortran. To use this code transformation, GCC has to be configured with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--with-ppl</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--with-cloog</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to enable the Graphite loop transformation infrastructure.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fgraphite-identity</CODE></DT>
<DD><A name=index-fgraphite-identity-889></A>Enable the identity transformation for graphite. For every SCoP we generate the polyhedral representation and transform it back to gimple. Using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fgraphite-identity</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>we can check the costs or benefits of the GIMPLE -&gt; GRAPHITE -&gt; GIMPLE transformation. Some minimal optimizations are also performed by the code generator CLooG, like index splitting and dead code elimination in loops.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-floop-nest-optimize</CODE></DT>
<DD><A name=index-floop-nest-optimize-890></A>Enable the ISL based loop nest optimizer. This is a generic loop nest optimizer based on the Pluto optimization algorithms. It calculates a loop structure optimized for data-locality and parallelism. This option is experimental.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-floop-parallelize-all</CODE></DT>
<DD><A name=index-floop-parallelize-all-891></A>Use the Graphite data dependence analysis to identify loops that can be parallelized. Parallelize all the loops that can be analyzed to not contain loop carried dependences without checking that it is profitable to parallelize the loops.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fcheck-data-deps</CODE></DT>
<DD><A name=index-fcheck-data-deps-892></A>Compare the results of several data dependence analyzers. This option is used for debugging the data dependence analyzers.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-loop-if-convert</CODE></DT>
<DD>Attempt to transform conditional jumps in the innermost loops to branch-less equivalents. The intent is to remove control-flow from the innermost loops in order to improve the ability of the vectorization pass to handle these loops. This is enabled by default if vectorization is enabled.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-loop-if-convert-stores</CODE></DT>
<DD>Attempt to also if-convert conditional jumps containing memory writes. This transformation can be unsafe for multi-threaded programs as it transforms conditional memory writes into unconditional memory writes. For example,<PRE style="FONT-SIZE: smaller" class=smallexample>          for (i = 0; i &lt; N; i++)
            if (cond)
              A[i] = expr;
</PRE>
<P>is transformed to</P><PRE style="FONT-SIZE: smaller" class=smallexample>          for (i = 0; i &lt; N; i++)
            A[i] = cond ? expr : A[i];
</PRE>
<P>potentially producing data races.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-ftree-loop-distribution</CODE></DT>
<DD>Perform loop distribution. This flag can improve cache performance on big loop bodies and allow further loop optimizations, like parallelization or vectorization, to take place. For example, the loop<PRE style="FONT-SIZE: smaller" class=smallexample>          DO I = 1, N
            A(I) = B(I) + C
            D(I) = E(I) * F
          ENDDO
</PRE>
<P>is transformed to</P><PRE style="FONT-SIZE: smaller" class=smallexample>          DO I = 1, N
             A(I) = B(I) + C
          ENDDO
          DO I = 1, N
             D(I) = E(I) * F
          ENDDO
</PRE><BR></DD>
<DT><CODE>-ftree-loop-distribute-patterns</CODE></DT>
<DD>Perform loop distribution of patterns that can be code generated with calls to a library. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.
<P>This pass distributes the initialization loops and generates a call to memset zero. For example, the loop</P><PRE style="FONT-SIZE: smaller" class=smallexample>          DO I = 1, N
            A(I) = 0
            B(I) = A(I) + I
          ENDDO
</PRE>
<P>is transformed to</P><PRE style="FONT-SIZE: smaller" class=smallexample>          DO I = 1, N
             A(I) = 0
          ENDDO
          DO I = 1, N
             B(I) = A(I) + I
          ENDDO
</PRE>
<P>and the initialization loop is transformed into a call to memset zero.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-ftree-loop-im</CODE></DT>
<DD><A name=index-ftree-loop-im-893></A>Perform loop invariant motion on trees. This pass moves only invariants that are hard to handle at RTL level (function calls, operations that expand to nontrivial sequences of insns). With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-funswitch-loops</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>it also moves operands of conditions that are invariant out of the loop, so that we can use just trivial invariantness analysis in loop unswitching. The pass also includes store motion.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-loop-ivcanon</CODE></DT>
<DD><A name=index-ftree-loop-ivcanon-894></A>Create a canonical counter for number of iterations in loops for which determining number of iterations requires complicated analysis. Later optimizations then may determine the number easily. Useful especially in connection with unrolling.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fivopts</CODE></DT>
<DD><A name=index-fivopts-895></A>Perform induction variable optimizations (strength reduction, induction variable merging and induction variable elimination) on trees.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-parallelize-loops=n</CODE></DT>
<DD><A name=index-ftree-parallelize-loops-896></A>Parallelize loops, i.e., split their iteration space to run in n threads. This is only possible for loops whose iterations are independent and can be arbitrarily reordered. The optimization is only profitable on multiprocessor machines, for loops that are CPU-intensive, rather than constrained e.g. by memory bandwidth. This option implies<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-pthread</SPAN></SAMP>, and thus is only supported on targets that have support for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-pthread</SPAN></SAMP>.<BR></DD>
<DT><CODE>-ftree-pta</CODE></DT>
<DD><A name=index-ftree-pta-897></A>Perform function-local points-to analysis on trees. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-sra</CODE></DT>
<DD><A name=index-ftree-sra-898></A>Perform scalar replacement of aggregates. This pass replaces structure references with scalars to prevent committing structures to memory too early. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-copyrename</CODE></DT>
<DD><A name=index-ftree-copyrename-899></A>Perform copy renaming on trees. This pass attempts to rename compiler temporaries to other variables at copy locations, usually resulting in variable names which more closely resemble the original variables. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-coalesce-inlined-vars</CODE></DT>
<DD><A name=index-ftree-coalesce-inlined-vars-900></A>Tell the copyrename pass (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftree-copyrename</SPAN></SAMP>) to attempt to combine small user-defined variables too, but only if they were inlined from other functions. It is a more limited form of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftree-coalesce-vars</SPAN></SAMP>. This may harm debug information of such inlined variables, but it will keep variables of the inlined-into function apart from each other, such that they are more likely to contain the expected values in a debugging session. This was the default in GCC versions older than 4.7.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-coalesce-vars</CODE></DT>
<DD><A name=index-ftree-coalesce-vars-901></A>Tell the copyrename pass (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftree-copyrename</SPAN></SAMP>) to attempt to combine small user-defined variables too, instead of just compiler temporaries. This may severely limit the ability to debug an optimized program compiled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-var-tracking-assignments</SPAN></SAMP>. In the negated form, this flag prevents SSA coalescing of user variables, including inlined ones. This option is enabled by default.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-ter</CODE></DT>
<DD><A name=index-ftree-ter-902></A>Perform temporary expression replacement during the SSA-&gt;normal phase. Single use/single def temporaries are replaced at their use location with their defining expression. This results in non-GIMPLE code, but gives the expanders much more complex trees to work on resulting in better RTL generation. This is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-slsr</CODE></DT>
<DD><A name=index-ftree-slsr-903></A>Perform straight-line strength reduction on trees. This recognizes related expressions involving multiplications and replaces them by less expensive calculations when possible. This is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-vectorize</CODE></DT>
<DD><A name=index-ftree-vectorize-904></A>Perform vectorization on trees. This flag enables<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftree-loop-vectorize</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftree-slp-vectorize</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>if not explicitly specified.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-loop-vectorize</CODE></DT>
<DD><A name=index-ftree-loop-vectorize-905></A>Perform loop vectorization on trees. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftree-vectorize</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is enabled.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-slp-vectorize</CODE></DT>
<DD><A name=index-ftree-slp-vectorize-906></A>Perform basic block vectorization on trees. This flag is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftree-vectorize</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is enabled.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fvect-cost-model=</CODE><VAR>model</VAR></DT>
<DD><A name=index-fvect-cost-model-907></A>Alter the cost model used for vectorization. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>model</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument should be one of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>unlimited</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>dynamic</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>cheap</CODE>. With the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>unlimited</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>model the vectorized code-path is assumed to be profitable while with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>dynamic</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>model a runtime check will guard the vectorized code-path to enable it only for iteration counts that will likely execute faster than when executing the original scalar loop. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>cheap</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>model will disable vectorization of loops where doing so would be cost prohibitive for example due to required runtime checks for data dependence or alignment but otherwise is equal to the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>dynamic</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>model. The default cost model depends on other optimization flags and is either<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>dynamic</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>cheap</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsimd-cost-model=</CODE><VAR>model</VAR></DT>
<DD><A name=index-fsimd-cost-model-908></A>Alter the cost model used for vectorization of loops marked with the OpenMP or Cilk Plus simd directive. The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>model</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>argument should be one of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>unlimited</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>dynamic</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>cheap</CODE>. All values of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>model</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>have the same meaning as described in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fvect-cost-model</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and by default a cost model defined with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fvect-cost-model</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftree-vrp</CODE></DT>
<DD><A name=index-ftree-vrp-909></A>Perform Value Range Propagation on trees. This is similar to the constant propagation pass, but instead of values, ranges of values are propagated. This allows the optimizers to remove unnecessary range checks like array bound checks and null pointer checks. This is enabled by default at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and higher. Null pointer check elimination is only done if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fdelete-null-pointer-checks</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is enabled.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ftracer</CODE></DT>
<DD><A name=index-ftracer-910></A>Perform tail duplication to enlarge superblock size. This transformation simplifies the control flow of the function allowing other optimizations to do a better job.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-funroll-loops</CODE></DT>
<DD><A name=index-funroll-loops-911></A>Unroll loops whose number of iterations can be determined at compile time or upon entry to the loop.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-funroll-loops</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>implies<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-frerun-cse-after-loop</SPAN></SAMP>. This option makes code larger, and may or may not make it run faster.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-funroll-all-loops</CODE></DT>
<DD><A name=index-funroll-all-loops-912></A>Unroll all loops, even if their number of iterations is uncertain when the loop is entered. This usually makes programs run more slowly.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-funroll-all-loops</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>implies the same options as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-funroll-loops</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsplit-ivs-in-unroller</CODE></DT>
<DD><A name=index-fsplit-ivs-in-unroller-913></A>Enables expression of values of induction variables in later iterations of the unrolled loop using the value in the first iteration. This breaks long dependency chains, thus improving efficiency of the scheduling passes.
<P>A combination of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fweb</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and CSE is often sufficient to obtain the same effect. However, that is not reliable in cases where the loop body is more complicated than a single basic block. It also does not work at all on some architectures due to restrictions in the CSE pass.</P>
<P>This optimization is enabled by default.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fvariable-expansion-in-unroller</CODE></DT>
<DD><A name=index-fvariable-expansion-in-unroller-914></A>With this option, the compiler creates multiple copies of some local variables when unrolling a loop, which can result in superior code.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fpartial-inlining</CODE></DT>
<DD><A name=index-fpartial-inlining-915></A>Inline parts of functions. This option has any effect only when inlining itself is turned on by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-finline-functions</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-finline-small-functions</SPAN></SAMP>options.
<P>Enabled at level<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fpredictive-commoning</CODE></DT>
<DD><A name=index-fpredictive-commoning-916></A>Perform predictive commoning optimization, i.e., reusing computations (especially memory loads and stores) performed in previous iterations of loops.
<P>This option is enabled at level<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fprefetch-loop-arrays</CODE></DT>
<DD><A name=index-fprefetch-loop-arrays-917></A>If supported by the target machine, generate instructions to prefetch memory to improve the performance of loops that access large arrays.
<P>This option may generate better or worse code; results are highly dependent on the structure of loops within the source code.</P>
<P>Disabled at level<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fno-peephole</CODE></DT>
<DT><CODE>-fno-peephole2</CODE></DT>
<DD><A name=index-fno-peephole-918></A><A name=index-fno-peephole2-919></A>Disable any machine-specific peephole optimizations. The difference between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-peephole</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-peephole2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in how they are implemented in the compiler; some targets use one, some use the other, a few use both.
<P><SAMP><SPAN class=option>-fpeephole</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is enabled by default.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fpeephole2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fno-guess-branch-probability</CODE></DT>
<DD><A name=index-fno-guess-branch-probability-920></A>Do not guess branch probabilities using heuristics.
<P>GCC uses heuristics to guess branch probabilities if they are not provided by profiling feedback (<SAMP><SPAN class=option>-fprofile-arcs</SPAN></SAMP>). These heuristics are based on the control flow graph. If some branch probabilities are specified by &#8216;<SAMP><SPAN class=samp>__builtin_expect</SPAN></SAMP>&#8217;, then the heuristics are used to guess branch probabilities for the rest of the control flow graph, taking the &#8216;<SAMP><SPAN class=samp>__builtin_expect</SPAN></SAMP>&#8217; info into account. The interactions between the heuristics and &#8216;<SAMP><SPAN class=samp>__builtin_expect</SPAN></SAMP>&#8217; can be complex, and in some cases, it may be useful to disable the heuristics so that the effects of &#8216;<SAMP><SPAN class=samp>__builtin_expect</SPAN></SAMP>&#8217; are easier to understand.</P>
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fguess-branch-probability</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-freorder-blocks</CODE></DT>
<DD><A name=index-freorder-blocks-921></A>Reorder basic blocks in the compiled function in order to reduce number of taken branches and improve code locality.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-freorder-blocks-and-partition</CODE></DT>
<DD><A name=index-freorder-blocks-and-partition-922></A>In addition to reordering basic blocks in the compiled function, in order to reduce number of taken branches, partitions hot and cold basic blocks into separate sections of the assembly and .o files, to improve paging and cache locality performance.
<P>This optimization is automatically turned off in the presence of exception handling, for linkonce sections, for functions with a user-defined section attribute and on any architecture that does not support named sections.</P>
<P>Enabled for x86 at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-freorder-functions</CODE></DT>
<DD><A name=index-freorder-functions-923></A>Reorder functions in the object file in order to improve code locality. This is implemented by using special subsections<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>.text.hot</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>for most frequently executed functions and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>.text.unlikely</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>for unlikely executed functions. Reordering is done by the linker so object file format must support named sections and linker must place them in a reasonable way.
<P>Also profile feedback must be available to make this option effective. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-arcs</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>for details.</P>
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fstrict-aliasing</CODE></DT>
<DD><A name=index-fstrict-aliasing-924></A>Allow the compiler to assume the strictest aliasing rules applicable to the language being compiled. For C (and C++), this activates optimizations based on the type of expressions. In particular, an object of one type is assumed never to reside at the same address as an object of a different type, unless the types are almost the same. For example, an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>unsigned int</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>can alias an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE>, but not a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>void*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>double</CODE>. A character type may alias any other type.
<P><A name=Type-punning></A>Pay special attention to code like this:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          union a_union {
            int i;
            double d;
          };
          
          int f() {
            union a_union t;
            t.d = 3.0;
            return t.i;
          }
</PRE>
<P>The practice of reading from a different union member than the one most recently written to (called &#8220;type-punning&#8221;) is common. Even with<SAMP><SPAN class=option>-fstrict-aliasing</SPAN></SAMP>, type-punning is allowed, provided the memory is accessed through the union type. So, the code above works as expected. See<A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Structures-unions-enumerations-and-bit-fields-implementation.html#Structures-unions-enumerations-and-bit-fields-implementation">Structures unions enumerations and bit-fields implementation</A>. However, this code might not:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          int f() {
            union a_union t;
            int* ip;
            t.d = 3.0;
            ip = &amp;t.i;
            return *ip;
          }
</PRE>
<P>Similarly, access by taking the address, casting the resulting pointer and dereferencing the result has undefined behavior, even if the cast uses a union type, e.g.:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          int f() {
            double d = 3.0;
            return ((union a_union *) &amp;d)-&gt;i;
          }
</PRE>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fstrict-aliasing</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option is enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fstrict-overflow</CODE></DT>
<DD><A name=index-fstrict-overflow-925></A>Allow the compiler to assume strict signed overflow rules, depending on the language being compiled. For C (and C++) this means that overflow when doing arithmetic with signed numbers is undefined, which means that the compiler may assume that it does not happen. This permits various optimizations. For example, the compiler assumes that an expression like<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>i + 10 &gt; i</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is always true for signed<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>i</CODE>. This assumption is only valid if signed overflow is undefined, as the expression is false if<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>i + 10</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>overflows when using twos complement arithmetic. When this option is in effect any attempt to determine whether an operation on signed numbers overflows must be written carefully to not actually involve overflow.
<P>This option also allows the compiler to assume strict pointer semantics: given a pointer to an object, if adding an offset to that pointer does not produce a pointer to the same object, the addition is undefined. This permits the compiler to conclude that<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>p + u &gt; p</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is always true for a pointer<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>p</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and unsigned integer<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>u</CODE>. This assumption is only valid because pointer wraparound is undefined, as the expression is false if<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>p + u</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>overflows using twos complement arithmetic.</P>
<P>See also the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fwrapv</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option. Using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fwrapv</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>means that integer signed overflow is fully defined: it wraps. When<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fwrapv</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used, there is no difference between<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fstrict-overflow</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-strict-overflow</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>for integers. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fwrapv</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>certain types of overflow are permitted. For example, if the compiler gets an overflow when doing arithmetic on constants, the overflowed value can still be used with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fwrapv</SPAN></SAMP>, but not otherwise.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fstrict-overflow</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option is enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-falign-functions</CODE></DT>
<DT><CODE>-falign-functions=</CODE><VAR>n</VAR></DT>
<DD><A name=index-falign-functions-926></A>Align the start of functions to the next power-of-two greater than<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR>, skipping up to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>bytes. For instance,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-falign-functions=32</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>aligns functions to the next 32-byte boundary, but<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-falign-functions=24</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>aligns to the next 32-byte boundary only if this can be done by skipping 23 bytes or less.
<P><SAMP><SPAN class=option>-fno-align-functions</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-falign-functions=1</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>are equivalent and mean that functions are not aligned.</P>
<P>Some assemblers only support this flag when<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a power of two; in that case, it is rounded up.</P>
<P>If<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not specified or is zero, use a machine-dependent default.</P>
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-falign-labels</CODE></DT>
<DT><CODE>-falign-labels=</CODE><VAR>n</VAR></DT>
<DD><A name=index-falign-labels-927></A>Align all branch targets to a power-of-two boundary, skipping up to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>bytes like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-falign-functions</SPAN></SAMP>. This option can easily make code slower, because it must insert dummy operations for when the branch target is reached in the usual flow of the code.
<P><SAMP><SPAN class=option>-fno-align-labels</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-falign-labels=1</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>are equivalent and mean that labels are not aligned.</P>
<P>If<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-falign-loops</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-falign-jumps</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>are applicable and are greater than this value, then their values are used instead.</P>
<P>If<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not specified or is zero, use a machine-dependent default which is very likely to be &#8216;<SAMP><SPAN class=samp>1</SPAN></SAMP>&#8217;, meaning no alignment.</P>
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-falign-loops</CODE></DT>
<DT><CODE>-falign-loops=</CODE><VAR>n</VAR></DT>
<DD><A name=index-falign-loops-928></A>Align loops to a power-of-two boundary, skipping up to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>bytes like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-falign-functions</SPAN></SAMP>. If the loops are executed many times, this makes up for any execution of the dummy operations.
<P><SAMP><SPAN class=option>-fno-align-loops</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-falign-loops=1</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>are equivalent and mean that loops are not aligned.</P>
<P>If<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not specified or is zero, use a machine-dependent default.</P>
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-falign-jumps</CODE></DT>
<DT><CODE>-falign-jumps=</CODE><VAR>n</VAR></DT>
<DD><A name=index-falign-jumps-929></A>Align branch targets to a power-of-two boundary, for branch targets where the targets can only be reached by jumping, skipping up to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR>bytes like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-falign-functions</SPAN></SAMP>. In this case, no dummy operations need be executed.
<P><SAMP><SPAN class=option>-fno-align-jumps</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-falign-jumps=1</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>are equivalent and mean that loops are not aligned.</P>
<P>If<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not specified or is zero, use a machine-dependent default.</P>
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-funit-at-a-time</CODE></DT>
<DD><A name=index-funit-at-a-time-930></A>This option is left for compatibility reasons.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-funit-at-a-time</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>has no effect, while<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-unit-at-a-time</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>implies<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-toplevel-reorder</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-section-anchors</SPAN></SAMP>.
<P>Enabled by default.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fno-toplevel-reorder</CODE></DT>
<DD><A name=index-fno-toplevel-reorder-931></A>Do not reorder top-level functions, variables, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>statements. Output them in the same order that they appear in the input file. When this option is used, unreferenced static variables are not removed. This option is intended to support existing code that relies on a particular ordering. For new code, it is better to use attributes when possible.
<P>Enabled at level<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O0</SPAN></SAMP>. When disabled explicitly, it also implies<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-section-anchors</SPAN></SAMP>, which is otherwise enabled at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O0</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>on some targets.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fweb</CODE></DT>
<DD><A name=index-fweb-932></A>Constructs webs as commonly used for register allocation purposes and assign each web individual pseudo register. This allows the register allocation pass to operate on pseudos directly, but also strengthens several other optimization passes, such as CSE, loop optimizer and trivial dead code remover. It can, however, make debugging impossible, since variables no longer stay in a &#8220;home register&#8221;.
<P>Enabled by default with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-funroll-loops</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fwhole-program</CODE></DT>
<DD><A name=index-fwhole-program-933></A>Assume that the current compilation unit represents the whole program being compiled. All public functions and variables with the exception of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>main</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and those merged by attribute<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>externally_visible</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>become static functions and in effect are optimized more aggressively by interprocedural optimizers.
<P>This option should not be used in combination with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-flto</CODE>. Instead relying on a linker plugin should provide safer and more precise information.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-flto[=</CODE><VAR>n</VAR><CODE>]</CODE></DT>
<DD><A name=index-flto-934></A>This option runs the standard link-time optimizer. When invoked with source code, it generates GIMPLE (one of GCC's internal representations) and writes it to special ELF sections in the object file. When the object files are linked together, all the function bodies are read from these ELF sections and instantiated as if they had been part of the same translation unit.
<P>To use the link-time optimizer,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-flto</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and optimization options should be specified at compile time and during the final link. For example:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          gcc -c -O2 -flto foo.c
          gcc -c -O2 -flto bar.c
          gcc -o myprog -flto -O2 foo.o bar.o
</PRE>
<P>The first two invocations to GCC save a bytecode representation of GIMPLE into special ELF sections inside<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>foo.o</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>bar.o</SPAN></SAMP>. The final invocation reads the GIMPLE bytecode from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>foo.o</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>bar.o</SPAN></SAMP>, merges the two files into a single internal image, and compiles the result as usual. Since both<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>foo.o</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>bar.o</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>are merged into a single image, this causes all the interprocedural analyses and optimizations in GCC to work across the two files as if they were a single one. This means, for example, that the inliner is able to inline functions in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>bar.o</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>into functions in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>foo.o</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and vice-versa.</P>
<P>Another (simpler) way to enable link-time optimization is:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          gcc -o myprog -flto -O2 foo.c bar.c
</PRE>
<P>The above generates bytecode for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>foo.c</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>bar.c</SPAN></SAMP>, merges them together into a single GIMPLE representation and optimizes them as usual to produce<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>myprog</SPAN></SAMP>.</P>
<P>The only important thing to keep in mind is that to enable link-time optimizations you need to use the GCC driver to perform the link-step. GCC then automatically performs link-time optimization if any of the objects involved were compiled with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-flto</SPAN></SAMP>. You generally should specify the optimization options to be used for link-time optimization though GCC will try to be clever at guessing an optimization level to use from the options used at compile-time if you fail to specify one at link-time. You can always override the automatic decision to do link-time optimization at link-time by passing<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-lto</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the link command.</P>
<P>To make whole program optimization effective, it is necessary to make certain whole program assumptions. The compiler needs to know what functions and variables can be accessed by libraries and runtime outside of the link-time optimized unit. When supported by the linker, the linker plugin (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fuse-linker-plugin</SPAN></SAMP>) passes information to the compiler about used and externally visible symbols. When the linker plugin is not available,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fwhole-program</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>should be used to allow the compiler to make these assumptions, which leads to more aggressive optimization decisions.</P>
<P>When<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fuse-linker-plugin</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not enabled then, when a file is compiled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-flto</SPAN></SAMP>, the generated object file is larger than a regular object file because it contains GIMPLE bytecodes and the usual final code (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffat-lto-objects</SPAN></SAMP>. This means that object files with LTO information can be linked as normal object files; if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-lto</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is passed to the linker, no interprocedural optimizations are applied. Note that when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-fat-lto-objects</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is enabled the compile-stage is faster but you cannot perform a regular, non-LTO link on them.</P>
<P>Additionally, the optimization flags used to compile individual files are not necessarily related to those used at link time. For instance,</P><PRE style="FONT-SIZE: smaller" class=smallexample>          gcc -c -O0 -ffat-lto-objects -flto foo.c
          gcc -c -O0 -ffat-lto-objects -flto bar.c
          gcc -o myprog -O3 foo.o bar.o
</PRE>
<P>This produces individual object files with unoptimized assembler code, but the resulting binary<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>myprog</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is optimized at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>. If, instead, the final binary is generated with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-lto</SPAN></SAMP>, then<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>myprog</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not optimized.</P>
<P>When producing the final binary, GCC only applies link-time optimizations to those files that contain bytecode. Therefore, you can mix and match object files and libraries with GIMPLE bytecodes and final object code. GCC automatically selects which files to optimize in LTO mode and which files to link without further processing.</P>
<P>There are some code generation flags preserved by GCC when generating bytecodes, as they need to be used during the final link stage. Generally options specified at link-time override those specified at compile-time.</P>
<P>If you do not specify an optimization level option<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>at link-time then GCC will compute one based on the optimization levels used when compiling the object files. The highest optimization level will win here.</P>
<P>Currently, the following options and their setting are take from the first object file that explicitely specified it:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fPIC</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fpic</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fpie</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fcommon</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fexceptions</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fnon-call-exceptions</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fgnu-tm</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and all the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-m</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>target flags.</P>
<P>Certain ABI changing flags are required to match in all compilation-units and trying to override this at link-time with a conflicting value is ignored. This includes options such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-freg-struct-return</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fpcc-struct-return</SPAN></SAMP>.</P>
<P>Other options such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffp-contract</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-strict-overflow</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fwrapv</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-trapv</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-strict-aliasing</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>are passed through to the link stage and merged conservatively for conflicting translation units. Specifically<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-strict-overflow</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fwrapv</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-trapv</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>take precedence and for example<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffp-contract=off</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>takes precedence over<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffp-contract=fast</SPAN></SAMP>. You can override them at linke-time.</P>
<P>It is recommended that you compile all the files participating in the same link with the same options and also specify those options at link time.</P>
<P>If LTO encounters objects with C linkage declared with incompatible types in separate translation units to be linked together (undefined behavior according to ISO C99 6.2.7), a non-fatal diagnostic may be issued. The behavior is still undefined at run time. Similar diagnostics may be raised for other languages.</P>
<P>Another feature of LTO is that it is possible to apply interprocedural optimizations on files written in different languages:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          gcc -c -flto foo.c
          g++ -c -flto bar.cc
          gfortran -c -flto baz.f90
          g++ -o myprog -flto -O3 foo.o bar.o baz.o -lgfortran
</PRE>
<P>Notice that the final link is done with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>g++</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to get the C++ runtime libraries and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-lgfortran</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is added to get the Fortran runtime libraries. In general, when mixing languages in LTO mode, you should use the same link command options as when mixing languages in a regular (non-LTO) compilation.</P>
<P>If object files containing GIMPLE bytecode are stored in a library archive, say<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>libfoo.a</SPAN></SAMP>, it is possible to extract and use them in an LTO link if you are using a linker with plugin support. To create static libraries suitable for LTO, use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>gcc-ar</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>gcc-ranlib</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>instead of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>ar</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<CODE>ranlib</CODE>; to show the symbols of object files with GIMPLE bytecode, use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>gcc-nm</SPAN></SAMP>. Those commands require that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>ar</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>ranlib</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>nm</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>have been compiled with plugin support. At link time, use the the flag<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fuse-linker-plugin</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to ensure that the library participates in the LTO optimization process:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          gcc -o myprog -O2 -flto -fuse-linker-plugin a.o b.o -lfoo
</PRE>
<P>With the linker plugin enabled, the linker extracts the needed GIMPLE files from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>libfoo.a</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and passes them on to the running GCC to make them part of the aggregated GIMPLE image to be optimized.</P>
<P>If you are not using a linker with plugin support and/or do not enable the linker plugin, then the objects inside<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>libfoo.a</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>are extracted and linked as usual, but they do not participate in the LTO optimization process. In order to make a static library suitable for both LTO optimization and usual linkage, compile its object files with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-flto</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-ffat-lto-objects</CODE>.</P>
<P>Link-time optimizations do not require the presence of the whole program to operate. If the program does not require any symbols to be exported, it is possible to combine<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-flto</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fwhole-program</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to allow the interprocedural optimizers to use more aggressive assumptions which may lead to improved optimization opportunities. Use of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fwhole-program</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not needed when linker plugin is active (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fuse-linker-plugin</SPAN></SAMP>).</P>
<P>The current implementation of LTO makes no attempt to generate bytecode that is portable between different types of hosts. The bytecode files are versioned and there is a strict version check, so bytecode files generated in one version of GCC will not work with an older or newer version of GCC.</P>
<P>Link-time optimization does not work well with generation of debugging information. Combining<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-flto</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-g</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is currently experimental and expected to produce unexpected results.</P>
<P>If you specify the optional<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR>, the optimization and code generation done at link time is executed in parallel using<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>parallel jobs by utilizing an installed<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>make</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>program. The environment variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=env>MAKE</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>may be used to override the program used. The default value for<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is 1.</P>
<P>You can also specify<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-flto=jobserver</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to use GNU make's job server mode to determine the number of parallel jobs. This is useful when the Makefile calling GCC is already executing in parallel. You must prepend a &#8216;<SAMP><SPAN class=samp>+</SPAN></SAMP>&#8217; to the command recipe in the parent Makefile for this to work. This option likely only works if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=env>MAKE</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is GNU make.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-flto-partition=</CODE><VAR>alg</VAR></DT>
<DD><A name=index-flto-partition-935></A>Specify the partitioning algorithm used by the link-time optimizer. The value is either<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>1to1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to specify a partitioning mirroring the original source files or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>balanced</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to specify partitioning into equally sized chunks (whenever possible) or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>max</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to create new partition for every symbol where possible. Specifying<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>none</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>as an algorithm disables partitioning and streaming completely. The default value is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>balanced</CODE>. While<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>1to1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be used as an workaround for various code ordering issues, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>max</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>partitioning is intended for internal testing only.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-flto-compression-level=</CODE><VAR>n</VAR></DT>
<DD>This option specifies the level of compression used for intermediate language written to LTO object files, and is only meaningful in conjunction with LTO mode (<SAMP><SPAN class=option>-flto</SPAN></SAMP>). Valid values are 0 (no compression) to 9 (maximum compression). Values outside this range are clamped to either 0 or 9. If the option is not given, a default balanced compression setting is used.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-flto-report</CODE></DT>
<DD>Prints a report with internal details on the workings of the link-time optimizer. The contents of this report vary from version to version. It is meant to be useful to GCC developers when processing object files in LTO mode (via<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-flto</SPAN></SAMP>).
<P>Disabled by default.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-flto-report-wpa</CODE></DT>
<DD>Like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-flto-report</SPAN></SAMP>, but only print for the WPA phase of Link Time Optimization.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fuse-linker-plugin</CODE></DT>
<DD>Enables the use of a linker plugin during link-time optimization. This option relies on plugin support in the linker, which is available in gold or in GNU ld 2.21 or newer.
<P>This option enables the extraction of object files with GIMPLE bytecode out of library archives. This improves the quality of optimization by exposing more code to the link-time optimizer. This information specifies what symbols can be accessed externally (by non-LTO object or during dynamic linking). Resulting code quality improvements on binaries (and shared libraries that use hidden visibility) are similar to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-fwhole-program</CODE>. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-flto</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>for a description of the effect of this flag and how to use it.</P>
<P>This option is enabled by default when LTO support in GCC is enabled and GCC was configured for use with a linker supporting plugins (GNU ld 2.21 or newer or gold).<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-ffat-lto-objects</CODE></DT>
<DD><A name=index-ffat-lto-objects-936></A>Fat LTO objects are object files that contain both the intermediate language and the object code. This makes them usable for both LTO linking and normal linking. This option is effective only when compiling with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-flto</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and is ignored at link time.
<P><SAMP><SPAN class=option>-fno-fat-lto-objects</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>improves compilation time over plain LTO, but requires the complete toolchain to be aware of LTO. It requires a linker with linker plugin support for basic functionality. Additionally,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>nm</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>ar</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>ranlib</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>need to support linker plugins to allow a full-featured build environment (capable of building static libraries etc). GCC provides the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>gcc-ar</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>gcc-nm</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>gcc-ranlib</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>wrappers to pass the right options to these tools. With non fat LTO makefiles need to be modified to use them.</P>
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-fat-lto-objects</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>on targets with linker plugin support.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fcompare-elim</CODE></DT>
<DD><A name=index-fcompare-elim-937></A>After register allocation and post-register allocation instruction splitting, identify arithmetic instructions that compute processor flags similar to a comparison operation based on that arithmetic. If possible, eliminate the explicit comparison operation.
<P>This pass only applies to certain targets that cannot explicitly represent the comparison operation before register allocation is complete.</P>
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fuse-ld=bfd</CODE></DT>
<DD><A name=index-fuse-ld_003dbfd-938></A>Use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>bfd</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>linker instead of the default linker.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fuse-ld=gold</CODE></DT>
<DD><A name=index-fuse-ld_003dgold-939></A>Use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>gold</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>linker instead of the default linker.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fcprop-registers</CODE></DT>
<DD><A name=index-fcprop-registers-940></A>After register allocation and post-register allocation instruction splitting, perform a copy-propagation pass to try to reduce scheduling dependencies and occasionally eliminate the copy.
<P>Enabled at levels<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fprofile-correction</CODE></DT>
<DD><A name=index-fprofile-correction-941></A>Profiles collected using an instrumented binary for multi-threaded programs may be inconsistent due to missed counter updates. When this option is specified, GCC uses heuristics to correct or smooth out such inconsistencies. By default, GCC emits an error message when an inconsistent profile is detected.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fprofile-dir=</CODE><VAR>path</VAR></DT>
<DD><A name=index-fprofile-dir-942></A>Set the directory to search for the profile data files in to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>path</VAR>. This option affects only the profile data generated by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-generate</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftest-coverage</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-arcs</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and used by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-use</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fbranch-probabilities</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and its related options. Both absolute and relative paths can be used. By default, GCC uses the current directory as<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>path</VAR>, thus the profile data file appears in the same directory as the object file.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fprofile-generate</CODE></DT>
<DT><CODE>-fprofile-generate=</CODE><VAR>path</VAR></DT>
<DD><A name=index-fprofile-generate-943></A>Enable options usually used for instrumenting application to produce profile useful for later recompilation with profile feedback based optimization. You must use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-generate</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>both when compiling and when linking your program.
<P>The following options are enabled:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-fprofile-arcs</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-fprofile-values</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-fvpt</CODE>.</P>
<P>If<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>path</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is specified, GCC looks at the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>path</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>to find the profile feedback data files. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-dir</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fprofile-use</CODE></DT>
<DT><CODE>-fprofile-use=</CODE><VAR>path</VAR></DT>
<DD><A name=index-fprofile-use-944></A>Enable profile feedback directed optimizations, and optimizations generally profitable only with profile feedback available.
<P>The following options are enabled:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-fbranch-probabilities</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-fvpt</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-funroll-loops</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-fpeel-loops</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-ftracer</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>-ftree-vectorize</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>ftree-loop-distribute-patterns</CODE></P>
<P>By default, GCC emits an error message if the feedback profiles do not match the source code. This error can be turned into a warning by using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Wcoverage-mismatch</SPAN></SAMP>. Note this may result in poorly optimized code.</P>
<P>If<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>path</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is specified, GCC looks at the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>path</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>to find the profile feedback data files. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-dir</SPAN></SAMP>.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The following options control compiler behavior regarding floating-point arithmetic. These options trade off between speed and correctness. All must be specifically enabled.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><CODE>-ffloat-store</CODE></DT>
<DD><A name=index-ffloat-store-945></A>Do not store floating-point variables in registers, and inhibit other options that might change whether a floating-point value is taken from a register or memory.
<P><A name=index-floating-point-precision-946></A>This option prevents undesirable excess precision on machines such as the 68000 where the floating registers (of the 68881) keep more precision than a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>double</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is supposed to have. Similarly for the x86 architecture. For most programs, the excess precision does only good, but a few programs rely on the precise definition of IEEE floating point. Use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffloat-store</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>for such programs, after modifying them to store all pertinent intermediate computations into variables.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fexcess-precision=</CODE><VAR>style</VAR></DT>
<DD><A name=index-fexcess-precision-947></A>This option allows further control over excess precision on machines where floating-point registers have more precision than the IEEE<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>float</CODE>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>double</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>types and the processor does not support operations rounding to those types. By default,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fexcess-precision=fast</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is in effect; this means that operations are carried out in the precision of the registers and that it is unpredictable when rounding to the types specified in the source code takes place. When compiling C, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fexcess-precision=standard</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is specified then excess precision follows the rules specified in ISO C99; in particular, both casts and assignments cause values to be rounded to their semantic types (whereas<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffloat-store</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>only affects assignments). This option is enabled by default for C if a strict conformance option such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-std=c99</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used.
<P><A name=index-mfpmath-948></A><SAMP><SPAN class=option>-fexcess-precision=standard</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not implemented for languages other than C, and has no effect if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-funsafe-math-optimizations</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffast-math</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is specified. On the x86, it also has no effect if<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mfpmath=sse</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mfpmath=sse+387</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is specified; in the former case, IEEE semantics apply without excess precision, and in the latter, rounding is unpredictable.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-ffast-math</CODE></DT>
<DD><A name=index-ffast-math-949></A>Sets<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-math-errno</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-funsafe-math-optimizations</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffinite-math-only</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-rounding-math</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-signaling-nans</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fcx-limited-range</SPAN></SAMP>.
<P>This option causes the preprocessor macro<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__FAST_MATH__</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be defined.</P>
<P>This option is not turned on by any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option besides<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Ofast</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>since it can result in incorrect output for programs that depend on an exact implementation of IEEE or ISO rules/specifications for math functions. It may, however, yield faster code for programs that do not require the guarantees of these specifications.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fno-math-errno</CODE></DT>
<DD><A name=index-fno-math-errno-950></A>Do not set<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>errno</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>after calling math functions that are executed with a single instruction, e.g.,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>sqrt</CODE>. A program that relies on IEEE exceptions for math error handling may want to use this flag for speed while maintaining IEEE arithmetic compatibility.
<P>This option is not turned on by any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option since it can result in incorrect output for programs that depend on an exact implementation of IEEE or ISO rules/specifications for math functions. It may, however, yield faster code for programs that do not require the guarantees of these specifications.</P>
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fmath-errno</SPAN></SAMP>.</P>
<P>On Darwin systems, the math library never sets<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>errno</CODE>. There is therefore no reason for the compiler to consider the possibility that it might, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-math-errno</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the default.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-funsafe-math-optimizations</CODE></DT>
<DD><A name=index-funsafe-math-optimizations-951></A>Allow optimizations for floating-point arithmetic that (a) assume that arguments and results are valid and (b) may violate IEEE or ANSI standards. When used at link-time, it may include libraries or startup files that change the default FPU control word or other similar optimizations.
<P>This option is not turned on by any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option since it can result in incorrect output for programs that depend on an exact implementation of IEEE or ISO rules/specifications for math functions. It may, however, yield faster code for programs that do not require the guarantees of these specifications. Enables<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-signed-zeros</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-trapping-math</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fassociative-math</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-freciprocal-math</SPAN></SAMP>.</P>
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-unsafe-math-optimizations</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fassociative-math</CODE></DT>
<DD><A name=index-fassociative-math-952></A>Allow re-association of operands in series of floating-point operations. This violates the ISO C and C++ language standard by possibly changing computation result. NOTE: re-ordering may change the sign of zero as well as ignore NaNs and inhibit or create underflow or overflow (and thus cannot be used on code that relies on rounding behavior like<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(x + 2**52) - 2**52</CODE>. May also reorder floating-point comparisons and thus may not be used when ordered comparisons are required. This option requires that both<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-signed-zeros</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-trapping-math</SPAN></SAMP>be in effect. Moreover, it doesn't make much sense with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-frounding-math</SPAN></SAMP>. For Fortran the option is automatically enabled when both<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-signed-zeros</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-trapping-math</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>are in effect.
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-associative-math</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-freciprocal-math</CODE></DT>
<DD><A name=index-freciprocal-math-953></A>Allow the reciprocal of a value to be used instead of dividing by the value if this enables optimizations. For example<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>x / y</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be replaced with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>x * (1/y)</CODE>, which is useful if<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(1/y)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is subject to common subexpression elimination. Note that this loses precision and increases the number of flops operating on the value.
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-reciprocal-math</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-ffinite-math-only</CODE></DT>
<DD><A name=index-ffinite-math-only-954></A>Allow optimizations for floating-point arithmetic that assume that arguments and results are not NaNs or +-Infs.
<P>This option is not turned on by any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option since it can result in incorrect output for programs that depend on an exact implementation of IEEE or ISO rules/specifications for math functions. It may, however, yield faster code for programs that do not require the guarantees of these specifications.</P>
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-finite-math-only</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fno-signed-zeros</CODE></DT>
<DD><A name=index-fno-signed-zeros-955></A>Allow optimizations for floating-point arithmetic that ignore the signedness of zero. IEEE arithmetic specifies the behavior of distinct +0.0 and &#8722;0.0 values, which then prohibits simplification of expressions such as x+0.0 or 0.0*x (even with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffinite-math-only</SPAN></SAMP>). This option implies that the sign of a zero result isn't significant.
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsigned-zeros</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fno-trapping-math</CODE></DT>
<DD><A name=index-fno-trapping-math-956></A>Compile code assuming that floating-point operations cannot generate user-visible traps. These traps include division by zero, overflow, underflow, inexact result and invalid operation. This option requires that<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-signaling-nans</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>be in effect. Setting this option may allow faster code if one relies on &#8220;non-stop&#8221; IEEE arithmetic, for example.
<P>This option should never be turned on by any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option since it can result in incorrect output for programs that depend on an exact implementation of IEEE or ISO rules/specifications for math functions.</P>
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftrapping-math</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-frounding-math</CODE></DT>
<DD><A name=index-frounding-math-957></A>Disable transformations and optimizations that assume default floating-point rounding behavior. This is round-to-zero for all floating point to integer conversions, and round-to-nearest for all other arithmetic truncations. This option should be specified for programs that change the FP rounding mode dynamically, or that may be executed with a non-default rounding mode. This option disables constant folding of floating-point expressions at compile time (which may be affected by rounding mode) and arithmetic transformations that are unsafe in the presence of sign-dependent rounding modes.
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-rounding-math</SPAN></SAMP>.</P>
<P>This option is experimental and does not currently guarantee to disable all GCC optimizations that are affected by rounding mode. Future versions of GCC may provide finer control of this setting using C99's<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>FENV_ACCESS</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>pragma. This command-line option will be used to specify the default state for<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>FENV_ACCESS</CODE>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fsignaling-nans</CODE></DT>
<DD><A name=index-fsignaling-nans-958></A>Compile code assuming that IEEE signaling NaNs may generate user-visible traps during floating-point operations. Setting this option disables optimizations that may change the number of exceptions visible with signaling NaNs. This option implies<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftrapping-math</SPAN></SAMP>.
<P>This option causes the preprocessor macro<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__SUPPORT_SNAN__</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to be defined.</P>
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-signaling-nans</SPAN></SAMP>.</P>
<P>This option is experimental and does not currently guarantee to disable all GCC optimizations that affect signaling NaN behavior.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fsingle-precision-constant</CODE></DT>
<DD><A name=index-fsingle-precision-constant-959></A>Treat floating-point constants as single precision instead of implicitly converting them to double-precision constants.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fcx-limited-range</CODE></DT>
<DD><A name=index-fcx-limited-range-960></A>When enabled, this option states that a range reduction step is not needed when performing complex division. Also, there is no checking whether the result of a complex multiplication or division is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>NaN + I*NaN</CODE>, with an attempt to rescue the situation in that case. The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-cx-limited-range</SPAN></SAMP>, but is enabled by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ffast-math</SPAN></SAMP>.
<P>This option controls the default setting of the ISO C99<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>CX_LIMITED_RANGE</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>pragma. Nevertheless, the option applies to all languages.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fcx-fortran-rules</CODE></DT>
<DD><A name=index-fcx-fortran-rules-961></A>Complex multiplication and division follow Fortran rules. Range reduction is done as part of complex division, but there is no checking whether the result of a complex multiplication or division is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>NaN + I*NaN</CODE>, with an attempt to rescue the situation in that case.
<P>The default is<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-cx-fortran-rules</SPAN></SAMP>.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The following options control optimizations that may improve performance, but are not enabled by any<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>options. This section includes experimental options that may produce broken code.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><CODE>-fbranch-probabilities</CODE></DT>
<DD><A name=index-fbranch-probabilities-962></A>After running a program compiled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-arcs</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>(see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Debugging-Options.html#Debugging-Options">Options for Debugging Your Program or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>gcc</SPAN></SAMP></A>), you can compile it a second time using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fbranch-probabilities</SPAN></SAMP>, to improve optimizations based on the number of times each branch was taken. When a program compiled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-arcs</SPAN></SAMP>exits, it saves arc execution counts to a file called<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><VAR>sourcename</VAR><SPAN class=file>.gcda</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>for each source file. The information in this data file is very dependent on the structure of the generated code, so you must use the same source code and the same optimization options for both compilations.
<P>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fbranch-probabilities</SPAN></SAMP>, GCC puts a &#8216;<SAMP><SPAN class=samp>REG_BR_PROB</SPAN></SAMP>&#8217; note on each &#8216;<SAMP><SPAN class=samp>JUMP_INSN</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>CALL_INSN</SPAN></SAMP>&#8217;. These can be used to improve optimization. Currently, they are only used in one place: in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>reorg.c</SPAN></SAMP>, instead of guessing which path a branch is most likely to take, the &#8216;<SAMP><SPAN class=samp>REG_BR_PROB</SPAN></SAMP>&#8217; values are used to exactly determine which path is taken more often.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fprofile-values</CODE></DT>
<DD><A name=index-fprofile-values-963></A>If combined with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-arcs</SPAN></SAMP>, it adds code so that some data about values of expressions in the program is gathered.
<P>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fbranch-probabilities</SPAN></SAMP>, it reads back the data gathered from profiling values of expressions for usage in optimizations.</P>
<P>Enabled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-generate</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-use</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fprofile-reorder-functions</CODE></DT>
<DD><A name=index-fprofile-reorder-functions-964></A>Function reordering based on profile instrumentation collects first time of execution of a function and orders these functions in ascending order.
<P>Enabled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-use</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fvpt</CODE></DT>
<DD><A name=index-fvpt-965></A>If combined with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-arcs</SPAN></SAMP>, this option instructs the compiler to add code to gather information about values of expressions.
<P>With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fbranch-probabilities</SPAN></SAMP>, it reads back the data gathered and actually performs the optimizations based on them. Currently the optimizations include specialization of division operations using the knowledge about the value of the denominator.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-frename-registers</CODE></DT>
<DD><A name=index-frename-registers-966></A>Attempt to avoid false dependencies in scheduled code by making use of registers left over after register allocation. This optimization most benefits processors with lots of registers. Depending on the debug information format adopted by the target, however, it can make debugging impossible, since variables no longer stay in a &#8220;home register&#8221;.
<P>Enabled by default with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-funroll-loops</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fpeel-loops</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-ftracer</CODE></DT>
<DD><A name=index-ftracer-967></A>Perform tail duplication to enlarge superblock size. This transformation simplifies the control flow of the function allowing other optimizations to do a better job.
<P>Enabled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-use</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-funroll-loops</CODE></DT>
<DD><A name=index-funroll-loops-968></A>Unroll loops whose number of iterations can be determined at compile time or upon entry to the loop.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-funroll-loops</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>implies<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-frerun-cse-after-loop</SPAN></SAMP>,<SAMP><SPAN class=option>-fweb</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-frename-registers</SPAN></SAMP>. It also turns on complete loop peeling (i.e. complete removal of loops with a small constant number of iterations). This option makes code larger, and may or may not make it run faster.
<P>Enabled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-use</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-funroll-all-loops</CODE></DT>
<DD><A name=index-funroll-all-loops-969></A>Unroll all loops, even if their number of iterations is uncertain when the loop is entered. This usually makes programs run more slowly.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-funroll-all-loops</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>implies the same options as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-funroll-loops</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fpeel-loops</CODE></DT>
<DD><A name=index-fpeel-loops-970></A>Peels loops for which there is enough information that they do not roll much (from profile feedback). It also turns on complete loop peeling (i.e. complete removal of loops with small constant number of iterations).
<P>Enabled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-use</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fmove-loop-invariants</CODE></DT>
<DD><A name=index-fmove-loop-invariants-971></A>Enables the loop invariant motion pass in the RTL loop optimizer. Enabled at level<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O1</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-funswitch-loops</CODE></DT>
<DD><A name=index-funswitch-loops-972></A>Move branches with loop invariant conditions out of the loop, with duplicates of the loop on both branches (modified according to result of the condition).<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-ffunction-sections</CODE></DT>
<DT><CODE>-fdata-sections</CODE></DT>
<DD><A name=index-ffunction-sections-973></A><A name=index-fdata-sections-974></A>Place each function or data item into its own section in the output file if the target supports arbitrary sections. The name of the function or the name of the data item determines the section's name in the output file.
<P>Use these options on systems where the linker can perform optimizations to improve locality of reference in the instruction space. Most systems using the ELF object format and SPARC processors running Solaris 2 have linkers with such optimizations. AIX may have these optimizations in the future.</P>
<P>Only use these options when there are significant benefits from doing so. When you specify these options, the assembler and linker create larger object and executable files and are also slower. You cannot use<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>gprof</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>on all systems if you specify this option, and you may have problems with debugging if you specify both this option and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-g</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>-fbranch-target-load-optimize</CODE></DT>
<DD><A name=index-fbranch-target-load-optimize-975></A>Perform branch target register load optimization before prologue / epilogue threading. The use of target registers can typically be exposed only during reload, thus hoisting loads out of loops and doing inter-block scheduling needs a separate optimization pass.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fbranch-target-load-optimize2</CODE></DT>
<DD><A name=index-fbranch-target-load-optimize2-976></A>Perform branch target register load optimization after prologue / epilogue threading.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fbtr-bb-exclusive</CODE></DT>
<DD><A name=index-fbtr-bb-exclusive-977></A>When performing branch target register load optimization, don't reuse branch target registers within any basic block.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fstack-protector</CODE></DT>
<DD><A name=index-fstack-protector-978></A>Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>alloca</CODE>, and functions with buffers larger than 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fstack-protector-all</CODE></DT>
<DD><A name=index-fstack-protector-all-979></A>Like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fstack-protector</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>except that all functions are protected.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fstack-protector-strong</CODE></DT>
<DD><A name=index-fstack-protector-strong-980></A>Like<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fstack-protector</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>but includes additional functions to be protected &#8212; those that have local array definitions, or have references to local frame addresses.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-fsection-anchors</CODE></DT>
<DD><A name=index-fsection-anchors-981></A>Try to reduce the number of symbolic address calculations by using shared &#8220;anchor&#8221; symbols to address nearby objects. This transformation can help to reduce the number of GOT entries and GOT accesses on some targets.
<P>For example, the implementation of the following function<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE>:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          static int a, b, c;
          int foo (void) { return a + b + c; }
</PRE>
<P class=noindent>usually calculates the addresses of all three variables, but if you compile it with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsection-anchors</SPAN></SAMP>, it accesses the variables from a common anchor point instead. The effect is similar to the following pseudocode (which isn't valid C):</P><PRE style="FONT-SIZE: smaller" class=smallexample>          int foo (void)
          {
            register int *xr = &amp;x;
            return xr[&amp;a - &amp;x] + xr[&amp;b - &amp;x] + xr[&amp;c - &amp;x];
          }
</PRE>
<P>Not all targets support this option.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>--param<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>name</VAR><CODE>=</CODE><VAR>value</VAR></DT>
<DD><A name=index-param-982></A>In some places, GCC uses various constants to control the amount of optimization that is done. For example, GCC does not inline functions that contain more than a certain number of instructions. You can control some of these constants on the command line using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param</SPAN></SAMP>option.
<P>The names of specific parameters, and the meaning of the values, are tied to the internals of the compiler, and are subject to change without notice in future releases.</P>
<P>In each case, the<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>value</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an integer. The allowable choices for<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>name</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>are:</P>
<DL>
<DT><CODE>predictable-branch-outcome</CODE></DT>
<DD>When branch is predicted to be taken with probability lower than this threshold (in percent), then it is considered well predictable. The default is 10.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-crossjump-edges</CODE></DT>
<DD>The maximum number of incoming edges to consider for cross-jumping. The algorithm used by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fcrossjumping</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is O(N^2) in the number of edges incoming to each block. Increasing values mean more aggressive optimization, making the compilation time increase with probably small improvement in executable size.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>min-crossjump-insns</CODE></DT>
<DD>The minimum number of instructions that must be matched at the end of two blocks before cross-jumping is performed on them. This value is ignored in the case where all instructions in the block being cross-jumped from are matched. The default value is 5.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-grow-copy-bb-insns</CODE></DT>
<DD>The maximum code size expansion factor when copying basic blocks instead of jumping. The expansion is relative to a jump instruction. The default value is 8.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-goto-duplication-insns</CODE></DT>
<DD>The maximum number of instructions to duplicate to a block that jumps to a computed goto. To avoid O(N^2) behavior in a number of passes, GCC factors computed gotos early in the compilation process, and unfactors them as late as possible. Only computed jumps at the end of a basic blocks with no more than max-goto-duplication-insns are unfactored. The default value is 8.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-delay-slot-insn-search</CODE></DT>
<DD>The maximum number of instructions to consider when looking for an instruction to fill a delay slot. If more than this arbitrary number of instructions are searched, the time savings from filling the delay slot are minimal, so stop searching. Increasing values mean more aggressive optimization, making the compilation time increase with probably small improvement in execution time.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-delay-slot-live-search</CODE></DT>
<DD>When trying to fill delay slots, the maximum number of instructions to consider when searching for a block with valid live register information. Increasing this arbitrarily chosen value means more aggressive optimization, increasing the compilation time. This parameter should be removed when the delay slot code is rewritten to maintain the control-flow graph.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-gcse-memory</CODE></DT>
<DD>The approximate maximum amount of memory that can be allocated in order to perform the global common subexpression elimination optimization. If more memory than specified is required, the optimization is not done.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-gcse-insertion-ratio</CODE></DT>
<DD>If the ratio of expression insertions to deletions is larger than this value for any expression, then RTL PRE inserts or removes the expression and thus leaves partially redundant computations in the instruction stream. The default value is 20.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-pending-list-length</CODE></DT>
<DD>The maximum number of pending dependencies scheduling allows before flushing the current state and starting over. Large functions with few branches or calls can create excessively large lists which needlessly consume memory and resources.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-modulo-backtrack-attempts</CODE></DT>
<DD>The maximum number of backtrack attempts the scheduler should make when modulo scheduling a loop. Larger values can exponentially increase compilation time.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-inline-insns-single</CODE></DT>
<DD>Several parameters control the tree inliner used in GCC. This number sets the maximum number of instructions (counted in GCC's internal representation) in a single function that the tree inliner considers for inlining. This only affects functions declared inline and methods implemented in a class declaration (C++). The default value is 400.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-inline-insns-auto</CODE></DT>
<DD>When you use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-finline-functions</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>(included in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>), a lot of functions that would otherwise not be considered for inlining by the compiler are investigated. To those functions, a different (more restrictive) limit compared to functions declared inline can be applied. The default value is 40.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>inline-min-speedup</CODE></DT>
<DD>When estimated performance improvement of caller + callee runtime exceeds this threshold (in precent), the function can be inlined regardless the limit on<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param max-inline-insns-single</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param max-inline-insns-auto</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>large-function-insns</CODE></DT>
<DD>The limit specifying really large functions. For functions larger than this limit after inlining, inlining is constrained by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param large-function-growth</SPAN></SAMP>. This parameter is useful primarily to avoid extreme compilation time caused by non-linear algorithms used by the back end. The default value is 2700.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>large-function-growth</CODE></DT>
<DD>Specifies maximal growth of large function caused by inlining in percents. The default value is 100 which limits large function growth to 2.0 times the original size.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>large-unit-insns</CODE></DT>
<DD>The limit specifying large translation unit. Growth caused by inlining of units larger than this limit is limited by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param inline-unit-growth</SPAN></SAMP>. For small units this might be too tight. For example, consider a unit consisting of function A that is inline and B that just calls A three times. If B is small relative to A, the growth of unit is 300\% and yet such inlining is very sane. For very large units consisting of small inlineable functions, however, the overall unit growth limit is needed to avoid exponential explosion of code size. Thus for smaller units, the size is increased to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param large-unit-insns</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>before applying<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param inline-unit-growth</SPAN></SAMP>. The default is 10000.<BR></DD>
<DT><CODE>inline-unit-growth</CODE></DT>
<DD>Specifies maximal overall growth of the compilation unit caused by inlining. The default value is 30 which limits unit growth to 1.3 times the original size.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>ipcp-unit-growth</CODE></DT>
<DD>Specifies maximal overall growth of the compilation unit caused by interprocedural constant propagation. The default value is 10 which limits unit growth to 1.1 times the original size.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>large-stack-frame</CODE></DT>
<DD>The limit specifying large stack frames. While inlining the algorithm is trying to not grow past this limit too much. The default value is 256 bytes.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>large-stack-frame-growth</CODE></DT>
<DD>Specifies maximal growth of large stack frames caused by inlining in percents. The default value is 1000 which limits large stack frame growth to 11 times the original size.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-inline-insns-recursive</CODE></DT>
<DT><CODE>max-inline-insns-recursive-auto</CODE></DT>
<DD>Specifies the maximum number of instructions an out-of-line copy of a self-recursive inline function can grow into by performing recursive inlining.
<P>For functions declared inline,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param max-inline-insns-recursive</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is taken into account. For functions not declared inline, recursive inlining happens only when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-finline-functions</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>(included in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>) is enabled and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param max-inline-insns-recursive-auto</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used. The default value is 450.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>max-inline-recursive-depth</CODE></DT>
<DT><CODE>max-inline-recursive-depth-auto</CODE></DT>
<DD>Specifies the maximum recursion depth used for recursive inlining.
<P>For functions declared inline,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param max-inline-recursive-depth</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is taken into account. For functions not declared inline, recursive inlining happens only when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-finline-functions</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>(included in<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>) is enabled and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param max-inline-recursive-depth-auto</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used. The default value is 8.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>min-inline-recursive-probability</CODE></DT>
<DD>Recursive inlining is profitable only for function having deep recursion in average and can hurt for function having little recursion depth by increasing the prologue size or complexity of function body to other optimizers.
<P>When profile feedback is available (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fprofile-generate</SPAN></SAMP>) the actual recursion depth can be guessed from probability that function recurses via a given call expression. This parameter limits inlining only to call expressions whose probability exceeds the given threshold (in percents). The default value is 10.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>early-inlining-insns</CODE></DT>
<DD>Specify growth that the early inliner can make. In effect it increases the amount of inlining for code having a large abstraction penalty. The default value is 10.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-early-inliner-iterations</CODE></DT>
<DT><CODE>max-early-inliner-iterations</CODE></DT>
<DD>Limit of iterations of the early inliner. This basically bounds the number of nested indirect calls the early inliner can resolve. Deeper chains are still handled by late inlining.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>comdat-sharing-probability</CODE></DT>
<DT><CODE>comdat-sharing-probability</CODE></DT>
<DD>Probability (in percent) that C++ inline function with comdat visibility are shared across multiple compilation units. The default value is 20.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>min-vect-loop-bound</CODE></DT>
<DD>The minimum number of iterations under which loops are not vectorized when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-ftree-vectorize</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used. The number of iterations after vectorization needs to be greater than the value specified by this option to allow vectorization. The default value is 0.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>gcse-cost-distance-ratio</CODE></DT>
<DD>Scaling factor in calculation of maximum distance an expression can be moved by GCSE optimizations. This is currently supported only in the code hoisting pass. The bigger the ratio, the more aggressive code hoisting is with simple expressions, i.e., the expressions that have cost less than<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>gcse-unrestricted-cost</SPAN></SAMP>. Specifying 0 disables hoisting of simple expressions. The default value is 10.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>gcse-unrestricted-cost</CODE></DT>
<DD>Cost, roughly measured as the cost of a single typical machine instruction, at which GCSE optimizations do not constrain the distance an expression can travel. This is currently supported only in the code hoisting pass. The lesser the cost, the more aggressive code hoisting is. Specifying 0 allows all expressions to travel unrestricted distances. The default value is 3.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-hoist-depth</CODE></DT>
<DD>The depth of search in the dominator tree for expressions to hoist. This is used to avoid quadratic behavior in hoisting algorithm. The value of 0 does not limit on the search, but may slow down compilation of huge functions. The default value is 30.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-tail-merge-comparisons</CODE></DT>
<DD>The maximum amount of similar bbs to compare a bb with. This is used to avoid quadratic behavior in tree tail merging. The default value is 10.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-tail-merge-iterations</CODE></DT>
<DD>The maximum amount of iterations of the pass over the function. This is used to limit compilation time in tree tail merging. The default value is 2.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-unrolled-insns</CODE></DT>
<DD>The maximum number of instructions that a loop may have to be unrolled. If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-average-unrolled-insns</CODE></DT>
<DD>The maximum number of instructions biased by probabilities of their execution that a loop may have to be unrolled. If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-unroll-times</CODE></DT>
<DD>The maximum number of unrollings of a single loop.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-peeled-insns</CODE></DT>
<DD>The maximum number of instructions that a loop may have to be peeled. If a loop is peeled, this parameter also determines how many times the loop code is peeled.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-peel-times</CODE></DT>
<DD>The maximum number of peelings of a single loop.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-peel-branches</CODE></DT>
<DD>The maximum number of branches on the hot path through the peeled sequence.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-completely-peeled-insns</CODE></DT>
<DD>The maximum number of insns of a completely peeled loop.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-completely-peel-times</CODE></DT>
<DD>The maximum number of iterations of a loop to be suitable for complete peeling.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-completely-peel-loop-nest-depth</CODE></DT>
<DD>The maximum depth of a loop nest suitable for complete peeling.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-unswitch-insns</CODE></DT>
<DD>The maximum number of insns of an unswitched loop.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-unswitch-level</CODE></DT>
<DD>The maximum number of branches unswitched in a single loop.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>lim-expensive</CODE></DT>
<DD>The minimum cost of an expensive expression in the loop invariant motion.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>iv-consider-all-candidates-bound</CODE></DT>
<DD>Bound on number of candidates for induction variables, below which all candidates are considered for each use in induction variable optimizations. If there are more candidates than this, only the most relevant ones are considered to avoid quadratic time complexity.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>iv-max-considered-uses</CODE></DT>
<DD>The induction variable optimizations give up on loops that contain more induction variable uses.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>iv-always-prune-cand-set-bound</CODE></DT>
<DD>If the number of candidates in the set is smaller than this value, always try to remove unnecessary ivs from the set when adding a new one.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>scev-max-expr-size</CODE></DT>
<DD>Bound on size of expressions used in the scalar evolutions analyzer. Large expressions slow the analyzer.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>scev-max-expr-complexity</CODE></DT>
<DD>Bound on the complexity of the expressions in the scalar evolutions analyzer. Complex expressions slow the analyzer.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>omega-max-vars</CODE></DT>
<DD>The maximum number of variables in an Omega constraint system. The default value is 128.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>omega-max-geqs</CODE></DT>
<DD>The maximum number of inequalities in an Omega constraint system. The default value is 256.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>omega-max-eqs</CODE></DT>
<DD>The maximum number of equalities in an Omega constraint system. The default value is 128.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>omega-max-wild-cards</CODE></DT>
<DD>The maximum number of wildcard variables that the Omega solver is able to insert. The default value is 18.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>omega-hash-table-size</CODE></DT>
<DD>The size of the hash table in the Omega solver. The default value is 550.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>omega-max-keys</CODE></DT>
<DD>The maximal number of keys used by the Omega solver. The default value is 500.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>omega-eliminate-redundant-constraints</CODE></DT>
<DD>When set to 1, use expensive methods to eliminate all redundant constraints. The default value is 0.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>vect-max-version-for-alignment-checks</CODE></DT>
<DD>The maximum number of run-time checks that can be performed when doing loop versioning for alignment in the vectorizer.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>vect-max-version-for-alias-checks</CODE></DT>
<DD>The maximum number of run-time checks that can be performed when doing loop versioning for alias in the vectorizer.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>vect-max-peeling-for-alignment</CODE></DT>
<DD>The maximum number of loop peels to enhance access alignment for vectorizer. Value -1 means 'no limit'.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-iterations-to-track</CODE></DT>
<DD>The maximum number of iterations of a loop the brute-force algorithm for analysis of the number of iterations of the loop tries to evaluate.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>hot-bb-count-ws-permille</CODE></DT>
<DD>A basic block profile count is considered hot if it contributes to the given permillage (i.e. 0...1000) of the entire profiled execution.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>hot-bb-frequency-fraction</CODE></DT>
<DD>Select fraction of the entry block frequency of executions of basic block in function given basic block needs to have to be considered hot.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-predicted-iterations</CODE></DT>
<DD>The maximum number of loop iterations we predict statically. This is useful in cases where a function contains a single loop with known bound and another loop with unknown bound. The known number of iterations is predicted correctly, while the unknown number of iterations average to roughly 10. This means that the loop without bounds appears artificially cold relative to the other one.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>builtin-expect-probability</CODE></DT>
<DD>Control the probability of the expression having the specified value. This parameter takes a percentage (i.e. 0 ... 100) as input. The default probability of 90 is obtained empirically.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>align-threshold</CODE></DT>
<DD>Select fraction of the maximal frequency of executions of a basic block in a function to align the basic block.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>align-loop-iterations</CODE></DT>
<DD>A loop expected to iterate at least the selected number of iterations is aligned.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>tracer-dynamic-coverage</CODE></DT>
<DT><CODE>tracer-dynamic-coverage-feedback</CODE></DT>
<DD>This value is used to limit superblock formation once the given percentage of executed instructions is covered. This limits unnecessary code size expansion.
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>tracer-dynamic-coverage-feedback</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used only when profile feedback is available. The real profiles (as opposed to statically estimated ones) are much less balanced allowing the threshold to be larger value.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>tracer-max-code-growth</CODE></DT>
<DD>Stop tail duplication once code growth has reached given percentage. This is a rather artificial limit, as most of the duplicates are eliminated later in cross jumping, so it may be set to much higher values than is the desired code growth.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>tracer-min-branch-ratio</CODE></DT>
<DD>Stop reverse growth when the reverse probability of best edge is less than this threshold (in percent).<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>tracer-min-branch-ratio</CODE></DT>
<DT><CODE>tracer-min-branch-ratio-feedback</CODE></DT>
<DD>Stop forward growth if the best edge has probability lower than this threshold.
<P>Similarly to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>tracer-dynamic-coverage</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>two values are present, one for compilation for profile feedback and one for compilation without. The value for compilation with profile feedback needs to be more conservative (higher) in order to make tracer effective.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>max-cse-path-length</CODE></DT>
<DD>The maximum number of basic blocks on path that CSE considers. The default is 10.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-cse-insns</CODE></DT>
<DD>The maximum number of instructions CSE processes before flushing. The default is 1000.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>ggc-min-expand</CODE></DT>
<DD>GCC uses a garbage collector to manage its own memory allocation. This parameter specifies the minimum percentage by which the garbage collector's heap should be allowed to expand between collections. Tuning this may improve compilation speed; it has no effect on code generation.
<P>The default is 30% + 70% * (RAM/1GB) with an upper bound of 100% when RAM &gt;= 1GB. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>getrlimit</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is available, the notion of &#8220;RAM&#8221; is the smallest of actual RAM and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>RLIMIT_DATA</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>RLIMIT_AS</CODE>. If GCC is not able to calculate RAM on a particular platform, the lower bound of 30% is used. Setting this parameter and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>ggc-min-heapsize</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to zero causes a full collection to occur at every opportunity. This is extremely slow, but can be useful for debugging.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>ggc-min-heapsize</CODE></DT>
<DD>Minimum size of the garbage collector's heap before it begins bothering to collect garbage. The first collection occurs after the heap expands by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>ggc-min-expand</SPAN></SAMP>% beyond<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>ggc-min-heapsize</SPAN></SAMP>. Again, tuning this may improve compilation speed, and has no effect on code generation.
<P>The default is the smaller of RAM/8, RLIMIT_RSS, or a limit that tries to ensure that RLIMIT_DATA or RLIMIT_AS are not exceeded, but with a lower bound of 4096 (four megabytes) and an upper bound of 131072 (128 megabytes). If GCC is not able to calculate RAM on a particular platform, the lower bound is used. Setting this parameter very large effectively disables garbage collection. Setting this parameter and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>ggc-min-expand</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to zero causes a full collection to occur at every opportunity.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>max-reload-search-insns</CODE></DT>
<DD>The maximum number of instruction reload should look backward for equivalent register. Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance. The default value is 100.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-cselib-memory-locations</CODE></DT>
<DD>The maximum number of memory locations cselib should take into account. Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance. The default value is 500.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>reorder-blocks-duplicate</CODE></DT>
<DT><CODE>reorder-blocks-duplicate-feedback</CODE></DT>
<DD>Used by the basic block reordering pass to decide whether to use unconditional branch or duplicate the code on its destination. Code is duplicated when its estimated size is smaller than this value multiplied by the estimated size of unconditional jump in the hot spots of the program.
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>reorder-block-duplicate-feedback</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used only when profile feedback is available. It may be set to higher values than<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>reorder-block-duplicate</SPAN></SAMP>since information about the hot spots is more accurate.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>max-sched-ready-insns</CODE></DT>
<DD>The maximum number of instructions ready to be issued the scheduler should consider at any given time during the first scheduling pass. Increasing values mean more thorough searches, making the compilation time increase with probably little benefit. The default value is 100.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-sched-region-blocks</CODE></DT>
<DD>The maximum number of blocks in a region to be considered for interblock scheduling. The default value is 10.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-pipeline-region-blocks</CODE></DT>
<DD>The maximum number of blocks in a region to be considered for pipelining in the selective scheduler. The default value is 15.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-sched-region-insns</CODE></DT>
<DD>The maximum number of insns in a region to be considered for interblock scheduling. The default value is 100.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-pipeline-region-insns</CODE></DT>
<DD>The maximum number of insns in a region to be considered for pipelining in the selective scheduler. The default value is 200.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>min-spec-prob</CODE></DT>
<DD>The minimum probability (in percents) of reaching a source block for interblock speculative scheduling. The default value is 40.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-sched-extend-regions-iters</CODE></DT>
<DD>The maximum number of iterations through CFG to extend regions. A value of 0 (the default) disables region extensions.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-sched-insn-conflict-delay</CODE></DT>
<DD>The maximum conflict delay for an insn to be considered for speculative motion. The default value is 3.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>sched-spec-prob-cutoff</CODE></DT>
<DD>The minimal probability of speculation success (in percents), so that speculative insns are scheduled. The default value is 40.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>sched-spec-state-edge-prob-cutoff</CODE></DT>
<DD>The minimum probability an edge must have for the scheduler to save its state across it. The default value is 10.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>sched-mem-true-dep-cost</CODE></DT>
<DD>Minimal distance (in CPU cycles) between store and load targeting same memory locations. The default value is 1.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>selsched-max-lookahead</CODE></DT>
<DD>The maximum size of the lookahead window of selective scheduling. It is a depth of search for available instructions. The default value is 50.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>selsched-max-sched-times</CODE></DT>
<DD>The maximum number of times that an instruction is scheduled during selective scheduling. This is the limit on the number of iterations through which the instruction may be pipelined. The default value is 2.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>selsched-max-insns-to-rename</CODE></DT>
<DD>The maximum number of best instructions in the ready list that are considered for renaming in the selective scheduler. The default value is 2.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>sms-min-sc</CODE></DT>
<DD>The minimum value of stage count that swing modulo scheduler generates. The default value is 2.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-last-value-rtl</CODE></DT>
<DD>The maximum size measured as number of RTLs that can be recorded in an expression in combiner for a pseudo register as last known value of that register. The default is 10000.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>integer-share-limit</CODE></DT>
<DD>Small integer constants can use a shared data structure, reducing the compiler's memory usage and increasing its speed. This sets the maximum value of a shared integer constant. The default value is 256.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>ssp-buffer-size</CODE></DT>
<DD>The minimum size of buffers (i.e. arrays) that receive stack smashing protection when<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fstack-protection</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is used.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>min-size-for-stack-sharing</CODE></DT>
<DD>The minimum size of variables taking part in stack slot sharing when not optimizing. The default value is 32.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-jump-thread-duplication-stmts</CODE></DT>
<DD>Maximum number of statements allowed in a block that needs to be duplicated when threading jumps.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-fields-for-field-sensitive</CODE></DT>
<DD>Maximum number of fields in a structure treated in a field sensitive manner during pointer analysis. The default is zero for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O0</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O1</SPAN></SAMP>, and 100 for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP>, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>prefetch-latency</CODE></DT>
<DD>Estimate on average number of instructions that are executed before prefetch finishes. The distance prefetched ahead is proportional to this constant. Increasing this number may also lead to less streams being prefetched (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>simultaneous-prefetches</SPAN></SAMP>).<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>simultaneous-prefetches</CODE></DT>
<DD>Maximum number of prefetches that can run at the same time.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>l1-cache-line-size</CODE></DT>
<DD>The size of cache line in L1 cache, in bytes.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>l1-cache-size</CODE></DT>
<DD>The size of L1 cache, in kilobytes.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>l2-cache-size</CODE></DT>
<DD>The size of L2 cache, in kilobytes.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>min-insn-to-prefetch-ratio</CODE></DT>
<DD>The minimum ratio between the number of instructions and the number of prefetches to enable prefetching in a loop.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>prefetch-min-insn-to-mem-ratio</CODE></DT>
<DD>The minimum ratio between the number of instructions and the number of memory references to enable prefetching in a loop.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>use-canonical-types</CODE></DT>
<DD>Whether the compiler should use the &#8220;canonical&#8221; type system. By default, this should always be 1, which uses a more efficient internal mechanism for comparing types in C++ and Objective-C++. However, if bugs in the canonical type system are causing compilation failures, set this value to 0 to disable canonical types.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>switch-conversion-max-branch-ratio</CODE></DT>
<DD>Switch initialization conversion refuses to create arrays that are bigger than<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>switch-conversion-max-branch-ratio</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>times the number of branches in the switch.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-partial-antic-length</CODE></DT>
<DD>Maximum length of the partial antic set computed during the tree partial redundancy elimination optimization (<SAMP><SPAN class=option>-ftree-pre</SPAN></SAMP>) when optimizing at<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and above. For some sorts of source code the enhanced partial redundancy elimination optimization can run away, consuming all of the memory available on the host machine. This parameter sets a limit on the length of the sets that are computed, which prevents the runaway behavior. Setting a value of 0 for this parameter allows an unlimited set length.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>sccvn-max-scc-size</CODE></DT>
<DD>Maximum size of a strongly connected component (SCC) during SCCVN processing. If this limit is hit, SCCVN processing for the whole function is not done and optimizations depending on it are disabled. The default maximum SCC size is 10000.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>sccvn-max-alias-queries-per-access</CODE></DT>
<DD>Maximum number of alias-oracle queries we perform when looking for redundancies for loads and stores. If this limit is hit the search is aborted and the load or store is not considered redundant. The number of queries is algorithmically limited to the number of stores on all paths from the load to the function entry. The default maxmimum number of queries is 1000.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>ira-max-loops-num</CODE></DT>
<DD>IRA uses regional register allocation by default. If a function contains more loops than the number given by this parameter, only at most the given number of the most frequently-executed loops form regions for regional register allocation. The default value of the parameter is 100.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>ira-max-conflict-table-size</CODE></DT>
<DD>Although IRA uses a sophisticated algorithm to compress the conflict table, the table can still require excessive amounts of memory for huge functions. If the conflict table for a function could be more than the size in MB given by this parameter, the register allocator instead uses a faster, simpler, and lower-quality algorithm that does not require building a pseudo-register conflict table. The default value of the parameter is 2000.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>ira-loop-reserved-regs</CODE></DT>
<DD>IRA can be used to evaluate more accurate register pressure in loops for decisions to move loop invariants (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O3</SPAN></SAMP>). The number of available registers reserved for some other purposes is given by this parameter. The default value of the parameter is 2, which is the minimal number of registers needed by typical instructions. This value is the best found from numerous experiments.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>loop-invariant-max-bbs-in-loop</CODE></DT>
<DD>Loop invariant motion can be very expensive, both in compilation time and in amount of needed compile-time memory, with very large loops. Loops with more basic blocks than this parameter won't have loop invariant motion optimization performed on them. The default value of the parameter is 1000 for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O1</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and 10000 for<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O2</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>and above.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>loop-max-datarefs-for-datadeps</CODE></DT>
<DD>Building data dapendencies is expensive for very large loops. This parameter limits the number of data references in loops that are considered for data dependence analysis. These large loops are no handled by the optimizations using loop data dependencies. The default value is 1000.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-vartrack-size</CODE></DT>
<DD>Sets a maximum number of hash table slots to use during variable tracking dataflow analysis of any function. If this limit is exceeded with variable tracking at assignments enabled, analysis for that function is retried without it, after removing all debug insns from the function. If the limit is exceeded even without debug insns, var tracking analysis is completely disabled for the function. Setting the parameter to zero makes it unlimited.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-vartrack-expr-depth</CODE></DT>
<DD>Sets a maximum number of recursion levels when attempting to map variable names or debug temporaries to value expressions. This trades compilation time for more complete debug information. If this is set too low, value expressions that are available and could be represented in debug information may end up not being used; setting this higher may enable the compiler to find more complex debug expressions, but compile time and memory use may grow. The default is 12.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>min-nondebug-insn-uid</CODE></DT>
<DD>Use uids starting at this parameter for nondebug insns. The range below the parameter is reserved exclusively for debug insns created by<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fvar-tracking-assignments</SPAN></SAMP>, but debug insns may get (non-overlapping) uids above it if the reserved range is exhausted.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>ipa-sra-ptr-growth-factor</CODE></DT>
<DD>IPA-SRA replaces a pointer to an aggregate with one or more new parameters only when their cumulative size is less or equal to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>ipa-sra-ptr-growth-factor</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>times the size of the original pointer parameter.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>tm-max-aggregate-size</CODE></DT>
<DD>When making copies of thread-local variables in a transaction, this parameter specifies the size in bytes after which variables are saved with the logging functions as opposed to save/restore code sequence pairs. This option only applies when using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fgnu-tm</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>graphite-max-nb-scop-params</CODE></DT>
<DD>To avoid exponential effects in the Graphite loop transforms, the number of parameters in a Static Control Part (SCoP) is bounded. The default value is 10 parameters. A variable whose value is unknown at compilation time and defined outside a SCoP is a parameter of the SCoP.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>graphite-max-bbs-per-function</CODE></DT>
<DD>To avoid exponential effects in the detection of SCoPs, the size of the functions analyzed by Graphite is bounded. The default value is 100 basic blocks.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>loop-block-tile-size</CODE></DT>
<DD>Loop blocking or strip mining transforms, enabled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-floop-block</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-floop-strip-mine</SPAN></SAMP>, strip mine each loop in the loop nest by a given number of iterations. The strip length can be changed using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>loop-block-tile-size</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>parameter. The default value is 51 iterations.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>ipa-cp-value-list-size</CODE></DT>
<DD>IPA-CP attempts to track all possible values and types passed to a function's parameter in order to propagate them and perform devirtualization.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>ipa-cp-value-list-size</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>is the maximum number of values and types it stores per one formal parameter of a function.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>ipa-cp-eval-threshold</CODE></DT>
<DD>IPA-CP calculates its own score of cloning profitability heuristics and performs those cloning opportunities with scores that exceed<SAMP><SPAN class=option>ipa-cp-eval-threshold</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>ipa-max-agg-items</CODE></DT>
<DD>IPA-CP is also capable to propagate a number of scalar values passed in an aggregate.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>ipa-max-agg-items</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>controls the maximum number of such values per one parameter.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>ipa-cp-loop-hint-bonus</CODE></DT>
<DD>When IPA-CP determines that a cloning candidate would make the number of iterations of a loop known, it adds a bonus of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>ipa-cp-loop-hint-bonus</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>bonus to the profitability score of the candidate.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>ipa-cp-array-index-hint-bonus</CODE></DT>
<DD>When IPA-CP determines that a cloning candidate would make the index of an array access known, it adds a bonus of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>ipa-cp-array-index-hint-bonus</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>bonus to the profitability score of the candidate.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>lto-partitions</CODE></DT>
<DD>Specify desired number of partitions produced during WHOPR compilation. The number of partitions should exceed the number of CPUs used for compilation. The default value is 32.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>lto-minpartition</CODE></DT>
<DD>Size of minimal partition for WHOPR (in estimated instructions). This prevents expenses of splitting very small programs into too many partitions.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>cxx-max-namespaces-for-diagnostic-help</CODE></DT>
<DD>The maximum number of namespaces to consult for suggestions when C++ name lookup fails for an identifier. The default is 1000.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>sink-frequency-threshold</CODE></DT>
<DD>The maximum relative execution frequency (in percents) of the target block relative to a statement's original block to allow statement sinking of a statement. Larger numbers result in more aggressive statement sinking. The default value is 75. A small positive adjustment is applied for statements with memory operands as those are even more profitable so sink.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>max-stores-to-sink</CODE></DT>
<DD>The maximum number of conditional stores paires that can be sunk. Set to 0 if either vectorization (<SAMP><SPAN class=option>-ftree-vectorize</SPAN></SAMP>) or if-conversion (<SAMP><SPAN class=option>-ftree-loop-if-convert</SPAN></SAMP>) is disabled. The default is 2.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>allow-load-data-races</CODE></DT>
<DD>Allow optimizers to introduce new data races on loads. Set to 1 to allow, otherwise to 0. This option is enabled by default unless implicitly set by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fmemory-model=</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>allow-store-data-races</CODE></DT>
<DD>Allow optimizers to introduce new data races on stores. Set to 1 to allow, otherwise to 0. This option is enabled by default unless implicitly set by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fmemory-model=</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>allow-packed-load-data-races</CODE></DT>
<DD>Allow optimizers to introduce new data races on packed data loads. Set to 1 to allow, otherwise to 0. This option is enabled by default unless implicitly set by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fmemory-model=</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>allow-packed-store-data-races</CODE></DT>
<DD>Allow optimizers to introduce new data races on packed data stores. Set to 1 to allow, otherwise to 0. This option is enabled by default unless implicitly set by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fmemory-model=</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>case-values-threshold</CODE></DT>
<DD>The smallest number of different values for which it is best to use a jump-table instead of a tree of conditional branches. If the value is 0, use the default for the machine. The default is 0.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>tree-reassoc-width</CODE></DT>
<DD>Set the maximum number of instructions executed in parallel in reassociated tree. This parameter overrides target dependent heuristics used by default if has non zero value.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>sched-pressure-algorithm</CODE></DT>
<DD>Choose between the two available implementations of<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsched-pressure</SPAN></SAMP>. Algorithm 1 is the original implementation and is the more likely to prevent instructions from being reordered. Algorithm 2 was designed to be a compromise between the relatively conservative approach taken by algorithm 1 and the rather aggressive approach taken by the default scheduler. It relies more heavily on having a regular register file and accurate register pressure classes. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=file>haifa-sched.c</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the GCC sources for more details.
<P>The default choice depends on the target.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>max-slsr-cand-scan</CODE></DT>
<DD>Set the maximum number of existing candidates that will be considered when seeking a basis for a new straight-line strength reduction candidate.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>asan-globals</CODE></DT>
<DD>Enable buffer overflow detection for global objects. This kind of protection is enabled by default if you are using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsanitize=address</SPAN></SAMP>option. To disable global objects protection use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param asan-globals=0</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>asan-stack</CODE></DT>
<DD>Enable buffer overflow detection for stack objects. This kind of protection is enabled by default when using<SAMP><SPAN class=option>-fsanitize=address</SPAN></SAMP>. To disable stack protection use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param asan-stack=0</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>asan-instrument-reads</CODE></DT>
<DD>Enable buffer overflow detection for memory reads. This kind of protection is enabled by default when using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsanitize=address</SPAN></SAMP>. To disable memory reads protection use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param asan-instrument-reads=0</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>asan-instrument-writes</CODE></DT>
<DD>Enable buffer overflow detection for memory writes. This kind of protection is enabled by default when using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsanitize=address</SPAN></SAMP>. To disable memory writes protection use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param asan-instrument-writes=0</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>asan-memintrin</CODE></DT>
<DD>Enable detection for built-in functions. This kind of protection is enabled by default when using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsanitize=address</SPAN></SAMP>. To disable built-in functions protection use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param asan-memintrin=0</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>asan-use-after-return</CODE></DT>
<DD>Enable detection of use-after-return. This kind of protection is enabled by default when using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fsanitize=address</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option. To disable use-after-return detection use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>--param asan-use-after-return=0</SPAN></SAMP>.</DD></DL></DD></DL>