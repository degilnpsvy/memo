<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.49 Using Vector Instructions through Built-in Functions</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">On some targets, the instruction set contains SIMD vector instructions which operate on multiple values contained in one large register at the same time. For example, on the i386 the MMX, 3DNow! and SSE extensions can be used this way.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The first step in using these extensions is to provide the necessary data types. This should be done using an appropriate<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>typedef</CODE>:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     typedef int v4si __attribute__ ((vector_size (16)));
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=noindent>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>type specifies the base type, while the attribute specifies the vector size for the variable, measured in bytes. For example, the declaration above causes the compiler to set the mode for the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>v4si</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>type to be 16 bytes wide and divided into<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>sized units. For a 32-bit<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE>this means a vector of 4 units of 4 bytes, and the corresponding mode of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is<SPAN class=Apple-converted-space>&nbsp;</SPAN><ACRONYM>V4SI</ACRONYM>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>vector_size</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute is only applicable to integral and float scalars, although arrays, pointers, and function return values are allowed in conjunction with this construct. Only sizes that are a power of two are currently allowed.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">All the basic integer types can be used as base types, both as signed and as unsigned:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>char</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>short</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>long</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>long long</CODE>. In addition,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>float</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>double</CODE>can be used to build floating-point vector types.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Specifying a combination that is not valid for the current architecture causes GCC to synthesize the instructions using a narrower mode. For example, if you specify a variable of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>V4SI</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and your architecture does not allow for this specific SIMD type, GCC produces code that uses 4<CODE>SIs</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The types defined in this manner can be used with a subset of normal C operations. Currently, GCC allows using the following operators on these types:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>+, -, *, /, unary minus, ^, |, &amp;, ~, %</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The operations behave like C++<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>valarrays</CODE>. Addition is defined as the addition of the corresponding elements of the operands. For example, in the code below, each of the 4 elements in<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>a</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is added to the corresponding 4 elements in<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>b</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the resulting vector is stored in<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>c</VAR>.</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     typedef int v4si __attribute__ ((vector_size (16)));
     
     v4si a, b, c;
     
     c = a + b;
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Subtraction, multiplication, division, and the logical operations operate in a similar manner. Likewise, the result of using the unary minus or complement operators on a vector type is a vector whose elements are the negative or complemented values of the corresponding elements in the operand.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">It is possible to use shifting operators<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>&lt;&lt;</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>&gt;&gt;</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>on integer-type vectors. The operation is defined as following:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>{a0, a1, ..., an} &gt;&gt; {b0, b1, ..., bn} == {a0 &gt;&gt; b0, a1 &gt;&gt; b1, ..., an &gt;&gt; bn}</CODE>. Vector operands must have the same number of elements.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">For convenience, it is allowed to use a binary vector operation where one operand is a scalar. In that case the compiler transforms the scalar operand into a vector where each element is the scalar from the operation. The transformation happens only if the scalar could be safely converted to the vector-element type. Consider the following code.</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     typedef int v4si __attribute__ ((vector_size (16)));
     
     v4si a, b, c;
     long l;
     
     a = b + 1;    /* a = b + {1,1,1,1}; */
     a = 2 * b;    /* a = {2,2,2,2} * b; */
     
     a = l + a;    /* Error, cannot convert long to int. */
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Vectors can be subscripted as if the vector were an array with the same number of elements and base type. Out of bound accesses invoke undefined behavior at run time. Warnings for out of bound accesses for vector subscription can be enabled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Warray-bounds</SPAN></SAMP>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Vector comparison is supported with standard comparison operators:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>==, !=, &lt;, &lt;=, &gt;, &gt;=</CODE>. Comparison operands can be vector expressions of integer-type or real-type. Comparison between integer-type vectors and real-type vectors are not supported. The result of the comparison is a vector of the same width and number of elements as the comparison operands with a signed integral element type.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Vectors are compared element-wise producing 0 when comparison is false and -1 (constant of the appropriate type where all bits are set) otherwise. Consider the following example.</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     typedef int v4si __attribute__ ((vector_size (16)));
     
     v4si a = {1,2,3,4};
     v4si b = {3,2,1,4};
     v4si c;
     
     c = a &gt;  b;     /* The result would be {0, 0,-1, 0}  */
     c = a == b;     /* The result would be {0,-1, 0,-1}  */
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In C++, the ternary operator<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>?:</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is available.<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a?b:c</CODE>, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>b</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>c</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are vectors of the same type and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an integer vector with the same number of elements of the same size as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>b</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>c</CODE>, computes all three arguments and creates a vector<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>{a[0]?b[0]:c[0], a[1]?b[1]:c[1], ...}</CODE>. Note that unlike in OpenCL,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is thus interpreted as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a != 0</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and not<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a &lt; 0</CODE>. As in the case of binary operations, this syntax is also accepted when one of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>b</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>c</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a scalar that is then transformed into a vector. If both<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>b</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>c</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are scalars and the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>true?b:c</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>has the same size as the element type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a</CODE>, then<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>b</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>c</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>are converted to a vector type whose elements have this type and with the same number of elements as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Vector shuffling is available using functions<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__builtin_shuffle (vec, mask)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__builtin_shuffle (vec0, vec1, mask)</CODE>. Both functions construct a permutation of elements from one or two vectors and return a vector of the same type as the input vector(s). The<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>mask</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is an integral vector with the same width (<VAR>W</VAR>) and element count (<VAR>N</VAR>) as the output vector.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The elements of the input vectors are numbered in memory ordering of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>vec0</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>beginning at 0 and<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>vec1</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>beginning at<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>N</VAR>. The elements of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>mask</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>are considered modulo<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>N</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the single-operand case and modulo 2*<VAR>N</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the two-operand case.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Consider the following example,</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     typedef int v4si __attribute__ ((vector_size (16)));
     
     v4si a = {1,2,3,4};
     v4si b = {5,6,7,8};
     v4si mask1 = {0,1,1,3};
     v4si mask2 = {0,4,2,5};
     v4si res;
     
     res = __builtin_shuffle (a, mask1);       /* res is {1,2,2,4}  */
     res = __builtin_shuffle (a, b, mask2);    /* res is {1,5,3,6}  */
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Note that<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__builtin_shuffle</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is intentionally semantically compatible with the OpenCL<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>shuffle</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>shuffle2</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>functions.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">You can declare variables and use them in function calls and returns, as well as in assignments and some casts. You can specify a vector type as a return type for a function. Vector types can also be used as function arguments. It is possible to cast from one vector type to another, provided they are of the same size (in fact, you can also cast vectors to and from other datatypes of the same size).</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">You cannot operate between vectors of different lengths or different signedness without a cast.