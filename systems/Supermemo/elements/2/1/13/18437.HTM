<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.1 Statements and Declarations in Expressions</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-statements-inside-expressions-2644></A><A name=index-declarations-inside-expressions-2645></A><A name=index-expressions-containing-statements-2646></A><A name=index-macros_002c-statements-in-expressions-2647></A>A compound statement enclosed in parentheses may appear as an expression in GNU C. This allows you to use loops, switches, and local variables within an expression.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Recall that a compound statement is a sequence of statements surrounded by braces; in this construct, parentheses go around the braces. For example:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     ({ int y = foo (); int z;
        if (y &gt; 0) z = y;
        else z = - y;
        z; })
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=noindent>is a valid (though slightly more complex than necessary) expression for the absolute value of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo ()</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The last thing in the compound statement should be an expression followed by a semicolon; the value of this subexpression serves as the value of the entire construct. (If you use some other kind of statement last within the braces, the construct has type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>void</CODE>, and thus effectively no value.)</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">This feature is especially useful in making macro definitions &#8220;safe&#8221; (so that they evaluate each operand exactly once). For example, the &#8220;maximum&#8221; function is commonly defined as a macro in standard C as follows:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     #define max(a,b) ((a) &gt; (b) ? (a) : (b))
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=noindent><A name=index-side-effects_002c-macro-argument-2648></A>But this definition computes either<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>a</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>b</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>twice, with bad results if the operand has side effects. In GNU C, if you know the type of the operands (here taken as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE>), you can define the macro safely as follows:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     #define maxint(a,b) \
       ({int _a = (a), _b = (b); _a &gt; _b ? _a : _b; })
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Embedded statements are not allowed in constant expressions, such as the value of an enumeration constant, the width of a bit-field, or the initial value of a static variable.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">If you don't know the type of the operand, you can still do this, but you must use<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>typeof</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__auto_type</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Typeof.html#Typeof">Typeof</A>).</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In G++, the result value of a statement expression undergoes array and function pointer decay, and is returned by value to the enclosing expression. For instance, if<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>A</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a class, then</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>             A a;
     
             ({a;}).Foo ()
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=noindent>constructs a temporary<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>A</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>object to hold the result of the statement expression, and that is used to invoke<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Foo</CODE>. Therefore the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>this</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>pointer observed by<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not the address of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In a statement expression, any temporaries created within a statement are destroyed at that statement's end. This makes statement expressions inside macros slightly different from function calls. In the latter case temporaries introduced during argument evaluation are destroyed at the end of the statement that includes the function call. In the statement expression case they are destroyed during the statement expression. For instance,</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     #define macro(a)  ({__typeof__(a) b = (a); b + 3; })
     template&lt;typename T&gt; T function(T a) { T b = a; return b + 3; }
     
     void foo ()
     {
       macro (X ());
       function (X ());
     }
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=noindent>has different places where temporaries are destroyed. For the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>macro</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>case, the temporary<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>X</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is destroyed just after the initialization of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>b</CODE>. In the<CODE>function</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>case that temporary is destroyed when the function returns.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">These considerations mean that it is probably a bad idea to use statement expressions of this form in header files that are designed to work with C++. (Note that some versions of the GNU C Library contained header files using statement expressions that lead to precisely this bug.)</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Jumping into a statement expression with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>goto</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or using a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>switch</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>statement outside the statement expression with a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>case</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>default</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>label inside the statement expression is not permitted. Jumping into a statement expression with a computed<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>goto</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Labels-as-Values.html#Labels-as-Values">Labels as Values</A>) has undefined behavior. Jumping out of a statement expression is permitted, but if the statement expression is part of a larger expression then it is unspecified which other subexpressions of that expression have been evaluated except where the language definition requires certain subexpressions to be evaluated before or after the statement expression. In any case, as with a function call, the evaluation of a statement expression is not interleaved with the evaluation of other parts of the containing expression. For example,</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>       foo (), (({ bar1 (); goto a; 0; }) + bar2 ()), baz();
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=noindent>calls<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>bar1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and does not call<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>baz</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>but may or may not call<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>bar2</CODE>. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>bar2</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is called, it is called after<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and before<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>bar1</CODE>.