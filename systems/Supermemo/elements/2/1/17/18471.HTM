<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>6.31 Attribute Syntax</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-attribute-syntax-3014></A>This section describes the syntax with which<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__attribute__</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>may be used, and the constructs to which attribute specifiers bind, for the C language. Some details may vary for C++ and Objective-C. Because of infelicities in the grammar for attributes, some forms described here may not be successfully parsed in all cases.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">There are some problems with the semantics of attributes in C++. For example, there are no manglings for attributes, although they may affect code generation, so problems may arise when attributed types are used in conjunction with templates or overloading. Similarly,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>typeid</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not distinguish between types with different attributes. Support for attributes in C++ may be restricted in future to attributes on declarations only, but not on nested declarators.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Function-Attributes.html#Function-Attributes">Function Attributes</A>, for details of the semantics of attributes applying to functions. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Variable-Attributes.html#Variable-Attributes">Variable Attributes</A>, for details of the semantics of attributes applying to variables. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Type-Attributes.html#Type-Attributes">Type Attributes</A>, for details of the semantics of attributes applying to structure, union and enumerated types.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">An<SPAN class=Apple-converted-space>&nbsp;</SPAN><DFN>attribute specifier</DFN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is of the form<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__attribute__ ((</CODE><VAR>attribute-list</VAR><CODE>))</CODE>. An<SPAN class=Apple-converted-space>&nbsp;</SPAN><DFN>attribute list</DFN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a possibly empty comma-separated sequence of<DFN>attributes</DFN>, where each attribute is one of the following:</P>
<UL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<LI>Empty. Empty attributes are ignored.</LI>
<LI>A word (which may be an identifier such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>unused</CODE>, or a reserved word such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>const</CODE>).</LI>
<LI>A word, followed by, in parentheses, parameters for the attribute. These parameters take one of the following forms:
<UL>
<LI>An identifier. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>mode</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attributes use this form.</LI>
<LI>An identifier followed by a comma and a non-empty comma-separated list of expressions. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>format</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attributes use this form.</LI>
<LI>A possibly empty comma-separated list of expressions. For example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>format_arg</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attributes use this form with the list being a single integer constant expression, and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>alias</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attributes use this form with the list being a single string constant.</LI></UL></LI></UL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">An<SPAN class=Apple-converted-space>&nbsp;</SPAN><DFN>attribute specifier list</DFN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a sequence of one or more attribute specifiers, not separated by any other tokens.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In GNU C, an attribute specifier list may appear after the colon following a label, other than a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>case</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>default</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>label. The only attribute it makes sense to use after a label is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>unused</CODE>. This feature is intended for program-generated code that may contain unused labels, but which is compiled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Wall</SPAN></SAMP>. It is not normally appropriate to use in it human-written code, though it could be useful in cases where the code that jumps to the label is contained within an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>#ifdef</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>conditional. GNU C++ only permits attributes on labels if the attribute specifier is immediately followed by a semicolon (i.e., the label applies to an empty statement). If the semicolon is missing, C++ label attributes are ambiguous, as it is permissible for a declaration, which could begin with an attribute list, to be labelled in C++. Declarations cannot be labelled in C90 or C99, so the ambiguity does not arise there.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">An attribute specifier list may appear as part of a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>enum</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>specifier. It may go either immediately after the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>union</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>enum</CODE>keyword, or after the closing brace. The former syntax is preferred. Where attribute specifiers follow the closing brace, they are considered to relate to the structure, union or enumerated type defined, not to any enclosing declaration the type specifier appears in, and the type defined is not complete until after the attribute specifiers.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Otherwise, an attribute specifier appears as part of a declaration, counting declarations of unnamed parameters and type names, and relates to that declaration (which may be nested in another declaration, for example in the case of a parameter declaration), or to a particular declarator within a declaration. Where an attribute specifier is applied to a parameter declared as a function or an array, it should apply to the function or array rather than the pointer to which the parameter is implicitly converted, but this is not yet correctly implemented.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Any list of specifiers and qualifiers at the start of a declaration may contain attribute specifiers, whether or not such a list may in that context contain storage class specifiers. (Some attributes, however, are essentially in the nature of storage class specifiers, and only make sense where storage class specifiers may be used; for example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>section</CODE>.) There is one necessary limitation to this syntax: the first old-style parameter declaration in a function definition cannot begin with an attribute specifier, because such an attribute applies to the function instead by syntax described below (which, however, is not yet implemented in this case). In some other cases, attribute specifiers are permitted by this grammar but not yet supported by the compiler. All attribute specifiers in this place relate to the declaration as a whole. In the obsolescent usage where a type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is implied by the absence of type specifiers, such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">At present, the first parameter in a function prototype must have some type specifier that is not an attribute specifier; this resolves an ambiguity in the interpretation of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>void f(int (__attribute__((foo)) x))</CODE>, but is subject to change. At present, if the parentheses of a function declarator contain only attributes then those attributes are ignored, rather than yielding an error or warning or implying a single parameter of type int, but this is subject to change.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">An attribute specifier list may appear immediately before a declarator (other than the first) in a comma-separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers. Such attribute specifiers apply only to the identifier before whose declarator they appear. For example, in</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     __attribute__((noreturn)) void d0 (void),
         __attribute__((format(printf, 1, 2))) d1 (const char *, ...),
          d2 (void)
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=noindent>the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>noreturn</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute applies to all the functions declared; the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>format</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute only applies to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>d1</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">An attribute specifier list may appear immediately before the comma,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>=</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or semicolon terminating the declaration of an identifier other than a function definition. Such attribute specifiers apply to the declared object or function. Where an assembler name for an object or function is specified (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Asm-Labels.html#Asm-Labels">Asm Labels</A>), the attribute must follow the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>asm</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>specification.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">An attribute specifier list may, in future, be permitted to appear after the declarator in a function definition (before any old-style parameter declarations or the function body).</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Attribute specifiers may be mixed with type qualifiers appearing inside the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>[]</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>of a parameter array declarator, in the C99 construct by which such qualifiers are applied to the pointer to which the array is implicitly converted. Such attribute specifiers apply to the pointer, not to the array, but at present this is not implemented and they are ignored.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">An attribute specifier list may appear at the start of a nested declarator. At present, there are some limitations in this usage: the attributes correctly apply to the declarator, but for most individual attributes the semantics this implies are not implemented. When attribute specifiers follow the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>of a pointer declarator, they may be mixed with any type qualifiers present. The following describes the formal semantics of this syntax. It makes the most sense if you are familiar with the formal specification of declarators in the ISO C standard.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Consider (as in C99 subclause 6.7.5 paragraph 4) a declaration<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>T D1</CODE>, where<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>T</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>contains declaration specifiers that specify a type<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>Type</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>(such as<CODE>int</CODE>) and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>D1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a declarator that contains an identifier<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>ident</VAR>. The type specified for<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>ident</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>for derived declarators whose type does not include an attribute specifier is as in the ISO C standard.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">If<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>D1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>has the form<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>(<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>attribute-specifier-list</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>D )</CODE>, and the declaration<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>T D</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>specifies the type &#8220;<VAR>derived-declarator-type-list</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>Type</VAR>&#8221; for<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>ident</VAR>, then<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>T D1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>specifies the type &#8220;<VAR>derived-declarator-type-list</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>attribute-specifier-list</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>Type</VAR>&#8221; for<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>ident</VAR>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">If<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>D1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>has the form<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>*<SPAN class=Apple-converted-space>&nbsp;</SPAN></CODE><VAR>type-qualifier-and-attribute-specifier-list</VAR><CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>D</CODE>, and the declaration<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>T D</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>specifies the type &#8220;<VAR>derived-declarator-type-list</VAR><VAR>Type</VAR>&#8221; for<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>ident</VAR>, then<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>T D1</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>specifies the type &#8220;<VAR>derived-declarator-type-list</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>type-qualifier-and-attribute-specifier-list</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>pointer to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>Type</VAR>&#8221; for<VAR>ident</VAR>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">For example,</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     void (__attribute__((noreturn)) ****f) (void);
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=noindent>specifies the type &#8220;pointer to pointer to pointer to pointer to non-returning function returning<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>void</CODE>&#8221;. As another example,</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     char *__attribute__((aligned(8))) *f;
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=noindent>specifies the type &#8220;pointer to 8-byte-aligned pointer to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>char</CODE>&#8221;. Note again that this does not work with most attributes; for example, the usage of &#8216;<SAMP><SPAN class=samp>aligned</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>noreturn</SPAN></SAMP>&#8217; attributes given above is not yet supported.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">For compatibility with existing code written for compiler versions that did not implement attributes on nested declarators, some laxity is allowed in the placing of attributes. If an attribute that only applies to types is applied to a declaration, it is treated as applying to the type of that declaration. If an attribute that only applies to declarations is applied to the type of a declaration, it is treated as applying to that declaration; and, for compatibility with code placing the attributes immediately before the identifier declared, such an attribute applied to a function return type is treated as applying to the function type, and such an attribute applied to an array element type is treated as applying to the array type. If an attribute that only applies to function types is applied to a pointer-to-function type, it is treated as applying to the pointer target type; if such an attribute is applied to a function return type that is not a pointer-to-function type, it is treated as applying to the function type.