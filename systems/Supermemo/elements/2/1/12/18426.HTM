<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>4.10 Qualifiers</H3>
<UL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<LI><CITE>What constitutes an access to an object that has volatile-qualified type (C90 6.5.3, C99 and C11 6.7.3).</CITE>
<P>Such an object is normally accessed by pointers and used for accessing hardware. In most expressions, it is intuitively obvious what is a read and what is a write. For example</P><PRE style="FONT-SIZE: smaller" class=smallexample>          volatile int *dst = <VAR>somevalue</VAR>;
          volatile int *src = <VAR>someothervalue</VAR>;
          *dst = *src;
</PRE>
<P class=noindent>will cause a read of the volatile object pointed to by<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>src</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>and store the value into the volatile object pointed to by<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>dst</VAR>. There is no guarantee that these reads and writes are atomic, especially for objects larger than<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE>.</P>
<P>However, if the volatile storage is not being modified, and the value of the volatile storage is not used, then the situation is less obvious. For example</P><PRE style="FONT-SIZE: smaller" class=smallexample>          volatile int *src = <VAR>somevalue</VAR>;
          *src;
</PRE>
<P>According to the C standard, such an expression is an rvalue whose type is the unqualified version of its original type, i.e.<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE>. Whether GCC interprets this as a read of the volatile object being pointed to or only as a request to evaluate the expression for its side-effects depends on this type.</P>
<P>If it is a scalar type, or on most targets an aggregate type whose only member object is of a scalar type, or a union type whose member objects are of scalar types, the expression is interpreted by GCC as a read of the volatile object; in the other cases, the expression is only evaluated for its side-effects.</P></LI></UL>