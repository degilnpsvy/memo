<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>3.17.45 SPU Options</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-SPU-options-2459></A>These &#8216;<SAMP><SPAN class=samp>-m</SPAN></SAMP>&#8217; options are supported on the SPU:</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><CODE>-mwarn-reloc</CODE></DT>
<DT><CODE>-merror-reloc</CODE></DT>
<DD><A name=index-mwarn-reloc-2460></A><A name=index-merror-reloc-2461></A>The loader for SPU does not handle dynamic relocations. By default, GCC gives an error when it generates code that requires a dynamic relocation.<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mno-error-reloc</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>disables the error,<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mwarn-reloc</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>generates a warning instead.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-msafe-dma</CODE></DT>
<DT><CODE>-munsafe-dma</CODE></DT>
<DD><A name=index-msafe-dma-2462></A><A name=index-munsafe-dma-2463></A>Instructions that initiate or test completion of DMA must not be reordered with respect to loads and stores of the memory that is being accessed. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-munsafe-dma</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>you must use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>volatile</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>keyword to protect memory accesses, but that can lead to inefficient code in places where the memory is known to not change. Rather than mark the memory as volatile, you can use<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-msafe-dma</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to tell the compiler to treat the DMA instructions as potentially affecting all memory.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mbranch-hints</CODE></DT>
<DD><A name=index-mbranch-hints-2464></A>By default, GCC generates a branch hint instruction to avoid pipeline stalls for always-taken or probably-taken branches. A hint is not generated closer than 8 instructions away from its branch. There is little reason to disable them, except for debugging purposes, or to make an object a little bit smaller.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-msmall-mem</CODE></DT>
<DT><CODE>-mlarge-mem</CODE></DT>
<DD><A name=index-msmall-mem-2465></A><A name=index-mlarge-mem-2466></A>By default, GCC generates code assuming that addresses are never larger than 18 bits. With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mlarge-mem</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>code is generated that assumes a full 32-bit address.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mstdmain</CODE></DT>
<DD><A name=index-mstdmain-2467></A>By default, GCC links against startup code that assumes the SPU-style main function interface (which has an unconventional parameter list). With<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mstdmain</SPAN></SAMP>, GCC links your program against startup code that assumes a C99-style interface to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>main</CODE>, including a local copy of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>argv</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>strings.<BR></DD>
<DT><CODE>-mfixed-range=</CODE><VAR>register-range</VAR></DT>
<DD><A name=index-mfixed-range-2468></A>Generate code treating the given register range as fixed registers. A fixed register is one that the register allocator cannot use. This is useful when compiling kernel code. A register range is specified as two registers separated by a dash. Multiple register ranges can be specified separated by a comma.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mea32</CODE></DT>
<DT><CODE>-mea64</CODE></DT>
<DD><A name=index-mea32-2469></A><A name=index-mea64-2470></A>Compile code assuming that pointers to the PPU address space accessed via the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ea</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>named address space qualifier are either 32 or 64 bits wide. The default is 32 bits. As this is an ABI-changing option, all object code in an executable must be compiled with the same setting.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-maddress-space-conversion</CODE></DT>
<DT><CODE>-mno-address-space-conversion</CODE></DT>
<DD><A name=index-maddress-space-conversion-2471></A><A name=index-mno-address-space-conversion-2472></A>Allow/disallow treating the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ea</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>address space as superset of the generic address space. This enables explicit type casts between<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ea</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and generic pointer as well as implicit conversions of generic pointers to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ea</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>pointers. The default is to allow address space pointer conversions.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mcache-size=</CODE><VAR>cache-size</VAR></DT>
<DD><A name=index-mcache-size-2473></A>This option controls the version of libgcc that the compiler links to an executable and selects a software-managed cache for accessing variables in the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ea</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>address space with a particular cache size. Possible options for<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>cache-size</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>are &#8216;<SAMP><SPAN class=samp>8</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>16</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>32</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>64</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>128</SPAN></SAMP>&#8217;. The default cache size is 64KB.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-matomic-updates</CODE></DT>
<DT><CODE>-mno-atomic-updates</CODE></DT>
<DD><A name=index-matomic-updates-2474></A><A name=index-mno-atomic-updates-2475></A>This option controls the version of libgcc that the compiler links to an executable and selects whether atomic updates to the software-managed cache of PPU-side variables are used. If you use atomic updates, changes to a PPU variable from SPU code using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>__ea</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>named address space qualifier do not interfere with changes to other PPU variables residing in the same cache line from PPU code. If you do not use atomic updates, such interference may occur; however, writing back cache lines is more efficient. The default behavior is to use atomic updates.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mdual-nops</CODE></DT>
<DT><CODE>-mdual-nops=</CODE><VAR>n</VAR></DT>
<DD><A name=index-mdual-nops-2476></A>By default, GCC inserts nops to increase dual issue when it expects it to increase performance.<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>can be a value from 0 to 10. A smaller<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR>inserts fewer nops. 10 is the default, 0 is the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-mno-dual-nops</SPAN></SAMP>. Disabled with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Os</SPAN></SAMP>.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mhint-max-nops=</CODE><VAR>n</VAR></DT>
<DD><A name=index-mhint-max-nops-2477></A>Maximum number of nops to insert for a branch hint. A branch hint must be at least 8 instructions away from the branch it is affecting. GCC inserts up to<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>n</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>nops to enforce this, otherwise it does not generate the branch hint.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-mhint-max-distance=</CODE><VAR>n</VAR></DT>
<DD><A name=index-mhint-max-distance-2478></A>The encoding of the branch hint instruction limits the hint to be within 256 instructions of the branch it is affecting. By default, GCC makes sure it is within 125.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>-msafe-hints</CODE></DT>
<DD><A name=index-msafe-hints-2479></A>Work around a hardware bug that causes the SPU to stall indefinitely. By default, GCC inserts the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>hbrp</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>instruction to make sure this stall won't happen.</DD></DL>