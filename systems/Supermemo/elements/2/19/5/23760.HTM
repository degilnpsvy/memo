// kernel/module.c
<P></P>
<P>/*<BR>&nbsp;&nbsp; Copyright (C) 2002 Richard Henderson<BR>&nbsp;&nbsp; Copyright (C) 2001 Rusty Russell, 2002, 2010 Rusty Russell IBM.</P>
<P></P>
<P>&nbsp;&nbsp;&nbsp; This program is free software; you can redistribute it and/or modify<BR>&nbsp;&nbsp;&nbsp; it under the terms of the GNU General Public License as published by<BR>&nbsp;&nbsp;&nbsp; the Free Software Foundation; either version 2 of the License, or<BR>&nbsp;&nbsp;&nbsp; (at your option) any later version.</P>
<P>&nbsp;&nbsp;&nbsp; This program is distributed in the hope that it will be useful,<BR>&nbsp;&nbsp;&nbsp; but WITHOUT ANY WARRANTY; without even the implied warranty of<BR>&nbsp;&nbsp;&nbsp; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp; See the<BR>&nbsp;&nbsp;&nbsp; GNU General Public License for more details.</P>
<P>&nbsp;&nbsp;&nbsp; You should have received a copy of the GNU General Public License<BR>&nbsp;&nbsp;&nbsp; along with this program; if not, write to the Free Software<BR>&nbsp;&nbsp;&nbsp; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA&nbsp; 02111-1307&nbsp; USA<BR>*/<BR>#include &lt;linux/export.h&gt;<BR>#include &lt;linux/moduleloader.h&gt;<BR>#include &lt;linux/ftrace_event.h&gt;<BR>#include &lt;linux/init.h&gt;<BR>#include &lt;linux/kallsyms.h&gt;<BR>#include &lt;linux/file.h&gt;<BR>#include &lt;linux/fs.h&gt;<BR>#include &lt;linux/sysfs.h&gt;<BR>#include &lt;linux/kernel.h&gt;<BR>#include &lt;linux/slab.h&gt;<BR>#include &lt;linux/vmalloc.h&gt;<BR>#include &lt;linux/elf.h&gt;<BR>#include &lt;linux/proc_fs.h&gt;<BR>#include &lt;linux/security.h&gt;<BR>#include &lt;linux/seq_file.h&gt;<BR>#include &lt;linux/syscalls.h&gt;<BR>#include &lt;linux/fcntl.h&gt;<BR>#include &lt;linux/rcupdate.h&gt;<BR>#include &lt;linux/capability.h&gt;<BR>#include &lt;linux/cpu.h&gt;<BR>#include &lt;linux/moduleparam.h&gt;<BR>#include &lt;linux/errno.h&gt;<BR>#include &lt;linux/err.h&gt;<BR>#include &lt;linux/vermagic.h&gt;<BR>#include &lt;linux/notifier.h&gt;<BR>#include &lt;linux/sched.h&gt;<BR>#include &lt;linux/stop_machine.h&gt;<BR>#include &lt;linux/device.h&gt;<BR>#include &lt;linux/string.h&gt;<BR>#include &lt;linux/mutex.h&gt;<BR>#include &lt;linux/rculist.h&gt;<BR>#include &lt;asm/uaccess.h&gt;<BR>#include &lt;asm/cacheflush.h&gt;<BR>#include &lt;asm/mmu_context.h&gt;<BR>#include &lt;linux/license.h&gt;<BR>#include &lt;asm/sections.h&gt;<BR>#include &lt;linux/tracepoint.h&gt;<BR>#include &lt;linux/ftrace.h&gt;<BR>#include &lt;linux/async.h&gt;<BR>#include &lt;linux/percpu.h&gt;<BR>#include &lt;linux/kmemleak.h&gt;<BR>#include &lt;linux/jump_label.h&gt;<BR>#include &lt;linux/pfn.h&gt;<BR>#include &lt;linux/bsearch.h&gt;<BR>#include &lt;linux/fips.h&gt;<BR>#include &lt;uapi/linux/module.h&gt;<BR>#include "module-internal.h"</P>
<P>#define CREATE_TRACE_POINTS<BR>#include &lt;trace/events/module.h&gt;</P>
<P>#ifndef ARCH_SHF_SMALL<BR>#define ARCH_SHF_SMALL 0<BR>#endif</P>
<P>/*<BR>&nbsp;* Modules' sections will be aligned on page boundaries<BR>&nbsp;* to ensure complete separation of code and data, but<BR>&nbsp;* only when CONFIG_DEBUG_SET_MODULE_RONX=y<BR>&nbsp;*/<BR>#ifdef CONFIG_DEBUG_SET_MODULE_RONX<BR># define debug_align(X) ALIGN(X, PAGE_SIZE)<BR>#else<BR># define debug_align(X) (X)<BR>#endif</P>
<P>/*<BR>&nbsp;* Given BASE and SIZE this macro calculates the number of pages the<BR>&nbsp;* memory regions occupies<BR>&nbsp;*/<BR>#define MOD_NUMBER_OF_PAGES(BASE, SIZE) (((SIZE) &gt; 0) ?&nbsp;&nbsp;\<BR>&nbsp;&nbsp;(PFN_DOWN((unsigned long)(BASE) + (SIZE) - 1) -&nbsp;\<BR>&nbsp;&nbsp;&nbsp; PFN_DOWN((unsigned long)BASE) + 1)&nbsp;\<BR>&nbsp;&nbsp;: (0UL))</P>
<P>/* If this is set, the section belongs in the init part of the module */<BR>#define INIT_OFFSET_MASK (1UL &lt;&lt; (BITS_PER_LONG-1))</P>
<P>/*<BR>&nbsp;* Mutex protects:<BR>&nbsp;* 1) List of modules (also safely readable with preempt_disable),<BR>&nbsp;* 2) module_use links,<BR>&nbsp;* 3) module_addr_min/module_addr_max.<BR>&nbsp;* (delete uses stop_machine/add uses RCU list operations). */<BR>DEFINE_MUTEX(module_mutex);<BR>EXPORT_SYMBOL_GPL(module_mutex);<BR>static LIST_HEAD(modules);<BR>#ifdef CONFIG_KGDB_KDB<BR>struct list_head *kdb_modules = &amp;modules; /* kdb needs the list of modules */<BR>#endif /* CONFIG_KGDB_KDB */</P>
<P>#ifdef CONFIG_MODULE_SIG<BR>#ifdef CONFIG_MODULE_SIG_FORCE<BR>static bool sig_enforce = true;<BR>#else<BR>static bool sig_enforce = false;</P>
<P>static int param_set_bool_enable_only(const char *val,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct kernel_param *kp)<BR>{<BR>&nbsp;int err;<BR>&nbsp;bool test;<BR>&nbsp;struct kernel_param dummy_kp = *kp;</P>
<P>&nbsp;dummy_kp.arg = &amp;test;</P>
<P>&nbsp;err = param_set_bool(val, &amp;dummy_kp);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;return err;</P>
<P>&nbsp;/* Don't let them unset it once it's set! */<BR>&nbsp;if (!test &amp;&amp; sig_enforce)<BR>&nbsp;&nbsp;return -EROFS;</P>
<P>&nbsp;if (test)<BR>&nbsp;&nbsp;sig_enforce = true;<BR>&nbsp;return 0;<BR>}</P>
<P>static const struct kernel_param_ops param_ops_bool_enable_only = {<BR>&nbsp;.set = param_set_bool_enable_only,<BR>&nbsp;.get = param_get_bool,<BR>};<BR>#define param_check_bool_enable_only param_check_bool</P>
<P>module_param(sig_enforce, bool_enable_only, 0644);<BR>#endif /* !CONFIG_MODULE_SIG_FORCE */<BR>#endif /* CONFIG_MODULE_SIG */</P>
<P>/* Block module loading/unloading? */<BR>int modules_disabled = 0;<BR>core_param(nomodule, modules_disabled, bint, 0);</P>
<P>/* Waiting for a module to finish initializing? */<BR>static DECLARE_WAIT_QUEUE_HEAD(module_wq);</P>
<P>static BLOCKING_NOTIFIER_HEAD(module_notify_list);</P>
<P>/* Bounds of module allocation, for speeding __module_address.<BR>&nbsp;* Protected by module_mutex. */<BR>static unsigned long module_addr_min = -1UL, module_addr_max = 0;</P>
<P>int register_module_notifier(struct notifier_block * nb)<BR>{<BR>&nbsp;return blocking_notifier_chain_register(&amp;module_notify_list, nb);<BR>}<BR>EXPORT_SYMBOL(register_module_notifier);</P>
<P>int unregister_module_notifier(struct notifier_block * nb)<BR>{<BR>&nbsp;return blocking_notifier_chain_unregister(&amp;module_notify_list, nb);<BR>}<BR>EXPORT_SYMBOL(unregister_module_notifier);</P>
<P>struct load_info {<BR>&nbsp;Elf_Ehdr *hdr;<BR>&nbsp;unsigned long len;<BR>&nbsp;Elf_Shdr *sechdrs;<BR>&nbsp;char *secstrings, *strtab;<BR>&nbsp;unsigned long symoffs, stroffs;<BR>&nbsp;struct _ddebug *debug;<BR>&nbsp;unsigned int num_debug;<BR>&nbsp;bool sig_ok;<BR>&nbsp;struct {<BR>&nbsp;&nbsp;unsigned int sym, str, mod, vers, info, pcpu;<BR>&nbsp;} index;<BR>};</P>
<P>/* We require a truly strong try_module_get(): 0 means failure due to<BR>&nbsp;&nbsp; ongoing or failed initialization etc. */<BR>static inline int strong_try_module_get(struct module *mod)<BR>{<BR>&nbsp;BUG_ON(mod &amp;&amp; mod-&gt;state == MODULE_STATE_UNFORMED);<BR>&nbsp;if (mod &amp;&amp; mod-&gt;state == MODULE_STATE_COMING)<BR>&nbsp;&nbsp;return -EBUSY;<BR>&nbsp;if (try_module_get(mod))<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;else<BR>&nbsp;&nbsp;return -ENOENT;<BR>}</P>
<P>static inline void add_taint_module(struct module *mod, unsigned flag,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum lockdep_ok lockdep_ok)<BR>{<BR>&nbsp;add_taint(flag, lockdep_ok);<BR>&nbsp;mod-&gt;taints |= (1U &lt;&lt; flag);<BR>}</P>
<P>/*<BR>&nbsp;* A thread that wants to hold a reference to a module only while it<BR>&nbsp;* is running can call this to safely exit.&nbsp; nfsd and lockd use this.<BR>&nbsp;*/<BR>void __module_put_and_exit(struct module *mod, long code)<BR>{<BR>&nbsp;module_put(mod);<BR>&nbsp;do_exit(code);<BR>}<BR>EXPORT_SYMBOL(__module_put_and_exit);</P>
<P>/* Find a module section: 0 means not found. */<BR>static unsigned int find_sec(const struct load_info *info, const char *name)<BR>{<BR>&nbsp;unsigned int i;</P>
<P>&nbsp;for (i = 1; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<BR>&nbsp;&nbsp;Elf_Shdr *shdr = &amp;info-&gt;sechdrs[i];<BR>&nbsp;&nbsp;/* Alloc bit cleared means "ignore it." */<BR>&nbsp;&nbsp;if ((shdr-&gt;sh_flags &amp; SHF_ALLOC)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; strcmp(info-&gt;secstrings + shdr-&gt;sh_name, name) == 0)<BR>&nbsp;&nbsp;&nbsp;return i;<BR>&nbsp;}<BR>&nbsp;return 0;<BR>}</P>
<P>/* Find a module section, or NULL. */<BR>static void *section_addr(const struct load_info *info, const char *name)<BR>{<BR>&nbsp;/* Section 0 has sh_addr 0. */<BR>&nbsp;return (void *)info-&gt;sechdrs[find_sec(info, name)].sh_addr;<BR>}</P>
<P>/* Find a module section, or NULL.&nbsp; Fill in number of "objects" in section. */<BR>static void *section_objs(const struct load_info *info,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp; size_t object_size,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int *num)<BR>{<BR>&nbsp;unsigned int sec = find_sec(info, name);</P>
<P>&nbsp;/* Section 0 has sh_addr 0 and sh_size 0. */<BR>&nbsp;*num = info-&gt;sechdrs[sec].sh_size / object_size;<BR>&nbsp;return (void *)info-&gt;sechdrs[sec].sh_addr;<BR>}</P>
<P>/* Provided by the linker */<BR>extern const struct kernel_symbol __start___ksymtab[];<BR>extern const struct kernel_symbol __stop___ksymtab[];<BR>extern const struct kernel_symbol __start___ksymtab_gpl[];<BR>extern const struct kernel_symbol __stop___ksymtab_gpl[];<BR>extern const struct kernel_symbol __start___ksymtab_gpl_future[];<BR>extern const struct kernel_symbol __stop___ksymtab_gpl_future[];<BR>extern const unsigned long __start___kcrctab[];<BR>extern const unsigned long __start___kcrctab_gpl[];<BR>extern const unsigned long __start___kcrctab_gpl_future[];<BR>#ifdef CONFIG_UNUSED_SYMBOLS<BR>extern const struct kernel_symbol __start___ksymtab_unused[];<BR>extern const struct kernel_symbol __stop___ksymtab_unused[];<BR>extern const struct kernel_symbol __start___ksymtab_unused_gpl[];<BR>extern const struct kernel_symbol __stop___ksymtab_unused_gpl[];<BR>extern const unsigned long __start___kcrctab_unused[];<BR>extern const unsigned long __start___kcrctab_unused_gpl[];<BR>#endif</P>
<P>#ifndef CONFIG_MODVERSIONS<BR>#define symversion(base, idx) NULL<BR>#else<BR>#define symversion(base, idx) ((base != NULL) ? ((base) + (idx)) : NULL)<BR>#endif</P>
<P>static bool each_symbol_in_section(const struct symsearch *arr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int arrsize,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module *owner,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool (*fn)(const struct symsearch *syms,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module *owner,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data)<BR>{<BR>&nbsp;unsigned int j;</P>
<P>&nbsp;for (j = 0; j &lt; arrsize; j++) {<BR>&nbsp;&nbsp;if (fn(&amp;arr[j], owner, data))<BR>&nbsp;&nbsp;&nbsp;return true;<BR>&nbsp;}</P>
<P>&nbsp;return false;<BR>}</P>
<P>/* Returns true as soon as fn returns true, otherwise false. */<BR>bool each_symbol_section(bool (*fn)(const struct symsearch *arr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module *owner,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data),<BR>&nbsp;&nbsp;&nbsp; void *data)<BR>{<BR>&nbsp;struct module *mod;<BR>&nbsp;static const struct symsearch arr[] = {<BR>&nbsp;&nbsp;{ __start___ksymtab, __stop___ksymtab, __start___kcrctab,<BR>&nbsp;&nbsp;&nbsp; NOT_GPL_ONLY, false },<BR>&nbsp;&nbsp;{ __start___ksymtab_gpl, __stop___ksymtab_gpl,<BR>&nbsp;&nbsp;&nbsp; __start___kcrctab_gpl,<BR>&nbsp;&nbsp;&nbsp; GPL_ONLY, false },<BR>&nbsp;&nbsp;{ __start___ksymtab_gpl_future, __stop___ksymtab_gpl_future,<BR>&nbsp;&nbsp;&nbsp; __start___kcrctab_gpl_future,<BR>&nbsp;&nbsp;&nbsp; WILL_BE_GPL_ONLY, false },<BR>#ifdef CONFIG_UNUSED_SYMBOLS<BR>&nbsp;&nbsp;{ __start___ksymtab_unused, __stop___ksymtab_unused,<BR>&nbsp;&nbsp;&nbsp; __start___kcrctab_unused,<BR>&nbsp;&nbsp;&nbsp; NOT_GPL_ONLY, true },<BR>&nbsp;&nbsp;{ __start___ksymtab_unused_gpl, __stop___ksymtab_unused_gpl,<BR>&nbsp;&nbsp;&nbsp; __start___kcrctab_unused_gpl,<BR>&nbsp;&nbsp;&nbsp; GPL_ONLY, true },<BR>#endif<BR>&nbsp;};</P>
<P>&nbsp;if (each_symbol_in_section(arr, ARRAY_SIZE(arr), NULL, fn, data))<BR>&nbsp;&nbsp;return true;</P>
<P>&nbsp;list_for_each_entry_rcu(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;struct symsearch arr[] = {<BR>&nbsp;&nbsp;&nbsp;{ mod-&gt;syms, mod-&gt;syms + mod-&gt;num_syms, mod-&gt;crcs,<BR>&nbsp;&nbsp;&nbsp;&nbsp; NOT_GPL_ONLY, false },<BR>&nbsp;&nbsp;&nbsp;{ mod-&gt;gpl_syms, mod-&gt;gpl_syms + mod-&gt;num_gpl_syms,<BR>&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;gpl_crcs,<BR>&nbsp;&nbsp;&nbsp;&nbsp; GPL_ONLY, false },<BR>&nbsp;&nbsp;&nbsp;{ mod-&gt;gpl_future_syms,<BR>&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;gpl_future_syms + mod-&gt;num_gpl_future_syms,<BR>&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;gpl_future_crcs,<BR>&nbsp;&nbsp;&nbsp;&nbsp; WILL_BE_GPL_ONLY, false },<BR>#ifdef CONFIG_UNUSED_SYMBOLS<BR>&nbsp;&nbsp;&nbsp;{ mod-&gt;unused_syms,<BR>&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;unused_syms + mod-&gt;num_unused_syms,<BR>&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;unused_crcs,<BR>&nbsp;&nbsp;&nbsp;&nbsp; NOT_GPL_ONLY, true },<BR>&nbsp;&nbsp;&nbsp;{ mod-&gt;unused_gpl_syms,<BR>&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;unused_gpl_syms + mod-&gt;num_unused_gpl_syms,<BR>&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;unused_gpl_crcs,<BR>&nbsp;&nbsp;&nbsp;&nbsp; GPL_ONLY, true },<BR>#endif<BR>&nbsp;&nbsp;};</P>
<P>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;if (each_symbol_in_section(arr, ARRAY_SIZE(arr), mod, fn, data))<BR>&nbsp;&nbsp;&nbsp;return true;<BR>&nbsp;}<BR>&nbsp;return false;<BR>}<BR>EXPORT_SYMBOL_GPL(each_symbol_section);</P>
<P>struct find_symbol_arg {<BR>&nbsp;/* Input */<BR>&nbsp;const char *name;<BR>&nbsp;bool gplok;<BR>&nbsp;bool warn;</P>
<P>&nbsp;/* Output */<BR>&nbsp;struct module *owner;<BR>&nbsp;const unsigned long *crc;<BR>&nbsp;const struct kernel_symbol *sym;<BR>};</P>
<P>static bool check_symbol(const struct symsearch *syms,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct module *owner,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int symnum, void *data)<BR>{<BR>&nbsp;struct find_symbol_arg *fsa = data;</P>
<P>&nbsp;if (!fsa-&gt;gplok) {<BR>&nbsp;&nbsp;if (syms-&gt;licence == GPL_ONLY)<BR>&nbsp;&nbsp;&nbsp;return false;<BR>&nbsp;&nbsp;if (syms-&gt;licence == WILL_BE_GPL_ONLY &amp;&amp; fsa-&gt;warn) {<BR>&nbsp;&nbsp;&nbsp;printk(KERN_WARNING "Symbol %s is being used "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "by a non-GPL module, which will not "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "be allowed in the future\n", fsa-&gt;name);<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>#ifdef CONFIG_UNUSED_SYMBOLS<BR>&nbsp;if (syms-&gt;unused &amp;&amp; fsa-&gt;warn) {<BR>&nbsp;&nbsp;printk(KERN_WARNING "Symbol %s is marked as UNUSED, "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "however this module is using it.\n", fsa-&gt;name);<BR>&nbsp;&nbsp;printk(KERN_WARNING<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "This symbol will go away in the future.\n");<BR>&nbsp;&nbsp;printk(KERN_WARNING<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Please evalute if this is the right api to use and if "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "it really is, submit a report the linux kernel "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "mailinglist together with submitting your code for "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "inclusion.\n");<BR>&nbsp;}<BR>#endif</P>
<P>&nbsp;fsa-&gt;owner = owner;<BR>&nbsp;fsa-&gt;crc = symversion(syms-&gt;crcs, symnum);<BR>&nbsp;fsa-&gt;sym = &amp;syms-&gt;start[symnum];<BR>&nbsp;return true;<BR>}</P>
<P>static int cmp_name(const void *va, const void *vb)<BR>{<BR>&nbsp;const char *a;<BR>&nbsp;const struct kernel_symbol *b;<BR>&nbsp;a = va; b = vb;<BR>&nbsp;return strcmp(a, b-&gt;name);<BR>}</P>
<P>static bool find_symbol_in_section(const struct symsearch *syms,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module *owner,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data)<BR>{<BR>&nbsp;struct find_symbol_arg *fsa = data;<BR>&nbsp;struct kernel_symbol *sym;</P>
<P>&nbsp;sym = bsearch(fsa-&gt;name, syms-&gt;start, syms-&gt;stop - syms-&gt;start,<BR>&nbsp;&nbsp;&nbsp;sizeof(struct kernel_symbol), cmp_name);</P>
<P>&nbsp;if (sym != NULL &amp;&amp; check_symbol(syms, owner, sym - syms-&gt;start, data))<BR>&nbsp;&nbsp;return true;</P>
<P>&nbsp;return false;<BR>}</P>
<P>/* Find a symbol and return it, along with, (optional) crc and<BR>&nbsp;* (optional) module which owns it.&nbsp; Needs preempt disabled or module_mutex. */<BR>const struct kernel_symbol *find_symbol(const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct module **owner,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const unsigned long **crc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool gplok,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool warn)<BR>{<BR>&nbsp;struct find_symbol_arg fsa;</P>
<P>&nbsp;fsa.name = name;<BR>&nbsp;fsa.gplok = gplok;<BR>&nbsp;fsa.warn = warn;</P>
<P>&nbsp;if (each_symbol_section(find_symbol_in_section, &amp;fsa)) {<BR>&nbsp;&nbsp;if (owner)<BR>&nbsp;&nbsp;&nbsp;*owner = fsa.owner;<BR>&nbsp;&nbsp;if (crc)<BR>&nbsp;&nbsp;&nbsp;*crc = fsa.crc;<BR>&nbsp;&nbsp;return fsa.sym;<BR>&nbsp;}</P>
<P>&nbsp;pr_debug("Failed to find symbol %s\n", name);<BR>&nbsp;return NULL;<BR>}<BR>EXPORT_SYMBOL_GPL(find_symbol);</P>
<P>/* Search for module by name: must hold module_mutex. */<BR>static struct module *find_module_all(const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool even_unformed)<BR>{<BR>&nbsp;struct module *mod;</P>
<P>&nbsp;list_for_each_entry(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;if (!even_unformed &amp;&amp; mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;if (strcmp(mod-&gt;name, name) == 0)<BR>&nbsp;&nbsp;&nbsp;return mod;<BR>&nbsp;}<BR>&nbsp;return NULL;<BR>}</P>
<P>struct module *find_module(const char *name)<BR>{<BR>&nbsp;return find_module_all(name, false);<BR>}<BR>EXPORT_SYMBOL_GPL(find_module);</P>
<P>#ifdef CONFIG_SMP</P>
<P>static inline void __percpu *mod_percpu(struct module *mod)<BR>{<BR>&nbsp;return mod-&gt;percpu;<BR>}</P>
<P>static int percpu_modalloc(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long size, unsigned long align)<BR>{<BR>&nbsp;if (align &gt; PAGE_SIZE) {<BR>&nbsp;&nbsp;printk(KERN_WARNING "%s: per-cpu alignment %li &gt; %li\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name, align, PAGE_SIZE);<BR>&nbsp;&nbsp;align = PAGE_SIZE;<BR>&nbsp;}</P>
<P>&nbsp;mod-&gt;percpu = __alloc_reserved_percpu(size, align);<BR>&nbsp;if (!mod-&gt;percpu) {<BR>&nbsp;&nbsp;printk(KERN_WARNING<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%s: Could not allocate %lu bytes percpu data\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name, size);<BR>&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;}<BR>&nbsp;mod-&gt;percpu_size = size;<BR>&nbsp;return 0;<BR>}</P>
<P>static void percpu_modfree(struct module *mod)<BR>{<BR>&nbsp;free_percpu(mod-&gt;percpu);<BR>}</P>
<P>static unsigned int find_pcpusec(struct load_info *info)<BR>{<BR>&nbsp;return find_sec(info, ".data..percpu");<BR>}</P>
<P>static void percpu_modcopy(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *from, unsigned long size)<BR>{<BR>&nbsp;int cpu;</P>
<P>&nbsp;for_each_possible_cpu(cpu)<BR>&nbsp;&nbsp;memcpy(per_cpu_ptr(mod-&gt;percpu, cpu), from, size);<BR>}</P>
<P>/**<BR>&nbsp;* is_module_percpu_address - test whether address is from module static percpu<BR>&nbsp;* @addr: address to test<BR>&nbsp;*<BR>&nbsp;* Test whether @addr belongs to module static percpu area.<BR>&nbsp;*<BR>&nbsp;* RETURNS:<BR>&nbsp;* %true if @addr is from module static percpu area<BR>&nbsp;*/<BR>bool is_module_percpu_address(unsigned long addr)<BR>{<BR>&nbsp;struct module *mod;<BR>&nbsp;unsigned int cpu;</P>
<P>&nbsp;preempt_disable();</P>
<P>&nbsp;list_for_each_entry_rcu(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;if (!mod-&gt;percpu_size)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;for_each_possible_cpu(cpu) {<BR>&nbsp;&nbsp;&nbsp;void *start = per_cpu_ptr(mod-&gt;percpu, cpu);</P>
<P>&nbsp;&nbsp;&nbsp;if ((void *)addr &gt;= start &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void *)addr &lt; start + mod-&gt;percpu_size) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;preempt_enable();<BR>&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;preempt_enable();<BR>&nbsp;return false;<BR>}</P>
<P>#else /* ... !CONFIG_SMP */</P>
<P>static inline void __percpu *mod_percpu(struct module *mod)<BR>{<BR>&nbsp;return NULL;<BR>}<BR>static inline int percpu_modalloc(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long size, unsigned long align)<BR>{<BR>&nbsp;return -ENOMEM;<BR>}<BR>static inline void percpu_modfree(struct module *mod)<BR>{<BR>}<BR>static unsigned int find_pcpusec(struct load_info *info)<BR>{<BR>&nbsp;return 0;<BR>}<BR>static inline void percpu_modcopy(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *from, unsigned long size)<BR>{<BR>&nbsp;/* pcpusec should be 0, and size of that section should be 0. */<BR>&nbsp;BUG_ON(size != 0);<BR>}<BR>bool is_module_percpu_address(unsigned long addr)<BR>{<BR>&nbsp;return false;<BR>}</P>
<P>#endif /* CONFIG_SMP */</P>
<P>#define MODINFO_ATTR(field)&nbsp;\<BR>static void setup_modinfo_##field(struct module *mod, const char *s)&nbsp; \<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;mod-&gt;field = kstrdup(s, GFP_KERNEL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>static ssize_t show_modinfo_##field(struct module_attribute *mattr,&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;struct module_kobject *mk, char *buffer)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;return sprintf(buffer, "%s\n", mk-&gt;mod-&gt;field);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>static int modinfo_##field##_exists(struct module *mod)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;return mod-&gt;field != NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>static void free_modinfo_##field(struct module *mod)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;kfree(mod-&gt;field);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;mod-&gt;field = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>static struct module_attribute modinfo_##field = {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;.attr = { .name = __stringify(field), .mode = 0444 },&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;.show = show_modinfo_##field,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;.setup = setup_modinfo_##field,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;.test = modinfo_##field##_exists,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;.free = free_modinfo_##field,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>};</P>
<P>MODINFO_ATTR(version);<BR>MODINFO_ATTR(srcversion);</P>
<P>static char last_unloaded_module[MODULE_NAME_LEN+1];</P>
<P>#ifdef CONFIG_MODULE_UNLOAD</P>
<P>EXPORT_TRACEPOINT_SYMBOL(module_get);</P>
<P>/* Init the unload section of the module. */<BR>static int module_unload_init(struct module *mod)<BR>{<BR>&nbsp;mod-&gt;refptr = alloc_percpu(struct module_ref);<BR>&nbsp;if (!mod-&gt;refptr)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;INIT_LIST_HEAD(&amp;mod-&gt;source_list);<BR>&nbsp;INIT_LIST_HEAD(&amp;mod-&gt;target_list);</P>
<P>&nbsp;/* Hold reference count during initialization. */<BR>&nbsp;__this_cpu_write(mod-&gt;refptr-&gt;incs, 1);<BR>&nbsp;/* Backwards compatibility macros put refcount during init. */<BR>&nbsp;mod-&gt;waiter = current;</P>
<P>&nbsp;return 0;<BR>}</P>
<P>/* Does a already use b? */<BR>static int already_uses(struct module *a, struct module *b)<BR>{<BR>&nbsp;struct module_use *use;</P>
<P>&nbsp;list_for_each_entry(use, &amp;b-&gt;source_list, source_list) {<BR>&nbsp;&nbsp;if (use-&gt;source == a) {<BR>&nbsp;&nbsp;&nbsp;pr_debug("%s uses %s!\n", a-&gt;name, b-&gt;name);<BR>&nbsp;&nbsp;&nbsp;return 1;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;pr_debug("%s does not use %s!\n", a-&gt;name, b-&gt;name);<BR>&nbsp;return 0;<BR>}</P>
<P>/*<BR>&nbsp;* Module a uses b<BR>&nbsp;*&nbsp; - we add 'a' as a "source", 'b' as a "target" of module use<BR>&nbsp;*&nbsp; - the module_use is added to the list of 'b' sources (so<BR>&nbsp;*&nbsp;&nbsp;&nbsp; 'b' can walk the list to see who sourced them), and of 'a'<BR>&nbsp;*&nbsp;&nbsp;&nbsp; targets (so 'a' can see what modules it targets).<BR>&nbsp;*/<BR>static int add_module_usage(struct module *a, struct module *b)<BR>{<BR>&nbsp;struct module_use *use;</P>
<P>&nbsp;pr_debug("Allocating new usage for %s.\n", a-&gt;name);<BR>&nbsp;use = kmalloc(sizeof(*use), GFP_ATOMIC);<BR>&nbsp;if (!use) {<BR>&nbsp;&nbsp;printk(KERN_WARNING "%s: out of memory loading\n", a-&gt;name);<BR>&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;}</P>
<P>&nbsp;use-&gt;source = a;<BR>&nbsp;use-&gt;target = b;<BR>&nbsp;list_add(&amp;use-&gt;source_list, &amp;b-&gt;source_list);<BR>&nbsp;list_add(&amp;use-&gt;target_list, &amp;a-&gt;target_list);<BR>&nbsp;return 0;<BR>}</P>
<P>/* Module a uses b: caller needs module_mutex() */<BR>int ref_module(struct module *a, struct module *b)<BR>{<BR>&nbsp;int err;</P>
<P>&nbsp;if (b == NULL || already_uses(a, b))<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;/* If module isn't available, we fail. */<BR>&nbsp;err = strong_try_module_get(b);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;return err;</P>
<P>&nbsp;err = add_module_usage(a, b);<BR>&nbsp;if (err) {<BR>&nbsp;&nbsp;module_put(b);<BR>&nbsp;&nbsp;return err;<BR>&nbsp;}<BR>&nbsp;return 0;<BR>}<BR>EXPORT_SYMBOL_GPL(ref_module);</P>
<P>/* Clear the unload stuff of the module. */<BR>static void module_unload_free(struct module *mod)<BR>{<BR>&nbsp;struct module_use *use, *tmp;</P>
<P>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;list_for_each_entry_safe(use, tmp, &amp;mod-&gt;target_list, target_list) {<BR>&nbsp;&nbsp;struct module *i = use-&gt;target;<BR>&nbsp;&nbsp;pr_debug("%s unusing %s\n", mod-&gt;name, i-&gt;name);<BR>&nbsp;&nbsp;module_put(i);<BR>&nbsp;&nbsp;list_del(&amp;use-&gt;source_list);<BR>&nbsp;&nbsp;list_del(&amp;use-&gt;target_list);<BR>&nbsp;&nbsp;kfree(use);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;module_mutex);</P>
<P>&nbsp;free_percpu(mod-&gt;refptr);<BR>}</P>
<P>#ifdef CONFIG_MODULE_FORCE_UNLOAD<BR>static inline int try_force_unload(unsigned int flags)<BR>{<BR>&nbsp;int ret = (flags &amp; O_TRUNC);<BR>&nbsp;if (ret)<BR>&nbsp;&nbsp;add_taint(TAINT_FORCED_RMMOD, LOCKDEP_NOW_UNRELIABLE);<BR>&nbsp;return ret;<BR>}<BR>#else<BR>static inline int try_force_unload(unsigned int flags)<BR>{<BR>&nbsp;return 0;<BR>}<BR>#endif /* CONFIG_MODULE_FORCE_UNLOAD */</P>
<P>struct stopref<BR>{<BR>&nbsp;struct module *mod;<BR>&nbsp;int flags;<BR>&nbsp;int *forced;<BR>};</P>
<P>/* Whole machine is stopped with interrupts off when this runs. */<BR>static int __try_stop_module(void *_sref)<BR>{<BR>&nbsp;struct stopref *sref = _sref;</P>
<P>&nbsp;/* If it's not unused, quit unless we're forcing. */<BR>&nbsp;if (module_refcount(sref-&gt;mod) != 0) {<BR>&nbsp;&nbsp;if (!(*sref-&gt;forced = try_force_unload(sref-&gt;flags)))<BR>&nbsp;&nbsp;&nbsp;return -EWOULDBLOCK;<BR>&nbsp;}</P>
<P>&nbsp;/* Mark it as dying. */<BR>&nbsp;sref-&gt;mod-&gt;state = MODULE_STATE_GOING;<BR>&nbsp;return 0;<BR>}</P>
<P>static int try_stop_module(struct module *mod, int flags, int *forced)<BR>{<BR>&nbsp;if (flags &amp; O_NONBLOCK) {<BR>&nbsp;&nbsp;struct stopref sref = { mod, flags, forced };</P>
<P>&nbsp;&nbsp;return stop_machine(__try_stop_module, &amp;sref, NULL);<BR>&nbsp;} else {<BR>&nbsp;&nbsp;/* We don't need to stop the machine for this. */<BR>&nbsp;&nbsp;mod-&gt;state = MODULE_STATE_GOING;<BR>&nbsp;&nbsp;synchronize_sched();<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}<BR>}</P>
<P>unsigned long module_refcount(struct module *mod)<BR>{<BR>&nbsp;unsigned long incs = 0, decs = 0;<BR>&nbsp;int cpu;</P>
<P>&nbsp;for_each_possible_cpu(cpu)<BR>&nbsp;&nbsp;decs += per_cpu_ptr(mod-&gt;refptr, cpu)-&gt;decs;<BR>&nbsp;/*<BR>&nbsp; * ensure the incs are added up after the decs.<BR>&nbsp; * module_put ensures incs are visible before decs with smp_wmb.<BR>&nbsp; *<BR>&nbsp; * This 2-count scheme avoids the situation where the refcount<BR>&nbsp; * for CPU0 is read, then CPU0 increments the module refcount,<BR>&nbsp; * then CPU1 drops that refcount, then the refcount for CPU1 is<BR>&nbsp; * read. We would record a decrement but not its corresponding<BR>&nbsp; * increment so we would see a low count (disaster).<BR>&nbsp; *<BR>&nbsp; * Rare situation? But module_refcount can be preempted, and we<BR>&nbsp; * might be tallying up 4096+ CPUs. So it is not impossible.<BR>&nbsp; */<BR>&nbsp;smp_rmb();<BR>&nbsp;for_each_possible_cpu(cpu)<BR>&nbsp;&nbsp;incs += per_cpu_ptr(mod-&gt;refptr, cpu)-&gt;incs;<BR>&nbsp;return incs - decs;<BR>}<BR>EXPORT_SYMBOL(module_refcount);</P>
<P>/* This exists whether we can unload or not */<BR>static void free_module(struct module *mod);</P>
<P>static void wait_for_zero_refcount(struct module *mod)<BR>{<BR>&nbsp;/* Since we might sleep for some time, release the mutex first */<BR>&nbsp;mutex_unlock(&amp;module_mutex);<BR>&nbsp;for (;;) {<BR>&nbsp;&nbsp;pr_debug("Looking at refcount...\n");<BR>&nbsp;&nbsp;set_current_state(TASK_UNINTERRUPTIBLE);<BR>&nbsp;&nbsp;if (module_refcount(mod) == 0)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;schedule();<BR>&nbsp;}<BR>&nbsp;current-&gt;state = TASK_RUNNING;<BR>&nbsp;mutex_lock(&amp;module_mutex);<BR>}</P>
<P>SYSCALL_DEFINE2(delete_module, const char __user *, name_user,<BR>&nbsp;&nbsp;unsigned int, flags)<BR>{<BR>&nbsp;struct module *mod;<BR>&nbsp;char name[MODULE_NAME_LEN];<BR>&nbsp;int ret, forced = 0;</P>
<P>&nbsp;if (!capable(CAP_SYS_MODULE) || modules_disabled)<BR>&nbsp;&nbsp;return -EPERM;</P>
<P>&nbsp;if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) &lt; 0)<BR>&nbsp;&nbsp;return -EFAULT;<BR>&nbsp;name[MODULE_NAME_LEN-1] = '\0';</P>
<P>&nbsp;if (mutex_lock_interruptible(&amp;module_mutex) != 0)<BR>&nbsp;&nbsp;return -EINTR;</P>
<P>&nbsp;mod = find_module(name);<BR>&nbsp;if (!mod) {<BR>&nbsp;&nbsp;ret = -ENOENT;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}</P>
<P>&nbsp;if (!list_empty(&amp;mod-&gt;source_list)) {<BR>&nbsp;&nbsp;/* Other modules depend on us: get rid of them first. */<BR>&nbsp;&nbsp;ret = -EWOULDBLOCK;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}</P>
<P>&nbsp;/* Doing init or already dying? */<BR>&nbsp;if (mod-&gt;state != MODULE_STATE_LIVE) {<BR>&nbsp;&nbsp;/* FIXME: if (force), slam module count and wake up<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; waiter --RR */<BR>&nbsp;&nbsp;pr_debug("%s already dying\n", mod-&gt;name);<BR>&nbsp;&nbsp;ret = -EBUSY;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}</P>
<P>&nbsp;/* If it has an init func, it must have an exit func to unload */<BR>&nbsp;if (mod-&gt;init &amp;&amp; !mod-&gt;exit) {<BR>&nbsp;&nbsp;forced = try_force_unload(flags);<BR>&nbsp;&nbsp;if (!forced) {<BR>&nbsp;&nbsp;&nbsp;/* This module can't be removed */<BR>&nbsp;&nbsp;&nbsp;ret = -EBUSY;<BR>&nbsp;&nbsp;&nbsp;goto out;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;/* Set this up before setting mod-&gt;state */<BR>&nbsp;mod-&gt;waiter = current;</P>
<P>&nbsp;/* Stop the machine so refcounts can't move and disable module. */<BR>&nbsp;ret = try_stop_module(mod, flags, &amp;forced);<BR>&nbsp;if (ret != 0)<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;/* Never wait if forced. */<BR>&nbsp;if (!forced &amp;&amp; module_refcount(mod) != 0)<BR>&nbsp;&nbsp;wait_for_zero_refcount(mod);</P>
<P>&nbsp;mutex_unlock(&amp;module_mutex);<BR>&nbsp;/* Final destruction now no one is using it. */<BR>&nbsp;if (mod-&gt;exit != NULL)<BR>&nbsp;&nbsp;mod-&gt;exit();<BR>&nbsp;blocking_notifier_call_chain(&amp;module_notify_list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MODULE_STATE_GOING, mod);<BR>&nbsp;async_synchronize_full();</P>
<P>&nbsp;/* Store the name of the last unloaded module for diagnostic purposes */<BR>&nbsp;strlcpy(last_unloaded_module, mod-&gt;name, sizeof(last_unloaded_module));</P>
<P>&nbsp;free_module(mod);<BR>&nbsp;return 0;<BR>out:<BR>&nbsp;mutex_unlock(&amp;module_mutex);<BR>&nbsp;return ret;<BR>}</P>
<P>static inline void print_unload_info(struct seq_file *m, struct module *mod)<BR>{<BR>&nbsp;struct module_use *use;<BR>&nbsp;int printed_something = 0;</P>
<P>&nbsp;seq_printf(m, " %lu ", module_refcount(mod));</P>
<P>&nbsp;/* Always include a trailing , so userspace can differentiate<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; between this and the old multi-field proc format. */<BR>&nbsp;list_for_each_entry(use, &amp;mod-&gt;source_list, source_list) {<BR>&nbsp;&nbsp;printed_something = 1;<BR>&nbsp;&nbsp;seq_printf(m, "%s,", use-&gt;source-&gt;name);<BR>&nbsp;}</P>
<P>&nbsp;if (mod-&gt;init != NULL &amp;&amp; mod-&gt;exit == NULL) {<BR>&nbsp;&nbsp;printed_something = 1;<BR>&nbsp;&nbsp;seq_printf(m, "[permanent],");<BR>&nbsp;}</P>
<P>&nbsp;if (!printed_something)<BR>&nbsp;&nbsp;seq_printf(m, "-");<BR>}</P>
<P>void __symbol_put(const char *symbol)<BR>{<BR>&nbsp;struct module *owner;</P>
<P>&nbsp;preempt_disable();<BR>&nbsp;if (!find_symbol(symbol, &amp;owner, NULL, true, false))<BR>&nbsp;&nbsp;BUG();<BR>&nbsp;module_put(owner);<BR>&nbsp;preempt_enable();<BR>}<BR>EXPORT_SYMBOL(__symbol_put);</P>
<P>/* Note this assumes addr is a function, which it currently always is. */<BR>void symbol_put_addr(void *addr)<BR>{<BR>&nbsp;struct module *modaddr;<BR>&nbsp;unsigned long a = (unsigned long)dereference_function_descriptor(addr);</P>
<P>&nbsp;if (core_kernel_text(a))<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/* module_text_address is safe here: we're supposed to have reference<BR>&nbsp; * to module from symbol_get, so it can't go away. */<BR>&nbsp;modaddr = __module_text_address(a);<BR>&nbsp;BUG_ON(!modaddr);<BR>&nbsp;module_put(modaddr);<BR>}<BR>EXPORT_SYMBOL_GPL(symbol_put_addr);</P>
<P>static ssize_t show_refcnt(struct module_attribute *mattr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module_kobject *mk, char *buffer)<BR>{<BR>&nbsp;return sprintf(buffer, "%lu\n", module_refcount(mk-&gt;mod));<BR>}</P>
<P>static struct module_attribute modinfo_refcnt =<BR>&nbsp;__ATTR(refcnt, 0444, show_refcnt, NULL);</P>
<P>void __module_get(struct module *module)<BR>{<BR>&nbsp;if (module) {<BR>&nbsp;&nbsp;preempt_disable();<BR>&nbsp;&nbsp;__this_cpu_inc(module-&gt;refptr-&gt;incs);<BR>&nbsp;&nbsp;trace_module_get(module, _RET_IP_);<BR>&nbsp;&nbsp;preempt_enable();<BR>&nbsp;}<BR>}<BR>EXPORT_SYMBOL(__module_get);</P>
<P>bool try_module_get(struct module *module)<BR>{<BR>&nbsp;bool ret = true;</P>
<P>&nbsp;if (module) {<BR>&nbsp;&nbsp;preempt_disable();</P>
<P>&nbsp;&nbsp;if (likely(module_is_live(module))) {<BR>&nbsp;&nbsp;&nbsp;__this_cpu_inc(module-&gt;refptr-&gt;incs);<BR>&nbsp;&nbsp;&nbsp;trace_module_get(module, _RET_IP_);<BR>&nbsp;&nbsp;} else<BR>&nbsp;&nbsp;&nbsp;ret = false;</P>
<P>&nbsp;&nbsp;preempt_enable();<BR>&nbsp;}<BR>&nbsp;return ret;<BR>}<BR>EXPORT_SYMBOL(try_module_get);</P>
<P>void module_put(struct module *module)<BR>{<BR>&nbsp;if (module) {<BR>&nbsp;&nbsp;preempt_disable();<BR>&nbsp;&nbsp;smp_wmb(); /* see comment in module_refcount */<BR>&nbsp;&nbsp;__this_cpu_inc(module-&gt;refptr-&gt;decs);</P>
<P>&nbsp;&nbsp;trace_module_put(module, _RET_IP_);<BR>&nbsp;&nbsp;/* Maybe they're waiting for us to drop reference? */<BR>&nbsp;&nbsp;if (unlikely(!module_is_live(module)))<BR>&nbsp;&nbsp;&nbsp;wake_up_process(module-&gt;waiter);<BR>&nbsp;&nbsp;preempt_enable();<BR>&nbsp;}<BR>}<BR>EXPORT_SYMBOL(module_put);</P>
<P>#else /* !CONFIG_MODULE_UNLOAD */<BR>static inline void print_unload_info(struct seq_file *m, struct module *mod)<BR>{<BR>&nbsp;/* We don't know the usage count, or what modules are using. */<BR>&nbsp;seq_printf(m, " - -");<BR>}</P>
<P>static inline void module_unload_free(struct module *mod)<BR>{<BR>}</P>
<P>int ref_module(struct module *a, struct module *b)<BR>{<BR>&nbsp;return strong_try_module_get(b);<BR>}<BR>EXPORT_SYMBOL_GPL(ref_module);</P>
<P>static inline int module_unload_init(struct module *mod)<BR>{<BR>&nbsp;return 0;<BR>}<BR>#endif /* CONFIG_MODULE_UNLOAD */</P>
<P>static size_t module_flags_taint(struct module *mod, char *buf)<BR>{<BR>&nbsp;size_t l = 0;</P>
<P>&nbsp;if (mod-&gt;taints &amp; (1 &lt;&lt; TAINT_PROPRIETARY_MODULE))<BR>&nbsp;&nbsp;buf[l++] = 'P';<BR>&nbsp;if (mod-&gt;taints &amp; (1 &lt;&lt; TAINT_OOT_MODULE))<BR>&nbsp;&nbsp;buf[l++] = 'O';<BR>&nbsp;if (mod-&gt;taints &amp; (1 &lt;&lt; TAINT_FORCED_MODULE))<BR>&nbsp;&nbsp;buf[l++] = 'F';<BR>&nbsp;if (mod-&gt;taints &amp; (1 &lt;&lt; TAINT_CRAP))<BR>&nbsp;&nbsp;buf[l++] = 'C';<BR>&nbsp;/*<BR>&nbsp; * TAINT_FORCED_RMMOD: could be added.<BR>&nbsp; * TAINT_UNSAFE_SMP, TAINT_MACHINE_CHECK, TAINT_BAD_PAGE don't<BR>&nbsp; * apply to modules.<BR>&nbsp; */<BR>&nbsp;return l;<BR>}</P>
<P>static ssize_t show_initstate(struct module_attribute *mattr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module_kobject *mk, char *buffer)<BR>{<BR>&nbsp;const char *state = "unknown";</P>
<P>&nbsp;switch (mk-&gt;mod-&gt;state) {<BR>&nbsp;case MODULE_STATE_LIVE:<BR>&nbsp;&nbsp;state = "live";<BR>&nbsp;&nbsp;break;<BR>&nbsp;case MODULE_STATE_COMING:<BR>&nbsp;&nbsp;state = "coming";<BR>&nbsp;&nbsp;break;<BR>&nbsp;case MODULE_STATE_GOING:<BR>&nbsp;&nbsp;state = "going";<BR>&nbsp;&nbsp;break;<BR>&nbsp;default:<BR>&nbsp;&nbsp;BUG();<BR>&nbsp;}<BR>&nbsp;return sprintf(buffer, "%s\n", state);<BR>}</P>
<P>static struct module_attribute modinfo_initstate =<BR>&nbsp;__ATTR(initstate, 0444, show_initstate, NULL);</P>
<P>static ssize_t store_uevent(struct module_attribute *mattr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module_kobject *mk,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *buffer, size_t count)<BR>{<BR>&nbsp;enum kobject_action action;</P>
<P>&nbsp;if (kobject_action_type(buffer, count, &amp;action) == 0)<BR>&nbsp;&nbsp;kobject_uevent(&amp;mk-&gt;kobj, action);<BR>&nbsp;return count;<BR>}</P>
<P>struct module_attribute module_uevent =<BR>&nbsp;__ATTR(uevent, 0200, NULL, store_uevent);</P>
<P>static ssize_t show_coresize(struct module_attribute *mattr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module_kobject *mk, char *buffer)<BR>{<BR>&nbsp;return sprintf(buffer, "%u\n", mk-&gt;mod-&gt;core_size);<BR>}</P>
<P>static struct module_attribute modinfo_coresize =<BR>&nbsp;__ATTR(coresize, 0444, show_coresize, NULL);</P>
<P>static ssize_t show_initsize(struct module_attribute *mattr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module_kobject *mk, char *buffer)<BR>{<BR>&nbsp;return sprintf(buffer, "%u\n", mk-&gt;mod-&gt;init_size);<BR>}</P>
<P>static struct module_attribute modinfo_initsize =<BR>&nbsp;__ATTR(initsize, 0444, show_initsize, NULL);</P>
<P>static ssize_t show_taint(struct module_attribute *mattr,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct module_kobject *mk, char *buffer)<BR>{<BR>&nbsp;size_t l;</P>
<P>&nbsp;l = module_flags_taint(mk-&gt;mod, buffer);<BR>&nbsp;buffer[l++] = '\n';<BR>&nbsp;return l;<BR>}</P>
<P>static struct module_attribute modinfo_taint =<BR>&nbsp;__ATTR(taint, 0444, show_taint, NULL);</P>
<P>static struct module_attribute *modinfo_attrs[] = {<BR>&nbsp;&amp;module_uevent,<BR>&nbsp;&amp;modinfo_version,<BR>&nbsp;&amp;modinfo_srcversion,<BR>&nbsp;&amp;modinfo_initstate,<BR>&nbsp;&amp;modinfo_coresize,<BR>&nbsp;&amp;modinfo_initsize,<BR>&nbsp;&amp;modinfo_taint,<BR>#ifdef CONFIG_MODULE_UNLOAD<BR>&nbsp;&amp;modinfo_refcnt,<BR>#endif<BR>&nbsp;NULL,<BR>};</P>
<P>static const char vermagic[] = VERMAGIC_STRING;</P>
<P>static int try_to_force_load(struct module *mod, const char *reason)<BR>{<BR>#ifdef CONFIG_MODULE_FORCE_LOAD<BR>&nbsp;if (!test_taint(TAINT_FORCED_MODULE))<BR>&nbsp;&nbsp;printk(KERN_WARNING "%s: %s: kernel tainted.\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name, reason);<BR>&nbsp;add_taint_module(mod, TAINT_FORCED_MODULE, LOCKDEP_NOW_UNRELIABLE);<BR>&nbsp;return 0;<BR>#else<BR>&nbsp;return -ENOEXEC;<BR>#endif<BR>}</P>
<P>#ifdef CONFIG_MODVERSIONS<BR>/* If the arch applies (non-zero) relocations to kernel kcrctab, unapply it. */<BR>static unsigned long maybe_relocated(unsigned long crc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct module *crc_owner)<BR>{<BR>#ifdef ARCH_RELOCATES_KCRCTAB<BR>&nbsp;if (crc_owner == NULL)<BR>&nbsp;&nbsp;return crc - (unsigned long)reloc_start;<BR>#endif<BR>&nbsp;return crc;<BR>}</P>
<P>static int check_version(Elf_Shdr *sechdrs,<BR>&nbsp;&nbsp;&nbsp; unsigned int versindex,<BR>&nbsp;&nbsp;&nbsp; const char *symname,<BR>&nbsp;&nbsp;&nbsp; struct module *mod, <BR>&nbsp;&nbsp;&nbsp; const unsigned long *crc,<BR>&nbsp;&nbsp;&nbsp; const struct module *crc_owner)<BR>{<BR>&nbsp;unsigned int i, num_versions;<BR>&nbsp;struct modversion_info *versions;</P>
<P>&nbsp;/* Exporting module didn't supply crcs?&nbsp; OK, we're already tainted. */<BR>&nbsp;if (!crc)<BR>&nbsp;&nbsp;return 1;</P>
<P>&nbsp;/* No versions at all?&nbsp; modprobe --force does this. */<BR>&nbsp;if (versindex == 0)<BR>&nbsp;&nbsp;return try_to_force_load(mod, symname) == 0;</P>
<P>&nbsp;versions = (void *) sechdrs[versindex].sh_addr;<BR>&nbsp;num_versions = sechdrs[versindex].sh_size<BR>&nbsp;&nbsp;/ sizeof(struct modversion_info);</P>
<P>&nbsp;for (i = 0; i &lt; num_versions; i++) {<BR>&nbsp;&nbsp;if (strcmp(versions[i].name, symname) != 0)<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;if (versions[i].crc == maybe_relocated(*crc, crc_owner))<BR>&nbsp;&nbsp;&nbsp;return 1;<BR>&nbsp;&nbsp;pr_debug("Found checksum %lX vs module %lX\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maybe_relocated(*crc, crc_owner), versions[i].crc);<BR>&nbsp;&nbsp;goto bad_version;<BR>&nbsp;}</P>
<P>&nbsp;printk(KERN_WARNING "%s: no symbol version for %s\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name, symname);<BR>&nbsp;return 0;</P>
<P>bad_version:<BR>&nbsp;printk("%s: disagrees about version of symbol %s\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name, symname);<BR>&nbsp;return 0;<BR>}</P>
<P>static inline int check_modstruct_version(Elf_Shdr *sechdrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int versindex,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module *mod)<BR>{<BR>&nbsp;const unsigned long *crc;</P>
<P>&nbsp;/* Since this should be found in kernel (which can't be removed),<BR>&nbsp; * no locking is necessary. */<BR>&nbsp;if (!find_symbol(VMLINUX_SYMBOL_STR(module_layout), NULL,<BR>&nbsp;&nbsp;&nbsp; &amp;crc, true, false))<BR>&nbsp;&nbsp;BUG();<BR>&nbsp;return check_version(sechdrs, versindex,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VMLINUX_SYMBOL_STR(module_layout), mod, crc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);<BR>}</P>
<P>/* First part is kernel version, which we ignore if module has crcs. */<BR>static inline int same_magic(const char *amagic, const char *bmagic,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool has_crcs)<BR>{<BR>&nbsp;if (has_crcs) {<BR>&nbsp;&nbsp;amagic += strcspn(amagic, " ");<BR>&nbsp;&nbsp;bmagic += strcspn(bmagic, " ");<BR>&nbsp;}<BR>&nbsp;return strcmp(amagic, bmagic) == 0;<BR>}<BR>#else<BR>static inline int check_version(Elf_Shdr *sechdrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned int versindex,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const char *symname,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct module *mod, <BR>&nbsp;&nbsp;&nbsp;&nbsp;const unsigned long *crc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;const struct module *crc_owner)<BR>{<BR>&nbsp;return 1;<BR>}</P>
<P>static inline int check_modstruct_version(Elf_Shdr *sechdrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int versindex,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module *mod)<BR>{<BR>&nbsp;return 1;<BR>}</P>
<P>static inline int same_magic(const char *amagic, const char *bmagic,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool has_crcs)<BR>{<BR>&nbsp;return strcmp(amagic, bmagic) == 0;<BR>}<BR>#endif /* CONFIG_MODVERSIONS */</P>
<P>/* Resolve a symbol for this module.&nbsp; I.e. if we find one, record usage. */<BR>static const struct kernel_symbol *resolve_symbol(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct load_info *info,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char ownername[])<BR>{<BR>&nbsp;struct module *owner;<BR>&nbsp;const struct kernel_symbol *sym;<BR>&nbsp;const unsigned long *crc;<BR>&nbsp;int err;</P>
<P>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;sym = find_symbol(name, &amp;owner, &amp;crc,<BR>&nbsp;&nbsp;&nbsp;&nbsp; !(mod-&gt;taints &amp; (1 &lt;&lt; TAINT_PROPRIETARY_MODULE)), true);<BR>&nbsp;if (!sym)<BR>&nbsp;&nbsp;goto unlock;</P>
<P>&nbsp;if (!check_version(info-&gt;sechdrs, info-&gt;index.vers, name, mod, crc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; owner)) {<BR>&nbsp;&nbsp;sym = ERR_PTR(-EINVAL);<BR>&nbsp;&nbsp;goto getname;<BR>&nbsp;}</P>
<P>&nbsp;err = ref_module(mod, owner);<BR>&nbsp;if (err) {<BR>&nbsp;&nbsp;sym = ERR_PTR(err);<BR>&nbsp;&nbsp;goto getname;<BR>&nbsp;}</P>
<P>getname:<BR>&nbsp;/* We must make copy under the lock if we failed to get ref. */<BR>&nbsp;strncpy(ownername, module_name(owner), MODULE_NAME_LEN);<BR>unlock:<BR>&nbsp;mutex_unlock(&amp;module_mutex);<BR>&nbsp;return sym;<BR>}</P>
<P>static const struct kernel_symbol *<BR>resolve_symbol_wait(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct load_info *info,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name)<BR>{<BR>&nbsp;const struct kernel_symbol *ksym;<BR>&nbsp;char owner[MODULE_NAME_LEN];</P>
<P>&nbsp;if (wait_event_interruptible_timeout(module_wq,<BR>&nbsp;&nbsp;&nbsp;!IS_ERR(ksym = resolve_symbol(mod, info, name, owner))<BR>&nbsp;&nbsp;&nbsp;|| PTR_ERR(ksym) != -EBUSY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30 * HZ) &lt;= 0) {<BR>&nbsp;&nbsp;printk(KERN_WARNING "%s: gave up waiting for init of module %s.\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name, owner);<BR>&nbsp;}<BR>&nbsp;return ksym;<BR>}</P>
<P>/*<BR>&nbsp;* /sys/module/foo/sections stuff<BR>&nbsp;* J. Corbet &lt;<A href="mailto:corbet@lwn.net">corbet@lwn.net</A>&gt;<BR>&nbsp;*/<BR>#ifdef CONFIG_SYSFS</P>
<P>#ifdef CONFIG_KALLSYMS<BR>static inline bool sect_empty(const Elf_Shdr *sect)<BR>{<BR>&nbsp;return !(sect-&gt;sh_flags &amp; SHF_ALLOC) || sect-&gt;sh_size == 0;<BR>}</P>
<P>struct module_sect_attr<BR>{<BR>&nbsp;struct module_attribute mattr;<BR>&nbsp;char *name;<BR>&nbsp;unsigned long address;<BR>};</P>
<P>struct module_sect_attrs<BR>{<BR>&nbsp;struct attribute_group grp;<BR>&nbsp;unsigned int nsections;<BR>&nbsp;struct module_sect_attr attrs[0];<BR>};</P>
<P>static ssize_t module_sect_show(struct module_attribute *mattr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct module_kobject *mk, char *buf)<BR>{<BR>&nbsp;struct module_sect_attr *sattr =<BR>&nbsp;&nbsp;container_of(mattr, struct module_sect_attr, mattr);<BR>&nbsp;return sprintf(buf, "0x%pK\n", (void *)sattr-&gt;address);<BR>}</P>
<P>static void free_sect_attrs(struct module_sect_attrs *sect_attrs)<BR>{<BR>&nbsp;unsigned int section;</P>
<P>&nbsp;for (section = 0; section &lt; sect_attrs-&gt;nsections; section++)<BR>&nbsp;&nbsp;kfree(sect_attrs-&gt;attrs[section].name);<BR>&nbsp;kfree(sect_attrs);<BR>}</P>
<P>static void add_sect_attrs(struct module *mod, const struct load_info *info)<BR>{<BR>&nbsp;unsigned int nloaded = 0, i, size[2];<BR>&nbsp;struct module_sect_attrs *sect_attrs;<BR>&nbsp;struct module_sect_attr *sattr;<BR>&nbsp;struct attribute **gattr;</P>
<P>&nbsp;/* Count loaded sections and allocate structures */<BR>&nbsp;for (i = 0; i &lt; info-&gt;hdr-&gt;e_shnum; i++)<BR>&nbsp;&nbsp;if (!sect_empty(&amp;info-&gt;sechdrs[i]))<BR>&nbsp;&nbsp;&nbsp;nloaded++;<BR>&nbsp;size[0] = ALIGN(sizeof(*sect_attrs)<BR>&nbsp;&nbsp;&nbsp;+ nloaded * sizeof(sect_attrs-&gt;attrs[0]),<BR>&nbsp;&nbsp;&nbsp;sizeof(sect_attrs-&gt;grp.attrs[0]));<BR>&nbsp;size[1] = (nloaded + 1) * sizeof(sect_attrs-&gt;grp.attrs[0]);<BR>&nbsp;sect_attrs = kzalloc(size[0] + size[1], GFP_KERNEL);<BR>&nbsp;if (sect_attrs == NULL)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/* Setup section attributes. */<BR>&nbsp;sect_attrs-&gt;grp.name = "sections";<BR>&nbsp;sect_attrs-&gt;grp.attrs = (void *)sect_attrs + size[0];</P>
<P>&nbsp;sect_attrs-&gt;nsections = 0;<BR>&nbsp;sattr = &amp;sect_attrs-&gt;attrs[0];<BR>&nbsp;gattr = &amp;sect_attrs-&gt;grp.attrs[0];<BR>&nbsp;for (i = 0; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<BR>&nbsp;&nbsp;Elf_Shdr *sec = &amp;info-&gt;sechdrs[i];<BR>&nbsp;&nbsp;if (sect_empty(sec))<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;sattr-&gt;address = sec-&gt;sh_addr;<BR>&nbsp;&nbsp;sattr-&gt;name = kstrdup(info-&gt;secstrings + sec-&gt;sh_name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFP_KERNEL);<BR>&nbsp;&nbsp;if (sattr-&gt;name == NULL)<BR>&nbsp;&nbsp;&nbsp;goto out;<BR>&nbsp;&nbsp;sect_attrs-&gt;nsections++;<BR>&nbsp;&nbsp;sysfs_attr_init(&amp;sattr-&gt;mattr.attr);<BR>&nbsp;&nbsp;sattr-&gt;mattr.show = module_sect_show;<BR>&nbsp;&nbsp;sattr-&gt;mattr.store = NULL;<BR>&nbsp;&nbsp;sattr-&gt;mattr.attr.name = sattr-&gt;name;<BR>&nbsp;&nbsp;sattr-&gt;mattr.attr.mode = S_IRUGO;<BR>&nbsp;&nbsp;*(gattr++) = &amp;(sattr++)-&gt;mattr.attr;<BR>&nbsp;}<BR>&nbsp;*gattr = NULL;</P>
<P>&nbsp;if (sysfs_create_group(&amp;mod-&gt;mkobj.kobj, &amp;sect_attrs-&gt;grp))<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;mod-&gt;sect_attrs = sect_attrs;<BR>&nbsp;return;<BR>&nbsp; out:<BR>&nbsp;free_sect_attrs(sect_attrs);<BR>}</P>
<P>static void remove_sect_attrs(struct module *mod)<BR>{<BR>&nbsp;if (mod-&gt;sect_attrs) {<BR>&nbsp;&nbsp;sysfs_remove_group(&amp;mod-&gt;mkobj.kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;mod-&gt;sect_attrs-&gt;grp);<BR>&nbsp;&nbsp;/* We are positive that no one is using any sect attrs<BR>&nbsp;&nbsp; * at this point.&nbsp; Deallocate immediately. */<BR>&nbsp;&nbsp;free_sect_attrs(mod-&gt;sect_attrs);<BR>&nbsp;&nbsp;mod-&gt;sect_attrs = NULL;<BR>&nbsp;}<BR>}</P>
<P>/*<BR>&nbsp;* /sys/module/foo/notes/.section.name gives contents of SHT_NOTE sections.<BR>&nbsp;*/</P>
<P>struct module_notes_attrs {<BR>&nbsp;struct kobject *dir;<BR>&nbsp;unsigned int notes;<BR>&nbsp;struct bin_attribute attrs[0];<BR>};</P>
<P>static ssize_t module_notes_read(struct file *filp, struct kobject *kobj,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct bin_attribute *bin_attr,<BR>&nbsp;&nbsp;&nbsp;&nbsp; char *buf, loff_t pos, size_t count)<BR>{<BR>&nbsp;/*<BR>&nbsp; * The caller checked the pos and count against our size.<BR>&nbsp; */<BR>&nbsp;memcpy(buf, bin_attr-&gt;private + pos, count);<BR>&nbsp;return count;<BR>}</P>
<P>static void free_notes_attrs(struct module_notes_attrs *notes_attrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int i)<BR>{<BR>&nbsp;if (notes_attrs-&gt;dir) {<BR>&nbsp;&nbsp;while (i-- &gt; 0)<BR>&nbsp;&nbsp;&nbsp;sysfs_remove_bin_file(notes_attrs-&gt;dir,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;notes_attrs-&gt;attrs[i]);<BR>&nbsp;&nbsp;kobject_put(notes_attrs-&gt;dir);<BR>&nbsp;}<BR>&nbsp;kfree(notes_attrs);<BR>}</P>
<P>static void add_notes_attrs(struct module *mod, const struct load_info *info)<BR>{<BR>&nbsp;unsigned int notes, loaded, i;<BR>&nbsp;struct module_notes_attrs *notes_attrs;<BR>&nbsp;struct bin_attribute *nattr;</P>
<P>&nbsp;/* failed to create section attributes, so can't create notes */<BR>&nbsp;if (!mod-&gt;sect_attrs)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;/* Count notes sections and allocate structures.&nbsp; */<BR>&nbsp;notes = 0;<BR>&nbsp;for (i = 0; i &lt; info-&gt;hdr-&gt;e_shnum; i++)<BR>&nbsp;&nbsp;if (!sect_empty(&amp;info-&gt;sechdrs[i]) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (info-&gt;sechdrs[i].sh_type == SHT_NOTE))<BR>&nbsp;&nbsp;&nbsp;++notes;</P>
<P>&nbsp;if (notes == 0)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;notes_attrs = kzalloc(sizeof(*notes_attrs)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + notes * sizeof(notes_attrs-&gt;attrs[0]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GFP_KERNEL);<BR>&nbsp;if (notes_attrs == NULL)<BR>&nbsp;&nbsp;return;</P>
<P>&nbsp;notes_attrs-&gt;notes = notes;<BR>&nbsp;nattr = &amp;notes_attrs-&gt;attrs[0];<BR>&nbsp;for (loaded = i = 0; i &lt; info-&gt;hdr-&gt;e_shnum; ++i) {<BR>&nbsp;&nbsp;if (sect_empty(&amp;info-&gt;sechdrs[i]))<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;if (info-&gt;sechdrs[i].sh_type == SHT_NOTE) {<BR>&nbsp;&nbsp;&nbsp;sysfs_bin_attr_init(nattr);<BR>&nbsp;&nbsp;&nbsp;nattr-&gt;attr.name = mod-&gt;sect_attrs-&gt;attrs[loaded].name;<BR>&nbsp;&nbsp;&nbsp;nattr-&gt;attr.mode = S_IRUGO;<BR>&nbsp;&nbsp;&nbsp;nattr-&gt;size = info-&gt;sechdrs[i].sh_size;<BR>&nbsp;&nbsp;&nbsp;nattr-&gt;private = (void *) info-&gt;sechdrs[i].sh_addr;<BR>&nbsp;&nbsp;&nbsp;nattr-&gt;read = module_notes_read;<BR>&nbsp;&nbsp;&nbsp;++nattr;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;++loaded;<BR>&nbsp;}</P>
<P>&nbsp;notes_attrs-&gt;dir = kobject_create_and_add("notes", &amp;mod-&gt;mkobj.kobj);<BR>&nbsp;if (!notes_attrs-&gt;dir)<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;for (i = 0; i &lt; notes; ++i)<BR>&nbsp;&nbsp;if (sysfs_create_bin_file(notes_attrs-&gt;dir,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;notes_attrs-&gt;attrs[i]))<BR>&nbsp;&nbsp;&nbsp;goto out;</P>
<P>&nbsp;mod-&gt;notes_attrs = notes_attrs;<BR>&nbsp;return;</P>
<P>&nbsp; out:<BR>&nbsp;free_notes_attrs(notes_attrs, i);<BR>}</P>
<P>static void remove_notes_attrs(struct module *mod)<BR>{<BR>&nbsp;if (mod-&gt;notes_attrs)<BR>&nbsp;&nbsp;free_notes_attrs(mod-&gt;notes_attrs, mod-&gt;notes_attrs-&gt;notes);<BR>}</P>
<P>#else</P>
<P>static inline void add_sect_attrs(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct load_info *info)<BR>{<BR>}</P>
<P>static inline void remove_sect_attrs(struct module *mod)<BR>{<BR>}</P>
<P>static inline void add_notes_attrs(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct load_info *info)<BR>{<BR>}</P>
<P>static inline void remove_notes_attrs(struct module *mod)<BR>{<BR>}<BR>#endif /* CONFIG_KALLSYMS */</P>
<P>static void add_usage_links(struct module *mod)<BR>{<BR>#ifdef CONFIG_MODULE_UNLOAD<BR>&nbsp;struct module_use *use;<BR>&nbsp;int nowarn;</P>
<P>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;list_for_each_entry(use, &amp;mod-&gt;target_list, target_list) {<BR>&nbsp;&nbsp;nowarn = sysfs_create_link(use-&gt;target-&gt;holders_dir,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;mod-&gt;mkobj.kobj, mod-&gt;name);<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;module_mutex);<BR>#endif<BR>}</P>
<P>static void del_usage_links(struct module *mod)<BR>{<BR>#ifdef CONFIG_MODULE_UNLOAD<BR>&nbsp;struct module_use *use;</P>
<P>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;list_for_each_entry(use, &amp;mod-&gt;target_list, target_list)<BR>&nbsp;&nbsp;sysfs_remove_link(use-&gt;target-&gt;holders_dir, mod-&gt;name);<BR>&nbsp;mutex_unlock(&amp;module_mutex);<BR>#endif<BR>}</P>
<P>static int module_add_modinfo_attrs(struct module *mod)<BR>{<BR>&nbsp;struct module_attribute *attr;<BR>&nbsp;struct module_attribute *temp_attr;<BR>&nbsp;int error = 0;<BR>&nbsp;int i;</P>
<P>&nbsp;mod-&gt;modinfo_attrs = kzalloc((sizeof(struct module_attribute) *<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ARRAY_SIZE(modinfo_attrs) + 1)),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFP_KERNEL);<BR>&nbsp;if (!mod-&gt;modinfo_attrs)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;temp_attr = mod-&gt;modinfo_attrs;<BR>&nbsp;for (i = 0; (attr = modinfo_attrs[i]) &amp;&amp; !error; i++) {<BR>&nbsp;&nbsp;if (!attr-&gt;test ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (attr-&gt;test &amp;&amp; attr-&gt;test(mod))) {<BR>&nbsp;&nbsp;&nbsp;memcpy(temp_attr, attr, sizeof(*temp_attr));<BR>&nbsp;&nbsp;&nbsp;sysfs_attr_init(&amp;temp_attr-&gt;attr);<BR>&nbsp;&nbsp;&nbsp;error = sysfs_create_file(&amp;mod-&gt;mkobj.kobj,&amp;temp_attr-&gt;attr);<BR>&nbsp;&nbsp;&nbsp;++temp_attr;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;return error;<BR>}</P>
<P>static void module_remove_modinfo_attrs(struct module *mod)<BR>{<BR>&nbsp;struct module_attribute *attr;<BR>&nbsp;int i;</P>
<P>&nbsp;for (i = 0; (attr = &amp;mod-&gt;modinfo_attrs[i]); i++) {<BR>&nbsp;&nbsp;/* pick a field to test for end of list */<BR>&nbsp;&nbsp;if (!attr-&gt;attr.name)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;sysfs_remove_file(&amp;mod-&gt;mkobj.kobj,&amp;attr-&gt;attr);<BR>&nbsp;&nbsp;if (attr-&gt;free)<BR>&nbsp;&nbsp;&nbsp;attr-&gt;free(mod);<BR>&nbsp;}<BR>&nbsp;kfree(mod-&gt;modinfo_attrs);<BR>}</P>
<P>static int mod_sysfs_init(struct module *mod)<BR>{<BR>&nbsp;int err;<BR>&nbsp;struct kobject *kobj;</P>
<P>&nbsp;if (!module_sysfs_initialized) {<BR>&nbsp;&nbsp;printk(KERN_ERR "%s: module sysfs not initialized\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name);<BR>&nbsp;&nbsp;err = -EINVAL;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}</P>
<P>&nbsp;kobj = kset_find_obj(module_kset, mod-&gt;name);<BR>&nbsp;if (kobj) {<BR>&nbsp;&nbsp;printk(KERN_ERR "%s: module is already loaded\n", mod-&gt;name);<BR>&nbsp;&nbsp;kobject_put(kobj);<BR>&nbsp;&nbsp;err = -EINVAL;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}</P>
<P>&nbsp;mod-&gt;mkobj.mod = mod;</P>
<P>&nbsp;memset(&amp;mod-&gt;mkobj.kobj, 0, sizeof(mod-&gt;mkobj.kobj));<BR>&nbsp;mod-&gt;mkobj.kobj.kset = module_kset;<BR>&nbsp;err = kobject_init_and_add(&amp;mod-&gt;mkobj.kobj, &amp;module_ktype, NULL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%s", mod-&gt;name);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;kobject_put(&amp;mod-&gt;mkobj.kobj);</P>
<P>&nbsp;/* delay uevent until full sysfs population */<BR>out:<BR>&nbsp;return err;<BR>}</P>
<P>static int mod_sysfs_setup(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct load_info *info,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct kernel_param *kparam,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int num_params)<BR>{<BR>&nbsp;int err;</P>
<P>&nbsp;err = mod_sysfs_init(mod);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;mod-&gt;holders_dir = kobject_create_and_add("holders", &amp;mod-&gt;mkobj.kobj);<BR>&nbsp;if (!mod-&gt;holders_dir) {<BR>&nbsp;&nbsp;err = -ENOMEM;<BR>&nbsp;&nbsp;goto out_unreg;<BR>&nbsp;}</P>
<P>&nbsp;err = module_param_sysfs_setup(mod, kparam, num_params);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;goto out_unreg_holders;</P>
<P>&nbsp;err = module_add_modinfo_attrs(mod);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;goto out_unreg_param;</P>
<P>&nbsp;add_usage_links(mod);<BR>&nbsp;add_sect_attrs(mod, info);<BR>&nbsp;add_notes_attrs(mod, info);</P>
<P>&nbsp;kobject_uevent(&amp;mod-&gt;mkobj.kobj, KOBJ_ADD);<BR>&nbsp;return 0;</P>
<P>out_unreg_param:<BR>&nbsp;module_param_sysfs_remove(mod);<BR>out_unreg_holders:<BR>&nbsp;kobject_put(mod-&gt;holders_dir);<BR>out_unreg:<BR>&nbsp;kobject_put(&amp;mod-&gt;mkobj.kobj);<BR>out:<BR>&nbsp;return err;<BR>}</P>
<P>static void mod_sysfs_fini(struct module *mod)<BR>{<BR>&nbsp;remove_notes_attrs(mod);<BR>&nbsp;remove_sect_attrs(mod);<BR>&nbsp;kobject_put(&amp;mod-&gt;mkobj.kobj);<BR>}</P>
<P>#else /* !CONFIG_SYSFS */</P>
<P>static int mod_sysfs_setup(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct load_info *info,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct kernel_param *kparam,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int num_params)<BR>{<BR>&nbsp;return 0;<BR>}</P>
<P>static void mod_sysfs_fini(struct module *mod)<BR>{<BR>}</P>
<P>static void module_remove_modinfo_attrs(struct module *mod)<BR>{<BR>}</P>
<P>static void del_usage_links(struct module *mod)<BR>{<BR>}</P>
<P>#endif /* CONFIG_SYSFS */</P>
<P>static void mod_sysfs_teardown(struct module *mod)<BR>{<BR>&nbsp;del_usage_links(mod);<BR>&nbsp;module_remove_modinfo_attrs(mod);<BR>&nbsp;module_param_sysfs_remove(mod);<BR>&nbsp;kobject_put(mod-&gt;mkobj.drivers_dir);<BR>&nbsp;kobject_put(mod-&gt;holders_dir);<BR>&nbsp;mod_sysfs_fini(mod);<BR>}</P>
<P>/*<BR>&nbsp;* unlink the module with the whole machine is stopped with interrupts off<BR>&nbsp;* - this defends against kallsyms not taking locks<BR>&nbsp;*/<BR>static int __unlink_module(void *_mod)<BR>{<BR>&nbsp;struct module *mod = _mod;<BR>&nbsp;list_del(&amp;mod-&gt;list);<BR>&nbsp;module_bug_cleanup(mod);<BR>&nbsp;return 0;<BR>}</P>
<P>#ifdef CONFIG_DEBUG_SET_MODULE_RONX<BR>/*<BR>&nbsp;* LKM RO/NX protection: protect module's text/ro-data<BR>&nbsp;* from modification and any data from execution.<BR>&nbsp;*/<BR>void set_page_attributes(void *start, void *end, int (*set)(unsigned long start, int num_pages))<BR>{<BR>&nbsp;unsigned long begin_pfn = PFN_DOWN((unsigned long)start);<BR>&nbsp;unsigned long end_pfn = PFN_DOWN((unsigned long)end);</P>
<P>&nbsp;if (end_pfn &gt; begin_pfn)<BR>&nbsp;&nbsp;set(begin_pfn &lt;&lt; PAGE_SHIFT, end_pfn - begin_pfn);<BR>}</P>
<P>static void set_section_ro_nx(void *base,<BR>&nbsp;&nbsp;&nbsp;unsigned long text_size,<BR>&nbsp;&nbsp;&nbsp;unsigned long ro_size,<BR>&nbsp;&nbsp;&nbsp;unsigned long total_size)<BR>{<BR>&nbsp;/* begin and end PFNs of the current subsection */<BR>&nbsp;unsigned long begin_pfn;<BR>&nbsp;unsigned long end_pfn;</P>
<P>&nbsp;/*<BR>&nbsp; * Set RO for module text and RO-data:<BR>&nbsp; * - Always protect first page.<BR>&nbsp; * - Do not protect last partial page.<BR>&nbsp; */<BR>&nbsp;if (ro_size &gt; 0)<BR>&nbsp;&nbsp;set_page_attributes(base, base + ro_size, set_memory_ro);</P>
<P>&nbsp;/*<BR>&nbsp; * Set NX permissions for module data:<BR>&nbsp; * - Do not protect first partial page.<BR>&nbsp; * - Always protect last page.<BR>&nbsp; */<BR>&nbsp;if (total_size &gt; text_size) {<BR>&nbsp;&nbsp;begin_pfn = PFN_UP((unsigned long)base + text_size);<BR>&nbsp;&nbsp;end_pfn = PFN_UP((unsigned long)base + total_size);<BR>&nbsp;&nbsp;if (end_pfn &gt; begin_pfn)<BR>&nbsp;&nbsp;&nbsp;set_memory_nx(begin_pfn &lt;&lt; PAGE_SHIFT, end_pfn - begin_pfn);<BR>&nbsp;}<BR>}</P>
<P>static void unset_module_core_ro_nx(struct module *mod)<BR>{<BR>&nbsp;set_page_attributes(mod-&gt;module_core + mod-&gt;core_text_size,<BR>&nbsp;&nbsp;mod-&gt;module_core + mod-&gt;core_size,<BR>&nbsp;&nbsp;set_memory_x);<BR>&nbsp;set_page_attributes(mod-&gt;module_core,<BR>&nbsp;&nbsp;mod-&gt;module_core + mod-&gt;core_ro_size,<BR>&nbsp;&nbsp;set_memory_rw);<BR>}</P>
<P>static void unset_module_init_ro_nx(struct module *mod)<BR>{<BR>&nbsp;set_page_attributes(mod-&gt;module_init + mod-&gt;init_text_size,<BR>&nbsp;&nbsp;mod-&gt;module_init + mod-&gt;init_size,<BR>&nbsp;&nbsp;set_memory_x);<BR>&nbsp;set_page_attributes(mod-&gt;module_init,<BR>&nbsp;&nbsp;mod-&gt;module_init + mod-&gt;init_ro_size,<BR>&nbsp;&nbsp;set_memory_rw);<BR>}</P>
<P>/* Iterate through all modules and set each module's text as RW */<BR>void set_all_modules_text_rw(void)<BR>{<BR>&nbsp;struct module *mod;</P>
<P>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;list_for_each_entry_rcu(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;if ((mod-&gt;module_core) &amp;&amp; (mod-&gt;core_text_size)) {<BR>&nbsp;&nbsp;&nbsp;set_page_attributes(mod-&gt;module_core,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mod-&gt;module_core + mod-&gt;core_text_size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_memory_rw);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;if ((mod-&gt;module_init) &amp;&amp; (mod-&gt;init_text_size)) {<BR>&nbsp;&nbsp;&nbsp;set_page_attributes(mod-&gt;module_init,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mod-&gt;module_init + mod-&gt;init_text_size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_memory_rw);<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;module_mutex);<BR>}</P>
<P>/* Iterate through all modules and set each module's text as RO */<BR>void set_all_modules_text_ro(void)<BR>{<BR>&nbsp;struct module *mod;</P>
<P>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;list_for_each_entry_rcu(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;if ((mod-&gt;module_core) &amp;&amp; (mod-&gt;core_text_size)) {<BR>&nbsp;&nbsp;&nbsp;set_page_attributes(mod-&gt;module_core,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mod-&gt;module_core + mod-&gt;core_text_size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_memory_ro);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;if ((mod-&gt;module_init) &amp;&amp; (mod-&gt;init_text_size)) {<BR>&nbsp;&nbsp;&nbsp;set_page_attributes(mod-&gt;module_init,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mod-&gt;module_init + mod-&gt;init_text_size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_memory_ro);<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;mutex_unlock(&amp;module_mutex);<BR>}<BR>#else<BR>static inline void set_section_ro_nx(void *base, unsigned long text_size, unsigned long ro_size, unsigned long total_size) { }<BR>static void unset_module_core_ro_nx(struct module *mod) { }<BR>static void unset_module_init_ro_nx(struct module *mod) { }<BR>#endif</P>
<P>void __weak module_free(struct module *mod, void *module_region)<BR>{<BR>&nbsp;vfree(module_region);<BR>}</P>
<P>void __weak module_arch_cleanup(struct module *mod)<BR>{<BR>}</P>
<P>/* Free a module, remove from lists, etc. */<BR>static void free_module(struct module *mod)<BR>{<BR>&nbsp;trace_module_free(mod);</P>
<P>&nbsp;mod_sysfs_teardown(mod);</P>
<P>&nbsp;/* We leave it in list to prevent duplicate loads, but make sure<BR>&nbsp; * that noone uses it while it's being deconstructed. */<BR>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;mod-&gt;state = MODULE_STATE_UNFORMED;<BR>&nbsp;mutex_unlock(&amp;module_mutex);</P>
<P>&nbsp;/* Remove dynamic debug info */<BR>&nbsp;ddebug_remove_module(mod-&gt;name);</P>
<P>&nbsp;/* Arch-specific cleanup. */<BR>&nbsp;module_arch_cleanup(mod);</P>
<P>&nbsp;/* Module unload stuff */<BR>&nbsp;module_unload_free(mod);</P>
<P>&nbsp;/* Free any allocated parameters. */<BR>&nbsp;destroy_params(mod-&gt;kp, mod-&gt;num_kp);</P>
<P>&nbsp;/* Now we can delete it from the lists */<BR>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;stop_machine(__unlink_module, mod, NULL);<BR>&nbsp;mutex_unlock(&amp;module_mutex);</P>
<P>&nbsp;/* This may be NULL, but that's OK */<BR>&nbsp;unset_module_init_ro_nx(mod);<BR>&nbsp;module_free(mod, mod-&gt;module_init);<BR>&nbsp;kfree(mod-&gt;args);<BR>&nbsp;percpu_modfree(mod);</P>
<P>&nbsp;/* Free lock-classes: */<BR>&nbsp;lockdep_free_key_range(mod-&gt;module_core, mod-&gt;core_size);</P>
<P>&nbsp;/* Finally, free the core (containing the module structure) */<BR>&nbsp;unset_module_core_ro_nx(mod);<BR>&nbsp;module_free(mod, mod-&gt;module_core);</P>
<P>#ifdef CONFIG_MPU<BR>&nbsp;update_protections(current-&gt;mm);<BR>#endif<BR>}</P>
<P>void *__symbol_get(const char *symbol)<BR>{<BR>&nbsp;struct module *owner;<BR>&nbsp;const struct kernel_symbol *sym;</P>
<P>&nbsp;preempt_disable();<BR>&nbsp;sym = find_symbol(symbol, &amp;owner, NULL, true, true);<BR>&nbsp;if (sym &amp;&amp; strong_try_module_get(owner))<BR>&nbsp;&nbsp;sym = NULL;<BR>&nbsp;preempt_enable();</P>
<P>&nbsp;return sym ? (void *)sym-&gt;value : NULL;<BR>}<BR>EXPORT_SYMBOL_GPL(__symbol_get);</P>
<P>/*<BR>&nbsp;* Ensure that an exported symbol [global namespace] does not already exist<BR>&nbsp;* in the kernel or in some other module's exported symbol table.<BR>&nbsp;*<BR>&nbsp;* You must hold the module_mutex.<BR>&nbsp;*/<BR>static int verify_export_symbols(struct module *mod)<BR>{<BR>&nbsp;unsigned int i;<BR>&nbsp;struct module *owner;<BR>&nbsp;const struct kernel_symbol *s;<BR>&nbsp;struct {<BR>&nbsp;&nbsp;const struct kernel_symbol *sym;<BR>&nbsp;&nbsp;unsigned int num;<BR>&nbsp;} arr[] = {<BR>&nbsp;&nbsp;{ mod-&gt;syms, mod-&gt;num_syms },<BR>&nbsp;&nbsp;{ mod-&gt;gpl_syms, mod-&gt;num_gpl_syms },<BR>&nbsp;&nbsp;{ mod-&gt;gpl_future_syms, mod-&gt;num_gpl_future_syms },<BR>#ifdef CONFIG_UNUSED_SYMBOLS<BR>&nbsp;&nbsp;{ mod-&gt;unused_syms, mod-&gt;num_unused_syms },<BR>&nbsp;&nbsp;{ mod-&gt;unused_gpl_syms, mod-&gt;num_unused_gpl_syms },<BR>#endif<BR>&nbsp;};</P>
<P>&nbsp;for (i = 0; i &lt; ARRAY_SIZE(arr); i++) {<BR>&nbsp;&nbsp;for (s = arr[i].sym; s &lt; arr[i].sym + arr[i].num; s++) {<BR>&nbsp;&nbsp;&nbsp;if (find_symbol(s-&gt;name, &amp;owner, NULL, true, false)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_ERR<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%s: exports duplicate symbol %s"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " (owned by %s)\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name, s-&gt;name, module_name(owner));<BR>&nbsp;&nbsp;&nbsp;&nbsp;return -ENOEXEC;<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;return 0;<BR>}</P>
<P>/* Change all symbols so that st_value encodes the pointer directly. */<BR>static int simplify_symbols(struct module *mod, const struct load_info *info)<BR>{<BR>&nbsp;Elf_Shdr *symsec = &amp;info-&gt;sechdrs[info-&gt;index.sym];<BR>&nbsp;Elf_Sym *sym = (void *)symsec-&gt;sh_addr;<BR>&nbsp;unsigned long secbase;<BR>&nbsp;unsigned int i;<BR>&nbsp;int ret = 0;<BR>&nbsp;const struct kernel_symbol *ksym;</P>
<P>&nbsp;for (i = 1; i &lt; symsec-&gt;sh_size / sizeof(Elf_Sym); i++) {<BR>&nbsp;&nbsp;const char *name = info-&gt;strtab + sym[i].st_name;</P>
<P>&nbsp;&nbsp;switch (sym[i].st_shndx) {<BR>&nbsp;&nbsp;case SHN_COMMON:<BR>&nbsp;&nbsp;&nbsp;/* We compiled with -fno-common.&nbsp; These are not<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; supposed to happen.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;pr_debug("Common symbol: %s\n", name);<BR>&nbsp;&nbsp;&nbsp;printk("%s: please compile with -fno-common\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name);<BR>&nbsp;&nbsp;&nbsp;ret = -ENOEXEC;<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;case SHN_ABS:<BR>&nbsp;&nbsp;&nbsp;/* Don't need to do anything */<BR>&nbsp;&nbsp;&nbsp;pr_debug("Absolute symbol: 0x%08lx\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (long)sym[i].st_value);<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;case SHN_UNDEF:<BR>&nbsp;&nbsp;&nbsp;ksym = resolve_symbol_wait(mod, info, name);<BR>&nbsp;&nbsp;&nbsp;/* Ok if resolved.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;if (ksym &amp;&amp; !IS_ERR(ksym)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;sym[i].st_value = ksym-&gt;value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;&nbsp;/* Ok if weak.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;if (!ksym &amp;&amp; ELF_ST_BIND(sym[i].st_info) == STB_WEAK)<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;&nbsp;printk(KERN_WARNING "%s: Unknown symbol %s (err %li)\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name, name, PTR_ERR(ksym));<BR>&nbsp;&nbsp;&nbsp;ret = PTR_ERR(ksym) ?: -ENOENT;<BR>&nbsp;&nbsp;&nbsp;break;</P>
<P>&nbsp;&nbsp;default:<BR>&nbsp;&nbsp;&nbsp;/* Divert to percpu allocation if a percpu var. */<BR>&nbsp;&nbsp;&nbsp;if (sym[i].st_shndx == info-&gt;index.pcpu)<BR>&nbsp;&nbsp;&nbsp;&nbsp;secbase = (unsigned long)mod_percpu(mod);<BR>&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;secbase = info-&gt;sechdrs[sym[i].st_shndx].sh_addr;<BR>&nbsp;&nbsp;&nbsp;sym[i].st_value += secbase;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;return ret;<BR>}</P>
<P>static int apply_relocations(struct module *mod, const struct load_info *info)<BR>{<BR>&nbsp;unsigned int i;<BR>&nbsp;int err = 0;</P>
<P>&nbsp;/* Now do relocations. */<BR>&nbsp;for (i = 1; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<BR>&nbsp;&nbsp;unsigned int infosec = info-&gt;sechdrs[i].sh_info;</P>
<P>&nbsp;&nbsp;/* Not a valid relocation section? */<BR>&nbsp;&nbsp;if (infosec &gt;= info-&gt;hdr-&gt;e_shnum)<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;/* Don't bother with non-allocated sections */<BR>&nbsp;&nbsp;if (!(info-&gt;sechdrs[infosec].sh_flags &amp; SHF_ALLOC))<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;if (info-&gt;sechdrs[i].sh_type == SHT_REL)<BR>&nbsp;&nbsp;&nbsp;err = apply_relocate(info-&gt;sechdrs, info-&gt;strtab,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;index.sym, i, mod);<BR>&nbsp;&nbsp;else if (info-&gt;sechdrs[i].sh_type == SHT_RELA)<BR>&nbsp;&nbsp;&nbsp;err = apply_relocate_add(info-&gt;sechdrs, info-&gt;strtab,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;index.sym, i, mod);<BR>&nbsp;&nbsp;if (err &lt; 0)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;}<BR>&nbsp;return err;<BR>}</P>
<P>/* Additional bytes needed by arch in front of individual sections */<BR>unsigned int __weak arch_mod_section_prepend(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int section)<BR>{<BR>&nbsp;/* default implementation just returns zero */<BR>&nbsp;return 0;<BR>}</P>
<P>/* Update size with this section: return offset. */<BR>static long get_offset(struct module *mod, unsigned int *size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Elf_Shdr *sechdr, unsigned int section)<BR>{<BR>&nbsp;long ret;</P>
<P>&nbsp;*size += arch_mod_section_prepend(mod, section);<BR>&nbsp;ret = ALIGN(*size, sechdr-&gt;sh_addralign ?: 1);<BR>&nbsp;*size = ret + sechdr-&gt;sh_size;<BR>&nbsp;return ret;<BR>}</P>
<P>/* Lay out the SHF_ALLOC sections in a way not dissimilar to how ld<BR>&nbsp;&nbsp; might -- code, read-only data, read-write data, small data.&nbsp; Tally<BR>&nbsp;&nbsp; sizes, and place the offsets into sh_entsize fields: high bit means it<BR>&nbsp;&nbsp; belongs in init. */<BR>static void layout_sections(struct module *mod, struct load_info *info)<BR>{<BR>&nbsp;static unsigned long const masks[][2] = {<BR>&nbsp;&nbsp;/* NOTE: all executable code must be the first section<BR>&nbsp;&nbsp; * in this array; otherwise modify the text_size<BR>&nbsp;&nbsp; * finder in the two loops below */<BR>&nbsp;&nbsp;{ SHF_EXECINSTR | SHF_ALLOC, ARCH_SHF_SMALL },<BR>&nbsp;&nbsp;{ SHF_ALLOC, SHF_WRITE | ARCH_SHF_SMALL },<BR>&nbsp;&nbsp;{ SHF_WRITE | SHF_ALLOC, ARCH_SHF_SMALL },<BR>&nbsp;&nbsp;{ ARCH_SHF_SMALL | SHF_ALLOC, 0 }<BR>&nbsp;};<BR>&nbsp;unsigned int m, i;</P>
<P>&nbsp;for (i = 0; i &lt; info-&gt;hdr-&gt;e_shnum; i++)<BR>&nbsp;&nbsp;info-&gt;sechdrs[i].sh_entsize = ~0UL;</P>
<P>&nbsp;pr_debug("Core section allocation order:\n");<BR>&nbsp;for (m = 0; m &lt; ARRAY_SIZE(masks); ++m) {<BR>&nbsp;&nbsp;for (i = 0; i &lt; info-&gt;hdr-&gt;e_shnum; ++i) {<BR>&nbsp;&nbsp;&nbsp;Elf_Shdr *s = &amp;info-&gt;sechdrs[i];<BR>&nbsp;&nbsp;&nbsp;const char *sname = info-&gt;secstrings + s-&gt;sh_name;</P>
<P>&nbsp;&nbsp;&nbsp;if ((s-&gt;sh_flags &amp; masks[m][0]) != masks[m][0]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (s-&gt;sh_flags &amp; masks[m][1])<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || s-&gt;sh_entsize != ~0UL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || strstarts(sname, ".init"))<BR>&nbsp;&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;&nbsp;s-&gt;sh_entsize = get_offset(mod, &amp;mod-&gt;core_size, s, i);<BR>&nbsp;&nbsp;&nbsp;pr_debug("\t%s\n", sname);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;switch (m) {<BR>&nbsp;&nbsp;case 0: /* executable */<BR>&nbsp;&nbsp;&nbsp;mod-&gt;core_size = debug_align(mod-&gt;core_size);<BR>&nbsp;&nbsp;&nbsp;mod-&gt;core_text_size = mod-&gt;core_size;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 1: /* RO: text and ro-data */<BR>&nbsp;&nbsp;&nbsp;mod-&gt;core_size = debug_align(mod-&gt;core_size);<BR>&nbsp;&nbsp;&nbsp;mod-&gt;core_ro_size = mod-&gt;core_size;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 3: /* whole core */<BR>&nbsp;&nbsp;&nbsp;mod-&gt;core_size = debug_align(mod-&gt;core_size);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;pr_debug("Init section allocation order:\n");<BR>&nbsp;for (m = 0; m &lt; ARRAY_SIZE(masks); ++m) {<BR>&nbsp;&nbsp;for (i = 0; i &lt; info-&gt;hdr-&gt;e_shnum; ++i) {<BR>&nbsp;&nbsp;&nbsp;Elf_Shdr *s = &amp;info-&gt;sechdrs[i];<BR>&nbsp;&nbsp;&nbsp;const char *sname = info-&gt;secstrings + s-&gt;sh_name;</P>
<P>&nbsp;&nbsp;&nbsp;if ((s-&gt;sh_flags &amp; masks[m][0]) != masks[m][0]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (s-&gt;sh_flags &amp; masks[m][1])<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || s-&gt;sh_entsize != ~0UL<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || !strstarts(sname, ".init"))<BR>&nbsp;&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;&nbsp;s-&gt;sh_entsize = (get_offset(mod, &amp;mod-&gt;init_size, s, i)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | INIT_OFFSET_MASK);<BR>&nbsp;&nbsp;&nbsp;pr_debug("\t%s\n", sname);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;switch (m) {<BR>&nbsp;&nbsp;case 0: /* executable */<BR>&nbsp;&nbsp;&nbsp;mod-&gt;init_size = debug_align(mod-&gt;init_size);<BR>&nbsp;&nbsp;&nbsp;mod-&gt;init_text_size = mod-&gt;init_size;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 1: /* RO: text and ro-data */<BR>&nbsp;&nbsp;&nbsp;mod-&gt;init_size = debug_align(mod-&gt;init_size);<BR>&nbsp;&nbsp;&nbsp;mod-&gt;init_ro_size = mod-&gt;init_size;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;case 3: /* whole init */<BR>&nbsp;&nbsp;&nbsp;mod-&gt;init_size = debug_align(mod-&gt;init_size);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>}</P>
<P>static void set_license(struct module *mod, const char *license)<BR>{<BR>&nbsp;if (!license)<BR>&nbsp;&nbsp;license = "unspecified";</P>
<P>&nbsp;if (!license_is_gpl_compatible(license)) {<BR>&nbsp;&nbsp;if (!test_taint(TAINT_PROPRIETARY_MODULE))<BR>&nbsp;&nbsp;&nbsp;printk(KERN_WARNING "%s: module license '%s' taints "<BR>&nbsp;&nbsp;&nbsp;&nbsp;"kernel.\n", mod-&gt;name, license);<BR>&nbsp;&nbsp;add_taint_module(mod, TAINT_PROPRIETARY_MODULE,<BR>&nbsp;&nbsp;&nbsp;&nbsp; LOCKDEP_NOW_UNRELIABLE);<BR>&nbsp;}<BR>}</P>
<P>/* Parse tag=value strings from .modinfo section */<BR>static char *next_string(char *string, unsigned long *secsize)<BR>{<BR>&nbsp;/* Skip non-zero chars */<BR>&nbsp;while (string[0]) {<BR>&nbsp;&nbsp;string++;<BR>&nbsp;&nbsp;if ((*secsize)-- &lt;= 1)<BR>&nbsp;&nbsp;&nbsp;return NULL;<BR>&nbsp;}</P>
<P>&nbsp;/* Skip any zero padding. */<BR>&nbsp;while (!string[0]) {<BR>&nbsp;&nbsp;string++;<BR>&nbsp;&nbsp;if ((*secsize)-- &lt;= 1)<BR>&nbsp;&nbsp;&nbsp;return NULL;<BR>&nbsp;}<BR>&nbsp;return string;<BR>}</P>
<P>static char *get_modinfo(struct load_info *info, const char *tag)<BR>{<BR>&nbsp;char *p;<BR>&nbsp;unsigned int taglen = strlen(tag);<BR>&nbsp;Elf_Shdr *infosec = &amp;info-&gt;sechdrs[info-&gt;index.info];<BR>&nbsp;unsigned long size = infosec-&gt;sh_size;</P>
<P>&nbsp;for (p = (char *)infosec-&gt;sh_addr; p; p = next_string(p, &amp;size)) {<BR>&nbsp;&nbsp;if (strncmp(p, tag, taglen) == 0 &amp;&amp; p[taglen] == '=')<BR>&nbsp;&nbsp;&nbsp;return p + taglen + 1;<BR>&nbsp;}<BR>&nbsp;return NULL;<BR>}</P>
<P>static void setup_modinfo(struct module *mod, struct load_info *info)<BR>{<BR>&nbsp;struct module_attribute *attr;<BR>&nbsp;int i;</P>
<P>&nbsp;for (i = 0; (attr = modinfo_attrs[i]); i++) {<BR>&nbsp;&nbsp;if (attr-&gt;setup)<BR>&nbsp;&nbsp;&nbsp;attr-&gt;setup(mod, get_modinfo(info, attr-&gt;attr.name));<BR>&nbsp;}<BR>}</P>
<P>static void free_modinfo(struct module *mod)<BR>{<BR>&nbsp;struct module_attribute *attr;<BR>&nbsp;int i;</P>
<P>&nbsp;for (i = 0; (attr = modinfo_attrs[i]); i++) {<BR>&nbsp;&nbsp;if (attr-&gt;free)<BR>&nbsp;&nbsp;&nbsp;attr-&gt;free(mod);<BR>&nbsp;}<BR>}</P>
<P>#ifdef CONFIG_KALLSYMS</P>
<P>/* lookup symbol in given range of kernel_symbols */<BR>static const struct kernel_symbol *lookup_symbol(const char *name,<BR>&nbsp;const struct kernel_symbol *start,<BR>&nbsp;const struct kernel_symbol *stop)<BR>{<BR>&nbsp;return bsearch(name, start, stop - start,<BR>&nbsp;&nbsp;&nbsp;sizeof(struct kernel_symbol), cmp_name);<BR>}</P>
<P>static int is_exported(const char *name, unsigned long value,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct module *mod)<BR>{<BR>&nbsp;const struct kernel_symbol *ks;<BR>&nbsp;if (!mod)<BR>&nbsp;&nbsp;ks = lookup_symbol(name, __start___ksymtab, __stop___ksymtab);<BR>&nbsp;else<BR>&nbsp;&nbsp;ks = lookup_symbol(name, mod-&gt;syms, mod-&gt;syms + mod-&gt;num_syms);<BR>&nbsp;return ks != NULL &amp;&amp; ks-&gt;value == value;<BR>}</P>
<P>/* As per nm */<BR>static char elf_type(const Elf_Sym *sym, const struct load_info *info)<BR>{<BR>&nbsp;const Elf_Shdr *sechdrs = info-&gt;sechdrs;</P>
<P>&nbsp;if (ELF_ST_BIND(sym-&gt;st_info) == STB_WEAK) {<BR>&nbsp;&nbsp;if (ELF_ST_TYPE(sym-&gt;st_info) == STT_OBJECT)<BR>&nbsp;&nbsp;&nbsp;return 'v';<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;return 'w';<BR>&nbsp;}<BR>&nbsp;if (sym-&gt;st_shndx == SHN_UNDEF)<BR>&nbsp;&nbsp;return 'U';<BR>&nbsp;if (sym-&gt;st_shndx == SHN_ABS)<BR>&nbsp;&nbsp;return 'a';<BR>&nbsp;if (sym-&gt;st_shndx &gt;= SHN_LORESERVE)<BR>&nbsp;&nbsp;return '?';<BR>&nbsp;if (sechdrs[sym-&gt;st_shndx].sh_flags &amp; SHF_EXECINSTR)<BR>&nbsp;&nbsp;return 't';<BR>&nbsp;if (sechdrs[sym-&gt;st_shndx].sh_flags &amp; SHF_ALLOC<BR>&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; sechdrs[sym-&gt;st_shndx].sh_type != SHT_NOBITS) {<BR>&nbsp;&nbsp;if (!(sechdrs[sym-&gt;st_shndx].sh_flags &amp; SHF_WRITE))<BR>&nbsp;&nbsp;&nbsp;return 'r';<BR>&nbsp;&nbsp;else if (sechdrs[sym-&gt;st_shndx].sh_flags &amp; ARCH_SHF_SMALL)<BR>&nbsp;&nbsp;&nbsp;return 'g';<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;return 'd';<BR>&nbsp;}<BR>&nbsp;if (sechdrs[sym-&gt;st_shndx].sh_type == SHT_NOBITS) {<BR>&nbsp;&nbsp;if (sechdrs[sym-&gt;st_shndx].sh_flags &amp; ARCH_SHF_SMALL)<BR>&nbsp;&nbsp;&nbsp;return 's';<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;return 'b';<BR>&nbsp;}<BR>&nbsp;if (strstarts(info-&gt;secstrings + sechdrs[sym-&gt;st_shndx].sh_name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ".debug")) {<BR>&nbsp;&nbsp;return 'n';<BR>&nbsp;}<BR>&nbsp;return '?';<BR>}</P>
<P>static bool is_core_symbol(const Elf_Sym *src, const Elf_Shdr *sechdrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int shnum)<BR>{<BR>&nbsp;const Elf_Shdr *sec;</P>
<P>&nbsp;if (src-&gt;st_shndx == SHN_UNDEF<BR>&nbsp;&nbsp;&nbsp;&nbsp; || src-&gt;st_shndx &gt;= shnum<BR>&nbsp;&nbsp;&nbsp;&nbsp; || !src-&gt;st_name)<BR>&nbsp;&nbsp;return false;</P>
<P>&nbsp;sec = sechdrs + src-&gt;st_shndx;<BR>&nbsp;if (!(sec-&gt;sh_flags &amp; SHF_ALLOC)<BR>#ifndef CONFIG_KALLSYMS_ALL<BR>&nbsp;&nbsp;&nbsp;&nbsp; || !(sec-&gt;sh_flags &amp; SHF_EXECINSTR)<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp; || (sec-&gt;sh_entsize &amp; INIT_OFFSET_MASK))<BR>&nbsp;&nbsp;return false;</P>
<P>&nbsp;return true;<BR>}</P>
<P>/*<BR>&nbsp;* We only allocate and copy the strings needed by the parts of symtab<BR>&nbsp;* we keep.&nbsp; This is simple, but has the effect of making multiple<BR>&nbsp;* copies of duplicates.&nbsp; We could be more sophisticated, see<BR>&nbsp;* linux-kernel thread starting with<BR>&nbsp;* &lt;<A href="mailto:73defb5e4bca04a6431392cc341112b1@localhost">73defb5e4bca04a6431392cc341112b1@localhost</A>&gt;.<BR>&nbsp;*/<BR>static void layout_symtab(struct module *mod, struct load_info *info)<BR>{<BR>&nbsp;Elf_Shdr *symsect = info-&gt;sechdrs + info-&gt;index.sym;<BR>&nbsp;Elf_Shdr *strsect = info-&gt;sechdrs + info-&gt;index.str;<BR>&nbsp;const Elf_Sym *src;<BR>&nbsp;unsigned int i, nsrc, ndst, strtab_size = 0;</P>
<P>&nbsp;/* Put symbol section at end of init part of module. */<BR>&nbsp;symsect-&gt;sh_flags |= SHF_ALLOC;<BR>&nbsp;symsect-&gt;sh_entsize = get_offset(mod, &amp;mod-&gt;init_size, symsect,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;index.sym) | INIT_OFFSET_MASK;<BR>&nbsp;pr_debug("\t%s\n", info-&gt;secstrings + symsect-&gt;sh_name);</P>
<P>&nbsp;src = (void *)info-&gt;hdr + symsect-&gt;sh_offset;<BR>&nbsp;nsrc = symsect-&gt;sh_size / sizeof(*src);</P>
<P>&nbsp;/* Compute total space required for the core symbols' strtab. */<BR>&nbsp;for (ndst = i = 0; i &lt; nsrc; i++) {<BR>&nbsp;&nbsp;if (i == 0 ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_core_symbol(src+i, info-&gt;sechdrs, info-&gt;hdr-&gt;e_shnum)) {<BR>&nbsp;&nbsp;&nbsp;strtab_size += strlen(&amp;info-&gt;strtab[src[i].st_name])+1;<BR>&nbsp;&nbsp;&nbsp;ndst++;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;/* Append room for core symbols at end of core part. */<BR>&nbsp;info-&gt;symoffs = ALIGN(mod-&gt;core_size, symsect-&gt;sh_addralign ?: 1);<BR>&nbsp;info-&gt;stroffs = mod-&gt;core_size = info-&gt;symoffs + ndst * sizeof(Elf_Sym);<BR>&nbsp;mod-&gt;core_size += strtab_size;</P>
<P>&nbsp;/* Put string table section at end of init part of module. */<BR>&nbsp;strsect-&gt;sh_flags |= SHF_ALLOC;<BR>&nbsp;strsect-&gt;sh_entsize = get_offset(mod, &amp;mod-&gt;init_size, strsect,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;index.str) | INIT_OFFSET_MASK;<BR>&nbsp;pr_debug("\t%s\n", info-&gt;secstrings + strsect-&gt;sh_name);<BR>}</P>
<P>static void add_kallsyms(struct module *mod, const struct load_info *info)<BR>{<BR>&nbsp;unsigned int i, ndst;<BR>&nbsp;const Elf_Sym *src;<BR>&nbsp;Elf_Sym *dst;<BR>&nbsp;char *s;<BR>&nbsp;Elf_Shdr *symsec = &amp;info-&gt;sechdrs[info-&gt;index.sym];</P>
<P>&nbsp;mod-&gt;symtab = (void *)symsec-&gt;sh_addr;<BR>&nbsp;mod-&gt;num_symtab = symsec-&gt;sh_size / sizeof(Elf_Sym);<BR>&nbsp;/* Make sure we get permanent strtab: don't use info-&gt;strtab. */<BR>&nbsp;mod-&gt;strtab = (void *)info-&gt;sechdrs[info-&gt;index.str].sh_addr;</P>
<P>&nbsp;/* Set types up while we still have access to sections. */<BR>&nbsp;for (i = 0; i &lt; mod-&gt;num_symtab; i++)<BR>&nbsp;&nbsp;mod-&gt;symtab[i].st_info = elf_type(&amp;mod-&gt;symtab[i], info);</P>
<P>&nbsp;mod-&gt;core_symtab = dst = mod-&gt;module_core + info-&gt;symoffs;<BR>&nbsp;mod-&gt;core_strtab = s = mod-&gt;module_core + info-&gt;stroffs;<BR>&nbsp;src = mod-&gt;symtab;<BR>&nbsp;for (ndst = i = 0; i &lt; mod-&gt;num_symtab; i++) {<BR>&nbsp;&nbsp;if (i == 0 ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_core_symbol(src+i, info-&gt;sechdrs, info-&gt;hdr-&gt;e_shnum)) {<BR>&nbsp;&nbsp;&nbsp;dst[ndst] = src[i];<BR>&nbsp;&nbsp;&nbsp;dst[ndst++].st_name = s - mod-&gt;core_strtab;<BR>&nbsp;&nbsp;&nbsp;s += strlcpy(s, &amp;mod-&gt;strtab[src[i].st_name],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KSYM_NAME_LEN) + 1;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;mod-&gt;core_num_syms = ndst;<BR>}<BR>#else<BR>static inline void layout_symtab(struct module *mod, struct load_info *info)<BR>{<BR>}</P>
<P>static void add_kallsyms(struct module *mod, const struct load_info *info)<BR>{<BR>}<BR>#endif /* CONFIG_KALLSYMS */</P>
<P>static void dynamic_debug_setup(struct _ddebug *debug, unsigned int num)<BR>{<BR>&nbsp;if (!debug)<BR>&nbsp;&nbsp;return;<BR>#ifdef CONFIG_DYNAMIC_DEBUG<BR>&nbsp;if (ddebug_add_module(debug, num, debug-&gt;modname))<BR>&nbsp;&nbsp;printk(KERN_ERR "dynamic debug error adding module: %s\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug-&gt;modname);<BR>#endif<BR>}</P>
<P>static void dynamic_debug_remove(struct _ddebug *debug)<BR>{<BR>&nbsp;if (debug)<BR>&nbsp;&nbsp;ddebug_remove_module(debug-&gt;modname);<BR>}</P>
<P>void * __weak module_alloc(unsigned long size)<BR>{<BR>&nbsp;return vmalloc_exec(size);<BR>}</P>
<P>static void *module_alloc_update_bounds(unsigned long size)<BR>{<BR>&nbsp;void *ret = module_alloc(size);</P>
<P>&nbsp;if (ret) {<BR>&nbsp;&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;&nbsp;/* Update module bounds. */<BR>&nbsp;&nbsp;if ((unsigned long)ret &lt; module_addr_min)<BR>&nbsp;&nbsp;&nbsp;module_addr_min = (unsigned long)ret;<BR>&nbsp;&nbsp;if ((unsigned long)ret + size &gt; module_addr_max)<BR>&nbsp;&nbsp;&nbsp;module_addr_max = (unsigned long)ret + size;<BR>&nbsp;&nbsp;mutex_unlock(&amp;module_mutex);<BR>&nbsp;}<BR>&nbsp;return ret;<BR>}</P>
<P>#ifdef CONFIG_DEBUG_KMEMLEAK<BR>static void kmemleak_load_module(const struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct load_info *info)<BR>{<BR>&nbsp;unsigned int i;</P>
<P>&nbsp;/* only scan the sections containing data */<BR>&nbsp;kmemleak_scan_area(mod, sizeof(struct module), GFP_KERNEL);</P>
<P>&nbsp;for (i = 1; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<BR>&nbsp;&nbsp;/* Scan all writable sections that's not executable */<BR>&nbsp;&nbsp;if (!(info-&gt;sechdrs[i].sh_flags &amp; SHF_ALLOC) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !(info-&gt;sechdrs[i].sh_flags &amp; SHF_WRITE) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (info-&gt;sechdrs[i].sh_flags &amp; SHF_EXECINSTR))<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;kmemleak_scan_area((void *)info-&gt;sechdrs[i].sh_addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;sechdrs[i].sh_size, GFP_KERNEL);<BR>&nbsp;}<BR>}<BR>#else<BR>static inline void kmemleak_load_module(const struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const struct load_info *info)<BR>{<BR>}<BR>#endif</P>
<P>#ifdef CONFIG_MODULE_SIG<BR>static int module_sig_check(struct load_info *info)<BR>{<BR>&nbsp;int err = -ENOKEY;<BR>&nbsp;const unsigned long markerlen = sizeof(MODULE_SIG_STRING) - 1;<BR>&nbsp;const void *mod = info-&gt;hdr;</P>
<P>&nbsp;if (info-&gt;len &gt; markerlen &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; memcmp(mod + info-&gt;len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {<BR>&nbsp;&nbsp;/* We truncate the module to discard the signature */<BR>&nbsp;&nbsp;info-&gt;len -= markerlen;<BR>&nbsp;&nbsp;err = mod_verify_sig(mod, &amp;info-&gt;len);<BR>&nbsp;}</P>
<P>&nbsp;if (!err) {<BR>&nbsp;&nbsp;info-&gt;sig_ok = true;<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;}</P>
<P>&nbsp;/* Not having a signature is only an error if we're strict. */<BR>&nbsp;if (err &lt; 0 &amp;&amp; fips_enabled)<BR>&nbsp;&nbsp;panic("Module verification failed with error %d in FIPS mode\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err);<BR>&nbsp;if (err == -ENOKEY &amp;&amp; !sig_enforce)<BR>&nbsp;&nbsp;err = 0;</P>
<P>&nbsp;return err;<BR>}<BR>#else /* !CONFIG_MODULE_SIG */<BR>static int module_sig_check(struct load_info *info)<BR>{<BR>&nbsp;return 0;<BR>}<BR>#endif /* !CONFIG_MODULE_SIG */</P>
<P>/* Sanity checks against invalid binaries, wrong arch, weird elf version. */<BR>static int elf_header_check(struct load_info *info)<BR>{<BR>&nbsp;if (info-&gt;len &lt; sizeof(*(info-&gt;hdr)))<BR>&nbsp;&nbsp;return -ENOEXEC;</P>
<P>&nbsp;if (memcmp(info-&gt;hdr-&gt;e_ident, ELFMAG, SELFMAG) != 0<BR>&nbsp;&nbsp;&nbsp;&nbsp; || info-&gt;hdr-&gt;e_type != ET_REL<BR>&nbsp;&nbsp;&nbsp;&nbsp; || !elf_check_arch(info-&gt;hdr)<BR>&nbsp;&nbsp;&nbsp;&nbsp; || info-&gt;hdr-&gt;e_shentsize != sizeof(Elf_Shdr))<BR>&nbsp;&nbsp;return -ENOEXEC;</P>
<P>&nbsp;if (info-&gt;hdr-&gt;e_shoff &gt;= info-&gt;len<BR>&nbsp;&nbsp;&nbsp;&nbsp; || (info-&gt;hdr-&gt;e_shnum * sizeof(Elf_Shdr) &gt;<BR>&nbsp;&nbsp;info-&gt;len - info-&gt;hdr-&gt;e_shoff))<BR>&nbsp;&nbsp;return -ENOEXEC;</P>
<P>&nbsp;return 0;<BR>}</P>
<P>/* Sets info-&gt;hdr and info-&gt;len. */<BR>static int copy_module_from_user(const void __user *umod, unsigned long len,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct load_info *info)<BR>{<BR>&nbsp;int err;</P>
<P>&nbsp;info-&gt;len = len;<BR>&nbsp;if (info-&gt;len &lt; sizeof(*(info-&gt;hdr)))<BR>&nbsp;&nbsp;return -ENOEXEC;</P>
<P>&nbsp;err = security_kernel_module_from_file(NULL);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;return err;</P>
<P>&nbsp;/* Suck in entire file: we'll want most of it. */<BR>&nbsp;info-&gt;hdr = vmalloc(info-&gt;len);<BR>&nbsp;if (!info-&gt;hdr)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;if (copy_from_user(info-&gt;hdr, umod, info-&gt;len) != 0) {<BR>&nbsp;&nbsp;vfree(info-&gt;hdr);<BR>&nbsp;&nbsp;return -EFAULT;<BR>&nbsp;}</P>
<P>&nbsp;return 0;<BR>}</P>
<P>/* Sets info-&gt;hdr and info-&gt;len. */<BR>static int copy_module_from_fd(int fd, struct load_info *info)<BR>{<BR>&nbsp;struct file *file;<BR>&nbsp;int err;<BR>&nbsp;struct kstat stat;<BR>&nbsp;loff_t pos;<BR>&nbsp;ssize_t bytes = 0;</P>
<P>&nbsp;file = fget(fd);<BR>&nbsp;if (!file)<BR>&nbsp;&nbsp;return -ENOEXEC;</P>
<P>&nbsp;err = security_kernel_module_from_file(file);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;err = vfs_getattr(&amp;file-&gt;f_path, &amp;stat);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;if (stat.size &gt; INT_MAX) {<BR>&nbsp;&nbsp;err = -EFBIG;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}</P>
<P>&nbsp;/* Don't hand 0 to vmalloc, it whines. */<BR>&nbsp;if (stat.size == 0) {<BR>&nbsp;&nbsp;err = -EINVAL;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}</P>
<P>&nbsp;info-&gt;hdr = vmalloc(stat.size);<BR>&nbsp;if (!info-&gt;hdr) {<BR>&nbsp;&nbsp;err = -ENOMEM;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}</P>
<P>&nbsp;pos = 0;<BR>&nbsp;while (pos &lt; stat.size) {<BR>&nbsp;&nbsp;bytes = kernel_read(file, pos, (char *)(info-&gt;hdr) + pos,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stat.size - pos);<BR>&nbsp;&nbsp;if (bytes &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;vfree(info-&gt;hdr);<BR>&nbsp;&nbsp;&nbsp;err = bytes;<BR>&nbsp;&nbsp;&nbsp;goto out;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;if (bytes == 0)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;pos += bytes;<BR>&nbsp;}<BR>&nbsp;info-&gt;len = pos;</P>
<P>out:<BR>&nbsp;fput(file);<BR>&nbsp;return err;<BR>}</P>
<P>static void free_copy(struct load_info *info)<BR>{<BR>&nbsp;vfree(info-&gt;hdr);<BR>}</P>
<P>static int rewrite_section_headers(struct load_info *info, int flags)<BR>{<BR>&nbsp;unsigned int i;</P>
<P>&nbsp;/* This should always be true, but let's be sure. */<BR>&nbsp;info-&gt;sechdrs[0].sh_addr = 0;</P>
<P>&nbsp;for (i = 1; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<BR>&nbsp;&nbsp;Elf_Shdr *shdr = &amp;info-&gt;sechdrs[i];<BR>&nbsp;&nbsp;if (shdr-&gt;sh_type != SHT_NOBITS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; info-&gt;len &lt; shdr-&gt;sh_offset + shdr-&gt;sh_size) {<BR>&nbsp;&nbsp;&nbsp;printk(KERN_ERR "Module len %lu truncated\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;len);<BR>&nbsp;&nbsp;&nbsp;return -ENOEXEC;<BR>&nbsp;&nbsp;}</P>
<P>&nbsp;&nbsp;/* Mark all sections sh_addr with their address in the<BR>&nbsp;&nbsp;&nbsp;&nbsp; temporary image. */<BR>&nbsp;&nbsp;shdr-&gt;sh_addr = (size_t)info-&gt;hdr + shdr-&gt;sh_offset;</P>
<P>#ifndef CONFIG_MODULE_UNLOAD<BR>&nbsp;&nbsp;/* Don't load .exit sections */<BR>&nbsp;&nbsp;if (strstarts(info-&gt;secstrings+shdr-&gt;sh_name, ".exit"))<BR>&nbsp;&nbsp;&nbsp;shdr-&gt;sh_flags &amp;= ~(unsigned long)SHF_ALLOC;<BR>#endif<BR>&nbsp;}</P>
<P>&nbsp;/* Track but don't keep modinfo and version sections. */<BR>&nbsp;if (flags &amp; MODULE_INIT_IGNORE_MODVERSIONS)<BR>&nbsp;&nbsp;info-&gt;index.vers = 0; /* Pretend no __versions section! */<BR>&nbsp;else<BR>&nbsp;&nbsp;info-&gt;index.vers = find_sec(info, "__versions");<BR>&nbsp;info-&gt;index.info = find_sec(info, ".modinfo");<BR>&nbsp;info-&gt;sechdrs[info-&gt;index.info].sh_flags &amp;= ~(unsigned long)SHF_ALLOC;<BR>&nbsp;info-&gt;sechdrs[info-&gt;index.vers].sh_flags &amp;= ~(unsigned long)SHF_ALLOC;<BR>&nbsp;return 0;<BR>}</P>
<P>/*<BR>&nbsp;* Set up our basic convenience variables (pointers to section headers,<BR>&nbsp;* search for module section index etc), and do some basic section<BR>&nbsp;* verification.<BR>&nbsp;*<BR>&nbsp;* Return the temporary module pointer (we'll replace it with the final<BR>&nbsp;* one when we move the module sections around).<BR>&nbsp;*/<BR>static struct module *setup_load_info(struct load_info *info, int flags)<BR>{<BR>&nbsp;unsigned int i;<BR>&nbsp;int err;<BR>&nbsp;struct module *mod;</P>
<P>&nbsp;/* Set up the convenience variables */<BR>&nbsp;info-&gt;sechdrs = (void *)info-&gt;hdr + info-&gt;hdr-&gt;e_shoff;<BR>&nbsp;info-&gt;secstrings = (void *)info-&gt;hdr<BR>&nbsp;&nbsp;+ info-&gt;sechdrs[info-&gt;hdr-&gt;e_shstrndx].sh_offset;</P>
<P>&nbsp;err = rewrite_section_headers(info, flags);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;return ERR_PTR(err);</P>
<P>&nbsp;/* Find internal symbols and strings. */<BR>&nbsp;for (i = 1; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<BR>&nbsp;&nbsp;if (info-&gt;sechdrs[i].sh_type == SHT_SYMTAB) {<BR>&nbsp;&nbsp;&nbsp;info-&gt;index.sym = i;<BR>&nbsp;&nbsp;&nbsp;info-&gt;index.str = info-&gt;sechdrs[i].sh_link;<BR>&nbsp;&nbsp;&nbsp;info-&gt;strtab = (char *)info-&gt;hdr<BR>&nbsp;&nbsp;&nbsp;&nbsp;+ info-&gt;sechdrs[info-&gt;index.str].sh_offset;<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}</P>
<P>&nbsp;info-&gt;index.mod = find_sec(info, ".gnu.linkonce.this_module");<BR>&nbsp;if (!info-&gt;index.mod) {<BR>&nbsp;&nbsp;printk(KERN_WARNING "No module found in object\n");<BR>&nbsp;&nbsp;return ERR_PTR(-ENOEXEC);<BR>&nbsp;}<BR>&nbsp;/* This is temporary: point mod into copy of data. */<BR>&nbsp;mod = (void *)info-&gt;sechdrs[info-&gt;index.mod].sh_addr;</P>
<P>&nbsp;if (info-&gt;index.sym == 0) {<BR>&nbsp;&nbsp;printk(KERN_WARNING "%s: module has no symbols (stripped?)\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name);<BR>&nbsp;&nbsp;return ERR_PTR(-ENOEXEC);<BR>&nbsp;}</P>
<P>&nbsp;info-&gt;index.pcpu = find_pcpusec(info);</P>
<P>&nbsp;/* Check module struct version now, before we try to use module. */<BR>&nbsp;if (!check_modstruct_version(info-&gt;sechdrs, info-&gt;index.vers, mod))<BR>&nbsp;&nbsp;return ERR_PTR(-ENOEXEC);</P>
<P>&nbsp;return mod;<BR>}</P>
<P>static int check_modinfo(struct module *mod, struct load_info *info, int flags)<BR>{<BR>&nbsp;const char *modmagic = get_modinfo(info, "vermagic");<BR>&nbsp;int err;</P>
<P>&nbsp;if (flags &amp; MODULE_INIT_IGNORE_VERMAGIC)<BR>&nbsp;&nbsp;modmagic = NULL;</P>
<P>&nbsp;/* This is allowed: modprobe --force will invalidate it. */<BR>&nbsp;if (!modmagic) {<BR>&nbsp;&nbsp;err = try_to_force_load(mod, "bad vermagic");<BR>&nbsp;&nbsp;if (err)<BR>&nbsp;&nbsp;&nbsp;return err;<BR>&nbsp;} else if (!same_magic(modmagic, vermagic, info-&gt;index.vers)) {<BR>&nbsp;&nbsp;printk(KERN_ERR "%s: version magic '%s' should be '%s'\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name, modmagic, vermagic);<BR>&nbsp;&nbsp;return -ENOEXEC;<BR>&nbsp;}</P>
<P>&nbsp;if (!get_modinfo(info, "intree"))<BR>&nbsp;&nbsp;add_taint_module(mod, TAINT_OOT_MODULE, LOCKDEP_STILL_OK);</P>
<P>&nbsp;if (get_modinfo(info, "staging")) {<BR>&nbsp;&nbsp;add_taint_module(mod, TAINT_CRAP, LOCKDEP_STILL_OK);<BR>&nbsp;&nbsp;printk(KERN_WARNING "%s: module is from the staging directory,"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " the quality is unknown, you have been warned.\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name);<BR>&nbsp;}</P>
<P>&nbsp;/* Set up license info based on the info section */<BR>&nbsp;set_license(mod, get_modinfo(info, "license"));</P>
<P>&nbsp;return 0;<BR>}</P>
<P>static int find_module_sections(struct module *mod, struct load_info *info)<BR>{<BR>&nbsp;mod-&gt;kp = section_objs(info, "__param",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;kp), &amp;mod-&gt;num_kp);<BR>&nbsp;mod-&gt;syms = section_objs(info, "__ksymtab",<BR>&nbsp;&nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;syms), &amp;mod-&gt;num_syms);<BR>&nbsp;mod-&gt;crcs = section_addr(info, "__kcrctab");<BR>&nbsp;mod-&gt;gpl_syms = section_objs(info, "__ksymtab_gpl",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;gpl_syms),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;mod-&gt;num_gpl_syms);<BR>&nbsp;mod-&gt;gpl_crcs = section_addr(info, "__kcrctab_gpl");<BR>&nbsp;mod-&gt;gpl_future_syms = section_objs(info,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "__ksymtab_gpl_future",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;gpl_future_syms),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;mod-&gt;num_gpl_future_syms);<BR>&nbsp;mod-&gt;gpl_future_crcs = section_addr(info, "__kcrctab_gpl_future");</P>
<P>#ifdef CONFIG_UNUSED_SYMBOLS<BR>&nbsp;mod-&gt;unused_syms = section_objs(info, "__ksymtab_unused",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(*mod-&gt;unused_syms),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;mod-&gt;num_unused_syms);<BR>&nbsp;mod-&gt;unused_crcs = section_addr(info, "__kcrctab_unused");<BR>&nbsp;mod-&gt;unused_gpl_syms = section_objs(info, "__ksymtab_unused_gpl",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;unused_gpl_syms),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;mod-&gt;num_unused_gpl_syms);<BR>&nbsp;mod-&gt;unused_gpl_crcs = section_addr(info, "__kcrctab_unused_gpl");<BR>#endif<BR>#ifdef CONFIG_CONSTRUCTORS<BR>&nbsp;mod-&gt;ctors = section_objs(info, ".ctors",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;ctors), &amp;mod-&gt;num_ctors);<BR>&nbsp;if (!mod-&gt;ctors)<BR>&nbsp;&nbsp;mod-&gt;ctors = section_objs(info, ".init_array",<BR>&nbsp;&nbsp;&nbsp;&nbsp;sizeof(*mod-&gt;ctors), &amp;mod-&gt;num_ctors);<BR>&nbsp;else if (find_sec(info, ".init_array")) {<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * This shouldn't happen with same compiler and binutils<BR>&nbsp;&nbsp; * building all parts of the module.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;printk(KERN_WARNING "%s: has both .ctors and .init_array.\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name);<BR>&nbsp;&nbsp;return -EINVAL;<BR>&nbsp;}<BR>#endif</P>
<P>#ifdef CONFIG_TRACEPOINTS<BR>&nbsp;mod-&gt;tracepoints_ptrs = section_objs(info, "__tracepoints_ptrs",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;tracepoints_ptrs),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;mod-&gt;num_tracepoints);<BR>#endif<BR>#ifdef HAVE_JUMP_LABEL<BR>&nbsp;mod-&gt;jump_entries = section_objs(info, "__jump_table",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(*mod-&gt;jump_entries),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;mod-&gt;num_jump_entries);<BR>#endif<BR>#ifdef CONFIG_EVENT_TRACING<BR>&nbsp;mod-&gt;trace_events = section_objs(info, "_ftrace_events",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;trace_events),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;mod-&gt;num_trace_events);<BR>#endif<BR>#ifdef CONFIG_TRACING<BR>&nbsp;mod-&gt;trace_bprintk_fmt_start = section_objs(info, "__trace_printk_fmt",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;trace_bprintk_fmt_start),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;mod-&gt;num_trace_bprintk_fmt);<BR>#endif<BR>#ifdef CONFIG_FTRACE_MCOUNT_RECORD<BR>&nbsp;/* sechdrs[0].sh_size is always zero */<BR>&nbsp;mod-&gt;ftrace_callsites = section_objs(info, "__mcount_loc",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;ftrace_callsites),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;mod-&gt;num_ftrace_callsites);<BR>#endif</P>
<P>&nbsp;mod-&gt;extable = section_objs(info, "__ex_table",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;extable), &amp;mod-&gt;num_exentries);</P>
<P>&nbsp;if (section_addr(info, "__obsparm"))<BR>&nbsp;&nbsp;printk(KERN_WARNING "%s: Ignoring obsolete parameters\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name);</P>
<P>&nbsp;info-&gt;debug = section_objs(info, "__verbose",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(*info-&gt;debug), &amp;info-&gt;num_debug);</P>
<P>&nbsp;return 0;<BR>}</P>
<P>static int move_module(struct module *mod, struct load_info *info)<BR>{<BR>&nbsp;int i;<BR>&nbsp;void *ptr;</P>
<P>&nbsp;/* Do the allocs. */<BR>&nbsp;ptr = module_alloc_update_bounds(mod-&gt;core_size);<BR>&nbsp;/*<BR>&nbsp; * The pointer to this block is stored in the module structure<BR>&nbsp; * which is inside the block. Just mark it as not being a<BR>&nbsp; * leak.<BR>&nbsp; */<BR>&nbsp;kmemleak_not_leak(ptr);<BR>&nbsp;if (!ptr)<BR>&nbsp;&nbsp;return -ENOMEM;</P>
<P>&nbsp;memset(ptr, 0, mod-&gt;core_size);<BR>&nbsp;mod-&gt;module_core = ptr;</P>
<P>&nbsp;if (mod-&gt;init_size) {<BR>&nbsp;&nbsp;ptr = module_alloc_update_bounds(mod-&gt;init_size);<BR>&nbsp;&nbsp;/*<BR>&nbsp;&nbsp; * The pointer to this block is stored in the module structure<BR>&nbsp;&nbsp; * which is inside the block. This block doesn't need to be<BR>&nbsp;&nbsp; * scanned as it contains data and code that will be freed<BR>&nbsp;&nbsp; * after the module is initialized.<BR>&nbsp;&nbsp; */<BR>&nbsp;&nbsp;kmemleak_ignore(ptr);<BR>&nbsp;&nbsp;if (!ptr) {<BR>&nbsp;&nbsp;&nbsp;module_free(mod, mod-&gt;module_core);<BR>&nbsp;&nbsp;&nbsp;return -ENOMEM;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;memset(ptr, 0, mod-&gt;init_size);<BR>&nbsp;&nbsp;mod-&gt;module_init = ptr;<BR>&nbsp;} else<BR>&nbsp;&nbsp;mod-&gt;module_init = NULL;</P>
<P>&nbsp;/* Transfer each section which specifies SHF_ALLOC */<BR>&nbsp;pr_debug("final section addresses:\n");<BR>&nbsp;for (i = 0; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<BR>&nbsp;&nbsp;void *dest;<BR>&nbsp;&nbsp;Elf_Shdr *shdr = &amp;info-&gt;sechdrs[i];</P>
<P>&nbsp;&nbsp;if (!(shdr-&gt;sh_flags &amp; SHF_ALLOC))<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;if (shdr-&gt;sh_entsize &amp; INIT_OFFSET_MASK)<BR>&nbsp;&nbsp;&nbsp;dest = mod-&gt;module_init<BR>&nbsp;&nbsp;&nbsp;&nbsp;+ (shdr-&gt;sh_entsize &amp; ~INIT_OFFSET_MASK);<BR>&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;dest = mod-&gt;module_core + shdr-&gt;sh_entsize;</P>
<P>&nbsp;&nbsp;if (shdr-&gt;sh_type != SHT_NOBITS)<BR>&nbsp;&nbsp;&nbsp;memcpy(dest, (void *)shdr-&gt;sh_addr, shdr-&gt;sh_size);<BR>&nbsp;&nbsp;/* Update sh_addr to point to copy in image. */<BR>&nbsp;&nbsp;shdr-&gt;sh_addr = (unsigned long)dest;<BR>&nbsp;&nbsp;pr_debug("\t0x%lx %s\n",<BR>&nbsp;&nbsp;&nbsp; (long)shdr-&gt;sh_addr, info-&gt;secstrings + shdr-&gt;sh_name);<BR>&nbsp;}</P>
<P>&nbsp;return 0;<BR>}</P>
<P>static int check_module_license_and_versions(struct module *mod)<BR>{<BR>&nbsp;/*<BR>&nbsp; * ndiswrapper is under GPL by itself, but loads proprietary modules.<BR>&nbsp; * Don't use add_taint_module(), as it would prevent ndiswrapper from<BR>&nbsp; * using GPL-only symbols it needs.<BR>&nbsp; */<BR>&nbsp;if (strcmp(mod-&gt;name, "ndiswrapper") == 0)<BR>&nbsp;&nbsp;add_taint(TAINT_PROPRIETARY_MODULE, LOCKDEP_NOW_UNRELIABLE);</P>
<P>&nbsp;/* driverloader was caught wrongly pretending to be under GPL */<BR>&nbsp;if (strcmp(mod-&gt;name, "driverloader") == 0)<BR>&nbsp;&nbsp;add_taint_module(mod, TAINT_PROPRIETARY_MODULE,<BR>&nbsp;&nbsp;&nbsp;&nbsp; LOCKDEP_NOW_UNRELIABLE);</P>
<P>&nbsp;/* lve claims to be GPL but upstream won't provide source */<BR>&nbsp;if (strcmp(mod-&gt;name, "lve") == 0)<BR>&nbsp;&nbsp;add_taint_module(mod, TAINT_PROPRIETARY_MODULE,<BR>&nbsp;&nbsp;&nbsp;&nbsp; LOCKDEP_NOW_UNRELIABLE);</P>
<P>#ifdef CONFIG_MODVERSIONS<BR>&nbsp;if ((mod-&gt;num_syms &amp;&amp; !mod-&gt;crcs)<BR>&nbsp;&nbsp;&nbsp;&nbsp; || (mod-&gt;num_gpl_syms &amp;&amp; !mod-&gt;gpl_crcs)<BR>&nbsp;&nbsp;&nbsp;&nbsp; || (mod-&gt;num_gpl_future_syms &amp;&amp; !mod-&gt;gpl_future_crcs)<BR>#ifdef CONFIG_UNUSED_SYMBOLS<BR>&nbsp;&nbsp;&nbsp;&nbsp; || (mod-&gt;num_unused_syms &amp;&amp; !mod-&gt;unused_crcs)<BR>&nbsp;&nbsp;&nbsp;&nbsp; || (mod-&gt;num_unused_gpl_syms &amp;&amp; !mod-&gt;unused_gpl_crcs)<BR>#endif<BR>&nbsp;&nbsp;) {<BR>&nbsp;&nbsp;return try_to_force_load(mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "no versions for exported symbols");<BR>&nbsp;}<BR>#endif<BR>&nbsp;return 0;<BR>}</P>
<P>static void flush_module_icache(const struct module *mod)<BR>{<BR>&nbsp;mm_segment_t old_fs;</P>
<P>&nbsp;/* flush the icache in correct context */<BR>&nbsp;old_fs = get_fs();<BR>&nbsp;set_fs(KERNEL_DS);</P>
<P>&nbsp;/*<BR>&nbsp; * Flush the instruction cache, since we've played with text.<BR>&nbsp; * Do it before processing of module parameters, so the module<BR>&nbsp; * can provide parameter accessor functions of its own.<BR>&nbsp; */<BR>&nbsp;if (mod-&gt;module_init)<BR>&nbsp;&nbsp;flush_icache_range((unsigned long)mod-&gt;module_init,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned long)mod-&gt;module_init<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + mod-&gt;init_size);<BR>&nbsp;flush_icache_range((unsigned long)mod-&gt;module_core,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned long)mod-&gt;module_core + mod-&gt;core_size);</P>
<P>&nbsp;set_fs(old_fs);<BR>}</P>
<P>int __weak module_frob_arch_sections(Elf_Ehdr *hdr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Elf_Shdr *sechdrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *secstrings,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module *mod)<BR>{<BR>&nbsp;return 0;<BR>}</P>
<P>static struct module *layout_and_allocate(struct load_info *info, int flags)<BR>{<BR>&nbsp;/* Module within temporary copy. */<BR>&nbsp;struct module *mod;<BR>&nbsp;int err;</P>
<P>&nbsp;mod = setup_load_info(info, flags);<BR>&nbsp;if (IS_ERR(mod))<BR>&nbsp;&nbsp;return mod;</P>
<P>&nbsp;err = check_modinfo(mod, info, flags);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;return ERR_PTR(err);</P>
<P>&nbsp;/* Allow arches to frob section contents and sizes.&nbsp; */<BR>&nbsp;err = module_frob_arch_sections(info-&gt;hdr, info-&gt;sechdrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info-&gt;secstrings, mod);<BR>&nbsp;if (err &lt; 0)<BR>&nbsp;&nbsp;return ERR_PTR(err);</P>
<P>&nbsp;/* We will do a special allocation for per-cpu sections later. */<BR>&nbsp;info-&gt;sechdrs[info-&gt;index.pcpu].sh_flags &amp;= ~(unsigned long)SHF_ALLOC;</P>
<P>&nbsp;/* Determine total sizes, and put offsets in sh_entsize.&nbsp; For now<BR>&nbsp;&nbsp;&nbsp; this is done generically; there doesn't appear to be any<BR>&nbsp;&nbsp;&nbsp; special cases for the architectures. */<BR>&nbsp;layout_sections(mod, info);<BR>&nbsp;layout_symtab(mod, info);</P>
<P>&nbsp;/* Allocate and move to the final place */<BR>&nbsp;err = move_module(mod, info);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;return ERR_PTR(err);</P>
<P>&nbsp;/* Module has been copied to its final place now: return it. */<BR>&nbsp;mod = (void *)info-&gt;sechdrs[info-&gt;index.mod].sh_addr;<BR>&nbsp;kmemleak_load_module(mod, info);<BR>&nbsp;return mod;<BR>}</P>
<P>static int alloc_module_percpu(struct module *mod, struct load_info *info)<BR>{<BR>&nbsp;Elf_Shdr *pcpusec = &amp;info-&gt;sechdrs[info-&gt;index.pcpu];<BR>&nbsp;if (!pcpusec-&gt;sh_size)<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;/* We have a special allocation for this section. */<BR>&nbsp;return percpu_modalloc(mod, pcpusec-&gt;sh_size, pcpusec-&gt;sh_addralign);<BR>}</P>
<P>/* mod is no longer valid after this! */<BR>static void module_deallocate(struct module *mod, struct load_info *info)<BR>{<BR>&nbsp;percpu_modfree(mod);<BR>&nbsp;module_free(mod, mod-&gt;module_init);<BR>&nbsp;module_free(mod, mod-&gt;module_core);<BR>}</P>
<P>int __weak module_finalize(const Elf_Ehdr *hdr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const Elf_Shdr *sechdrs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module *me)<BR>{<BR>&nbsp;return 0;<BR>}</P>
<P>static int post_relocation(struct module *mod, const struct load_info *info)<BR>{<BR>&nbsp;/* Sort exception table now relocations are done. */<BR>&nbsp;sort_extable(mod-&gt;extable, mod-&gt;extable + mod-&gt;num_exentries);</P>
<P>&nbsp;/* Copy relocated percpu area over. */<BR>&nbsp;percpu_modcopy(mod, (void *)info-&gt;sechdrs[info-&gt;index.pcpu].sh_addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info-&gt;sechdrs[info-&gt;index.pcpu].sh_size);</P>
<P>&nbsp;/* Setup kallsyms-specific fields. */<BR>&nbsp;add_kallsyms(mod, info);</P>
<P>&nbsp;/* Arch-specific module finalizing. */<BR>&nbsp;return module_finalize(info-&gt;hdr, info-&gt;sechdrs, mod);<BR>}</P>
<P>/* Is this module of this name done loading?&nbsp; No locks held. */<BR>static bool finished_loading(const char *name)<BR>{<BR>&nbsp;struct module *mod;<BR>&nbsp;bool ret;</P>
<P>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;mod = find_module_all(name, true);<BR>&nbsp;ret = !mod || mod-&gt;state == MODULE_STATE_LIVE<BR>&nbsp;&nbsp;|| mod-&gt;state == MODULE_STATE_GOING;<BR>&nbsp;mutex_unlock(&amp;module_mutex);</P>
<P>&nbsp;return ret;<BR>}</P>
<P>/* Call module constructors. */<BR>static void do_mod_ctors(struct module *mod)<BR>{<BR>#ifdef CONFIG_CONSTRUCTORS<BR>&nbsp;unsigned long i;</P>
<P>&nbsp;for (i = 0; i &lt; mod-&gt;num_ctors; i++)<BR>&nbsp;&nbsp;mod-&gt;ctors[i]();<BR>#endif<BR>}</P>
<P>/* This is where the real work happens */<BR>static int do_init_module(struct module *mod)<BR>{<BR>&nbsp;int ret = 0;</P>
<P>&nbsp;/*<BR>&nbsp; * We want to find out whether @mod uses async during init.&nbsp; Clear<BR>&nbsp; * PF_USED_ASYNC.&nbsp; async_schedule*() will set it.<BR>&nbsp; */<BR>&nbsp;current-&gt;flags &amp;= ~PF_USED_ASYNC;</P>
<P>&nbsp;blocking_notifier_call_chain(&amp;module_notify_list,<BR>&nbsp;&nbsp;&nbsp;MODULE_STATE_COMING, mod);</P>
<P>&nbsp;/* Set RO and NX regions for core */<BR>&nbsp;set_section_ro_nx(mod-&gt;module_core,<BR>&nbsp;&nbsp;&nbsp;&nbsp;mod-&gt;core_text_size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;mod-&gt;core_ro_size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;mod-&gt;core_size);</P>
<P>&nbsp;/* Set RO and NX regions for init */<BR>&nbsp;set_section_ro_nx(mod-&gt;module_init,<BR>&nbsp;&nbsp;&nbsp;&nbsp;mod-&gt;init_text_size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;mod-&gt;init_ro_size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;mod-&gt;init_size);</P>
<P>&nbsp;do_mod_ctors(mod);<BR>&nbsp;/* Start the module */<BR>&nbsp;if (mod-&gt;init != NULL)<BR>&nbsp;&nbsp;ret = do_one_initcall(mod-&gt;init);<BR>&nbsp;if (ret &lt; 0) {<BR>&nbsp;&nbsp;/* Init routine failed: abort.&nbsp; Try to protect us from<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buggy refcounters. */<BR>&nbsp;&nbsp;mod-&gt;state = MODULE_STATE_GOING;<BR>&nbsp;&nbsp;synchronize_sched();<BR>&nbsp;&nbsp;module_put(mod);<BR>&nbsp;&nbsp;blocking_notifier_call_chain(&amp;module_notify_list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MODULE_STATE_GOING, mod);<BR>&nbsp;&nbsp;free_module(mod);<BR>&nbsp;&nbsp;wake_up_all(&amp;module_wq);<BR>&nbsp;&nbsp;return ret;<BR>&nbsp;}<BR>&nbsp;if (ret &gt; 0) {<BR>&nbsp;&nbsp;printk(KERN_WARNING<BR>"%s: '%s'-&gt;init suspiciously returned %d, it should follow 0/-E convention\n"<BR>"%s: loading module anyway...\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __func__, mod-&gt;name, ret,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __func__);<BR>&nbsp;&nbsp;dump_stack();<BR>&nbsp;}</P>
<P>&nbsp;/* Now it's a first class citizen! */<BR>&nbsp;mod-&gt;state = MODULE_STATE_LIVE;<BR>&nbsp;blocking_notifier_call_chain(&amp;module_notify_list,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MODULE_STATE_LIVE, mod);</P>
<P>&nbsp;/*<BR>&nbsp; * We need to finish all async code before the module init sequence<BR>&nbsp; * is done.&nbsp; This has potential to deadlock.&nbsp; For example, a newly<BR>&nbsp; * detected block device can trigger request_module() of the<BR>&nbsp; * default iosched from async probing task.&nbsp; Once userland helper<BR>&nbsp; * reaches here, async_synchronize_full() will wait on the async<BR>&nbsp; * task waiting on request_module() and deadlock.<BR>&nbsp; *<BR>&nbsp; * This deadlock is avoided by perfomring async_synchronize_full()<BR>&nbsp; * iff module init queued any async jobs.&nbsp; This isn't a full<BR>&nbsp; * solution as it will deadlock the same if module loading from<BR>&nbsp; * async jobs nests more than once; however, due to the various<BR>&nbsp; * constraints, this hack seems to be the best option for now.<BR>&nbsp; * Please refer to the following thread for details.<BR>&nbsp; *<BR>&nbsp; * <A href="http://thread.gmane.org/gmane.linux.kernel/1420814">http://thread.gmane.org/gmane.linux.kernel/1420814</A><BR>&nbsp; */<BR>&nbsp;if (current-&gt;flags &amp; PF_USED_ASYNC)<BR>&nbsp;&nbsp;async_synchronize_full();</P>
<P>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;/* Drop initial reference. */<BR>&nbsp;module_put(mod);<BR>&nbsp;trim_init_extable(mod);<BR>#ifdef CONFIG_KALLSYMS<BR>&nbsp;mod-&gt;num_symtab = mod-&gt;core_num_syms;<BR>&nbsp;mod-&gt;symtab = mod-&gt;core_symtab;<BR>&nbsp;mod-&gt;strtab = mod-&gt;core_strtab;<BR>#endif<BR>&nbsp;unset_module_init_ro_nx(mod);<BR>&nbsp;module_free(mod, mod-&gt;module_init);<BR>&nbsp;mod-&gt;module_init = NULL;<BR>&nbsp;mod-&gt;init_size = 0;<BR>&nbsp;mod-&gt;init_ro_size = 0;<BR>&nbsp;mod-&gt;init_text_size = 0;<BR>&nbsp;mutex_unlock(&amp;module_mutex);<BR>&nbsp;wake_up_all(&amp;module_wq);</P>
<P>&nbsp;return 0;<BR>}</P>
<P>static int may_init_module(void)<BR>{<BR>&nbsp;if (!capable(CAP_SYS_MODULE) || modules_disabled)<BR>&nbsp;&nbsp;return -EPERM;</P>
<P>&nbsp;return 0;<BR>}</P>
<P>/*<BR>&nbsp;* We try to place it in the list now to make sure it's unique before<BR>&nbsp;* we dedicate too many resources.&nbsp; In particular, temporary percpu<BR>&nbsp;* memory exhaustion.<BR>&nbsp;*/<BR>static int add_unformed_module(struct module *mod)<BR>{<BR>&nbsp;int err;<BR>&nbsp;struct module *old;</P>
<P>&nbsp;mod-&gt;state = MODULE_STATE_UNFORMED;</P>
<P>again:<BR>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;if ((old = find_module_all(mod-&gt;name, true)) != NULL) {<BR>&nbsp;&nbsp;if (old-&gt;state == MODULE_STATE_COMING<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || old-&gt;state == MODULE_STATE_UNFORMED) {<BR>&nbsp;&nbsp;&nbsp;/* Wait in case it fails to load. */<BR>&nbsp;&nbsp;&nbsp;mutex_unlock(&amp;module_mutex);<BR>&nbsp;&nbsp;&nbsp;err = wait_event_interruptible(module_wq,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finished_loading(mod-&gt;name));<BR>&nbsp;&nbsp;&nbsp;if (err)<BR>&nbsp;&nbsp;&nbsp;&nbsp;goto out_unlocked;<BR>&nbsp;&nbsp;&nbsp;goto again;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;err = -EEXIST;<BR>&nbsp;&nbsp;goto out;<BR>&nbsp;}<BR>&nbsp;list_add_rcu(&amp;mod-&gt;list, &amp;modules);<BR>&nbsp;err = 0;</P>
<P>out:<BR>&nbsp;mutex_unlock(&amp;module_mutex);<BR>out_unlocked:<BR>&nbsp;return err;<BR>}</P>
<P>static int complete_formation(struct module *mod, struct load_info *info)<BR>{<BR>&nbsp;int err;</P>
<P>&nbsp;mutex_lock(&amp;module_mutex);</P>
<P>&nbsp;/* Find duplicate symbols (must be called under lock). */<BR>&nbsp;err = verify_export_symbols(mod);<BR>&nbsp;if (err &lt; 0)<BR>&nbsp;&nbsp;goto out;</P>
<P>&nbsp;/* This relies on module_mutex for list integrity. */<BR>&nbsp;module_bug_finalize(info-&gt;hdr, info-&gt;sechdrs, mod);</P>
<P>&nbsp;/* Mark state as coming so strong_try_module_get() ignores us,<BR>&nbsp; * but kallsyms etc. can see us. */<BR>&nbsp;mod-&gt;state = MODULE_STATE_COMING;</P>
<P>out:<BR>&nbsp;mutex_unlock(&amp;module_mutex);<BR>&nbsp;return err;<BR>}</P>
<P>/* Allocate and load the module: note that size of section 0 is always<BR>&nbsp;&nbsp; zero, and we rely on this for optional sections. */<BR>static int load_module(struct load_info *info, const char __user *uargs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int flags)<BR>{<BR>&nbsp;struct module *mod;<BR>&nbsp;long err;</P>
<P>&nbsp;err = module_sig_check(info);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;goto free_copy;</P>
<P>&nbsp;err = elf_header_check(info);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;goto free_copy;</P>
<P>&nbsp;/* Figure out module layout, and allocate all the memory. */<BR>&nbsp;mod = layout_and_allocate(info, flags);<BR>&nbsp;if (IS_ERR(mod)) {<BR>&nbsp;&nbsp;err = PTR_ERR(mod);<BR>&nbsp;&nbsp;goto free_copy;<BR>&nbsp;}</P>
<P>&nbsp;/* Reserve our place in the list. */<BR>&nbsp;err = add_unformed_module(mod);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;goto free_module;</P>
<P>#ifdef CONFIG_MODULE_SIG<BR>&nbsp;mod-&gt;sig_ok = info-&gt;sig_ok;<BR>&nbsp;if (!mod-&gt;sig_ok) {<BR>&nbsp;&nbsp;printk_once(KERN_NOTICE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%s: module verification failed: signature and/or"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " required key missing - tainting kernel\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name);<BR>&nbsp;&nbsp;add_taint_module(mod, TAINT_FORCED_MODULE, LOCKDEP_STILL_OK);<BR>&nbsp;}<BR>#endif</P>
<P>&nbsp;/* To avoid stressing percpu allocator, do this once we're unique. */<BR>&nbsp;err = alloc_module_percpu(mod, info);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;goto unlink_mod;</P>
<P>&nbsp;/* Now module is in final location, initialize linked lists, etc. */<BR>&nbsp;err = module_unload_init(mod);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;goto unlink_mod;</P>
<P>&nbsp;/* Now we've got everything in the final locations, we can<BR>&nbsp; * find optional sections. */<BR>&nbsp;err = find_module_sections(mod, info);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;goto free_unload;</P>
<P>&nbsp;err = check_module_license_and_versions(mod);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;goto free_unload;</P>
<P>&nbsp;/* Set up MODINFO_ATTR fields */<BR>&nbsp;setup_modinfo(mod, info);</P>
<P>&nbsp;/* Fix up syms, so that st_value is a pointer to location. */<BR>&nbsp;err = simplify_symbols(mod, info);<BR>&nbsp;if (err &lt; 0)<BR>&nbsp;&nbsp;goto free_modinfo;</P>
<P>&nbsp;err = apply_relocations(mod, info);<BR>&nbsp;if (err &lt; 0)<BR>&nbsp;&nbsp;goto free_modinfo;</P>
<P>&nbsp;err = post_relocation(mod, info);<BR>&nbsp;if (err &lt; 0)<BR>&nbsp;&nbsp;goto free_modinfo;</P>
<P>&nbsp;flush_module_icache(mod);</P>
<P>&nbsp;/* Now copy in args */<BR>&nbsp;mod-&gt;args = strndup_user(uargs, ~0UL &gt;&gt; 1);<BR>&nbsp;if (IS_ERR(mod-&gt;args)) {<BR>&nbsp;&nbsp;err = PTR_ERR(mod-&gt;args);<BR>&nbsp;&nbsp;goto free_arch_cleanup;<BR>&nbsp;}</P>
<P>&nbsp;dynamic_debug_setup(info-&gt;debug, info-&gt;num_debug);</P>
<P>&nbsp;/* Ftrace init must be called in the MODULE_STATE_UNFORMED state */<BR>&nbsp;ftrace_module_init(mod);</P>
<P>&nbsp;/* Finally it's fully formed, ready to start executing. */<BR>&nbsp;err = complete_formation(mod, info);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;goto ddebug_cleanup;</P>
<P>&nbsp;/* Module is ready to execute: parsing args may do that. */<BR>&nbsp;err = parse_args(mod-&gt;name, mod-&gt;args, mod-&gt;kp, mod-&gt;num_kp,<BR>&nbsp;&nbsp;&nbsp; -32768, 32767, &amp;ddebug_dyndbg_module_param_cb);<BR>&nbsp;if (err &lt; 0)<BR>&nbsp;&nbsp;goto bug_cleanup;</P>
<P>&nbsp;/* Link in to syfs. */<BR>&nbsp;err = mod_sysfs_setup(mod, info, mod-&gt;kp, mod-&gt;num_kp);<BR>&nbsp;if (err &lt; 0)<BR>&nbsp;&nbsp;goto bug_cleanup;</P>
<P>&nbsp;/* Get rid of temporary copy. */<BR>&nbsp;free_copy(info);</P>
<P>&nbsp;/* Done! */<BR>&nbsp;trace_module_load(mod);</P>
<P>&nbsp;return do_init_module(mod);</P>
<P>&nbsp;bug_cleanup:<BR>&nbsp;/* module_bug_cleanup needs module_mutex protection */<BR>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;module_bug_cleanup(mod);<BR>&nbsp;mutex_unlock(&amp;module_mutex);<BR>&nbsp;ddebug_cleanup:<BR>&nbsp;dynamic_debug_remove(info-&gt;debug);<BR>&nbsp;synchronize_sched();<BR>&nbsp;kfree(mod-&gt;args);<BR>&nbsp;free_arch_cleanup:<BR>&nbsp;module_arch_cleanup(mod);<BR>&nbsp;free_modinfo:<BR>&nbsp;free_modinfo(mod);<BR>&nbsp;free_unload:<BR>&nbsp;module_unload_free(mod);<BR>&nbsp;unlink_mod:<BR>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;/* Unlink carefully: kallsyms could be walking list. */<BR>&nbsp;list_del_rcu(&amp;mod-&gt;list);<BR>&nbsp;wake_up_all(&amp;module_wq);<BR>&nbsp;mutex_unlock(&amp;module_mutex);<BR>&nbsp;free_module:<BR>&nbsp;module_deallocate(mod, info);<BR>&nbsp;free_copy:<BR>&nbsp;free_copy(info);<BR>&nbsp;return err;<BR>}</P>
<P>SYSCALL_DEFINE3(init_module, void __user *, umod,<BR>&nbsp;&nbsp;unsigned long, len, const char __user *, uargs)<BR>{<BR>&nbsp;int err;<BR>&nbsp;struct load_info info = { };</P>
<P>&nbsp;err = may_init_module();<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;return err;</P>
<P>&nbsp;pr_debug("init_module: umod=%p, len=%lu, uargs=%p\n",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umod, len, uargs);</P>
<P>&nbsp;err = copy_module_from_user(umod, len, &amp;info);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;return err;</P>
<P>&nbsp;return load_module(&amp;info, uargs, 0);<BR>}</P>
<P>SYSCALL_DEFINE3(finit_module, int, fd, const char __user *, uargs, int, flags)<BR>{<BR>&nbsp;int err;<BR>&nbsp;struct load_info info = { };</P>
<P>&nbsp;err = may_init_module();<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;return err;</P>
<P>&nbsp;pr_debug("finit_module: fd=%d, uargs=%p, flags=%i\n", fd, uargs, flags);</P>
<P>&nbsp;if (flags &amp; ~(MODULE_INIT_IGNORE_MODVERSIONS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |MODULE_INIT_IGNORE_VERMAGIC))<BR>&nbsp;&nbsp;return -EINVAL;</P>
<P>&nbsp;err = copy_module_from_fd(fd, &amp;info);<BR>&nbsp;if (err)<BR>&nbsp;&nbsp;return err;</P>
<P>&nbsp;return load_module(&amp;info, uargs, flags);<BR>}</P>
<P>static inline int within(unsigned long addr, void *start, unsigned long size)<BR>{<BR>&nbsp;return ((void *)addr &gt;= start &amp;&amp; (void *)addr &lt; start + size);<BR>}</P>
<P>#ifdef CONFIG_KALLSYMS<BR>/*<BR>&nbsp;* This ignores the intensely annoying "mapping symbols" found<BR>&nbsp;* in ARM ELF files: $a, $t and $d.<BR>&nbsp;*/<BR>static inline int is_arm_mapping_symbol(const char *str)<BR>{<BR>&nbsp;return str[0] == '$' &amp;&amp; strchr("atd", str[1])<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; (str[2] == '\0' || str[2] == '.');<BR>}</P>
<P>static const char *get_ksymbol(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long *size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long *offset)<BR>{<BR>&nbsp;unsigned int i, best = 0;<BR>&nbsp;unsigned long nextval;</P>
<P>&nbsp;/* At worse, next value is at end of module */<BR>&nbsp;if (within_module_init(addr, mod))<BR>&nbsp;&nbsp;nextval = (unsigned long)mod-&gt;module_init+mod-&gt;init_text_size;<BR>&nbsp;else<BR>&nbsp;&nbsp;nextval = (unsigned long)mod-&gt;module_core+mod-&gt;core_text_size;</P>
<P>&nbsp;/* Scan for closest preceding symbol, and next symbol. (ELF<BR>&nbsp;&nbsp;&nbsp; starts real symbols at 1). */<BR>&nbsp;for (i = 1; i &lt; mod-&gt;num_symtab; i++) {<BR>&nbsp;&nbsp;if (mod-&gt;symtab[i].st_shndx == SHN_UNDEF)<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;/* We ignore unnamed symbols: they're uninformative<BR>&nbsp;&nbsp; * and inserted at a whim. */<BR>&nbsp;&nbsp;if (mod-&gt;symtab[i].st_value &lt;= addr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; mod-&gt;symtab[i].st_value &gt; mod-&gt;symtab[best].st_value<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; *(mod-&gt;strtab + mod-&gt;symtab[i].st_name) != '\0'<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !is_arm_mapping_symbol(mod-&gt;strtab + mod-&gt;symtab[i].st_name))<BR>&nbsp;&nbsp;&nbsp;best = i;<BR>&nbsp;&nbsp;if (mod-&gt;symtab[i].st_value &gt; addr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; mod-&gt;symtab[i].st_value &lt; nextval<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; *(mod-&gt;strtab + mod-&gt;symtab[i].st_name) != '\0'<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !is_arm_mapping_symbol(mod-&gt;strtab + mod-&gt;symtab[i].st_name))<BR>&nbsp;&nbsp;&nbsp;nextval = mod-&gt;symtab[i].st_value;<BR>&nbsp;}</P>
<P>&nbsp;if (!best)<BR>&nbsp;&nbsp;return NULL;</P>
<P>&nbsp;if (size)<BR>&nbsp;&nbsp;*size = nextval - mod-&gt;symtab[best].st_value;<BR>&nbsp;if (offset)<BR>&nbsp;&nbsp;*offset = addr - mod-&gt;symtab[best].st_value;<BR>&nbsp;return mod-&gt;strtab + mod-&gt;symtab[best].st_name;<BR>}</P>
<P>/* For kallsyms to ask for address resolution.&nbsp; NULL means not found.&nbsp; Careful<BR>&nbsp;* not to lock to avoid deadlock on oopses, simply disable preemption. */<BR>const char *module_address_lookup(unsigned long addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long *size,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long *offset,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char **modname,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *namebuf)<BR>{<BR>&nbsp;struct module *mod;<BR>&nbsp;const char *ret = NULL;</P>
<P>&nbsp;preempt_disable();<BR>&nbsp;list_for_each_entry_rcu(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;if (within_module_init(addr, mod) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; within_module_core(addr, mod)) {<BR>&nbsp;&nbsp;&nbsp;if (modname)<BR>&nbsp;&nbsp;&nbsp;&nbsp;*modname = mod-&gt;name;<BR>&nbsp;&nbsp;&nbsp;ret = get_ksymbol(mod, addr, size, offset);<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;/* Make a copy in here where it's safe */<BR>&nbsp;if (ret) {<BR>&nbsp;&nbsp;strncpy(namebuf, ret, KSYM_NAME_LEN - 1);<BR>&nbsp;&nbsp;ret = namebuf;<BR>&nbsp;}<BR>&nbsp;preempt_enable();<BR>&nbsp;return ret;<BR>}</P>
<P>int lookup_module_symbol_name(unsigned long addr, char *symname)<BR>{<BR>&nbsp;struct module *mod;</P>
<P>&nbsp;preempt_disable();<BR>&nbsp;list_for_each_entry_rcu(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;if (within_module_init(addr, mod) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; within_module_core(addr, mod)) {<BR>&nbsp;&nbsp;&nbsp;const char *sym;</P>
<P>&nbsp;&nbsp;&nbsp;sym = get_ksymbol(mod, addr, NULL, NULL);<BR>&nbsp;&nbsp;&nbsp;if (!sym)<BR>&nbsp;&nbsp;&nbsp;&nbsp;goto out;<BR>&nbsp;&nbsp;&nbsp;strlcpy(symname, sym, KSYM_NAME_LEN);<BR>&nbsp;&nbsp;&nbsp;preempt_enable();<BR>&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>out:<BR>&nbsp;preempt_enable();<BR>&nbsp;return -ERANGE;<BR>}</P>
<P>int lookup_module_symbol_attrs(unsigned long addr, unsigned long *size,<BR>&nbsp;&nbsp;&nbsp;unsigned long *offset, char *modname, char *name)<BR>{<BR>&nbsp;struct module *mod;</P>
<P>&nbsp;preempt_disable();<BR>&nbsp;list_for_each_entry_rcu(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;if (within_module_init(addr, mod) ||<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; within_module_core(addr, mod)) {<BR>&nbsp;&nbsp;&nbsp;const char *sym;</P>
<P>&nbsp;&nbsp;&nbsp;sym = get_ksymbol(mod, addr, size, offset);<BR>&nbsp;&nbsp;&nbsp;if (!sym)<BR>&nbsp;&nbsp;&nbsp;&nbsp;goto out;<BR>&nbsp;&nbsp;&nbsp;if (modname)<BR>&nbsp;&nbsp;&nbsp;&nbsp;strlcpy(modname, mod-&gt;name, MODULE_NAME_LEN);<BR>&nbsp;&nbsp;&nbsp;if (name)<BR>&nbsp;&nbsp;&nbsp;&nbsp;strlcpy(name, sym, KSYM_NAME_LEN);<BR>&nbsp;&nbsp;&nbsp;preempt_enable();<BR>&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>out:<BR>&nbsp;preempt_enable();<BR>&nbsp;return -ERANGE;<BR>}</P>
<P>int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,<BR>&nbsp;&nbsp;&nbsp;char *name, char *module_name, int *exported)<BR>{<BR>&nbsp;struct module *mod;</P>
<P>&nbsp;preempt_disable();<BR>&nbsp;list_for_each_entry_rcu(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;if (symnum &lt; mod-&gt;num_symtab) {<BR>&nbsp;&nbsp;&nbsp;*value = mod-&gt;symtab[symnum].st_value;<BR>&nbsp;&nbsp;&nbsp;*type = mod-&gt;symtab[symnum].st_info;<BR>&nbsp;&nbsp;&nbsp;strlcpy(name, mod-&gt;strtab + mod-&gt;symtab[symnum].st_name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;KSYM_NAME_LEN);<BR>&nbsp;&nbsp;&nbsp;strlcpy(module_name, mod-&gt;name, MODULE_NAME_LEN);<BR>&nbsp;&nbsp;&nbsp;*exported = is_exported(name, *value, mod);<BR>&nbsp;&nbsp;&nbsp;preempt_enable();<BR>&nbsp;&nbsp;&nbsp;return 0;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;symnum -= mod-&gt;num_symtab;<BR>&nbsp;}<BR>&nbsp;preempt_enable();<BR>&nbsp;return -ERANGE;<BR>}</P>
<P>static unsigned long mod_find_symname(struct module *mod, const char *name)<BR>{<BR>&nbsp;unsigned int i;</P>
<P>&nbsp;for (i = 0; i &lt; mod-&gt;num_symtab; i++)<BR>&nbsp;&nbsp;if (strcmp(name, mod-&gt;strtab+mod-&gt;symtab[i].st_name) == 0 &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;symtab[i].st_info != 'U')<BR>&nbsp;&nbsp;&nbsp;return mod-&gt;symtab[i].st_value;<BR>&nbsp;return 0;<BR>}</P>
<P>/* Look for this name: can be of form module:name. */<BR>unsigned long module_kallsyms_lookup_name(const char *name)<BR>{<BR>&nbsp;struct module *mod;<BR>&nbsp;char *colon;<BR>&nbsp;unsigned long ret = 0;</P>
<P>&nbsp;/* Don't lock: we're in enough trouble already. */<BR>&nbsp;preempt_disable();<BR>&nbsp;if ((colon = strchr(name, ':')) != NULL) {<BR>&nbsp;&nbsp;*colon = '\0';<BR>&nbsp;&nbsp;if ((mod = find_module(name)) != NULL)<BR>&nbsp;&nbsp;&nbsp;ret = mod_find_symname(mod, colon+1);<BR>&nbsp;&nbsp;*colon = ':';<BR>&nbsp;} else {<BR>&nbsp;&nbsp;list_for_each_entry_rcu(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;&nbsp;if ((ret = mod_find_symname(mod, name)) != 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;preempt_enable();<BR>&nbsp;return ret;<BR>}</P>
<P>int module_kallsyms_on_each_symbol(int (*fn)(void *, const char *,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct module *, unsigned long),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *data)<BR>{<BR>&nbsp;struct module *mod;<BR>&nbsp;unsigned int i;<BR>&nbsp;int ret;</P>
<P>&nbsp;list_for_each_entry(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;for (i = 0; i &lt; mod-&gt;num_symtab; i++) {<BR>&nbsp;&nbsp;&nbsp;ret = fn(data, mod-&gt;strtab + mod-&gt;symtab[i].st_name,<BR>&nbsp;&nbsp;&nbsp;&nbsp; mod, mod-&gt;symtab[i].st_value);<BR>&nbsp;&nbsp;&nbsp;if (ret != 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;return ret;<BR>&nbsp;&nbsp;}<BR>&nbsp;}<BR>&nbsp;return 0;<BR>}<BR>#endif /* CONFIG_KALLSYMS */</P>
<P>static char *module_flags(struct module *mod, char *buf)<BR>{<BR>&nbsp;int bx = 0;</P>
<P>&nbsp;BUG_ON(mod-&gt;state == MODULE_STATE_UNFORMED);<BR>&nbsp;if (mod-&gt;taints ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;state == MODULE_STATE_GOING ||<BR>&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;state == MODULE_STATE_COMING) {<BR>&nbsp;&nbsp;buf[bx++] = '(';<BR>&nbsp;&nbsp;bx += module_flags_taint(mod, buf + bx);<BR>&nbsp;&nbsp;/* Show a - for module-is-being-unloaded */<BR>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_GOING)<BR>&nbsp;&nbsp;&nbsp;buf[bx++] = '-';<BR>&nbsp;&nbsp;/* Show a + for module-is-being-loaded */<BR>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_COMING)<BR>&nbsp;&nbsp;&nbsp;buf[bx++] = '+';<BR>&nbsp;&nbsp;buf[bx++] = ')';<BR>&nbsp;}<BR>&nbsp;buf[bx] = '\0';</P>
<P>&nbsp;return buf;<BR>}</P>
<P>#ifdef CONFIG_PROC_FS<BR>/* Called by the /proc file system to return a list of modules. */<BR>static void *m_start(struct seq_file *m, loff_t *pos)<BR>{<BR>&nbsp;mutex_lock(&amp;module_mutex);<BR>&nbsp;return seq_list_start(&amp;modules, *pos);<BR>}</P>
<P>static void *m_next(struct seq_file *m, void *p, loff_t *pos)<BR>{<BR>&nbsp;return seq_list_next(p, &amp;modules, pos);<BR>}</P>
<P>static void m_stop(struct seq_file *m, void *p)<BR>{<BR>&nbsp;mutex_unlock(&amp;module_mutex);<BR>}</P>
<P>static int m_show(struct seq_file *m, void *p)<BR>{<BR>&nbsp;struct module *mod = list_entry(p, struct module, list);<BR>&nbsp;char buf[8];</P>
<P>&nbsp;/* We always ignore unformed modules. */<BR>&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;return 0;</P>
<P>&nbsp;seq_printf(m, "%s %u",<BR>&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name, mod-&gt;init_size + mod-&gt;core_size);<BR>&nbsp;print_unload_info(m, mod);</P>
<P>&nbsp;/* Informative for users. */<BR>&nbsp;seq_printf(m, " %s",<BR>&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;state == MODULE_STATE_GOING ? "Unloading":<BR>&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;state == MODULE_STATE_COMING ? "Loading":<BR>&nbsp;&nbsp;&nbsp;&nbsp; "Live");<BR>&nbsp;/* Used by oprofile and other similar tools. */<BR>&nbsp;seq_printf(m, " 0x%pK", mod-&gt;module_core);</P>
<P>&nbsp;/* Taints info */<BR>&nbsp;if (mod-&gt;taints)<BR>&nbsp;&nbsp;seq_printf(m, " %s", module_flags(mod, buf));</P>
<P>&nbsp;seq_printf(m, "\n");<BR>&nbsp;return 0;<BR>}</P>
<P>/* Format: modulename size refcount deps address</P>
<P>&nbsp;&nbsp; Where refcount is a number or -, and deps is a comma-separated list<BR>&nbsp;&nbsp; of depends or -.<BR>*/<BR>static const struct seq_operations modules_op = {<BR>&nbsp;.start&nbsp;= m_start,<BR>&nbsp;.next&nbsp;= m_next,<BR>&nbsp;.stop&nbsp;= m_stop,<BR>&nbsp;.show&nbsp;= m_show<BR>};</P>
<P>static int modules_open(struct inode *inode, struct file *file)<BR>{<BR>&nbsp;return seq_open(file, &amp;modules_op);<BR>}</P>
<P>static const struct file_operations proc_modules_operations = {<BR>&nbsp;.open&nbsp;&nbsp;= modules_open,<BR>&nbsp;.read&nbsp;&nbsp;= seq_read,<BR>&nbsp;.llseek&nbsp;&nbsp;= seq_lseek,<BR>&nbsp;.release&nbsp;= seq_release,<BR>};</P>
<P>static int __init proc_modules_init(void)<BR>{<BR>&nbsp;proc_create("modules", 0, NULL, &amp;proc_modules_operations);<BR>&nbsp;return 0;<BR>}<BR>module_init(proc_modules_init);<BR>#endif</P>
<P>/* Given an address, look for it in the module exception tables. */<BR>const struct exception_table_entry *search_module_extables(unsigned long addr)<BR>{<BR>&nbsp;const struct exception_table_entry *e = NULL;<BR>&nbsp;struct module *mod;</P>
<P>&nbsp;preempt_disable();<BR>&nbsp;list_for_each_entry_rcu(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;if (mod-&gt;num_exentries == 0)<BR>&nbsp;&nbsp;&nbsp;continue;</P>
<P>&nbsp;&nbsp;e = search_extable(mod-&gt;extable,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;extable + mod-&gt;num_exentries - 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addr);<BR>&nbsp;&nbsp;if (e)<BR>&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;}<BR>&nbsp;preempt_enable();</P>
<P>&nbsp;/* Now, if we found one, we are running inside it now, hence<BR>&nbsp;&nbsp;&nbsp; we cannot unload the module, hence no refcnt needed. */<BR>&nbsp;return e;<BR>}</P>
<P>/*<BR>&nbsp;* is_module_address - is this address inside a module?<BR>&nbsp;* @addr: the address to check.<BR>&nbsp;*<BR>&nbsp;* See is_module_text_address() if you simply want to see if the address<BR>&nbsp;* is code (not data).<BR>&nbsp;*/<BR>bool is_module_address(unsigned long addr)<BR>{<BR>&nbsp;bool ret;</P>
<P>&nbsp;preempt_disable();<BR>&nbsp;ret = __module_address(addr) != NULL;<BR>&nbsp;preempt_enable();</P>
<P>&nbsp;return ret;<BR>}</P>
<P>/*<BR>&nbsp;* __module_address - get the module which contains an address.<BR>&nbsp;* @addr: the address.<BR>&nbsp;*<BR>&nbsp;* Must be called with preempt disabled or module mutex held so that<BR>&nbsp;* module doesn't get freed during this.<BR>&nbsp;*/<BR>struct module *__module_address(unsigned long addr)<BR>{<BR>&nbsp;struct module *mod;</P>
<P>&nbsp;if (addr &lt; module_addr_min || addr &gt; module_addr_max)<BR>&nbsp;&nbsp;return NULL;</P>
<P>&nbsp;list_for_each_entry_rcu(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;if (within_module_core(addr, mod)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || within_module_init(addr, mod))<BR>&nbsp;&nbsp;&nbsp;return mod;<BR>&nbsp;}<BR>&nbsp;return NULL;<BR>}<BR>EXPORT_SYMBOL_GPL(__module_address);</P>
<P>/*<BR>&nbsp;* is_module_text_address - is this address inside module code?<BR>&nbsp;* @addr: the address to check.<BR>&nbsp;*<BR>&nbsp;* See is_module_address() if you simply want to see if the address is<BR>&nbsp;* anywhere in a module.&nbsp; See kernel_text_address() for testing if an<BR>&nbsp;* address corresponds to kernel or module code.<BR>&nbsp;*/<BR>bool is_module_text_address(unsigned long addr)<BR>{<BR>&nbsp;bool ret;</P>
<P>&nbsp;preempt_disable();<BR>&nbsp;ret = __module_text_address(addr) != NULL;<BR>&nbsp;preempt_enable();</P>
<P>&nbsp;return ret;<BR>}</P>
<P>/*<BR>&nbsp;* __module_text_address - get the module whose code contains an address.<BR>&nbsp;* @addr: the address.<BR>&nbsp;*<BR>&nbsp;* Must be called with preempt disabled or module mutex held so that<BR>&nbsp;* module doesn't get freed during this.<BR>&nbsp;*/<BR>struct module *__module_text_address(unsigned long addr)<BR>{<BR>&nbsp;struct module *mod = __module_address(addr);<BR>&nbsp;if (mod) {<BR>&nbsp;&nbsp;/* Make sure it's within the text section. */<BR>&nbsp;&nbsp;if (!within(addr, mod-&gt;module_init, mod-&gt;init_text_size)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; !within(addr, mod-&gt;module_core, mod-&gt;core_text_size))<BR>&nbsp;&nbsp;&nbsp;mod = NULL;<BR>&nbsp;}<BR>&nbsp;return mod;<BR>}<BR>EXPORT_SYMBOL_GPL(__module_text_address);</P>
<P>/* Don't grab lock, we're oopsing. */<BR>void print_modules(void)<BR>{<BR>&nbsp;struct module *mod;<BR>&nbsp;char buf[8];</P>
<P>&nbsp;printk(KERN_DEFAULT "Modules linked in:");<BR>&nbsp;/* Most callers should already have preempt disabled, but make sure */<BR>&nbsp;preempt_disable();<BR>&nbsp;list_for_each_entry_rcu(mod, &amp;modules, list) {<BR>&nbsp;&nbsp;if (mod-&gt;state == MODULE_STATE_UNFORMED)<BR>&nbsp;&nbsp;&nbsp;continue;<BR>&nbsp;&nbsp;printk(" %s%s", mod-&gt;name, module_flags(mod, buf));<BR>&nbsp;}<BR>&nbsp;preempt_enable();<BR>&nbsp;if (last_unloaded_module[0])<BR>&nbsp;&nbsp;printk(" [last unloaded: %s]", last_unloaded_module);<BR>&nbsp;printk("\n");<BR>}</P>
<P>#ifdef CONFIG_MODVERSIONS<BR>/* Generate the signature for all relevant module structures here.<BR>&nbsp;* If these change, we don't want to try to parse the module. */<BR>void module_layout(struct module *mod,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct modversion_info *ver,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct kernel_param *kp,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct kernel_symbol *ks,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct tracepoint * const *tp)<BR>{<BR>}<BR>EXPORT_SYMBOL(module_layout);<BR>#endif