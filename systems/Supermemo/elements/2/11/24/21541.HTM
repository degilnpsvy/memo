<H1 class=SECT1><A name=COMPARISON-OPS></A>7.3. Other Comparison Operators</H1>
<P>A <I class=FIRSTTERM>binary</I> comparison operator compares two variables or quantities. <EM>Note that integer and string comparison use a different set of operators.</EM></P>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=ICOMPARISON1></A>integer comparison</B></P>
<DL>
<DT><A name=EQUALREF></A><SPAN class=TOKEN>-eq</SPAN> 
<DD>
<P>is equal to</P>
<P><TT class=USERINPUT><B>if [ "$a" -eq "$b" ]</B></TT></P>
<DT><A name=NEQUALREF></A><SPAN class=TOKEN>-ne</SPAN> 
<DD>
<P>is not equal to</P>
<P><TT class=USERINPUT><B>if [ "$a" -ne "$b" ]</B></TT></P>
<DT><A name=GT0REF></A><SPAN class=TOKEN>-gt</SPAN> 
<DD>
<P>is greater than</P>
<P><TT class=USERINPUT><B>if [ "$a" -gt "$b" ]</B></TT></P>
<DT><A name=GE0REF></A><SPAN class=TOKEN>-ge</SPAN> 
<DD>
<P>is greater than or equal to</P>
<P><TT class=USERINPUT><B>if [ "$a" -ge "$b" ]</B></TT></P>
<DT><A name=LT0REF></A><SPAN class=TOKEN>-lt</SPAN> 
<DD>
<P>is less than</P>
<P><TT class=USERINPUT><B>if [ "$a" -lt "$b" ]</B></TT></P>
<DT><A name=LE0REF></A><SPAN class=TOKEN>-le</SPAN> 
<DD>
<P>is less than or equal to</P>
<P><TT class=USERINPUT><B>if [ "$a" -le "$b" ]</B></TT></P>
<DT><A name=INTLT></A><SPAN class=TOKEN>&lt;</SPAN> 
<DD>
<P>is less than (within <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DBLPARENS">double parentheses</A>)</P>
<P><TT class=USERINPUT><B>(("$a" &lt; "$b"))</B></TT></P>
<DT><A name=LTEQ></A><SPAN class=TOKEN>&lt;=</SPAN> 
<DD>
<P>is less than or equal to (within double parentheses)</P>
<P><TT class=USERINPUT><B>(("$a" &lt;= "$b"))</B></TT></P>
<DT><A name=INTGT></A><SPAN class=TOKEN>&gt;</SPAN> 
<DD>
<P>is greater than (within double parentheses)</P>
<P><TT class=USERINPUT><B>(("$a" &gt; "$b"))</B></TT></P>
<DT><A name=GTEQ></A><SPAN class=TOKEN>&gt;=</SPAN> 
<DD>
<P>is greater than or equal to (within double parentheses)</P>
<P><TT class=USERINPUT><B>(("$a" &gt;= "$b"))</B></TT></P></DD></DL></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=SCOMPARISON1></A>string comparison</B></P>
<DL>
<DT><SPAN class=TOKEN>=</SPAN> 
<DD>
<P><A name=EQUALSIGNREF></A></P>
<P>is equal to</P>
<P><TT class=USERINPUT><B>if [ "$a" = "$b" ]</B></TT></P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>Note the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#WHITESPACEREF">whitespace</A> framing the <B class=COMMAND>=</B>.</P>
<P><TT class=USERINPUT><B>if [ "$a"="$b" ]</B></TT> is <EM>not</EM> equivalent to the above.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=SCOMPARISON2></A><SPAN class=TOKEN>==</SPAN> 
<DD>
<P>is equal to</P>
<P><TT class=USERINPUT><B>if [ "$a" == "$b" ]</B></TT></P>
<P>This is a synonym for <SPAN class=TOKEN>=</SPAN>.</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>The <SPAN class=TOKEN>==</SPAN> comparison operator behaves differently within a <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DBLBRACKETS">double-brackets</A> test than within single brackets. 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>[[ $a == z* ]]   # True if $a starts with an "z" (pattern matching).
[[ $a == "z*" ]] # True if $a is equal to z* (literal matching).

[ $a == z* ]     # File globbing and word splitting take place.
[ "$a" == "z*" ] # True if $a is equal to z* (literal matching).

# Thanks, St&#233;phane Chazelas</PRE></FONT></TD></TR></TBODY></TABLE></P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=NOTEQUAL></A><SPAN class=TOKEN>!=</SPAN> 
<DD>
<P>is not equal to</P>
<P><TT class=USERINPUT><B>if [ "$a" != "$b" ]</B></TT></P>
<P>This operator uses pattern matching within a <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DBLBRACKETS">[[ ... ]]</A> construct.</P>
<DT><A name=LTREF></A><SPAN class=TOKEN>&lt;</SPAN> 
<DD>
<P>is less than, in <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ASCIIDEF">ASCII</A> alphabetical order</P>
<P><TT class=USERINPUT><B>if [[ "$a" &lt; "$b" ]]</B></TT></P>
<P><TT class=USERINPUT><B>if [ "$a" \&lt; "$b" ]</B></TT></P>
<P>Note that the <SPAN class=QUOTE>"&lt;"</SPAN> needs to be <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ESCP">escaped</A> within a <TT class=USERINPUT><B>[ ]</B></TT> construct.</P>
<DT><A name=GTREF></A><SPAN class=TOKEN>&gt;</SPAN> 
<DD>
<P>is greater than, in ASCII alphabetical order</P>
<P><TT class=USERINPUT><B>if [[ "$a" &gt; "$b" ]]</B></TT></P>
<P><TT class=USERINPUT><B>if [ "$a" \&gt; "$b" ]</B></TT></P>
<P>Note that the <SPAN class=QUOTE>"&gt;"</SPAN> needs to be escaped within a <TT class=USERINPUT><B>[ ]</B></TT> construct.</P>
<P>See <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BUBBLE">Example 27-11</A> for an application of this comparison operator.</P>
<DT><A name=STRINGNULL></A><SPAN class=TOKEN>-z</SPAN> 
<DD>
<P>string is <I class=FIRSTTERM>null</I>, that is, has zero length</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING> String=''   # Zero-length ("null") string variable.

if [ -z "$String" ]
then
  echo "\$String is null."
else
  echo "\$String is NOT null."
fi     # $String is null.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=STRINGNOTNULL></A><SPAN class=TOKEN>-n</SPAN> 
<DD>
<P>string is not <I class=FIRSTTERM>null.</I></P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>The <TT class=USERINPUT><B>-n</B></TT> test requires that the string be quoted within the test brackets. Using an unquoted string with <I class=FIRSTTERM>! -z</I>, or even just the unquoted string alone within test brackets (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#STRTEST">Example 7-6</A>) normally works, however, this is an unsafe practice. <EM>Always</EM> quote a tested string. <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN3669" name=AEN3669><SPAN class=footnote>[37]</SPAN></A> </P></TD></TR></TBODY></TABLE></DIV></DD></DL></DIV>
<DIV class=EXAMPLE><A name=EX13></A>
<P><B>Example 7-5. Arithmetic and string comparisons</B></P>
<TABLE border=0 width="100%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

a=4
b=5

#  Here "a" and "b" can be treated either as integers or strings.
#  There is some blurring between the arithmetic and string comparisons,
#+ since Bash variables are not strongly typed.

#  Bash permits integer operations and comparisons on variables
#+ whose value consists of all-integer characters.
#  Caution advised, however.

echo

if [ "$a" -ne "$b" ]
then
  echo "$a is not equal to $b"
  echo "(arithmetic comparison)"
fi

echo

if [ "$a" != "$b" ]
then
  echo "$a is not equal to $b."
  echo "(string comparison)"
  #     "4"  != "5"
  # ASCII 52 != ASCII 53
fi

# In this particular instance, both "-ne" and "!=" work.

echo

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DIV class=EXAMPLE><A name=STRTEST></A>
<P><B>Example 7-6. Testing whether a string is <I class=FIRSTTERM>null</I></B></P>
<TABLE border=0 width="100%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
#  str-test.sh: Testing null strings and unquoted strings,
#+ but not strings and sealing wax, not to mention cabbages and kings . . .

# Using   if [ ... ]

# If a string has not been initialized, it has no defined value.
# This state is called "null" (not the same as zero!).

if [ -n $string1 ]    # string1 has not been declared or initialized.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # Wrong result.
# Shows $string1 as not null, although it was not initialized.

echo

# Let's try it again.

if [ -n "$string1" ]  # This time, $string1 is quoted.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # Quote strings within test brackets!

echo

if [ $string1 ]       # This time, $string1 stands naked.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # This works fine.
# The [ ... ] test operator alone detects whether the string is null.
# However it is good practice to quote it (if [ "$string1" ]).
#
# As Stephane Chazelas points out,
#    if [ $string1 ]    has one argument, "]"
#    if [ "$string1" ]  has two arguments, the empty "$string1" and "]" 


echo


string1=initialized

if [ $string1 ]       # Again, $string1 stands unquoted.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # Again, gives correct result.
# Still, it is better to quote it ("$string1"), because . . .


string1="a = b"

if [ $string1 ]       # Again, $string1 stands unquoted.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # Not quoting "$string1" now gives wrong result!

exit 0   # Thank you, also, Florian Wisser, for the "heads-up".</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DIV class=EXAMPLE><A name=EX14></A>
<P><B>Example 7-7. <I class=FIRSTTERM>zmore</I></B></P>
<TABLE border=0 width="100%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# zmore

# View gzipped files with 'more' filter.

E_NOARGS=85
E_NOTFOUND=86
E_NOTGZIP=87

if [ $# -eq 0 ] # same effect as:  if [ -z "$1" ]
# $1 can exist, but be empty:  zmore "" arg2 arg3
then
  echo "Usage: `basename $0` filename" &gt;&amp;2
  # Error message to stderr.
  exit $E_NOARGS
  # Returns 85 as exit status of script (error code).
fi  

filename=$1

if [ ! -f "$filename" ]   # Quoting $filename allows for possible spaces.
then
  echo "File $filename not found!" &gt;&amp;2   # Error message to stderr.
  exit $E_NOTFOUND
fi  

if [ ${filename##*.} != "gz" ]
# Using bracket in variable substitution.
then
  echo "File $1 is not a gzipped file!"
  exit $E_NOTGZIP
fi  

zcat $1 | more

# Uses the 'more' filter.
# May substitute 'less' if desired.

exit $?   # Script returns exit status of pipe.
#  Actually "exit $?" is unnecessary, as the script will, in any case,
#+ return the exit status of the last command executed.</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=CCOMPARISON1></A>compound comparison</B></P>
<DL>
<DT><A name=COMPOUNDAND></A><SPAN class=TOKEN>-a</SPAN> 
<DD>
<P>logical and</P>
<P><TT class=REPLACEABLE><I>exp1 -a exp2</I></TT> returns true if <EM>both</EM> exp1 and exp2 are true.</P>
<DT><A name=COMPOUNDOR></A><SPAN class=TOKEN>-o</SPAN> 
<DD>
<P>logical or </P>
<P><TT class=REPLACEABLE><I>exp1 -o exp2</I></TT> returns true if either exp1 <EM>or</EM> exp2 is true.</P></DD></DL></DIV>
<P>These are similar to the Bash comparison operators <B class=COMMAND>&amp;&amp;</B> and <B class=COMMAND>||</B>, used within <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DBLBRACKETS">double brackets</A>. 
<TABLE border=0 width="100%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>[[ condition1 &amp;&amp; condition2 ]]</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>The <B class=COMMAND>-o</B> and <B class=COMMAND>-a</B> operators work with the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#TTESTREF">test</A> command or occur within single test brackets. 
<TABLE border=0 width="100%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>if [ "$expr1" -a "$expr2" ]
then
  echo "Both expr1 and expr2 are true."
else
  echo "Either expr1 or expr2 is false."
fi</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="100%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>But, as <EM>rihad</EM> points out: 
<TABLE border=0 width="100%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>[ 1 -eq 1 ] &amp;&amp; [ -n "`echo true 1&gt;&amp;2`" ]   # true
[ 1 -eq 2 ] &amp;&amp; [ -n "`echo true 1&gt;&amp;2`" ]   # (no output)
# ^^^^^^^ False condition. So far, everything as expected.

# However ...
[ 1 -eq 2 -a -n "`echo true 1&gt;&amp;2`" ]       # true
# ^^^^^^^ False condition. So, why "true" output?

# Is it because both condition clauses within brackets evaluate?
[[ 1 -eq 2 &amp;&amp; -n "`echo true 1&gt;&amp;2`" ]]     # (no output)
# No, that's not it.

# Apparently &amp;&amp; and || "short-circuit" while -a and -o do not.</PRE></FONT></TD></TR></TBODY></TABLE></P></TD></TR></TBODY></TABLE></DIV>
<P>Refer to <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ANDOR">Example 8-3</A>, <A href="http://tldp.org/LDP/abs/html/abs-guide.html#TWODIM">Example 27-17</A>, and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#WHX">Example A-29</A> to see compound comparison operators in action.