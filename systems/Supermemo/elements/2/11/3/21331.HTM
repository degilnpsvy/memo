&nbsp;&nbsp;&nbsp; dtc<BR>&nbsp;Create flattened device tree blob object suitable for linking<BR>&nbsp;into vmlinux. Device tree blobs linked into vmlinux are placed<BR>&nbsp;in an init section in the image. Platform code *must* copy the<BR>&nbsp;blob to non-init memory prior to calling unflatten_device_tree().</P>
<P>&nbsp;To use this command, simply add *.dtb into obj-y or targets, or make<BR>&nbsp;some other target depend on %.dtb</P>
<P>&nbsp;A central rule exists to create $(obj)/%.dtb from $(src)/%.dts;<BR>&nbsp;architecture Makefiles do no need to explicitly write out that rule.</P>
<P>&nbsp;Example:<BR>&nbsp;&nbsp;targets += $(dtb-y)<BR>&nbsp;&nbsp;clean-files += *.dtb<BR>&nbsp;&nbsp;DTC_FLAGS ?= -p 1024</P>
<P>&nbsp;&nbsp;&nbsp; dtc_cpp<BR>&nbsp;This is just like dtc as describe above, except that the C pre-<BR>&nbsp;processor is invoked upon the .dtsp file before compiling the result<BR>&nbsp;with dtc.</P>
<P>&nbsp;In order for build dependencies to work, all files compiled using<BR>&nbsp;dtc_cpp must use the C pre-processor's #include functionality and not<BR>&nbsp;dtc's /include/ functionality.</P>
<P>&nbsp;Using the C pre-processor allows use of #define to create named<BR>&nbsp;constants. In turn, the #defines will typically appear in a header<BR>&nbsp;file, which may be shared with regular C code. Since the dtc language<BR>&nbsp;represents a data structure rather than code in C syntax, similar<BR>&nbsp;restrictions are placed on a header file included by a device tree<BR>&nbsp;file as for a header file included by an assembly language file.<BR>&nbsp;In particular, the C pre-processor is passed -x assembler-with-cpp,<BR>&nbsp;which sets macro __ASSEMBLY__. __DTS__ is also set. These allow header<BR>&nbsp;files to restrict their content to that compatible with device tree<BR>&nbsp;source.</P>
<P>&nbsp;A central rule exists to create $(obj)/%.dtb from $(src)/%.dtsp;<BR>&nbsp;architecture Makefiles do no need to explicitly write out that rule.