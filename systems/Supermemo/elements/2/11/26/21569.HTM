<H1><A name=INTERNAL></A>Chapter 15. Internal Commands and Builtins</H1>
<P><A name=BUILTINREF></A>A <I class=FIRSTTERM>builtin</I> is a <B class=COMMAND>command</B> contained within the Bash tool set, literally <I class=FIRSTTERM>built in</I>. This is either for performance reasons -- builtins execute faster than external commands, which usually require <I class=FIRSTTERM>forking off</I> <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN8607" name=AEN8607><SPAN class=footnote>[58]</SPAN></A> a separate process -- or because a particular builtin needs direct access to the shell internals.</P>
<P><A name=FORKREF></A></P>
<TABLE class=SIDEBAR border=1 cellPadding=5>
<TBODY>
<TR>
<TD>
<DIV class=SIDEBAR><A name=AEN8611></A>
<P></P>
<P><A name=PARENTREF></A>When a command or the shell itself initiates (or <I class=FIRSTTERM>spawns</I>) a new subprocess to carry out a task, this is called <I class=FIRSTTERM>forking</I>. This new process is the <I class=FIRSTTERM>child</I>, and the process that <I class=FIRSTTERM>forked</I> it off is the <I class=FIRSTTERM>parent</I>. While the <I class=FIRSTTERM>child process</I> is doing its work, the <I class=FIRSTTERM>parent process</I> is still executing.</P>
<P>Note that while a <I class=FIRSTTERM>parent process</I> gets the <I class=FIRSTTERM>process ID</I> of the <I class=FIRSTTERM>child process</I>, and can thus pass arguments to it, <EM>the reverse is not true</EM>. <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PARCHILDPROBREF">This can create problems that are subtle and hard to track down.</A></P>
<DIV class=EXAMPLE><A name=SPAWNSCR></A>
<P><B>Example 15-1. A script that spawns multiple instances of itself</B></P>
<TABLE border=0 width="100%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# spawn.sh


PIDS=$(pidof sh $0)  # Process IDs of the various instances of this script.
P_array=( $PIDS )    # Put them in an array (why?).
echo $PIDS           # Show process IDs of parent and child processes.
let "instances = ${#P_array[*]} - 1"  # Count elements, less 1.
                                      # Why subtract 1?
echo "$instances instance(s) of this script running."
echo "[Hit Ctl-C to exit.]"; echo


sleep 1              # Wait.
sh $0                # Play it again, Sam.

exit 0               # Not necessary; script will never get to here.
                     # Why not?

#  After exiting with a Ctl-C,
#+ do all the spawned instances of the script die?
#  If so, why?

# Note:
# ----
# Be careful not to run this script too long.
# It will eventually eat up too many system resources.

#  Is having a script spawn multiple instances of itself
#+ an advisable scripting technique.
#  Why or why not?</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P><A name=BLTINFRK></A></P>
<P>Generally, a Bash <I class=FIRSTTERM>builtin</I> does not fork a subprocess when it executes within a script. An external system command or filter in a script usually <EM>will</EM> fork a subprocess.</P>
<P></P></DIV></TD></TR></TBODY></TABLE>
<P>A builtin may be a synonym to a system command of the same name, but Bash reimplements it internally. For example, the Bash <B class=COMMAND>echo</B> command is not the same as <TT class=FILENAME>/bin/echo</TT>, although their behavior is almost identical. 
<TABLE border=0 width="100%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

echo "This line uses the \"echo\" builtin."
/bin/echo "This line uses the /bin/echo system command."</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P><A name=KEYWORDREF></A>A <I class=FIRSTTERM>keyword</I> is a <I class=FIRSTTERM>reserved</I> word, token or operator. Keywords have a special meaning to the shell, and indeed are the building blocks of the shell's syntax. As examples, <I class=FIRSTTERM>for</I>, <I class=FIRSTTERM>while</I>, <I class=FIRSTTERM>do</I>, and <I class=FIRSTTERM>!</I> are keywords. Similar to a <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BUILTINREF">builtin</A>, a keyword is hard-coded into Bash, but unlike a <I class=FIRSTTERM>builtin</I>, a keyword is not in itself a command, but <EM>a subunit of a command construct</EM>. <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN8650" name=AEN8650><SPAN class=footnote>[59]</SPAN></A> </P>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=INTIO1></A>I/O</B></P>
<DL>
<DT><A name=ECHOREF></A><B class=COMMAND>echo</B> 
<DD>
<P>prints (to <TT class=FILENAME>stdout</TT>) an expression or variable (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX9">Example 4-1</A>). 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>echo Hello
echo $a</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>An <B class=COMMAND>echo</B> requires the <TT class=OPTION>-e</TT> option to print escaped characters. See <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ESCAPED">Example 5-2</A>.</P>
<P>Normally, each <B class=COMMAND>echo</B> command prints a terminal newline, but the <TT class=OPTION>-n</TT> option suppresses this.</P>
<P><A name=ECHOGREPREF></A></P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>An <B class=COMMAND>echo</B> can be used to feed a sequence of commands down a pipe.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>if echo "$VAR" | grep -q txt   # if [[ $VAR = *txt* ]]
then
  echo "$VAR contains the substring sequence \"txt\""
fi</PRE></FONT></TD></TR></TBODY></TABLE></P></TD></TR></TBODY></TABLE></DIV>
<P><A name=ECHOCS></A></P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>An <B class=COMMAND>echo</B>, in combination with <A href="http://tldp.org/LDP/abs/html/abs-guide.html#COMMANDSUBREF">command substitution</A> can set a variable.</P>
<P><TT class=USERINPUT><B>a=`echo "HELLO" | tr A-Z a-z`</B></TT></P>
<P>See also <A href="http://tldp.org/LDP/abs/html/abs-guide.html#LOWERCASE">Example 16-22</A>, <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX57">Example 16-3</A>, <A href="http://tldp.org/LDP/abs/html/abs-guide.html#MONTHLYPMT">Example 16-47</A>, and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BASE">Example 16-48</A>.</P></TD></TR></TBODY></TABLE></DIV>
<P>Be aware that <B class=COMMAND>echo `command`</B> deletes any linefeeds that the output of <TT class=REPLACEABLE><I>command</I></TT> generates.</P>
<P>The <A href="http://tldp.org/LDP/abs/html/abs-guide.html#IFSREF">$IFS</A> (internal field separator) variable normally contains <SPAN class=TOKEN>\n</SPAN> (linefeed) as one of its set of <A href="http://tldp.org/LDP/abs/html/abs-guide.html#WHITESPACEREF">whitespace</A> characters. Bash therefore splits the output of <TT class=REPLACEABLE><I>command</I></TT> at linefeeds into arguments to <B class=COMMAND>echo</B>. Then <B class=COMMAND>echo</B> outputs these arguments, separated by spaces.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>ls -l /usr/share/apps/kjezz/sounds</B></TT>
<TT class=COMPUTEROUTPUT>-rw-r--r--    1 root     root         1407 Nov  7  2000 reflect.au
 -rw-r--r--    1 root     root          362 Nov  7  2000 seconds.au</TT>




<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo `ls -l /usr/share/apps/kjezz/sounds`</B></TT>
<TT class=COMPUTEROUTPUT>total 40 -rw-r--r-- 1 root root 716 Nov 7 2000 reflect.au -rw-r--r-- 1 root root ...</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>So, how can we embed a linefeed within an <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ECHOREF">echoed</A> character string? 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># Embedding a linefeed?
echo "Why doesn't this string \n split on two lines?"
# Doesn't split.

# Let's try something else.

echo
	     
echo $"A line of text containing
a linefeed."
# Prints as two distinct lines (embedded linefeed).
# But, is the "$" variable prefix really necessary?

echo

echo "This string splits
on two lines."
# No, the "$" is not needed.

echo
echo "---------------"
echo

echo -n $"Another line of text containing
a linefeed."
# Prints as two distinct lines (embedded linefeed).
# Even the -n option fails to suppress the linefeed here.

echo
echo
echo "---------------"
echo
echo

# However, the following doesn't work as expected.
# Why not? Hint: Assignment to a variable.
string1=$"Yet another line of text containing
a linefeed (maybe)."

echo $string1
# Yet another line of text containing a linefeed (maybe).
#                                    ^
# Linefeed becomes a space.

# Thanks, Steve Parker, for pointing this out.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P><A name=BINECHO></A></P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>This command is a shell builtin, and not the same as <TT class=FILENAME>/bin/echo</TT>, although its behavior is similar.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>type -a echo</B></TT>
<TT class=COMPUTEROUTPUT>echo is a shell builtin
 echo is /bin/echo</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=PRINTFREF></A><B class=COMMAND>printf</B> 
<DD>
<P>The <B class=COMMAND>printf</B>, formatted print, command is an enhanced <B class=COMMAND>echo</B>. It is a limited variant of the <I class=FIRSTTERM>C</I> language <TT class=FUNCTION>printf()</TT> library function, and its syntax is somewhat different.</P>
<P><B class=COMMAND>printf</B> <TT class=REPLACEABLE><I>format-string</I></TT>... <TT class=REPLACEABLE><I>parameter</I></TT>... </P>
<P>This is the Bash <I class=FIRSTTERM>builtin</I> version of the <TT class=FILENAME>/bin/printf</TT> or <TT class=FILENAME>/usr/bin/printf</TT> command. See the <B class=COMMAND>printf</B> <A href="http://tldp.org/LDP/abs/html/abs-guide.html#MANREF">manpage</A> (of the system command) for in-depth coverage.</P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>Older versions of Bash may not support <B class=COMMAND>printf</B>.</P></TD></TR></TBODY></TABLE></DIV>
<DIV class=EXAMPLE><A name=EX47></A>
<P><B>Example 15-2. <I class=FIRSTTERM>printf</I> in action</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# printf demo

declare -r PI=3.14159265358979     # Read-only variable, i.e., a constant.
declare -r DecimalConstant=31373

Message1="Greetings,"
Message2="Earthling."

echo

printf "Pi to 2 decimal places = %1.2f" $PI
echo
printf "Pi to 9 decimal places = %1.9f" $PI  # It even rounds off correctly.

printf "\n"                                  # Prints a line feed,
                                             # Equivalent to 'echo' . . .

printf "Constant = \t%d\n" $DecimalConstant  # Inserts tab (\t).

printf "%s %s \n" $Message1 $Message2

echo

# ==========================================#
# Simulation of C function, sprintf().
# Loading a variable with a formatted string.

echo 

Pi12=$(printf "%1.12f" $PI)
echo "Pi to 12 decimal places = $Pi12"      # Roundoff error!

Msg=`printf "%s %s \n" $Message1 $Message2`
echo $Msg; echo $Msg

#  As it happens, the 'sprintf' function can now be accessed
#+ as a loadable module to Bash,
#+ but this is not portable.

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>Formatting error messages is a useful application of <B class=COMMAND>printf</B></P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>E_BADDIR=85

var=nonexistent_directory

error()
{
  printf "$@" &gt;&amp;2
  # Formats positional params passed, and sends them to stderr.
  echo
  exit $E_BADDIR
}

cd $var || error $"Can't cd to %s." "$var"

# Thanks, S.C.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>See also <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PROGRESSBAR">Example 36-17</A>.</P>
<DT><A name=READREF></A><B class=COMMAND>read</B> 
<DD>
<P><SPAN class=QUOTE>"Reads"</SPAN> the value of a variable from <TT class=FILENAME>stdin</TT>, that is, interactively fetches input from the keyboard. The <TT class=OPTION>-a</TT> option lets <B class=COMMAND>read</B> get array variables (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX67">Example 27-6</A>).</P>
<DIV class=EXAMPLE><A name=EX36></A>
<P><B>Example 15-3. Variable assignment, using <I class=FIRSTTERM>read</I></B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# "Reading" variables.

echo -n "Enter the value of variable 'var1': "
# The -n option to echo suppresses newline.

read var1
# Note no '$' in front of var1, since it is being set.

echo "var1 = $var1"


echo

# A single 'read' statement can set multiple variables.
echo -n "Enter the values of variables 'var2' and 'var3' "
echo =n "(separated by a space or tab): "
read var2 var3
echo "var2 = $var2      var3 = $var3"
#  If you input only one value,
#+ the other variable(s) will remain unset (null).

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>A <B class=COMMAND>read</B> without an associated variable assigns its input to the dedicated variable <A href="http://tldp.org/LDP/abs/html/abs-guide.html#REPLYREF">$REPLY</A>.</P>
<DIV class=EXAMPLE><A name=READNOVAR></A>
<P><B>Example 15-4. What happens when <I class=FIRSTTERM>read</I> has no variable</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# read-novar.sh

echo

# -------------------------- #
echo -n "Enter a value: "
read var
echo "\"var\" = "$var""
# Everything as expected here.
# -------------------------- #

echo

# ------------------------------------------------------------------- #
echo -n "Enter another value: "
read           #  No variable supplied for 'read', therefore...
               #+ Input to 'read' assigned to default variable, $REPLY.
var="$REPLY"
echo "\"var\" = "$var""
# This is equivalent to the first code block.
# ------------------------------------------------------------------- #

echo
echo "========================="
echo


#  This example is similar to the "reply.sh" script.
#  However, this one shows that $REPLY is available
#+ even after a 'read' to a variable in the conventional way.


# ================================================================= #

#  In some instances, you might wish to discard the first value read.
#  In such cases, simply ignore the $REPLY variable.

{ # Code block.
read            # Line 1, to be discarded.
read line2      # Line 2, saved in variable.
  } &lt;$0
echo "Line 2 of this script is:"
echo "$line2"   #   # read-novar.sh
echo            #   #!/bin/bash  line discarded.

# See also the soundcard-on.sh script.

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>Normally, inputting a <TT class=USERINPUT><B>\</B></TT> suppresses a newline during input to a <B class=COMMAND>read</B>. The <TT class=OPTION>-r</TT> option causes an inputted <TT class=USERINPUT><B>\</B></TT> to be interpreted literally.</P>
<DIV class=EXAMPLE><A name=READR></A>
<P><B>Example 15-5. Multi-line input to <I class=FIRSTTERM>read</I></B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

echo

echo "Enter a string terminated by a \\, then press &lt;ENTER&gt;."
echo "Then, enter a second string (no \\ this time), and again press &lt;ENTER&gt;."

read var1     # The "\" suppresses the newline, when reading $var1.
              #     first line \
              #     second line

echo "var1 = $var1"
#     var1 = first line second line

#  For each line terminated by a "\"
#+ you get a prompt on the next line to continue feeding characters into var1.

echo; echo

echo "Enter another string terminated by a \\ , then press &lt;ENTER&gt;."
read -r var2  # The -r option causes the "\" to be read literally.
              #     first line \

echo "var2 = $var2"
#     var2 = first line \

# Data entry terminates with the first &lt;ENTER&gt;.

echo 

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P><A name=READOPTIONS></A></P>
<P>The <B class=COMMAND>read</B> command has some interesting options that permit echoing a prompt and even reading keystrokes without hitting <B class=KEYCAP>ENTER</B>.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># Read a keypress without hitting ENTER.

read -s -n1 -p "Hit a key " keypress
echo; echo "Keypress was "\"$keypress\""."

# -s option means do not echo input.
# -n N option means accept only N characters of input.
# -p option means echo the following prompt before reading input.

# Using these options is tricky, since they need to be in the correct order.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P><A name=READARROW></A></P>
<P>The <TT class=OPTION>-n</TT> option to <B class=COMMAND>read</B> also allows detection of the <B class=KEYCAP>arrow keys</B> and certain of the other unusual keys.</P>
<DIV class=EXAMPLE><A name=ARROWDETECT></A>
<P><B>Example 15-6. Detecting the arrow keys</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# arrow-detect.sh: Detects the arrow keys, and a few more.
# Thank you, Sandro Magi, for showing me how.

# --------------------------------------------
# Character codes generated by the keypresses.
arrowup='\[A'
arrowdown='\[B'
arrowrt='\[C'
arrowleft='\[D'
insert='\[2'
delete='\[3'
# --------------------------------------------

SUCCESS=0
OTHER=65

echo -n "Press a key...  "
# May need to also press ENTER if a key not listed above pressed.
read -n3 key                      # Read 3 characters.

echo -n "$key" | grep "$arrowup"  #Check if character code detected.
if [ "$?" -eq $SUCCESS ]
then
  echo "Up-arrow key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$arrowdown"
if [ "$?" -eq $SUCCESS ]
then
  echo "Down-arrow key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$arrowrt"
if [ "$?" -eq $SUCCESS ]
then
  echo "Right-arrow key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$arrowleft"
if [ "$?" -eq $SUCCESS ]
then
  echo "Left-arrow key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$insert"
if [ "$?" -eq $SUCCESS ]
then
  echo "\"Insert\" key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$delete"
if [ "$?" -eq $SUCCESS ]
then
  echo "\"Delete\" key pressed."
  exit $SUCCESS
fi


echo " Some other key pressed."

exit $OTHER

# ========================================= #

#  Mark Alexander came up with a simplified
#+ version of the above script (Thank you!).
#  It eliminates the need for grep.

#!/bin/bash

  uparrow=$'\x1b[A'
  downarrow=$'\x1b[B'
  leftarrow=$'\x1b[D'
  rightarrow=$'\x1b[C'

  read -s -n3 -p "Hit an arrow key: " x

  case "$x" in
  $uparrow)
     echo "You pressed up-arrow"
     ;;
  $downarrow)
     echo "You pressed down-arrow"
     ;;
  $leftarrow)
     echo "You pressed left-arrow"
     ;;
  $rightarrow)
     echo "You pressed right-arrow"
     ;;
  esac

exit $?

# ========================================= #

# Antonio Macchi has a simpler alternative.

#!/bin/bash

while true
do
  read -sn1 a
  test "$a" == `echo -en "\e"` || continue
  read -sn1 a
  test "$a" == "[" || continue
  read -sn1 a
  case "$a" in
    A)  echo "up";;
    B)  echo "down";;
    C)  echo "right";;
    D)  echo "left";;
  esac
done

# ========================================= #

#  Exercise:
#  --------
#  1) Add detection of the "Home," "End," "PgUp," and "PgDn" keys.</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>The <TT class=OPTION>-n</TT> option to <B class=COMMAND>read</B> will not detect the <B class=KEYCAP>ENTER</B> (newline) key.</P></TD></TR></TBODY></TABLE></DIV>
<P><A name=READTIMED></A></P>
<P>The <TT class=OPTION>-t</TT> option to <B class=COMMAND>read</B> permits timed input (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#TOUT">Example 9-4</A> and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#QKY">Example A-41</A>).</P>
<P><A name=READFD></A>The <TT class=OPTION>-u</TT> option takes the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FDREF">file descriptor</A> of the target file.</P>
<P><A name=READREDIR0></A></P>
<P>The <B class=COMMAND>read</B> command may also <SPAN class=QUOTE>"read"</SPAN> its variable value from a file <A href="http://tldp.org/LDP/abs/html/abs-guide.html#IOREDIRREF">redirected</A> to <TT class=FILENAME>stdin</TT>. If the file contains more than one line, only the first line is assigned to the variable. If <B class=COMMAND>read</B> has more than one parameter, then each of these variables gets assigned a successive <A href="http://tldp.org/LDP/abs/html/abs-guide.html#WHITESPACEREF">whitespace-delineated</A> string. Caution!</P>
<DIV class=EXAMPLE><A name=READREDIR></A>
<P><B>Example 15-7. Using <I class=FIRSTTERM>read</I> with <A href="http://tldp.org/LDP/abs/html/abs-guide.html#IOREDIRREF">file redirection</A></B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

read var1 &lt;data-file
echo "var1 = $var1"
# var1 set to the entire first line of the input file "data-file"

read var2 var3 &lt;data-file
echo "var2 = $var2   var3 = $var3"
# Note non-intuitive behavior of "read" here.
# 1) Rewinds back to the beginning of input file.
# 2) Each variable is now set to a corresponding string,
#    separated by whitespace, rather than to an entire line of text.
# 3) The final variable gets the remainder of the line.
# 4) If there are more variables to be set than whitespace-terminated strings
#    on the first line of the file, then the excess variables remain empty.

echo "------------------------------------------------"

# How to resolve the above problem with a loop:
while read line
do
  echo "$line"
done &lt;data-file
# Thanks, Heiner Steven for pointing this out.

echo "------------------------------------------------"

# Use $IFS (Internal Field Separator variable) to split a line of input to
# "read", if you do not want the default to be whitespace.

echo "List of all users:"
OIFS=$IFS; IFS=:       # /etc/passwd uses ":" for field separator.
while read name passwd uid gid fullname ignore
do
  echo "$name ($fullname)"
done &lt;/etc/passwd   # I/O redirection.
IFS=$OIFS              # Restore original $IFS.
# This code snippet also by Heiner Steven.



#  Setting the $IFS variable within the loop itself
#+ eliminates the need for storing the original $IFS
#+ in a temporary variable.
#  Thanks, Dim Segebart, for pointing this out.
echo "------------------------------------------------"
echo "List of all users:"

while IFS=: read name passwd uid gid fullname ignore
do
  echo "$name ($fullname)"
done &lt;/etc/passwd   # I/O redirection.

echo
echo "\$IFS still $IFS"

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P><A name=PIPEREADREF0></A></P>
<P><A href="http://tldp.org/LDP/abs/html/abs-guide.html#PIPEREF">Piping</A> output to a <I class=FIRSTTERM>read</I>, using <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ECHOREF">echo</A> to set variables <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BADREAD0">will fail</A>.</P>
<P><A name=READPIPEREF></A>Yet, piping the output of <A href="http://tldp.org/LDP/abs/html/abs-guide.html#CATREF">cat</A> <EM>seems</EM> to work.</P>
<P><A name=WHILEREADREF></A></P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>cat file1 file2 |
while read line
do
echo $line
done</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>However, as Bj&#246;n Eriksson shows:</P>
<DIV class=EXAMPLE><A name=READPIPE></A>
<P><B>Example 15-8. Problems reading from a pipe</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/sh
# readpipe.sh
# This example contributed by Bjon Eriksson.

### shopt -s lastpipe

last="(null)"
cat $0 |
while read line
do
    echo "{$line}"
    last=$line
done

echo
echo "++++++++++++++++++++++"
printf "\nAll done, last: $last\n" #  The output of this line
                                   #+ changes if you uncomment line 5.
                                   #  (Bash, version -ge 4.2 required.)

exit 0  # End of code.
        # (Partial) output of script follows.
        # The 'echo' supplies extra brackets.

#############################################

./readpipe.sh 

{#!/bin/sh}
{last="(null)"}
{cat $0 |}
{while read line}
{do}
{echo "{$line}"}
{last=$line}
{done}
{printf "nAll done, last: $lastn"}


All done, last: (null)

The variable (last) is set within the loop/subshell
but its value does not persist outside the loop.</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>The <I class=FIRSTTERM>gendiff</I> script, usually found in <TT class=FILENAME>/usr/bin</TT> on many Linux distros, pipes the output of <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FINDREF">find</A> to a <I class=FIRSTTERM>while read</I> construct. 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>find $1 \( -name "*$2" -o -name ".*$2" \) -print |
while read f; do
. . .</PRE></FONT></TD></TR></TBODY></TABLE></P></TD></TR></TBODY></TABLE></DIV>
<DIV class=TIP>
<P></P>
<TABLE class=TIP border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Tip src="http://tldp.org/LDP/abs/images/tip.gif"></TD>
<TD vAlign=top align=left>
<P>It is possible to <I class=FIRSTTERM>paste</I> text into the input field of a <I class=FIRSTTERM>read</I> (but <EM>not</EM> multiple lines!). See <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PADSW">Example A-38</A>.</P></TD></TR></TBODY></TABLE></DIV></DD></DL></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=INTFILESYSTEM1></A>Filesystem</B></P>
<DL>
<DT><A name=CDREF></A><B class=COMMAND>cd</B> 
<DD>
<P>The familiar <B class=COMMAND>cd</B> change directory command finds use in scripts where execution of a command requires being in a specified directory.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)</PRE></FONT></TD></TR></TBODY></TABLE>[from the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#COXEX">previously cited</A> example by Alan Cox]</P>
<P>The <TT class=OPTION>-P</TT> (physical) option to <B class=COMMAND>cd</B> causes it to ignore symbolic links.</P>
<P><B class=COMMAND>cd -</B> changes to <A href="http://tldp.org/LDP/abs/html/abs-guide.html#OLDPWD">$OLDPWD</A>, the previous working directory.</P>
<P><A name=DOUBLESLASHREF></A></P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>The <B class=COMMAND>cd</B> command does not function as expected when presented with two forward slashes. 
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>cd //</B></TT>
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>pwd</B></TT>
<TT class=COMPUTEROUTPUT>//</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE>The output should, of course, be <TT class=COMPUTEROUTPUT>/</TT>. This is a problem both from the command-line and in a script.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=PWD2REF></A><B class=COMMAND>pwd</B> 
<DD>
<P>Print Working Directory. This gives the user's (or script's) current directory (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX37">Example 15-9</A>). The effect is identical to reading the value of the builtin variable <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PWDREF">$PWD</A>.</P>
<DT><A name=DIRSD></A><B class=COMMAND>pushd</B>, <B class=COMMAND>popd</B>, <B class=COMMAND>dirs</B> 
<DD>
<P>This command set is a mechanism for bookmarking working directories, a means of moving back and forth through directories in an orderly manner. A pushdown <A href="http://tldp.org/LDP/abs/html/abs-guide.html#STACKDEFREF">stack</A> is used to keep track of directory names. Options allow various manipulations of the directory stack.</P>
<P><A name=PUSHDREF></A><TT class=USERINPUT><B>pushd dir-name</B></TT> pushes the path <TT class=REPLACEABLE><I>dir-name</I></TT> onto the directory stack (to the <I class=FIRSTTERM>top</I> of the stack) and simultaneously changes the current working directory to <TT class=REPLACEABLE><I>dir-name</I></TT></P>
<P><A name=POPDREF></A><B class=COMMAND>popd</B> removes (pops) the top directory path name off the directory stack and simultaneously changes the current working directory to the directory now at the <I class=FIRSTTERM>top</I> of the stack.</P>
<P><A name=DIRSREF></A><B class=COMMAND>dirs</B> lists the contents of the directory stack (compare this with the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DIRSTACKREF">$DIRSTACK</A> variable). A successful <B class=COMMAND>pushd</B> or <B class=COMMAND>popd</B> will automatically invoke <B class=COMMAND>dirs</B>.</P>
<P>Scripts that require various changes to the current working directory without hard-coding the directory name changes can make good use of these commands. Note that the implicit <TT class=VARNAME>$DIRSTACK</TT> array variable, accessible from within a script, holds the contents of the directory stack. </P>
<DIV class=EXAMPLE><A name=EX37></A>
<P><B>Example 15-9. Changing the current working directory</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

dir1=/usr/local
dir2=/var/spool

pushd $dir1
# Will do an automatic 'dirs' (list directory stack to stdout).
echo "Now in directory `pwd`." # Uses back-quoted 'pwd'.

# Now, do some stuff in directory 'dir1'.
pushd $dir2
echo "Now in directory `pwd`."

# Now, do some stuff in directory 'dir2'.
echo "The top entry in the DIRSTACK array is $DIRSTACK."
popd
echo "Now back in directory `pwd`."

# Now, do some more stuff in directory 'dir1'.
popd
echo "Now back in original working directory `pwd`."

exit 0

# What happens if you don't 'popd' -- then exit the script?
# Which directory do you end up in? Why?</PRE></FONT></TD></TR></TBODY></TABLE></DIV></DD></DL></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=INTVAR1></A>Variables</B></P>
<DL>
<DT><A name=LETREF></A><B class=COMMAND>let</B> 
<DD>
<P>The <B class=COMMAND>let</B> command carries out <I class=FIRSTTERM>arithmetic</I> operations on variables. <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN9009" name=AEN9009><SPAN class=footnote>[60]</SPAN></A> In many cases, it functions as a less complex version of <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EXPRREF">expr</A>.</P>
<DIV class=EXAMPLE><A name=EX46></A>
<P><B>Example 15-10. Letting <I class=FIRSTTERM>let</I> do arithmetic.</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

echo

let a=11            # Same as 'a=11'
let a=a+5           # Equivalent to  let "a = a + 5"
                    # (Double quotes and spaces make it more readable.)
echo "11 + 5 = $a"  # 16

let "a &lt;&lt;= 3"       # Equivalent to  let "a = a &lt;&lt; 3"
echo "\"\$a\" (=16) left-shifted 3 places = $a"
                    # 128

let "a /= 4"        # Equivalent to  let "a = a / 4"
echo "128 / 4 = $a" # 32

let "a -= 5"        # Equivalent to  let "a = a - 5"
echo "32 - 5 = $a"  # 27

let "a *=  10"      # Equivalent to  let "a = a * 10"
echo "27 * 10 = $a" # 270

let "a %= 8"        # Equivalent to  let "a = a % 8"
echo "270 modulo 8 = $a  (270 / 8 = 33, remainder $a)"
                    # 6


# Does "let" permit C-style operators?
# Yes, just as the (( ... )) double-parentheses construct does.

let a++             # C-style (post) increment.
echo "6++ = $a"     # 6++ = 7
let a--             # C-style decrement.
echo "7-- = $a"     # 7-- = 6
# Of course, ++a, etc., also allowed . . .
echo


# Trinary operator.

# Note that $a is 6, see above.
let "t = a&lt;7?7:11"   # True
echo $t  # 7

let a++
let "t = a&lt;7?7:11"   # False
echo $t  #     11

exit</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P><A name=EXITVALANOMALY02></A></P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>The <I class=FIRSTTERM>let</I> command can, in certain contexts, return a surprising <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EXITSTATUSREF">exit status</A>.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># Evgeniy Ivanov points out:

var=0
echo $?     # 0
            # As expected.

let var++
echo $?     # 1
            # The command was successful, so why isn't $?=0 ???
            # Anomaly!

let var++
echo $?     # 0
            # As expected.


# Likewise . . .

let var=0
echo $?     # 1
            # The command was successful, so why isn't $?=0 ???

#  However, as Jeff Gorak points out,
#+ this is part of the design spec for 'let' . . .
# "If the last ARG evaluates to 0, let returns 1;
#  let returns 0 otherwise." ['help let']</PRE></FONT></TD></TR></TBODY></TABLE></P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=EVALREF></A><B class=COMMAND>eval</B> 
<DD>
<P><TT class=USERINPUT><B>eval arg1 [arg2] ... [argN]</B></TT></P>
<P>Combines the arguments in an expression or list of expressions and <TT class=REPLACEABLE><I>evaluates</I></TT> them. Any variables within the expression are expanded. The net result is to <B class=COMMAND>convert a string into a command</B>.</P>
<DIV class=TIP>
<P></P>
<TABLE class=TIP border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Tip src="http://tldp.org/LDP/abs/images/tip.gif"></TD>
<TD vAlign=top align=left>
<P>The <B class=COMMAND>eval</B> command can be used for code generation from the command-line or within a script. </P></TD></TR></TBODY></TABLE></DIV>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>command_string="ps ax"</B></TT>
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>process="ps ax"</B></TT>
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>eval "$command_string" | grep "$process"</B></TT>
<TT class=COMPUTEROUTPUT>26973 pts/3    R+     0:00 grep --color ps ax
 26974 pts/3    R+     0:00 ps ax</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P><A name=EVALFORCED></A></P>
<P>Each invocation of <I class=FIRSTTERM>eval</I> forces a re-<EM>evaluation</EM> of its arguments. 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>a='$b'
b='$c'
c=d

echo $a             # $b
                    # First level.
eval echo $a        # $c
                    # Second level.
eval eval echo $a   # d
                    # Third level.

# Thank you, E. Choroba.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P><A name=EVALEFF></A></P>
<DIV class=EXAMPLE><A name=EX43></A>
<P><B>Example 15-11. Showing the effect of <I class=FIRSTTERM>eval</I></B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# Exercising "eval" ...

y=`eval ls -l`  #  Similar to y=`ls -l`
echo $y         #+ but linefeeds removed because "echoed" variable is unquoted.
echo
echo "$y"       #  Linefeeds preserved when variable is quoted.

echo; echo

y=`eval df`     #  Similar to y=`df`
echo $y         #+ but linefeeds removed.

#  When LF's not preserved, it may make it easier to parse output,
#+ using utilities such as "awk".

echo
echo "==========================================================="
echo

eval "`seq 3 | sed -e 's/.*/echo var&amp;=ABCDEFGHIJ/'`"
# var1=ABCDEFGHIJ
# var2=ABCDEFGHIJ
# var3=ABCDEFGHIJ

echo
echo "==========================================================="
echo


# Now, showing how to do something useful with "eval" . . .
# (Thank you, E. Choroba!)

version=3.4     #  Can we split the version into major and minor
                #+ part in one command?
echo "version = $version"
eval major=${version/./;minor=}     #  Replaces '.' in version by ';minor='
                                    #  The substitution yields '3; minor=4'
                                    #+ so eval does minor=4, major=3
echo Major: $major, minor: $minor   #  Major: 3, minor: 4</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P><A name=ARRCHOICE0></A></P>
<DIV class=EXAMPLE><A name=ARRCHOICE></A>
<P><B>Example 15-12. Using <I class=FIRSTTERM>eval</I> to select among variables</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# arr-choice.sh

#  Passing arguments to a function to select
#+ one particular variable out of a group.

arr0=( 10 11 12 13 14 15 )
arr1=( 20 21 22 23 24 25 )
arr2=( 30 31 32 33 34 35 )
#       0  1  2  3  4  5      Element number (zero-indexed)


choose_array ()
{
  eval array_member=\${arr${array_number}[element_number]}
  #                 ^       ^^^^^^^^^^^^
  #  Using eval to construct the name of a variable,
  #+ in this particular case, an array name.

  echo "Element $element_number of array $array_number is $array_member"
} #  Function can be rewritten to take parameters.

array_number=0    # First array.
element_number=3
choose_array      # 13

array_number=2    # Third array.
element_number=4
choose_array      # 34

array_number=3    # Null array (arr3 not allocated).
element_number=4
choose_array      # (null)

# Thank you, Antonio Macchi, for pointing this out.</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DIV class=EXAMPLE><A name=ECHOPARAMS></A>
<P><B>Example 15-13. <I class=FIRSTTERM>Echoing</I> the <I class=FIRSTTERM>command-line parameters</I></B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# echo-params.sh

# Call this script with a few command-line parameters.
# For example:
#     sh echo-params.sh first second third fourth fifth

params=$#              # Number of command-line parameters.
param=1                # Start at first command-line param.

while [ "$param" -le "$params" ]
do
  echo -n "Command-line parameter "
  echo -n \$$param     #  Gives only the *name* of variable.
#         ^^^          #  $1, $2, $3, etc.
                       #  Why?
                       #  \$ escapes the first "$"
                       #+ so it echoes literally,
                       #+ and $param dereferences "$param" . . .
                       #+ . . . as expected.
  echo -n " = "
  eval echo \$$param   #  Gives the *value* of variable.
# ^^^^      ^^^        #  The "eval" forces the *evaluation*
                       #+ of \$$
                       #+ as an indirect variable reference.

(( param ++ ))         # On to the next.
done

exit $?

# =================================================

$ sh echo-params.sh first second third fourth fifth
Command-line parameter $1 = first
Command-line parameter $2 = second
Command-line parameter $3 = third
Command-line parameter $4 = fourth
Command-line parameter $5 = fifth</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DIV class=EXAMPLE><A name=EX44></A>
<P><B>Example 15-14. Forcing a log-off</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# Killing ppp to force a log-off.
# For dialup connection, of course.

# Script should be run as root user.

SERPORT=ttyS3
#  Depending on the hardware and even the kernel version,
#+ the modem port on your machine may be different --
#+ /dev/ttyS1 or /dev/ttyS2.


killppp="eval kill -9 `ps ax | awk '/ppp/ { print $1 }'`"
#                     -------- process ID of ppp -------  

$killppp                     # This variable is now a command.


# The following operations must be done as root user.

chmod 666 /dev/$SERPORT      # Restore r+w permissions, or else what?
#  Since doing a SIGKILL on ppp changed the permissions on the serial port,
#+ we restore permissions to previous state.

rm /var/lock/LCK..$SERPORT   # Remove the serial port lock file. Why?

exit $?

# Exercises:
# ---------
# 1) Have script check whether root user is invoking it.
# 2) Do a check on whether the process to be killed
#+   is actually running before attempting to kill it.   
# 3) Write an alternate version of this script based on 'fuser':
#+      if [ fuser -s /dev/modem ]; then . . .</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DIV class=EXAMPLE><A name=ROT14></A>
<P><B>Example 15-15. A version of <I class=FIRSTTERM>rot13</I></B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# A version of "rot13" using 'eval'.
# Compare to "rot13.sh" example.

setvar_rot_13()              # "rot13" scrambling
{
  local varname=$1 varvalue=$2
  eval $varname='$(echo "$varvalue" | tr a-z n-za-m)'
}


setvar_rot_13 var "foobar"   # Run "foobar" through rot13.
echo $var                    # sbbone

setvar_rot_13 var "$var"     # Run "sbbone" through rot13.
                             # Back to original variable.
echo $var                    # foobar

# This example by Stephane Chazelas.
# Modified by document author.

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>Here is another example of using <I class=FIRSTTERM>eval</I> to <EM>evaluate</EM> a complex expression, this one from an earlier version of YongYe's <A href="https://github.com/yongye/shell/blob/master/Tetris_Game.sh" target=_top>Tetris game script</A>.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>eval ${1}+=\"${x} ${y} \"</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P><A href="http://tldp.org/LDP/abs/html/abs-guide.html#SAMORSE">Example A-53</A> uses <I class=FIRSTTERM>eval</I> to convert <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ARRAYREF">array</A> elements into a command list.</P>
<P>The <I class=FIRSTTERM>eval</I> command occurs in the older version of <A href="http://tldp.org/LDP/abs/html/abs-guide.html#IVRREF">indirect referencing</A>. 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>eval var=\$$var</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DIV class=TIP>
<P></P>
<TABLE class=TIP border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Tip src="http://tldp.org/LDP/abs/images/tip.gif"></TD>
<TD vAlign=top align=left>
<P>The <I class=FIRSTTERM>eval</I> command can be used to <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BRACEEXPREF3">parameterize <I class=FIRSTTERM>brace expansion</I></A>.</P></TD></TR></TBODY></TABLE></DIV>
<P><A name=EVALRISK></A></P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>The <B class=COMMAND>eval</B> command can be risky, and normally should be avoided when there exists a reasonable alternative. An <TT class=USERINPUT><B>eval $COMMANDS</B></TT> executes the contents of <TT class=REPLACEABLE><I>COMMANDS</I></TT>, which may contain such unpleasant surprises as <B class=COMMAND>rm -rf *</B>. Running an <B class=COMMAND>eval</B> on unfamiliar code written by persons unknown is living dangerously.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=SETREF></A><B class=COMMAND>set</B> 
<DD>
<P>The <B class=COMMAND>set</B> command changes the value of internal script variables/options. One use for this is to toggle <A href="http://tldp.org/LDP/abs/html/abs-guide.html#OPTIONSREF">option flags</A> which help determine the behavior of the script. Another application for it is to reset the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#POSPARAMREF">positional parameters</A> that a script sees as the result of a command (<TT class=USERINPUT><B>set `command`</B></TT>). The script can then parse the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FIELDREF">fields</A> of the command output.</P>
<DIV class=EXAMPLE><A name=EX34></A>
<P><B>Example 15-16. Using <I class=FIRSTTERM>set</I> with positional parameters</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# ex34.sh
# Script "set-test"

# Invoke this script with three command-line parameters,
# for example, "sh ex34.sh one two three".

echo
echo "Positional parameters before  set \`uname -a\` :"
echo "Command-line argument #1 = $1"
echo "Command-line argument #2 = $2"
echo "Command-line argument #3 = $3"


set `uname -a` # Sets the positional parameters to the output
               # of the command `uname -a`

echo
echo +++++
echo $_        # +++++
# Flags set in script.
echo $-        # hB
#                Anomalous behavior?
echo

echo "Positional parameters after  set \`uname -a\` :"
# $1, $2, $3, etc. reinitialized to result of `uname -a`
echo "Field #1 of 'uname -a' = $1"
echo "Field #2 of 'uname -a' = $2"
echo "Field #3 of 'uname -a' = $3"
echo \#\#\#
echo $_        # ###
echo

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>More fun with positional parameters.</P>
<DIV class=EXAMPLE><A name=REVPOSPARAMS></A>
<P><B>Example 15-17. Reversing the positional parameters</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# revposparams.sh: Reverse positional parameters.
# Script by Dan Jacobson, with stylistic revisions by document author.


set a\ b c d\ e;
#     ^      ^     Spaces escaped 
#       ^ ^        Spaces not escaped
OIFS=$IFS; IFS=:;
#              ^   Saving old IFS and setting new one.

echo

until [ $# -eq 0 ]
do          #      Step through positional parameters.
  echo "### k0 = "$k""     # Before
  k=$1:$k;  #      Append each pos param to loop variable.
#     ^
  echo "### k = "$k""      # After
  echo
  shift;
done

set $k  #  Set new positional parameters.
echo -
echo $# #  Count of positional parameters.
echo -
echo

for i   #  Omitting the "in list" sets the variable -- i --
        #+ to the positional parameters.
do
  echo $i  # Display new positional parameters.
done

IFS=$OIFS  # Restore IFS.

#  Question:
#  Is it necessary to set an new IFS, internal field separator,
#+ in order for this script to work properly?
#  What happens if you don't? Try it.
#  And, why use the new IFS -- a colon -- in line 17,
#+ to append to the loop variable?
#  What is the purpose of this?

exit 0

$ ./revposparams.sh

### k0 = 
### k = a b

### k0 = a b
### k = c a b

### k0 = c a b
### k = d e c a b

-
3
-

d e
c
a b</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>Invoking <B class=COMMAND>set</B> without any options or arguments simply lists all the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ENVREF">environmental</A> and other variables that have been initialized.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>set</B></TT>
<TT class=COMPUTEROUTPUT>AUTHORCOPY=/home/bozo/posts
 BASH=/bin/bash
 BASH_VERSION=$'2.05.8(1)-release'
 ...
 XAUTHORITY=/home/bozo/.Xauthority
 _=/etc/bashrc
 variable22=abc
 variable23=xzy</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>Using <B class=COMMAND>set</B> with the <TT class=OPTION>--</TT> option explicitly assigns the contents of a variable to the positional parameters. If no variable follows the <TT class=OPTION>--</TT> it <I class=FIRSTTERM>unsets</I> the positional parameters.</P>
<DIV class=EXAMPLE><A name=SETPOS></A>
<P><B>Example 15-18. Reassigning the positional parameters</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

variable="one two three four five"

set -- $variable
# Sets positional parameters to the contents of "$variable".

first_param=$1
second_param=$2
shift; shift        # Shift past first two positional params.
# shift 2             also works.
remaining_params="$*"

echo
echo "first parameter = $first_param"             # one
echo "second parameter = $second_param"           # two
echo "remaining parameters = $remaining_params"   # three four five

echo; echo

# Again.
set -- $variable
first_param=$1
second_param=$2
echo "first parameter = $first_param"             # one
echo "second parameter = $second_param"           # two

# ======================================================

set --
# Unsets positional parameters if no variable specified.

first_param=$1
second_param=$2
echo "first parameter = $first_param"             # (null value)
echo "second parameter = $second_param"           # (null value)

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>See also <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX22A">Example 11-2</A> and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX33A">Example 16-56</A>.</P>
<DT><A name=UNSETREF></A><B class=COMMAND>unset</B> 
<DD>
<P>The <B class=COMMAND>unset</B> command deletes a shell variable, effectively setting it to <I class=FIRSTTERM>null</I>. Note that this command does not affect positional parameters.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>unset PATH</B></TT>

<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $PATH</B></TT>
<TT class=COMPUTEROUTPUT>
</TT><TT class=PROMPT>bash$ </TT></PRE></FONT></TD></TR></TBODY></TABLE></P>
<DIV class=EXAMPLE><A name=UNS></A>
<P><B>Example 15-19. <SPAN class=QUOTE>"Unsetting"</SPAN> a variable</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# unset.sh: Unsetting a variable.

variable=hello                       #  Initialized.
echo "variable = $variable"

unset variable                       #  Unset.
                                     #  In this particular context,
                                     #+ same effect as:   variable=
echo "(unset) variable = $variable"  #  $variable is null.

if [ -z "$variable" ]                #  Try a string-length test.
then
  echo "\$variable has zero length."
fi

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>In most contexts, an <I class=FIRSTTERM>undeclared</I> variable and one that has been <I class=FIRSTTERM>unset</I> are equivalent. However, the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#UNDDR">${parameter:-default}</A> parameter substitution construct can distinguish between the two.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=EXPORTREF></A><B class=COMMAND>export</B> 
<DD>
<P><A name=EXPORTREF2></A></P>
<P>The <B class=COMMAND>export</B> <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN9199" name=AEN9199><SPAN class=footnote>[61]</SPAN></A> command makes available variables to all child processes of the running script or shell. One important use of the <B class=COMMAND>export</B> command is in <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FILESREF1">startup files</A>, to initialize and make accessible <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ENVREF">environmental variables</A> to subsequent user processes.</P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>Unfortunately, <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PARCHILDPROBREF">there is no way to export variables back to the parent process</A>, to the process that called or invoked the script or shell.</P></TD></TR></TBODY></TABLE></DIV>
<P><A name=EXPORTAWK></A></P>
<DIV class=EXAMPLE><A name=COLTOTALER3></A>
<P><B>Example 15-20. Using <I class=FIRSTTERM>export</I> to pass a variable to an embedded <I class=FIRSTTERM>awk</I> script</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

#  Yet another version of the "column totaler" script (col-totaler.sh)
#+ that adds up a specified column (of numbers) in the target file.
#  This uses the environment to pass a script variable to 'awk' . . .
#+ and places the awk script in a variable.


ARGS=2
E_WRONGARGS=85

if [ $# -ne "$ARGS" ] # Check for proper number of command-line args.
then
   echo "Usage: `basename $0` filename column-number"
   exit $E_WRONGARGS
fi

filename=$1
column_number=$2

#===== Same as original script, up to this point =====#

export column_number
# Export column number to environment, so it's available for retrieval.


# -----------------------------------------------
awkscript='{ total += $ENVIRON["column_number"] }
END { print total }'
# Yes, a variable can hold an awk script.
# -----------------------------------------------

# Now, run the awk script.
awk "$awkscript" "$filename"

# Thanks, Stephane Chazelas.

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DIV class=TIP>
<P></P>
<TABLE class=TIP border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Tip src="http://tldp.org/LDP/abs/images/tip.gif"></TD>
<TD vAlign=top align=left>
<P>It is possible to initialize and export variables in the same operation, as in <B class=COMMAND>export var1=xxx</B>.</P>
<P>However, as Greg Keraunen points out, in certain situations this may have a different effect than setting a variable, then exporting it.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>export var=(a b); echo ${var[0]}</B></TT>
<TT class=COMPUTEROUTPUT>(a b)</TT>



<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>var=(a b); export var; echo ${var[0]}</B></TT>
<TT class=COMPUTEROUTPUT>a</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P></TD></TR></TBODY></TABLE></DIV>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>A variable to be exported may require special treatment. See <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BASHPROF">Example M-2</A>.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=DECLARE2REF></A><B class=COMMAND>declare</B>, <B class=COMMAND>typeset</B> 
<DD>
<P>The <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DECLAREREF">declare</A> and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DECLAREREF">typeset</A> commands specify and/or restrict properties of variables.</P>
<DT><A name=READONLYREF></A><B class=COMMAND>readonly</B> 
<DD>
<P>Same as <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DECLAREREF">declare -r</A>, sets a variable as read-only, or, in effect, as a constant. Attempts to change the variable fail with an error message. This is the shell analog of the <I class=FIRSTTERM>C</I> language <B class=COMMAND>const</B> type qualifier.</P>
<DT><A name=GETOPTSX></A><B class=COMMAND>getopts</B> 
<DD>
<P>This powerful tool parses command-line arguments passed to the script. This is the Bash analog of the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#GETOPTY">getopt</A> external command and the <I class=FIRSTTERM>getopt</I> library function familiar to <I class=FIRSTTERM>C</I> programmers. It permits passing and concatenating multiple options <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN9289" name=AEN9289><SPAN class=footnote>[62]</SPAN></A> and associated arguments to a script (for example <TT class=USERINPUT><B>scriptname -abc -e /usr/local</B></TT>).</P>
<P><A name=GETOPTSOPT></A></P>
<P>The <B class=COMMAND>getopts</B> construct uses two implicit variables. <TT class=VARNAME>$OPTIND</TT> is the argument pointer (<I class=WORDASWORD>OPTion INDex</I>) and <TT class=VARNAME>$OPTARG</TT> (<I class=WORDASWORD>OPTion ARGument</I>) the (optional) argument attached to an option. A colon following the option name in the declaration tags that option as having an associated argument.</P>
<P>A <B class=COMMAND>getopts</B> construct usually comes packaged in a <A href="http://tldp.org/LDP/abs/html/abs-guide.html#WHILELOOPREF">while loop</A>, which processes the options and arguments one at a time, then increments the implicit <TT class=VARNAME>$OPTIND</TT> variable to point to the next.</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>
<P></P>
<OL type=1>
<LI>
<P>The arguments passed from the command-line to the script must be preceded by a dash (<TT class=OPTION>-</TT>). It is the prefixed <TT class=OPTION>-</TT> that lets <B class=COMMAND>getopts</B> recognize command-line arguments as <I class=FIRSTTERM>options</I>. In fact, <B class=COMMAND>getopts</B> will not process arguments without the prefixed <TT class=OPTION>-</TT>, and will terminate option processing at the first argument encountered lacking them.</P>
<LI>
<P>The <B class=COMMAND>getopts</B> template differs slightly from the standard <A href="http://tldp.org/LDP/abs/html/abs-guide.html#WHILELOOPREF">while loop</A>, in that it lacks condition brackets.</P>
<LI>
<P>The <B class=COMMAND>getopts</B> construct is a highly functional replacement for the traditional <A href="http://tldp.org/LDP/abs/html/abs-guide.html#GETOPTY">getopt</A> external command.</P></LI></OL>
<P></P></TD></TR></TBODY></TABLE></DIV>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>while getopts ":abcde:fg" Option
# Initial declaration.
# a, b, c, d, e, f, and g are the options (flags) expected.
# The : after option 'e' shows it will have an argument passed with it.
do
  case $Option in
    a ) # Do something with variable 'a'.
    b ) # Do something with variable 'b'.
    ...
    e)  # Do something with 'e', and also with $OPTARG,
        # which is the associated argument passed with option 'e'.
    ...
    g ) # Do something with variable 'g'.
  esac
done
shift $(($OPTIND - 1))
# Move argument pointer to next.

# All this is not nearly as complicated as it looks &lt;grin&gt;.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DIV class=EXAMPLE><A name=EX33></A>
<P><B>Example 15-21. Using <I class=FIRSTTERM>getopts</I> to read the options/arguments passed to a script</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# ex33.sh: Exercising getopts and OPTIND
#          Script modified 10/09/03 at the suggestion of Bill Gradwohl.


# Here we observe how 'getopts' processes command-line arguments to script.
# The arguments are parsed as "options" (flags) and associated arguments.

# Try invoking this script with:
#   'scriptname -mn'
#   'scriptname -oq qOption' (qOption can be some arbitrary string.)
#   'scriptname -qXXX -r'
#
#   'scriptname -qr'
#+      - Unexpected result, takes "r" as the argument to option "q"
#   'scriptname -q -r' 
#+      - Unexpected result, same as above
#   'scriptname -mnop -mnop'  - Unexpected result
#   (OPTIND is unreliable at stating where an option came from.)
#
#  If an option expects an argument ("flag:"), then it will grab
#+ whatever is next on the command-line.

NO_ARGS=0 
E_OPTERROR=85

if [ $# -eq "$NO_ARGS" ]    # Script invoked with no command-line args?
then
  echo "Usage: `basename $0` options (-mnopqrs)"
  exit $E_OPTERROR          # Exit and explain usage.
                            # Usage: scriptname -options
                            # Note: dash (-) necessary
fi  


while getopts ":mnopq:rs" Option
do
  case $Option in
    m     ) echo "Scenario #1: option -m-   [OPTIND=${OPTIND}]";;
    n | o ) echo "Scenario #2: option -$Option-   [OPTIND=${OPTIND}]";;
    p     ) echo "Scenario #3: option -p-   [OPTIND=${OPTIND}]";;
    q     ) echo "Scenario #4: option -q-\
                  with argument \"$OPTARG\"   [OPTIND=${OPTIND}]";;
    #  Note that option 'q' must have an associated argument,
    #+ otherwise it falls through to the default.
    r | s ) echo "Scenario #5: option -$Option-";;
    *     ) echo "Unimplemented option chosen.";;   # Default.
  esac
done

shift $(($OPTIND - 1))
#  Decrements the argument pointer so it points to next argument.
#  $1 now references the first non-option item supplied on the command-line
#+ if one exists.

exit $?

#   As Bill Gradwohl states,
#  "The getopts mechanism allows one to specify:  scriptname -mnop -mnop
#+  but there is no reliable way to differentiate what came
#+ from where by using OPTIND."
#  There are, however, workarounds.</PRE></FONT></TD></TR></TBODY></TABLE></DIV></DD></DL></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=INTSCRBEH1></A>Script Behavior</B></P>
<DL>
<DT><A name=SOURCEREF></A><B class=COMMAND>source</B>, <SPAN class=TOKEN>.</SPAN> (<A href="http://tldp.org/LDP/abs/html/abs-guide.html#DOTREF">dot</A> command) 
<DD>
<P>This command, when invoked from the command-line, executes a script. Within a script, a <TT class=USERINPUT><B>source file-name</B></TT> loads the file <TT class=FILENAME>file-name</TT>. <I class=FIRSTTERM>Sourcing</I> a file (dot-command) <I class=FIRSTTERM>imports</I> code into the script, appending to the script (same effect as the <TT class=USERINPUT><B>#include</B></TT> directive in a <I class=FIRSTTERM>C</I> program). The net result is the same as if the <SPAN class=QUOTE>"sourced"</SPAN> lines of code were physically present in the body of the script. This is useful in situations when multiple scripts use a common data file or function library.</P>
<DIV class=EXAMPLE><A name=EX38></A>
<P><B>Example 15-22. <SPAN class=QUOTE>"Including"</SPAN> a data file</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
#  Note that this example must be invoked with bash, i.e., bash ex38.sh
#+ not  sh ex38.sh !

. data-file    # Load a data file.
# Same effect as "source data-file", but more portable.

#  The file "data-file" must be present in current working directory,
#+ since it is referred to by its basename.

# Now, let's reference some data from that file.

echo "variable1 (from data-file) = $variable1"
echo "variable3 (from data-file) = $variable3"

let "sum = $variable2 + $variable4"
echo "Sum of variable2 + variable4 (from data-file) = $sum"
echo "message1 (from data-file) is \"$message1\""
#                                  Escaped quotes
echo "message2 (from data-file) is \"$message2\""

print_message This is the message-print function in the data-file.


exit $?</PRE></FONT></TD></TR></TBODY></TABLE>
<P>File <TT class=FILENAME>data-file</TT> for <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX38">Example 15-22</A>, above. Must be present in same directory.</P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># This is a data file loaded by a script.
# Files of this type may contain variables, functions, etc.
# It loads with a 'source' or '.' command from a shell script.

# Let's initialize some variables.

variable1=23
variable2=474
variable3=5
variable4=97

message1="Greetings from *** line $LINENO *** of the data file!"
message2="Enough for now. Goodbye."

print_message ()
{   # Echoes any message passed to it.

  if [ -z "$1" ]
  then
    return 1 # Error, if argument missing.
  fi

  echo

  until [ -z "$1" ]
  do             # Step through arguments passed to function.
    echo -n "$1" # Echo args one at a time, suppressing line feeds.
    echo -n " "  # Insert spaces between words.
    shift        # Next one.
  done  

  echo

  return 0
}</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>If the <I class=FIRSTTERM>sourced</I> file is itself an executable script, then it will run, then return control to the script that called it. A <I class=FIRSTTERM>sourced</I> executable script may use a <A href="http://tldp.org/LDP/abs/html/abs-guide.html#RETURNREF">return</A> for this purpose.</P>
<P><A name=SOURCEPARAMS></A></P>
<P>Arguments may be (optionally) passed to the <I class=FIRSTTERM>sourced</I> file as <A href="http://tldp.org/LDP/abs/html/abs-guide.html#POSPARAMREF1">positional parameters</A>. 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>source $filename $arg1 arg2</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>It is even possible for a script to <I class=FIRSTTERM>source</I> itself, though this does not seem to have any practical applications.</P>
<DIV class=EXAMPLE><A name=SELFSOURCE></A>
<P><B>Example 15-23. A (useless) script that sources itself</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# self-source.sh: a script sourcing itself "recursively."
# From "Stupid Script Tricks," Volume II.

MAXPASSCNT=100    # Maximum number of execution passes.

echo -n  "$pass_count  "
#  At first execution pass, this just echoes two blank spaces,
#+ since $pass_count still uninitialized.

let "pass_count += 1"
#  Assumes the uninitialized variable $pass_count
#+ can be incremented the first time around.
#  This works with Bash and pdksh, but
#+ it relies on non-portable (and possibly dangerous) behavior.
#  Better would be to initialize $pass_count to 0 before incrementing.

while [ "$pass_count" -le $MAXPASSCNT ]
do
  . $0   # Script "sources" itself, rather than calling itself.
         # ./$0 (which would be true recursion) doesn't work here. Why?
done  

#  What occurs here is not actually recursion,
#+ since the script effectively "expands" itself, i.e.,
#+ generates a new section of code
#+ with each pass through the 'while' loop',
#  with each 'source' in line 20.
#
#  Of course, the script interprets each newly 'sourced' "#!" line
#+ as a comment, and not as the start of a new script.

echo

exit 0   # The net effect is counting from 1 to 100.
         # Very impressive.

# Exercise:
# --------
# Write a script that uses this trick to actually do something useful.</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DT><A name=EXITREF></A><B class=COMMAND>exit</B> 
<DD>
<P>Unconditionally terminates a script. <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN9393" name=AEN9393><SPAN class=footnote>[63]</SPAN></A> The <B class=COMMAND>exit</B> command may optionally take an integer argument, which is returned to the shell as the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EXITSTATUSREF">exit status</A> of the script. It is good practice to end all but the simplest scripts with an <TT class=USERINPUT><B>exit 0</B></TT>, indicating a successful run.</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>If a script terminates with an <B class=COMMAND>exit</B> lacking an argument, the exit status of the script is the exit status of the last command executed in the script, not counting the <B class=COMMAND>exit</B>. This is equivalent to an <B class=COMMAND>exit $?</B>.</P></TD></TR></TBODY></TABLE></DIV>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>An <B class=COMMAND>exit</B> command may also be used to terminate a <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SUBSHELLSREF">subshell</A>.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=EXECREF></A><B class=COMMAND>exec</B> 
<DD>
<P>This shell builtin replaces the current process with a specified command. Normally, when the shell encounters a command, it <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FORKREF">forks off</A> a child process to actually execute the command. Using the <B class=COMMAND>exec</B> builtin, the shell does not fork, and the command <I class=FIRSTTERM>exec</I>'ed replaces the shell. When used in a script, therefore, it forces an exit from the script when the <B class=COMMAND>exec</B>'ed command terminates. <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN9425" name=AEN9425><SPAN class=footnote>[64]</SPAN></A> </P>
<DIV class=EXAMPLE><A name=EX54></A>
<P><B>Example 15-24. Effects of <I class=FIRSTTERM>exec</I></B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

exec echo "Exiting \"$0\" at line $LINENO."   # Exit from script here.
# $LINENO is an internal Bash variable set to the line number it's on.

# ----------------------------------
# The following lines never execute.

echo "This echo fails to echo."

exit 99                       #  This script will not exit here.
                              #  Check exit value after script terminates
                              #+ with an 'echo $?'.
                              #  It will *not* be 99.</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DIV class=EXAMPLE><A name=SELFEXEC></A>
<P><B>Example 15-25. A script that <I class=FIRSTTERM>exec's</I> itself</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# self-exec.sh

# Note: Set permissions on this script to 555 or 755,
#       then call it with ./self-exec.sh or sh ./self-exec.sh.

echo

echo "This line appears ONCE in the script, yet it keeps echoing."
echo "The PID of this instance of the script is still $$."
#     Demonstrates that a subshell is not forked off.

echo "==================== Hit Ctl-C to exit ===================="

sleep 1

exec $0   #  Spawns another instance of this same script
          #+ that replaces the previous one.

echo "This line will never echo!"  # Why not?

exit 99                            # Will not exit here!
                                   # Exit code will not be 99!</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>An <B class=COMMAND>exec</B> also serves to <A href="http://tldp.org/LDP/abs/html/abs-guide.html#USINGEXECREF">reassign file descriptors</A>. For example, <TT class=USERINPUT><B>exec &lt;zzz-file</B></TT> replaces <TT class=FILENAME>stdin</TT> with the file <TT class=FILENAME>zzz-file</TT>.</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>The <TT class=OPTION>-exec</TT> option to <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FINDREF">find</A> is <TT class=REPLACEABLE><I>not</I></TT> the same as the <B class=COMMAND>exec</B> shell builtin.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=SHOPTREF></A><B class=COMMAND>shopt</B> 
<DD>
<P>This command permits changing <I class=FIRSTTERM>shell options</I> on the fly (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#AL">Example 25-1</A> and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#UNAL">Example 25-2</A>). It often appears in the Bash <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FILESREF1">startup files</A>, but also has its uses in scripts. Needs <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BASH2REF">version 2</A> or later of Bash.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>shopt -s cdspell
# Allows minor misspelling of directory names with 'cd'
# Option -s sets, -u unsets.

cd /hpme  # Oops! Mistyped '/home'.
pwd       # /home
          # The shell corrected the misspelling.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><B class=COMMAND>caller</B><A name=CALLERREF></A> 
<DD>
<P>Putting a <B class=COMMAND>caller</B> command inside a <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FUNCTIONREF">function</A> echoes to <TT class=FILENAME>stdout</TT> information about the <I class=FIRSTTERM>caller</I> of that function.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

function1 ()
{
  # Inside function1 ().
  caller 0   # Tell me about it.
}

function1    # Line 9 of script.

# 9 main test.sh
# ^                 Line number that the function was called from.
#   ^^^^            Invoked from "main" part of script.
#        ^^^^^^^    Name of calling script.

caller 0     # Has no effect because it's not inside a function.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>A <B class=COMMAND>caller</B> command can also return <I class=FIRSTTERM>caller</I> information from a script <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SOURCEREF">sourced</A> within another script. Analogous to a function, this is a <SPAN class=QUOTE>"subroutine call."</SPAN></P>
<P>You may find this command useful in debugging.</P></DD></DL></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=INTCOMMAND1></A>Commands</B></P>
<DL>
<DT><A name=TRUEREF></A><B class=COMMAND>true</B> 
<DD>
<P>A command that returns a successful (<SPAN class=RETURNVALUE>zero</SPAN>) <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EXITSTATUSREF">exit status</A>, but does nothing else. </P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>true</B></TT>
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $?</B></TT>
<TT class=COMPUTEROUTPUT>0</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># Endless loop
while true   # alias for ":"
do
   operation-1
   operation-2
   ...
   operation-n
   # Need a way to break out of loop or script will hang.
done</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=FALSEREF></A><B class=COMMAND>false</B> 
<DD>
<P>A command that returns an unsuccessful <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EXITSTATUSREF">exit status</A>, but does nothing else.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>false</B></TT>
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $?</B></TT>
<TT class=COMPUTEROUTPUT>1</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># Testing "false" 
if false
then
  echo "false evaluates \"true\""
else
  echo "false evaluates \"false\""
fi
# false evaluates "false"


# Looping while "false" (null loop)
while false
do
   # The following code will not execute.
   operation-1
   operation-2
   ...
   operation-n
   # Nothing happens!
done   </PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=TYPEREF></A><B class=COMMAND>type [cmd]</B> 
<DD>
<P>Similar to the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#WHICHREF">which</A> external command, <B class=COMMAND>type cmd</B> identifies <SPAN class=QUOTE>"cmd."</SPAN> Unlike <B class=COMMAND>which</B>, <B class=COMMAND>type</B> is a Bash builtin. The useful <TT class=OPTION>-a</TT> option to <B class=COMMAND>type</B> identifies <TT class=REPLACEABLE><I>keywords</I></TT> and <TT class=REPLACEABLE><I>builtins</I></TT>, and also locates system commands with identical names.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>type '['</B></TT>
<TT class=COMPUTEROUTPUT>[ is a shell builtin</TT>
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>type -a '['</B></TT>
<TT class=COMPUTEROUTPUT>[ is a shell builtin
 [ is /usr/bin/[</TT>


<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>type type</B></TT>
<TT class=COMPUTEROUTPUT>type is a shell builtin</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>The <B class=COMMAND>type</B> command can be useful for <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DEVNULLREDIRECT">testing whether a certain command exists</A>.</P>
<DT><A name=HASHCMDREF></A><B class=COMMAND>hash [cmds]</B> 
<DD>
<P>Records the <I class=FIRSTTERM>path</I> name of specified commands -- in the shell <I class=FIRSTTERM>hash table</I> <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN9591" name=AEN9591><SPAN class=footnote>[65]</SPAN></A> -- so the shell or script will not need to search the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PATHREF">$PATH</A> on subsequent calls to those commands. When <B class=COMMAND>hash</B> is called with no arguments, it simply lists the commands that have been hashed. The <TT class=OPTION>-r</TT> option resets the hash table.</P>
<DT><A name=BINDREF></A><B class=COMMAND>bind</B> 
<DD>
<P>The <B class=COMMAND>bind</B> builtin displays or modifies <I class=FIRSTTERM>readline</I> <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN9621" name=AEN9621><SPAN class=footnote>[66]</SPAN></A> key bindings.</P>
<DT><A name=HELPREF></A><B class=COMMAND>help</B> 
<DD>
<P>Gets a short usage summary of a shell builtin. This is the counterpart to <A href="http://tldp.org/LDP/abs/html/abs-guide.html#WHATISREF">whatis</A>, but for builtins. The display of <I class=FIRSTTERM>help</I> information got a much-needed update in the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BASH4REF">version 4 release</A> of Bash.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>help exit</B></TT>
<TT class=COMPUTEROUTPUT>exit: exit [n]
    Exit the shell with a status of N.  If N is omitted, the exit status
    is that of the last command executed.</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P></DD></DL></DIV>