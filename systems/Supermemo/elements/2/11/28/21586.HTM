# The ``scripts/Makefile.build'' 
<P></P>
<P># ==========================================================================<BR># Building<BR># ==========================================================================</P>
<P></P>
<P>src := $(obj)</P>
<P>PHONY := __build<BR>__build:</P>
<P># Init all relevant variables used in kbuild files so<BR># 1) they have correct type<BR># 2) they do not inherit any value from the environment<BR>obj-y :=<BR>obj-m :=<BR>lib-y :=<BR>lib-m :=<BR>always :=<BR>targets :=<BR>subdir-y :=<BR>subdir-m :=<BR>EXTRA_AFLAGS&nbsp;&nbsp; :=<BR>EXTRA_CFLAGS&nbsp;&nbsp; :=<BR>EXTRA_CPPFLAGS :=<BR>EXTRA_LDFLAGS&nbsp; :=<BR>asflags-y&nbsp; :=<BR>ccflags-y&nbsp; :=<BR>cppflags-y :=<BR>ldflags-y&nbsp; :=</P>
<P>subdir-asflags-y :=<BR>subdir-ccflags-y :=</P>
<P># Read auto.conf if it exists, otherwise ignore<BR>-include include/config/auto.conf</P>
<P>include scripts/Kbuild.include</P>
<P># For backward compatibility check that these variables do not change<BR>save-cflags := $(CFLAGS)</P>
<P># The filename Kbuild has precedence over Makefile<BR>kbuild-dir := $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))<BR>kbuild-file := $(if $(wildcard $(kbuild-dir)/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)<BR>include $(kbuild-file)</P>
<P># If the save-* variables changed error out<BR>ifeq ($(KBUILD_NOPEDANTIC),)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ifneq ("$(save-cflags)","$(CFLAGS)")<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(error CFLAGS was changed in "$(kbuild-file)". Fix it to use ccflags-y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif<BR>endif</P>
<P>#<BR># make W=... settings<BR>#<BR># W=1 - warnings that may be relevant and does not occur too often<BR># W=2 - warnings that occur quite often but may still be relevant<BR># W=3 - the more obscure warnings, can most likely be ignored<BR>#<BR># $(call cc-option, -W...) handles gcc -W.. options which<BR># are not supported by all versions of the compiler<BR>ifdef KBUILD_ENABLE_EXTRA_GCC_CHECKS<BR>warning-&nbsp; := $(empty)</P>
<P>warning-1 := -Wextra -Wunused -Wno-unused-parameter<BR>warning-1 += -Wmissing-declarations<BR>warning-1 += -Wmissing-format-attribute<BR>warning-1 += -Wmissing-prototypes<BR>warning-1 += -Wold-style-definition<BR>warning-1 += $(call cc-option, -Wmissing-include-dirs)<BR>warning-1 += $(call cc-option, -Wunused-but-set-variable)<BR>warning-1 += $(call cc-disable-warning, missing-field-initializers)</P>
<P>warning-2 := -Waggregate-return<BR>warning-2 += -Wcast-align<BR>warning-2 += -Wdisabled-optimization<BR>warning-2 += -Wnested-externs<BR>warning-2 += -Wshadow<BR>warning-2 += $(call cc-option, -Wlogical-op)<BR>warning-2 += $(call cc-option, -Wmissing-field-initializers)</P>
<P>warning-3 := -Wbad-function-cast<BR>warning-3 += -Wcast-qual<BR>warning-3 += -Wconversion<BR>warning-3 += -Wpacked<BR>warning-3 += -Wpadded<BR>warning-3 += -Wpointer-arith<BR>warning-3 += -Wredundant-decls<BR>warning-3 += -Wswitch-default<BR>warning-3 += $(call cc-option, -Wpacked-bitfield-compat)<BR>warning-3 += $(call cc-option, -Wvla)</P>
<P>warning := $(warning-$(findstring 1, $(KBUILD_ENABLE_EXTRA_GCC_CHECKS)))<BR>warning += $(warning-$(findstring 2, $(KBUILD_ENABLE_EXTRA_GCC_CHECKS)))<BR>warning += $(warning-$(findstring 3, $(KBUILD_ENABLE_EXTRA_GCC_CHECKS)))</P>
<P>ifeq ("$(strip $(warning))","")<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(error W=$(KBUILD_ENABLE_EXTRA_GCC_CHECKS) is unknown)<BR>endif</P>
<P>KBUILD_CFLAGS += $(warning)<BR>endif</P>
<P>include scripts/Makefile.lib</P>
<P>ifdef host-progs<BR>ifneq ($(hostprogs-y),$(host-progs))<BR>$(warning kbuild: $(obj)/Makefile - Usage of host-progs is deprecated. Please replace with hostprogs-y!)<BR>hostprogs-y += $(host-progs)<BR>endif<BR>endif</P>
<P># Do not include host rules unless needed<BR>ifneq ($(hostprogs-y)$(hostprogs-m),)<BR>include scripts/Makefile.host<BR>endif</P>
<P>ifneq ($(KBUILD_SRC),)<BR># Create output directory if not already present<BR>_dummy := $(shell [ -d $(obj) ] || mkdir -p $(obj))</P>
<P># Create directories for object files if directory does not exist<BR># Needed when obj-y := dir/file.o syntax is used<BR>_dummy := $(foreach d,$(obj-dirs), $(shell [ -d $(d) ] || mkdir -p $(d)))<BR>endif</P>
<P>ifndef obj<BR>$(warning kbuild: Makefile.build is included improperly)<BR>endif</P>
<P># ===========================================================================</P>
<P>ifneq ($(strip $(lib-y) $(lib-m) $(lib-n) $(lib-)),)<BR>lib-target := $(obj)/lib.a<BR>endif</P>
<P>ifneq ($(strip $(obj-y) $(obj-m) $(obj-n) $(obj-) $(subdir-m) $(lib-target)),)<BR>builtin-target := $(obj)/built-in.o<BR>endif</P>
<P>modorder-target := $(obj)/modules.order</P>
<P># We keep a list of all modules in $(MODVERDIR)</P>
<P>__build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \<BR>&nbsp; $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \<BR>&nbsp; $(subdir-ym) $(always)<BR>&nbsp;@:</P>
<P># Linus' kernel sanity checking tool<BR>ifneq ($(KBUILD_CHECKSRC),0)<BR>&nbsp; ifeq ($(KBUILD_CHECKSRC),2)<BR>&nbsp;&nbsp;&nbsp; quiet_cmd_force_checksrc = CHECK&nbsp;&nbsp; $&lt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd_force_checksrc = $(CHECK) $(CHECKFLAGS) $(c_flags) $&lt; ;<BR>&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; quiet_cmd_checksrc&nbsp;&nbsp;&nbsp;&nbsp; = CHECK&nbsp;&nbsp; $&lt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd_checksrc&nbsp;&nbsp;&nbsp;&nbsp; = $(CHECK) $(CHECKFLAGS) $(c_flags) $&lt; ;<BR>&nbsp; endif<BR>endif</P>
<P># Do section mismatch analysis for each module/built-in.o<BR>ifdef CONFIG_DEBUG_SECTION_MISMATCH<BR>&nbsp; cmd_secanalysis = ; scripts/mod/modpost $@<BR>endif</P>
<P># Compile C sources (.c)<BR># ---------------------------------------------------------------------------</P>
<P># Default is built-in, unless we know otherwise<BR>modkern_cflags =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;$(if $(part-of-module),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;$(KBUILD_CFLAGS_MODULE) $(CFLAGS_MODULE), \<BR>&nbsp;&nbsp;$(KBUILD_CFLAGS_KERNEL) $(CFLAGS_KERNEL))<BR>quiet_modtag := $(empty)&nbsp;&nbsp; $(empty)</P>
<P>$(real-objs-m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : part-of-module := y<BR>$(real-objs-m:.o=.i)&nbsp; : part-of-module := y<BR>$(real-objs-m:.o=.s)&nbsp; : part-of-module := y<BR>$(real-objs-m:.o=.lst): part-of-module := y</P>
<P>$(real-objs-m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : quiet_modtag := [M]<BR>$(real-objs-m:.o=.i)&nbsp; : quiet_modtag := [M]<BR>$(real-objs-m:.o=.s)&nbsp; : quiet_modtag := [M]<BR>$(real-objs-m:.o=.lst): quiet_modtag := [M]</P>
<P>$(obj-m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : quiet_modtag := [M]</P>
<P># Default for not multi-part modules<BR>modname = $(basetarget)</P>
<P>$(multi-objs-m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : modname = $(modname-multi)<BR>$(multi-objs-m:.o=.i)&nbsp;&nbsp; : modname = $(modname-multi)<BR>$(multi-objs-m:.o=.s)&nbsp;&nbsp; : modname = $(modname-multi)<BR>$(multi-objs-m:.o=.lst) : modname = $(modname-multi)<BR>$(multi-objs-y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : modname = $(modname-multi)<BR>$(multi-objs-y:.o=.i)&nbsp;&nbsp; : modname = $(modname-multi)<BR>$(multi-objs-y:.o=.s)&nbsp;&nbsp; : modname = $(modname-multi)<BR>$(multi-objs-y:.o=.lst) : modname = $(modname-multi)</P>
<P>quiet_cmd_cc_s_c = CC $(quiet_modtag)&nbsp; $@<BR>cmd_cc_s_c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = $(CC) $(c_flags) -fverbose-asm -S -o $@ $&lt;</P>
<P>$(obj)/%.s: $(src)/%.c FORCE<BR>&nbsp;$(call if_changed_dep,cc_s_c)</P>
<P>quiet_cmd_cc_i_c = CPP $(quiet_modtag) $@<BR>cmd_cc_i_c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = $(CPP) $(c_flags)&nbsp;&nbsp; -o $@ $&lt;</P>
<P>$(obj)/%.i: $(src)/%.c FORCE<BR>&nbsp;$(call if_changed_dep,cc_i_c)</P>
<P>cmd_gensymtypes =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; $(CPP) -D__GENKSYMS__ $(c_flags) $&lt; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; $(GENKSYMS) $(if $(1), -T $(2))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; $(patsubst y,-s _,$(CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; $(if $(KBUILD_PRESERVE),-p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; -r $(firstword $(wildcard $(2:.symtypes=.symref) /dev/null))</P>
<P>quiet_cmd_cc_symtypes_c = SYM $(quiet_modtag) $@<BR>cmd_cc_symtypes_c =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; set -e;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; $(call cmd_gensymtypes,true,$@) &gt;/dev/null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; test -s $@ || rm -f $@</P>
<P>$(obj)/%.symtypes : $(src)/%.c FORCE<BR>&nbsp;$(call cmd,cc_symtypes_c)</P>
<P># C (.c) files<BR># The C file is compiled and updated dependency information is generated.<BR># (See cmd_cc_o_c + relevant part of rule_cc_o_c)</P>
<P>quiet_cmd_cc_o_c = CC $(quiet_modtag)&nbsp; $@</P>
<P>ifndef CONFIG_MODVERSIONS<BR>cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $&lt;</P>
<P>else<BR># When module versioning is enabled the following steps are executed:<BR># o compile a .tmp_&lt;file&gt;.o from &lt;file&gt;.c<BR># o if .tmp_&lt;file&gt;.o doesn't contain a __ksymtab version, i.e. does<BR>#&nbsp;&nbsp; not export symbols, we just rename .tmp_&lt;file&gt;.o to &lt;file&gt;.o and<BR>#&nbsp;&nbsp; are done.<BR># o otherwise, we calculate symbol versions using the good old<BR>#&nbsp;&nbsp; genksyms on the preprocessed source and postprocess them in a way<BR>#&nbsp;&nbsp; that they are usable as a linker script<BR># o generate &lt;file&gt;.o from .tmp_&lt;file&gt;.o using the linker to<BR>#&nbsp;&nbsp; replace the unresolved symbols __crc_exported_symbol with<BR>#&nbsp;&nbsp; the actual value of the checksum generated by genksyms</P>
<P>cmd_cc_o_c = $(CC) $(c_flags) -c -o $(@D)/.tmp_$(@F) $&lt;<BR>cmd_modversions =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if $(OBJDUMP) -h $(@D)/.tmp_$(@F) | grep -q __ksymtab; then&nbsp;&nbsp;\<BR>&nbsp;&nbsp;$(call cmd_gensymtypes,$(KBUILD_SYMTYPES),$(@:.o=.symtypes))&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt; $(@D)/.tmp_$(@F:.o=.ver);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;$(LD) $(LDFLAGS) -r -o $@ $(@D)/.tmp_$(@F) &nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;-T $(@D)/.tmp_$(@F:.o=.ver);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;rm -f $(@D)/.tmp_$(@F) $(@D)/.tmp_$(@F:.o=.ver);&nbsp;&nbsp;\<BR>&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;mv -f $(@D)/.tmp_$(@F) $@;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;fi;<BR>endif</P>
<P>ifdef CONFIG_FTRACE_MCOUNT_RECORD<BR>ifdef BUILD_C_RECORDMCOUNT<BR>ifeq ("$(origin RECORDMCOUNT_WARN)", "command line")<BR>&nbsp; RECORDMCOUNT_FLAGS = -w<BR>endif<BR># Due to recursion, we must skip empty.o.<BR># The empty.o file is created in the make process in order to determine<BR>#&nbsp; the target endianness and word size. It is made before all other C<BR>#&nbsp; files, including recordmcount.<BR>sub_cmd_record_mcount =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if [ $(@) != "scripts/mod/empty.o" ]; then&nbsp;\<BR>&nbsp;&nbsp;$(objtree)/scripts/recordmcount $(RECORDMCOUNT_FLAGS) "$(@)";&nbsp;\<BR>&nbsp;fi;<BR>recordmcount_source := $(srctree)/scripts/recordmcount.c \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(srctree)/scripts/recordmcount.h<BR>else<BR>sub_cmd_record_mcount = set -e ; perl $(srctree)/scripts/recordmcount.pl "$(ARCH)" \<BR>&nbsp;"$(if $(CONFIG_CPU_BIG_ENDIAN),big,little)" \<BR>&nbsp;"$(if $(CONFIG_64BIT),64,32)" \<BR>&nbsp;"$(OBJDUMP)" "$(OBJCOPY)" "$(CC) $(KBUILD_CFLAGS)" \<BR>&nbsp;"$(LD)" "$(NM)" "$(RM)" "$(MV)" \<BR>&nbsp;"$(if $(part-of-module),1,0)" "$(@)";<BR>recordmcount_source := $(srctree)/scripts/recordmcount.pl<BR>endif<BR>cmd_record_mcount = &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if [ "$(findstring -pg,$(_c_flags))" = "-pg" ]; then&nbsp;\<BR>&nbsp;&nbsp;$(sub_cmd_record_mcount)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;fi;<BR>endif</P>
<P>define rule_cc_o_c<BR>&nbsp;$(call echo-cmd,checksrc) $(cmd_checksrc)&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;$(call echo-cmd,cc_o_c) $(cmd_cc_o_c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;$(cmd_modversions)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;$(call echo-cmd,record_mcount)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;$(cmd_record_mcount)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;scripts/basic/fixdep $(depfile) $@ '$(call make-cmd,cc_o_c)' &gt;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(dot-target).tmp;&nbsp; \<BR>&nbsp;rm -f $(depfile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;mv -f $(dot-target).tmp $(dot-target).cmd<BR>endef</P>
<P># Built-in and composite module parts<BR>$(obj)/%.o: $(src)/%.c $(recordmcount_source) FORCE<BR>&nbsp;$(call cmd,force_checksrc)<BR>&nbsp;$(call if_changed_rule,cc_o_c)</P>
<P># Single-part modules are special since we need to mark them in $(MODVERDIR)</P>
<P>$(single-used-m): $(obj)/%.o: $(src)/%.c $(recordmcount_source) FORCE<BR>&nbsp;$(call cmd,force_checksrc)<BR>&nbsp;$(call if_changed_rule,cc_o_c)<BR>&nbsp;@{ echo $(@:.o=.ko); echo $@; } &gt; $(MODVERDIR)/$(@F:.o=.mod)</P>
<P>quiet_cmd_cc_lst_c = MKLST&nbsp;&nbsp; $@<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd_cc_lst_c = $(CC) $(c_flags) -g -c -o $*.o $&lt; &amp;&amp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(CONFIG_SHELL) $(srctree)/scripts/makelst $*.o \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.map $(OBJDUMP) &gt; $@</P>
<P>$(obj)/%.lst: $(src)/%.c FORCE<BR>&nbsp;$(call if_changed_dep,cc_lst_c)</P>
<P># Compile assembler sources (.S)<BR># ---------------------------------------------------------------------------</P>
<P>modkern_aflags := $(KBUILD_AFLAGS_KERNEL) $(AFLAGS_KERNEL)</P>
<P>$(real-objs-m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : modkern_aflags := $(KBUILD_AFLAGS_MODULE) $(AFLAGS_MODULE)<BR>$(real-objs-m:.o=.s): modkern_aflags := $(KBUILD_AFLAGS_MODULE) $(AFLAGS_MODULE)</P>
<P>quiet_cmd_as_s_S = CPP $(quiet_modtag) $@<BR>cmd_as_s_S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = $(CPP) $(a_flags)&nbsp;&nbsp; -o $@ $&lt; </P>
<P>$(obj)/%.s: $(src)/%.S FORCE<BR>&nbsp;$(call if_changed_dep,as_s_S)</P>
<P>quiet_cmd_as_o_S = AS $(quiet_modtag)&nbsp; $@<BR>cmd_as_o_S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = $(CC) $(a_flags) -c -o $@ $&lt;</P>
<P>$(obj)/%.o: $(src)/%.S FORCE<BR>&nbsp;$(call if_changed_dep,as_o_S)</P>
<P>targets += $(real-objs-y) $(real-objs-m) $(lib-y)<BR>targets += $(extra-y) $(MAKECMDGOALS) $(always)</P>
<P># Linker scripts preprocessor (.lds.S -&gt; .lds)<BR># ---------------------------------------------------------------------------<BR>quiet_cmd_cpp_lds_S = LDS&nbsp;&nbsp;&nbsp;&nbsp; $@<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd_cpp_lds_S = $(CPP) $(cpp_flags) -P -C -U$(ARCH) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -D__ASSEMBLY__ -DLINKER_SCRIPT -o $@ $&lt;</P>
<P>$(obj)/%.lds: $(src)/%.lds.S FORCE<BR>&nbsp;$(call if_changed_dep,cpp_lds_S)</P>
<P># ASN.1 grammar<BR># ---------------------------------------------------------------------------<BR>quiet_cmd_asn1_compiler = ASN.1&nbsp;&nbsp; $@<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd_asn1_compiler = $(objtree)/scripts/asn1_compiler $&lt; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;$(subst .h,.c,$@) $(subst .c,.h,$@)</P>
<P>.PRECIOUS: $(objtree)/$(obj)/%-asn1.c $(objtree)/$(obj)/%-asn1.h</P>
<P>$(obj)/%-asn1.c $(obj)/%-asn1.h: $(src)/%.asn1 $(objtree)/scripts/asn1_compiler<BR>&nbsp;$(call cmd,asn1_compiler)</P>
<P># Build the compiled-in targets<BR># ---------------------------------------------------------------------------</P>
<P># To build objects in subdirs, we need to descend into the directories<BR>$(sort $(subdir-obj-y)): $(subdir-ym) ;</P>
<P>#<BR># Rule to compile a set of .o files into one .o file<BR>#<BR>ifdef builtin-target<BR>quiet_cmd_link_o_target = LD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $@<BR># If the list of objects to link is empty, just create an empty built-in.o<BR>cmd_link_o_target = $(if $(strip $(obj-y)),\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(LD) $(ld_flags) -r -o $@ $(filter $(obj-y), $^) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(cmd_secanalysis),\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rm -f $@; $(AR) rcs$(KBUILD_ARFLAGS) $@)</P>
<P>$(builtin-target): $(obj-y) FORCE<BR>&nbsp;$(call if_changed,link_o_target)</P>
<P>targets += $(builtin-target)<BR>endif # builtin-target</P>
<P>#<BR># Rule to create modules.order file<BR>#<BR># Create commands to either record .ko file or cat modules.order from<BR># a subdirectory<BR>modorder-cmds =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;$(foreach m, $(modorder),&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;$(if $(filter %/modules.order, $m),&nbsp;\<BR>&nbsp;&nbsp;&nbsp;cat $m;, echo kernel/$m;))</P>
<P>$(modorder-target): $(subdir-ym) FORCE<BR>&nbsp;$(Q)(cat /dev/null; $(modorder-cmds)) &gt; $@</P>
<P>#<BR># Rule to compile a set of .o files into one .a file<BR>#<BR>ifdef lib-target<BR>quiet_cmd_link_l_target = AR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $@<BR>cmd_link_l_target = rm -f $@; $(AR) rcs$(KBUILD_ARFLAGS) $@ $(lib-y)</P>
<P>$(lib-target): $(lib-y) FORCE<BR>&nbsp;$(call if_changed,link_l_target)</P>
<P>targets += $(lib-target)<BR>endif</P>
<P>#<BR># Rule to link composite objects<BR>#<BR>#&nbsp; Composite objects are specified in kbuild makefile as follows:<BR>#&nbsp;&nbsp;&nbsp; &lt;composite-object&gt;-objs := &lt;list of .o files&gt;<BR>#&nbsp; or<BR>#&nbsp;&nbsp;&nbsp; &lt;composite-object&gt;-y&nbsp;&nbsp;&nbsp; := &lt;list of .o files&gt;<BR>link_multi_deps =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>$(filter $(addprefix $(obj)/,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>$($(subst $(obj)/,,$(@:.o=-objs)))&nbsp;&nbsp;&nbsp; \<BR>$($(subst $(obj)/,,$(@:.o=-y)))), $^)<BR>&nbsp;<BR>quiet_cmd_link_multi-y = LD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $@<BR>cmd_link_multi-y = $(LD) $(ld_flags) -r -o $@ $(link_multi_deps) $(cmd_secanalysis)</P>
<P>quiet_cmd_link_multi-m = LD [M]&nbsp; $@<BR>cmd_link_multi-m = $(cmd_link_multi-y)</P>
<P># We would rather have a list of rules like<BR># &nbsp;foo.o: $(foo-objs)<BR># but that's not so easy, so we rather make all composite objects depend<BR># on the set of all their parts<BR>$(multi-used-y) : %.o: $(multi-objs-y) FORCE<BR>&nbsp;$(call if_changed,link_multi-y)</P>
<P>$(multi-used-m) : %.o: $(multi-objs-m) FORCE<BR>&nbsp;$(call if_changed,link_multi-m)<BR>&nbsp;@{ echo $(@:.o=.ko); echo $(link_multi_deps); } &gt; $(MODVERDIR)/$(@F:.o=.mod)</P>
<P>targets += $(multi-used-y) $(multi-used-m)</P>
<P><BR># Descending<BR># ---------------------------------------------------------------------------</P>
<P>PHONY += $(subdir-ym)<BR>$(subdir-ym):<BR>&nbsp;$(Q)$(MAKE) $(build)=$@</P>
<P># Add FORCE to the prequisites of a target to force it to be always rebuilt.<BR># ---------------------------------------------------------------------------</P>
<P>PHONY += FORCE</P>
<P>FORCE:</P>
<P># Read all saved command lines and dependencies for the $(targets) we<BR># may be building above, using $(if_changed{,_dep}). As an<BR># optimization, we don't need to read them if the target does not<BR># exist, we will rebuild anyway in that case.</P>
<P>targets := $(wildcard $(sort $(targets)))<BR>cmd_files := $(wildcard $(foreach f,$(targets),$(dir $(f)).$(notdir $(f)).cmd))</P>
<P>ifneq ($(cmd_files),)<BR>&nbsp; include $(cmd_files)<BR>endif</P>
<P># Declare the contents of the .PHONY variable as phony.&nbsp; We keep that<BR># information in a variable se we can use it in if_changed and friends.</P>
<P>.PHONY: $(PHONY)