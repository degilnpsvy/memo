<H1 class=SECT1><A name=INTERNALVARIABLES></A>9.1. Internal Variables</H1>
<P></P>
<DIV class=VARIABLELIST>
<DL>
<DT><TT class=REPLACEABLE><I><A href="http://tldp.org/LDP/abs/html/abs-guide.html#BUILTINREF">Builtin</A> variables:</I></TT> 
<DD>
<P>variables affecting bash script behavior</P>
<DT><A name=BASHVARREF></A><TT class=VARNAME>$BASH</TT> 
<DD>
<P>The path to the <I class=FIRSTTERM>Bash</I> binary itself 
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $BASH</B></TT>
<TT class=COMPUTEROUTPUT>/bin/bash</TT></PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=BASHENVREF></A><TT class=VARNAME>$BASH_ENV</TT> 
<DD>
<P>An <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ENVREF">environmental variable</A> pointing to a Bash startup file to be read when a script is invoked</P>
<DT><A name=BASHSUBSHELLREF></A><TT class=VARNAME>$BASH_SUBSHELL</TT> 
<DD>
<P>A variable indicating the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SUBSHELLSREF">subshell</A> level. This is a new addition to Bash, <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BASH3REF">version 3</A>.</P>
<P>See <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SUBSHELL">Example 21-1</A> for usage.</P>
<DT><A name=BASHPIDREF></A><TT class=VARNAME>$BASHPID</TT> 
<DD>
<P><I class=FIRSTTERM>Process ID</I> of the current instance of Bash. This is not the same as the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PROCCID">$$</A> variable, but it often gives the same result.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash4$ </TT><TT class=USERINPUT><B>echo $$</B></TT>
<TT class=COMPUTEROUTPUT>11015</TT>


<TT class=PROMPT>bash4$ </TT><TT class=USERINPUT><B>echo $BASHPID</B></TT>
<TT class=COMPUTEROUTPUT>11015</TT>


<TT class=PROMPT>bash4$ </TT><TT class=USERINPUT><B>ps ax | grep bash4</B></TT>
<TT class=COMPUTEROUTPUT>11015 pts/2    R      0:00 bash4</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P><A name=BASHPIDREF2></A>But ...</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash4

echo "\$\$ outside of subshell = $$"                              # 9602
echo "\$BASH_SUBSHELL  outside of subshell = $BASH_SUBSHELL"      # 0
echo "\$BASHPID outside of subshell = $BASHPID"                   # 9602

echo

( echo "\$\$ inside of subshell = $$"                             # 9602
  echo "\$BASH_SUBSHELL inside of subshell = $BASH_SUBSHELL"      # 1
  echo "\$BASHPID inside of subshell = $BASHPID" )                # 9603
  # Note that $$ returns PID of parent process.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><TT class=VARNAME>$BASH_VERSINFO[n]</TT> 
<DD>
<P>A 6-element <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ARRAYREF">array</A> containing version information about the installed release of Bash. This is similar to <TT class=VARNAME>$BASH_VERSION</TT>, below, but a bit more detailed.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># Bash version info:

for n in 0 1 2 3 4 5
do
  echo "BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}"
done  

# BASH_VERSINFO[0] = 3                      # Major version no.
# BASH_VERSINFO[1] = 00                     # Minor version no.
# BASH_VERSINFO[2] = 14                     # Patch level.
# BASH_VERSINFO[3] = 1                      # Build version.
# BASH_VERSINFO[4] = release                # Release status.
# BASH_VERSINFO[5] = i386-redhat-linux-gnu  # Architecture
                                            # (same as $MACHTYPE).</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><TT class=VARNAME>$BASH_VERSION</TT> 
<DD>
<P>The version of Bash installed on the system</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $BASH_VERSION</B></TT>
<TT class=COMPUTEROUTPUT>3.2.25(1)-release</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>tcsh% </TT><TT class=USERINPUT><B>echo $BASH_VERSION</B></TT>
<TT class=COMPUTEROUTPUT>BASH_VERSION: Undefined variable.</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>Checking $BASH_VERSION is a good method of determining which shell is running. <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SHELLVARREF">$SHELL</A> does not necessarily give the correct answer.</P>
<DT><A name=CDPATHREF></A><TT class=VARNAME>$CDPATH</TT> 
<DD>
<P>A colon-separated list of search paths available to the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#CDREF">cd</A> command, similar in function to the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PATHREF">$PATH</A> variable for binaries. The <TT class=VARNAME>$CDPATH</TT> variable may be set in the local <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BASHRC"><TT class=FILENAME>~/.bashrc</TT></A> file.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>cd bash-doc</B></TT>
<TT class=COMPUTEROUTPUT>bash: cd: bash-doc: No such file or directory</TT>


<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>CDPATH=/usr/share/doc</B></TT>
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>cd bash-doc</B></TT>
<TT class=COMPUTEROUTPUT>/usr/share/doc/bash-doc</TT>


<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $PWD</B></TT>
<TT class=COMPUTEROUTPUT>/usr/share/doc/bash-doc</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=DIRSTACKREF></A><TT class=VARNAME>$DIRSTACK</TT> 
<DD>
<P>The top value in the directory stack <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN4671" name=AEN4671><SPAN class=footnote>[41]</SPAN></A> (affected by <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PUSHDREF">pushd</A> and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#POPDREF">popd</A>)</P>
<P>This builtin variable corresponds to the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DIRSD">dirs</A> command, however <B class=COMMAND>dirs</B> shows the entire contents of the directory stack.</P>
<DT><TT class=VARNAME>$EDITOR</TT> 
<DD>
<P>The default editor invoked by a script, usually <B class=COMMAND>vi</B> or <B class=COMMAND>emacs</B>.</P>
<DT><A name=EUIDREF></A><TT class=VARNAME>$EUID</TT> 
<DD>
<P><SPAN class=QUOTE>"effective"</SPAN> user ID number</P>
<P>Identification number of whatever identity the current user has assumed, perhaps by means of <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SUREF">su</A>.</P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>The <TT class=VARNAME>$EUID</TT> is not necessarily the same as the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#UIDREF">$UID</A>.</P></TD></TR></TBODY></TABLE></DIV>
<DT><TT class=VARNAME>$FUNCNAME</TT> 
<DD>
<P>Name of the current function</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>xyz23 ()
{
  echo "$FUNCNAME now executing."  # xyz23 now executing.
}

xyz23

echo "FUNCNAME = $FUNCNAME"        # FUNCNAME =
                                   # Null value outside a function.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>See also <A href="http://tldp.org/LDP/abs/html/abs-guide.html#USEGETOPT">Example A-50</A>.</P>
<DT><TT class=VARNAME>$GLOBIGNORE</TT> 
<DD>
<P>A list of filename patterns to be excluded from matching in <A href="http://tldp.org/LDP/abs/html/abs-guide.html#GLOBBINGREF">globbing</A>.</P>
<DT><A name=GROUPSREF></A><TT class=VARNAME>$GROUPS</TT> 
<DD>
<P>Groups current user belongs to</P>
<P>This is a listing (array) of the group id numbers for current user, as recorded in <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DATAFILESREF1"><TT class=FILENAME>/etc/passwd</TT></A> and <TT class=FILENAME>/etc/group</TT>. </P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>root# </TT><TT class=USERINPUT><B>echo $GROUPS</B></TT>
<TT class=COMPUTEROUTPUT>0</TT>


<TT class=PROMPT>root# </TT><TT class=USERINPUT><B>echo ${GROUPS[1]}</B></TT>
<TT class=COMPUTEROUTPUT>1</TT>


<TT class=PROMPT>root# </TT><TT class=USERINPUT><B>echo ${GROUPS[5]}</B></TT>
<TT class=COMPUTEROUTPUT>6</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=HOMEDIRREF></A><TT class=VARNAME>$HOME</TT> 
<DD>
<P>Home directory of the user, usually <TT class=FILENAME>/home/username</TT> (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX6">Example 10-7</A>)</P>
<DT><A name=HOSTNAMEREF></A><TT class=VARNAME>$HOSTNAME</TT> 
<DD>
<P>The <A href="http://tldp.org/LDP/abs/html/abs-guide.html#HNAMEREF">hostname</A> command assigns the system host name at bootup in an init script. However, the <TT class=FUNCTION>gethostname()</TT> function sets the Bash internal variable <TT class=VARNAME>$HOSTNAME</TT>. See also <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX6">Example 10-7</A>.</P>
<DT><TT class=VARNAME>$HOSTTYPE</TT> 
<DD>
<P>host type</P>
<P>Like <A href="http://tldp.org/LDP/abs/html/abs-guide.html#MACHTYPEREF">$MACHTYPE</A>, identifies the system hardware.</P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $HOSTTYPE</B></TT>
<TT class=COMPUTEROUTPUT>i686</TT></PRE></FONT></TD></TR></TBODY></TABLE>
<DT><A name=IFSREF></A><TT class=VARNAME>$IFS</TT> 
<DD>
<P>internal field separator</P>
<P>This variable determines how Bash recognizes <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FIELDREF">fields</A>, or word boundaries, when it interprets character strings.</P>
<P><A name=IFSWS></A></P>
<P>$IFS defaults to <A href="http://tldp.org/LDP/abs/html/abs-guide.html#WHITESPACEREF">whitespace</A> (space, tab, and newline), but may be changed, for example, to parse a comma-separated data file. Note that <A href="http://tldp.org/LDP/abs/html/abs-guide.html#APPREF">$*</A> uses the first character held in <TT class=VARNAME>$IFS</TT>. See <A href="http://tldp.org/LDP/abs/html/abs-guide.html#WEIRDVARS">Example 5-1</A>.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo "$IFS"</B></TT>
<TT class=COMPUTEROUTPUT></TT>
<TT class=COMPUTEROUTPUT>(With $IFS set to default, a blank line displays.)</TT>
	      


<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo "$IFS" | cat -vte</B></TT>
<TT class=COMPUTEROUTPUT> ^I$
 $</TT>
<TT class=COMPUTEROUTPUT>(Show whitespace: here a single space, ^I [horizontal tab],
  and newline, and display "$" at end-of-line.)</TT>



<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>bash -c 'set w x y z; IFS=":-;"; echo "$*"'</B></TT>
<TT class=COMPUTEROUTPUT>w:x:y:z</TT>
<TT class=COMPUTEROUTPUT>(Read commands from string and assign any arguments to pos params.)</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>Set <TT class=VARNAME>$IFS</TT> to eliminate whitespace in <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PATHNAMEREF">pathnames</A>. 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>IFS="$(printf '\n\t')"   # Per David Wheeler.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P><TT class=VARNAME>$IFS</TT> does not handle whitespace the same as it does other characters. 
<DIV class=EXAMPLE><A name=IFSH></A>
<P><B>Example 9-1. $IFS and whitespace</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# ifs.sh


var1="a+b+c"
var2="d-e-f"
var3="g,h,i"

IFS=+
# The plus sign will be interpreted as a separator.
echo $var1     # a b c
echo $var2     # d-e-f
echo $var3     # g,h,i

echo

IFS="-"
# The plus sign reverts to default interpretation.
# The minus sign will be interpreted as a separator.
echo $var1     # a+b+c
echo $var2     # d e f
echo $var3     # g,h,i

echo

IFS=","
# The comma will be interpreted as a separator.
# The minus sign reverts to default interpretation.
echo $var1     # a+b+c
echo $var2     # d-e-f
echo $var3     # g h i

echo

IFS=" "
# The space character will be interpreted as a separator.
# The comma reverts to default interpretation.
echo $var1     # a+b+c
echo $var2     # d-e-f
echo $var3     # g,h,i

# ======================================================== #

# However ...
# $IFS treats whitespace differently than other characters.

output_args_one_per_line()
{
  for arg
  do
    echo "[$arg]"
  done #  ^    ^   Embed within brackets, for your viewing pleasure.
}

echo; echo "IFS=\" \""
echo "-------"

IFS=" "
var=" a  b c   "
#    ^ ^^   ^^^
output_args_one_per_line $var  # output_args_one_per_line `echo " a  b c   "`
# [a]
# [b]
# [c]


echo; echo "IFS=:"
echo "-----"

IFS=:
var=":a::b:c:::"               # Same pattern as above,
#    ^ ^^   ^^^                #+ but substituting ":" for " "  ...
output_args_one_per_line $var
# []
# [a]
# []
# [b]
# [c]
# []
# []

# Note "empty" brackets.
# The same thing happens with the "FS" field separator in awk.


echo

exit</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P></P></TD></TR></TBODY></TABLE></DIV>
<P>(Many thanks, St&#233;phane Chazelas, for clarification and above examples.)</P>
<P>See also <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ISSPAMMER">Example 16-41</A>, <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BINGREP">Example 11-8</A>, and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#MAILBOXGREP">Example 19-14</A> for instructive examples of using <TT class=VARNAME>$IFS</TT>.</P>
<DT><TT class=VARNAME>$IGNOREEOF</TT> 
<DD>
<P>Ignore EOF: how many end-of-files (control-D) the shell will ignore before logging out.</P>
<DT><TT class=VARNAME>$LC_COLLATE</TT> 
<DD>
<P>Often set in the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SAMPLE-BASHRC"><TT class=FILENAME>.bashrc</TT></A> or <TT class=FILENAME>/etc/profile</TT> files, this variable controls collation order in filename expansion and pattern matching. If mishandled, <TT class=VARNAME>LC_COLLATE</TT> can cause unexpected results in <A href="http://tldp.org/LDP/abs/html/abs-guide.html#GLOBBINGREF">filename globbing</A>.</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>As of version 2.05 of Bash, filename globbing no longer distinguishes between lowercase and uppercase letters in a character range between brackets. For example, <B class=COMMAND>ls [A-M]*</B> would match both <TT class=FILENAME>File1.txt</TT> and <TT class=FILENAME>file1.txt</TT>. To revert to the customary behavior of bracket matching, set <TT class=VARNAME>LC_COLLATE</TT> to <TT class=OPTION>C</TT> by an <TT class=USERINPUT><B>export LC_COLLATE=C</B></TT> in <TT class=FILENAME>/etc/profile</TT> and/or <TT class=FILENAME>~/.bashrc</TT>.</P></TD></TR></TBODY></TABLE></DIV>
<DT><TT class=VARNAME>$LC_CTYPE</TT> 
<DD>
<P>This internal variable controls character interpretation in <A href="http://tldp.org/LDP/abs/html/abs-guide.html#GLOBBINGREF">globbing</A> and pattern matching.</P>
<DT><A name=LINENOREF></A><TT class=VARNAME>$LINENO</TT> 
<DD>
<P>This variable is the line number of the shell script in which this variable appears. It has significance only within the script in which it appears, and is chiefly useful for debugging purposes.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># *** BEGIN DEBUG BLOCK ***
last_cmd_arg=$_  # Save it.

echo "At line number $LINENO, variable \"v1\" = $v1"
echo "Last command argument processed = $last_cmd_arg"
# *** END DEBUG BLOCK ***</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=MACHTYPEREF></A><TT class=VARNAME>$MACHTYPE</TT> 
<DD>
<P>machine type</P>
<P>Identifies the system hardware.</P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $MACHTYPE</B></TT>
<TT class=COMPUTEROUTPUT>i686</TT></PRE></FONT></TD></TR></TBODY></TABLE>
<DT><A name=OLDPWD></A><TT class=VARNAME>$OLDPWD</TT> 
<DD>
<P>Old working directory (<SPAN class=QUOTE>"OLD-Print-Working-Directory"</SPAN>, previous directory you were in).</P>
<DT><TT class=VARNAME>$OSTYPE</TT> 
<DD>
<P>operating system type</P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $OSTYPE</B></TT>
<TT class=COMPUTEROUTPUT>linux</TT></PRE></FONT></TD></TR></TBODY></TABLE>
<DT><A name=PATHREF></A><TT class=VARNAME>$PATH</TT> 
<DD>
<P>Path to binaries, usually <TT class=FILENAME>/usr/bin/</TT>, <TT class=FILENAME>/usr/X11R6/bin/</TT>, <TT class=FILENAME>/usr/local/bin</TT>, etc.</P>
<P>When given a command, the shell automatically does a hash table search on the directories listed in the <I class=FIRSTTERM>path</I> for the executable. The path is stored in the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ENVREF">environmental variable</A>, <TT class=VARNAME>$PATH</TT>, a list of directories, separated by colons. Normally, the system stores the <TT class=VARNAME>$PATH</TT> definition in <TT class=FILENAME>/etc/profile</TT> and/or <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SAMPLE-BASHRC"><TT class=FILENAME>~/.bashrc</TT></A> (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FILES">Appendix H</A>).</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><B class=COMMAND>echo $PATH</B>
<TT class=COMPUTEROUTPUT>/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin</TT></PRE></FONT></TD></TR></TBODY></TABLE></P>
<P><TT class=USERINPUT><B>PATH=${PATH}:/opt/bin</B></TT> appends the <TT class=FILENAME>/opt/bin</TT> directory to the current path. In a script, it may be expedient to temporarily add a directory to the path in this way. When the script exits, this restores the original <TT class=VARNAME>$PATH</TT> (a child process, such as a script, may not change the environment of the parent process, the shell).</P>
<P><A name=CURRENTWDREF></A></P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>The current <SPAN class=QUOTE>"working directory"</SPAN>, <TT class=FILENAME>./</TT>, is usually omitted from the <TT class=VARNAME>$PATH</TT> as a security measure.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=PIPESTATUSREF></A><TT class=VARNAME>$PIPESTATUS</TT> 
<DD>
<P><A href="http://tldp.org/LDP/abs/html/abs-guide.html#ARRAYREF">Array</A> variable holding <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EXITSTATUSREF">exit status</A>(es) of last executed <I class=FIRSTTERM>foreground</I> <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PIPEREF">pipe</A>.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $PIPESTATUS</B></TT>
<TT class=COMPUTEROUTPUT>0</TT>

<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>ls -al | bogus_command</B></TT>
<TT class=COMPUTEROUTPUT>bash: bogus_command: command not found</TT>
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo ${PIPESTATUS[1]}</B></TT>
<TT class=COMPUTEROUTPUT>127</TT>

<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>ls -al | bogus_command</B></TT>
<TT class=COMPUTEROUTPUT>bash: bogus_command: command not found</TT>
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $?</B></TT>
<TT class=COMPUTEROUTPUT>127</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>The members of the <TT class=VARNAME>$PIPESTATUS</TT> array hold the exit status of each respective command executed in a pipe. <TT class=VARNAME>$PIPESTATUS[0]</TT> holds the exit status of the first command in the pipe, <TT class=VARNAME>$PIPESTATUS[1]</TT> the exit status of the second command, and so on.</P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>The <TT class=VARNAME>$PIPESTATUS</TT> variable may contain an erroneous <SPAN class=ERRORCODE>0</SPAN> value in a login shell (in releases prior to 3.0 of Bash). </P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>tcsh% </TT><TT class=USERINPUT><B>bash</B></TT>

<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>who | grep nobody | sort</B></TT>
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo ${PIPESTATUS[*]}</B></TT>
<TT class=COMPUTEROUTPUT>0</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>The above lines contained in a script would produce the expected <TT class=COMPUTEROUTPUT>0 1 0</TT> output. </P>
<P>Thank you, Wayne Pollock for pointing this out and supplying the above example. </P></TD></TR></TBODY></TABLE></DIV>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>The <TT class=VARNAME>$PIPESTATUS</TT> variable gives unexpected results in some contexts.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $BASH_VERSION</B></TT>
<TT class=COMPUTEROUTPUT>3.00.14(1)-release</TT>

<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>$ ls | bogus_command | wc</B></TT>
<TT class=COMPUTEROUTPUT>bash: bogus_command: command not found
 0       0       0</TT>

<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo ${PIPESTATUS[@]}</B></TT>
<TT class=COMPUTEROUTPUT>141 127 0</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>Chet Ramey attributes the above output to the behavior of <A href="http://tldp.org/LDP/abs/html/abs-guide.html#LSREF">ls</A>. If <I class=FIRSTTERM>ls</I> writes to a <I class=FIRSTTERM>pipe</I> whose output is not read, then <TT class=REPLACEABLE><I>SIGPIPE</I></TT> kills it, and its <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EXITSTATUSREF">exit status</A> is <SPAN class=RETURNVALUE>141</SPAN>. Otherwise its exit status is <SPAN class=RETURNVALUE>0</SPAN>, as expected. This likewise is the case for <A href="http://tldp.org/LDP/abs/html/abs-guide.html#TRREF">tr</A>.</P></TD></TR></TBODY></TABLE></DIV>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P><TT class=VARNAME>$PIPESTATUS</TT> is a <SPAN class=QUOTE>"volatile"</SPAN> variable. It needs to be captured immediately after the pipe in question, before any other command intervenes.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>$ ls | bogus_command | wc</B></TT>
<TT class=COMPUTEROUTPUT>bash: bogus_command: command not found
 0       0       0</TT>

<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo ${PIPESTATUS[@]}</B></TT>
<TT class=COMPUTEROUTPUT>0 127 0</TT>

<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo ${PIPESTATUS[@]}</B></TT>
<TT class=COMPUTEROUTPUT>0</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P></TD></TR></TBODY></TABLE></DIV>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>The <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PIPEFAILREF">pipefail option</A> may be useful in cases where <TT class=VARNAME>$PIPESTATUS</TT> does not give the desired information.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=PPIDREF></A><TT class=VARNAME>$PPID</TT> 
<DD>
<P></P>
<P>The <TT class=VARNAME>$PPID</TT> of a process is the process ID (<TT class=VARNAME>pid</TT>) of its parent process. <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN5154" name=AEN5154><SPAN class=footnote>[42]</SPAN></A> </P>
<P>Compare this with the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PIDOFREF">pidof</A> command.</P>
<DT><TT class=VARNAME>$PROMPT_COMMAND</TT> 
<DD>
<P>A variable holding a command to be executed just before the primary prompt, <TT class=VARNAME>$PS1</TT> is to be displayed.</P>
<DT><A name=PS1REF></A><TT class=VARNAME>$PS1</TT> 
<DD>
<P>This is the main prompt, seen at the command-line.</P>
<DT><A name=SECPROMPTREF></A><TT class=VARNAME>$PS2</TT> 
<DD>
<P>The secondary prompt, seen when additional input is expected. It displays as <SPAN class=QUOTE>"&gt;"</SPAN>.</P>
<DT><TT class=VARNAME>$PS3</TT> 
<DD>
<P>The tertiary prompt, displayed in a <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SELECTREF">select</A> loop (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX31">Example 11-30</A>).</P>
<DT><TT class=VARNAME>$PS4</TT> 
<DD>
<P>The quartenary prompt, shown at the beginning of each line of output when invoking a script with the <SPAN class=TOKEN>-x</SPAN> <EM>[verbose trace]</EM> <A href="http://tldp.org/LDP/abs/html/abs-guide.html#OPTIONSREF">option</A>. It displays as <SPAN class=QUOTE>"+"</SPAN>.</P>
<P>As a debugging aid, it may be useful to embed diagnostic information in <TT class=VARNAME>$PS4</TT>. 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>P4='$(read time junk &lt; /proc/$$/schedstat; echo "@@@ $time @@@ " )'
# Per suggestion by Erik Brandsberg.
set -x
# Various commands follow ...</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=PWDREF></A><TT class=VARNAME>$PWD</TT> 
<DD>
<P>Working directory (directory you are in at the time)</P>
<P>This is the analog to the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PWD2REF">pwd</A> builtin command.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

E_WRONG_DIRECTORY=85

clear # Clear the screen.

TargetDirectory=/home/bozo/projects/GreatAmericanNovel

cd $TargetDirectory
echo "Deleting stale files in $TargetDirectory."

if [ "$PWD" != "$TargetDirectory" ]
then    # Keep from wiping out wrong directory by accident.
  echo "Wrong directory!"
  echo "In $PWD, rather than $TargetDirectory!"
  echo "Bailing out!"
  exit $E_WRONG_DIRECTORY
fi  

rm -rf *
rm .[A-Za-z0-9]*    # Delete dotfiles.
# rm -f .[^.]* ..?*   to remove filenames beginning with multiple dots.
# (shopt -s dotglob; rm -f *)   will also work.
# Thanks, S.C. for pointing this out.

#  A filename (`basename`) may contain all characters in the 0 - 255 range,
#+ except "/".
#  Deleting files beginning with weird characters, such as -
#+ is left as an exercise. (Hint: rm ./-weirdname or rm -- -weirdname)
result=$?   # Result of delete operations. If successful = 0.

echo
ls -al              # Any files left?
echo "Done."
echo "Old files deleted in $TargetDirectory."
echo

# Various other operations here, as necessary.

exit $result</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=REPLYREF></A><TT class=VARNAME>$REPLY</TT> 
<DD>
<P>The default value when a variable is not supplied to <A href="http://tldp.org/LDP/abs/html/abs-guide.html#READREF">read</A>. Also applicable to <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SELECTREF">select</A> menus, but only supplies the item number of the variable chosen, not the value of the variable itself.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# reply.sh

# REPLY is the default value for a 'read' command.

echo
echo -n "What is your favorite vegetable? "
read

echo "Your favorite vegetable is $REPLY."
#  REPLY holds the value of last "read" if and only if
#+ no variable supplied.

echo
echo -n "What is your favorite fruit? "
read fruit
echo "Your favorite fruit is $fruit."
echo "but..."
echo "Value of \$REPLY is still $REPLY."
#  $REPLY is still set to its previous value because
#+ the variable $fruit absorbed the new "read" value.

echo

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><TT class=VARNAME>$SECONDS</TT> 
<DD>
<P>The number of seconds the script has been running.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

TIME_LIMIT=10
INTERVAL=1

echo
echo "Hit Control-C to exit before $TIME_LIMIT seconds."
echo

while [ "$SECONDS" -le "$TIME_LIMIT" ]
do   #   $SECONDS is an internal shell variable.
  if [ "$SECONDS" -eq 1 ]
  then
    units=second
  else  
    units=seconds
  fi

  echo "This script has been running $SECONDS $units."
  #  On a slow or overburdened machine, the script may skip a count
  #+ every once in a while.
  sleep $INTERVAL
done

echo -e "\a"  # Beep!

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><TT class=VARNAME>$SHELLOPTS</TT> 
<DD>
<P>The list of enabled shell <A href="http://tldp.org/LDP/abs/html/abs-guide.html#OPTIONSREF">options</A>, a readonly variable. 
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $SHELLOPTS</B></TT>
<TT class=COMPUTEROUTPUT>braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=SHLVLREF></A><TT class=VARNAME>$SHLVL</TT> 
<DD>
<P>Shell level, how deeply Bash is nested. <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN5320" name=AEN5320><SPAN class=footnote>[43]</SPAN></A> If, at the command-line, $SHLVL is 1, then in a script it will increment to 2.</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>This variable is <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SUBSHNLEVREF"><EM>not</EM> affected by subshells</A>. Use <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BASHSUBSHELLREF">$BASH_SUBSHELL</A> when you need an indication of subshell nesting.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=TMOUTREF></A><TT class=VARNAME>$TMOUT</TT> 
<DD>
<P>If the <TT class=REPLACEABLE><I>$TMOUT</I></TT> environmental variable is set to a non-zero value <TT class=VARNAME>time</TT>, then the shell prompt will time out after <TT class=VARNAME>$time</TT> seconds. This will cause a logout.</P>
<P>As of version 2.05b of Bash, it is now possible to use <TT class=REPLACEABLE><I>$TMOUT</I></TT> in a script in combination with <A href="http://tldp.org/LDP/abs/html/abs-guide.html#READREF">read</A>.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># Works in scripts for Bash, versions 2.05b and later.

TMOUT=3    # Prompt times out at three seconds.

echo "What is your favorite song?"
echo "Quickly now, you only have $TMOUT seconds to answer!"
read song

if [ -z "$song" ]
then
  song="(no answer)"
  # Default response.
fi

echo "Your favorite song is $song."</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P><A name=TIMINGLOOP></A></P>
<P>There are other, more complex, ways of implementing timed input in a script. One alternative is to set up a timing loop to signal the script when it times out. This also requires a signal handling routine to <A href="http://tldp.org/LDP/abs/html/abs-guide.html#TRAPREF1">trap</A> (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX76">Example 32-5</A>) the interrupt generated by the timing loop (whew!).</P>
<DIV class=EXAMPLE><A name=TMDIN></A>
<P><B>Example 9-2. Timed Input</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# timed-input.sh

# TMOUT=3    Also works, as of newer versions of Bash.

TIMER_INTERRUPT=14
TIMELIMIT=3  # Three seconds in this instance.
             # May be set to different value.

PrintAnswer()
{
  if [ "$answer" = TIMEOUT ]
  then
    echo $answer
  else       # Don't want to mix up the two instances. 
    echo "Your favorite veggie is $answer"
    kill $!  #  Kills no-longer-needed TimerOn function
             #+ running in background.
             #  $! is PID of last job running in background.
  fi

}  


TimerOn()
{
  sleep $TIMELIMIT &amp;&amp; kill -s 14 $$ &amp;
  # Waits 3 seconds, then sends sigalarm to script.
}  


Int14Vector()
{
  answer="TIMEOUT"
  PrintAnswer
  exit $TIMER_INTERRUPT
}  

trap Int14Vector $TIMER_INTERRUPT
# Timer interrupt (14) subverted for our purposes.

echo "What is your favorite vegetable "
TimerOn
read answer
PrintAnswer


#  Admittedly, this is a kludgy implementation of timed input.
#  However, the "-t" option to "read" simplifies this task.
#  See the "t-out.sh" script.
#  However, what about timing not just single user input,
#+ but an entire script?

#  If you need something really elegant ...
#+ consider writing the application in C or C++,
#+ using appropriate library functions, such as 'alarm' and 'setitimer.'

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P><A name=STTYTO></A></P>
<P>An alternative is using <A href="http://tldp.org/LDP/abs/html/abs-guide.html#STTYREF">stty</A>.</P>
<DIV class=EXAMPLE><A name=TIMEOUT></A>
<P><B>Example 9-3. Once more, timed input</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# timeout.sh

#  Written by Stephane Chazelas,
#+ and modified by the document author.

INTERVAL=5                # timeout interval

timedout_read() {
  timeout=$1
  varname=$2
  old_tty_settings=`stty -g`
  stty -icanon min 0 time ${timeout}0
  eval read $varname      # or just  read $varname
  stty "$old_tty_settings"
  # See man page for "stty."
}

echo; echo -n "What's your name? Quick! "
timedout_read $INTERVAL your_name

#  This may not work on every terminal type.
#  The maximum timeout depends on the terminal.
#+ (it is often 25.5 seconds).

echo

if [ ! -z "$your_name" ]  # If name input before timeout ...
then
  echo "Your name is $your_name."
else
  echo "Timed out."
fi

echo

# The behavior of this script differs somewhat from "timed-input.sh."
# At each keystroke, the counter resets.

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>Perhaps the simplest method is using the <TT class=OPTION>-t</TT> option to <A href="http://tldp.org/LDP/abs/html/abs-guide.html#READREF">read</A>.</P>
<DIV class=EXAMPLE><A name=TOUT></A>
<P><B>Example 9-4. Timed <I class=FIRSTTERM>read</I></B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# t-out.sh [time-out]
# Inspired by a suggestion from "syngin seven" (thanks).


TIMELIMIT=4         # 4 seconds

read -t $TIMELIMIT variable &lt;&amp;1
#                           ^^^
#  In this instance, "&lt;&amp;1" is needed for Bash 1.x and 2.x,
#  but unnecessary for Bash 3+.

echo

if [ -z "$variable" ]  # Is null?
then
  echo "Timed out, variable still unset."
else  
  echo "variable = $variable"
fi  

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DT><A name=UIDREF></A><TT class=VARNAME>$UID</TT> 
<DD>
<P>User ID number</P>
<P>Current user's user identification number, as recorded in <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DATAFILESREF1"><TT class=FILENAME>/etc/passwd</TT></A></P>
<P>This is the current user's real id, even if she has temporarily assumed another identity through <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SUREF">su</A>. <TT class=VARNAME>$UID</TT> is a readonly variable, not subject to change from the command line or within a script, and is the counterpart to the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#IDREF">id</A> builtin.</P>
<DIV class=EXAMPLE><A name=AMIROOT></A>
<P><B>Example 9-5. Am I root?</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# am-i-root.sh:   Am I root or not?

ROOT_UID=0   # Root has $UID 0.

if [ "$UID" -eq "$ROOT_UID" ]  # Will the real "root" please stand up?
then
  echo "You are root."
else
  echo "You are just an ordinary user (but mom loves you just the same)."
fi

exit 0


# ============================================================= #
# Code below will not execute, because the script already exited.

# An alternate method of getting to the root of matters:

ROOTUSER_NAME=root

username=`id -nu`              # Or...   username=`whoami`
if [ "$username" = "$ROOTUSER_NAME" ]
then
  echo "Rooty, toot, toot. You are root."
else
  echo "You are just a regular fella."
fi</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>See also <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX2">Example 2-3</A>.</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>The variables <TT class=VARNAME>$ENV</TT>, <TT class=VARNAME>$LOGNAME</TT>, <TT class=VARNAME>$MAIL</TT>, <TT class=VARNAME>$TERM</TT>, <TT class=VARNAME>$USER</TT>, and <TT class=VARNAME>$USERNAME</TT> are <EM>not</EM> Bash <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BUILTINREF">builtins</A>. These are, however, often set as <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ENVREF">environmental variables</A> in one of the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FILESREF1">Bash</A> or <I class=FIRSTTERM>login</I> startup files. <A name=SHELLVARREF></A><TT class=VARNAME>$SHELL</TT>, the name of the user's login shell, may be set from <TT class=FILENAME>/etc/passwd</TT> or in an <SPAN class=QUOTE>"init"</SPAN> script, and it is likewise not a Bash builtin.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>tcsh% </TT><TT class=USERINPUT><B>echo $LOGNAME</B></TT>
<TT class=COMPUTEROUTPUT>bozo</TT>
<TT class=PROMPT>tcsh% </TT><TT class=USERINPUT><B>echo $SHELL</B></TT>
<TT class=COMPUTEROUTPUT>/bin/tcsh</TT>
<TT class=PROMPT>tcsh% </TT><TT class=USERINPUT><B>echo $TERM</B></TT>
<TT class=COMPUTEROUTPUT>rxvt</TT>

<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $LOGNAME</B></TT>
<TT class=COMPUTEROUTPUT>bozo</TT>
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $SHELL</B></TT>
<TT class=COMPUTEROUTPUT>/bin/tcsh</TT>
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo $TERM</B></TT>
<TT class=COMPUTEROUTPUT>rxvt</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P></TD></TR></TBODY></TABLE></DIV></DD></DL></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B>Positional Parameters</B></P>
<DL>
<DT><A name=POSPARAMREF></A><TT class=VARNAME>$0</TT>, <TT class=VARNAME>$1</TT>, <TT class=VARNAME>$2</TT>, etc. 
<DD>
<P>Positional parameters, passed from command line to script, passed to a function, or <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SETREF">set</A> to a variable (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX17">Example 4-5</A> and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX34">Example 15-16</A>)</P>
<DT><A name=CLACOUNTREF></A><TT class=VARNAME>$#</TT> 
<DD>
<P>Number of command-line arguments <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN5479" name=AEN5479><SPAN class=footnote>[44]</SPAN></A> or positional parameters (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX4">Example 36-2</A>)</P>
<DT><A name=APPREF></A><TT class=VARNAME>$*</TT> 
<DD>
<P>All of the positional parameters, seen as a single word</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P><SPAN class=QUOTE>"<TT class=VARNAME>$*</TT>"</SPAN> must be quoted.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=APPREF2></A><TT class=VARNAME>$@</TT> 
<DD>
<P>Same as <SPAN class=TOKEN>$*</SPAN>, but each parameter is a quoted string, that is, the parameters are passed on intact, without interpretation or expansion. This means, among other things, that each parameter in the argument list is seen as a separate word.</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>Of course, <SPAN class=QUOTE>"<TT class=VARNAME>$@</TT>"</SPAN> should be quoted.</P></TD></TR></TBODY></TABLE></DIV>
<DIV class=EXAMPLE><A name=ARGLIST></A>
<P><B>Example 9-6. <I class=FIRSTTERM>arglist</I>: Listing arguments with $* and $@</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# arglist.sh
# Invoke this script with several arguments, such as "one two three" ...

E_BADARGS=85

if [ ! -n "$1" ]
then
  echo "Usage: `basename $0` argument1 argument2 etc."
  exit $E_BADARGS
fi  

echo

index=1          # Initialize count.

echo "Listing args with \"\$*\":"
for arg in "$*"  # Doesn't work properly if "$*" isn't quoted.
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # $* sees all arguments as single word. 
echo "Entire arg list seen as single word."

echo

index=1          # Reset count.
                 # What happens if you forget to do this?

echo "Listing args with \"\$@\":"
for arg in "$@"
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # $@ sees arguments as separate words. 
echo "Arg list seen as separate words."

echo

index=1          # Reset count.

echo "Listing args with \$* (unquoted):"
for arg in $*
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # Unquoted $* sees arguments as separate words. 
echo "Arg list seen as separate words."

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>Following a <B class=COMMAND>shift</B>, the <TT class=VARNAME>$@</TT> holds the remaining command-line parameters, lacking the previous <TT class=VARNAME>$1</TT>, which was lost. 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# Invoke with ./scriptname 1 2 3 4 5

echo "$@"    # 1 2 3 4 5
shift
echo "$@"    # 2 3 4 5
shift
echo "$@"    # 3 4 5

# Each "shift" loses parameter $1.
# "$@" then contains the remaining parameters.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>The <TT class=VARNAME>$@</TT> special parameter finds use as a tool for filtering input into shell scripts. The <B class=COMMAND>cat "$@"</B> construction accepts input to a script either from <TT class=FILENAME>stdin</TT> or from files given as parameters to the script. See <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ROT13">Example 16-24</A> and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#CRYPTOQUOTE">Example 16-25</A>.</P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>The <TT class=VARNAME>$*</TT> and <TT class=VARNAME>$@</TT> parameters sometimes display inconsistent and puzzling behavior, depending on the setting of <A href="http://tldp.org/LDP/abs/html/abs-guide.html#IFSREF">$IFS</A>.</P></TD></TR></TBODY></TABLE></DIV>
<DIV class=EXAMPLE><A name=INCOMPAT></A>
<P><B>Example 9-7. Inconsistent <TT class=VARNAME>$*</TT> and <TT class=VARNAME>$@</TT> behavior</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

#  Erratic behavior of the "$*" and "$@" internal Bash variables,
#+ depending on whether or not they are quoted.
#  Demonstrates inconsistent handling of word splitting and linefeeds.


set -- "First one" "second" "third:one" "" "Fifth: :one"
# Setting the script arguments, $1, $2, $3, etc.

echo

echo 'IFS unchanged, using "$*"'
c=0
for i in "$*"               # quoted
do echo "$((c+=1)): [$i]"   # This line remains the same in every instance.
                            # Echo args.
done
echo ---

echo 'IFS unchanged, using $*'
c=0
for i in $*                 # unquoted
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS unchanged, using "$@"'
c=0
for i in "$@"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS unchanged, using $@'
c=0
for i in $@
do echo "$((c+=1)): [$i]"
done
echo ---

IFS=:
echo 'IFS=":", using "$*"'
c=0
for i in "$*"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $*'
c=0
for i in $*
do echo "$((c+=1)): [$i]"
done
echo ---

var=$*
echo 'IFS=":", using "$var" (var=$*)'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $var (var=$*)'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

var="$*"
echo 'IFS=":", using $var (var="$*")'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$var" (var="$*")'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$@"'
c=0
for i in "$@"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $@'
c=0
for i in $@
do echo "$((c+=1)): [$i]"
done
echo ---

var=$@
echo 'IFS=":", using $var (var=$@)'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$var" (var=$@)'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

var="$@"
echo 'IFS=":", using "$var" (var="$@")'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $var (var="$@")'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done

echo

# Try this script with ksh or zsh -y.

exit 0

#  This example script written by Stephane Chazelas,
#+ and slightly modified by the document author.</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>The <B class=COMMAND>$@</B> and <B class=COMMAND>$*</B> parameters differ only when between double quotes.</P></TD></TR></TBODY></TABLE></DIV>
<DIV class=EXAMPLE><A name=IFSEMPTY></A>
<P><B>Example 9-8. <TT class=VARNAME>$*</TT> and <TT class=VARNAME>$@</TT> when <TT class=VARNAME>$IFS</TT> is empty</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

#  If $IFS set, but empty,
#+ then "$*" and "$@" do not echo positional params as expected.

mecho ()       # Echo positional parameters.
{
echo "$1,$2,$3";
}


IFS=""         # Set, but empty.
set a b c      # Positional parameters.

mecho "$*"     # abc,,
#                   ^^
mecho $*       # a,b,c

mecho $@       # a,b,c
mecho "$@"     # a,b,c

#  The behavior of $* and $@ when $IFS is empty depends
#+ on which Bash or sh version being run.
#  It is therefore inadvisable to depend on this "feature" in a script.


# Thanks, Stephane Chazelas.

exit</PRE></FONT></TD></TR></TBODY></TABLE></DIV></DD></DL></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B>Other Special Parameters</B></P>
<DL>
<DT><A name=FLPREF></A><TT class=VARNAME>$-</TT> 
<DD>
<P>Flags passed to script (using <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SETREF">set</A>). See <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX34">Example 15-16</A>.</P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>This was originally a <I class=FIRSTTERM>ksh</I> construct adopted into Bash, and unfortunately it does not seem to work reliably in Bash scripts. One possible use for it is to have a script <A href="http://tldp.org/LDP/abs/html/abs-guide.html#IITEST">self-test whether it is interactive</A>.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=PIDVARREF></A><TT class=VARNAME>$!</TT> 
<DD>
<P><A href="http://tldp.org/LDP/abs/html/abs-guide.html#PROCESSIDDEF">PID</A> (process ID) of last job run in background</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>LOG=$0.log

COMMAND1="sleep 100"

echo "Logging PIDs background commands for script: $0" &gt;&gt; "$LOG"
# So they can be monitored, and killed as necessary.
echo &gt;&gt; "$LOG"

# Logging commands.

echo -n "PID of \"$COMMAND1\":  " &gt;&gt; "$LOG"
${COMMAND1} &amp;
echo $! &gt;&gt; "$LOG"
# PID of "sleep 100":  1506

# Thank you, Jacques Lederer, for suggesting this.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>Using <TT class=VARNAME>$!</TT> for job control:</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>possibly_hanging_job &amp; { sleep ${TIMEOUT}; eval 'kill -9 $!' &amp;&gt; /dev/null; }
# Forces completion of an ill-behaved program.
# Useful, for example, in init scripts.

# Thank you, Sylvain Fourmanoit, for this creative use of the "!" variable.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>Or, alternately:</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># This example by Matthew Sage.
# Used with permission.

TIMEOUT=30   # Timeout value in seconds
count=0

possibly_hanging_job &amp; {
        while ((count &lt; TIMEOUT )); do
                eval '[ ! -d "/proc/$!" ] &amp;&amp; ((count = TIMEOUT))'
                # /proc is where information about running processes is found.
                # "-d" tests whether it exists (whether directory exists).
                # So, we're waiting for the job in question to show up.
                ((count++))
                sleep 1
        done
        eval '[ -d "/proc/$!" ] &amp;&amp; kill -15 $!'
        # If the hanging job is running, kill it.
}

#  -------------------------------------------------------------- #

#  However, this may not not work as specified if another process
#+ begins to run after the "hanging_job" . . .
#  In such a case, the wrong job may be killed.
#  Ariel Meragelman suggests the following fix.

TIMEOUT=30
count=0
# Timeout value in seconds
possibly_hanging_job &amp; {

while ((count &lt; TIMEOUT )); do
  eval '[ ! -d "/proc/$lastjob" ] &amp;&amp; ((count = TIMEOUT))'
  lastjob=$!
  ((count++))
  sleep 1
done
eval '[ -d "/proc/$lastjob" ] &amp;&amp; kill -15 $lastjob'

}

exit</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=UNDERSCOREREF></A><TT class=VARNAME>$_</TT> 
<DD>
<P>Special variable set to final argument of previous command executed.</P>
<DIV class=EXAMPLE><A name=USCREF></A>
<P><B>Example 9-9. Underscore variable</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

echo $_              #  /bin/bash
                     #  Just called /bin/bash to run the script.
                     #  Note that this will vary according to
                     #+ how the script is invoked.

du &gt;/dev/null        #  So no output from command.
echo $_              #  du

ls -al &gt;/dev/null    #  So no output from command.
echo $_              #  -al  (last argument)

:
echo $_              #  :</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DT><A name=XSTATVARREF></A><TT class=VARNAME>$?</TT> 
<DD>
<P><A href="http://tldp.org/LDP/abs/html/abs-guide.html#EXITSTATUSREF">Exit status</A> of a command, <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FUNCTIONREF">function</A>, or the script itself (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#MAX">Example 24-7</A>)</P>
<DT><A name=PROCCID></A><TT class=VARNAME>$$</TT> 
<DD>
<P>Process ID (<I class=FIRSTTERM>PID</I>) of the script itself. <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN5654" name=AEN5654><SPAN class=footnote>[45]</SPAN></A> The <TT class=VARNAME>$$</TT> variable often finds use in scripts to construct <SPAN class=QUOTE>"unique"</SPAN> temp file names (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ONLINE">Example 32-6</A>, <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DERPM">Example 16-31</A>, and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SELFDESTRUCT">Example 15-27</A>). This is usually simpler than invoking <A href="http://tldp.org/LDP/abs/html/abs-guide.html#MKTEMPREF">mktemp</A>.</P></DD></DL></DIV>