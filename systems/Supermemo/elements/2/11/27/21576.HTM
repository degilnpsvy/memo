<H1 class=SECT1><A name=FILEARCHIV></A>16.5. File and Archiving Commands</H1>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=FAARCHIVING1></A>Archiving</B></P>
<DL>
<DT><A name=TARREF></A><B class=COMMAND>tar</B> 
<DD>
<P>The standard UNIX archiving utility. <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN11885" name=AEN11885><SPAN class=footnote>[75]</SPAN></A> Originally a <I class=WORDASWORD>Tape ARchiving</I> program, it has developed into a general purpose package that can handle all manner of archiving with all types of destination devices, ranging from tape drives to regular files to even <TT class=FILENAME>stdout</TT> (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX58">Example 3-4</A>). GNU <I class=FIRSTTERM>tar</I> has been patched to accept various compression filters, for example: <B class=COMMAND>tar czvf archive_name.tar.gz *</B>, which recursively archives and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#GZIPREF">gzips</A> all files in a directory tree except <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DOTFILESREF">dotfiles</A> in the current working directory (<A href="http://tldp.org/LDP/abs/html/abs-guide.html#PWDREF">$PWD</A>). <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN11896" name=AEN11896><SPAN class=footnote>[76]</SPAN></A> </P>
<P>Some useful <B class=COMMAND>tar</B> options: 
<P></P>
<OL type=1>
<LI>
<P><TT class=OPTION>-c</TT> create (a new archive)</P>
<LI>
<P><TT class=OPTION>-x</TT> extract (files from existing archive)</P>
<LI>
<P><TT class=OPTION>--delete</TT> delete (files from existing archive)</P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>This option will not work on magnetic tape devices.</P></TD></TR></TBODY></TABLE></DIV>
<LI>
<P><TT class=OPTION>-r</TT> append (files to existing archive)</P>
<LI>
<P><TT class=OPTION>-A</TT> append (<I class=FIRSTTERM>tar</I> files to existing archive)</P>
<LI>
<P><TT class=OPTION>-t</TT> list (contents of existing archive)</P>
<LI>
<P><TT class=OPTION>-u</TT> update archive</P>
<LI>
<P><TT class=OPTION>-d</TT> compare archive with specified filesystem</P>
<LI>
<P><TT class=OPTION>--after-date</TT> only process files with a date stamp <EM>after</EM> specified date</P>
<LI>
<P><TT class=OPTION>-z</TT> <A href="http://tldp.org/LDP/abs/html/abs-guide.html#GZIPREF">gzip</A> the archive</P>
<P>(compress or uncompress, depending on whether combined with the <TT class=OPTION>-c</TT> or <TT class=OPTION>-x</TT>) option</P>
<LI>
<P><TT class=OPTION>-j</TT> <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BZIPREF">bzip2</A> the archive</P></LI></OL>
<P></P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>It may be difficult to recover data from a corrupted <I class=FIRSTTERM>gzipped</I> tar archive. When archiving important files, make multiple backups.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=SHARREF></A><B class=COMMAND>shar</B> 
<DD>
<P><I class=FIRSTTERM>Shell archiving</I> utility. The text and/or binary files in a shell archive are concatenated without compression, and the resultant archive is essentially a shell script, complete with <SPAN class=TOKEN>#!/bin/sh</SPAN> header, containing all the necessary unarchiving commands, as well as the files themselves. Unprintable binary characters in the target file(s) are converted to printable ASCII characters in the output <I class=FIRSTTERM>shar</I> file. <I class=FIRSTTERM>Shar archives</I> still show up in Usenet newsgroups, but otherwise <B class=COMMAND>shar</B> has been replaced by <B class=COMMAND>tar</B>/<B class=COMMAND>gzip</B>. The <B class=COMMAND>unshar</B> command unpacks <I class=FIRSTTERM>shar</I> archives.</P>
<P>The <B class=COMMAND>mailshar</B> command is a Bash script that uses <B class=COMMAND>shar</B> to concatenate multiple files into a single one for e-mailing. This script supports compression and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#UUENCODEREF">uuencoding</A>.</P>
<DT><A name=ARREF></A><B class=COMMAND>ar</B> 
<DD>
<P>Creation and manipulation utility for archives, mainly used for binary object file libraries.</P>
<DT><A name=RPMREF></A><B class=COMMAND>rpm</B> 
<DD>
<P>The <I class=FIRSTTERM>Red Hat Package Manager</I>, or <B class=COMMAND>rpm</B> utility provides a wrapper for source or binary archives. It includes commands for installing and checking the integrity of packages, among other things.</P>
<P>A simple <B class=COMMAND>rpm -i package_name.rpm</B> usually suffices to install a package, though there are many more options available.</P>
<DIV class=TIP>
<P></P>
<TABLE class=TIP border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Tip src="http://tldp.org/LDP/abs/images/tip.gif"></TD>
<TD vAlign=top align=left>
<P><TT class=USERINPUT><B>rpm -qf</B></TT> identifies which package a file originates from.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>rpm -qf /bin/ls</B></TT>
<TT class=COMPUTEROUTPUT>coreutils-5.2.1-31</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P></TD></TR></TBODY></TABLE></DIV>
<DIV class=TIP>
<P></P>
<TABLE class=TIP border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Tip src="http://tldp.org/LDP/abs/images/tip.gif"></TD>
<TD vAlign=top align=left>
<P><TT class=USERINPUT><B>rpm -qa</B></TT> gives a complete list of all installed <I class=FIRSTTERM>rpm</I> packages on a given system. An <TT class=USERINPUT><B>rpm -qa package_name</B></TT> lists only the package(s) corresponding to <TT class=FILENAME>package_name</TT>.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>rpm -qa</B></TT>
<TT class=COMPUTEROUTPUT>redhat-logos-1.1.3-1
 glibc-2.2.4-13
 cracklib-2.7-12
 dosfstools-2.7-1
 gdbm-1.8.0-10
 ksymoops-2.4.1-1
 mktemp-1.5-11
 perl-5.6.0-17
 reiserfs-utils-3.x.0j-2
 ...</TT>


<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>rpm -qa docbook-utils</B></TT>
<TT class=COMPUTEROUTPUT>docbook-utils-0.6.9-2</TT>


<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>rpm -qa docbook | grep docbook</B></TT>
<TT class=COMPUTEROUTPUT>docbook-dtd31-sgml-1.0-10
 docbook-style-dsssl-1.64-3
 docbook-dtd30-sgml-1.0-10
 docbook-dtd40-sgml-1.0-11
 docbook-utils-pdf-0.6.9-2
 docbook-dtd41-sgml-1.0-10
 docbook-utils-0.6.9-2</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=CPIOREF></A><B class=COMMAND>cpio</B> 
<DD>
<P>This specialized archiving copy command (<B class=COMMAND>c</B>o<B class=COMMAND>p</B>y <B class=COMMAND>i</B>nput and <B class=COMMAND>o</B>utput) is rarely seen any more, having been supplanted by <B class=COMMAND>tar</B>/<B class=COMMAND>gzip</B>. It still has its uses, such as moving a directory tree. With an appropriate block size (for copying) specified, it can be appreciably faster than <B class=COMMAND>tar</B>.</P>
<DIV class=EXAMPLE><A name=EX48></A>
<P><B>Example 16-30. Using <I class=FIRSTTERM>cpio</I> to move a directory tree</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

# Copying a directory tree using cpio.

# Advantages of using 'cpio':
#   Speed of copying. It's faster than 'tar' with pipes.
#   Well suited for copying special files (named pipes, etc.)
#+  that 'cp' may choke on.

ARGS=2
E_BADARGS=65

if [ $# -ne "$ARGS" ]
then
  echo "Usage: `basename $0` source destination"
  exit $E_BADARGS
fi  

source="$1"
destination="$2"

###################################################################
find "$source" -depth | cpio -admvp "$destination"
#               ^^^^^         ^^^^^
#  Read the 'find' and 'cpio' info pages to decipher these options.
#  The above works only relative to $PWD (current directory) . . .
#+ full pathnames are specified.
###################################################################


# Exercise:
# --------

#  Add code to check the exit status ($?) of the 'find | cpio' pipe
#+ and output appropriate error messages if anything went wrong.

exit $?</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DT><A name=RPM2CPIOREF></A><B class=COMMAND>rpm2cpio</B> 
<DD>
<P>This command extracts a <B class=COMMAND>cpio</B> archive from an <A href="http://tldp.org/LDP/abs/html/abs-guide.html#RPMREF">rpm</A> one.</P>
<DIV class=EXAMPLE><A name=DERPM></A>
<P><B>Example 16-31. Unpacking an <I class=FIRSTTERM>rpm</I> archive</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# de-rpm.sh: Unpack an 'rpm' archive

: ${1?"Usage: `basename $0` target-file"}
# Must specify 'rpm' archive name as an argument.


TEMPFILE=$$.cpio                         #  Tempfile with "unique" name.
                                         #  $$ is process ID of script.

rpm2cpio &lt; $1 &gt; $TEMPFILE                #  Converts rpm archive into
                                         #+ cpio archive.
cpio --make-directories -F $TEMPFILE -i  #  Unpacks cpio archive.
rm -f $TEMPFILE                          #  Deletes cpio archive.

exit 0

#  Exercise:
#  Add check for whether 1) "target-file" exists and
#+                       2) it is an rpm archive.
#  Hint:                    Parse output of 'file' command.</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DT><A name=PAXREF></A><B class=COMMAND>pax</B> 
<DD>
<P>The <I class=FIRSTTERM>pax</I> <B class=COMMAND>p</B>ortable <B class=COMMAND>a</B>rchive e<B class=COMMAND>x</B>change toolkit facilitates periodic file backups and is designed to be cross-compatible between various flavors of UNIX. It was designed to replace <A href="http://tldp.org/LDP/abs/html/abs-guide.html#TARREF">tar</A> and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#CPIOREF">cpio</A>.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>pax -wf daily_backup.pax ~/linux-server/files 
#  Creates a tar archive of all files in the target directory.
#  Note that the options to pax must be in the correct order --
#+ pax -fw     has an entirely different effect.

pax -f daily_backup.pax
#  Lists the files in the archive.

pax -rf daily_backup.pax ~/bsd-server/files
#  Restores the backed-up files from the Linux machine
#+ onto a BSD one.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>Note that <I class=FIRSTTERM>pax</I> handles many of the standard archiving and compression commands.</P></DD></DL></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=FACOMPRESSION1></A>Compression</B></P>
<DL>
<DT><A name=GZIPREF></A><B class=COMMAND>gzip</B> 
<DD>
<P>The standard GNU/UNIX compression utility, replacing the inferior and proprietary <B class=COMMAND>compress</B>. The corresponding decompression command is <B class=COMMAND>gunzip</B>, which is the equivalent of <B class=COMMAND>gzip -d</B>.</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>The <TT class=OPTION>-c</TT> option sends the output of <B class=COMMAND>gzip</B> to <TT class=FILENAME>stdout</TT>. This is useful when <A href="http://tldp.org/LDP/abs/html/abs-guide.html#PIPEREF">piping</A> to other commands.</P></TD></TR></TBODY></TABLE></DIV>
<P><A name=ZCATREF></A></P>
<P>The <B class=COMMAND>zcat</B> filter decompresses a <I class=FIRSTTERM>gzipped</I> file to <TT class=FILENAME>stdout</TT>, as possible input to a pipe or redirection. This is, in effect, a <B class=COMMAND>cat</B> command that works on compressed files (including files processed with the older <A href="http://tldp.org/LDP/abs/html/abs-guide.html#COMPRESSREF">compress</A> utility). The <B class=COMMAND>zcat</B> command is equivalent to <B class=COMMAND>gzip -dc</B>.</P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>On some commercial UNIX systems, <B class=COMMAND>zcat</B> is a synonym for <B class=COMMAND>uncompress -c</B>, and will not work on <I class=FIRSTTERM>gzipped</I> files.</P></TD></TR></TBODY></TABLE></DIV>
<P>See also <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EX14">Example 7-7</A>.</P>
<DT><A name=BZIPREF></A><B class=COMMAND>bzip2</B> 
<DD>
<P>An alternate compression utility, usually more efficient (but slower) than <B class=COMMAND>gzip</B>, especially on large files. The corresponding decompression command is <B class=COMMAND>bunzip2</B>.</P>
<P>Similar to the <B class=COMMAND>zcat</B> command, <B class=COMMAND>bzcat</B> decompresses a <I class=FIRSTTERM>bzipped2-ed</I> file to <TT class=FILENAME>stdout</TT>.</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>Newer versions of <A href="http://tldp.org/LDP/abs/html/abs-guide.html#TARREF">tar</A> have been patched with <B class=COMMAND>bzip2</B> support.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=COMPRESSREF></A><B class=COMMAND>compress</B>, <A name=UNCOMPRESSREF></A><B class=COMMAND>uncompress</B> 
<DD>
<P>This is an older, proprietary compression utility found in commercial UNIX distributions. The more efficient <B class=COMMAND>gzip</B> has largely replaced it. Linux distributions generally include a <B class=COMMAND>compress</B> workalike for compatibility, although <B class=COMMAND>gunzip</B> can unarchive files treated with <B class=COMMAND>compress</B>.</P>
<DIV class=TIP>
<P></P>
<TABLE class=TIP border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Tip src="http://tldp.org/LDP/abs/images/tip.gif"></TD>
<TD vAlign=top align=left>
<P>The <B class=COMMAND>znew</B> command transforms <I class=FIRSTTERM>compressed</I> files into <I class=FIRSTTERM>gzipped</I> ones.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=SQREF></A><B class=COMMAND>sq</B> 
<DD>
<P>Yet another compression (<B class=COMMAND>sq</B>ueeze) utility, a filter that works only on sorted <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ASCIIDEF">ASCII</A> word lists. It uses the standard invocation syntax for a filter, <B class=COMMAND>sq &lt; input-file &gt; output-file</B>. Fast, but not nearly as efficient as <A href="http://tldp.org/LDP/abs/html/abs-guide.html#GZIPREF">gzip</A>. The corresponding uncompression filter is <B class=COMMAND>unsq</B>, invoked like <B class=COMMAND>sq</B>.</P>
<DIV class=TIP>
<P></P>
<TABLE class=TIP border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Tip src="http://tldp.org/LDP/abs/images/tip.gif"></TD>
<TD vAlign=top align=left>
<P>The output of <B class=COMMAND>sq</B> may be piped to <B class=COMMAND>gzip</B> for further compression.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=ZIPREF></A><B class=COMMAND>zip</B>, <B class=COMMAND>unzip</B> 
<DD>
<P>Cross-platform file archiving and compression utility compatible with DOS <I class=FIRSTTERM>pkzip.exe</I>. <SPAN class=QUOTE>"Zipped"</SPAN> archives seem to be a more common medium of file exchange on the Internet than <SPAN class=QUOTE>"tarballs."</SPAN></P>
<DT><A name=UNARCREF></A><B class=COMMAND>unarc</B>, <B class=COMMAND>unarj</B>, <B class=COMMAND>unrar</B> 
<DD>
<P>These Linux utilities permit unpacking archives compressed with the DOS <I class=FIRSTTERM>arc.exe</I>, <I class=FIRSTTERM>arj.exe</I>, and <I class=FIRSTTERM>rar.exe</I> programs.</P>
<DT><A name=LZMAREF></A><B class=COMMAND>lzma</B>, <B class=COMMAND>unlzma</B>, <B class=COMMAND>lzcat</B> 
<DD>
<P>Highly efficient Lempel-Ziv-Markov compression. The syntax of <I class=FIRSTTERM>lzma</I> is similar to that of <I class=FIRSTTERM>gzip</I>. The <A href="http://www.7-zip.org/sdk.html" target=_top>7-zip Website</A> has more information.</P>
<DT><A name=XZREF></A><B class=COMMAND>xz</B>, <B class=COMMAND>unxz</B>, <B class=COMMAND>xzcat</B> 
<DD>
<P>A new high-efficiency compression tool, backward compatible with <I class=FIRSTTERM>lzma</I>, and with an invocation syntax similar to <I class=FIRSTTERM>gzip</I>. For more information, see the <A href="http://en.wikipedia.org/wiki/Xz" target=_top>Wikipedia entry</A>.</P></DD></DL></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=FAINFORMATION1></A>File Information</B></P>
<DL>
<DT><A name=FILEREF></A><B class=COMMAND>file</B> 
<DD>
<P>A utility for identifying file types. The command <TT class=USERINPUT><B>file file-name</B></TT> will return a file specification for <TT class=FILENAME>file-name</TT>, such as <TT class=COMPUTEROUTPUT>ascii text</TT> or <TT class=COMPUTEROUTPUT>data</TT>. It references the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#MAGNUMREF">magic numbers</A> found in <TT class=FILENAME>/usr/share/magic</TT>, <TT class=FILENAME>/etc/magic</TT>, or <TT class=FILENAME>/usr/lib/magic</TT>, depending on the Linux/UNIX distribution.</P>
<P>The <TT class=OPTION>-f</TT> option causes <B class=COMMAND>file</B> to run in <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BATCHPROCREF">batch</A> mode, to read from a designated file a list of filenames to analyze. The <TT class=OPTION>-z</TT> option, when used on a compressed target file, forces an attempt to analyze the uncompressed file type.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>file test.tar.gz</B></TT>
<TT class=COMPUTEROUTPUT>test.tar.gz: gzip compressed data, deflated,
 last modified: Sun Sep 16 13:34:51 2001, os: Unix</TT>

<TT class=PROMPT>bash </TT><TT class=USERINPUT><B>file -z test.tar.gz</B></TT>
<TT class=COMPUTEROUTPUT>test.tar.gz: GNU tar archive (gzip compressed data, deflated,
 last modified: Sun Sep 16 13:34:51 2001, os: Unix)</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># Find sh and Bash scripts in a given directory:

DIRECTORY=/usr/local/bin
KEYWORD=Bourne
# Bourne and Bourne-Again shell scripts

file $DIRECTORY/* | fgrep $KEYWORD

# Output:

# /usr/local/bin/burn-cd:          Bourne-Again shell script text executable
# /usr/local/bin/burnit:           Bourne-Again shell script text executable
# /usr/local/bin/cassette.sh:      Bourne shell script text executable
# /usr/local/bin/copy-cd:          Bourne-Again shell script text executable
# . . .</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DIV class=EXAMPLE><A name=STRIPC></A>
<P><B>Example 16-32. Stripping comments from C program files</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# strip-comment.sh: Strips out the comments (/* COMMENT */) in a C program.

E_NOARGS=0
E_ARGERROR=66
E_WRONG_FILE_TYPE=67

if [ $# -eq "$E_NOARGS" ]
then
  echo "Usage: `basename $0` C-program-file" &gt;&amp;2 # Error message to stderr.
  exit $E_ARGERROR
fi  

# Test for correct file type.
type=`file $1 | awk '{ print $2, $3, $4, $5 }'`
# "file $1" echoes file type . . .
# Then awk removes the first field, the filename . . .
# Then the result is fed into the variable "type."
correct_type="ASCII C program text"

if [ "$type" != "$correct_type" ]
then
  echo
  echo "This script works on C program files only."
  echo
  exit $E_WRONG_FILE_TYPE
fi  


# Rather cryptic sed script:
#--------
sed '
/^\/\*/d
/.*\*\//d
' $1
#--------
# Easy to understand if you take several hours to learn sed fundamentals.


#  Need to add one more line to the sed script to deal with
#+ case where line of code has a comment following it on same line.
#  This is left as a non-trivial exercise.

#  Also, the above code deletes non-comment lines with a "*/" . . .
#+ not a desirable result.

exit 0


# ----------------------------------------------------------------
# Code below this line will not execute because of 'exit 0' above.

# Stephane Chazelas suggests the following alternative:

usage() {
  echo "Usage: `basename $0` C-program-file" &gt;&amp;2
  exit 1
}

WEIRD=`echo -n -e '\377'`   # or WEIRD=$'\377'
[[ $# -eq 1 ]] || usage
case `file "$1"` in
  *"C program text"*) sed -e "s%/\*%${WEIRD}%g;s%\*/%${WEIRD}%g" "$1" \
     | tr '\377\n' '\n\377' \
     | sed -ne 'p;n' \
     | tr -d '\n' | tr '\377' '\n';;
  *) usage;;
esac

#  This is still fooled by things like:
#  printf("/*");
#  or
#  /*  /* buggy embedded comment */
#
#  To handle all special cases (comments in strings, comments in string
#+ where there is a \", \\" ...),
#+ the only way is to write a C parser (using lex or yacc perhaps?).

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DT><A name=WHICHREF></A><B class=COMMAND>which</B> 
<DD>
<P><B class=COMMAND>which command</B> gives the full path to <SPAN class=QUOTE>"command."</SPAN> This is useful for finding out whether a particular command or utility is installed on the system.</P>
<P><TT class=USERINPUT><B>$bash which rm</B></TT> 
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=COMPUTEROUTPUT>/usr/bin/rm</TT></PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>For an interesting use of this command, see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#HORSERACE">Example 36-16</A>.</P>
<DT><A name=WHEREISREF></A><B class=COMMAND>whereis</B> 
<DD>
<P>Similar to <B class=COMMAND>which</B>, above, <B class=COMMAND>whereis command</B> gives the full path to <SPAN class=QUOTE>"command,"</SPAN> but also to its <A href="http://tldp.org/LDP/abs/html/abs-guide.html#MANREF">manpage</A>.</P>
<P><TT class=USERINPUT><B>$bash whereis rm</B></TT> 
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=COMPUTEROUTPUT>rm: /bin/rm /usr/share/man/man1/rm.1.bz2</TT></PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=WHATISREF></A><B class=COMMAND>whatis</B> 
<DD>
<P><B class=COMMAND>whatis command</B> looks up <SPAN class=QUOTE>"command"</SPAN> in the <TT class=REPLACEABLE><I>whatis</I></TT> database. This is useful for identifying system commands and important configuration files. Consider it a simplified <B class=COMMAND>man</B> command.</P>
<P><TT class=USERINPUT><B>$bash whatis whatis</B></TT> 
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=COMPUTEROUTPUT>whatis               (1)  - search the whatis database for complete words</TT></PRE></FONT></TD></TR></TBODY></TABLE></P>
<DIV class=EXAMPLE><A name=WHAT></A>
<P><B>Example 16-33. Exploring <TT class=FILENAME>/usr/X11R6/bin</TT></B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

# What are all those mysterious binaries in /usr/X11R6/bin?

DIRECTORY="/usr/X11R6/bin"
# Try also "/bin", "/usr/bin", "/usr/local/bin", etc.

for file in $DIRECTORY/*
do
  whatis `basename $file`   # Echoes info about the binary.
done

exit 0

#  Note: For this to work, you must create a "whatis" database
#+ with /usr/sbin/makewhatis.
#  You may wish to redirect output of this script, like so:
#    ./what.sh &gt;&gt;whatis.db
#  or view it a page at a time on stdout,
#    ./what.sh | less</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>See also <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FILEINFO">Example 11-3</A>.</P>
<DT><A name=VDIRREF></A><B class=COMMAND>vdir</B> 
<DD>
<P>Show a detailed directory listing. The effect is similar to <A href="http://tldp.org/LDP/abs/html/abs-guide.html#LSREF">ls -lb</A>.</P>
<P>This is one of the GNU <I class=FIRSTTERM>fileutils</I>.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>vdir</B></TT>
<TT class=COMPUTEROUTPUT>total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</TT>

<TT class=PROMPT>bash </TT><TT class=USERINPUT><B>ls -l</B></TT>
<TT class=COMPUTEROUTPUT>total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=LOCATEREF></A><B class=COMMAND>locate</B>, <A name=SLOCATEREF></A><B class=COMMAND>slocate</B> 
<DD>
<P>The <B class=COMMAND>locate</B> command searches for files using a database stored for just that purpose. The <B class=COMMAND>slocate</B> command is the secure version of <B class=COMMAND>locate</B> (which may be aliased to <B class=COMMAND>slocate</B>).</P>
<P><TT class=USERINPUT><B>$bash locate hickson</B></TT> 
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=COMPUTEROUTPUT>/usr/lib/xephem/catalogs/hickson.edb</TT></PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=GETFACLREF></A><B class=COMMAND>getfacl</B>, <A name=SETFACLREF></A><B class=COMMAND>setfacl</B> 
<DD>
<P>These commands <I class=FIRSTTERM>retrieve</I> or <I class=FIRSTTERM>set</I> the <B class=COMMAND>f</B>ile <B class=COMMAND>a</B>ccess <B class=COMMAND>c</B>ontrol <B class=COMMAND>l</B>ist -- the <I class=FIRSTTERM>owner</I>, <I class=FIRSTTERM>group</I>, and file permissions.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>getfacl *</B></TT>
<TT class=COMPUTEROUTPUT># file: test1.txt
 # owner: bozo
 # group: bozgrp
 user::rw-
 group::rw-
 other::r--

 # file: test2.txt
 # owner: bozo
 # group: bozgrp
 user::rw-
 group::rw-
 other::r--</TT>
 

 
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>setfacl -m u:bozo:rw yearly_budget.csv</B></TT>
<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>getfacl yearly_budget.csv</B></TT>
<TT class=COMPUTEROUTPUT># file: yearly_budget.csv
 # owner: accountant
 # group: budgetgrp
 user::rw-
 user:bozo:rw-
 user:accountant:rw-
 group::rw-
 mask::rw-
 other::r--</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=READLINKREF></A><B class=COMMAND>readlink</B> 
<DD>
<P>Disclose the file that a symbolic link points to.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>readlink /usr/bin/awk</B></TT>
<TT class=COMPUTEROUTPUT>../../bin/gawk</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=STRINGSREF></A><B class=COMMAND>strings</B> 
<DD>
<P>Use the <B class=COMMAND>strings</B> command to find printable strings in a binary or data file. It will list sequences of printable characters found in the target file. This might be handy for a quick 'n dirty examination of a core dump or for looking at an unknown graphic image file (<TT class=USERINPUT><B>strings image-file | more</B></TT> might show something like <I class=FIRSTTERM>JFIF</I>, which would identify the file as a <I class=FIRSTTERM>jpeg</I> graphic). In a script, you would probably parse the output of <B class=COMMAND>strings</B> with <A href="http://tldp.org/LDP/abs/html/abs-guide.html#GREPREF">grep</A> or <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SEDREF">sed</A>. See <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BINGREP">Example 11-8</A> and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FINDSTRING">Example 11-10</A>.</P>
<DIV class=EXAMPLE><A name=WSTRINGS></A>
<P><B>Example 16-34. An <SPAN class=QUOTE>"improved"</SPAN> <I class=FIRSTTERM>strings</I> command</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# wstrings.sh: "word-strings" (enhanced "strings" command)
#
#  This script filters the output of "strings" by checking it
#+ against a standard word list file.
#  This effectively eliminates gibberish and noise,
#+ and outputs only recognized words.

# ===========================================================
#                 Standard Check for Script Argument(s)
ARGS=1
E_BADARGS=85
E_NOFILE=86

if [ $# -ne $ARGS ]
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi

if [ ! -f "$1" ]                      # Check if file exists.
then
    echo "File \"$1\" does not exist."
    exit $E_NOFILE
fi
# ===========================================================


MINSTRLEN=3                           #  Minimum string length.
WORDFILE=/usr/share/dict/linux.words  #  Dictionary file.
#  May specify a different word list file
#+ of one-word-per-line format.
#  For example, the "yawl" word-list package,
#  http://bash.deta.in/yawl-0.3.2.tar.gz


wlist=`strings "$1" | tr A-Z a-z | tr '[:space:]' Z | \
       tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`

# Translate output of 'strings' command with multiple passes of 'tr'.
#  "tr A-Z a-z"  converts to lowercase.
#  "tr '[:space:]'"  converts whitespace characters to Z's.
#  "tr -cs '[:alpha:]' Z"  converts non-alphabetic characters to Z's,
#+ and squeezes multiple consecutive Z's.
#  "tr -s '\173-\377' Z"  converts all characters past 'z' to Z's
#+ and squeezes multiple consecutive Z's,
#+ which gets rid of all the weird characters that the previous
#+ translation failed to deal with.
#  Finally, "tr Z ' '" converts all those Z's to whitespace,
#+ which will be seen as word separators in the loop below.

#  ***********************************************************************
#  Note the technique of feeding/piping the output of 'tr' back to itself,
#+ but with different arguments and/or options on each successive pass.
#  ***********************************************************************


for word in $wlist                    #  Important:
                                      #  $wlist must not be quoted here.
                                      # "$wlist" does not work.
                                      #  Why not?
do
  strlen=${#word}                     #  String length.
  if [ "$strlen" -lt "$MINSTRLEN" ]   #  Skip over short strings.
  then
    continue
  fi

  grep -Fw $word "$WORDFILE"          #   Match whole words only.
#      ^^^                            #  "Fixed strings" and
                                      #+ "whole words" options. 
done  

exit $?</PRE></FONT></TD></TR></TBODY></TABLE></DIV></DD></DL></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=COMPARISONN1></A>Comparison</B></P>
<DL>
<DT><A name=DIFFREF></A><B class=COMMAND>diff</B>, <B class=COMMAND>patch</B> 
<DD>
<P><B class=COMMAND>diff</B>: flexible file comparison utility. It compares the target files line-by-line sequentially. In some applications, such as comparing word dictionaries, it may be helpful to filter the files through <A href="http://tldp.org/LDP/abs/html/abs-guide.html#SORTREF">sort</A> and <B class=COMMAND>uniq</B> before piping them to <B class=COMMAND>diff</B>. <TT class=USERINPUT><B>diff file-1 file-2</B></TT> outputs the lines in the files that differ, with carets showing which file each particular line belongs to.</P>
<P>The <TT class=OPTION>--side-by-side</TT> option to <B class=COMMAND>diff</B> outputs each compared file, line by line, in separate columns, with non-matching lines marked. The <TT class=OPTION>-c</TT> and <TT class=OPTION>-u</TT> options likewise make the output of the command easier to interpret.</P>
<P>There are available various fancy frontends for <B class=COMMAND>diff</B>, such as <B class=COMMAND>sdiff</B>, <B class=COMMAND>wdiff</B>, <B class=COMMAND>xdiff</B>, and <B class=COMMAND>mgdiff</B>. </P>
<DIV class=TIP>
<P></P>
<TABLE class=TIP border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Tip src="http://tldp.org/LDP/abs/images/tip.gif"></TD>
<TD vAlign=top align=left>
<P><A name=DIFFERR2></A>The <B class=COMMAND>diff</B> command returns an exit status of <SPAN class=ERRORCODE>0</SPAN> if the compared files are identical, and <SPAN class=ERRORCODE>1</SPAN> if they differ (or <SPAN class=ERRORCODE>2</SPAN> when <I class=FIRSTTERM>binary</I> files are being compared). This permits use of <B class=COMMAND>diff</B> in a test construct within a shell script (see below).</P></TD></TR></TBODY></TABLE></DIV>
<P>A common use for <B class=COMMAND>diff</B> is generating difference files to be used with <B class=COMMAND>patch</B> The <TT class=OPTION>-e</TT> option outputs files suitable for <B class=COMMAND>ed</B> or <B class=COMMAND>ex</B> scripts.</P>
<P><A name=PATCHREF></A></P>
<P><B class=COMMAND>patch</B>: flexible versioning utility. Given a difference file generated by <B class=COMMAND>diff</B>, <B class=COMMAND>patch</B> can upgrade a previous version of a package to a newer version. It is much more convenient to distribute a relatively small <SPAN class=QUOTE>"diff"</SPAN> file than the entire body of a newly revised package. Kernel <SPAN class=QUOTE>"patches"</SPAN> have become the preferred method of distributing the frequent releases of the Linux kernel.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>patch -p1 &lt;patch-file
# Takes all the changes listed in 'patch-file'
# and applies them to the files referenced therein.
# This upgrades to a newer version of the package.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>Patching the kernel:</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>cd /usr/src
gzip -cd patchXX.gz | patch -p0
# Upgrading kernel source using 'patch'.
# From the Linux kernel docs "README",
# by anonymous author (Alan Cox?).</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>The <B class=COMMAND>diff</B> command can also recursively compare directories (for the filenames present).</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>diff -r ~/notes1 ~/notes2</B></TT>
<TT class=COMPUTEROUTPUT>Only in /home/bozo/notes1: file02
 Only in /home/bozo/notes1: file03
 Only in /home/bozo/notes2: file04</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P></TD></TR></TBODY></TABLE></DIV>
<DIV class=TIP>
<P></P>
<TABLE class=TIP border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Tip src="http://tldp.org/LDP/abs/images/tip.gif"></TD>
<TD vAlign=top align=left>
<P><A name=ZDIFFREF></A></P>
<P>Use <B class=COMMAND>zdiff</B> to compare <I class=FIRSTTERM>gzipped</I> files.</P></TD></TR></TBODY></TABLE></DIV>
<DIV class=TIP>
<P></P>
<TABLE class=TIP border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Tip src="http://tldp.org/LDP/abs/images/tip.gif"></TD>
<TD vAlign=top align=left>
<P><A name=DIFFSTATREF></A></P>
<P>Use <B class=COMMAND>diffstat</B> to create a histogram (point-distribution graph) of output from <B class=COMMAND>diff</B>.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=DIFF3REF></A><B class=COMMAND>diff3</B>, <B class=COMMAND>merge</B> 
<DD>
<P>An extended version of <B class=COMMAND>diff</B> that compares three files at a time. This command returns an exit value of 0 upon successful execution, but unfortunately this gives no information about the results of the comparison.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>diff3 file-1 file-2 file-3</B></TT>
<TT class=COMPUTEROUTPUT>====
 1:1c
   This is line 1 of "file-1".
 2:1c
   This is line 1 of "file-2".
 3:1c
   This is line 1 of "file-3"</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P><A name=MERGEREF></A>The <B class=COMMAND>merge</B> (3-way file merge) command is an interesting adjunct to <I class=FIRSTTERM>diff3</I>. Its syntax is <TT class=USERINPUT><B>merge Mergefile file1 file2</B></TT>. The result is to output to <TT class=FILENAME>Mergefile</TT> the changes that lead from <TT class=FILENAME>file1</TT> to <TT class=FILENAME>file2</TT>. Consider this command a stripped-down version of <I class=FIRSTTERM>patch</I>.</P>
<DT><A name=SDIFFREF></A><B class=COMMAND>sdiff</B> 
<DD>
<P>Compare and/or edit two files in order to merge them into an output file. Because of its interactive nature, this command would find little use in a script.</P>
<DT><A name=CMPREF></A><B class=COMMAND>cmp</B> 
<DD>
<P>The <B class=COMMAND>cmp</B> command is a simpler version of <B class=COMMAND>diff</B>, above. Whereas <B class=COMMAND>diff</B> reports the differences between two files, <B class=COMMAND>cmp</B> merely shows at what point they differ.</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>Like <B class=COMMAND>diff</B>, <B class=COMMAND>cmp</B> returns an exit status of 0 if the compared files are identical, and 1 if they differ. This permits use in a test construct within a shell script.</P></TD></TR></TBODY></TABLE></DIV>
<DIV class=EXAMPLE><A name=FILECOMP></A>
<P><B>Example 16-35. Using <I class=FIRSTTERM>cmp</I> to compare two files within a script.</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# file-comparison.sh

ARGS=2  # Two args to script expected.
E_BADARGS=85
E_UNREADABLE=86

if [ $# -ne "$ARGS" ]
then
  echo "Usage: `basename $0` file1 file2"
  exit $E_BADARGS
fi

if [[ ! -r "$1" || ! -r "$2" ]]
then
  echo "Both files to be compared must exist and be readable."
  exit $E_UNREADABLE
fi

cmp $1 $2 &amp;&gt; /dev/null
#   Redirection to /dev/null buries the output of the "cmp" command.
#   cmp -s $1 $2  has same result ("-s" silent flag to "cmp")
#   Thank you  Anders Gustavsson for pointing this out.
#
#  Also works with 'diff', i.e.,
#+ diff $1 $2 &amp;&gt; /dev/null

if [ $? -eq 0 ]         # Test exit status of "cmp" command.
then
  echo "File \"$1\" is identical to file \"$2\"."
else  
  echo "File \"$1\" differs from file \"$2\"."
fi

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DIV class=TIP>
<P></P>
<TABLE class=TIP border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Tip src="http://tldp.org/LDP/abs/images/tip.gif"></TD>
<TD vAlign=top align=left>
<P>Use <B class=COMMAND>zcmp</B> on <I class=FIRSTTERM>gzipped</I> files.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=COMMREF></A><B class=COMMAND>comm</B> 
<DD>
<P>Versatile file comparison utility. The files must be sorted for this to be useful.</P>
<P><B class=COMMAND>comm <TT class=REPLACEABLE><I>-options</I></TT> <TT class=REPLACEABLE><I>first-file</I></TT> <TT class=REPLACEABLE><I>second-file</I></TT></B></P>
<P><TT class=USERINPUT><B>comm file-1 file-2</B></TT> outputs three columns: 
<P></P>
<UL>
<LI>
<P>column 1 = lines unique to <TT class=FILENAME>file-1</TT></P>
<LI>
<P>column 2 = lines unique to <TT class=FILENAME>file-2</TT></P>
<LI>
<P>column 3 = lines common to both.</P></LI></UL>
<P></P>
<P>The options allow suppressing output of one or more columns. 
<P></P>
<UL>
<LI>
<P><TT class=OPTION>-1</TT> suppresses column <TT class=LITERAL>1</TT></P>
<LI>
<P><TT class=OPTION>-2</TT> suppresses column <TT class=LITERAL>2</TT></P>
<LI>
<P><TT class=OPTION>-3</TT> suppresses column <TT class=LITERAL>3</TT></P>
<LI>
<P><TT class=OPTION>-12</TT> suppresses both columns <TT class=LITERAL>1</TT> and <TT class=LITERAL>2</TT>, etc.</P></LI></UL>
<P></P>
<P>This command is useful for comparing <SPAN class=QUOTE>"dictionaries"</SPAN> or <I class=FIRSTTERM>word lists</I> -- sorted text files with one word per line.</P></DD></DL></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=FAUTILS1></A>Utilities</B></P>
<DL>
<DT><A name=BASENAMEREF></A><B class=COMMAND>basename</B> 
<DD>
<P>Strips the path information from a file name, printing only the file name. The construction <TT class=USERINPUT><B>basename $0</B></TT> lets the script know its name, that is, the name it was invoked by. This can be used for <SPAN class=QUOTE>"usage"</SPAN> messages if, for example a script is called with missing arguments: 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>echo "Usage: `basename $0` arg1 arg2 ... argn"</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=DIRNAMEREF></A><B class=COMMAND>dirname</B> 
<DD>
<P>Strips the <B class=COMMAND>basename</B> from a filename, printing only the path information.</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P><B class=COMMAND>basename</B> and <B class=COMMAND>dirname</B> can operate on any arbitrary string. The argument does not need to refer to an existing file, or even be a filename for that matter (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DAYSBETWEEN">Example A-7</A>).</P></TD></TR></TBODY></TABLE></DIV>
<DIV class=EXAMPLE><A name=EX35></A>
<P><B>Example 16-36. <I class=FIRSTTERM>basename</I> and <I class=FIRSTTERM>dirname</I></B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

address=/home/bozo/daily-journal.txt

echo "Basename of /home/bozo/daily-journal.txt = `basename $address`"
echo "Dirname of /home/bozo/daily-journal.txt = `dirname $address`"
echo
echo "My own home is `basename ~/`."         # `basename ~` also works.
echo "The home of my home is `dirname ~/`."  # `dirname ~`  also works.

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DT><A name=SPLITREF></A><B class=COMMAND>split</B>, <A name=CSPLITREF></A><B class=COMMAND>csplit</B> 
<DD>
<P>These are utilities for splitting a file into smaller chunks. Their usual use is for splitting up large files in order to back them up on floppies or preparatory to e-mailing or uploading them.</P>
<P>The <B class=COMMAND>csplit</B> command splits a file according to <I class=FIRSTTERM>context</I>, the split occuring where patterns are matched.</P>
<DIV class=EXAMPLE><A name=SPLITCOPY></A>
<P><B>Example 16-37. A script that copies itself in sections</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# splitcopy.sh

#  A script that splits itself into chunks,
#+ then reassembles the chunks into an exact copy
#+ of the original script.

CHUNKSIZE=4    #  Size of first chunk of split files.
OUTPREFIX=xx   #  csplit prefixes, by default,
               #+ files with "xx" ...

csplit "$0" "$CHUNKSIZE"

# Some comment lines for padding . . .
# Line 15
# Line 16
# Line 17
# Line 18
# Line 19
# Line 20

cat "$OUTPREFIX"* &gt; "$0.copy"  # Concatenate the chunks.
rm "$OUTPREFIX"*               # Get rid of the chunks.

exit $?</PRE></FONT></TD></TR></TBODY></TABLE></DIV></DD></DL></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=FAENCENCR1></A>Encoding and Encryption</B></P>
<DL>
<DT><A name=SUMREF></A><B class=COMMAND>sum</B>, <A name=CKSUMREF></A><B class=COMMAND>cksum</B>, <A name=MD5SUMREF></A><B class=COMMAND>md5sum</B>, <A name=SHA1SUMREF></A><B class=COMMAND>sha1sum</B> 
<DD>
<P><A name=CHECKSUMREF></A>These are utilities for generating <I class=FIRSTTERM>checksums</I>. A <I class=FIRSTTERM>checksum</I> is a number <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN12840" name=AEN12840><SPAN class=footnote>[77]</SPAN></A> mathematically calculated from the contents of a file, for the purpose of checking its integrity. A script might refer to a list of checksums for security purposes, such as ensuring that the contents of key system files have not been altered or corrupted. For security applications, use the <B class=COMMAND>md5sum</B> (<B class=COMMAND>m</B>essage <B class=COMMAND>d</B>igest <B class=COMMAND>5</B> check<B class=COMMAND>sum</B>) command, or better yet, the newer <B class=COMMAND>sha1sum</B> (Secure Hash Algorithm). <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN12849" name=AEN12849><SPAN class=footnote>[78]</SPAN></A> </P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>cksum /boot/vmlinuz</B></TT>
<TT class=COMPUTEROUTPUT>1670054224 804083 /boot/vmlinuz</TT>

<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo -n "Top Secret" | cksum</B></TT>
<TT class=COMPUTEROUTPUT>3391003827 10</TT>



<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>md5sum /boot/vmlinuz</B></TT>
<TT class=COMPUTEROUTPUT>0f43eccea8f09e0a0b2b5cf1dcf333ba  /boot/vmlinuz</TT>

<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>echo -n "Top Secret" | md5sum</B></TT>
<TT class=COMPUTEROUTPUT>8babc97a6f62a4649716f4df8d61728f  -</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>The <B class=COMMAND>cksum</B> command shows the size, in bytes, of its target, whether file or <TT class=FILENAME>stdout</TT>.</P>
<P>The <B class=COMMAND>md5sum</B> and <B class=COMMAND>sha1sum</B> commands display a <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DASHREF2">dash</A> when they receive their input from <TT class=FILENAME>stdout</TT>.</P></TD></TR></TBODY></TABLE></DIV>
<DIV class=EXAMPLE><A name=FILEINTEGRITY></A>
<P><B>Example 16-38. Checking file integrity</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# file-integrity.sh: Checking whether files in a given directory
#                    have been tampered with.

E_DIR_NOMATCH=80
E_BAD_DBFILE=81

dbfile=File_record.md5
# Filename for storing records (database file).


set_up_database ()
{
  echo ""$directory"" &gt; "$dbfile"
  # Write directory name to first line of file.
  md5sum "$directory"/* &gt;&gt; "$dbfile"
  # Append md5 checksums and filenames.
}

check_database ()
{
  local n=0
  local filename
  local checksum

  # ------------------------------------------- #
  #  This file check should be unnecessary,
  #+ but better safe than sorry.

  if [ ! -r "$dbfile" ]
  then
    echo "Unable to read checksum database file!"
    exit $E_BAD_DBFILE
  fi
  # ------------------------------------------- #

  while read record[n]
  do

    directory_checked="${record[0]}"
    if [ "$directory_checked" != "$directory" ]
    then
      echo "Directories do not match up!"
      # Tried to use file for a different directory.
      exit $E_DIR_NOMATCH
    fi

    if [ "$n" -gt 0 ]   # Not directory name.
    then
      filename[n]=$( echo ${record[$n]} | awk '{ print $2 }' )
      #  md5sum writes records backwards,
      #+ checksum first, then filename.
      checksum[n]=$( md5sum "${filename[n]}" )


      if [ "${record[n]}" = "${checksum[n]}" ]
      then
        echo "${filename[n]} unchanged."

        elif [ "`basename ${filename[n]}`" != "$dbfile" ]
               #  Skip over checksum database file,
               #+ as it will change with each invocation of script.
               #  ---
               #  This unfortunately means that when running
               #+ this script on $PWD, tampering with the
               #+ checksum database file will not be detected.
               #  Exercise: Fix this.
        then
          echo "${filename[n]} : CHECKSUM ERROR!"
        # File has been changed since last checked.
        fi

      fi



    let "n+=1"
  done &lt;"$dbfile"       # Read from checksum database file. 

}  

# =================================================== #
# main ()

if [ -z  "$1" ]
then
  directory="$PWD"      #  If not specified,
else                    #+ use current working directory.
  directory="$1"
fi  

clear                   # Clear screen.
echo " Running file integrity check on $directory"
echo

# ------------------------------------------------------------------ #
  if [ ! -r "$dbfile" ] # Need to create database file?
  then
    echo "Setting up database file, \""$directory"/"$dbfile"\"."; echo
    set_up_database
  fi  
# ------------------------------------------------------------------ #

check_database          # Do the actual work.

echo 

#  You may wish to redirect the stdout of this script to a file,
#+ especially if the directory checked has many files in it.

exit 0

#  For a much more thorough file integrity check,
#+ consider the "Tripwire" package,
#+ http://sourceforge.net/projects/tripwire/.</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P>Also see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DIRECTORYINFO">Example A-19</A>, <A href="http://tldp.org/LDP/abs/html/abs-guide.html#HORSERACE">Example 36-16</A>, and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#RANDSTRING">Example 10-2</A> for creative uses of the <B class=COMMAND>md5sum</B> command.</P>
<DIV class=NOTE>
<P></P>
<TABLE class=NOTE border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Note src="http://tldp.org/LDP/abs/images/note.gif"></TD>
<TD vAlign=top align=left>
<P>There have been reports that the 128-bit <B class=COMMAND>md5sum</B> can be cracked, so the more secure 160-bit <B class=COMMAND>sha1sum</B> is a welcome new addition to the checksum toolkit. </P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>md5sum testfile</B></TT>
<TT class=COMPUTEROUTPUT>e181e2c8720c60522c4c4c981108e367  testfile</TT>


<TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>sha1sum testfile</B></TT>
<TT class=COMPUTEROUTPUT>5d7425a9c08a66c3177f1e31286fa40986ffc996  testfile</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></DIV>
<P>Security consultants have demonstrated that even <B class=COMMAND>sha1sum</B> can be compromised. Fortunately, newer Linux distros include longer bit-length <B class=COMMAND>sha224sum</B>, <B class=COMMAND>sha256sum</B>, <B class=COMMAND>sha384sum</B>, and <B class=COMMAND>sha512sum</B> commands.</P>
<DT><A name=UUENCODEREF></A><B class=COMMAND>uuencode</B> 
<DD>
<P>This utility encodes binary files (images, sound files, compressed files, etc.) into <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ASCIIDEF">ASCII</A> characters, making them suitable for transmission in the body of an e-mail message or in a newsgroup posting. This is especially useful where MIME (multimedia) encoding is not available.</P>
<DT><A name=UUDECODEREF></A><B class=COMMAND>uudecode</B> 
<DD>
<P>This reverses the encoding, decoding <I class=FIRSTTERM>uuencoded</I> files back into the original binaries.</P>
<DIV class=EXAMPLE><A name=EX52></A>
<P><B>Example 16-39. Uudecoding encoded files</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# Uudecodes all uuencoded files in current working directory.

lines=35        # Allow 35 lines for the header (very generous).

for File in *   # Test all the files in $PWD.
do
  search1=`head -n $lines $File | grep begin | wc -w`
  search2=`tail -n $lines $File | grep end | wc -w`
  #  Uuencoded files have a "begin" near the beginning,
  #+ and an "end" near the end.
  if [ "$search1" -gt 0 ]
  then
    if [ "$search2" -gt 0 ]
    then
      echo "uudecoding - $File -"
      uudecode $File
    fi  
  fi
done  

#  Note that running this script upon itself fools it
#+ into thinking it is a uuencoded file,
#+ because it contains both "begin" and "end".

#  Exercise:
#  --------
#  Modify this script to check each file for a newsgroup header,
#+ and skip to next if not found.

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<DIV class=TIP>
<P></P>
<TABLE class=TIP border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Tip src="http://tldp.org/LDP/abs/images/tip.gif"></TD>
<TD vAlign=top align=left>
<P>The <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FOLDREF">fold -s</A> command may be useful (possibly in a pipe) to process long uudecoded text messages downloaded from Usenet newsgroups.</P></TD></TR></TBODY></TABLE></DIV>
<DT><A name=MIMENCODEREF></A><B class=COMMAND>mimencode</B>, <A name=MMENCODEREF></A><B class=COMMAND>mmencode</B> 
<DD>
<P>The <B class=COMMAND>mimencode</B> and <B class=COMMAND>mmencode</B> commands process multimedia-encoded e-mail attachments. Although <I class=FIRSTTERM>mail user agents</I> (such as <I class=FIRSTTERM>pine</I> or <I class=FIRSTTERM>kmail</I>) normally handle this automatically, these particular utilities permit manipulating such attachments manually from the command-line or in <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BATCHPROCREF">batch processing mode</A> by means of a shell script.</P>
<DT><A name=CRYPTREF></A><B class=COMMAND>crypt</B> 
<DD>
<P>At one time, this was the standard UNIX file encryption utility. <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN12969" name=AEN12969><SPAN class=footnote>[79]</SPAN></A> Politically-motivated government regulations prohibiting the export of encryption software resulted in the disappearance of <B class=COMMAND>crypt</B> from much of the UNIX world, and it is still missing from most Linux distributions. Fortunately, programmers have come up with a number of decent alternatives to it, among them the author's very own <A href="ftp://metalab.unc.edu/pub/Linux/utils/file/cruft-0.2.tar.gz" target=_top>cruft</A> (see <A href="http://tldp.org/LDP/abs/html/abs-guide.html#ENCRYPTEDPW">Example A-4</A>). </P>
<DT><A name=OPENSSLREF></A><B class=COMMAND>openssl</B> 
<DD>
<P>This is an Open Source implementation of <I class=FIRSTTERM>Secure Sockets Layer</I> encryption. 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># To encrypt a file:
openssl aes-128-ecb -salt -in file.txt -out file.encrypted \
-pass pass:my_password
#          ^^^^^^^^^^^   User-selected password.
#       aes-128-ecb      is the encryption method chosen.

# To decrypt an openssl-encrypted file:
openssl aes-128-ecb -d -salt -in file.encrypted -out file.txt \
-pass pass:my_password
#          ^^^^^^^^^^^   User-selected password.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P><A href="http://tldp.org/LDP/abs/html/abs-guide.html#PIPEREF">Piping</A> <I class=FIRSTTERM>openssl</I> to/from <A href="http://tldp.org/LDP/abs/html/abs-guide.html#TARREF">tar</A> makes it possible to encrypt an entire directory tree. 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># To encrypt a directory:

sourcedir="/home/bozo/testfiles"
encrfile="encr-dir.tar.gz"
password=my_secret_password

tar czvf - "$sourcedir" |
openssl des3 -salt -out "$encrfile" -pass pass:"$password"
#       ^^^^   Uses des3 encryption.
# Writes encrypted file "encr-dir.tar.gz" in current working directory.

# To decrypt the resulting tarball:
openssl des3 -d -salt -in "$encrfile" -pass pass:"$password" |
tar -xzv
# Decrypts and unpacks into current working directory.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>Of course, <I class=FIRSTTERM>openssl</I> has many other uses, such as obtaining signed <I class=FIRSTTERM>certificates</I> for Web sites. See the <A href="http://tldp.org/LDP/abs/html/abs-guide.html#INFOREF">info</A> page.</P>
<DT><A name=SHREDREF></A><B class=COMMAND>shred</B> 
<DD>
<P>Securely erase a file by overwriting it multiple times with random bit patterns before deleting it. This command has the same effect as <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BLOTOUT">Example 16-61</A>, but does it in a more thorough and elegant manner.</P>
<P>This is one of the GNU <I class=FIRSTTERM>fileutils</I>.</P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>Advanced forensic technology may still be able to recover the contents of a file, even after application of <B class=COMMAND>shred</B>.</P></TD></TR></TBODY></TABLE></DIV></DD></DL></DIV>
<P></P>
<DIV class=VARIABLELIST>
<P><B><A name=FAMISC1></A>Miscellaneous</B></P>
<DL>
<DT><A name=MKTEMPREF></A><B class=COMMAND>mktemp</B> 
<DD>
<P>Create a <I class=FIRSTTERM>temporary file</I> <A href="http://tldp.org/LDP/abs/html/abs-guide.html#FTN.AEN13030" name=AEN13030><SPAN class=footnote>[80]</SPAN></A> with a <SPAN class=QUOTE>"unique"</SPAN> filename. When invoked from the command-line without additional arguments, it creates a zero-length file in the <TT class=FILENAME>/tmp</TT> directory.</P>
<P>
<TABLE border=1 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=SCREEN><TT class=PROMPT>bash$ </TT><TT class=USERINPUT><B>mktemp</B></TT>
<TT class=COMPUTEROUTPUT>/tmp/tmp.zzsvql3154</TT>
	      </PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>PREFIX=filename
tempfile=`mktemp $PREFIX.XXXXXX`
#                        ^^^^^^ Need at least 6 placeholders
#+                              in the filename template.
#   If no filename template supplied,
#+ "tmp.XXXXXXXXXX" is the default.

echo "tempfile name = $tempfile"
# tempfile name = filename.QA2ZpY
#                 or something similar...

#  Creates a file of that name in the current working directory
#+ with 600 file permissions.
#  A "umask 177" is therefore unnecessary,
#+ but it's good programming practice nevertheless.</PRE></FONT></TD></TR></TBODY></TABLE></P>
<DT><A name=MAKEREF></A><B class=COMMAND>make</B> 
<DD>
<P><A name=MAKEFILEREF></A></P>
<P>Utility for building and compiling binary packages. This can also be used for any set of operations triggered by incremental changes in source files.</P>
<P>The <I class=FIRSTTERM>make</I> command checks a <TT class=FILENAME>Makefile</TT>, a list of file dependencies and operations to be carried out.</P>
<P>The <I class=FIRSTTERM>make</I> utility is, in effect, a powerful scripting language similar in many ways to <I class=FIRSTTERM>Bash</I>, but with the capability of recognizing <I class=FIRSTTERM>dependencies</I>. For in-depth coverage of this useful tool set, see the <A href="http://www.gnu.org/manual/manual.html" target=_top>GNU software documentation site</A>.</P>
<DT><A name=INSTALLREF></A><B class=COMMAND>install</B> 
<DD>
<P>Special purpose file copying command, similar to <A href="http://tldp.org/LDP/abs/html/abs-guide.html#CPREF">cp</A>, but capable of setting permissions and attributes of the copied files. This command seems tailormade for installing software packages, and as such it shows up frequently in <TT class=FILENAME>Makefiles</TT> (in the <TT class=REPLACEABLE><I>make install :</I></TT> section). It could likewise prove useful in installation scripts.</P>
<DT><A name=DOS2UNIXREF></A><B class=COMMAND>dos2unix</B> 
<DD>
<P>This utility, written by Benjamin Lin and collaborators, converts DOS-formatted text files (lines terminated by CR-LF) to UNIX format (lines terminated by LF only), and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#DOSNEWLINES">vice-versa</A>.</P>
<DT><A name=PTXREF></A><B class=COMMAND>ptx</B> 
<DD>
<P>The <B class=COMMAND>ptx [targetfile]</B> command outputs a permuted index (cross-reference list) of the targetfile. This may be further filtered and formatted in a pipe, if necessary.</P>
<DT><A name=MOREREF></A><B class=COMMAND>more</B>, <A name=LESSREF></A><B class=COMMAND>less</B> 
<DD>
<P>Pagers that display a text file or stream to <TT class=FILENAME>stdout</TT>, one screenful at a time. These may be used to filter the output of <TT class=FILENAME>stdout</TT> . . . or of a script.</P>
<P>An interesting application of <I class=FIRSTTERM>more</I> is to <SPAN class=QUOTE>"test drive"</SPAN> a command sequence, to forestall potentially unpleasant consequences. 
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>ls /home/bozo | awk '{print "rm -rf " $1}' | more
#                                            ^^^^
		 
# Testing the effect of the following (disastrous) command-line:
#      ls /home/bozo | awk '{print "rm -rf " $1}' | sh
#      Hand off to the shell to execute . . .       ^^</PRE></FONT></TD></TR></TBODY></TABLE></P>
<P>The <I class=FIRSTTERM>less</I> pager has the interesting property of doing a formatted display of <I class=FIRSTTERM>man page</I> source. See <A href="http://tldp.org/LDP/abs/html/abs-guide.html#MANED">Example A-39</A>.</P></DD></DL></DIV>