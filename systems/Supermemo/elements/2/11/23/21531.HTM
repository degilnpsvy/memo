<H1 class=SECT1><A name=VARASSIGNMENT></A>4.2. Variable Assignment</H1>
<P></P>
<DIV class=VARIABLELIST>
<DL>
<DT><A name=EQREF></A><SPAN class=TOKEN>=</SPAN> 
<DD>
<P>the assignment operator (<EM>no space before and after</EM>)</P>
<DIV class=CAUTION>
<P></P>
<TABLE class=CAUTION border=0 width="90%">
<TBODY>
<TR>
<TD vAlign=top width=25 align=middle><IMG hspace=5 alt=Caution src="http://tldp.org/LDP/abs/images/caution.gif"></TD>
<TD vAlign=top align=left>
<P>Do not confuse this with <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EQUALSIGNREF">=</A> and <A href="http://tldp.org/LDP/abs/html/abs-guide.html#EQUALREF">-eq</A>, which <A href="http://tldp.org/LDP/abs/html/abs-guide.html#IFTHEN">test</A>, rather than assign!</P>
<P>Note that <SPAN class=TOKEN>=</SPAN> can be either an <I class=FIRSTTERM>assignment</I> or a <I class=FIRSTTERM>test</I> operator, depending on context.</P></TD></TR></TBODY></TABLE></DIV>
<P><A name=EX15_0></A></P>
<DIV class=EXAMPLE><A name=EX15></A>
<P><B>Example 4-2. Plain Variable Assignment</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash
# Naked variables

echo

# When is a variable "naked", i.e., lacking the '$' in front?
# When it is being assigned, rather than referenced.

# Assignment
a=879
echo "The value of \"a\" is $a."

# Assignment using 'let'
let a=16+5
echo "The value of \"a\" is now $a."

echo

# In a 'for' loop (really, a type of disguised assignment):
echo -n "Values of \"a\" in the loop are: "
for a in 7 8 9 11
do
  echo -n "$a "
done

echo
echo

# In a 'read' statement (also a type of assignment):
echo -n "Enter \"a\" "
read a
echo "The value of \"a\" is now $a."

echo

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P><A name=EX16_0></A></P>
<DIV class=EXAMPLE><A name=EX16></A>
<P><B>Example 4-3. Variable Assignment, plain and fancy</B></P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING>#!/bin/bash

a=23              # Simple case
echo $a
b=$a
echo $b

# Now, getting a little bit fancier (command substitution).

a=`echo Hello!`   # Assigns result of 'echo' command to 'a' ...
echo $a
#  Note that including an exclamation mark (!) within a
#+ command substitution construct will not work from the command-line,
#+ since this triggers the Bash "history mechanism."
#  Inside a script, however, the history functions are disabled by default.

a=`ls -l`         # Assigns result of 'ls -l' command to 'a'
echo $a           # Unquoted, however, it removes tabs and newlines.
echo
echo "$a"         # The quoted variable preserves whitespace.
                  # (See the chapter on "Quoting.")

exit 0</PRE></FONT></TD></TR></TBODY></TABLE></DIV>
<P><A name=COMMANDSUBREF0></A></P>
<P>Variable assignment using the <I class=FIRSTTERM>$(...)</I> mechanism (a newer method than <A href="http://tldp.org/LDP/abs/html/abs-guide.html#BACKQUOTESREF">backquotes</A>). This is likewise a form of <A href="http://tldp.org/LDP/abs/html/abs-guide.html#COMMANDSUBREF">command substitution</A>.</P>
<P>
<TABLE border=0 width="90%" bgColor=#e0e0e0>
<TBODY>
<TR>
<TD><FONT color=#000000><PRE class=PROGRAMLISTING># From /etc/rc.d/rc.local
R=$(cat /etc/redhat-release)
arch=$(uname -m)</PRE></FONT></TD></TR></TBODY></TABLE></P></DD></DL></DIV>