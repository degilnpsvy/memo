=== 6 Architecture Makefiles 
<P><FONT class=extract>The top level Makefile sets up the environment and does the preparation,<BR>before starting to descend down in the individual directories.<BR>The top level makefile contains the generic part, whereas<BR>arch/$(ARCH)/Makefile contains what is required to set up kbuild<BR>for said architecture.<BR></FONT>To do so, arch/$(ARCH)/Makefile sets up a number of variables and defines<BR>a few targets.;</P>
<P><FONT class=extract>When kbuild executes, the following steps are followed (roughly):<BR>1) Configuration of the kernel =&gt; produce .config<BR>2) Store kernel version in include/linux/version.h<BR>3) Symlink include/asm to include/asm-$(ARCH)<BR>4) Updating all other prerequisites to the target prepare:<BR>&nbsp;&nbsp; - Additional prerequisites are specified in arch/$(ARCH)/Makefile<BR>5) Recursively descend down in all directories listed in<BR>&nbsp;&nbsp; init-* core* drivers-* net-* libs-* and build all targets.<BR>&nbsp;&nbsp; - The values of the above variables are expanded in arch/$(ARCH)/Makefile.<BR>6) All object files are then linked and the resulting file vmlinux is<BR>&nbsp;&nbsp; located at the root of the obj tree.<BR>&nbsp;&nbsp; The very first objects linked are listed in head-y, assigned by<BR>&nbsp;&nbsp; arch/$(ARCH)/Makefile.<BR>7) Finally, the architecture-specific part does any required post processing<BR>&nbsp;&nbsp; and builds the final bootimage.<BR>&nbsp;&nbsp; - This includes building boot records<BR>&nbsp;&nbsp; - Preparing initrd images and the like</FONT></P>
<P><BR><FONT class=extract>--- 6.1 Set variables to tweak the build to the architecture</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; LDFLAGS&nbsp;&nbsp;Generic $(LD) options</FONT></P>
<P><FONT class=extract>&nbsp;Flags used for all invocations of the linker.<BR>&nbsp;Often specifying the emulation is sufficient.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#arch/s390/Makefile<BR>&nbsp;&nbsp;LDFLAGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := -m elf_s390<BR>&nbsp;Note: ldflags-y can be used to further customise<BR>&nbsp;the flags used. See chapter 3.7.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; LDFLAGS_MODULE&nbsp;Options for $(LD) when linking modules</FONT></P>
<P><FONT class=extract>&nbsp;LDFLAGS_MODULE is used to set specific flags for $(LD) when<BR>&nbsp;linking the .ko files used for modules.<BR>&nbsp;Default is "-r", for relocatable output.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; LDFLAGS_vmlinux&nbsp;Options for $(LD) when linking vmlinux</FONT></P>
<P><FONT class=extract>&nbsp;LDFLAGS_vmlinux is used to specify additional flags to pass to<BR>&nbsp;the linker when linking the final vmlinux image.<BR>&nbsp;LDFLAGS_vmlinux uses the LDFLAGS_$@ support.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#arch/x86/Makefile<BR>&nbsp;&nbsp;LDFLAGS_vmlinux := -e stext</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; OBJCOPYFLAGS&nbsp;objcopy flags</FONT></P>
<P><FONT class=extract>&nbsp;When $(call if_changed,objcopy) is used to translate a .o file,<BR>&nbsp;the flags specified in OBJCOPYFLAGS will be used.<BR>&nbsp;$(call if_changed,objcopy) is often used to generate raw binaries on<BR>&nbsp;vmlinux.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#arch/s390/Makefile<BR>&nbsp;&nbsp;OBJCOPYFLAGS := -O binary</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;#arch/s390/boot/Makefile<BR>&nbsp;&nbsp;$(obj)/image: vmlinux FORCE<BR>&nbsp;&nbsp;&nbsp;$(call if_changed,objcopy)</FONT></P>
<P><FONT class=extract>&nbsp;In this example, the binary $(obj)/image is a binary version of<BR>&nbsp;vmlinux. The usage of $(call if_changed,xxx) will be described later.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; KBUILD_AFLAGS&nbsp;&nbsp;$(AS) assembler flags</FONT></P>
<P><FONT class=extract>&nbsp;Default value - see top level Makefile<BR>&nbsp;Append or modify as required per architecture.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#arch/sparc64/Makefile<BR>&nbsp;&nbsp;KBUILD_AFLAGS += -m64 -mcpu=ultrasparc</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; KBUILD_CFLAGS&nbsp;&nbsp;$(CC) compiler flags</FONT></P>
<P><FONT class=extract>&nbsp;Default value - see top level Makefile<BR>&nbsp;Append or modify as required per architecture.</FONT></P>
<P><FONT class=extract>&nbsp;Often, the KBUILD_CFLAGS variable depends on the configuration.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#arch/x86/boot/compressed/Makefile<BR>&nbsp;&nbsp;cflags-$(CONFIG_X86_32) := -march=i386<BR>&nbsp;&nbsp;cflags-$(CONFIG_X86_64) := -mcmodel=small<BR>&nbsp;&nbsp;KBUILD_CFLAGS += $(cflags-y)</FONT></P>
<P><FONT class=extract>&nbsp;Many arch Makefiles dynamically run the target C compiler to<BR>&nbsp;probe supported options:</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;#arch/x86/Makefile</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;...<BR>&nbsp;&nbsp;cflags-$(CONFIG_MPENTIUMII)&nbsp;&nbsp;&nbsp;&nbsp; += $(call cc-option,\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-march=pentium2,-march=i686)<BR>&nbsp;&nbsp;...<BR>&nbsp;&nbsp;# Disable unit-at-a-time mode ...<BR>&nbsp;&nbsp;KBUILD_CFLAGS += $(call cc-option,-fno-unit-at-a-time)<BR>&nbsp;&nbsp;...</FONT></P>
<P><BR><FONT class=extract>&nbsp;The first example utilises the trick that a config option expands<BR>&nbsp;to 'y' when selected.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; KBUILD_AFLAGS_KERNEL&nbsp;$(AS) options specific for built-in</FONT></P>
<P><FONT class=extract>&nbsp;$(KBUILD_AFLAGS_KERNEL) contains extra C compiler flags used to compile<BR>&nbsp;resident kernel code.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; KBUILD_AFLAGS_MODULE&nbsp;&nbsp; Options for $(AS) when building modules</FONT></P>
<P><FONT class=extract>&nbsp;$(KBUILD_AFLAGS_MODULE) is used to add arch specific options that<BR>&nbsp;are used for $(AS).<BR>&nbsp;From commandline AFLAGS_MODULE shall be used (see kbuild.txt).</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; KBUILD_CFLAGS_KERNEL&nbsp;$(CC) options specific for built-in</FONT></P>
<P><FONT class=extract>&nbsp;$(KBUILD_CFLAGS_KERNEL) contains extra C compiler flags used to compile<BR>&nbsp;resident kernel code.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; KBUILD_CFLAGS_MODULE&nbsp;&nbsp; Options for $(CC) when building modules</FONT></P>
<P><FONT class=extract>&nbsp;$(KBUILD_CFLAGS_MODULE) is used to add arch specific options that<BR>&nbsp;are used for $(CC).<BR>&nbsp;From commandline CFLAGS_MODULE shall be used (see kbuild.txt).</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; KBUILD_LDFLAGS_MODULE&nbsp;&nbsp; Options for $(LD) when linking modules</FONT></P>
<P><FONT class=extract>&nbsp;$(KBUILD_LDFLAGS_MODULE) is used to add arch specific options<BR>&nbsp;used when linking modules. This is often a linker script.<BR>&nbsp;From commandline LDFLAGS_MODULE shall be used (see kbuild.txt).</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; KBUILD_ARFLAGS&nbsp;&nbsp; Options for $(AR) when creating archives</FONT></P>
<P><FONT class=extract>&nbsp;$(KBUILD_ARFLAGS) set by the top level Makefile to "D" (deterministic<BR>&nbsp;mode) if this option is supported by $(AR).</FONT></P>
<P><FONT class=extract>--- 6.2 Add prerequisites to archheaders:</FONT></P>
<P><FONT class=extract>&nbsp;The archheaders: rule is used to generate header files that<BR>&nbsp;may be installed into user space by "make header_install" or<BR>&nbsp;"make headers_install_all".&nbsp; In order to support<BR>&nbsp;"make headers_install_all", this target has to be able to run<BR>&nbsp;on an unconfigured tree, or a tree configured for another<BR>&nbsp;architecture.</FONT></P>
<P><FONT class=extract>&nbsp;It is run before "make archprepare" when run on the<BR>&nbsp;architecture itself.</FONT></P>
<P><BR><FONT class=extract>--- 6.3 Add prerequisites to archprepare:</FONT></P>
<P><FONT class=extract>&nbsp;The archprepare: rule is used to list prerequisites that need to be<BR>&nbsp;built before starting to descend down in the subdirectories.<BR>&nbsp;This is usually used for header files containing assembler constants.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;Example:<BR>&nbsp;&nbsp;#arch/arm/Makefile<BR>&nbsp;&nbsp;archprepare: maketools</FONT></P>
<P><FONT class=extract>&nbsp;In this example, the file target maketools will be processed<BR>&nbsp;before descending down in the subdirectories.<BR>&nbsp;See also chapter XXX-TODO that describe how kbuild supports<BR>&nbsp;generating offset header files.</FONT></P>
<P><BR><FONT class=extract>--- 6.4 List directories to visit when descending</FONT></P>
<P><FONT class=extract>&nbsp;An arch Makefile cooperates with the top Makefile to define variables<BR>&nbsp;which specify how to build the vmlinux file.&nbsp; Note that there is no<BR>&nbsp;corresponding arch-specific section for modules; the module-building<BR>&nbsp;machinery is all architecture-independent.</FONT></P>
<P><BR><FONT class=extract>&nbsp;&nbsp;&nbsp; head-y, init-y, core-y, libs-y, drivers-y, net-y</FONT></P>
<P><FONT class=extract>&nbsp;$(head-y) lists objects to be linked first in vmlinux.<BR>&nbsp;$(libs-y) lists directories where a lib.a archive can be located.<BR>&nbsp;The rest list directories where a built-in.o object file can be<BR>&nbsp;located.</FONT></P>
<P><FONT class=extract>&nbsp;$(init-y) objects will be located after $(head-y).<BR>&nbsp;Then the rest follows in this order:<BR>&nbsp;$(core-y), $(libs-y), $(drivers-y) and $(net-y).</FONT></P>
<P><FONT class=extract>&nbsp;The top level Makefile defines values for all generic directories,<BR>&nbsp;and arch/$(ARCH)/Makefile only adds architecture-specific directories.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#arch/sparc64/Makefile<BR>&nbsp;&nbsp;core-y += arch/sparc64/kernel/<BR>&nbsp;&nbsp;libs-y += arch/sparc64/prom/ arch/sparc64/lib/<BR>&nbsp;&nbsp;drivers-$(CONFIG_OPROFILE)&nbsp; += arch/sparc64/oprofile/</FONT></P>
<P><BR><FONT class=extract>--- 6.5 Architecture-specific boot images</FONT></P>
<P><FONT class=extract>&nbsp;An arch Makefile specifies goals that take the vmlinux file, compress<BR>&nbsp;it, wrap it in bootstrapping code, and copy the resulting files<BR>&nbsp;somewhere. This includes various kinds of installation commands.<BR>&nbsp;The actual goals are not standardized across architectures.</FONT></P>
<P><FONT class=extract>&nbsp;It is common to locate any additional processing in a boot/<BR>&nbsp;directory below arch/$(ARCH)/.</FONT></P>
<P><FONT class=extract>&nbsp;Kbuild does not provide any smart way to support building a<BR>&nbsp;target specified in boot/. Therefore arch/$(ARCH)/Makefile shall<BR>&nbsp;call make manually to build a target in boot/.</FONT></P>
<P><FONT class=extract>&nbsp;The recommended approach is to include shortcuts in<BR>&nbsp;arch/$(ARCH)/Makefile, and use the full path when calling down<BR>&nbsp;into the arch/$(ARCH)/boot/Makefile.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#arch/x86/Makefile<BR>&nbsp;&nbsp;boot := arch/x86/boot<BR>&nbsp;&nbsp;bzImage: vmlinux<BR>&nbsp;&nbsp;&nbsp;$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@</FONT></P>
<P><FONT class=extract>&nbsp;"$(Q)$(MAKE) $(build)=&lt;dir&gt;" is the recommended way to invoke<BR>&nbsp;make in a subdirectory.</FONT></P>
<P><FONT class=extract>&nbsp;There are no rules for naming architecture-specific targets,<BR>&nbsp;but executing "make help" will list all relevant targets.<BR>&nbsp;To support this, $(archhelp) must be defined.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#arch/x86/Makefile<BR>&nbsp;&nbsp;define archhelp<BR>&nbsp;&nbsp;&nbsp; echo&nbsp; '* bzImage&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Image (arch/$(ARCH)/boot/bzImage)'<BR>&nbsp;&nbsp;endif</FONT></P>
<P><FONT class=extract>&nbsp;When make is executed without arguments, the first goal encountered<BR>&nbsp;will be built. In the top level Makefile the first goal present<BR>&nbsp;is all:.<BR>&nbsp;An architecture shall always, per default, build a bootable image.<BR>&nbsp;In "make help", the default goal is highlighted with a '*'.<BR>&nbsp;Add a new prerequisite to all: to select a default goal different<BR>&nbsp;from vmlinux.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#arch/x86/Makefile<BR>&nbsp;&nbsp;all: bzImage</FONT></P>
<P><FONT class=extract>&nbsp;When "make" is executed without arguments, bzImage will be built.</FONT></P>
<P><FONT class=extract>--- 6.6 Building non-kbuild targets</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; extra-y</FONT></P>
<P><FONT class=extract>&nbsp;extra-y specify additional targets created in the current<BR>&nbsp;directory, in addition to any targets specified by obj-*.</FONT></P>
<P><FONT class=extract>&nbsp;Listing all targets in extra-y is required for two purposes:<BR>&nbsp;1) Enable kbuild to check changes in command lines<BR>&nbsp;&nbsp;&nbsp; - When $(call if_changed,xxx) is used<BR>&nbsp;2) kbuild knows what files to delete during "make clean"</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#arch/x86/kernel/Makefile<BR>&nbsp;&nbsp;extra-y := head.o init_task.o</FONT></P>
<P><FONT class=extract>&nbsp;In this example, extra-y is used to list object files that<BR>&nbsp;shall be built, but shall not be linked as part of built-in.o.</FONT></P>
<P><BR><FONT class=extract>--- 6.7 Commands useful for building a boot image</FONT></P>
<P><FONT class=extract>&nbsp;Kbuild provides a few macros that are useful when building a<BR>&nbsp;boot image.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if_changed</FONT></P>
<P><FONT class=extract>&nbsp;if_changed is the infrastructure used for the following commands.</FONT></P>
<P><FONT class=extract>&nbsp;Usage:<BR>&nbsp;&nbsp;target: source(s) FORCE<BR>&nbsp;&nbsp;&nbsp;$(call if_changed,ld/objcopy/gzip)</FONT></P>
<P><FONT class=extract>&nbsp;When the rule is evaluated, it is checked to see if any files<BR>&nbsp;need an update, or the command line has changed since the last<BR>&nbsp;invocation. The latter will force a rebuild if any options<BR>&nbsp;to the executable have changed.<BR>&nbsp;Any target that utilises if_changed must be listed in $(targets),<BR>&nbsp;otherwise the command line check will fail, and the target will<BR>&nbsp;always be built.<BR>&nbsp;Assignments to $(targets) are without $(obj)/ prefix.<BR>&nbsp;if_changed may be used in conjunction with custom commands as<BR>&nbsp;defined in 6.8 "Custom kbuild commands".</FONT></P>
<P><FONT class=extract>&nbsp;Note: It is a typical mistake to forget the FORCE prerequisite.<BR>&nbsp;Another common pitfall is that whitespace is sometimes<BR>&nbsp;significant; for instance, the below will fail (note the extra space<BR>&nbsp;after the comma):<BR>&nbsp;&nbsp;target: source(s) FORCE<BR>&nbsp;#WRONG!#&nbsp;$(call if_changed, ld/objcopy/gzip)</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; ld<BR>&nbsp;Link target. Often, LDFLAGS_$@ is used to set specific options to ld.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; objcopy<BR>&nbsp;Copy binary. Uses OBJCOPYFLAGS usually specified in<BR>&nbsp;arch/$(ARCH)/Makefile.<BR>&nbsp;OBJCOPYFLAGS_$@ may be used to set additional options.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; gzip<BR>&nbsp;Compress target. Use maximum compression to compress target.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#arch/x86/boot/Makefile<BR>&nbsp;&nbsp;LDFLAGS_bootsect := -Ttext 0x0 -s --oformat binary<BR>&nbsp;&nbsp;LDFLAGS_setup&nbsp;&nbsp;&nbsp; := -Ttext 0x0 -s --oformat binary -e begtext</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;targets += setup setup.o bootsect bootsect.o<BR>&nbsp;&nbsp;$(obj)/setup $(obj)/bootsect: %: %.o FORCE<BR>&nbsp;&nbsp;&nbsp;$(call if_changed,ld)</FONT></P>
<P><FONT class=extract>&nbsp;In this example, there are two possible targets, requiring different<BR>&nbsp;options to the linker. The linker options are specified using the<BR>&nbsp;LDFLAGS_$@ syntax - one for each potential target.<BR>&nbsp;$(targets) are assigned all potential targets, by which kbuild knows<BR>&nbsp;the targets and will:<BR>&nbsp;&nbsp;1) check for commandline changes<BR>&nbsp;&nbsp;2) delete target during make clean</FONT></P>
<P><FONT class=extract>&nbsp;The ": %: %.o" part of the prerequisite is a shorthand that<BR>&nbsp;free us from listing the setup.o and bootsect.o files.<BR>&nbsp;Note: It is a common mistake to forget the "target :=" assignment,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resulting in the target file being recompiled for no<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obvious reason.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; dtc<BR>&nbsp;Create flattened device tree blob object suitable for linking<BR>&nbsp;into vmlinux. Device tree blobs linked into vmlinux are placed<BR>&nbsp;in an init section in the image. Platform code *must* copy the<BR>&nbsp;blob to non-init memory prior to calling unflatten_device_tree().</FONT></P>
<P><FONT class=extract>&nbsp;To use this command, simply add *.dtb into obj-y or targets, or make<BR>&nbsp;some other target depend on %.dtb</FONT></P>
<P><FONT class=extract>&nbsp;A central rule exists to create $(obj)/%.dtb from $(src)/%.dts;<BR>&nbsp;architecture Makefiles do no need to explicitly write out that rule.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;targets += $(dtb-y)<BR>&nbsp;&nbsp;clean-files += *.dtb<BR>&nbsp;&nbsp;DTC_FLAGS ?= -p 1024</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; dtc_cpp<BR>&nbsp;This is just like dtc as describe above, except that the C pre-<BR>&nbsp;processor is invoked upon the .dtsp file before compiling the result<BR>&nbsp;with dtc.</FONT></P>
<P><FONT class=extract>&nbsp;In order for build dependencies to work, all files compiled using<BR>&nbsp;dtc_cpp must use the C pre-processor's #include functionality and not<BR>&nbsp;dtc's /include/ functionality.</FONT></P>
<P><FONT class=extract>&nbsp;Using the C pre-processor allows use of #define to create named<BR>&nbsp;constants. In turn, the #defines will typically appear in a header<BR>&nbsp;file, which may be shared with regular C code. Since the dtc language<BR>&nbsp;represents a data structure rather than code in C syntax, similar<BR>&nbsp;restrictions are placed on a header file included by a device tree<BR>&nbsp;file as for a header file included by an assembly language file.<BR>&nbsp;In particular, the C pre-processor is passed -x assembler-with-cpp,<BR>&nbsp;which sets macro __ASSEMBLY__. __DTS__ is also set. These allow header<BR>&nbsp;files to restrict their content to that compatible with device tree<BR>&nbsp;source.</FONT></P>
<P><FONT class=extract>&nbsp;A central rule exists to create $(obj)/%.dtb from $(src)/%.dtsp;<BR>&nbsp;architecture Makefiles do no need to explicitly write out that rule.</FONT></P>
<P><FONT class=extract>--- 6.8 Custom kbuild commands</FONT></P>
<P><FONT class=extract>&nbsp;When kbuild is executing with KBUILD_VERBOSE=0, then only a shorthand<BR>&nbsp;of a command is normally displayed.<BR>&nbsp;To enable this behaviour for custom commands kbuild requires<BR>&nbsp;two variables to be set:<BR>&nbsp;quiet_cmd_&lt;command&gt;&nbsp;- what shall be echoed<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd_&lt;command&gt;&nbsp;- the command to execute</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#<BR>&nbsp;&nbsp;quiet_cmd_image = BUILD&nbsp;&nbsp; $@<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd_image = $(obj)/tools/build $(BUILDFLAGS) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(obj)/vmlinux.bin &gt; $@</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;targets += bzImage<BR>&nbsp;&nbsp;$(obj)/bzImage: $(obj)/vmlinux.bin $(obj)/tools/build FORCE<BR>&nbsp;&nbsp;&nbsp;$(call if_changed,image)<BR>&nbsp;&nbsp;&nbsp;@echo 'Kernel: $@ is ready'</FONT></P>
<P><FONT class=extract>&nbsp;When updating the $(obj)/bzImage target, the line</FONT></P>
<P><FONT class=extract>&nbsp;BUILD&nbsp;&nbsp;&nbsp; arch/x86/boot/bzImage</FONT></P>
<P><FONT class=extract>&nbsp;will be displayed with "make KBUILD_VERBOSE=0".</FONT></P>
<P><BR><FONT class=extract>--- 6.9 Preprocessing linker scripts</FONT></P>
<P><FONT class=extract>&nbsp;When the vmlinux image is built, the linker script<BR>&nbsp;arch/$(ARCH)/kernel/vmlinux.lds is used.<BR>&nbsp;The script is a preprocessed variant of the file vmlinux.lds.S<BR>&nbsp;located in the same directory.<BR>&nbsp;kbuild knows .lds files and includes a rule *lds.S -&gt; *lds.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#arch/x86/kernel/Makefile<BR>&nbsp;&nbsp;always := vmlinux.lds</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;#Makefile<BR>&nbsp;&nbsp;export CPPFLAGS_vmlinux.lds += -P -C -U$(ARCH)</FONT></P>
<P><FONT class=extract>&nbsp;The assignment to $(always) is used to tell kbuild to build the<BR>&nbsp;target vmlinux.lds.<BR>&nbsp;The assignment to $(CPPFLAGS_vmlinux.lds) tells kbuild to use the<BR>&nbsp;specified options when building the target vmlinux.lds.</FONT></P>
<P><FONT class=extract>&nbsp;When building the *.lds target, kbuild uses the variables:<BR>&nbsp;KBUILD_CPPFLAGS&nbsp;: Set in top-level Makefile<BR>&nbsp;cppflags-y&nbsp;: May be set in the kbuild makefile<BR>&nbsp;CPPFLAGS_$(@F)&nbsp; : Target specific flags.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note that the full filename is used in this<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assignment.</FONT></P>
<P><FONT class=extract>&nbsp;The kbuild infrastructure for *lds file are used in several<BR>&nbsp;architecture-specific files.</FONT></P>
<P><FONT class=extract>--- 6.10 Generic header files</FONT></P>
<P><FONT class=extract>&nbsp;The directory include/asm-generic contains the header files<BR>&nbsp;that may be shared between individual architectures.<BR>&nbsp;The recommended approach how to use a generic header file is<BR>&nbsp;to list the file in the Kbuild file.<BR>&nbsp;See "7.4 generic-y" for further info on syntax etc.</FONT>