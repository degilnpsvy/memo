kconfig-language.txt<BR>&nbsp;- specification of Config Language, the language in Kconfig files 
<P></P>
<P>Introduction<BR>------------</P>
<P></P>
<P>The configuration database is a collection of configuration options<BR>organized in a tree structure:</P>
<P>&nbsp;+- Code maturity level options<BR>&nbsp;|&nbsp; +- Prompt for development and/or incomplete code/drivers<BR>&nbsp;+- General setup<BR>&nbsp;|&nbsp; +- Networking support<BR>&nbsp;|&nbsp; +- System V IPC<BR>&nbsp;|&nbsp; +- BSD Process Accounting<BR>&nbsp;|&nbsp; +- Sysctl support<BR>&nbsp;+- Loadable module support<BR>&nbsp;|&nbsp; +- Enable loadable module support<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; +- Set version information on all module symbols<BR>&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; +- Kernel module loader<BR>&nbsp;+- ...</P>
<P>Every entry has its own dependencies. These dependencies are used<BR>to determine the visibility of an entry. Any child entry is only<BR>visible if its parent entry is also visible.</P>
<P><FONT class=extract>Menu entries<BR>------------</FONT></P>
<P><FONT class=extract>Most entries define a config option; all other entries help to organize<BR>them. A single configuration option is defined like this:</FONT></P>
<P><FONT class=extract>config MODVERSIONS<BR>&nbsp;bool "Set version information on all module symbols"<BR>&nbsp;depends on MODULES<BR>&nbsp;help<BR>&nbsp;&nbsp; Usually, modules have to be recompiled whenever you switch to a new<BR>&nbsp;&nbsp; kernel.&nbsp; ...</FONT></P>
<P><FONT class=extract>Every line starts with a key word and can be followed by multiple<BR>arguments.&nbsp; "config" starts a new config entry. The following lines<BR>define attributes for this config option. Attributes can be the type of<BR>the config option, input prompt, dependencies, help text and default<BR>values. A config option can be defined multiple times with the same<BR>name, but every definition can have only a single input prompt and the<BR>type must not conflict.</FONT></P>
<P><FONT class=extract>Menu attributes<BR>---------------</FONT></P>
<P><FONT class=extract>A menu entry can have a number of attributes. Not all of them are<BR>applicable everywhere (see syntax).</FONT></P>
<P><FONT class=extract>- type definition: "bool"/"tristate"/"string"/"hex"/"int"<BR>&nbsp; Every config option must have a type. There are only two basic types:<BR>&nbsp; tristate and string; the other types are based on these two. The type<BR>&nbsp; definition optionally accepts an input prompt, so these two examples<BR>&nbsp; are equivalent:</FONT></P>
<P><FONT class=extract>&nbsp;bool "Networking support"<BR>&nbsp; and<BR>&nbsp;bool<BR>&nbsp;prompt "Networking support"</FONT></P>
<P><FONT class=extract>- input prompt: "prompt" &lt;prompt&gt; ["if" &lt;expr&gt;]<BR>&nbsp; Every menu entry can have at most one prompt, which is used to display<BR>&nbsp; to the user. Optionally dependencies only for this prompt can be added<BR>&nbsp; with "if".</FONT></P>
<P><FONT class=extract>- default value: "default" &lt;expr&gt; ["if" &lt;expr&gt;]<BR>&nbsp; A config option can have any number of default values. If multiple<BR>&nbsp; default values are visible, only the first defined one is active.<BR>&nbsp; Default values are not limited to the menu entry where they are<BR>&nbsp; defined. This means the default can be defined somewhere else or be<BR>&nbsp; overridden by an earlier definition.<BR>&nbsp; The default value is only assigned to the config symbol if no other<BR>&nbsp; value was set by the user (via the input prompt above). If an input<BR>&nbsp; prompt is visible the default value is presented to the user and can<BR>&nbsp; be overridden by him.<BR>&nbsp; Optionally, dependencies only for this default value can be added with<BR>&nbsp; "if".</FONT></P>
<P><FONT class=extract>- type definition + default value:<BR>&nbsp;"def_bool"/"def_tristate" &lt;expr&gt; ["if" &lt;expr&gt;]<BR>&nbsp; This is a shorthand notation for a type definition plus a value.<BR>&nbsp; Optionally dependencies for this default value can be added with "if".</FONT></P>
<P><FONT class=extract>- dependencies: "depends on" &lt;expr&gt;<BR>&nbsp; This defines a dependency for this menu entry. If multiple<BR>&nbsp; dependencies are defined, they are connected with '&amp;&amp;'. Dependencies<BR>&nbsp; are applied to all other options within this menu entry (which also<BR>&nbsp; accept an "if" expression), so these two examples are equivalent:</FONT></P>
<P><FONT class=extract>&nbsp;bool "foo" if BAR<BR>&nbsp;default y if BAR<BR>&nbsp; and<BR>&nbsp;depends on BAR<BR>&nbsp;bool "foo"<BR>&nbsp;default y</FONT></P>
<P><FONT class=extract>- reverse dependencies: "select" &lt;symbol&gt; ["if" &lt;expr&gt;]<BR>&nbsp; While normal dependencies reduce the upper limit of a symbol (see<BR>&nbsp; below), reverse dependencies can be used to force a lower limit of<BR>&nbsp; another symbol. The value of the current menu symbol is used as the<BR>&nbsp; minimal value &lt;symbol&gt; can be set to. If &lt;symbol&gt; is selected multiple<BR>&nbsp; times, the limit is set to the largest selection.<BR>&nbsp; Reverse dependencies can only be used with boolean or tristate<BR>&nbsp; symbols.<BR>&nbsp; Note:<BR>&nbsp;select should be used with care. select will force<BR>&nbsp;a symbol to a value without visiting the dependencies.<BR>&nbsp;By abusing select you are able to select a symbol FOO even<BR>&nbsp;if FOO depends on BAR that is not set.<BR>&nbsp;In general use select only for non-visible symbols<BR>&nbsp;(no prompts anywhere) and for symbols with no dependencies.<BR>&nbsp;That will limit the usefulness but on the other hand avoid<BR>&nbsp;the illegal configurations all over.</FONT></P>
<P><FONT class=extract>- limiting menu display: "visible if" &lt;expr&gt;<BR>&nbsp; This attribute is only applicable to menu blocks, if the condition is<BR>&nbsp; false, the menu block is not displayed to the user (the symbols<BR>&nbsp; contained there can still be selected by other symbols, though). It is<BR>&nbsp; similar to a conditional "prompt" attribute for individual menu<BR>&nbsp; entries. Default value of "visible" is true.</FONT></P>
<P><FONT class=extract>- numerical ranges: "range" &lt;symbol&gt; &lt;symbol&gt; ["if" &lt;expr&gt;]<BR>&nbsp; This allows to limit the range of possible input values for int<BR>&nbsp; and hex symbols. The user can only input a value which is larger than<BR>&nbsp; or equal to the first symbol and smaller than or equal to the second<BR>&nbsp; symbol.</FONT></P>
<P><FONT class=extract>- help text: "help" or "---help---"<BR>&nbsp; This defines a help text. The end of the help text is determined by<BR>&nbsp; the indentation level, this means it ends at the first line which has<BR>&nbsp; a smaller indentation than the first line of the help text.<BR>&nbsp; "---help---" and "help" do not differ in behaviour, "---help---" is<BR>&nbsp; used to help visually separate configuration logic from help within<BR>&nbsp; the file as an aid to developers.</FONT></P>
<P><FONT class=extract>- misc options: "option" &lt;symbol&gt;[=&lt;value&gt;]<BR>&nbsp; Various less common options can be defined via this option syntax,<BR>&nbsp; which can modify the behaviour of the menu entry and its config<BR>&nbsp; symbol. These options are currently possible:</FONT></P>
<P><FONT class=extract>&nbsp; - "defconfig_list"<BR>&nbsp;&nbsp;&nbsp; This declares a list of default entries which can be used when<BR>&nbsp;&nbsp;&nbsp; looking for the default configuration (which is used when the main<BR>&nbsp;&nbsp;&nbsp; .config doesn't exists yet.)</FONT></P>
<P><FONT class=extract>&nbsp; - "modules"<BR>&nbsp;&nbsp;&nbsp; This declares the symbol to be used as the MODULES symbol, which<BR>&nbsp;&nbsp;&nbsp; enables the third modular state for all config symbols.<BR>&nbsp;&nbsp;&nbsp; At most one symbol may have the "modules" option set.</FONT></P>
<P><FONT class=extract>&nbsp; - "env"=&lt;value&gt;<BR>&nbsp;&nbsp;&nbsp; This imports the environment variable into Kconfig. It behaves like<BR>&nbsp;&nbsp;&nbsp; a default, except that the value comes from the environment, this<BR>&nbsp;&nbsp;&nbsp; also means that the behaviour when mixing it with normal defaults is<BR>&nbsp;&nbsp;&nbsp; undefined at this point. The symbol is currently not exported back<BR>&nbsp;&nbsp;&nbsp; to the build environment (if this is desired, it can be done via<BR>&nbsp;&nbsp;&nbsp; another symbol).</FONT></P>
<P><FONT class=extract>&nbsp; - "allnoconfig_y"<BR>&nbsp;&nbsp;&nbsp; This declares the symbol as one that should have the value y when<BR>&nbsp;&nbsp;&nbsp; using "allnoconfig". Used for symbols that hide other symbols.</FONT></P>
<P><FONT class=extract>Menu dependencies<BR>-----------------</FONT></P>
<P><FONT class=extract>Dependencies define the visibility of a menu entry and can also reduce<BR>the input range of tristate symbols. The tristate logic used in the<BR>expressions uses one more state than normal boolean logic to express the<BR>module state. Dependency expressions have the following syntax:</FONT></P>
<P><FONT class=extract>&lt;expr&gt; ::= &lt;symbol&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;symbol&gt; '=' &lt;symbol&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;symbol&gt; '!=' &lt;symbol&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '(' &lt;expr&gt; ')'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (4)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '!' &lt;expr&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (5)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;expr&gt; '&amp;&amp;' &lt;expr&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (6)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;expr&gt; '||' &lt;expr&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (7)</FONT></P>
<P><FONT class=extract>Expressions are listed in decreasing order of precedence. </FONT></P>
<P><FONT class=extract>(1) Convert the symbol into an expression. Boolean and tristate symbols<BR>&nbsp;&nbsp;&nbsp; are simply converted into the respective expression values. All<BR>&nbsp;&nbsp;&nbsp; other symbol types result in 'n'.<BR>(2) If the values of both symbols are equal, it returns 'y',<BR>&nbsp;&nbsp;&nbsp; otherwise 'n'.<BR>(3) If the values of both symbols are equal, it returns 'n',<BR>&nbsp;&nbsp;&nbsp; otherwise 'y'.<BR>(4) Returns the value of the expression. Used to override precedence.<BR>(5) Returns the result of (2-/expr/).<BR>(6) Returns the result of min(/expr/, /expr/).<BR>(7) Returns the result of max(/expr/, /expr/).</FONT></P>
<P><FONT class=extract>An expression can have a value of 'n', 'm' or 'y' (or 0, 1, 2<BR>respectively for calculations). A menu entry becomes visible when its<BR>expression evaluates to 'm' or 'y'.</FONT></P>
<P><FONT class=extract>There are two types of symbols: constant and non-constant symbols.<BR>Non-constant symbols are the most common ones and are defined with the<BR>'config' statement. Non-constant symbols consist entirely of alphanumeric<BR>characters or underscores.<BR>Constant symbols are only part of expressions. Constant symbols are<BR>always surrounded by single or double quotes. Within the quote, any<BR>other character is allowed and the quotes can be escaped using '\'.</FONT></P>
<P><FONT class=extract>Menu structure<BR>--------------</FONT></P>
<P><FONT class=extract>The position of a menu entry in the tree is determined in two ways. First<BR>it can be specified explicitly:</FONT></P>
<P><FONT class=extract>menu "Network device support"<BR>&nbsp;depends on NET</FONT></P>
<P><FONT class=extract>config NETDEVICES<BR>&nbsp;...</FONT></P>
<P><FONT class=extract>endmenu</FONT></P>
<P><FONT class=extract>All entries within the "menu" ... "endmenu" block become a submenu of<BR>"Network device support". All subentries inherit the dependencies from<BR>the menu entry, e.g. this means the dependency "NET" is added to the<BR>dependency list of the config option NETDEVICES.</FONT></P>
<P><FONT class=extract>The other way to generate the menu structure is done by analyzing the<BR>dependencies. If a menu entry somehow depends on the previous entry, it<BR>can be made a submenu of it. First, the previous (parent) symbol must<BR>be part of the dependency list and then one of these two conditions<BR>must be true:<BR>- the child entry must become invisible, if the parent is set to 'n'<BR>- the child entry must only be visible, if the parent is visible</FONT></P>
<P><FONT class=extract>config MODULES<BR>&nbsp;bool "Enable loadable module support"</FONT></P>
<P><FONT class=extract>config MODVERSIONS<BR>&nbsp;bool "Set version information on all module symbols"<BR>&nbsp;depends on MODULES</FONT></P>
<P><FONT class=extract>comment "module support disabled"<BR>&nbsp;depends on !MODULES</FONT></P>
<P><FONT class=extract>MODVERSIONS directly depends on MODULES, this means it's only visible if<BR>MODULES is different from 'n'. The comment on the other hand is always<BR>visible when MODULES is visible (the (empty) dependency of MODULES is<BR>also part of the comment dependencies).</FONT></P>
<P><BR><FONT class=extract>Kconfig syntax<BR>--------------</FONT></P>
<P><FONT class=extract>The configuration file describes a series of menu entries, where every<BR>line starts with a keyword (except help texts). The following keywords<BR>end a menu entry:<BR>- config<BR>- menuconfig<BR>- choice/endchoice<BR>- comment<BR>- menu/endmenu<BR>- if/endif<BR>- source<BR>The first five also start the definition of a menu entry.</FONT></P>
<P><FONT class=extract>config:</FONT></P>
<P><FONT class=extract>&nbsp;"config" &lt;symbol&gt;<BR>&nbsp;&lt;config options&gt;</FONT></P>
<P><FONT class=extract>This defines a config symbol &lt;symbol&gt; and accepts any of above<BR>attributes as options.</FONT></P>
<P><FONT class=extract>menuconfig:<BR>&nbsp;"menuconfig" &lt;symbol&gt;<BR>&nbsp;&lt;config options&gt;</FONT></P>
<P><FONT class=extract>This is similar to the simple config entry above, but it also gives a<BR>hint to front ends, that all suboptions should be displayed as a<BR>separate list of options.</FONT></P>
<P><FONT class=extract>choices:</FONT></P>
<P><FONT class=extract>&nbsp;"choice" [symbol]<BR>&nbsp;&lt;choice options&gt;<BR>&nbsp;&lt;choice block&gt;<BR>&nbsp;"endchoice"</FONT></P>
<P><FONT class=extract>This defines a choice group and accepts any of the above attributes as<BR>options. A choice can only be of type bool or tristate, while a boolean<BR>choice only allows a single config entry to be selected, a tristate<BR>choice also allows any number of config entries to be set to 'm'. This<BR>can be used if multiple drivers for a single hardware exists and only a<BR>single driver can be compiled/loaded into the kernel, but all drivers<BR>can be compiled as modules.<BR>A choice accepts another option "optional", which allows to set the<BR>choice to 'n' and no entry needs to be selected.<BR>If no [symbol] is associated with a choice, then you can not have multiple<BR>definitions of that choice. If a [symbol] is associated to the choice,<BR>then you may define the same choice (ie. with the same entries) in another<BR>place.</FONT></P>
<P><FONT class=extract>comment:</FONT></P>
<P><FONT class=extract>&nbsp;"comment" &lt;prompt&gt;<BR>&nbsp;&lt;comment options&gt;</FONT></P>
<P><FONT class=extract>This defines a comment which is displayed to the user during the<BR>configuration process and is also echoed to the output files. The only<BR>possible options are dependencies.</FONT></P>
<P><FONT class=extract>menu:</FONT></P>
<P><FONT class=extract>&nbsp;"menu" &lt;prompt&gt;<BR>&nbsp;&lt;menu options&gt;<BR>&nbsp;&lt;menu block&gt;<BR>&nbsp;"endmenu"</FONT></P>
<P><FONT class=extract>This defines a menu block, see "Menu structure" above for more<BR>information. The only possible options are dependencies and "visible"<BR>attributes.</FONT></P>
<P><FONT class=extract>if:</FONT></P>
<P><FONT class=extract>&nbsp;"if" &lt;expr&gt;<BR>&nbsp;&lt;if block&gt;<BR>&nbsp;"endif"</FONT></P>
<P><FONT class=extract>This defines an if block. The dependency expression &lt;expr&gt; is appended<BR>to all enclosed menu entries.</FONT></P>
<P><FONT class=extract>source:</FONT></P>
<P><FONT class=extract>&nbsp;"source" &lt;prompt&gt;</FONT></P>
<P><FONT class=extract>This reads the specified configuration file. This file is always parsed.</FONT></P>
<P><FONT class=extract>mainmenu:</FONT></P>
<P><FONT class=extract>&nbsp;"mainmenu" &lt;prompt&gt;</FONT></P>
<P><FONT class=extract>This sets the config program's title bar if the config program chooses<BR>to use it. It should be placed at the top of the configuration, before any<BR>other statement.</FONT></P>
<P><BR><FONT class=extract>Kconfig hints<BR>-------------<BR>This is a collection of Kconfig tips, most of which aren't obvious at<BR>first glance and most of which have become idioms in several Kconfig<BR>files.</FONT></P>
<P><FONT class=extract>Adding common features and make the usage configurable<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>It is a common idiom to implement a feature/functionality that are<BR>relevant for some architectures but not all.<BR>The recommended way to do so is to use a config variable named HAVE_*<BR>that is defined in a common Kconfig file and selected by the relevant<BR>architectures.<BR>An example is the generic IOMAP functionality.</FONT></P>
<P><FONT class=extract>We would in lib/Kconfig see:</FONT></P>
<P><FONT class=extract># Generic IOMAP is used to ...<BR>config HAVE_GENERIC_IOMAP</FONT></P>
<P><FONT class=extract>config GENERIC_IOMAP<BR>&nbsp;depends on HAVE_GENERIC_IOMAP &amp;&amp; FOO</FONT></P>
<P><FONT class=extract>And in lib/Makefile we would see:<BR>obj-$(CONFIG_GENERIC_IOMAP) += iomap.o</FONT></P>
<P><FONT class=extract>For each architecture using the generic IOMAP functionality we would see:</FONT></P>
<P><FONT class=extract>config X86<BR>&nbsp;select ...<BR>&nbsp;select HAVE_GENERIC_IOMAP<BR>&nbsp;select ...</FONT></P>
<P><FONT class=extract>Note: we use the existing config option and avoid creating a new<BR>config variable to select HAVE_GENERIC_IOMAP.</FONT></P>
<P><FONT class=extract>Note: the use of the internal config variable HAVE_GENERIC_IOMAP, it is<BR>introduced to overcome the limitation of select which will force a<BR>config option to 'y' no matter the dependencies.<BR>The dependencies are moved to the symbol GENERIC_IOMAP and we avoid the<BR>situation where select forces a symbol equals to 'y'.</FONT></P>
<P><FONT class=extract>Build as module only<BR>~~~~~~~~~~~~~~~~~~~~<BR>To restrict a component build to module-only, qualify its config symbol<BR>with "depends on m".&nbsp; E.g.:</FONT></P>
<P><FONT class=extract>config FOO<BR>&nbsp;depends on BAR &amp;&amp; m</FONT></P>
<P><FONT class=extract>limits FOO to module (=m) or disabled (=n).</FONT>