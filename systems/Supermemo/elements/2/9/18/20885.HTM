=== 6. Module Versioning 
<P></P>
<P><FONT class=extract>Module versioning is enabled by the CONFIG_MODVERSIONS tag, and is used<BR>as a simple ABI consistency check. A CRC value of the full prototype<BR>for an exported symbol is created. When a module is loaded/used, the<BR>CRC values contained in the kernel are compared with similar values in<BR>the module; if they are not equal, the kernel refuses to load the<BR>module.</FONT></P>
<P><FONT class=extract>Module.symvers contains a list of all exported symbols from a kernel<BR>build.</FONT></P>
<P><FONT class=extract>--- 6.1 Symbols From the Kernel (vmlinux + modules)</FONT></P>
<P><FONT class=extract>&nbsp;During a kernel build, a file named Module.symvers will be<BR>&nbsp;generated. Module.symvers contains all exported symbols from<BR>&nbsp;the kernel and compiled modules. For each symbol, the<BR>&nbsp;corresponding CRC value is also stored.</FONT></P>
<P><FONT class=extract>&nbsp;The syntax of the Module.symvers file is:<BR>&nbsp;&nbsp;&lt;CRC&gt;&nbsp;&nbsp;&nbsp;&nbsp; &lt;Symbol&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;module&gt;</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;0x2d036834&nbsp; scsi_remove_host&nbsp;&nbsp; drivers/scsi/scsi_mod</FONT></P>
<P><FONT class=extract>&nbsp;For a kernel build without CONFIG_MODVERSIONS enabled, the CRC<BR>&nbsp;would read 0x00000000.</FONT></P>
<P><FONT class=extract>&nbsp;Module.symvers serves two purposes:<BR>&nbsp;1) It lists all exported symbols from vmlinux and all modules.<BR>&nbsp;2) It lists the CRC if CONFIG_MODVERSIONS is enabled.</FONT></P>
<P><FONT class=extract>--- 6.2 Symbols and External Modules</FONT></P>
<P><FONT class=extract>&nbsp;When building an external module, the build system needs access<BR>&nbsp;to the symbols from the kernel to check if all external symbols<BR>&nbsp;are defined. This is done in the MODPOST step. modpost obtains<BR>&nbsp;the symbols by reading Module.symvers from the kernel source<BR>&nbsp;tree. If a Module.symvers file is present in the directory<BR>&nbsp;where the external module is being built, this file will be<BR>&nbsp;read too. During the MODPOST step, a new Module.symvers file<BR>&nbsp;will be written containing all exported symbols that were not<BR>&nbsp;defined in the kernel.</FONT></P>
<P><FONT class=extract>--- 6.3 Symbols From Another External Module</FONT></P>
<P><FONT class=extract>&nbsp;Sometimes, an external module uses exported symbols from<BR>&nbsp;another external module. kbuild needs to have full knowledge of<BR>&nbsp;all symbols to avoid spitting out warnings about undefined<BR>&nbsp;symbols. Three solutions exist for this situation.</FONT></P>
<P><FONT class=extract>&nbsp;NOTE: The method with a top-level kbuild file is recommended<BR>&nbsp;but may be impractical in certain situations.</FONT></P>
<P><FONT class=extract>&nbsp;Use a top-level kbuild file<BR>&nbsp;&nbsp;If you have two modules, foo.ko and bar.ko, where<BR>&nbsp;&nbsp;foo.ko needs symbols from bar.ko, you can use a<BR>&nbsp;&nbsp;common top-level kbuild file so both modules are<BR>&nbsp;&nbsp;compiled in the same build. Consider the following<BR>&nbsp;&nbsp;directory layout:</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;./foo/ &lt;= contains foo.ko<BR>&nbsp;&nbsp;./bar/ &lt;= contains bar.ko</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;The top-level kbuild file would then look like:</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;#./Kbuild (or ./Makefile):<BR>&nbsp;&nbsp;&nbsp;obj-y := foo/ bar/</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;And executing</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp;$ make -C $KDIR M=$PWD</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;will then do the expected and compile both modules with<BR>&nbsp;&nbsp;full knowledge of symbols from either module.</FONT></P>
<P><FONT class=extract>&nbsp;Use an extra Module.symvers file<BR>&nbsp;&nbsp;When an external module is built, a Module.symvers file<BR>&nbsp;&nbsp;is generated containing all exported symbols which are<BR>&nbsp;&nbsp;not defined in the kernel. To get access to symbols<BR>&nbsp;&nbsp;from bar.ko, copy the Module.symvers file from the<BR>&nbsp;&nbsp;compilation of bar.ko to the directory where foo.ko is<BR>&nbsp;&nbsp;built. During the module build, kbuild will read the<BR>&nbsp;&nbsp;Module.symvers file in the directory of the external<BR>&nbsp;&nbsp;module, and when the build is finished, a new<BR>&nbsp;&nbsp;Module.symvers file is created containing the sum of<BR>&nbsp;&nbsp;all symbols defined and not part of the kernel.</FONT></P>
<P><FONT class=extract>&nbsp;Use "make" variable KBUILD_EXTRA_SYMBOLS<BR>&nbsp;&nbsp;If it is impractical to copy Module.symvers from<BR>&nbsp;&nbsp;another module, you can assign a space separated list<BR>&nbsp;&nbsp;of files to KBUILD_EXTRA_SYMBOLS in your build file.<BR>&nbsp;&nbsp;These files will be loaded by modpost during the<BR>&nbsp;&nbsp;initialization of its symbol tables.</FONT>