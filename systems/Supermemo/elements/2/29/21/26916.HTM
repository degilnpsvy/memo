# qemu:tcg/i386/tcg_target.c
<P></P>
<P>/*<BR>&nbsp;* Tiny Code Generator for QEMU<BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2008 Fabrice Bellard<BR>&nbsp;*<BR>&nbsp;* Permission is hereby granted, free of charge, to any person obtaining a copy<BR>&nbsp;* of this software and associated documentation files (the "Software"), to deal<BR>&nbsp;* in the Software without restriction, including without limitation the rights<BR>&nbsp;* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<BR>&nbsp;* copies of the Software, and to permit persons to whom the Software is<BR>&nbsp;* furnished to do so, subject to the following conditions:<BR>&nbsp;*<BR>&nbsp;* The above copyright notice and this permission notice shall be included in<BR>&nbsp;* all copies or substantial portions of the Software.<BR>&nbsp;*<BR>&nbsp;* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<BR>&nbsp;* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<BR>&nbsp;* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL<BR>&nbsp;* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<BR>&nbsp;* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<BR>&nbsp;* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<BR>&nbsp;* THE SOFTWARE.<BR>&nbsp;*/</P>
<P></P>
<P>#include "tcg-be-ldst.h"</P>
<P>#ifndef NDEBUG<BR>static const char * const tcg_target_reg_names[TCG_TARGET_NB_REGS] = {<BR>#if TCG_TARGET_REG_BITS == 64<BR>&nbsp;&nbsp;&nbsp; "%rax", "%rcx", "%rdx", "%rbx", "%rsp", "%rbp", "%rsi", "%rdi",<BR>&nbsp;&nbsp;&nbsp; "%r8",&nbsp; "%r9",&nbsp; "%r10", "%r11", "%r12", "%r13", "%r14", "%r15",<BR>#else<BR>&nbsp;&nbsp;&nbsp; "%eax", "%ecx", "%edx", "%ebx", "%esp", "%ebp", "%esi", "%edi",<BR>#endif<BR>};<BR>#endif</P>
<P>static const int tcg_target_reg_alloc_order[] = {<BR>#if TCG_TARGET_REG_BITS == 64<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RBP,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RBX,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R12,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R13,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R14,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R15,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R10,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R11,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R9,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R8,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RCX,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RDX,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RSI,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RDI,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RAX,<BR>#else<BR>&nbsp;&nbsp;&nbsp; TCG_REG_EBX,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_ESI,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_EDI,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_EBP,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_ECX,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_EDX,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_EAX,<BR>#endif<BR>};</P>
<P>static const int tcg_target_call_iarg_regs[] = {<BR>#if TCG_TARGET_REG_BITS == 64<BR>#if defined(_WIN64)<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RCX,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RDX,<BR>#else<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RDI,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RSI,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RDX,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RCX,<BR>#endif<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R8,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R9,<BR>#else<BR>&nbsp;&nbsp;&nbsp; /* 32 bit mode uses stack based calling convention (GCC default). */<BR>#endif<BR>};</P>
<P>static const int tcg_target_call_oarg_regs[] = {<BR>&nbsp;&nbsp;&nbsp; TCG_REG_EAX,<BR>#if TCG_TARGET_REG_BITS == 32<BR>&nbsp;&nbsp;&nbsp; TCG_REG_EDX<BR>#endif<BR>};</P>
<P>/* Constants we accept.&nbsp; */<BR>#define TCG_CT_CONST_S32 0x100<BR>#define TCG_CT_CONST_U32 0x200<BR>#define TCG_CT_CONST_I32 0x400</P>
<P>/* Registers used with L constraint, which are the first argument <BR>&nbsp;&nbsp; registers on x86_64, and two random call clobbered registers on<BR>&nbsp;&nbsp; i386. */<BR>#if TCG_TARGET_REG_BITS == 64<BR># define TCG_REG_L0 tcg_target_call_iarg_regs[0]<BR># define TCG_REG_L1 tcg_target_call_iarg_regs[1]<BR>#else<BR># define TCG_REG_L0 TCG_REG_EAX<BR># define TCG_REG_L1 TCG_REG_EDX<BR>#endif</P>
<P>/* The host compiler should supply &lt;cpuid.h&gt; to enable runtime features<BR>&nbsp;&nbsp; detection, as we're not going to go so far as our own inline assembly.<BR>&nbsp;&nbsp; If not available, default values will be assumed.&nbsp; */<BR>#if defined(CONFIG_CPUID_H)<BR>#include &lt;cpuid.h&gt;<BR>#endif</P>
<P>/* For 32-bit, we are going to attempt to determine at runtime whether cmov<BR>&nbsp;&nbsp; is available.&nbsp; */<BR>#if TCG_TARGET_REG_BITS == 64<BR># define have_cmov 1<BR>#elif defined(CONFIG_CPUID_H) &amp;&amp; defined(bit_CMOV)<BR>static bool have_cmov;<BR>#else<BR># define have_cmov 0<BR>#endif</P>
<P>/* If bit_MOVBE is defined in cpuid.h (added in GCC version 4.6), we are<BR>&nbsp;&nbsp; going to attempt to determine at runtime whether movbe is available.&nbsp; */<BR>#if defined(CONFIG_CPUID_H) &amp;&amp; defined(bit_MOVBE)<BR>static bool have_movbe;<BR>#else<BR># define have_movbe 0<BR>#endif</P>
<P>/* We need this symbol in tcg-target.h, and we can't properly conditionalize<BR>&nbsp;&nbsp; it there.&nbsp; Therefore we always define the variable.&nbsp; */<BR>bool have_bmi1;</P>
<P>#if defined(CONFIG_CPUID_H) &amp;&amp; defined(bit_BMI2)<BR>static bool have_bmi2;<BR>#else<BR># define have_bmi2 0<BR>#endif</P>
<P>static tcg_insn_unit *tb_ret_addr;</P>
<P>static void patch_reloc(tcg_insn_unit *code_ptr, int type,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intptr_t value, intptr_t addend)<BR>{<BR>&nbsp;&nbsp;&nbsp; value += addend;<BR>&nbsp;&nbsp;&nbsp; switch(type) {<BR>&nbsp;&nbsp;&nbsp; case R_386_PC32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value -= (uintptr_t)code_ptr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (value != (int32_t)value) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_patch32(code_ptr, value);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case R_386_PC8:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value -= (uintptr_t)code_ptr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (value != (int8_t)value) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_patch8(code_ptr, value);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* parse target specific constraints */<BR>static int target_parse_constraint(TCGArgConstraint *ct, const char **pct_str)<BR>{<BR>&nbsp;&nbsp;&nbsp; const char *ct_str;</P>
<P>&nbsp;&nbsp;&nbsp; ct_str = *pct_str;<BR>&nbsp;&nbsp;&nbsp; switch(ct_str[0]) {<BR>&nbsp;&nbsp;&nbsp; case 'a':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ct-&gt;ct |= TCG_CT_REG;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(ct-&gt;u.regs, TCG_REG_EAX);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 'b':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ct-&gt;ct |= TCG_CT_REG;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(ct-&gt;u.regs, TCG_REG_EBX);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 'c':<BR>&nbsp;&nbsp;&nbsp; case_c:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ct-&gt;ct |= TCG_CT_REG;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(ct-&gt;u.regs, TCG_REG_ECX);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 'd':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ct-&gt;ct |= TCG_CT_REG;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(ct-&gt;u.regs, TCG_REG_EDX);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 'S':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ct-&gt;ct |= TCG_CT_REG;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(ct-&gt;u.regs, TCG_REG_ESI);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 'D':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ct-&gt;ct |= TCG_CT_REG;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(ct-&gt;u.regs, TCG_REG_EDI);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 'q':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ct-&gt;ct |= TCG_CT_REG;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set32(ct-&gt;u.regs, 0, 0xffff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set32(ct-&gt;u.regs, 0, 0xf);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 'Q':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ct-&gt;ct |= TCG_CT_REG;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set32(ct-&gt;u.regs, 0, 0xf);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 'r':<BR>&nbsp;&nbsp;&nbsp; case_r:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ct-&gt;ct |= TCG_CT_REG;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set32(ct-&gt;u.regs, 0, 0xffff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set32(ct-&gt;u.regs, 0, 0xff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 'C':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* With SHRX et al, we need not use ECX as shift count register.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (have_bmi2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto case_r;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto case_c;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* qemu_ld/st address constraint */<BR>&nbsp;&nbsp;&nbsp; case 'L':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ct-&gt;ct |= TCG_CT_REG;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set32(ct-&gt;u.regs, 0, 0xffff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set32(ct-&gt;u.regs, 0, 0xff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_reset_reg(ct-&gt;u.regs, TCG_REG_L0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_reset_reg(ct-&gt;u.regs, TCG_REG_L1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case 'e':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ct-&gt;ct |= TCG_CT_CONST_S32;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 'Z':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ct-&gt;ct |= TCG_CT_CONST_U32;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 'I':<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ct-&gt;ct |= TCG_CT_CONST_I32;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; ct_str++;<BR>&nbsp;&nbsp;&nbsp; *pct_str = ct_str;<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>/* test if a constant matches the constraint */<BR>static inline int tcg_target_const_match(tcg_target_long val, TCGType type,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const TCGArgConstraint *arg_ct)<BR>{<BR>&nbsp;&nbsp;&nbsp; int ct = arg_ct-&gt;ct;<BR>&nbsp;&nbsp;&nbsp; if (ct &amp; TCG_CT_CONST) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if ((ct &amp; TCG_CT_CONST_S32) &amp;&amp; val == (int32_t)val) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if ((ct &amp; TCG_CT_CONST_U32) &amp;&amp; val == (uint32_t)val) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if ((ct &amp; TCG_CT_CONST_I32) &amp;&amp; ~val == (int32_t)~val) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P>
<P>#if TCG_TARGET_REG_BITS == 64<BR># define LOWREGMASK(x)&nbsp;((x) &amp; 7)<BR>#else<BR># define LOWREGMASK(x)&nbsp;(x)<BR>#endif</P>
<P>#define P_EXT&nbsp;&nbsp;0x100&nbsp;&nbsp;/* 0x0f opcode prefix */<BR>#define P_EXT38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x200&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 0x0f 0x38 opcode prefix */<BR>#define P_DATA16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 0x66 opcode prefix */<BR>#if TCG_TARGET_REG_BITS == 64<BR># define P_ADDR32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 0x67 opcode prefix */<BR># define P_REXW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Set REX.W = 1 */<BR># define P_REXB_R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x2000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* REG field as byte register */<BR># define P_REXB_RM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x4000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* R/M field as byte register */<BR># define P_GS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x8000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* gs segment override */<BR>#else<BR># define P_ADDR32&nbsp;0<BR># define P_REXW&nbsp;&nbsp;0<BR># define P_REXB_R&nbsp;0<BR># define P_REXB_RM&nbsp;0<BR># define P_GS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>#endif<BR>#define P_SIMDF3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 0xf3 opcode prefix */<BR>#define P_SIMDF2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x20000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 0xf2 opcode prefix */</P>
<P>#define OPC_ARITH_EvIz&nbsp;(0x81)<BR>#define OPC_ARITH_EvIb&nbsp;(0x83)<BR>#define OPC_ARITH_GvEv&nbsp;(0x03)&nbsp;&nbsp;/* ... plus (ARITH_FOO &lt;&lt; 3) */<BR>#define OPC_ANDN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0xf2 | P_EXT38)<BR>#define OPC_ADD_GvEv&nbsp;(OPC_ARITH_GvEv | (ARITH_ADD &lt;&lt; 3))<BR>#define OPC_BSWAP&nbsp;(0xc8 | P_EXT)<BR>#define OPC_CALL_Jz&nbsp;(0xe8)<BR>#define OPC_CMOVCC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0x40 | P_EXT)&nbsp; /* ... plus condition code */<BR>#define OPC_CMP_GvEv&nbsp;(OPC_ARITH_GvEv | (ARITH_CMP &lt;&lt; 3))<BR>#define OPC_DEC_r32&nbsp;(0x48)<BR>#define OPC_IMUL_GvEv&nbsp;(0xaf | P_EXT)<BR>#define OPC_IMUL_GvEvIb&nbsp;(0x6b)<BR>#define OPC_IMUL_GvEvIz&nbsp;(0x69)<BR>#define OPC_INC_r32&nbsp;(0x40)<BR>#define OPC_JCC_long&nbsp;(0x80 | P_EXT)&nbsp;/* ... plus condition code */<BR>#define OPC_JCC_short&nbsp;(0x70)&nbsp;&nbsp;/* ... plus condition code */<BR>#define OPC_JMP_long&nbsp;(0xe9)<BR>#define OPC_JMP_short&nbsp;(0xeb)<BR>#define OPC_LEA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0x8d)<BR>#define OPC_MOVB_EvGv&nbsp;(0x88)&nbsp;&nbsp;/* stores, more or less */<BR>#define OPC_MOVL_EvGv&nbsp;(0x89)&nbsp;&nbsp;/* stores, more or less */<BR>#define OPC_MOVL_GvEv&nbsp;(0x8b)&nbsp;&nbsp;/* loads, more or less */<BR>#define OPC_MOVB_EvIz&nbsp;&nbsp; (0xc6)<BR>#define OPC_MOVL_EvIz&nbsp;(0xc7)<BR>#define OPC_MOVL_Iv&nbsp;&nbsp;&nbsp;&nbsp; (0xb8)<BR>#define OPC_MOVBE_GyMy&nbsp; (0xf0 | P_EXT38)<BR>#define OPC_MOVBE_MyGy&nbsp; (0xf1 | P_EXT38)<BR>#define OPC_MOVSBL&nbsp;(0xbe | P_EXT)<BR>#define OPC_MOVSWL&nbsp;(0xbf | P_EXT)<BR>#define OPC_MOVSLQ&nbsp;(0x63 | P_REXW)<BR>#define OPC_MOVZBL&nbsp;(0xb6 | P_EXT)<BR>#define OPC_MOVZWL&nbsp;(0xb7 | P_EXT)<BR>#define OPC_POP_r32&nbsp;(0x58)<BR>#define OPC_PUSH_r32&nbsp;(0x50)<BR>#define OPC_PUSH_Iv&nbsp;(0x68)<BR>#define OPC_PUSH_Ib&nbsp;(0x6a)<BR>#define OPC_RET&nbsp;&nbsp;(0xc3)<BR>#define OPC_SETCC&nbsp;(0x90 | P_EXT | P_REXB_RM) /* ... plus cc */<BR>#define OPC_SHIFT_1&nbsp;(0xd1)<BR>#define OPC_SHIFT_Ib&nbsp;(0xc1)<BR>#define OPC_SHIFT_cl&nbsp;(0xd3)<BR>#define OPC_SARX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0xf7 | P_EXT38 | P_SIMDF3)<BR>#define OPC_SHLX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0xf7 | P_EXT38 | P_DATA16)<BR>#define OPC_SHRX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0xf7 | P_EXT38 | P_SIMDF2)<BR>#define OPC_TESTL&nbsp;(0x85)<BR>#define OPC_XCHG_ax_r32&nbsp;(0x90)</P>
<P>#define OPC_GRP3_Ev&nbsp;(0xf7)<BR>#define OPC_GRP5&nbsp;(0xff)</P>
<P>/* Group 1 opcode extensions for 0x80-0x83.<BR>&nbsp;&nbsp; These are also used as modifiers for OPC_ARITH.&nbsp; */<BR>#define ARITH_ADD 0<BR>#define ARITH_OR&nbsp; 1<BR>#define ARITH_ADC 2<BR>#define ARITH_SBB 3<BR>#define ARITH_AND 4<BR>#define ARITH_SUB 5<BR>#define ARITH_XOR 6<BR>#define ARITH_CMP 7</P>
<P>/* Group 2 opcode extensions for 0xc0, 0xc1, 0xd0-0xd3.&nbsp; */<BR>#define SHIFT_ROL 0<BR>#define SHIFT_ROR 1<BR>#define SHIFT_SHL 4<BR>#define SHIFT_SHR 5<BR>#define SHIFT_SAR 7</P>
<P>/* Group 3 opcode extensions for 0xf6, 0xf7.&nbsp; To be used with OPC_GRP3.&nbsp; */<BR>#define EXT3_NOT&nbsp;&nbsp; 2<BR>#define EXT3_NEG&nbsp;&nbsp; 3<BR>#define EXT3_MUL&nbsp;&nbsp; 4<BR>#define EXT3_IMUL&nbsp; 5<BR>#define EXT3_DIV&nbsp;&nbsp; 6<BR>#define EXT3_IDIV&nbsp; 7</P>
<P>/* Group 5 opcode extensions for 0xff.&nbsp; To be used with OPC_GRP5.&nbsp; */<BR>#define EXT5_INC_Ev&nbsp;0<BR>#define EXT5_DEC_Ev&nbsp;1<BR>#define EXT5_CALLN_Ev&nbsp;2<BR>#define EXT5_JMPN_Ev&nbsp;4</P>
<P>/* Condition codes to be added to OPC_JCC_{long,short}.&nbsp; */<BR>#define JCC_JMP (-1)<BR>#define JCC_JO&nbsp; 0x0<BR>#define JCC_JNO 0x1<BR>#define JCC_JB&nbsp; 0x2<BR>#define JCC_JAE 0x3<BR>#define JCC_JE&nbsp; 0x4<BR>#define JCC_JNE 0x5<BR>#define JCC_JBE 0x6<BR>#define JCC_JA&nbsp; 0x7<BR>#define JCC_JS&nbsp; 0x8<BR>#define JCC_JNS 0x9<BR>#define JCC_JP&nbsp; 0xa<BR>#define JCC_JNP 0xb<BR>#define JCC_JL&nbsp; 0xc<BR>#define JCC_JGE 0xd<BR>#define JCC_JLE 0xe<BR>#define JCC_JG&nbsp; 0xf</P>
<P>static const uint8_t tcg_cond_to_jcc[] = {<BR>&nbsp;&nbsp;&nbsp; [TCG_COND_EQ] = JCC_JE,<BR>&nbsp;&nbsp;&nbsp; [TCG_COND_NE] = JCC_JNE,<BR>&nbsp;&nbsp;&nbsp; [TCG_COND_LT] = JCC_JL,<BR>&nbsp;&nbsp;&nbsp; [TCG_COND_GE] = JCC_JGE,<BR>&nbsp;&nbsp;&nbsp; [TCG_COND_LE] = JCC_JLE,<BR>&nbsp;&nbsp;&nbsp; [TCG_COND_GT] = JCC_JG,<BR>&nbsp;&nbsp;&nbsp; [TCG_COND_LTU] = JCC_JB,<BR>&nbsp;&nbsp;&nbsp; [TCG_COND_GEU] = JCC_JAE,<BR>&nbsp;&nbsp;&nbsp; [TCG_COND_LEU] = JCC_JBE,<BR>&nbsp;&nbsp;&nbsp; [TCG_COND_GTU] = JCC_JA,<BR>};</P>
<P>#if TCG_TARGET_REG_BITS == 64<BR>static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)<BR>{<BR>&nbsp;&nbsp;&nbsp; int rex;</P>
<P>&nbsp;&nbsp;&nbsp; if (opc &amp; P_GS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, 0x65);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (opc &amp; P_DATA16) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We should never be asking for both 16 and 64-bit operation.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert((opc &amp; P_REXW) == 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, 0x66);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (opc &amp; P_ADDR32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, 0x67);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; rex = 0;<BR>&nbsp;&nbsp;&nbsp; rex |= (opc &amp; P_REXW) ? 0x8 : 0x0;&nbsp; /* REX.W */<BR>&nbsp;&nbsp;&nbsp; rex |= (r &amp; 8) &gt;&gt; 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* REX.R */<BR>&nbsp;&nbsp;&nbsp; rex |= (x &amp; 8) &gt;&gt; 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* REX.X */<BR>&nbsp;&nbsp;&nbsp; rex |= (rm &amp; 8) &gt;&gt; 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* REX.B */</P>
<P>&nbsp;&nbsp;&nbsp; /* P_REXB_{R,RM} indicates that the given register is the low byte.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as otherwise the encoding indicates %[abcd]h.&nbsp; Note that the values<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; that are ORed in merely indicate that the REX byte must be present;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; those bits get discarded in output.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; rex |= opc &amp; (r &gt;= 4 ? P_REXB_R : 0);<BR>&nbsp;&nbsp;&nbsp; rex |= opc &amp; (rm &gt;= 4 ? P_REXB_RM : 0);</P>
<P>&nbsp;&nbsp;&nbsp; if (rex) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, (uint8_t)(rex | 0x40));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (opc &amp; (P_EXT | P_EXT38)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, 0x0f);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (opc &amp; P_EXT38) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, 0x38);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; tcg_out8(s, opc);<BR>}<BR>#else<BR>static void tcg_out_opc(TCGContext *s, int opc)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (opc &amp; P_DATA16) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, 0x66);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (opc &amp; (P_EXT | P_EXT38)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, 0x0f);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (opc &amp; P_EXT38) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, 0x38);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_out8(s, opc);<BR>}<BR>/* Discard the register arguments to tcg_out_opc early, so as not to penalize<BR>&nbsp;&nbsp; the 32-bit compilation paths.&nbsp; This method works with all versions of gcc,<BR>&nbsp;&nbsp; whereas relying on optimization may not be able to exclude them.&nbsp; */<BR>#define tcg_out_opc(s, opc, r, rm, x)&nbsp; (tcg_out_opc)(s, opc)<BR>#endif</P>
<P>static void tcg_out_modrm(TCGContext *s, int opc, int r, int rm)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_opc(s, opc, r, rm, 0);<BR>&nbsp;&nbsp;&nbsp; tcg_out8(s, 0xc0 | (LOWREGMASK(r) &lt;&lt; 3) | LOWREGMASK(rm));<BR>}</P>
<P>static void tcg_out_vex_modrm(TCGContext *s, int opc, int r, int v, int rm)<BR>{<BR>&nbsp;&nbsp;&nbsp; int tmp;</P>
<P>&nbsp;&nbsp;&nbsp; if ((opc &amp; (P_REXW | P_EXT | P_EXT38)) || (rm &amp; 8)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Three byte VEX prefix.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, 0xc4);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* VEX.m-mmmm */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (opc &amp; P_EXT38) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (opc &amp; P_EXT) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp |= 0x40;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* VEX.X */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp |= (r &amp; 8 ? 0 : 0x80);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* VEX.R */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp |= (rm &amp; 8 ? 0 : 0x20);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* VEX.B */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, tmp);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = (opc &amp; P_REXW ? 0x80 : 0);&nbsp;&nbsp; /* VEX.W */<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Two byte VEX prefix.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, 0xc5);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = (r &amp; 8 ? 0 : 0x80);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* VEX.R */<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; /* VEX.pp */<BR>&nbsp;&nbsp;&nbsp; if (opc &amp; P_DATA16) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp |= 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 0x66 */<BR>&nbsp;&nbsp;&nbsp; } else if (opc &amp; P_SIMDF3) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp |= 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 0xf3 */<BR>&nbsp;&nbsp;&nbsp; } else if (opc &amp; P_SIMDF2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp |= 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 0xf2 */<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tmp |= (~v &amp; 15) &lt;&lt; 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* VEX.vvvv */<BR>&nbsp;&nbsp;&nbsp; tcg_out8(s, tmp);<BR>&nbsp;&nbsp;&nbsp; tcg_out8(s, opc);<BR>&nbsp;&nbsp;&nbsp; tcg_out8(s, 0xc0 | (LOWREGMASK(r) &lt;&lt; 3) | LOWREGMASK(rm));<BR>}</P>
<P>/* Output an opcode with a full "rm + (index&lt;&lt;shift) + offset" address mode.<BR>&nbsp;&nbsp; We handle either RM and INDEX missing with a negative value.&nbsp; In 64-bit<BR>&nbsp;&nbsp; mode for absolute addresses, ~RM is the size of the immediate operand<BR>&nbsp;&nbsp; that will follow the instruction.&nbsp; */</P>
<P>static void tcg_out_modrm_sib_offset(TCGContext *s, int opc, int r, int rm,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int index, int shift, intptr_t offset)<BR>{<BR>&nbsp;&nbsp;&nbsp; int mod, len;</P>
<P>&nbsp;&nbsp;&nbsp; if (index &lt; 0 &amp;&amp; rm &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Try for a rip-relative addressing mode.&nbsp; This has replaced<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the 32-bit-mode absolute addressing encoding.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intptr_t pc = (intptr_t)s-&gt;code_ptr + 5 + ~rm;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intptr_t disp = offset - pc;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (disp == (int32_t)disp) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, opc, r, 0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, (LOWREGMASK(r) &lt;&lt; 3) | 5);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, disp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Try for an absolute address encoding.&nbsp; This requires the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use of the MODRM+SIB encoding and is therefore larger than<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rip-relative addressing.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (offset == (int32_t)offset) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, opc, r, 0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, (LOWREGMASK(r) &lt;&lt; 3) | 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, (4 &lt;&lt; 3) | 5);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, offset);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ??? The memory isn't directly addressable.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Absolute address.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, opc, r, 0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, (r &lt;&lt; 3) | 5);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, offset);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Find the length of the immediate addend.&nbsp; Note that the encoding<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; that would be used for (%ebp) indicates absolute addressing.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (rm &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod = 0, len = 4, rm = 5;<BR>&nbsp;&nbsp;&nbsp; } else if (offset == 0 &amp;&amp; LOWREGMASK(rm) != TCG_REG_EBP) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod = 0, len = 0;<BR>&nbsp;&nbsp;&nbsp; } else if (offset == (int8_t)offset) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod = 0x40, len = 1;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod = 0x80, len = 4;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Use a single byte MODRM format if possible.&nbsp; Note that the encoding<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; that would be used for %esp is the escape to the two byte form.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (index &lt; 0 &amp;&amp; LOWREGMASK(rm) != TCG_REG_ESP) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Single byte MODRM format.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, opc, r, rm, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, mod | (LOWREGMASK(r) &lt;&lt; 3) | LOWREGMASK(rm));<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Two byte MODRM+SIB format.&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note that the encoding that would place %esp into the index<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; field indicates no index register.&nbsp; In 64-bit mode, the REX.X<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit counts, so %r12 can be used as the index.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (index &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert(index != TCG_REG_ESP);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, opc, r, rm, index);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, mod | (LOWREGMASK(r) &lt;&lt; 3) | 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, (shift &lt;&lt; 6) | (LOWREGMASK(index) &lt;&lt; 3) | LOWREGMASK(rm));<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (len == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, offset);<BR>&nbsp;&nbsp;&nbsp; } else if (len == 4) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, offset);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* A simplification of the above with no index or shift.&nbsp; */<BR>static inline void tcg_out_modrm_offset(TCGContext *s, int opc, int r,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int rm, intptr_t offset)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, opc, r, rm, -1, 0, offset);<BR>}</P>
<P>/* Generate dest op= src.&nbsp; Uses the same ARITH_* codes as tgen_arithi.&nbsp; */<BR>static inline void tgen_arithr(TCGContext *s, int subop, int dest, int src)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Propagate an opcode prefix, such as P_REXW.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int ext = subop &amp; ~0x7;<BR>&nbsp;&nbsp;&nbsp; subop &amp;= 0x7;</P>
<P>&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_ARITH_GvEv + (subop &lt;&lt; 3) + ext, dest, src);<BR>}</P>
<P>static inline void tcg_out_mov(TCGContext *s, TCGType type,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGReg ret, TCGReg arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arg != ret) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int opc = OPC_MOVL_GvEv + (type == TCG_TYPE_I64 ? P_REXW : 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, opc, ret, arg);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void tcg_out_movi(TCGContext *s, TCGType type,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGReg ret, tcg_target_long arg)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_target_long diff;</P>
<P>&nbsp;&nbsp;&nbsp; if (arg == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithr(s, ARITH_XOR, ret, ret);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arg == (uint32_t)arg || type == TCG_TYPE_I32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_MOVL_Iv + LOWREGMASK(ret), 0, ret, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, arg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (arg == (int32_t)arg) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_MOVL_EvIz + P_REXW, 0, ret);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, arg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Try a 7 byte pc-relative lea before the 10 byte movq.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; diff = arg - ((uintptr_t)s-&gt;code_ptr + 7);<BR>&nbsp;&nbsp;&nbsp; if (diff == (int32_t)diff) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_LEA | P_REXW, ret, 0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, (LOWREGMASK(ret) &lt;&lt; 3) | 5);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, diff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_MOVL_Iv + P_REXW + LOWREGMASK(ret), 0, ret, 0);<BR>&nbsp;&nbsp;&nbsp; tcg_out64(s, arg);<BR>}</P>
<P>static inline void tcg_out_pushi(TCGContext *s, tcg_target_long val)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (val == (int8_t)val) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_PUSH_Ib, 0, 0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, val);<BR>&nbsp;&nbsp;&nbsp; } else if (val == (int32_t)val) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_PUSH_Iv, 0, 0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, val);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static inline void tcg_out_push(TCGContext *s, int reg)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_PUSH_r32 + LOWREGMASK(reg), 0, reg, 0);<BR>}</P>
<P>static inline void tcg_out_pop(TCGContext *s, int reg)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_POP_r32 + LOWREGMASK(reg), 0, reg, 0);<BR>}</P>
<P>static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGReg arg1, intptr_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; int opc = OPC_MOVL_GvEv + (type == TCG_TYPE_I64 ? P_REXW : 0);<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, opc, ret, arg1, arg2);<BR>}</P>
<P>static inline void tcg_out_st(TCGContext *s, TCGType type, TCGReg arg,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGReg arg1, intptr_t arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; int opc = OPC_MOVL_EvGv + (type == TCG_TYPE_I64 ? P_REXW : 0);<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, opc, arg, arg1, arg2);<BR>}</P>
<P>static inline void tcg_out_sti(TCGContext *s, TCGType type, TCGReg base,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_target_long ofs, tcg_target_long val)<BR>{<BR>&nbsp;&nbsp;&nbsp; int opc = OPC_MOVL_EvIz + (type == TCG_TYPE_I64 ? P_REXW : 0);<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, opc, 0, base, ofs);<BR>&nbsp;&nbsp;&nbsp; tcg_out32(s, val);<BR>}</P>
<P>static void tcg_out_shifti(TCGContext *s, int subopc, int reg, int count)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* Propagate an opcode prefix, such as P_DATA16.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; int ext = subopc &amp; ~0x7;<BR>&nbsp;&nbsp;&nbsp; subopc &amp;= 0x7;</P>
<P>&nbsp;&nbsp;&nbsp; if (count == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_SHIFT_1 + ext, subopc, reg);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_SHIFT_Ib + ext, subopc, reg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, count);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static inline void tcg_out_bswap32(TCGContext *s, int reg)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_BSWAP + LOWREGMASK(reg), 0, reg, 0);<BR>}</P>
<P>static inline void tcg_out_rolw_8(TCGContext *s, int reg)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_shifti(s, SHIFT_ROL + P_DATA16, reg, 8);<BR>}</P>
<P>static inline void tcg_out_ext8u(TCGContext *s, int dest, int src)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* movzbl */<BR>&nbsp;&nbsp;&nbsp; assert(src &lt; 4 || TCG_TARGET_REG_BITS == 64);<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_MOVZBL + P_REXB_RM, dest, src);<BR>}</P>
<P>static void tcg_out_ext8s(TCGContext *s, int dest, int src, int rexw)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* movsbl */<BR>&nbsp;&nbsp;&nbsp; assert(src &lt; 4 || TCG_TARGET_REG_BITS == 64);<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_MOVSBL + P_REXB_RM + rexw, dest, src);<BR>}</P>
<P>static inline void tcg_out_ext16u(TCGContext *s, int dest, int src)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* movzwl */<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_MOVZWL, dest, src);<BR>}</P>
<P>static inline void tcg_out_ext16s(TCGContext *s, int dest, int src, int rexw)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* movsw[lq] */<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_MOVSWL + rexw, dest, src);<BR>}</P>
<P>static inline void tcg_out_ext32u(TCGContext *s, int dest, int src)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* 32-bit mov zero extends.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_MOVL_GvEv, dest, src);<BR>}</P>
<P>static inline void tcg_out_ext32s(TCGContext *s, int dest, int src)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_MOVSLQ, dest, src);<BR>}</P>
<P>static inline void tcg_out_bswap64(TCGContext *s, int reg)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_BSWAP + P_REXW + LOWREGMASK(reg), 0, reg, 0);<BR>}</P>
<P>static void tgen_arithi(TCGContext *s, int c, int r0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_target_long val, int cf)<BR>{<BR>&nbsp;&nbsp;&nbsp; int rexw = 0;</P>
<P>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rexw = c &amp; -8;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c &amp;= 7;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* ??? While INC is 2 bytes shorter than ADDL $1, they also induce<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; partial flags update stalls on Pentium4 and are not recommended<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; by current Intel optimization manuals.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (!cf &amp;&amp; (c == ARITH_ADD || c == ARITH_SUB) &amp;&amp; (val == 1 || val == -1)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int is_inc = (c == ARITH_ADD) ^ (val &lt; 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The single-byte increment encodings are re-tasked as the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REX prefixes.&nbsp; Use the MODRM encoding.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_GRP5 + rexw,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (is_inc ? EXT5_INC_Ev : EXT5_DEC_Ev), r0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, (is_inc ? OPC_INC_r32 : OPC_DEC_r32) + r0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (c == ARITH_AND) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (val == 0xffffffffu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext32u(s, r0, r0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (val == (uint32_t)val) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* AND with no high bits set can use a 32-bit operation.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rexw = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (val == 0xffu &amp;&amp; (r0 &lt; 4 || TCG_TARGET_REG_BITS == 64)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext8u(s, r0, r0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (val == 0xffffu) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext16u(s, r0, r0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (val == (int8_t)val) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_ARITH_EvIb + rexw, c, r0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (rexw == 0 || val == (int32_t)val) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_ARITH_EvIz + rexw, c, r0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; tcg_abort();<BR>}</P>
<P>static void tcg_out_addi(TCGContext *s, int reg, tcg_target_long val)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (val != 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithi(s, ARITH_ADD + P_REXW, reg, val, 0);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* Use SMALL != 0 to force a short forward branch.&nbsp; */<BR>static void tcg_out_jxx(TCGContext *s, int opc, TCGLabel *l, int small)<BR>{<BR>&nbsp;&nbsp;&nbsp; int32_t val, val1;</P>
<P>&nbsp;&nbsp;&nbsp; if (l-&gt;has_value) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = tcg_pcrel_diff(s, l-&gt;u.value_ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val1 = val - 2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((int8_t)val1 == val1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (opc == -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, OPC_JMP_short);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, OPC_JCC_short + opc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, val1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (small) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (opc == -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, OPC_JMP_long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, val - 5);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_JCC_long + opc, 0, 0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, val - 6);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else if (small) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (opc == -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, OPC_JMP_short);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, OPC_JCC_short + opc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_reloc(s, s-&gt;code_ptr, R_386_PC8, l, -1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;code_ptr += 1;<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (opc == -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, OPC_JMP_long);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_JCC_long + opc, 0, 0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_reloc(s, s-&gt;code_ptr, R_386_PC32, l, -4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;code_ptr += 4;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void tcg_out_cmp(TCGContext *s, TCGArg arg1, TCGArg arg2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int const_arg2, int rexw)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (const_arg2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arg2 == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* test r, r */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_TESTL + rexw, arg1, arg1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithi(s, ARITH_CMP + rexw, arg1, arg2, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithr(s, ARITH_CMP + rexw, arg1, arg2);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void tcg_out_brcond32(TCGContext *s, TCGCond cond,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg arg1, TCGArg arg2, int const_arg2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGLabel *label, int small)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_cmp(s, arg1, arg2, const_arg2, 0);<BR>&nbsp;&nbsp;&nbsp; tcg_out_jxx(s, tcg_cond_to_jcc[cond], label, small);<BR>}</P>
<P>#if TCG_TARGET_REG_BITS == 64<BR>static void tcg_out_brcond64(TCGContext *s, TCGCond cond,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg arg1, TCGArg arg2, int const_arg2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGLabel *label, int small)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_cmp(s, arg1, arg2, const_arg2, P_REXW);<BR>&nbsp;&nbsp;&nbsp; tcg_out_jxx(s, tcg_cond_to_jcc[cond], label, small);<BR>}<BR>#else<BR>/* XXX: we implement it at the target level to avoid having to<BR>&nbsp;&nbsp; handle cross basic blocks temporaries */<BR>static void tcg_out_brcond2(TCGContext *s, const TCGArg *args,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int *const_args, int small)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGLabel *label_next = gen_new_label();<BR>&nbsp;&nbsp;&nbsp; TCGLabel *label_this = arg_label(args[5]);</P>
<P>&nbsp;&nbsp;&nbsp; switch(args[4]) {<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_EQ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_NE, args[0], args[2], const_args[2],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_next, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_EQ, args[1], args[3], const_args[3],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_NE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_NE, args[0], args[2], const_args[2],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_NE, args[1], args[3], const_args[3],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_LT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_LT, args[1], args[3], const_args[3],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_jxx(s, JCC_JNE, label_next, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_LTU, args[0], args[2], const_args[2],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_LE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_LT, args[1], args[3], const_args[3],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_jxx(s, JCC_JNE, label_next, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_LEU, args[0], args[2], const_args[2],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_GT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_GT, args[1], args[3], const_args[3],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_jxx(s, JCC_JNE, label_next, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_GTU, args[0], args[2], const_args[2],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_GE:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_GT, args[1], args[3], const_args[3],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_jxx(s, JCC_JNE, label_next, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_GEU, args[0], args[2], const_args[2],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_LTU:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_LTU, args[1], args[3], const_args[3],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_jxx(s, JCC_JNE, label_next, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_LTU, args[0], args[2], const_args[2],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_LEU:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_LTU, args[1], args[3], const_args[3],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_jxx(s, JCC_JNE, label_next, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_LEU, args[0], args[2], const_args[2],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_GTU:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_GTU, args[1], args[3], const_args[3],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_jxx(s, JCC_JNE, label_next, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_GTU, args[0], args[2], const_args[2],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case TCG_COND_GEU:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_GTU, args[1], args[3], const_args[3],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_jxx(s, JCC_JNE, label_next, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, TCG_COND_GEU, args[0], args[2], const_args[2],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_this, small);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_out_label(s, label_next, s-&gt;code_ptr);<BR>}<BR>#endif</P>
<P>static void tcg_out_setcond32(TCGContext *s, TCGCond cond, TCGArg dest,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg arg1, TCGArg arg2, int const_arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_cmp(s, arg1, arg2, const_arg2, 0);<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_SETCC | tcg_cond_to_jcc[cond], 0, dest);<BR>&nbsp;&nbsp;&nbsp; tcg_out_ext8u(s, dest, dest);<BR>}</P>
<P>#if TCG_TARGET_REG_BITS == 64<BR>static void tcg_out_setcond64(TCGContext *s, TCGCond cond, TCGArg dest,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg arg1, TCGArg arg2, int const_arg2)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_cmp(s, arg1, arg2, const_arg2, P_REXW);<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_SETCC | tcg_cond_to_jcc[cond], 0, dest);<BR>&nbsp;&nbsp;&nbsp; tcg_out_ext8u(s, dest, dest);<BR>}<BR>#else<BR>static void tcg_out_setcond2(TCGContext *s, const TCGArg *args,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int *const_args)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGArg new_args[6];<BR>&nbsp;&nbsp;&nbsp; TCGLabel *label_true, *label_over;</P>
<P>&nbsp;&nbsp;&nbsp; memcpy(new_args, args+1, 5*sizeof(TCGArg));</P>
<P>&nbsp;&nbsp;&nbsp; if (args[0] == args[1] || args[0] == args[2]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (!const_args[3] &amp;&amp; args[0] == args[3])<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || (!const_args[4] &amp;&amp; args[0] == args[4])) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* When the destination overlaps with one of the argument<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; registers, don't do anything tricky.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_true = gen_new_label();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_over = gen_new_label();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_args[5] = label_arg(label_true);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond2(s, new_args, const_args+1, 1);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movi(s, TCG_TYPE_I32, args[0], 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_jxx(s, JCC_JMP, label_over, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_label(s, label_true, s-&gt;code_ptr);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movi(s, TCG_TYPE_I32, args[0], 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_label(s, label_over, s-&gt;code_ptr);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* When the destination does not overlap one of the arguments,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear the destination first, jump if cond false, and emit an<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; increment in the true case.&nbsp; This results in smaller code.&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movi(s, TCG_TYPE_I32, args[0], 0);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_over = gen_new_label();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_args[4] = tcg_invert_cond(new_args[4]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_args[5] = label_arg(label_over);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond2(s, new_args, const_args+1, 1);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithi(s, ARITH_ADD, args[0], 1, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_label(s, label_over, s-&gt;code_ptr);<BR>&nbsp;&nbsp;&nbsp; }<BR>}<BR>#endif</P>
<P>static void tcg_out_movcond32(TCGContext *s, TCGCond cond, TCGArg dest,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg c1, TCGArg c2, int const_c2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg v1)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_cmp(s, c1, c2, const_c2, 0);<BR>&nbsp;&nbsp;&nbsp; if (have_cmov) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_CMOVCC | tcg_cond_to_jcc[cond], dest, v1);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGLabel *over = gen_new_label();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_jxx(s, tcg_cond_to_jcc[tcg_invert_cond(cond)], over, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_I32, dest, v1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_label(s, over, s-&gt;code_ptr);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>#if TCG_TARGET_REG_BITS == 64<BR>static void tcg_out_movcond64(TCGContext *s, TCGCond cond, TCGArg dest,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg c1, TCGArg c2, int const_c2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg v1)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_cmp(s, c1, c2, const_c2, P_REXW);<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_CMOVCC | tcg_cond_to_jcc[cond] | P_REXW, dest, v1);<BR>}<BR>#endif</P>
<P>static void tcg_out_branch(TCGContext *s, int call, tcg_insn_unit *dest)<BR>{<BR>&nbsp;&nbsp;&nbsp; intptr_t disp = tcg_pcrel_diff(s, dest) - 5;</P>
<P>&nbsp;&nbsp;&nbsp; if (disp == (int32_t)disp) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, call ? OPC_CALL_Jz : OPC_JMP_long, 0, 0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, disp);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_R10, (uintptr_t)dest);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_GRP5,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call ? EXT5_CALLN_Ev : EXT5_JMPN_Ev, TCG_REG_R10);<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static inline void tcg_out_call(TCGContext *s, tcg_insn_unit *dest)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_branch(s, 1, dest);<BR>}</P>
<P>static void tcg_out_jmp(TCGContext *s, tcg_insn_unit *dest)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_out_branch(s, 0, dest);<BR>}</P>
<P>#if defined(CONFIG_SOFTMMU)<BR>/* helper signature: helper_ret_ld_mmu(CPUState *env, target_ulong addr,<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mmu_idx, uintptr_t ra)<BR>&nbsp;*/<BR>static void * const qemu_ld_helpers[16] = {<BR>&nbsp;&nbsp;&nbsp; [MO_UB]&nbsp;&nbsp; = helper_ret_ldub_mmu,<BR>&nbsp;&nbsp;&nbsp; [MO_LEUW] = helper_le_lduw_mmu,<BR>&nbsp;&nbsp;&nbsp; [MO_LEUL] = helper_le_ldul_mmu,<BR>&nbsp;&nbsp;&nbsp; [MO_LEQ]&nbsp; = helper_le_ldq_mmu,<BR>&nbsp;&nbsp;&nbsp; [MO_BEUW] = helper_be_lduw_mmu,<BR>&nbsp;&nbsp;&nbsp; [MO_BEUL] = helper_be_ldul_mmu,<BR>&nbsp;&nbsp;&nbsp; [MO_BEQ]&nbsp; = helper_be_ldq_mmu,<BR>};</P>
<P>/* helper signature: helper_ret_st_mmu(CPUState *env, target_ulong addr,<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uintxx_t val, int mmu_idx, uintptr_t ra)<BR>&nbsp;*/<BR>static void * const qemu_st_helpers[16] = {<BR>&nbsp;&nbsp;&nbsp; [MO_UB]&nbsp;&nbsp; = helper_ret_stb_mmu,<BR>&nbsp;&nbsp;&nbsp; [MO_LEUW] = helper_le_stw_mmu,<BR>&nbsp;&nbsp;&nbsp; [MO_LEUL] = helper_le_stl_mmu,<BR>&nbsp;&nbsp;&nbsp; [MO_LEQ]&nbsp; = helper_le_stq_mmu,<BR>&nbsp;&nbsp;&nbsp; [MO_BEUW] = helper_be_stw_mmu,<BR>&nbsp;&nbsp;&nbsp; [MO_BEUL] = helper_be_stl_mmu,<BR>&nbsp;&nbsp;&nbsp; [MO_BEQ]&nbsp; = helper_be_stq_mmu,<BR>};</P>
<P>/* Perform the TLB load and compare.</P>
<P>&nbsp;&nbsp; Inputs:<BR>&nbsp;&nbsp; ADDRLO and ADDRHI contain the low and high part of the address.</P>
<P>&nbsp;&nbsp; MEM_INDEX and S_BITS are the memory context and log2 size of the load.</P>
<P>&nbsp;&nbsp; WHICH is the offset into the CPUTLBEntry structure of the slot to read.<BR>&nbsp;&nbsp; This should be offsetof addr_read or addr_write.</P>
<P>&nbsp;&nbsp; Outputs:<BR>&nbsp;&nbsp; LABEL_PTRS is filled with 1 (32-bit addresses) or 2 (64-bit addresses)<BR>&nbsp;&nbsp; positions of the displacements of forward jumps to the TLB miss case.</P>
<P>&nbsp;&nbsp; Second argument register is loaded with the low part of the address.<BR>&nbsp;&nbsp; In the TLB hit case, it has been adjusted as indicated by the TLB<BR>&nbsp;&nbsp; and so is a host address.&nbsp; In the TLB miss case, it continues to<BR>&nbsp;&nbsp; hold a guest address.</P>
<P>&nbsp;&nbsp; First argument register is clobbered.&nbsp; */</P>
<P>static inline void tcg_out_tlb_load(TCGContext *s, TCGReg addrlo, TCGReg addrhi,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mem_index, TCGMemOp opc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_insn_unit **label_ptr, int which)<BR>{<BR>&nbsp;&nbsp;&nbsp; const TCGReg r0 = TCG_REG_L0;<BR>&nbsp;&nbsp;&nbsp; const TCGReg r1 = TCG_REG_L1;<BR>&nbsp;&nbsp;&nbsp; TCGType ttype = TCG_TYPE_I32;<BR>&nbsp;&nbsp;&nbsp; TCGType tlbtype = TCG_TYPE_I32;<BR>&nbsp;&nbsp;&nbsp; int trexw = 0, hrexw = 0, tlbrexw = 0;<BR>&nbsp;&nbsp;&nbsp; int s_mask = (1 &lt;&lt; (opc &amp; MO_SIZE)) - 1;<BR>&nbsp;&nbsp;&nbsp; bool aligned = (opc &amp; MO_AMASK) == MO_ALIGN || s_mask == 0;</P>
<P>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TARGET_LONG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ttype = TCG_TYPE_I64;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trexw = P_REXW;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TYPE_PTR == TCG_TYPE_I64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hrexw = P_REXW;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TARGET_PAGE_BITS + CPU_TLB_BITS &gt; 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlbtype = TCG_TYPE_I64;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlbrexw = P_REXW;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; tcg_out_mov(s, tlbtype, r0, addrlo);<BR>&nbsp;&nbsp;&nbsp; if (aligned) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, ttype, r1, addrlo);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* For unaligned access check that we don't cross pages using<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the page address of the last byte.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_LEA + trexw, r1, addrlo, s_mask);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; tcg_out_shifti(s, SHIFT_SHR + tlbrexw, r0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TARGET_PAGE_BITS - CPU_TLB_ENTRY_BITS);</P>
<P>&nbsp;&nbsp;&nbsp; tgen_arithi(s, ARITH_AND + trexw, r1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TARGET_PAGE_MASK | (aligned ? s_mask : 0), 0);<BR>&nbsp;&nbsp;&nbsp; tgen_arithi(s, ARITH_AND + tlbrexw, r0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (CPU_TLB_SIZE - 1) &lt;&lt; CPU_TLB_ENTRY_BITS, 0);</P>
<P>&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, OPC_LEA + hrexw, r0, TCG_AREG0, r0, 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUArchState, tlb_table[mem_index][0])<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + which);</P>
<P>&nbsp;&nbsp;&nbsp; /* cmp 0(r0), r1 */<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_CMP_GvEv + trexw, r1, r0, 0);</P>
<P>&nbsp;&nbsp;&nbsp; /* Prepare for both the fast path add of the tlb addend, and the slow<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; path function argument setup.&nbsp; There are two cases worth note:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For 32-bit guest and x86_64 host, MOVL zero-extends the guest address<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; before the fastpath ADDQ below.&nbsp; For 64-bit guest and x32 host, MOVQ<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copies the entire guest address for the slow path, while truncation<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for the 32-bit host happens with the fastpath ADDL below.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_out_mov(s, ttype, r1, addrlo);</P>
<P>&nbsp;&nbsp;&nbsp; /* jne slow_path */<BR>&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_JCC_long + JCC_JNE, 0, 0, 0);<BR>&nbsp;&nbsp;&nbsp; label_ptr[0] = s-&gt;code_ptr;<BR>&nbsp;&nbsp;&nbsp; s-&gt;code_ptr += 4;</P>
<P>&nbsp;&nbsp;&nbsp; if (TARGET_LONG_BITS &gt; TCG_TARGET_REG_BITS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* cmp 4(r0), addrhi */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_CMP_GvEv, addrhi, r0, 4);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* jne slow_path */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_JCC_long + JCC_JNE, 0, 0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_ptr[1] = s-&gt;code_ptr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;code_ptr += 4;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* TLB Hit.&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp; /* add addend(r0), r1 */<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_ADD_GvEv + hrexw, r1, r0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(CPUTLBEntry, addend) - which);<BR>}</P>
<P>/*<BR>&nbsp;* Record the context of a call to the out of line helper code for the slow path<BR>&nbsp;* for a load or store, so that we can later generate the correct helper code<BR>&nbsp;*/<BR>static void add_qemu_ldst_label(TCGContext *s, bool is_ld, TCGMemOpIdx oi,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGReg datalo, TCGReg datahi,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGReg addrlo, TCGReg addrhi,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_insn_unit *raddr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_insn_unit **label_ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGLabelQemuLdst *label = new_ldst_label(s);</P>
<P>&nbsp;&nbsp;&nbsp; label-&gt;is_ld = is_ld;<BR>&nbsp;&nbsp;&nbsp; label-&gt;oi = oi;<BR>&nbsp;&nbsp;&nbsp; label-&gt;datalo_reg = datalo;<BR>&nbsp;&nbsp;&nbsp; label-&gt;datahi_reg = datahi;<BR>&nbsp;&nbsp;&nbsp; label-&gt;addrlo_reg = addrlo;<BR>&nbsp;&nbsp;&nbsp; label-&gt;addrhi_reg = addrhi;<BR>&nbsp;&nbsp;&nbsp; label-&gt;raddr = raddr;<BR>&nbsp;&nbsp;&nbsp; label-&gt;label_ptr[0] = label_ptr[0];<BR>&nbsp;&nbsp;&nbsp; if (TARGET_LONG_BITS &gt; TCG_TARGET_REG_BITS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label-&gt;label_ptr[1] = label_ptr[1];<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/*<BR>&nbsp;* Generate code for the slow path for a load at the end of block<BR>&nbsp;*/<BR>static void tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *l)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi = l-&gt;oi;<BR>&nbsp;&nbsp;&nbsp; TCGMemOp opc = get_memop(oi);<BR>&nbsp;&nbsp;&nbsp; TCGReg data_reg;<BR>&nbsp;&nbsp;&nbsp; tcg_insn_unit **label_ptr = &amp;l-&gt;label_ptr[0];</P>
<P>&nbsp;&nbsp;&nbsp; /* resolve label address */<BR>&nbsp;&nbsp;&nbsp; tcg_patch32(label_ptr[0], s-&gt;code_ptr - label_ptr[0] - 4);<BR>&nbsp;&nbsp;&nbsp; if (TARGET_LONG_BITS &gt; TCG_TARGET_REG_BITS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_patch32(label_ptr[1], s-&gt;code_ptr - label_ptr[1] - 4);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ofs = 0;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_st(s, TCG_TYPE_PTR, TCG_AREG0, TCG_REG_ESP, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofs += 4;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_st(s, TCG_TYPE_I32, l-&gt;addrlo_reg, TCG_REG_ESP, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofs += 4;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TARGET_LONG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_st(s, TCG_TYPE_I32, l-&gt;addrhi_reg, TCG_REG_ESP, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofs += 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_sti(s, TCG_TYPE_I32, TCG_REG_ESP, ofs, oi);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofs += 4;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_sti(s, TCG_TYPE_PTR, TCG_REG_ESP, ofs, (uintptr_t)l-&gt;raddr);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_PTR, tcg_target_call_iarg_regs[0], TCG_AREG0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The second argument is already loaded with addrlo.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movi(s, TCG_TYPE_I32, tcg_target_call_iarg_regs[2], oi);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movi(s, TCG_TYPE_PTR, tcg_target_call_iarg_regs[3],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (uintptr_t)l-&gt;raddr);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; tcg_out_call(s, qemu_ld_helpers[opc &amp; (MO_BSWAP | MO_SIZE)]);</P>
<P>&nbsp;&nbsp;&nbsp; data_reg = l-&gt;datalo_reg;<BR>&nbsp;&nbsp;&nbsp; switch (opc &amp; MO_SSIZE) {<BR>&nbsp;&nbsp;&nbsp; case MO_SB:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext8s(s, data_reg, TCG_REG_EAX, P_REXW);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case MO_SW:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext16s(s, data_reg, TCG_REG_EAX, P_REXW);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>#if TCG_TARGET_REG_BITS == 64<BR>&nbsp;&nbsp;&nbsp; case MO_SL:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext32s(s, data_reg, TCG_REG_EAX);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; case MO_UB:<BR>&nbsp;&nbsp;&nbsp; case MO_UW:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note that the helpers have zero-extended to tcg_target_long.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; case MO_UL:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_I32, data_reg, TCG_REG_EAX);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case MO_Q:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_I64, data_reg, TCG_REG_RAX);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (data_reg == TCG_REG_EDX) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* xchg %edx, %eax */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_XCHG_ax_r32 + TCG_REG_EDX, 0, 0, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_I32, l-&gt;datahi_reg, TCG_REG_EAX);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_I32, data_reg, TCG_REG_EAX);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_I32, l-&gt;datahi_reg, TCG_REG_EDX);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* Jump to the code corresponding to next IR of qemu_st */<BR>&nbsp;&nbsp;&nbsp; tcg_out_jmp(s, l-&gt;raddr);<BR>}</P>
<P>/*<BR>&nbsp;* Generate code for the slow path for a store at the end of block<BR>&nbsp;*/<BR>static void tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *l)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi = l-&gt;oi;<BR>&nbsp;&nbsp;&nbsp; TCGMemOp opc = get_memop(oi);<BR>&nbsp;&nbsp;&nbsp; TCGMemOp s_bits = opc &amp; MO_SIZE;<BR>&nbsp;&nbsp;&nbsp; tcg_insn_unit **label_ptr = &amp;l-&gt;label_ptr[0];<BR>&nbsp;&nbsp;&nbsp; TCGReg retaddr;</P>
<P>&nbsp;&nbsp;&nbsp; /* resolve label address */<BR>&nbsp;&nbsp;&nbsp; tcg_patch32(label_ptr[0], s-&gt;code_ptr - label_ptr[0] - 4);<BR>&nbsp;&nbsp;&nbsp; if (TARGET_LONG_BITS &gt; TCG_TARGET_REG_BITS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_patch32(label_ptr[1], s-&gt;code_ptr - label_ptr[1] - 4);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ofs = 0;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_st(s, TCG_TYPE_PTR, TCG_AREG0, TCG_REG_ESP, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofs += 4;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_st(s, TCG_TYPE_I32, l-&gt;addrlo_reg, TCG_REG_ESP, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofs += 4;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TARGET_LONG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_st(s, TCG_TYPE_I32, l-&gt;addrhi_reg, TCG_REG_ESP, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofs += 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_st(s, TCG_TYPE_I32, l-&gt;datalo_reg, TCG_REG_ESP, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofs += 4;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s_bits == MO_64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_st(s, TCG_TYPE_I32, l-&gt;datahi_reg, TCG_REG_ESP, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofs += 4;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_sti(s, TCG_TYPE_I32, TCG_REG_ESP, ofs, oi);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofs += 4;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retaddr = TCG_REG_EAX;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movi(s, TCG_TYPE_PTR, retaddr, (uintptr_t)l-&gt;raddr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_st(s, TCG_TYPE_PTR, retaddr, TCG_REG_ESP, ofs);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_PTR, tcg_target_call_iarg_regs[0], TCG_AREG0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The second argument is already loaded with addrlo.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, (s_bits == MO_64 ? TCG_TYPE_I64 : TCG_TYPE_I32),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_target_call_iarg_regs[2], l-&gt;datalo_reg);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movi(s, TCG_TYPE_I32, tcg_target_call_iarg_regs[3], oi);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ARRAY_SIZE(tcg_target_call_iarg_regs) &gt; 4) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retaddr = tcg_target_call_iarg_regs[4];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movi(s, TCG_TYPE_PTR, retaddr, (uintptr_t)l-&gt;raddr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retaddr = TCG_REG_RAX;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movi(s, TCG_TYPE_PTR, retaddr, (uintptr_t)l-&gt;raddr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_st(s, TCG_TYPE_PTR, retaddr, TCG_REG_ESP,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCG_TARGET_CALL_STACK_OFFSET);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; /* "Tail call" to the helper, with the return address back inline.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_out_push(s, retaddr);<BR>&nbsp;&nbsp;&nbsp; tcg_out_jmp(s, qemu_st_helpers[opc &amp; (MO_BSWAP | MO_SIZE)]);<BR>}<BR>#elif defined(__x86_64__) &amp;&amp; defined(__linux__)<BR># include &lt;asm/prctl.h&gt;<BR># include &lt;sys/prctl.h&gt;</P>
<P>int arch_prctl(int code, unsigned long addr);</P>
<P>static int guest_base_flags;<BR>static inline void setup_guest_base_seg(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (arch_prctl(ARCH_SET_GS, guest_base) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guest_base_flags = P_GS;<BR>&nbsp;&nbsp;&nbsp; }<BR>}<BR>#else<BR># define guest_base_flags 0<BR>static inline void setup_guest_base_seg(void) { }<BR>#endif /* SOFTMMU */</P>
<P>static void tcg_out_qemu_ld_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGReg base, int index, intptr_t ofs,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int seg, TCGMemOp memop)<BR>{<BR>&nbsp;&nbsp;&nbsp; const TCGMemOp real_bswap = memop &amp; MO_BSWAP;<BR>&nbsp;&nbsp;&nbsp; TCGMemOp bswap = real_bswap;<BR>&nbsp;&nbsp;&nbsp; int movop = OPC_MOVL_GvEv;</P>
<P>&nbsp;&nbsp;&nbsp; if (have_movbe &amp;&amp; real_bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bswap = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movop = OPC_MOVBE_GyMy;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch (memop &amp; MO_SSIZE) {<BR>&nbsp;&nbsp;&nbsp; case MO_UB:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, OPC_MOVZBL + seg, datalo,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base, index, 0, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case MO_SB:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, OPC_MOVSBL + P_REXW + seg, datalo,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base, index, 0, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case MO_UW:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, OPC_MOVZWL + seg, datalo,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base, index, 0, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (real_bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_rolw_8(s, datalo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case MO_SW:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (real_bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (have_movbe) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, OPC_MOVBE_GyMy + P_DATA16 + seg,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datalo, base, index, 0, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, OPC_MOVZWL + seg, datalo,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base, index, 0, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_rolw_8(s, datalo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_MOVSWL + P_REXW, datalo, datalo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, OPC_MOVSWL + P_REXW + seg,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datalo, base, index, 0, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case MO_UL:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, movop + seg, datalo, base, index, 0, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_bswap32(s, datalo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>#if TCG_TARGET_REG_BITS == 64<BR>&nbsp;&nbsp;&nbsp; case MO_SL:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (real_bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, movop + seg, datalo,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base, index, 0, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_bswap32(s, datalo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext32s(s, datalo, datalo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, OPC_MOVSLQ + seg, datalo,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base, index, 0, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; case MO_Q:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, movop + P_REXW + seg, datalo,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base, index, 0, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_bswap64(s, datalo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (real_bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int t = datalo;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datalo = datahi;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datahi = t;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (base != datalo) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, movop + seg, datalo,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base, index, 0, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, movop + seg, datahi,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base, index, 0, ofs + 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, movop + seg, datahi,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base, index, 0, ofs + 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, movop + seg, datalo,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base, index, 0, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_bswap32(s, datalo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_bswap32(s, datahi);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>/* XXX: qemu_ld and qemu_st could be modified to clobber only EDX and<BR>&nbsp;&nbsp; EAX. It will be useful once fixed registers globals are less<BR>&nbsp;&nbsp; common. */<BR>static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGReg datalo, datahi, addrlo;<BR>&nbsp;&nbsp;&nbsp; TCGReg addrhi __attribute__((unused));<BR>&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi;<BR>&nbsp;&nbsp;&nbsp; TCGMemOp opc;<BR>#if defined(CONFIG_SOFTMMU)<BR>&nbsp;&nbsp;&nbsp; int mem_index;<BR>&nbsp;&nbsp;&nbsp; tcg_insn_unit *label_ptr[2];<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; datalo = *args++;<BR>&nbsp;&nbsp;&nbsp; datahi = (TCG_TARGET_REG_BITS == 32 &amp;&amp; is64 ? *args++ : 0);<BR>&nbsp;&nbsp;&nbsp; addrlo = *args++;<BR>&nbsp;&nbsp;&nbsp; addrhi = (TARGET_LONG_BITS &gt; TCG_TARGET_REG_BITS ? *args++ : 0);<BR>&nbsp;&nbsp;&nbsp; oi = *args++;<BR>&nbsp;&nbsp;&nbsp; opc = get_memop(oi);</P>
<P>#if defined(CONFIG_SOFTMMU)<BR>&nbsp;&nbsp;&nbsp; mem_index = get_mmuidx(oi);</P>
<P>&nbsp;&nbsp;&nbsp; tcg_out_tlb_load(s, addrlo, addrhi, mem_index, opc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_ptr, offsetof(CPUTLBEntry, addr_read));</P>
<P>&nbsp;&nbsp;&nbsp; /* TLB Hit.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_out_qemu_ld_direct(s, datalo, datahi, TCG_REG_L1, -1, 0, 0, opc);</P>
<P>&nbsp;&nbsp;&nbsp; /* Record the current context of a load into ldst label */<BR>&nbsp;&nbsp;&nbsp; add_qemu_ldst_label(s, true, oi, datalo, datahi, addrlo, addrhi,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;code_ptr, label_ptr);<BR>#else<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t offset = guest_base;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGReg base = addrlo;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int index = -1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int seg = 0;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* For a 32-bit guest, the high 32 bits may contain garbage.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We can do this with the ADDR32 prefix if we're not using<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a guest base, or when using segmentation.&nbsp; Otherwise we<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; need to zero-extend manually.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (guest_base == 0 || guest_base_flags) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg = guest_base_flags;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS &gt; TARGET_LONG_BITS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg |= P_ADDR32;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TARGET_LONG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext32u(s, TCG_REG_L0, base);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base = TCG_REG_L0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (offset != guest_base) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movi(s, TCG_TYPE_I64, TCG_REG_L1, guest_base);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index = TCG_REG_L1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_qemu_ld_direct(s, datalo, datahi,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base, index, offset, seg, opc);<BR>&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>}</P>
<P>static void tcg_out_qemu_st_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGReg base, intptr_t ofs, int seg,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGMemOp memop)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* ??? Ideally we wouldn't need a scratch register.&nbsp; For user-only,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; we could perform the bswap twice to restore the original value<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instead of moving to the scratch.&nbsp; But as it is, the L constraint<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; means that TCG_REG_L0 is definitely free here.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; const TCGReg scratch = TCG_REG_L0;<BR>&nbsp;&nbsp;&nbsp; const TCGMemOp real_bswap = memop &amp; MO_BSWAP;<BR>&nbsp;&nbsp;&nbsp; TCGMemOp bswap = real_bswap;<BR>&nbsp;&nbsp;&nbsp; int movop = OPC_MOVL_EvGv;</P>
<P>&nbsp;&nbsp;&nbsp; if (have_movbe &amp;&amp; real_bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bswap = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movop = OPC_MOVBE_MyGy;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; switch (memop &amp; MO_SIZE) {<BR>&nbsp;&nbsp;&nbsp; case MO_8:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* In 32-bit mode, 8-bit stores can only happen from [abcd]x.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Use the scratch register if necessary.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 32 &amp;&amp; datalo &gt;= 4) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_I32, scratch, datalo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datalo = scratch;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVB_EvGv + P_REXB_R + seg,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datalo, base, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case MO_16:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_I32, scratch, datalo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_rolw_8(s, scratch);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datalo = scratch;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, movop + P_DATA16 + seg, datalo, base, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case MO_32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_I32, scratch, datalo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_bswap32(s, scratch);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datalo = scratch;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, movop + seg, datalo, base, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case MO_64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_I64, scratch, datalo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_bswap64(s, scratch);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datalo = scratch;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, movop + P_REXW + seg, datalo, base, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_I32, scratch, datahi);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_bswap32(s, scratch);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVL_EvGv + seg, scratch, base, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_I32, scratch, datalo);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_bswap32(s, scratch);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVL_EvGv + seg, scratch, base, ofs+4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (real_bswap) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int t = datalo;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datalo = datahi;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datahi = t;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, movop + seg, datalo, base, ofs);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, movop + seg, datahi, base, ofs+4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64)<BR>{<BR>&nbsp;&nbsp;&nbsp; TCGReg datalo, datahi, addrlo;<BR>&nbsp;&nbsp;&nbsp; TCGReg addrhi __attribute__((unused));<BR>&nbsp;&nbsp;&nbsp; TCGMemOpIdx oi;<BR>&nbsp;&nbsp;&nbsp; TCGMemOp opc;<BR>#if defined(CONFIG_SOFTMMU)<BR>&nbsp;&nbsp;&nbsp; int mem_index;<BR>&nbsp;&nbsp;&nbsp; tcg_insn_unit *label_ptr[2];<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; datalo = *args++;<BR>&nbsp;&nbsp;&nbsp; datahi = (TCG_TARGET_REG_BITS == 32 &amp;&amp; is64 ? *args++ : 0);<BR>&nbsp;&nbsp;&nbsp; addrlo = *args++;<BR>&nbsp;&nbsp;&nbsp; addrhi = (TARGET_LONG_BITS &gt; TCG_TARGET_REG_BITS ? *args++ : 0);<BR>&nbsp;&nbsp;&nbsp; oi = *args++;<BR>&nbsp;&nbsp;&nbsp; opc = get_memop(oi);</P>
<P>#if defined(CONFIG_SOFTMMU)<BR>&nbsp;&nbsp;&nbsp; mem_index = get_mmuidx(oi);</P>
<P>&nbsp;&nbsp;&nbsp; tcg_out_tlb_load(s, addrlo, addrhi, mem_index, opc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label_ptr, offsetof(CPUTLBEntry, addr_write));</P>
<P>&nbsp;&nbsp;&nbsp; /* TLB Hit.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_out_qemu_st_direct(s, datalo, datahi, TCG_REG_L1, 0, 0, opc);</P>
<P>&nbsp;&nbsp;&nbsp; /* Record the current context of a store into ldst label */<BR>&nbsp;&nbsp;&nbsp; add_qemu_ldst_label(s, false, oi, datalo, datahi, addrlo, addrhi,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;code_ptr, label_ptr);<BR>#else<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t offset = guest_base;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGReg base = addrlo;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int seg = 0;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* See comment in tcg_out_qemu_ld re zero-extension of addrlo.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (guest_base == 0 || guest_base_flags) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg = guest_base_flags;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS &gt; TARGET_LONG_BITS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg |= P_ADDR32;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ??? Note that we can't use the same SIB addressing scheme<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as for loads, since we require L0 free for bswap.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (offset != guest_base) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (TARGET_LONG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext32u(s, TCG_REG_L0, base);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base = TCG_REG_L0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movi(s, TCG_TYPE_I64, TCG_REG_L1, guest_base);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithr(s, ARITH_ADD + P_REXW, TCG_REG_L1, base);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base = TCG_REG_L1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (TARGET_LONG_BITS == 32) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext32u(s, TCG_REG_L1, base);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base = TCG_REG_L1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_qemu_st_direct(s, datalo, datahi, base, offset, seg, opc);<BR>&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>}</P>
<P>static inline void tcg_out_op(TCGContext *s, TCGOpcode opc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const TCGArg *args, const int *const_args)<BR>{<BR>&nbsp;&nbsp;&nbsp; int c, vexop, rexw = 0;</P>
<P>#if TCG_TARGET_REG_BITS == 64<BR># define OP_32_64(x) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case glue(glue(INDEX_op_, x), _i64): \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rexw = P_REXW; /* FALLTHRU */&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case glue(glue(INDEX_op_, x), _i32)<BR>#else<BR># define OP_32_64(x) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case glue(glue(INDEX_op_, x), _i32)<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; switch(opc) {<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_exit_tb:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_EAX, args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_jmp(s, tb_ret_addr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_goto_tb:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s-&gt;tb_jmp_offset) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* direct jump method */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, OPC_JMP_long); /* jmp im */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;tb_jmp_offset[args[0]] = tcg_current_code_size(s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* indirect jump method */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_GRP5, EXT5_JMPN_Ev, -1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (intptr_t)(s-&gt;tb_next + args[0]));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s-&gt;tb_next_offset[args[0]] = tcg_current_code_size(s);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_br:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_jxx(s, JCC_JMP, arg_label(args[0]), 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(ld8u):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note that we can ignore REXW for the zero-extend to 64-bit.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVZBL, args[0], args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(ld8s):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVSBL + rexw, args[0], args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(ld16u):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Note that we can ignore REXW for the zero-extend to 64-bit.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVZWL, args[0], args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(ld16s):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVSWL + rexw, args[0], args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>#if TCG_TARGET_REG_BITS == 64<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_ld32u_i64:<BR>#endif<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_ld_i32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ld(s, TCG_TYPE_I32, args[0], args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; OP_32_64(st8):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (const_args[0]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVB_EvIz,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVB_EvGv | P_REXB_R,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args[0], args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(st16):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (const_args[0]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVL_EvIz | P_DATA16,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out16(s, args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVL_EvGv | P_DATA16,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args[0], args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>#if TCG_TARGET_REG_BITS == 64<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_st32_i64:<BR>#endif<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_st_i32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (const_args[0]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVL_EvIz, 0, args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_st(s, TCG_TYPE_I32, args[0], args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; OP_32_64(add):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* For 3-operand addition, use LEA.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (args[0] != args[1]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCGArg a0 = args[0], a1 = args[1], a2 = args[2], c3 = 0;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (const_args[2]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c3 = a2, a2 = -1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (a0 == a2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Watch out for dest = src + dest, since we've removed<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the matching constraint on the add.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithr(s, ARITH_ADD + rexw, a0, a1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_sib_offset(s, OPC_LEA + rexw, a0, a1, a2, 0, c3);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = ARITH_ADD;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto gen_arith;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(sub):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = ARITH_SUB;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto gen_arith;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(and):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = ARITH_AND;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto gen_arith;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(or):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = ARITH_OR;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto gen_arith;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(xor):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = ARITH_XOR;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto gen_arith;<BR>&nbsp;&nbsp;&nbsp; gen_arith:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (const_args[2]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithi(s, c + rexw, args[0], args[2], 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithr(s, c + rexw, args[0], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; OP_32_64(andc):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (const_args[2]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_mov(s, rexw ? TCG_TYPE_I64 : TCG_TYPE_I32,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args[0], args[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithi(s, ARITH_AND + rexw, args[0], ~args[2], 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_vex_modrm(s, OPC_ANDN + rexw, args[0], args[2], args[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; OP_32_64(mul):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (const_args[2]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t val;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val = args[2];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (val == (int8_t)val) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_IMUL_GvEvIb + rexw, args[0], args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out8(s, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_IMUL_GvEvIz + rexw, args[0], args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, val);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_IMUL_GvEv + rexw, args[0], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; OP_32_64(div2):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_GRP3_Ev + rexw, EXT3_IDIV, args[4]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(divu2):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_GRP3_Ev + rexw, EXT3_DIV, args[4]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; OP_32_64(shl):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = SHIFT_SHL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vexop = OPC_SHLX;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto gen_shift_maybe_vex;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(shr):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = SHIFT_SHR;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vexop = OPC_SHRX;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto gen_shift_maybe_vex;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(sar):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = SHIFT_SAR;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vexop = OPC_SARX;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto gen_shift_maybe_vex;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(rotl):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = SHIFT_ROL;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto gen_shift;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(rotr):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = SHIFT_ROR;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto gen_shift;<BR>&nbsp;&nbsp;&nbsp; gen_shift_maybe_vex:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (have_bmi2 &amp;&amp; !const_args[2]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_vex_modrm(s, vexop + rexw, args[0], args[2], args[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* FALLTHRU */<BR>&nbsp;&nbsp;&nbsp; gen_shift:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (const_args[2]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_shifti(s, c + rexw, args[0], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_SHIFT_cl + rexw, c, args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case INDEX_op_brcond_i32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond32(s, args[2], args[0], args[1], const_args[1],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg_label(args[3]), 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_setcond_i32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_setcond32(s, args[3], args[0], args[1],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args[2], const_args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_movcond_i32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movcond32(s, args[5], args[0], args[1],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args[2], const_args[2], args[3]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; OP_32_64(bswap16):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_rolw_8(s, args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(bswap32):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_bswap32(s, args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; OP_32_64(neg):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_GRP3_Ev + rexw, EXT3_NEG, args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(not):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_GRP3_Ev + rexw, EXT3_NOT, args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; OP_32_64(ext8s):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext8s(s, args[0], args[1], rexw);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(ext16s):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext16s(s, args[0], args[1], rexw);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(ext8u):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext8u(s, args[0], args[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(ext16u):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext16u(s, args[0], args[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case INDEX_op_qemu_ld_i32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_qemu_ld(s, args, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_qemu_ld_i64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_qemu_ld(s, args, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_qemu_st_i32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_qemu_st(s, args, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_qemu_st_i64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_qemu_st(s, args, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; OP_32_64(mulu2):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_GRP3_Ev + rexw, EXT3_MUL, args[3]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(muls2):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_GRP3_Ev + rexw, EXT3_IMUL, args[3]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(add2):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (const_args[4]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithi(s, ARITH_ADD + rexw, args[0], args[4], 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithr(s, ARITH_ADD + rexw, args[0], args[4]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (const_args[5]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithi(s, ARITH_ADC + rexw, args[1], args[5], 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithr(s, ARITH_ADC + rexw, args[1], args[5]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; OP_32_64(sub2):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (const_args[4]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithi(s, ARITH_SUB + rexw, args[0], args[4], 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithr(s, ARITH_SUB + rexw, args[0], args[4]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (const_args[5]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithi(s, ARITH_SBB + rexw, args[1], args[5], 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tgen_arithr(s, ARITH_SBB + rexw, args[1], args[5]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>#if TCG_TARGET_REG_BITS == 32<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_brcond2_i32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond2(s, args, const_args, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_setcond2_i32:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_setcond2(s, args, const_args);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>#else /* TCG_TARGET_REG_BITS == 64 */<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_ld32s_i64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVSLQ, args[0], args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_ld_i64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ld(s, TCG_TYPE_I64, args[0], args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_st_i64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (const_args[0]) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_MOVL_EvIz | P_REXW,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out32(s, args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_st(s, TCG_TYPE_I64, args[0], args[1], args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case INDEX_op_brcond_i64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_brcond64(s, args[2], args[0], args[1], const_args[1],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg_label(args[3]), 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_setcond_i64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_setcond64(s, args[3], args[0], args[1],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args[2], const_args[2]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_movcond_i64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_movcond64(s, args[5], args[0], args[1],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args[2], const_args[2], args[3]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case INDEX_op_bswap64_i64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_bswap64(s, args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_extu_i32_i64:<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_ext32u_i64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext32u(s, args[0], args[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_ext_i32_i64:<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_ext32s_i64:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_ext32s(s, args[0], args[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; OP_32_64(deposit):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (args[3] == 0 &amp;&amp; args[4] == 8) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* load bits 0..7 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_MOVB_EvGv | P_REXB_R | P_REXB_RM,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args[2], args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (args[3] == 8 &amp;&amp; args[4] == 8) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* load bits 8..15 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_MOVB_EvGv, args[2], args[0] + 4);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (args[3] == 0 &amp;&amp; args[4] == 16) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* load bits 0..15 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_MOVL_EvGv | P_DATA16, args[2], args[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</P>
<P>&nbsp;&nbsp;&nbsp; case INDEX_op_mov_i32:&nbsp; /* Always emitted via tcg_out_mov.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_mov_i64:<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_movi_i32: /* Always emitted via tcg_out_movi.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_movi_i64:<BR>&nbsp;&nbsp;&nbsp; case INDEX_op_call:&nbsp;&nbsp;&nbsp;&nbsp; /* Always emitted via tcg_out_call.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_abort();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>#undef OP_32_64<BR>}</P>
<P>static const TCGTargetOpDef x86_op_defs[] = {<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_exit_tb, { } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_goto_tb, { } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_br, { } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ld8u_i32, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ld8s_i32, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ld16u_i32, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ld16s_i32, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ld_i32, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_st8_i32, { "qi", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_st16_i32, { "ri", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_st_i32, { "ri", "r" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_add_i32, { "r", "r", "ri" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_sub_i32, { "r", "0", "ri" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_mul_i32, { "r", "0", "ri" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_div2_i32, { "a", "d", "0", "1", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_divu2_i32, { "a", "d", "0", "1", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_and_i32, { "r", "0", "ri" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_or_i32, { "r", "0", "ri" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_xor_i32, { "r", "0", "ri" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_andc_i32, { "r", "r", "ri" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_shl_i32, { "r", "0", "Ci" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_shr_i32, { "r", "0", "Ci" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_sar_i32, { "r", "0", "Ci" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_rotl_i32, { "r", "0", "ci" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_rotr_i32, { "r", "0", "ci" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_brcond_i32, { "r", "ri" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_bswap16_i32, { "r", "0" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_bswap32_i32, { "r", "0" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_neg_i32, { "r", "0" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_not_i32, { "r", "0" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_ext8s_i32, { "r", "q" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ext16s_i32, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ext8u_i32, { "r", "q" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ext16u_i32, { "r", "r" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_setcond_i32, { "q", "r", "ri" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_deposit_i32, { "Q", "0", "Q" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_movcond_i32, { "r", "r", "ri", "r", "0" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_mulu2_i32, { "a", "d", "a", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_muls2_i32, { "a", "d", "a", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_add2_i32, { "r", "r", "0", "1", "ri", "ri" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_sub2_i32, { "r", "r", "0", "1", "ri", "ri" } },</P>
<P>#if TCG_TARGET_REG_BITS == 32<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_brcond2_i32, { "r", "r", "ri", "ri" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_setcond2_i32, { "r", "r", "r", "ri", "ri" } },<BR>#else<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ld8u_i64, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ld8s_i64, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ld16u_i64, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ld16s_i64, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ld32u_i64, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ld32s_i64, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ld_i64, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_st8_i64, { "ri", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_st16_i64, { "ri", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_st32_i64, { "ri", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_st_i64, { "re", "r" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_add_i64, { "r", "r", "re" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_mul_i64, { "r", "0", "re" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_div2_i64, { "a", "d", "0", "1", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_divu2_i64, { "a", "d", "0", "1", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_sub_i64, { "r", "0", "re" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_and_i64, { "r", "0", "reZ" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_or_i64, { "r", "0", "re" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_xor_i64, { "r", "0", "re" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_andc_i64, { "r", "r", "rI" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_shl_i64, { "r", "0", "Ci" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_shr_i64, { "r", "0", "Ci" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_sar_i64, { "r", "0", "Ci" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_rotl_i64, { "r", "0", "ci" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_rotr_i64, { "r", "0", "ci" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_brcond_i64, { "r", "re" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_setcond_i64, { "r", "r", "re" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_bswap16_i64, { "r", "0" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_bswap32_i64, { "r", "0" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_bswap64_i64, { "r", "0" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_neg_i64, { "r", "0" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_not_i64, { "r", "0" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_ext8s_i64, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ext16s_i64, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ext32s_i64, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ext8u_i64, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ext16u_i64, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_ext32u_i64, { "r", "r" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_ext_i32_i64, { "r", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_extu_i32_i64, { "r", "r" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_deposit_i64, { "Q", "0", "Q" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_movcond_i64, { "r", "r", "re", "r", "0" } },</P>
<P>&nbsp;&nbsp;&nbsp; { INDEX_op_mulu2_i64, { "a", "d", "a", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_muls2_i64, { "a", "d", "a", "r" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_add2_i64, { "r", "r", "0", "1", "re", "re" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_sub2_i64, { "r", "r", "0", "1", "re", "re" } },<BR>#endif</P>
<P>#if TCG_TARGET_REG_BITS == 64<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_qemu_ld_i32, { "r", "L" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_qemu_st_i32, { "L", "L" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_qemu_ld_i64, { "r", "L" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_qemu_st_i64, { "L", "L" } },<BR>#elif TARGET_LONG_BITS &lt;= TCG_TARGET_REG_BITS<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_qemu_ld_i32, { "r", "L" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_qemu_st_i32, { "L", "L" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_qemu_ld_i64, { "r", "r", "L" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_qemu_st_i64, { "L", "L", "L" } },<BR>#else<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_qemu_ld_i32, { "r", "L", "L" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_qemu_st_i32, { "L", "L", "L" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_qemu_ld_i64, { "r", "r", "L", "L" } },<BR>&nbsp;&nbsp;&nbsp; { INDEX_op_qemu_st_i64, { "L", "L", "L", "L" } },<BR>#endif<BR>&nbsp;&nbsp;&nbsp; { -1 },<BR>};</P>
<P>static int tcg_target_callee_save_regs[] = {<BR>#if TCG_TARGET_REG_BITS == 64<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RBP,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RBX,<BR>#if defined(_WIN64)<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RDI,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_RSI,<BR>#endif<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R12,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R13,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R14, /* Currently used for the global env. */<BR>&nbsp;&nbsp;&nbsp; TCG_REG_R15,<BR>#else<BR>&nbsp;&nbsp;&nbsp; TCG_REG_EBP, /* Currently used for the global env. */<BR>&nbsp;&nbsp;&nbsp; TCG_REG_EBX,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_ESI,<BR>&nbsp;&nbsp;&nbsp; TCG_REG_EDI,<BR>#endif<BR>};</P>
<P>/* Compute frame size via macros, to share between tcg_target_qemu_prologue<BR>&nbsp;&nbsp; and tcg_register_jit.&nbsp; */</P>
<P>#define PUSH_SIZE \<BR>&nbsp;&nbsp;&nbsp; ((1 + ARRAY_SIZE(tcg_target_callee_save_regs)) \<BR>&nbsp;&nbsp;&nbsp;&nbsp; * (TCG_TARGET_REG_BITS / 8))</P>
<P>#define FRAME_SIZE \<BR>&nbsp;&nbsp;&nbsp; ((PUSH_SIZE \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + TCG_STATIC_CALL_ARGS_SIZE \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + CPU_TEMP_BUF_NLONGS * sizeof(long) \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + TCG_TARGET_STACK_ALIGN - 1) \<BR>&nbsp;&nbsp;&nbsp;&nbsp; &amp; ~(TCG_TARGET_STACK_ALIGN - 1))</P>
<P>/* Generate global QEMU prologue and epilogue code */<BR>static void tcg_target_qemu_prologue(TCGContext *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; int i, stack_addend;</P>
<P>&nbsp;&nbsp;&nbsp; /* TB prologue */</P>
<P>&nbsp;&nbsp;&nbsp; /* Reserve some stack space, also for TCG temps.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; stack_addend = FRAME_SIZE - PUSH_SIZE;<BR>&nbsp;&nbsp;&nbsp; tcg_set_frame(s, TCG_REG_CALL_STACK, TCG_STATIC_CALL_ARGS_SIZE,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPU_TEMP_BUF_NLONGS * sizeof(long));</P>
<P>&nbsp;&nbsp;&nbsp; /* Save all callee saved registers.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; ARRAY_SIZE(tcg_target_callee_save_regs); i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_push(s, tcg_target_callee_save_regs[i]);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>#if TCG_TARGET_REG_BITS == 32<BR>&nbsp;&nbsp;&nbsp; tcg_out_ld(s, TCG_TYPE_PTR, TCG_AREG0, TCG_REG_ESP,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ARRAY_SIZE(tcg_target_callee_save_regs) + 1) * 4);<BR>&nbsp;&nbsp;&nbsp; tcg_out_addi(s, TCG_REG_ESP, -stack_addend);<BR>&nbsp;&nbsp;&nbsp; /* jmp *tb.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm_offset(s, OPC_GRP5, EXT5_JMPN_Ev, TCG_REG_ESP,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ARRAY_SIZE(tcg_target_callee_save_regs) + 2) * 4<BR>&nbsp;&nbsp;&nbsp; + stack_addend);<BR>#else<BR>&nbsp;&nbsp;&nbsp; tcg_out_mov(s, TCG_TYPE_PTR, TCG_AREG0, tcg_target_call_iarg_regs[0]);<BR>&nbsp;&nbsp;&nbsp; tcg_out_addi(s, TCG_REG_ESP, -stack_addend);<BR>&nbsp;&nbsp;&nbsp; /* jmp *tb.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; tcg_out_modrm(s, OPC_GRP5, EXT5_JMPN_Ev, tcg_target_call_iarg_regs[1]);<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; /* TB epilogue */<BR>&nbsp;&nbsp;&nbsp; tb_ret_addr = s-&gt;code_ptr;</P>
<P>&nbsp;&nbsp;&nbsp; tcg_out_addi(s, TCG_REG_CALL_STACK, stack_addend);</P>
<P>&nbsp;&nbsp;&nbsp; for (i = ARRAY_SIZE(tcg_target_callee_save_regs) - 1; i &gt;= 0; i--) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_out_pop(s, tcg_target_callee_save_regs[i]);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; tcg_out_opc(s, OPC_RET, 0, 0, 0);</P>
<P>#if !defined(CONFIG_SOFTMMU)<BR>&nbsp;&nbsp;&nbsp; /* Try to set up a segment register to point to guest_base.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; if (guest_base) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setup_guest_base_seg();<BR>&nbsp;&nbsp;&nbsp; }<BR>#endif<BR>}</P>
<P>static void tcg_target_init(TCGContext *s)<BR>{<BR>#ifdef CONFIG_CPUID_H<BR>&nbsp;&nbsp;&nbsp; unsigned a, b, c, d;<BR>&nbsp;&nbsp;&nbsp; int max = __get_cpuid_max(0, 0);</P>
<P>&nbsp;&nbsp;&nbsp; if (max &gt;= 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __cpuid(1, a, b, c, d);<BR>#ifndef have_cmov<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* For 32-bit, 99% certainty that we're running on hardware that<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; supports cmov, but we still need to check.&nbsp; In case cmov is not<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; available, we'll use a small forward branch.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; have_cmov = (d &amp; bit_CMOV) != 0;<BR>#endif<BR>#ifndef have_movbe<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* MOVBE is only available on Intel Atom and Haswell CPUs, so we<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; need to probe for it.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; have_movbe = (c &amp; bit_MOVBE) != 0;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (max &gt;= 7) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* BMI1 is available on AMD Piledriver and Intel Haswell CPUs.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __cpuid_count(7, 0, a, b, c, d);<BR>#ifdef bit_BMI<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; have_bmi1 = (b &amp; bit_BMI) != 0;<BR>#endif<BR>#ifndef have_bmi2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; have_bmi2 = (b &amp; bit_BMI2) != 0;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; }<BR>#endif</P>
<P>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 64) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set32(tcg_target_available_regs[TCG_TYPE_I32], 0, 0xffff);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set32(tcg_target_available_regs[TCG_TYPE_I64], 0, 0xffff);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set32(tcg_target_available_regs[TCG_TYPE_I32], 0, 0xff);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; tcg_regset_clear(tcg_target_call_clobber_regs);<BR>&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(tcg_target_call_clobber_regs, TCG_REG_EAX);<BR>&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(tcg_target_call_clobber_regs, TCG_REG_EDX);<BR>&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(tcg_target_call_clobber_regs, TCG_REG_ECX);<BR>&nbsp;&nbsp;&nbsp; if (TCG_TARGET_REG_BITS == 64) {<BR>#if !defined(_WIN64)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(tcg_target_call_clobber_regs, TCG_REG_RDI);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(tcg_target_call_clobber_regs, TCG_REG_RSI);<BR>#endif<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(tcg_target_call_clobber_regs, TCG_REG_R8);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(tcg_target_call_clobber_regs, TCG_REG_R9);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(tcg_target_call_clobber_regs, TCG_REG_R10);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(tcg_target_call_clobber_regs, TCG_REG_R11);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; tcg_regset_clear(s-&gt;reserved_regs);<BR>&nbsp;&nbsp;&nbsp; tcg_regset_set_reg(s-&gt;reserved_regs, TCG_REG_CALL_STACK);</P>
<P>&nbsp;&nbsp;&nbsp; tcg_add_target_add_op_defs(x86_op_defs);<BR>}</P>
<P>typedef struct {<BR>&nbsp;&nbsp;&nbsp; DebugFrameHeader h;<BR>&nbsp;&nbsp;&nbsp; uint8_t fde_def_cfa[4];<BR>&nbsp;&nbsp;&nbsp; uint8_t fde_reg_ofs[14];<BR>} DebugFrame;</P>
<P>/* We're expecting a 2 byte uleb128 encoded value.&nbsp; */<BR>QEMU_BUILD_BUG_ON(FRAME_SIZE &gt;= (1 &lt;&lt; 14));</P>
<P>#if !defined(__ELF__)<BR>&nbsp;&nbsp;&nbsp; /* Host machine without ELF. */<BR>#elif TCG_TARGET_REG_BITS == 64<BR>#define ELF_HOST_MACHINE EM_X86_64<BR>static const DebugFrame debug_frame = {<BR>&nbsp;&nbsp;&nbsp; .h.cie.len = sizeof(DebugFrameCIE)-4, /* length after .len member */<BR>&nbsp;&nbsp;&nbsp; .h.cie.id = -1,<BR>&nbsp;&nbsp;&nbsp; .h.cie.version = 1,<BR>&nbsp;&nbsp;&nbsp; .h.cie.code_align = 1,<BR>&nbsp;&nbsp;&nbsp; .h.cie.data_align = 0x78,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* sleb128 -8 */<BR>&nbsp;&nbsp;&nbsp; .h.cie.return_column = 16,</P>
<P>&nbsp;&nbsp;&nbsp; /* Total FDE size does not include the "len" member.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; .h.fde.len = sizeof(DebugFrame) - offsetof(DebugFrame, h.fde.cie_offset),</P>
<P>&nbsp;&nbsp;&nbsp; .fde_def_cfa = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12, 7,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_def_cfa %rsp, ... */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (FRAME_SIZE &amp; 0x7f) | 0x80,&nbsp;&nbsp;&nbsp;&nbsp; /* ... uleb128 FRAME_SIZE */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (FRAME_SIZE &gt;&gt; 7)<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; .fde_reg_ofs = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x90, 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_offset, %rip, -8 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The following ordering must match tcg_target_callee_save_regs.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x86, 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_offset, %rbp, -16 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x83, 3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_offset, %rbx, -24 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x8c, 4,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_offset, %r12, -32 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x8d, 5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_offset, %r13, -40 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x8e, 6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_offset, %r14, -48 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x8f, 7,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_offset, %r15, -56 */<BR>&nbsp;&nbsp;&nbsp; }<BR>};<BR>#else<BR>#define ELF_HOST_MACHINE EM_386<BR>static const DebugFrame debug_frame = {<BR>&nbsp;&nbsp;&nbsp; .h.cie.len = sizeof(DebugFrameCIE)-4, /* length after .len member */<BR>&nbsp;&nbsp;&nbsp; .h.cie.id = -1,<BR>&nbsp;&nbsp;&nbsp; .h.cie.version = 1,<BR>&nbsp;&nbsp;&nbsp; .h.cie.code_align = 1,<BR>&nbsp;&nbsp;&nbsp; .h.cie.data_align = 0x7c,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* sleb128 -4 */<BR>&nbsp;&nbsp;&nbsp; .h.cie.return_column = 8,</P>
<P>&nbsp;&nbsp;&nbsp; /* Total FDE size does not include the "len" member.&nbsp; */<BR>&nbsp;&nbsp;&nbsp; .h.fde.len = sizeof(DebugFrame) - offsetof(DebugFrame, h.fde.cie_offset),</P>
<P>&nbsp;&nbsp;&nbsp; .fde_def_cfa = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12, 4,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_def_cfa %esp, ... */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (FRAME_SIZE &amp; 0x7f) | 0x80,&nbsp;&nbsp;&nbsp;&nbsp; /* ... uleb128 FRAME_SIZE */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (FRAME_SIZE &gt;&gt; 7)<BR>&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp; .fde_reg_ofs = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x88, 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_offset, %eip, -4 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* The following ordering must match tcg_target_callee_save_regs.&nbsp; */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x85, 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_offset, %ebp, -8 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x83, 3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_offset, %ebx, -12 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x86, 4,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_offset, %esi, -16 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x87, 5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DW_CFA_offset, %edi, -20 */<BR>&nbsp;&nbsp;&nbsp; }<BR>};<BR>#endif</P>
<P>#if defined(ELF_HOST_MACHINE)<BR>void tcg_register_jit(void *buf, size_t buf_size)<BR>{<BR>&nbsp;&nbsp;&nbsp; tcg_register_jit_int(buf, buf_size, &amp;debug_frame, sizeof(debug_frame));<BR>}<BR>#endif