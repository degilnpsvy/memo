<H1>Documentation/TCG/backend-ops</H1>
<DIV id=contentSub></DIV>
<TABLE id=toc class=toc summary=Contents>
<TBODY>
<TR>
<TD>
<DIV id=toctitle>
<H2>Contents</H2><SPAN class=toctoggle>[<A id=togglelink class=internal toggleToc()?>hide</A>]</SPAN></DIV>
<UL>
<LI class=toclevel-1><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Backend_Ops"><SPAN class=tocnumber>1</SPAN> <SPAN class=toctext>Backend Ops</SPAN></A> 
<UL>
<LI class=toclevel-2><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Math"><SPAN class=tocnumber>1.1</SPAN> <SPAN class=toctext>Math</SPAN></A> 
<LI class=toclevel-2><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Bit"><SPAN class=tocnumber>1.2</SPAN> <SPAN class=toctext>Bit</SPAN></A> 
<LI class=toclevel-2><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Byte"><SPAN class=tocnumber>1.3</SPAN> <SPAN class=toctext>Byte</SPAN></A> 
<LI class=toclevel-2><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Load.2FStore"><SPAN class=tocnumber>1.4</SPAN> <SPAN class=toctext>Load/Store</SPAN></A> 
<LI class=toclevel-2><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Code_Flow"><SPAN class=tocnumber>1.5</SPAN> <SPAN class=toctext>Code Flow</SPAN></A> 
<LI class=toclevel-2><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Misc"><SPAN class=tocnumber>1.6</SPAN> <SPAN class=toctext>Misc</SPAN></A></LI></UL></LI></UL></TD></TR></TBODY></TABLE><A id=Backend_Ops name=Backend_Ops></A>
<H2><SPAN class=mw-headline>Backend Ops </SPAN></H2>
<P>These are the supported operations as implemented by the TCG backend for the host cpu (where QEMU executes; not what QEMU executes). This information is useful for people who want to port QEMU run on a new processor. </P><A id=Math name=Math></A>
<H3><SPAN class=mw-headline>Math </SPAN></H3>
<TABLE border=1>
<TBODY>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Addition class="external text" href="http://en.wikipedia.org/wiki/Addition" rel=nofollow>ADD</A> </TD>
<TD>Add two operands </TD>
<TD>ret = arg1 + arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Division_(mathematics) class="external text" href="http://en.wikipedia.org/wiki/Division_%28mathematics%29" rel=nofollow>DIV</A> </TD>
<TD>Divide two signed operands and return the quotient </TD>
<TD>ret = arg1 / arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Division_(mathematics) class="external text" href="http://en.wikipedia.org/wiki/Division_%28mathematics%29" rel=nofollow>DIVU</A> </TD>
<TD>Divide two unsigned operands and return the quotient </TD>
<TD>ret = arg1 / arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Assignment_(mathematical_logic) class="external text" href="http://en.wikipedia.org/wiki/Assignment_%28mathematical_logic%29" rel=nofollow>MOV</A> </TD>
<TD>Assign one operand to another </TD>
<TD>ret = arg1 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Multiplication class="external text" href="http://en.wikipedia.org/wiki/Multiplication" rel=nofollow>MUL</A> </TD>
<TD>Multiply two signed operands </TD>
<TD>ret = arg1 * arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Multiplication class="external text" href="http://en.wikipedia.org/wiki/Multiplication" rel=nofollow>MULU</A> </TD>
<TD>Multiply two unsigned operands </TD>
<TD>ret = arg1 * arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Negation class="external text" href="http://en.wikipedia.org/wiki/Negation" rel=nofollow>NEG</A> </TD>
<TD>Negate the sign of an operand </TD>
<TD>ret = -arg1 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Division_(mathematics) class="external text" href="http://en.wikipedia.org/wiki/Division_%28mathematics%29" rel=nofollow>REM</A> </TD>
<TD>Divide two signed operands and return the remainder </TD>
<TD>ret = arg1&nbsp;% arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Division_(mathematics) class="external text" href="http://en.wikipedia.org/wiki/Division_%28mathematics%29" rel=nofollow>REMU</A> </TD>
<TD>Divide two unsigned operands and return the remainder </TD>
<TD>ret = arg1&nbsp;% arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Subtraction class="external text" href="http://en.wikipedia.org/wiki/Subtraction" rel=nofollow>SUB</A> </TD>
<TD>Subtract two operands </TD>
<TD>ret = arg1 - arg2 </TD></TR></TBODY></TABLE><A id=Bit name=Bit></A>
<H3><SPAN class=mw-headline>Bit </SPAN></H3>
<TABLE border=1>
<TBODY>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_conjunction class="external text" href="http://en.wikipedia.org/wiki/Logical_conjunction" rel=nofollow>AND</A> </TD>
<TD>Logical AND two operands </TD>
<TD>ret = arg1 &amp; arg2 </TD></TR>
<TR>
<TD>ANDC </TD>
<TD>Logical AND one operand with the complement of another </TD>
<TD>ret = arg1 &amp; ~arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_equivalence class="external text" href="http://en.wikipedia.org/wiki/Logical_equivalence" rel=nofollow>EQV</A> </TD>
<TD>Compute logical equivalent of two operands </TD>
<TD>ret =&nbsp;!(arg1 ^ arg2) </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_NAND class="external text" href="http://en.wikipedia.org/wiki/Logical_NAND" rel=nofollow>NAND</A> </TD>
<TD>Logical NAND two operands </TD>
<TD>ret = arg1 &#8593; arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_NOR class="external text" href="http://en.wikipedia.org/wiki/Logical_NOR" rel=nofollow>NOR</A> </TD>
<TD>Logical NOR two operands </TD>
<TD>ret = arg1 &#8595; arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Negation class="external text" href="http://en.wikipedia.org/wiki/Negation" rel=nofollow>NOT</A> </TD>
<TD>Logical NOT an operand </TD>
<TD>ret =&nbsp;!arg1 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_disjunction class="external text" href="http://en.wikipedia.org/wiki/Logical_disjunction" rel=nofollow>OR</A> </TD>
<TD>Logical OR two operands </TD>
<TD>ret = arg1 | arg2 </TD></TR>
<TR>
<TD>ORC </TD>
<TD>Logical OR one operand with the complement of another </TD>
<TD>ret = arg1 | ~arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Circular_shift class="external text" href="http://en.wikipedia.org/wiki/Circular_shift" rel=nofollow>ROTL</A> </TD>
<TD>Rotate left one operand by magnitude of another </TD>
<TD>ret = arg1 rotl arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Circular_shift class="external text" href="http://en.wikipedia.org/wiki/Circular_shift" rel=nofollow>ROTR</A> </TD>
<TD>Rotate right one operand by magnitude of another </TD>
<TD>ret = arg1 rotr arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Arithmetic_shift class="external text" href="http://en.wikipedia.org/wiki/Arithmetic_shift" rel=nofollow>SAR</A> </TD>
<TD>Arithmetic shift right one operand by magnitude of another </TD>
<TD>ret = arg1 &gt;&gt; arg2 /* Sign bit used to fill vacant bits */ </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_shift class="external text" href="http://en.wikipedia.org/wiki/Logical_shift" rel=nofollow>SHL</A> </TD>
<TD>Logical shift left one operand by magnitude of another </TD>
<TD>ret = arg1 &lt;&lt; arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_shift class="external text" href="http://en.wikipedia.org/wiki/Logical_shift" rel=nofollow>SHR</A> </TD>
<TD>Logical shift right one operand by magnitude of another </TD>
<TD>ret = arg1 &gt;&gt; arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Exclusive_or class="external text" href="http://en.wikipedia.org/wiki/Exclusive_or" rel=nofollow>XOR</A> </TD>
<TD>Logical XOR two operands </TD>
<TD>ret = arg1 ^ arg2 </TD></TR></TBODY></TABLE><A id=Byte name=Byte></A>
<H3><SPAN class=mw-headline>Byte </SPAN></H3>
<TABLE border=1>
<TBODY>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Endianness class="external text" href="http://en.wikipedia.org/wiki/Endianness" rel=nofollow>BSWAP16</A> </TD>
<TD>Byte swap a 16bit quantity </TD>
<TD>ret = ((arg1 &amp; 0xff00) &gt;&gt; 8) | ((arg1 &amp; 0xff) &lt;&lt; 8) </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Endianness class="external text" href="http://en.wikipedia.org/wiki/Endianness" rel=nofollow>BSWAP32</A> </TD>
<TD>Byte swap a 32bit quantity </TD>
<TD>ret = ...see bswap16 and extend to 32bits... </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Endianness class="external text" href="http://en.wikipedia.org/wiki/Endianness" rel=nofollow>BSWAP64</A> </TD>
<TD>Byte swap a 64bit quantity </TD>
<TD>ret = ...see bswap32 and extend to 64bits... </TD></TR>
<TR>
<TD>EXT8S </TD>
<TD>Sign extend an 8bit operand </TD>
<TD>ret = (int8_t)arg1 </TD></TR>
<TR>
<TD>EXT8U </TD>
<TD>Zero extend an 8bit operand </TD>
<TD>ret = (uint8_t)arg1 </TD></TR>
<TR>
<TD>EXT16S </TD>
<TD>Sign extend an 16bit operand </TD>
<TD>ret = (int16_t)arg1 </TD></TR>
<TR>
<TD>EXT16U </TD>
<TD>Zero extend an 16bit operand </TD>
<TD>ret = (uint16_t)arg1 </TD></TR>
<TR>
<TD>EXT32S </TD>
<TD>Sign extend an 32bit operand </TD>
<TD>ret = (int32_t)arg1 </TD></TR>
<TR>
<TD>EXT32U </TD>
<TD>Zero extend an 32bit operand </TD>
<TD>ret = (uint32_t)arg1 </TD></TR></TBODY></TABLE><A id=Load.2FStore name=Load.2FStore></A>
<H3><SPAN class=mw-headline><FONT class=extract>Load/Store </FONT></SPAN></H3>
<P><FONT class=extract>These are for moving data between registers and arbitrary host memory. Typically used for funky CPU state that is not represented by dedicated registers already and thus infrequently used. These are not for accessing the target's memory space; see the QEMU_XX helpers below for that. </FONT></P>
<TABLE border=1>
<TBODY>
<TR>
<TD><FONT class=extract>LD8S </FONT></TD>
<TD><FONT class=extract>Load an 8bit quantity from host memory and sign extend </FONT></TD></TR>
<TR>
<TD><FONT class=extract>LD8U </FONT></TD>
<TD><FONT class=extract>Load an 8bit quantity from host memory and zero extend </FONT></TD></TR>
<TR>
<TD><FONT class=extract>LD16S </FONT></TD>
<TD><FONT class=extract>Load a 16bit quantity from host memory and sign extend </FONT></TD></TR>
<TR>
<TD><FONT class=extract>LD16U </FONT></TD>
<TD><FONT class=extract>Load a 16bit quantity from host memory and zero extend </FONT></TD></TR>
<TR>
<TD><FONT class=extract>LD32S </FONT></TD>
<TD><FONT class=extract>Load a 32bit quantity from host memory and sign extend </FONT></TD></TR>
<TR>
<TD><FONT class=extract>LD32U </FONT></TD>
<TD><FONT class=extract>Load a 32bit quantity from host memory and zero extend </FONT></TD></TR>
<TR>
<TD><FONT class=extract>LD64 </FONT></TD>
<TD><FONT class=extract>Load a 64bit quantity from host memory </FONT></TD></TR>
<TR>
<TD><FONT class=extract>LD </FONT></TD>
<TD><FONT class=extract>Alias to target native sized load </FONT></TD></TR>
<TR>
<TD><FONT class=extract>ST8 </FONT></TD>
<TD><FONT class=extract>Store a 8bit quantity to host memory </FONT></TD></TR>
<TR>
<TD><FONT class=extract>ST16 </FONT></TD>
<TD><FONT class=extract>Store a 16bit quantity to host memory </FONT></TD></TR>
<TR>
<TD><FONT class=extract>ST32 </FONT></TD>
<TD><FONT class=extract>Store a 32bit quantity to host memory </FONT></TD></TR>
<TR>
<TD><FONT class=extract>ST </FONT></TD>
<TD><FONT class=extract>Alias to target native sized store </FONT></TD></TR></TBODY></TABLE>
<P><FONT class=extract>These are for moving data between registers and arbitrary target memory. The address to load/store via is always the second argument while the first argument is always the value to be loaded/stored. The third argument (memory index) only makes sense for system targets; user targets will simply specify 0 all the time. </FONT></P>
<TABLE border=1>
<TBODY>
<TR>
<TD><FONT class=extract>QEMU_LD8S </FONT></TD>
<TD><FONT class=extract>Load an 8bit quantity from target memory and sign extend </FONT></TD>
<TD><FONT class=extract>ret = *(int8_t *)arg1 </FONT></TD></TR>
<TR>
<TD><FONT class=extract>QEMU_LD8U </FONT></TD>
<TD><FONT class=extract>Load an 8bit quantity from target memory and zero extend </FONT></TD>
<TD><FONT class=extract>ret = *(uint8_t *)arg1 </FONT></TD></TR>
<TR>
<TD><FONT class=extract>QEMU_LD16S </FONT></TD>
<TD><FONT class=extract>Load a 16bit quantity from target memory and sign extend </FONT></TD>
<TD><FONT class=extract>ret = *(int8_t *)arg1 </FONT></TD></TR>
<TR>
<TD><FONT class=extract>QEMU_LD16U </FONT></TD>
<TD><FONT class=extract>Load a 16bit quantity from target memory and zero extend </FONT></TD>
<TD><FONT class=extract>ret = *(uint8_t *)arg1 </FONT></TD></TR>
<TR>
<TD><FONT class=extract>QEMU_LD32S </FONT></TD>
<TD><FONT class=extract>Load a 32bit quantity from target memory and sign extend </FONT></TD>
<TD><FONT class=extract>ret = *(int8_t *)arg1 </FONT></TD></TR>
<TR>
<TD><FONT class=extract>QEMU_LD32U </FONT></TD>
<TD><FONT class=extract>Load a 32bit quantity from target memory and zero extend </FONT></TD>
<TD><FONT class=extract>ret = *(uint8_t *)arg1 </FONT></TD></TR>
<TR>
<TD><FONT class=extract>QEMU_LD64 </FONT></TD>
<TD><FONT class=extract>Load a 64bit quantity from target memory </FONT></TD>
<TD><FONT class=extract>ret = *(uint64_t *)arg1 </FONT></TD></TR>
<TR>
<TD><FONT class=extract>QEMU_ST8 </FONT></TD>
<TD><FONT class=extract>Store an 8bit quantity to target memory </FONT></TD>
<TD><FONT class=extract>*(uint8_t *)addr = arg </FONT></TD></TR>
<TR>
<TD><FONT class=extract>QEMU_ST16 </FONT></TD>
<TD><FONT class=extract>Store a 16bit quantity to target memory </FONT></TD>
<TD><FONT class=extract>*(uint16_t *)addr = arg </FONT></TD></TR>
<TR>
<TD><FONT class=extract>QEMU_ST32 </FONT></TD>
<TD><FONT class=extract>Store a 32bit quantity to target memory </FONT></TD>
<TD><FONT class=extract>*(uint32_t *)addr = arg </FONT></TD></TR>
<TR>
<TD><FONT class=extract>QEMU_ST64 </FONT></TD>
<TD><FONT class=extract>Store a 64bit quantity to target memory </FONT></TD>
<TD><FONT class=extract>*(uint64_t *)addr = arg </FONT></TD></TR></TBODY></TABLE><A id=Code_Flow name=Code_Flow></A>
<H3><SPAN class=mw-headline><FONT class=extract>Code Flow </FONT></SPAN></H3>
<TABLE border=1>
<TBODY>
<TR>
<TD><FONT class=extract>BR </FONT></TD>
<TD><FONT class=extract>Branch somewhere? </FONT></TD>
<TD><FONT class=extract></FONT></TD></TR>
<TR>
<TD><FONT class=extract>BRCOND </FONT></TD>
<TD><FONT class=extract>Test two operands and conditionally branch to a label </FONT></TD>
<TD><FONT class=extract>if (arg1 &lt;condition&gt; arg2) goto label </FONT></TD></TR>
<TR>
<TD><FONT class=extract>CALL </FONT></TD>
<TD><FONT class=extract>Call a helper function </FONT></TD>
<TD><FONT class=extract></FONT></TD></TR>
<TR>
<TD><FONT class=extract>GOTO_TB </FONT></TD>
<TD><FONT class=extract>Goto translation block </FONT></TD>
<TD><FONT class=extract></FONT></TD></TR>
<TR>
<TD><FONT class=extract>EXIT_TB </FONT></TD>
<TD><FONT class=extract>Exit translation block </FONT></TD>
<TD><FONT class=extract></FONT></TD></TR>
<TR>
<TD><FONT class=extract>SETCOND </FONT></TD>
<TD><FONT class=extract>Compare two operands </FONT></TD>
<TD><FONT class=extract>ret = arg1 &lt;condition&gt; arg2 </FONT></TD></TR>
<TR>
<TD><FONT class=extract>SET_LABEL </FONT></TD>
<TD><FONT class=extract>Mark the current location with a label </FONT></TD>
<TD><FONT class=extract>label: </FONT></TD></TR></TBODY></TABLE><A id=Misc name=Misc></A>
<H3><SPAN class=mw-headline><FONT class=extract>Misc </FONT></SPAN></H3>
<TABLE border=1>
<TBODY>
<TR>
<TD><FONT class=extract>DISCARD </FONT></TD>
<TD><FONT class=extract>Discard a register </FONT></TD></TR>
<TR>
<TD><FONT class=extract>NOP </FONT></TD>
<TD><FONT class=extract>Generate a No Operation insn </FONT></TD></TR></TBODY></TABLE>