<H1>Documentation/TCG/backend-ops</H1>
<DIV id=contentSub></DIV>
<TABLE id=toc class=toc summary=Contents>
<TBODY>
<TR>
<TD>
<DIV id=toctitle>
<H2>Contents</H2><SPAN class=toctoggle>[<A id=togglelink class=internal toggleToc()">hide</A>]</SPAN></DIV>
<UL>
<LI class=toclevel-1><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Backend_Ops"><SPAN class=tocnumber>1</SPAN> <SPAN class=toctext>Backend Ops</SPAN></A> 
<UL>
<LI class=toclevel-2><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Math"><SPAN class=tocnumber>1.1</SPAN> <SPAN class=toctext>Math</SPAN></A></LI>
<LI class=toclevel-2><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Bit"><SPAN class=tocnumber>1.2</SPAN> <SPAN class=toctext>Bit</SPAN></A></LI>
<LI class=toclevel-2><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Byte"><SPAN class=tocnumber>1.3</SPAN> <SPAN class=toctext>Byte</SPAN></A></LI>
<LI class=toclevel-2><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Load.2FStore"><SPAN class=tocnumber>1.4</SPAN> <SPAN class=toctext>Load/Store</SPAN></A></LI>
<LI class=toclevel-2><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Code_Flow"><SPAN class=tocnumber>1.5</SPAN> <SPAN class=toctext>Code Flow</SPAN></A></LI>
<LI class=toclevel-2><A href="http://wiki.qemu.org/Documentation/TCG/backend-ops#Misc"><SPAN class=tocnumber>1.6</SPAN> <SPAN class=toctext>Misc</SPAN></A></LI></UL></LI></UL></TD></TR></TBODY></TABLE><A id=Backend_Ops name=Backend_Ops></A>
<H2><SPAN class=mw-headline>Backend Ops </SPAN></H2>
<P>These are the supported operations as implemented by the TCG backend for the host cpu (where QEMU executes; not what QEMU executes). This information is useful for people who want to port QEMU run on a new processor. </P><A id=Math name=Math></A>
<H3><SPAN class=mw-headline>Math </SPAN></H3>
<TABLE border=1>
<TBODY>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Addition class="external text" href="http://en.wikipedia.org/wiki/Addition" rel=nofollow>ADD</A> </TD>
<TD>Add two operands </TD>
<TD>ret = arg1 + arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Division_(mathematics) class="external text" href="http://en.wikipedia.org/wiki/Division_%28mathematics%29" rel=nofollow>DIV</A> </TD>
<TD>Divide two signed operands and return the quotient </TD>
<TD>ret = arg1 / arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Division_(mathematics) class="external text" href="http://en.wikipedia.org/wiki/Division_%28mathematics%29" rel=nofollow>DIVU</A> </TD>
<TD>Divide two unsigned operands and return the quotient </TD>
<TD>ret = arg1 / arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Assignment_(mathematical_logic) class="external text" href="http://en.wikipedia.org/wiki/Assignment_%28mathematical_logic%29" rel=nofollow>MOV</A> </TD>
<TD>Assign one operand to another </TD>
<TD>ret = arg1 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Multiplication class="external text" href="http://en.wikipedia.org/wiki/Multiplication" rel=nofollow>MUL</A> </TD>
<TD>Multiply two signed operands </TD>
<TD>ret = arg1 * arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Multiplication class="external text" href="http://en.wikipedia.org/wiki/Multiplication" rel=nofollow>MULU</A> </TD>
<TD>Multiply two unsigned operands </TD>
<TD>ret = arg1 * arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Negation class="external text" href="http://en.wikipedia.org/wiki/Negation" rel=nofollow>NEG</A> </TD>
<TD>Negate the sign of an operand </TD>
<TD>ret = -arg1 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Division_(mathematics) class="external text" href="http://en.wikipedia.org/wiki/Division_%28mathematics%29" rel=nofollow>REM</A> </TD>
<TD>Divide two signed operands and return the remainder </TD>
<TD>ret = arg1&nbsp;% arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Division_(mathematics) class="external text" href="http://en.wikipedia.org/wiki/Division_%28mathematics%29" rel=nofollow>REMU</A> </TD>
<TD>Divide two unsigned operands and return the remainder </TD>
<TD>ret = arg1&nbsp;% arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Subtraction class="external text" href="http://en.wikipedia.org/wiki/Subtraction" rel=nofollow>SUB</A> </TD>
<TD>Subtract two operands </TD>
<TD>ret = arg1 - arg2 </TD></TR></TBODY></TABLE><A id=Bit name=Bit></A>
<H3><SPAN class=mw-headline>Bit </SPAN></H3>
<TABLE border=1>
<TBODY>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_conjunction class="external text" href="http://en.wikipedia.org/wiki/Logical_conjunction" rel=nofollow>AND</A> </TD>
<TD>Logical AND two operands </TD>
<TD>ret = arg1 &amp; arg2 </TD></TR>
<TR>
<TD>ANDC </TD>
<TD>Logical AND one operand with the complement of another </TD>
<TD>ret = arg1 &amp; ~arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_equivalence class="external text" href="http://en.wikipedia.org/wiki/Logical_equivalence" rel=nofollow>EQV</A> </TD>
<TD>Compute logical equivalent of two operands </TD>
<TD>ret =&nbsp;!(arg1 ^ arg2) </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_NAND class="external text" href="http://en.wikipedia.org/wiki/Logical_NAND" rel=nofollow>NAND</A> </TD>
<TD>Logical NAND two operands </TD>
<TD>ret = arg1 &#8593; arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_NOR class="external text" href="http://en.wikipedia.org/wiki/Logical_NOR" rel=nofollow>NOR</A> </TD>
<TD>Logical NOR two operands </TD>
<TD>ret = arg1 &#8595; arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Negation class="external text" href="http://en.wikipedia.org/wiki/Negation" rel=nofollow>NOT</A> </TD>
<TD>Logical NOT an operand </TD>
<TD>ret =&nbsp;!arg1 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_disjunction class="external text" href="http://en.wikipedia.org/wiki/Logical_disjunction" rel=nofollow>OR</A> </TD>
<TD>Logical OR two operands </TD>
<TD>ret = arg1 | arg2 </TD></TR>
<TR>
<TD>ORC </TD>
<TD>Logical OR one operand with the complement of another </TD>
<TD>ret = arg1 | ~arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Circular_shift class="external text" href="http://en.wikipedia.org/wiki/Circular_shift" rel=nofollow>ROTL</A> </TD>
<TD>Rotate left one operand by magnitude of another </TD>
<TD>ret = arg1 rotl arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Circular_shift class="external text" href="http://en.wikipedia.org/wiki/Circular_shift" rel=nofollow>ROTR</A> </TD>
<TD>Rotate right one operand by magnitude of another </TD>
<TD>ret = arg1 rotr arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Arithmetic_shift class="external text" href="http://en.wikipedia.org/wiki/Arithmetic_shift" rel=nofollow>SAR</A> </TD>
<TD>Arithmetic shift right one operand by magnitude of another </TD>
<TD>ret = arg1 &gt;&gt; arg2 /* Sign bit used to fill vacant bits */ </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_shift class="external text" href="http://en.wikipedia.org/wiki/Logical_shift" rel=nofollow>SHL</A> </TD>
<TD>Logical shift left one operand by magnitude of another </TD>
<TD>ret = arg1 &lt;&lt; arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Logical_shift class="external text" href="http://en.wikipedia.org/wiki/Logical_shift" rel=nofollow>SHR</A> </TD>
<TD>Logical shift right one operand by magnitude of another </TD>
<TD>ret = arg1 &gt;&gt; arg2 </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Exclusive_or class="external text" href="http://en.wikipedia.org/wiki/Exclusive_or" rel=nofollow>XOR</A> </TD>
<TD>Logical XOR two operands </TD>
<TD>ret = arg1 ^ arg2 </TD></TR></TBODY></TABLE><A id=Byte name=Byte></A>
<H3><SPAN class=mw-headline>Byte </SPAN></H3>
<TABLE border=1>
<TBODY>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Endianness class="external text" href="http://en.wikipedia.org/wiki/Endianness" rel=nofollow>BSWAP16</A> </TD>
<TD>Byte swap a 16bit quantity </TD>
<TD>ret = ((arg1 &amp; 0xff00) &gt;&gt; 8) | ((arg1 &amp; 0xff) &lt;&lt; 8) </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Endianness class="external text" href="http://en.wikipedia.org/wiki/Endianness" rel=nofollow>BSWAP32</A> </TD>
<TD>Byte swap a 32bit quantity </TD>
<TD>ret = ...see bswap16 and extend to 32bits... </TD></TR>
<TR>
<TD><A title=http://en.wikipedia.org/wiki/Endianness class="external text" href="http://en.wikipedia.org/wiki/Endianness" rel=nofollow>BSWAP64</A> </TD>
<TD>Byte swap a 64bit quantity </TD>
<TD>ret = ...see bswap32 and extend to 64bits... </TD></TR>
<TR>
<TD>EXT8S </TD>
<TD>Sign extend an 8bit operand </TD>
<TD>ret = (int8_t)arg1 </TD></TR>
<TR>
<TD>EXT8U </TD>
<TD>Zero extend an 8bit operand </TD>
<TD>ret = (uint8_t)arg1 </TD></TR>
<TR>
<TD>EXT16S </TD>
<TD>Sign extend an 16bit operand </TD>
<TD>ret = (int16_t)arg1 </TD></TR>
<TR>
<TD>EXT16U </TD>
<TD>Zero extend an 16bit operand </TD>
<TD>ret = (uint16_t)arg1 </TD></TR>
<TR>
<TD>EXT32S </TD>
<TD>Sign extend an 32bit operand </TD>
<TD>ret = (int32_t)arg1 </TD></TR>
<TR>
<TD>EXT32U </TD>
<TD>Zero extend an 32bit operand </TD>
<TD>ret = (uint32_t)arg1 </TD></TR></TBODY></TABLE><A id=Load.2FStore name=Load.2FStore></A>
<H3><SPAN class=mw-headline>Load/Store </SPAN></H3>
<P>These are for moving data between registers and arbitrary host memory. Typically used for funky CPU state that is not represented by dedicated registers already and thus infrequently used. These are not for accessing the target's memory space; see the QEMU_XX helpers below for that. </P>
<TABLE border=1>
<TBODY>
<TR>
<TD>LD8S </TD>
<TD>Load an 8bit quantity from host memory and sign extend </TD></TR>
<TR>
<TD>LD8U </TD>
<TD>Load an 8bit quantity from host memory and zero extend </TD></TR>
<TR>
<TD>LD16S </TD>
<TD>Load a 16bit quantity from host memory and sign extend </TD></TR>
<TR>
<TD>LD16U </TD>
<TD>Load a 16bit quantity from host memory and zero extend </TD></TR>
<TR>
<TD>LD32S </TD>
<TD>Load a 32bit quantity from host memory and sign extend </TD></TR>
<TR>
<TD>LD32U </TD>
<TD>Load a 32bit quantity from host memory and zero extend </TD></TR>
<TR>
<TD>LD64 </TD>
<TD>Load a 64bit quantity from host memory </TD></TR>
<TR>
<TD>LD </TD>
<TD>Alias to target native sized load </TD></TR>
<TR>
<TD>ST8 </TD>
<TD>Store a 8bit quantity to host memory </TD></TR>
<TR>
<TD>ST16 </TD>
<TD>Store a 16bit quantity to host memory </TD></TR>
<TR>
<TD>ST32 </TD>
<TD>Store a 32bit quantity to host memory </TD></TR>
<TR>
<TD>ST </TD>
<TD>Alias to target native sized store </TD></TR></TBODY></TABLE>
<P>These are for moving data between registers and arbitrary target memory. The address to load/store via is always the second argument while the first argument is always the value to be loaded/stored. The third argument (memory index) only makes sense for system targets; user targets will simply specify 0 all the time. </P>
<TABLE border=1>
<TBODY>
<TR>
<TD>QEMU_LD8S </TD>
<TD>Load an 8bit quantity from target memory and sign extend </TD>
<TD>ret = *(int8_t *)arg1 </TD></TR>
<TR>
<TD>QEMU_LD8U </TD>
<TD>Load an 8bit quantity from target memory and zero extend </TD>
<TD>ret = *(uint8_t *)arg1 </TD></TR>
<TR>
<TD>QEMU_LD16S </TD>
<TD>Load a 16bit quantity from target memory and sign extend </TD>
<TD>ret = *(int8_t *)arg1 </TD></TR>
<TR>
<TD>QEMU_LD16U </TD>
<TD>Load a 16bit quantity from target memory and zero extend </TD>
<TD>ret = *(uint8_t *)arg1 </TD></TR>
<TR>
<TD>QEMU_LD32S </TD>
<TD>Load a 32bit quantity from target memory and sign extend </TD>
<TD>ret = *(int8_t *)arg1 </TD></TR>
<TR>
<TD>QEMU_LD32U </TD>
<TD>Load a 32bit quantity from target memory and zero extend </TD>
<TD>ret = *(uint8_t *)arg1 </TD></TR>
<TR>
<TD>QEMU_LD64 </TD>
<TD>Load a 64bit quantity from target memory </TD>
<TD>ret = *(uint64_t *)arg1 </TD></TR>
<TR>
<TD>QEMU_ST8 </TD>
<TD>Store an 8bit quantity to target memory </TD>
<TD>*(uint8_t *)addr = arg </TD></TR>
<TR>
<TD>QEMU_ST16 </TD>
<TD>Store a 16bit quantity to target memory </TD>
<TD>*(uint16_t *)addr = arg </TD></TR>
<TR>
<TD>QEMU_ST32 </TD>
<TD>Store a 32bit quantity to target memory </TD>
<TD>*(uint32_t *)addr = arg </TD></TR>
<TR>
<TD>QEMU_ST64 </TD>
<TD>Store a 64bit quantity to target memory </TD>
<TD>*(uint64_t *)addr = arg </TD></TR></TBODY></TABLE><A id=Code_Flow name=Code_Flow></A>
<H3><SPAN class=mw-headline>Code Flow </SPAN></H3>
<TABLE border=1>
<TBODY>
<TR>
<TD>BR </TD>
<TD>Branch somewhere? </TD>
<TD></TD></TR>
<TR>
<TD>BRCOND </TD>
<TD>Test two operands and conditionally branch to a label </TD>
<TD>if (arg1 &lt;condition&gt; arg2) goto label </TD></TR>
<TR>
<TD>CALL </TD>
<TD>Call a helper function </TD>
<TD></TD></TR>
<TR>
<TD>GOTO_TB </TD>
<TD>Goto translation block </TD>
<TD></TD></TR>
<TR>
<TD>EXIT_TB </TD>
<TD>Exit translation block </TD>
<TD></TD></TR>
<TR>
<TD>SETCOND </TD>
<TD>Compare two operands </TD>
<TD>ret = arg1 &lt;condition&gt; arg2 </TD></TR>
<TR>
<TD>SET_LABEL </TD>
<TD>Mark the current location with a label </TD>
<TD>label: </TD></TR></TBODY></TABLE><A id=Misc name=Misc></A>
<H3><SPAN class=mw-headline>Misc </SPAN></H3>
<TABLE border=1>
<TBODY>
<TR>
<TD>DISCARD </TD>
<TD>Discard a register </TD></TR>
<TR>
<TD>NOP </TD>
<TD>Generate a No Operation insn </TD></TR></TBODY></TABLE>