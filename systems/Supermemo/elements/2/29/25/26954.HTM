/**<BR>&nbsp;* tlb_vaddr_to_host:<BR>&nbsp;* @env: CPUArchState<BR>&nbsp;* @addr: guest virtual address to look up<BR>&nbsp;* @access_type: 0 for read, 1 for write, 2 for execute<BR>&nbsp;* @mmu_idx: MMU index to use for lookup<BR>&nbsp;*<BR>&nbsp;* Look up the specified guest virtual index in the TCG softmmu TLB.<BR>&nbsp;* If the TLB contains a host virtual address suitable for direct RAM<BR>&nbsp;* access, then return it. Otherwise (TLB miss, TLB entry is for an<BR>&nbsp;* I/O access, etc) return NULL.<BR>&nbsp;*<BR>&nbsp;* This is the equivalent of the initial fast-path code used by<BR>&nbsp;* TCG backends for guest load and store accesses.<BR>&nbsp;*/<BR>static inline void *tlb_vaddr_to_host(CPUArchState *env, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access_type, int mmu_idx)<BR>{<BR>#if defined(CONFIG_USER_ONLY)<BR>&nbsp;&nbsp;&nbsp; return g2h(vaddr);<BR>#else<BR>&nbsp;&nbsp;&nbsp; int index = (addr &gt;&gt; TARGET_PAGE_BITS) &amp; (CPU_TLB_SIZE - 1);<BR>&nbsp;&nbsp;&nbsp; CPUTLBEntry *tlbentry = &amp;env-&gt;tlb_table[mmu_idx][index];<BR>&nbsp;&nbsp;&nbsp; target_ulong tlb_addr;<BR>&nbsp;&nbsp;&nbsp; uintptr_t haddr;</P>
<P>&nbsp;&nbsp;&nbsp; switch (access_type) {<BR>&nbsp;&nbsp;&nbsp; case 0:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_addr = tlbentry-&gt;addr_read;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 1:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_addr = tlbentry-&gt;addr_write;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; case 2:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tlb_addr = tlbentry-&gt;addr_code;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if ((addr &amp; TARGET_PAGE_MASK)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; != (tlb_addr &amp; (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* TLB entry is for a different page */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (tlb_addr &amp; ~TARGET_PAGE_MASK) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* IO access */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; haddr = addr + env-&gt;tlb_table[mmu_idx][index].addend;<BR>&nbsp;&nbsp;&nbsp; return (void *)haddr;<BR>#endif /* defined(CONFIG_USER_ONLY) */<BR>}