# qemu:include/qemu/bswap.h
<P></P>
<P>#ifndef BSWAP_H<BR>#define BSWAP_H</P>
<P>#include "config-host.h"<BR>#include &lt;inttypes.h&gt;<BR>#include &lt;limits.h&gt;<BR>#include &lt;string.h&gt;<BR>#include "fpu/softfloat.h"</P>
<P>#ifdef CONFIG_MACHINE_BSWAP_H<BR># include &lt;sys/endian.h&gt;<BR># include &lt;sys/types.h&gt;<BR># include &lt;machine/bswap.h&gt;<BR>#elif defined(__FreeBSD__)<BR># include &lt;sys/endian.h&gt;<BR>#elif defined(CONFIG_BYTESWAP_H)<BR># include &lt;byteswap.h&gt;</P>
<P>static inline uint16_t bswap16(uint16_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; return bswap_16(x);<BR>}</P>
<P>static inline uint32_t bswap32(uint32_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; return bswap_32(x);<BR>}</P>
<P>static inline uint64_t bswap64(uint64_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; return bswap_64(x);<BR>}<BR># else<BR>static inline uint16_t bswap16(uint16_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (((x &amp; 0x00ff) &lt;&lt; 8) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x &amp; 0xff00) &gt;&gt; 8));<BR>}</P>
<P>static inline uint32_t bswap32(uint32_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (((x &amp; 0x000000ffU) &lt;&lt; 24) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x &amp; 0x0000ff00U) &lt;&lt;&nbsp; 8) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x &amp; 0x00ff0000U) &gt;&gt;&nbsp; 8) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x &amp; 0xff000000U) &gt;&gt; 24));<BR>}</P>
<P>static inline uint64_t bswap64(uint64_t x)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (((x &amp; 0x00000000000000ffULL) &lt;&lt; 56) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x &amp; 0x000000000000ff00ULL) &lt;&lt; 40) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x &amp; 0x0000000000ff0000ULL) &lt;&lt; 24) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x &amp; 0x00000000ff000000ULL) &lt;&lt;&nbsp; 8) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x &amp; 0x000000ff00000000ULL) &gt;&gt;&nbsp; 8) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x &amp; 0x0000ff0000000000ULL) &gt;&gt; 24) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x &amp; 0x00ff000000000000ULL) &gt;&gt; 40) |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((x &amp; 0xff00000000000000ULL) &gt;&gt; 56));<BR>}<BR>#endif /* ! CONFIG_MACHINE_BSWAP_H */</P>
<P>static inline void bswap16s(uint16_t *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; *s = bswap16(*s);<BR>}</P>
<P>static inline void bswap32s(uint32_t *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; *s = bswap32(*s);<BR>}</P>
<P>static inline void bswap64s(uint64_t *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; *s = bswap64(*s);<BR>}</P>
<P>#if defined(HOST_WORDS_BIGENDIAN)<BR>#define be_bswap(v, size) (v)<BR>#define le_bswap(v, size) glue(bswap, size)(v)<BR>#define be_bswaps(v, size)<BR>#define le_bswaps(p, size) do { *p = glue(bswap, size)(*p); } while(0)<BR>#else<BR>#define le_bswap(v, size) (v)<BR>#define be_bswap(v, size) glue(bswap, size)(v)<BR>#define le_bswaps(v, size)<BR>#define be_bswaps(p, size) do { *p = glue(bswap, size)(*p); } while(0)<BR>#endif</P>
<P>#define CPU_CONVERT(endian, size, type)\<BR>static inline type endian ## size ## _to_cpu(type v)\<BR>{\<BR>&nbsp;&nbsp;&nbsp; return glue(endian, _bswap)(v, size);\<BR>}\<BR>\<BR>static inline type cpu_to_ ## endian ## size(type v)\<BR>{\<BR>&nbsp;&nbsp;&nbsp; return glue(endian, _bswap)(v, size);\<BR>}\<BR>\<BR>static inline void endian ## size ## _to_cpus(type *p)\<BR>{\<BR>&nbsp;&nbsp;&nbsp; glue(endian, _bswaps)(p, size);\<BR>}\<BR>\<BR>static inline void cpu_to_ ## endian ## size ## s(type *p)\<BR>{\<BR>&nbsp;&nbsp;&nbsp; glue(endian, _bswaps)(p, size);\<BR>}\<BR>\<BR>static inline type endian ## size ## _to_cpup(const type *p)\<BR>{\<BR>&nbsp;&nbsp;&nbsp; return glue(glue(endian, size), _to_cpu)(*p);\<BR>}\<BR>\<BR>static inline void cpu_to_ ## endian ## size ## w(type *p, type v)\<BR>{\<BR>&nbsp;&nbsp;&nbsp; *p = glue(glue(cpu_to_, endian), size)(v);\<BR>}</P>
<P>CPU_CONVERT(be, 16, uint16_t)<BR>CPU_CONVERT(be, 32, uint32_t)<BR>CPU_CONVERT(be, 64, uint64_t)</P>
<P>CPU_CONVERT(le, 16, uint16_t)<BR>CPU_CONVERT(le, 32, uint32_t)<BR>CPU_CONVERT(le, 64, uint64_t)</P>
<P>/* len must be one of 1, 2, 4 */<BR>static inline uint32_t qemu_bswap_len(uint32_t value, int len)<BR>{<BR>&nbsp;&nbsp;&nbsp; return bswap32(value) &gt;&gt; (32 - 8 * len);<BR>}</P>
<P>/* Unions for reinterpreting between floats and integers.&nbsp; */</P>
<P>typedef union {<BR>&nbsp;&nbsp;&nbsp; float32 f;<BR>&nbsp;&nbsp;&nbsp; uint32_t l;<BR>} CPU_FloatU;</P>
<P>typedef union {<BR>&nbsp;&nbsp;&nbsp; float64 d;<BR>#if defined(HOST_WORDS_BIGENDIAN)<BR>&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t upper;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t lower;<BR>&nbsp;&nbsp;&nbsp; } l;<BR>#else<BR>&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t lower;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t upper;<BR>&nbsp;&nbsp;&nbsp; } l;<BR>#endif<BR>&nbsp;&nbsp;&nbsp; uint64_t ll;<BR>} CPU_DoubleU;</P>
<P>typedef union {<BR>&nbsp;&nbsp;&nbsp;&nbsp; floatx80 d;<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t lower;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint16_t upper;<BR>&nbsp;&nbsp;&nbsp;&nbsp; } l;<BR>} CPU_LDoubleU;</P>
<P>typedef union {<BR>&nbsp;&nbsp;&nbsp; float128 q;<BR>#if defined(HOST_WORDS_BIGENDIAN)<BR>&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t upmost;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t upper;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t lower;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t lowest;<BR>&nbsp;&nbsp;&nbsp; } l;<BR>&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t upper;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t lower;<BR>&nbsp;&nbsp;&nbsp; } ll;<BR>#else<BR>&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t lowest;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t lower;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t upper;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t upmost;<BR>&nbsp;&nbsp;&nbsp; } l;<BR>&nbsp;&nbsp;&nbsp; struct {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t lower;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t upper;<BR>&nbsp;&nbsp;&nbsp; } ll;<BR>#endif<BR>} CPU_QuadU;</P>
<P>/* unaligned/endian-independent pointer access */</P>
<P>/*<BR>&nbsp;* the generic syntax is:<BR>&nbsp;*<BR>&nbsp;* load: ld{type}{sign}{size}{endian}_p(ptr)<BR>&nbsp;*<BR>&nbsp;* store: st{type}{size}{endian}_p(ptr, val)<BR>&nbsp;*<BR>&nbsp;* Note there are small differences with the softmmu access API!<BR>&nbsp;*<BR>&nbsp;* type is:<BR>&nbsp;* (empty): integer access<BR>&nbsp;*&nbsp;&nbsp; f&nbsp;&nbsp;&nbsp; : float access<BR>&nbsp;*<BR>&nbsp;* sign is:<BR>&nbsp;* (empty): for 32 or 64 bit sizes (including floats and doubles)<BR>&nbsp;*&nbsp;&nbsp; u&nbsp;&nbsp;&nbsp; : unsigned<BR>&nbsp;*&nbsp;&nbsp; s&nbsp;&nbsp;&nbsp; : signed<BR>&nbsp;*<BR>&nbsp;* size is:<BR>&nbsp;*&nbsp;&nbsp; b: 8 bits<BR>&nbsp;*&nbsp;&nbsp; w: 16 bits<BR>&nbsp;*&nbsp;&nbsp; l: 32 bits<BR>&nbsp;*&nbsp;&nbsp; q: 64 bits<BR>&nbsp;*<BR>&nbsp;* endian is:<BR>&nbsp;*&nbsp;&nbsp; he&nbsp;&nbsp; : host endian<BR>&nbsp;*&nbsp;&nbsp; be&nbsp;&nbsp; : big endian<BR>&nbsp;*&nbsp;&nbsp; le&nbsp;&nbsp; : little endian<BR>&nbsp;*&nbsp;&nbsp; te&nbsp;&nbsp; : target endian<BR>&nbsp;* (except for byte accesses, which have no endian infix).<BR>&nbsp;*<BR>&nbsp;* The target endian accessors are obviously only available to source<BR>&nbsp;* files which are built per-target; they are defined in cpu-all.h.<BR>&nbsp;*<BR>&nbsp;* In all cases these functions take a host pointer.<BR>&nbsp;* For accessors that take a guest address rather than a<BR>&nbsp;* host address, see the cpu_{ld,st}_* accessors defined in<BR>&nbsp;* cpu_ldst.h.<BR>&nbsp;*/</P>
<P>static inline int ldub_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return *(uint8_t *)ptr;<BR>}</P>
<P>static inline int ldsb_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return *(int8_t *)ptr;<BR>}</P>
<P>static inline void stb_p(void *ptr, uint8_t v)<BR>{<BR>&nbsp;&nbsp;&nbsp; *(uint8_t *)ptr = v;<BR>}</P>
<P>/* Any compiler worth its salt will turn these memcpy into native unaligned<BR>&nbsp;&nbsp; operations.&nbsp; Thus we don't need to play games with packed attributes, or<BR>&nbsp;&nbsp; inline byte-by-byte stores.&nbsp; */</P>
<P>static inline int lduw_he_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint16_t r;<BR>&nbsp;&nbsp;&nbsp; memcpy(&amp;r, ptr, sizeof(r));<BR>&nbsp;&nbsp;&nbsp; return r;<BR>}</P>
<P>static inline int ldsw_he_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; int16_t r;<BR>&nbsp;&nbsp;&nbsp; memcpy(&amp;r, ptr, sizeof(r));<BR>&nbsp;&nbsp;&nbsp; return r;<BR>}</P>
<P>static inline void stw_he_p(void *ptr, uint16_t v)<BR>{<BR>&nbsp;&nbsp;&nbsp; memcpy(ptr, &amp;v, sizeof(v));<BR>}</P>
<P>static inline int ldl_he_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; int32_t r;<BR>&nbsp;&nbsp;&nbsp; memcpy(&amp;r, ptr, sizeof(r));<BR>&nbsp;&nbsp;&nbsp; return r;<BR>}</P>
<P>static inline void stl_he_p(void *ptr, uint32_t v)<BR>{<BR>&nbsp;&nbsp;&nbsp; memcpy(ptr, &amp;v, sizeof(v));<BR>}</P>
<P>static inline uint64_t ldq_he_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; uint64_t r;<BR>&nbsp;&nbsp;&nbsp; memcpy(&amp;r, ptr, sizeof(r));<BR>&nbsp;&nbsp;&nbsp; return r;<BR>}</P>
<P>static inline void stq_he_p(void *ptr, uint64_t v)<BR>{<BR>&nbsp;&nbsp;&nbsp; memcpy(ptr, &amp;v, sizeof(v));<BR>}</P>
<P>static inline int lduw_le_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (uint16_t)le_bswap(lduw_he_p(ptr), 16);<BR>}</P>
<P>static inline int ldsw_le_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (int16_t)le_bswap(lduw_he_p(ptr), 16);<BR>}</P>
<P>static inline int ldl_le_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return le_bswap(ldl_he_p(ptr), 32);<BR>}</P>
<P>static inline uint64_t ldq_le_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return le_bswap(ldq_he_p(ptr), 64);<BR>}</P>
<P>static inline void stw_le_p(void *ptr, uint16_t v)<BR>{<BR>&nbsp;&nbsp;&nbsp; stw_he_p(ptr, le_bswap(v, 16));<BR>}</P>
<P>static inline void stl_le_p(void *ptr, uint32_t v)<BR>{<BR>&nbsp;&nbsp;&nbsp; stl_he_p(ptr, le_bswap(v, 32));<BR>}</P>
<P>static inline void stq_le_p(void *ptr, uint64_t v)<BR>{<BR>&nbsp;&nbsp;&nbsp; stq_he_p(ptr, le_bswap(v, 64));<BR>}</P>
<P>/* float access */</P>
<P>static inline float32 ldfl_le_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPU_FloatU u;<BR>&nbsp;&nbsp;&nbsp; u.l = ldl_le_p(ptr);<BR>&nbsp;&nbsp;&nbsp; return u.f;<BR>}</P>
<P>static inline void stfl_le_p(void *ptr, float32 v)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPU_FloatU u;<BR>&nbsp;&nbsp;&nbsp; u.f = v;<BR>&nbsp;&nbsp;&nbsp; stl_le_p(ptr, u.l);<BR>}</P>
<P>static inline float64 ldfq_le_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPU_DoubleU u;<BR>&nbsp;&nbsp;&nbsp; u.ll = ldq_le_p(ptr);<BR>&nbsp;&nbsp;&nbsp; return u.d;<BR>}</P>
<P>static inline void stfq_le_p(void *ptr, float64 v)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPU_DoubleU u;<BR>&nbsp;&nbsp;&nbsp; u.d = v;<BR>&nbsp;&nbsp;&nbsp; stq_le_p(ptr, u.ll);<BR>}</P>
<P>static inline int lduw_be_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (uint16_t)be_bswap(lduw_he_p(ptr), 16);<BR>}</P>
<P>static inline int ldsw_be_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return (int16_t)be_bswap(lduw_he_p(ptr), 16);<BR>}</P>
<P>static inline int ldl_be_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return be_bswap(ldl_he_p(ptr), 32);<BR>}</P>
<P>static inline uint64_t ldq_be_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; return be_bswap(ldq_he_p(ptr), 64);<BR>}</P>
<P>static inline void stw_be_p(void *ptr, uint16_t v)<BR>{<BR>&nbsp;&nbsp;&nbsp; stw_he_p(ptr, be_bswap(v, 16));<BR>}</P>
<P>static inline void stl_be_p(void *ptr, uint32_t v)<BR>{<BR>&nbsp;&nbsp;&nbsp; stl_he_p(ptr, be_bswap(v, 32));<BR>}</P>
<P>static inline void stq_be_p(void *ptr, uint64_t v)<BR>{<BR>&nbsp;&nbsp;&nbsp; stq_he_p(ptr, be_bswap(v, 64));<BR>}</P>
<P>/* float access */</P>
<P>static inline float32 ldfl_be_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPU_FloatU u;<BR>&nbsp;&nbsp;&nbsp; u.l = ldl_be_p(ptr);<BR>&nbsp;&nbsp;&nbsp; return u.f;<BR>}</P>
<P>static inline void stfl_be_p(void *ptr, float32 v)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPU_FloatU u;<BR>&nbsp;&nbsp;&nbsp; u.f = v;<BR>&nbsp;&nbsp;&nbsp; stl_be_p(ptr, u.l);<BR>}</P>
<P>static inline float64 ldfq_be_p(const void *ptr)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPU_DoubleU u;<BR>&nbsp;&nbsp;&nbsp; u.ll = ldq_be_p(ptr);<BR>&nbsp;&nbsp;&nbsp; return u.d;<BR>}</P>
<P>static inline void stfq_be_p(void *ptr, float64 v)<BR>{<BR>&nbsp;&nbsp;&nbsp; CPU_DoubleU u;<BR>&nbsp;&nbsp;&nbsp; u.d = v;<BR>&nbsp;&nbsp;&nbsp; stq_be_p(ptr, u.ll);<BR>}</P>
<P>static inline unsigned long leul_to_cpu(unsigned long v)<BR>{<BR>&nbsp;&nbsp;&nbsp; /* In order to break an include loop between here and<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu-common.h, don't rely on HOST_LONG_BITS.&nbsp; */<BR>#if ULONG_MAX == UINT32_MAX<BR>&nbsp;&nbsp;&nbsp; return le_bswap(v, 32);<BR>#elif ULONG_MAX == UINT64_MAX<BR>&nbsp;&nbsp;&nbsp; return le_bswap(v, 64);<BR>#else<BR># error Unknown sizeof long<BR>#endif<BR>}</P>
<P>#undef le_bswap<BR>#undef be_bswap<BR>#undef le_bswaps<BR>#undef be_bswaps</P>
<P>#endif /* BSWAP_H */