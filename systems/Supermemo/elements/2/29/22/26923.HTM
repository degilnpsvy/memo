# qemu:include/exec/cpu-all.h 
<P></P>
<P>/*<BR>&nbsp;* defines common to all virtual CPUs<BR>&nbsp;*<BR>&nbsp;*&nbsp; Copyright (c) 2003 Fabrice Bellard<BR>&nbsp;*<BR>&nbsp;* This library is free software; you can redistribute it and/or<BR>&nbsp;* modify it under the terms of the GNU Lesser General Public<BR>&nbsp;* License as published by the Free Software Foundation; either<BR>&nbsp;* version 2 of the License, or (at your option) any later version.<BR>&nbsp;*<BR>&nbsp;* This library is distributed in the hope that it will be useful,<BR>&nbsp;* but WITHOUT ANY WARRANTY; without even the implied warranty of<BR>&nbsp;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp; See the GNU<BR>&nbsp;* Lesser General Public License for more details.<BR>&nbsp;*<BR>&nbsp;* You should have received a copy of the GNU Lesser General Public<BR>&nbsp;* License along with this library; if not, see &lt;<A href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.<BR>&nbsp;*/<BR>#ifndef CPU_ALL_H<BR>#define CPU_ALL_H</P>
<P>#include "qemu-common.h"<BR>#include "exec/cpu-common.h"<BR>#include "exec/memory.h"<BR>#include "qemu/thread.h"<BR>#include "qom/cpu.h"<BR>#include "qemu/rcu.h"</P>
<P><FONT class=extract>#define EXCP_INTERRUPT &nbsp;0x10000 /* async interruption */<BR>#define EXCP_HLT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10001 /* hlt instruction reached */<BR>#define EXCP_DEBUG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10002 /* cpu stopped after a breakpoint or singlestep */<BR>#define EXCP_HALTED&nbsp;&nbsp;&nbsp;&nbsp; 0x10003 /* cpu is halted (waiting for external event) */<BR>#define EXCP_YIELD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10004 /* cpu wants to yield timeslice to another */</FONT></P>
<P><FONT class=extract>/* some important defines:<BR>&nbsp;*<BR>&nbsp;* WORDS_ALIGNED : if defined, the host cpu can only make word aligned<BR>&nbsp;* memory accesses.<BR>&nbsp;*<BR>&nbsp;* HOST_WORDS_BIGENDIAN : if defined, the host cpu is big endian and<BR>&nbsp;* otherwise little endian.<BR>&nbsp;*<BR>&nbsp;* (TARGET_WORDS_ALIGNED : same for target cpu (not supported yet))<BR>&nbsp;*<BR>&nbsp;* TARGET_WORDS_BIGENDIAN : same for target cpu<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>#if defined(HOST_WORDS_BIGENDIAN) != defined(TARGET_WORDS_BIGENDIAN)<BR>#define BSWAP_NEEDED<BR>#endif</FONT></P>
<P><FONT class=extract>#ifdef BSWAP_NEEDED</FONT></P>
<P><FONT class=extract>static inline uint16_t tswap16(uint16_t s)<BR>{<BR>&nbsp;&nbsp;&nbsp; return bswap16(s);<BR>}</FONT></P>
<P><FONT class=extract>static inline uint32_t tswap32(uint32_t s)<BR>{<BR>&nbsp;&nbsp;&nbsp; return bswap32(s);<BR>}</FONT></P>
<P><FONT class=extract>static inline uint64_t tswap64(uint64_t s)<BR>{<BR>&nbsp;&nbsp;&nbsp; return bswap64(s);<BR>}</FONT></P>
<P><FONT class=extract>static inline void tswap16s(uint16_t *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; *s = bswap16(*s);<BR>}</FONT></P>
<P><FONT class=extract>static inline void tswap32s(uint32_t *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; *s = bswap32(*s);<BR>}</FONT></P>
<P><FONT class=extract>static inline void tswap64s(uint64_t *s)<BR>{<BR>&nbsp;&nbsp;&nbsp; *s = bswap64(*s);<BR>}</FONT></P>
<P><FONT class=extract>#else</FONT></P>
<P><FONT class=extract>static inline uint16_t tswap16(uint16_t s)<BR>{<BR>&nbsp;&nbsp;&nbsp; return s;<BR>}</FONT></P>
<P><FONT class=extract>static inline uint32_t tswap32(uint32_t s)<BR>{<BR>&nbsp;&nbsp;&nbsp; return s;<BR>}</FONT></P>
<P><FONT class=extract>static inline uint64_t tswap64(uint64_t s)<BR>{<BR>&nbsp;&nbsp;&nbsp; return s;<BR>}</FONT></P>
<P><FONT class=extract>static inline void tswap16s(uint16_t *s)<BR>{<BR>}</FONT></P>
<P><FONT class=extract>static inline void tswap32s(uint32_t *s)<BR>{<BR>}</FONT></P>
<P><FONT class=extract>static inline void tswap64s(uint64_t *s)<BR>{<BR>}</FONT></P>
<P><FONT class=extract>#endif</FONT></P>
<P><FONT class=extract>#if TARGET_LONG_SIZE == 4<BR>#define tswapl(s) tswap32(s)<BR>#define tswapls(s) tswap32s((uint32_t *)(s))<BR>#define bswaptls(s) bswap32s(s)<BR>#else<BR>#define tswapl(s) tswap64(s)<BR>#define tswapls(s) tswap64s((uint64_t *)(s))<BR>#define bswaptls(s) bswap64s(s)<BR>#endif</FONT></P>
<P><FONT class=extract>/* Target-endianness CPU memory access functions. These fit into the<BR>&nbsp;* {ld,st}{type}{sign}{size}{endian}_p naming scheme described in bswap.h.<BR>&nbsp;*/<BR>#if defined(TARGET_WORDS_BIGENDIAN)<BR>#define lduw_p(p) lduw_be_p(p)<BR>#define ldsw_p(p) ldsw_be_p(p)<BR>#define ldl_p(p) ldl_be_p(p)<BR>#define ldq_p(p) ldq_be_p(p)<BR>#define ldfl_p(p) ldfl_be_p(p)<BR>#define ldfq_p(p) ldfq_be_p(p)<BR>#define stw_p(p, v) stw_be_p(p, v)<BR>#define stl_p(p, v) stl_be_p(p, v)<BR>#define stq_p(p, v) stq_be_p(p, v)<BR>#define stfl_p(p, v) stfl_be_p(p, v)<BR>#define stfq_p(p, v) stfq_be_p(p, v)<BR>#else<BR>#define lduw_p(p) lduw_le_p(p)<BR>#define ldsw_p(p) ldsw_le_p(p)<BR>#define ldl_p(p) ldl_le_p(p)<BR>#define ldq_p(p) ldq_le_p(p)<BR>#define ldfl_p(p) ldfl_le_p(p)<BR>#define ldfq_p(p) ldfq_le_p(p)<BR>#define stw_p(p, v) stw_le_p(p, v)<BR>#define stl_p(p, v) stl_le_p(p, v)<BR>#define stq_p(p, v) stq_le_p(p, v)<BR>#define stfl_p(p, v) stfl_le_p(p, v)<BR>#define stfq_p(p, v) stfq_le_p(p, v)<BR>#endif</FONT></P>
<P><FONT class=extract>/* MMU memory access macros */</FONT></P>
<P><FONT class=extract>#if defined(CONFIG_USER_ONLY)<BR>#include &lt;assert.h&gt;<BR>#include "exec/user/abitypes.h"</FONT></P>
<P><FONT class=extract>/* On some host systems the guest address space is reserved on the host.<BR>&nbsp;* This allows the guest address space to be offset to a convenient location.<BR>&nbsp;*/<BR>extern unsigned long guest_base;<BR>extern int have_guest_base;<BR>extern unsigned long reserved_va;</FONT></P>
<P><FONT class=extract>#define GUEST_ADDR_MAX (reserved_va ? reserved_va : \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1ul &lt;&lt; TARGET_VIRT_ADDR_SPACE_BITS) - 1)<BR>#endif</FONT></P>
<P><FONT class=extract>/* page related stuff */</FONT></P>
<P><FONT class=extract>#define TARGET_PAGE_SIZE (1 &lt;&lt; TARGET_PAGE_BITS)<BR>#define TARGET_PAGE_MASK ~(TARGET_PAGE_SIZE - 1)<BR>#define TARGET_PAGE_ALIGN(addr) (((addr) + TARGET_PAGE_SIZE - 1) &amp; TARGET_PAGE_MASK)</FONT></P>
<P><FONT class=extract>/* Using intptr_t ensures that qemu_*_page_mask is sign-extended even<BR>&nbsp;* when intptr_t is 32-bit and we are aligning a long long.<BR>&nbsp;*/<BR>extern uintptr_t qemu_real_host_page_size;<BR>extern intptr_t qemu_real_host_page_mask;<BR>extern uintptr_t qemu_host_page_size;<BR>extern intptr_t qemu_host_page_mask;</FONT></P>
<P><FONT class=extract>#define HOST_PAGE_ALIGN(addr) (((addr) + qemu_host_page_size - 1) &amp; qemu_host_page_mask)<BR>#define REAL_HOST_PAGE_ALIGN(addr) (((addr) + qemu_real_host_page_size - 1) &amp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qemu_real_host_page_mask)</FONT></P>
<P><FONT class=extract>/* same as PROT_xxx */<BR>#define PAGE_READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0001<BR>#define PAGE_WRITE&nbsp;&nbsp;&nbsp;&nbsp; 0x0002<BR>#define PAGE_EXEC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0004<BR>#define PAGE_BITS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PAGE_READ | PAGE_WRITE | PAGE_EXEC)<BR>#define PAGE_VALID&nbsp;&nbsp;&nbsp;&nbsp; 0x0008<BR>/* original state of the write flag (used when tracking self-modifying<BR>&nbsp;&nbsp; code */<BR>#define PAGE_WRITE_ORG 0x0010<BR>#if defined(CONFIG_BSD) &amp;&amp; defined(CONFIG_USER_ONLY)<BR>/* FIXME: Code that sets/uses this is broken and needs to go away.&nbsp; */<BR>#define PAGE_RESERVED&nbsp; 0x0020<BR>#endif</FONT></P>
<P><FONT class=extract>#if defined(CONFIG_USER_ONLY)<BR>void page_dump(FILE *f);</FONT></P>
<P><FONT class=extract>typedef int (*walk_memory_regions_fn)(void *, target_ulong,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target_ulong, unsigned long);<BR>int walk_memory_regions(void *, walk_memory_regions_fn);</FONT></P>
<P><FONT class=extract>int page_get_flags(target_ulong address);<BR>void page_set_flags(target_ulong start, target_ulong end, int flags);<BR>int page_check_range(target_ulong start, target_ulong len, int flags);<BR>#endif</FONT></P>
<P><FONT class=extract>CPUArchState *cpu_copy(CPUArchState *env);</FONT></P>
<P><FONT class=extract>/* Flags for use in ENV-&gt;INTERRUPT_PENDING.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp; The numbers assigned here are non-sequential in order to preserve<BR>&nbsp;&nbsp; binary compatibility with the vmstate dump.&nbsp; Bit 0 (0x0001) was<BR>&nbsp;&nbsp; previously used for CPU_INTERRUPT_EXIT, and is cleared when loading<BR>&nbsp;&nbsp; the vmstate dump.&nbsp; */</FONT></P>
<P><FONT class=extract>/* External hardware interrupt pending.&nbsp; This is typically used for<BR>&nbsp;&nbsp; interrupts from devices.&nbsp; */<BR>#define CPU_INTERRUPT_HARD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0002</FONT></P>
<P><FONT class=extract>/* Exit the current TB.&nbsp; This is typically used when some system-level device<BR>&nbsp;&nbsp; makes some change to the memory mapping.&nbsp; E.g. the a20 line change.&nbsp; */<BR>#define CPU_INTERRUPT_EXITTB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0004</FONT></P>
<P><FONT class=extract>/* Halt the CPU.&nbsp; */<BR>#define CPU_INTERRUPT_HALT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0020</FONT></P>
<P><FONT class=extract>/* Debug event pending.&nbsp; */<BR>#define CPU_INTERRUPT_DEBUG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0080</FONT></P>
<P><FONT class=extract>/* Reset signal.&nbsp; */<BR>#define CPU_INTERRUPT_RESET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0400</FONT></P>
<P><FONT class=extract>/* Several target-specific external hardware interrupts.&nbsp; Each target/cpu.h<BR>&nbsp;&nbsp; should define proper names based on these defines.&nbsp; */<BR>#define CPU_INTERRUPT_TGT_EXT_0&nbsp;&nbsp; 0x0008<BR>#define CPU_INTERRUPT_TGT_EXT_1&nbsp;&nbsp; 0x0010<BR>#define CPU_INTERRUPT_TGT_EXT_2&nbsp;&nbsp; 0x0040<BR>#define CPU_INTERRUPT_TGT_EXT_3&nbsp;&nbsp; 0x0200<BR>#define CPU_INTERRUPT_TGT_EXT_4&nbsp;&nbsp; 0x1000</FONT></P>
<P><FONT class=extract>/* Several target-specific internal interrupts.&nbsp; These differ from the<BR>&nbsp;&nbsp; preceding target-specific interrupts in that they are intended to<BR>&nbsp;&nbsp; originate from within the cpu itself, typically in response to some<BR>&nbsp;&nbsp; instruction being executed.&nbsp; These, therefore, are not masked while<BR>&nbsp;&nbsp; single-stepping within the debugger.&nbsp; */<BR>#define CPU_INTERRUPT_TGT_INT_0&nbsp;&nbsp; 0x0100<BR>#define CPU_INTERRUPT_TGT_INT_1&nbsp;&nbsp; 0x0800<BR>#define CPU_INTERRUPT_TGT_INT_2&nbsp;&nbsp; 0x2000</FONT></P>
<P><FONT class=extract>/* First unused bit: 0x4000.&nbsp; */</FONT></P>
<P><FONT class=extract>/* The set of all bits that should be masked when single-stepping.&nbsp; */<BR>#define CPU_INTERRUPT_SSTEP_MASK \<BR>&nbsp;&nbsp;&nbsp; (CPU_INTERRUPT_HARD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; | CPU_INTERRUPT_TGT_EXT_0&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; | CPU_INTERRUPT_TGT_EXT_1&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; | CPU_INTERRUPT_TGT_EXT_2&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; | CPU_INTERRUPT_TGT_EXT_3&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp; | CPU_INTERRUPT_TGT_EXT_4)</FONT></P>
<P><FONT class=extract>#if !defined(CONFIG_USER_ONLY)</FONT></P>
<P><FONT class=extract>/* Flags stored in the low bits of the TLB virtual address.&nbsp; These are<BR>&nbsp;&nbsp; defined so that fast path ram access is all zeros.&nbsp; */<BR>/* Zero if TLB entry is valid.&nbsp; */<BR>#define TLB_INVALID_MASK&nbsp;&nbsp; (1 &lt;&lt; 3)<BR>/* Set if TLB entry references a clean RAM page.&nbsp; The iotlb entry will<BR>&nbsp;&nbsp; contain the page physical address.&nbsp; */<BR>#define TLB_NOTDIRTY&nbsp;&nbsp;&nbsp; (1 &lt;&lt; 4)<BR>/* Set if TLB entry is an IO callback.&nbsp; */<BR>#define TLB_MMIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1 &lt;&lt; 5)</FONT></P>
<P><FONT class=extract>void dump_exec_info(FILE *f, fprintf_function cpu_fprintf);<BR>void dump_opcount_info(FILE *f, fprintf_function cpu_fprintf);<BR>#endif /* !CONFIG_USER_ONLY */</FONT></P>
<P><FONT class=extract>int cpu_memory_rw_debug(CPUState *cpu, target_ulong addr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint8_t *buf, int len, int is_write);</FONT></P>
<P>#endif /* CPU_ALL_H */