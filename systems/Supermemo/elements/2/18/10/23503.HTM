# Documentation/IRQ-domain.txt
<P></P>
<P>irq_domain interrupt number mapping library</P>
<P></P>
<P>The current design of the Linux kernel uses a single large number<BR>space where each separate IRQ source is assigned a different number.<BR>This is simple when there is only one interrupt controller, but in<BR>systems with multiple interrupt controllers the kernel must ensure<BR>that each one gets assigned non-overlapping allocations of Linux<BR>IRQ numbers.</P>
<P>The number of interrupt controllers registered as unique irqchips<BR>show a rising tendency: for example subdrivers of different kinds<BR>such as GPIO controllers avoid reimplementing identical callback<BR>mechanisms as the IRQ core system by modelling their interrupt<BR>handlers as irqchips, i.e. in effect cascading interrupt controllers.</P>
<P>Here the interrupt number loose all kind of correspondence to<BR>hardware interrupt numbers: whereas in the past, IRQ numbers could<BR>be chosen so they matched the hardware IRQ line into the root<BR>interrupt controller (i.e. the component actually fireing the<BR>interrupt line to the CPU) nowadays this number is just a number.</P>
<P>For this reason we need a mechanism to separate controller-local<BR>interrupt numbers, called hardware irq's, from Linux IRQ numbers.</P>
<P>The irq_alloc_desc*() and irq_free_desc*() APIs provide allocation of<BR>irq numbers, but they don't provide any support for reverse mapping of<BR>the controller-local IRQ (hwirq) number into the Linux IRQ number<BR>space.</P>
<P>The irq_domain library adds mapping between hwirq and IRQ numbers on<BR>top of the irq_alloc_desc*() API.&nbsp; An irq_domain to manage mapping is<BR>preferred over interrupt controller drivers open coding their own<BR>reverse mapping scheme.</P>
<P>irq_domain also implements translation from Device Tree interrupt<BR>specifiers to hwirq numbers, and can be easily extended to support<BR>other IRQ topology data sources.</P>
<P>=== irq_domain usage ===<BR>An interrupt controller driver creates and registers an irq_domain by<BR>calling one of the irq_domain_add_*() functions (each mapping method<BR>has a different allocator function, more on that later).&nbsp; The function<BR>will return a pointer to the irq_domain on success.&nbsp; The caller must<BR>provide the allocator function with an irq_domain_ops structure with<BR>the .map callback populated as a minimum.</P>
<P>In most cases, the irq_domain will begin empty without any mappings<BR>between hwirq and IRQ numbers.&nbsp; Mappings are added to the irq_domain<BR>by calling irq_create_mapping() which accepts the irq_domain and a<BR>hwirq number as arguments.&nbsp; If a mapping for the hwirq doesn't already<BR>exist then it will allocate a new Linux irq_desc, associate it with<BR>the hwirq, and call the .map() callback so the driver can perform any<BR>required hardware setup.</P>
<P>When an interrupt is received, irq_find_mapping() function should<BR>be used to find the Linux IRQ number from the hwirq number.</P>
<P>The irq_create_mapping() function must be called *atleast once*<BR>before any call to irq_find_mapping(), lest the descriptor will not<BR>be allocated.</P>
<P>If the driver has the Linux IRQ number or the irq_data pointer, and<BR>needs to know the associated hwirq number (such as in the irq_chip<BR>callbacks) then it can be directly obtained from irq_data-&gt;hwirq.</P>
<P>=== Types of irq_domain mappings ===<BR>There are several mechanisms available for reverse mapping from hwirq<BR>to Linux irq, and each mechanism uses a different allocation function.<BR>Which reverse map type should be used depends on the use case.&nbsp; Each<BR>of the reverse map types are described below:</P>
<P>==== Linear ====<BR>irq_domain_add_linear()</P>
<P>The linear reverse map maintains a fixed size table indexed by the<BR>hwirq number.&nbsp; When a hwirq is mapped, an irq_desc is allocated for<BR>the hwirq, and the IRQ number is stored in the table.</P>
<P>The Linear map is a good choice when the maximum number of hwirqs is<BR>fixed and a relatively small number (~ &lt; 256).&nbsp; The advantages of this<BR>map are fixed time lookup for IRQ numbers, and irq_descs are only<BR>allocated for in-use IRQs.&nbsp; The disadvantage is that the table must be<BR>as large as the largest possible hwirq number.</P>
<P>The majority of drivers should use the linear map.</P>
<P>==== Tree ====<BR>irq_domain_add_tree()</P>
<P>The irq_domain maintains a radix tree map from hwirq numbers to Linux<BR>IRQs.&nbsp; When an hwirq is mapped, an irq_desc is allocated and the<BR>hwirq is used as the lookup key for the radix tree.</P>
<P>The tree map is a good choice if the hwirq number can be very large<BR>since it doesn't need to allocate a table as large as the largest<BR>hwirq number.&nbsp; The disadvantage is that hwirq to IRQ number lookup is<BR>dependent on how many entries are in the table.</P>
<P>Very few drivers should need this mapping.&nbsp; At the moment, powerpc<BR>iseries is the only user.</P>
<P>==== No Map ===-<BR>irq_domain_add_nomap()</P>
<P>The No Map mapping is to be used when the hwirq number is<BR>programmable in the hardware.&nbsp; In this case it is best to program the<BR>Linux IRQ number into the hardware itself so that no mapping is<BR>required.&nbsp; Calling irq_create_direct_mapping() will allocate a Linux<BR>IRQ number and call the .map() callback so that driver can program the<BR>Linux IRQ number into the hardware.</P>
<P>Most drivers cannot use this mapping.</P>
<P>==== Legacy ====<BR>irq_domain_add_simple()<BR>irq_domain_add_legacy()<BR>irq_domain_add_legacy_isa()</P>
<P>The Legacy mapping is a special case for drivers that already have a<BR>range of irq_descs allocated for the hwirqs.&nbsp; It is used when the<BR>driver cannot be immediately converted to use the linear mapping.&nbsp; For<BR>example, many embedded system board support files use a set of #defines<BR>for IRQ numbers that are passed to struct device registrations.&nbsp; In that<BR>case the Linux IRQ numbers cannot be dynamically assigned and the legacy<BR>mapping should be used.</P>
<P>The legacy map assumes a contiguous range of IRQ numbers has already<BR>been allocated for the controller and that the IRQ number can be<BR>calculated by adding a fixed offset to the hwirq number, and<BR>visa-versa.&nbsp; The disadvantage is that it requires the interrupt<BR>controller to manage IRQ allocations and it requires an irq_desc to be<BR>allocated for every hwirq, even if it is unused.</P>
<P>The legacy map should only be used if fixed IRQ mappings must be<BR>supported.&nbsp; For example, ISA controllers would use the legacy map for<BR>mapping Linux IRQs 0-15 so that existing ISA drivers get the correct IRQ<BR>numbers.</P>
<P>Most users of legacy mappings should use irq_domain_add_simple() which<BR>will use a legacy domain only if an IRQ range is supplied by the<BR>system and will otherwise use a linear domain mapping. The semantics<BR>of this call are such that if an IRQ range is specified then<BR>descriptors will be allocated on-the-fly for it, and if no range is<BR>specified it will fall through to irq_domain_add_linear() which meand<BR>*no* irq descriptors will be allocated.</P>
<P>A typical use case for simple domains is where an irqchip provider<BR>is supporting both dynamic and static IRQ assignments.</P>
<P>In order to avoid ending up in a situation where a linear domain is<BR>used and no descriptor gets allocated it is very important to make sure<BR>that the driver using the simple domain call irq_create_mapping()<BR>before any irq_find_mapping() since the latter will actually work<BR>for the static IRQ assignment case.