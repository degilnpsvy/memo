# Documentation/BUG-HUNTING</P>
<P>Table of contents<BR>=================</P>
<P></P>
<P>Last updated: 20 December 2005</P>
<P>Contents<BR>========</P>
<P>- Introduction<BR>- Devices not appearing<BR>- Finding patch that caused a bug<BR>-- Finding using git-bisect<BR>-- Finding it the old way<BR>- Fixing the bug</P>
<P>Introduction<BR>============</P>
<P>Always try the latest kernel from kernel.org and build from source. If you are<BR>not confident in doing that please report the bug to your distribution vendor<BR>instead of to a kernel developer.</P>
<P>Finding bugs is not always easy. Have a go though. If you can't find it don't<BR>give up. Report as much as you have found to the relevant maintainer. See<BR>MAINTAINERS for who that is for the subsystem you have worked on.</P>
<P>Before you submit a bug report read REPORTING-BUGS.</P>
<P>Devices not appearing<BR>=====================</P>
<P>Often this is caused by udev. Check that first before blaming it on the<BR>kernel.</P>
<P>Finding patch that caused a bug<BR>===============================</P>
<P>&nbsp;</P>
<P>Finding using git-bisect<BR>------------------------</P>
<P>Using the provided tools with git makes finding bugs easy provided the bug is<BR>reproducible.</P>
<P>Steps to do it:<BR>- start using git for the kernel source<BR>- read the man page for git-bisect<BR>- have fun</P>
<P>Finding it the old way<BR>----------------------</P>
<P>[Sat Mar&nbsp; 2 10:32:33 PST 1996 KERNEL_BUG-HOWTO <A href="mailto:lm@sgi.com">lm@sgi.com</A> (Larry McVoy)]</P>
<P>This is how to track down a bug if you know nothing about kernel hacking.<BR>It's a brute force approach but it works pretty well.</P>
<P>You need:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . A reproducible bug - it has to happen predictably (sorry)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . All the kernel tar files from a revision that worked to the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; revision that doesn't</P>
<P>You will then do:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . Rebuild a revision that you believe works, install, and verify that.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . Do a binary search over the kernels to figure out which one<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; introduced the bug.&nbsp; I.e., suppose 1.3.28 didn't have the bug, but<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; you know that 1.3.69 does.&nbsp; Pick a kernel in the middle and build<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; that, like 1.3.50.&nbsp; Build &amp; test; if it works, pick the mid point<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; between .50 and .69, else the mid point between .28 and .50.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . You'll narrow it down to the kernel that introduced the bug.&nbsp; You<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; can probably do better than this but it gets tricky.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . Narrow it down to a subdirectory</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Copy kernel that works into "test".&nbsp; Let's say that 3.62 works,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; but 3.63 doesn't.&nbsp; So you diff -r those two kernels and come<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up with a list of directories that changed.&nbsp; For each of those<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; directories:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Copy the non-working directory next to the working directory<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as "dir.63".<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; One directory at time, try moving the working directory to<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "dir.62" and mv dir.63 dir"time, try</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mv dir dir.62<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mv dir.63 dir<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; find dir -name '*.[oa]' -print | xargs rm -f</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; And then rebuild and retest.&nbsp; Assuming that all related<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; changes were contained in the sub directory, this should<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isolate the change to a directory.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Problems: changes in header files may have occurred; I've<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found in my case that they were self explanatory - you may<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or may not want to give up when that happens.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . Narrow it down to a file</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - You can apply the same technique to each file in the directory,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hoping that the changes in that file are self contained.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . Narrow it down to a routine</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - You can take the old file and the new file and manually create<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a merged file that has</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #ifdef VER62<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; routine()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; routine()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; And then walk through that file, one routine at a time and<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prefix it with</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define VER62<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* both routines here */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #undef VER62</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Then recompile, retest, move the ifdefs until you find the one<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; that makes the difference.</P>
<P>Finally, you take all the info that you have, kernel revisions, bug<BR>description, the extent to which you have narrowed it down, and pass<BR>that off to whomever you believe is the maintainer of that section.<BR>A post to linux.dev.kernel isn't such a bad idea if you've done some<BR>work to narrow it down.</P>
<P>If you get it down to a routine, you'll probably get a fix in 24 hours.</P>
<P>My apologies to Linus and the other kernel hackers for describing this<BR>brute force approach, it's hardly what a kernel hacker would do.&nbsp; However,<BR>it does work and it lets non-hackers help fix bugs.&nbsp; And it is cool<BR>because Linux snapshots will let you do this - something that you can't<BR>do with vendor supplied releases.</P>
<P>Fixing the bug<BR>==============</P>
<P>Nobody is going to tell you how to fix bugs. Seriously. You need to work it<BR>out. But below are some hints on how to use the tools.</P>
<P>To debug a kernel, use objdump and look for the hex offset from the crash<BR>output to find the valid line of code/assembler. Without debug symbols, you<BR>will see the assembler code for the routine shown, but if your kernel has<BR>debug symbols the C code will also be available. (Debug symbols can be enabled<BR>in the kernel hacking menu of the menu configuration.) For example:</P>
<P>&nbsp;&nbsp;&nbsp; objdump -r -S -l --disassemble net/dccp/ipv4.o</P>
<P>NB.: you need to be at the top level of the kernel tree for this to pick up<BR>your C files.</P>
<P>If you don't have access to the code you can also debug on some crash dumps<BR>e.g. crash dump output as shown by Dave Miller.</P>
<P>&gt;&nbsp;&nbsp;&nbsp; EIP is at ip_queue_xmit+0x14/0x4c0<BR>&gt;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>&gt;&nbsp;&nbsp;&nbsp; Code: 44 24 04 e8 6f 05 00 00 e9 e8 fe ff ff 8d 76 00 8d bc 27 00 00<BR>&gt;&nbsp;&nbsp;&nbsp; 00 00 55 57&nbsp; 56 53 81 ec bc 00 00 00 8b ac 24 d0 00 00 00 8b 5d 08<BR>&gt;&nbsp;&nbsp;&nbsp; &lt;8b&gt; 83 3c 01 00 00 89 44&nbsp; 24 14 8b 45 28 85 c0 89 44 24 18 0f 85<BR>&gt;<BR>&gt;&nbsp;&nbsp;&nbsp; Put the bytes into a "foo.s" file like this:<BR>&gt;<BR>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .text<BR>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .globl foo<BR>&gt;&nbsp;&nbsp;&nbsp; foo:<BR>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .byte&nbsp; .... /* bytes from Code: part of OOPS dump */<BR>&gt;<BR>&gt;&nbsp;&nbsp;&nbsp; Compile it with "gcc -c -o foo.o foo.s" then look at the output of<BR>&gt;&nbsp;&nbsp;&nbsp; "objdump --disassemble foo.o".<BR>&gt;<BR>&gt;&nbsp;&nbsp;&nbsp; Output:<BR>&gt;<BR>&gt;&nbsp;&nbsp;&nbsp; ip_queue_xmit:<BR>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %ebp<BR>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %edi<BR>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %esi<BR>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %ebx<BR>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $0xbc, %esp<BR>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xd0(%esp), %ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! %ebp = arg0 (skb)<BR>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x8(%ebp), %ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! %ebx = skb-&gt;sk<BR>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x13c(%ebx), %eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! %eax = inet_sk(sk)-&gt;opt</P>
<P>In addition, you can use GDB to figure out the exact file and line<BR>number of the OOPS from the vmlinux file. If you have<BR>CONFIG_DEBUG_INFO enabled, you can simply copy the EIP value from the<BR>OOPS:</P>
<P>&nbsp;EIP:&nbsp;&nbsp;&nbsp; 0060:[&lt;c021e50e&gt;]&nbsp;&nbsp;&nbsp; Not tainted VLI</P>
<P>And use GDB to translate that to human-readable form:</P>
<P>&nbsp; gdb vmlinux<BR>&nbsp; (gdb) l *0xc021e50e</P>
<P>If you don't have CONFIG_DEBUG_INFO enabled, you use the function<BR>offset from the OOPS:</P>
<P>&nbsp;EIP is at vt_ioctl+0xda8/0x1482</P>
<P>And recompile the kernel with CONFIG_DEBUG_INFO enabled:</P>
<P>&nbsp; make vmlinux<BR>&nbsp; gdb vmlinux<BR>&nbsp; (gdb) p vt_ioctl<BR>&nbsp; (gdb) l *(0x&lt;address of vt_ioctl&gt; + 0xda8)<BR>or, as one command<BR>&nbsp; (gdb) l *(vt_ioctl + 0xda8)</P>
<P>If you have a call trace, such as :-<BR>&gt;Call Trace:<BR>&gt; [&lt;ffffffff8802c8e9&gt;] :jbd:log_wait_commit+0xa3/0xf5<BR>&gt; [&lt;ffffffff810482d9&gt;] autoremove_wake_function+0x0/0x2e<BR>&gt; [&lt;ffffffff8802770b&gt;] :jbd:journal_stop+0x1be/0x1ee<BR>&gt; ...<BR>this shows the problem in the :jbd: module. You can load that module in gdb<BR>and list the relevant code.<BR>&nbsp; gdb fs/jbd/jbd.ko<BR>&nbsp; (gdb) p log_wait_commit<BR>&nbsp; (gdb) l *(0x&lt;address&gt; + 0xa3)<BR>or<BR>&nbsp; (gdb) l *(log_wait_commit + 0xa3)</P>
<P><BR>Another very useful option of the Kernel Hacking section in menuconfig is<BR>Debug memory allocations. This will help you see whether data has been<BR>initialised and not set before use etc. To see the values that get assigned<BR>with this look at mm/slab.c and search for POISON_INUSE. When using this an<BR>Oops will often show the poisoned data instead of zero which is the default.</P>
<P>Once you have worked out a fix please submit it upstream. After all open<BR>source is about sharing what you do and don't you want to be recognised for<BR>your genius?</P>
<P>Please do read Documentation/SubmittingPatches though to help your code get<BR>accepted.