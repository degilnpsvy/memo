Platform drivers<BR>~~~~~~~~~~~~~~~~<BR><FONT class=extract>Platform drivers follow the standard driver model convention, where<BR>discovery/enumeration is handled outside the drivers, and drivers<BR>provide probe() and remove() methods.</FONT>&nbsp; They support power management<BR>and shutdown notifications using the standard conventions. 
<P></P>
<P>struct platform_driver {<BR><FONT class=clozed>&nbsp;int (*probe)(struct platform_device *);<BR>&nbsp;int (*remove)(struct platform_device *);<BR>&nbsp;void (*shutdown)(struct platform_device *);<BR>&nbsp;int (*suspend)(struct platform_device *, pm_message_t state);<BR>&nbsp;int (*suspend_late)(struct platform_device *, pm_message_t state);<BR>&nbsp;int (*resume_early)(struct platform_device *);<BR>&nbsp;int (*resume)(struct platform_device *);<BR>&nbsp;struct device_driver driver</FONT>;<BR>};</P>
<P><FONT class=extract>Note that probe() should in general verify that the specified device hardware<BR>actually exists; sometimes platform setup code can't be sure.</FONT>&nbsp; The probing<BR>can use device resources, including clocks, and device platform_data.</P>
<P><FONT class=extract>Platform drivers register themselves the normal way:</FONT></P>
<P><FONT class=extract>&nbsp;int platform_driver_register(struct platform_driver *drv);</FONT></P>
<P><FONT class=extract>Or, in common situations where the device is known not to be hot-pluggable,<BR>the probe() routine can live in an init section to reduce the driver's<BR>runtime memory footprint:</FONT></P>
<P><FONT class=extract>&nbsp;int platform_driver_probe(struct platform_driver *drv,<BR>&nbsp;&nbsp;&nbsp;&nbsp; int (*probe)(struct platform_device *))</FONT>