# Documentation/development-process/2.Process
<P></P>
<P>2: HOW THE DEVELOPMENT PROCESS WORKS</P>
<P></P>
<P>Linux kernel development in the early 1990's was a pretty loose affair,<BR>with relatively small numbers of users and developers involved.&nbsp; With a<BR>user base in the millions and with some 2,000 developers involved over the<BR>course of one year, the kernel has since had to evolve a number of<BR>processes to keep development happening smoothly.&nbsp; A solid understanding of<BR>how the process works is required in order to be an effective part of it.</P>
<P><BR>2.1: THE BIG PICTURE</P>
<P>The kernel developers use a loosely time-based release process, with a new<BR>major kernel release happening every two or three months.&nbsp; The recent<BR>release history looks like this:</P>
<P>&nbsp;2.6.38&nbsp;March 14, 2011<BR>&nbsp;2.6.37&nbsp;January 4, 2011<BR>&nbsp;2.6.36&nbsp;October 20, 2010<BR>&nbsp;2.6.35&nbsp;August 1, 2010<BR>&nbsp;2.6.34&nbsp;May 15, 2010<BR>&nbsp;2.6.33&nbsp;February 24, 2010</P>
<P>Every 2.6.x release is a major kernel release with new features, internal<BR>API changes, and more.&nbsp; A typical 2.6 release can contain nearly 10,000<BR>changesets with changes to several hundred thousand lines of code.&nbsp; 2.6 is<BR>thus the leading edge of Linux kernel development; the kernel uses a<BR>rolling development model which is continually integrating major changes.</P>
<P>A relatively straightforward discipline is followed with regard to the<BR>merging of patches for each release.&nbsp; At the beginning of each development<BR>cycle, the "merge window" is said to be open.&nbsp; At that time, code which is<BR>deemed to be sufficiently stable (and which is accepted by the development<BR>community) is merged into the mainline kernel.&nbsp; The bulk of changes for a<BR>new development cycle (and all of the major changes) will be merged during<BR>this time, at a rate approaching 1,000 changes ("patches," or "changesets")<BR>per day.</P>
<P>(As an aside, it is worth noting that the changes integrated during the<BR>merge window do not come out of thin air; they have been collected, tested,<BR>and staged ahead of time.&nbsp; How that process works will be described in<BR>detail later on).</P>
<P>The merge window lasts for approximately two weeks.&nbsp; At the end of this<BR>time, Linus Torvalds will declare that the window is closed and release the<BR>first of the "rc" kernels.&nbsp; For the kernel which is destined to be 2.6.40,<BR>for example, the release which happens at the end of the merge window will<BR>be called 2.6.40-rc1.&nbsp; The -rc1 release is the signal that the time to<BR>merge new features has passed, and that the time to stabilize the next<BR>kernel has begun.</P>
<P>Over the next six to ten weeks, only patches which fix problems should be<BR>submitted to the mainline.&nbsp; On occasion a more significant change will be<BR>allowed, but such occasions are rare; developers who try to merge new<BR>features outside of the merge window tend to get an unfriendly reception.<BR>As a general rule, if you miss the merge window for a given feature, the<BR>best thing to do is to wait for the next development cycle.&nbsp; (An occasional<BR>exception is made for drivers for previously-unsupported hardware; if they<BR>touch no in-tree code, they cannot cause regressions and should be safe to<BR>add at any time).</P>
<P>As fixes make their way into the mainline, the patch rate will slow over<BR>time.&nbsp; Linus releases new -rc kernels about once a week; a normal series<BR>will get up to somewhere between -rc6 and -rc9 before the kernel is<BR>considered to be sufficiently stable and the final 2.6.x release is made.<BR>At that point the whole process starts over again.</P>
<P>As an example, here is how the 2.6.38 development cycle went (all dates in<BR>2011):</P>
<P>&nbsp;January 4&nbsp;2.6.37 stable release<BR>&nbsp;January 18&nbsp;2.6.38-rc1, merge window closes<BR>&nbsp;January 21&nbsp;2.6.38-rc2<BR>&nbsp;February 1&nbsp;2.6.38-rc3<BR>&nbsp;February 7&nbsp;2.6.38-rc4<BR>&nbsp;February 15&nbsp;2.6.38-rc5<BR>&nbsp;February 21&nbsp;2.6.38-rc6<BR>&nbsp;March 1&nbsp;&nbsp;2.6.38-rc7<BR>&nbsp;March 7&nbsp;&nbsp;2.6.38-rc8<BR>&nbsp;March 14&nbsp;2.6.38 stable release</P>
<P>How do the developers decide when to close the development cycle and create<BR>the stable release?&nbsp; The most significant metric used is the list of<BR>regressions from previous releases.&nbsp; No bugs are welcome, but those which<BR>break systems which worked in the past are considered to be especially<BR>serious.&nbsp; For this reason, patches which cause regressions are looked upon<BR>unfavorably and are quite likely to be reverted during the stabilization<BR>period.</P>
<P>The developers' goal is to fix all known regressions before the stable<BR>release is made.&nbsp; In the real world, this kind of perfection is hard to<BR>achieve; there are just too many variables in a project of this size.<BR>There comes a point where delaying the final release just makes the problem<BR>worse; the pile of changes waiting for the next merge window will grow<BR>larger, creating even more regressions the next time around.&nbsp; So most 2.6.x<BR>kernels go out with a handful of known regressions though, hopefully, none<BR>of them are serious.</P>
<P>Once a stable release is made, its ongoing maintenance is passed off to the<BR>"stable team," currently consisting of Greg Kroah-Hartman.&nbsp; The stable team<BR>will release occasional updates to the stable release using the 2.6.x.y<BR>numbering scheme.&nbsp; To be considered for an update release, a patch must (1)<BR>fix a significant bug, and (2) already be merged into the mainline for the<BR>next development kernel.&nbsp; Kernels will typically receive stable updates for<BR>a little more than one development cycle past their initial release.&nbsp; So,<BR>for example, the 2.6.36 kernel's history looked like:</P>
<P>&nbsp;October 10&nbsp;2.6.36 stable release<BR>&nbsp;November 22&nbsp;2.6.36.1<BR>&nbsp;December 9&nbsp;2.6.36.2<BR>&nbsp;January 7&nbsp;2.6.36.3<BR>&nbsp;February 17&nbsp;2.6.36.4</P>
<P>2.6.36.4 was the final stable update for the 2.6.36 release.</P>
<P>Some kernels are designated "long term" kernels; they will receive support<BR>for a longer period.&nbsp; As of this writing, the current long term kernels<BR>and their maintainers are:</P>
<P>&nbsp;2.6.27&nbsp;Willy Tarreau&nbsp;&nbsp;(Deep-frozen stable kernel)<BR>&nbsp;2.6.32&nbsp;Greg Kroah-Hartman<BR>&nbsp;2.6.35&nbsp;Andi Kleen&nbsp;&nbsp;(Embedded flag kernel)</P>
<P>The selection of a kernel for long-term support is purely a matter of a<BR>maintainer having the need and the time to maintain that release.&nbsp; There<BR>are no known plans for long-term support for any specific upcoming<BR>release.</P>
<P><BR>2.2: THE LIFECYCLE OF A PATCH</P>
<P>Patches do not go directly from the developer's keyboard into the mainline<BR>kernel.&nbsp; There is, instead, a somewhat involved (if somewhat informal)<BR>process designed to ensure that each patch is reviewed for quality and that<BR>each patch implements a change which is desirable to have in the mainline.<BR>This process can happen quickly for minor fixes, or, in the case of large<BR>and controversial changes, go on for years.&nbsp; Much developer frustration<BR>comes from a lack of understanding of this process or from attempts to<BR>circumvent it.</P>
<P>In the hopes of reducing that frustration, this document will describe how<BR>a patch gets into the kernel.&nbsp; What follows below is an introduction which<BR>describes the process in a somewhat idealized way.&nbsp; A much more detailed<BR>treatment will come in later sections.</P>
<P>The stages that a patch goes through are, generally:</P>
<P>&nbsp;- Design.&nbsp; This is where the real requirements for the patch - and the way<BR>&nbsp;&nbsp; those requirements will be met - are laid out.&nbsp; Design work is often<BR>&nbsp;&nbsp; done without involving the community, but it is better to do this work<BR>&nbsp;&nbsp; in the open if at all possible; it can save a lot of time redesigning<BR>&nbsp;&nbsp; things later.</P>
<P>&nbsp;- Early review.&nbsp; Patches are posted to the relevant mailing list, and<BR>&nbsp;&nbsp; developers on that list reply with any comments they may have.&nbsp; This<BR>&nbsp;&nbsp; process should turn up any major problems with a patch if all goes<BR>&nbsp;&nbsp; well.</P>
<P>&nbsp;- Wider review.&nbsp; When the patch is getting close to ready for mainline<BR>&nbsp;&nbsp; inclusion, it should be accepted by a relevant subsystem maintainer -<BR>&nbsp;&nbsp; though this acceptance is not a guarantee that the patch will make it<BR>&nbsp;&nbsp; all the way to the mainline.&nbsp; The patch will show up in the maintainer's<BR>&nbsp;&nbsp; subsystem tree and into the -next trees (described below).&nbsp; When the<BR>&nbsp;&nbsp; process works, this step leads to more extensive review of the patch and<BR>&nbsp;&nbsp; the discovery of any problems resulting from the integration of this<BR>&nbsp;&nbsp; patch with work being done by others.</P>
<P>-&nbsp; Please note that most maintainers also have day jobs, so merging<BR>&nbsp;&nbsp; your patch may not be their highest priority.&nbsp; If your patch is<BR>&nbsp;&nbsp; getting feedback about changes that are needed, you should either<BR>&nbsp;&nbsp; make those changes or justify why they should not be made.&nbsp; If your<BR>&nbsp;&nbsp; patch has no review complaints but is not being merged by its<BR>&nbsp;&nbsp; appropriate subsystem or driver maintainer, you should be persistent<BR>&nbsp;&nbsp; in updating the patch to the current kernel so that it applies cleanly<BR>&nbsp;&nbsp; and keep sending it for review and merging.</P>
<P>&nbsp;- Merging into the mainline.&nbsp; Eventually, a successful patch will be<BR>&nbsp;&nbsp; merged into the mainline repository managed by Linus Torvalds.&nbsp; More<BR>&nbsp;&nbsp; comments and/or problems may surface at this time; it is important that<BR>&nbsp;&nbsp; the developer be responsive to these and fix any issues which arise.</P>
<P>&nbsp;- Stable release.&nbsp; The number of users potentially affected by the patch<BR>&nbsp;&nbsp; is now large, so, once again, new problems may arise.</P>
<P>&nbsp;- Long-term maintenance.&nbsp; While it is certainly possible for a developer<BR>&nbsp;&nbsp; to forget about code after merging it, that sort of behavior tends to<BR>&nbsp;&nbsp; leave a poor impression in the development community.&nbsp; Merging code<BR>&nbsp;&nbsp; eliminates some of the maintenance burden, in that others will fix<BR>&nbsp;&nbsp; problems caused by API changes.&nbsp; But the original developer should<BR>&nbsp;&nbsp; continue to take responsibility for the code if it is to remain useful<BR>&nbsp;&nbsp; in the longer term.</P>
<P>One of the largest mistakes made by kernel developers (or their employers)<BR>is to try to cut the process down to a single "merging into the mainline"<BR>step.&nbsp; This approach invariably leads to frustration for everybody<BR>involved.</P>
<P><BR>2.3: HOW PATCHES GET INTO THE KERNEL</P>
<P>There is exactly one person who can merge patches into the mainline kernel<BR>repository: Linus Torvalds.&nbsp; But, of the over 9,500 patches which went<BR>into the 2.6.38 kernel, only 112 (around 1.3%) were directly chosen by Linus<BR>himself.&nbsp; The kernel project has long since grown to a size where no single<BR>developer could possibly inspect and select every patch unassisted.&nbsp; The<BR>way the kernel developers have addressed this growth is through the use of<BR>a lieutenant system built around a chain of trust.</P>
<P>The kernel code base is logically broken down into a set of subsystems:<BR>networking, specific architecture support, memory management, video<BR>devices, etc.&nbsp; Most subsystems have a designated maintainer, a developer<BR>who has overall responsibility for the code within that subsystem.&nbsp; These<BR>subsystem maintainers are the gatekeepers (in a loose way) for the portion<BR>of the kernel they manage; they are the ones who will (usually) accept a<BR>patch for inclusion into the mainline kernel.</P>
<P>Subsystem maintainers each manage their own version of the kernel source<BR>tree, usually (but certainly not always) using the git source management<BR>tool.&nbsp; Tools like git (and related tools like quilt or mercurial) allow<BR>maintainers to track a list of patches, including authorship information<BR>and other metadata.&nbsp; At any given time, the maintainer can identify which<BR>patches in his or her repository are not found in the mainline.</P>
<P>When the merge window opens, top-level maintainers will ask Linus to "pull"<BR>the patches they have selected for merging from their repositories.&nbsp; If<BR>Linus agrees, the stream of patches will flow up into his repository,<BR>becoming part of the mainline kernel.&nbsp; The amount of attention that Linus<BR>pays to specific patches received in a pull operation varies.&nbsp; It is clear<BR>that, sometimes, he looks quite closely.&nbsp; But, as a general rule, Linus<BR>trusts the subsystem maintainers to not send bad patches upstream.</P>
<P>Subsystem maintainers, in turn, can pull patches from other maintainers.<BR>For example, the networking tree is built from patches which accumulated<BR>first in trees dedicated to network device drivers, wireless networking,<BR>etc.&nbsp; This chain of repositories can be arbitrarily long, though it rarely<BR>exceeds two or three links.&nbsp; Since each maintainer in the chain trusts<BR>those managing lower-level trees, this process is known as the "chain of<BR>trust."</P>
<P>Clearly, in a system like this, getting patches into the kernel depends on<BR>finding the right maintainer.&nbsp; Sending patches directly to Linus is not<BR>normally the right way to go.</P>
<P><BR>2.4: NEXT TREES</P>
<P>The chain of subsystem trees guides the flow of patches into the kernel,<BR>but it also raises an interesting question: what if somebody wants to look<BR>at all of the patches which are being prepared for the next merge window?<BR>Developers will be interested in what other changes are pending to see<BR>whether there are any conflicts to worry about; a patch which changes a<BR>core kernel function prototype, for example, will conflict with any other<BR>patches which use the older form of that function.&nbsp; Reviewers and testers<BR>want access to the changes in their integrated form before all of those<BR>changes land in the mainline kernel.&nbsp; One could pull changes from all of<BR>the interesting subsystem trees, but that would be a big and error-prone<BR>job.</P>
<P>The answer comes in the form of -next trees, where subsystem trees are<BR>collected for testing and review.&nbsp; The older of these trees, maintained by<BR>Andrew Morton, is called "-mm" (for memory management, which is how it got<BR>started).&nbsp; The -mm tree integrates patches from a long list of subsystem<BR>trees; it also has some patches aimed at helping with debugging.</P>
<P>Beyond that, -mm contains a significant collection of patches which have<BR>been selected by Andrew directly.&nbsp; These patches may have been posted on a<BR>mailing list, or they may apply to a part of the kernel for which there is<BR>no designated subsystem tree.&nbsp; As a result, -mm operates as a sort of<BR>subsystem tree of last resort; if there is no other obvious path for a<BR>patch into the mainline, it is likely to end up in -mm.&nbsp; Miscellaneous<BR>patches which accumulate in -mm will eventually either be forwarded on to<BR>an appropriate subsystem tree or be sent directly to Linus.&nbsp; In a typical<BR>development cycle, approximately 5-10% of the patches going into the<BR>mainline get there via -mm.</P>
<P>The current -mm patch is available in the "mmotm" (-mm of the moment)<BR>directory at:</P>
<P>&nbsp;<A href="http://userweb.kernel.org/~akpm/mmotm/">http://userweb.kernel.org/~akpm/mmotm/</A></P>
<P>Use of the MMOTM tree is likely to be a frustrating experience, though;<BR>there is a definite chance that it will not even compile.</P>
<P>The primary tree for next-cycle patch merging is linux-next, maintained by<BR>Stephen Rothwell.&nbsp; The linux-next tree is, by design, a snapshot of what<BR>the mainline is expected to look like after the next merge window closes.<BR>Linux-next trees are announced on the linux-kernel and linux-next mailing<BR>lists when they are assembled; they can be downloaded from:</P>
<P>&nbsp;<A href="http://www.kernel.org/pub/linux/kernel/people/sfr/linux-next/">http://www.kernel.org/pub/linux/kernel/people/sfr/linux-next/</A></P>
<P>Some information about linux-next has been gathered at:</P>
<P>&nbsp;<A href="http://linux.f-seidel.de/linux-next/pmwiki/">http://linux.f-seidel.de/linux-next/pmwiki/</A></P>
<P>Linux-next has become an integral part of the kernel development process;<BR>all patches merged during a given merge window should really have found<BR>their way into linux-next some time before the merge window opens.</P>
<P><BR>2.4.1: STAGING TREES</P>
<P>The kernel source tree contains the drivers/staging/ directory, where<BR>many sub-directories for drivers or filesystems that are on their way to<BR>being added to the kernel tree live.&nbsp; They remain in drivers/staging while<BR>they still need more work; once complete, they can be moved into the<BR>kernel proper.&nbsp; This is a way to keep track of drivers that aren't<BR>up to Linux kernel coding or quality standards, but people may want to use<BR>them and track development.</P>
<P>Greg Kroah-Hartman currently maintains the staging tree.&nbsp; Drivers that<BR>still need work are sent to him, with each driver having its own<BR>subdirectory in drivers/staging/.&nbsp; Along with the driver source files, a<BR>TODO file should be present in the directory as well.&nbsp; The TODO file lists<BR>the pending work that the driver needs for acceptance into the kernel<BR>proper, as well as a list of people that should be Cc'd for any patches to<BR>the driver.&nbsp; Current rules require that drivers contributed to staging<BR>must, at a minimum, compile properly.</P>
<P>Staging can be a relatively easy way to get new drivers into the mainline<BR>where, with luck, they will come to the attention of other developers and<BR>improve quickly.&nbsp; Entry into staging is not the end of the story, though;<BR>code in staging which is not seeing regular progress will eventually be<BR>removed.&nbsp; Distributors also tend to be relatively reluctant to enable<BR>staging drivers.&nbsp; So staging is, at best, a stop on the way toward becoming<BR>a proper mainline driver.</P>
<P><BR>2.5: TOOLS</P>
<P>As can be seen from the above text, the kernel development process depends<BR>heavily on the ability to herd collections of patches in various<BR>directions.&nbsp; The whole thing would not work anywhere near as well as it<BR>does without suitably powerful tools.&nbsp; Tutorials on how to use these tools<BR>are well beyond the scope of this document, but there is space for a few<BR>pointers.</P>
<P>By far the dominant source code management system used by the kernel<BR>community is git.&nbsp; Git is one of a number of distributed version control<BR>systems being developed in the free software community.&nbsp; It is well tuned<BR>for kernel development, in that it performs quite well when dealing with<BR>large repositories and large numbers of patches.&nbsp; It also has a reputation<BR>for being difficult to learn and use, though it has gotten better over<BR>time.&nbsp; Some sort of familiarity with git is almost a requirement for kernel<BR>developers; even if they do not use it for their own work, they'll need git<BR>to keep up with what other developers (and the mainline) are doing.</P>
<P>Git is now packaged by almost all Linux distributions.&nbsp; There is a home<BR>page at:</P>
<P>&nbsp;<A href="http://git-scm.com/">http://git-scm.com/</A></P>
<P>That page has pointers to documentation and tutorials.</P>
<P>Among the kernel developers who do not use git, the most popular choice is<BR>almost certainly Mercurial:</P>
<P>&nbsp;<A href="http://www.selenic.com/mercurial/">http://www.selenic.com/mercurial/</A></P>
<P>Mercurial shares many features with git, but it provides an interface which<BR>many find easier to use.</P>
<P>The other tool worth knowing about is Quilt:</P>
<P>&nbsp;<A href="http://savannah.nongnu.org/projects/quilt/">http://savannah.nongnu.org/projects/quilt/</A></P>
<P>Quilt is a patch management system, rather than a source code management<BR>system.&nbsp; It does not track history over time; it is, instead, oriented<BR>toward tracking a specific set of changes against an evolving code base.<BR>Some major subsystem maintainers use quilt to manage patches intended to go<BR>upstream.&nbsp; For the management of certain kinds of trees (-mm, for example),<BR>quilt is the best tool for the job.</P>
<P><BR>2.6: MAILING LISTS</P>
<P>A great deal of Linux kernel development work is done by way of mailing<BR>lists.&nbsp; It is hard to be a fully-functioning member of the community<BR>without joining at least one list somewhere.&nbsp; But Linux mailing lists also<BR>represent a potential hazard to developers, who risk getting buried under a<BR>load of electronic mail, running afoul of the conventions used on the Linux<BR>lists, or both.</P>
<P>Most kernel mailing lists are run on vger.kernel.org; the master list can<BR>be found at:</P>
<P>&nbsp;<A href="http://vger.kernel.org/vger-lists.html">http://vger.kernel.org/vger-lists.html</A></P>
<P>There are lists hosted elsewhere, though; a number of them are at<BR>lists.redhat.com.</P>
<P>The core mailing list for kernel development is, of course, linux-kernel.<BR>This list is an intimidating place to be; volume can reach 500 messages per<BR>day, the amount of noise is high, the conversation can be severely<BR>technical, and participants are not always concerned with showing a high<BR>degree of politeness.&nbsp; But there is no other place where the kernel<BR>development community comes together as a whole; developers who avoid this<BR>list will miss important information.</P>
<P>There are a few hints which can help with linux-kernel survival:</P>
<P>- Have the list delivered to a separate folder, rather than your main<BR>&nbsp; mailbox.&nbsp; One must be able to ignore the stream for sustained periods of<BR>&nbsp; time.</P>
<P>- Do not try to follow every conversation - nobody else does.&nbsp; It is<BR>&nbsp; important to filter on both the topic of interest (though note that<BR>&nbsp; long-running conversations can drift away from the original subject<BR>&nbsp; without changing the email subject line) and the people who are<BR>&nbsp; participating.</P>
<P>- Do not feed the trolls.&nbsp; If somebody is trying to stir up an angry<BR>&nbsp; response, ignore them.</P>
<P>- When responding to linux-kernel email (or that on other lists) preserve<BR>&nbsp; the Cc: header for all involved.&nbsp; In the absence of a strong reason (such<BR>&nbsp; as an explicit request), you should never remove recipients.&nbsp; Always make<BR>&nbsp; sure that the person you are responding to is in the Cc: list.&nbsp; This<BR>&nbsp; convention also makes it unnecessary to explicitly ask to be copied on<BR>&nbsp; replies to your postings.</P>
<P>- Search the list archives (and the net as a whole) before asking<BR>&nbsp; questions.&nbsp; Some developers can get impatient with people who clearly<BR>&nbsp; have not done their homework.</P>
<P>- Avoid top-posting (the practice of putting your answer above the quoted<BR>&nbsp; text you are responding to).&nbsp; It makes your response harder to read and<BR>&nbsp; makes a poor impression.</P>
<P>- Ask on the correct mailing list.&nbsp; Linux-kernel may be the general meeting<BR>&nbsp; point, but it is not the best place to find developers from all<BR>&nbsp; subsystems.</P>
<P>The last point - finding the correct mailing list - is a common place for<BR>beginning developers to go wrong.&nbsp; Somebody who asks a networking-related<BR>question on linux-kernel will almost certainly receive a polite suggestion<BR>to ask on the netdev list instead, as that is the list frequented by most<BR>networking developers.&nbsp; Other lists exist for the SCSI, video4linux, IDE,<BR>filesystem, etc. subsystems.&nbsp; The best place to look for mailing lists is<BR>in the MAINTAINERS file packaged with the kernel source.</P>
<P><BR>2.7: GETTING STARTED WITH KERNEL DEVELOPMENT</P>
<P>Questions about how to get started with the kernel development process are<BR>common - from both individuals and companies.&nbsp; Equally common are missteps<BR>which make the beginning of the relationship harder than it has to be.</P>
<P>Companies often look to hire well-known developers to get a development<BR>group started.&nbsp; This can, in fact, be an effective technique.&nbsp; But it also<BR>tends to be expensive and does not do much to grow the pool of experienced<BR>kernel developers.&nbsp; It is possible to bring in-house developers up to speed<BR>on Linux kernel development, given the investment of a bit of time.&nbsp; Taking<BR>this time can endow an employer with a group of developers who understand<BR>the kernel and the company both, and who can help to train others as well.<BR>Over the medium term, this is often the more profitable approach.</P>
<P>Individual developers are often, understandably, at a loss for a place to<BR>start.&nbsp; Beginning with a large project can be intimidating; one often wants<BR>to test the waters with something smaller first.&nbsp; This is the point where<BR>some developers jump into the creation of patches fixing spelling errors or<BR>minor coding style issues.&nbsp; Unfortunately, such patches create a level of<BR>noise which is distracting for the development community as a whole, so,<BR>increasingly, they are looked down upon.&nbsp; New developers wishing to<BR>introduce themselves to the community will not get the sort of reception<BR>they wish for by these means.</P>
<P>Andrew Morton gives this advice for aspiring kernel developers</P>
<P>&nbsp;The #1 project for all kernel beginners should surely be "make sure<BR>&nbsp;that the kernel runs perfectly at all times on all machines which<BR>&nbsp;you can lay your hands on".&nbsp; Usually the way to do this is to work<BR>&nbsp;with others on getting things fixed up (this can require<BR>&nbsp;persistence!) but that's fine - it's a part of kernel development.</P>
<P>(<A href="http://lwn.net/Articles/283982/">http://lwn.net/Articles/283982/</A>).</P>
<P>In the absence of obvious problems to fix, developers are advised to look<BR>at the current lists of regressions and open bugs in general.&nbsp; There is<BR>never any shortage of issues in need of fixing; by addressing these issues,<BR>developers will gain experience with the process while, at the same time,<BR>building respect with the rest of the development community.