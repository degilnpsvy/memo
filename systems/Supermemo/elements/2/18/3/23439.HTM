# Documentation/development-process/3.Early-stage
<P></P>
<P>3: EARLY-STAGE PLANNING</P>
<P></P>
<P>When contemplating a Linux kernel development project, it can be tempting<BR>to jump right in and start coding.&nbsp; As with any significant project,<BR>though, much of the groundwork for success is best laid before the first<BR>line of code is written.&nbsp; Some time spent in early planning and<BR>communication can save far more time later on.</P>
<P><BR>3.1: SPECIFYING THE PROBLEM</P>
<P>Like any engineering project, a successful kernel enhancement starts with a<BR>clear description of the problem to be solved.&nbsp; In some cases, this step is<BR>easy: when a driver is needed for a specific piece of hardware, for<BR>example.&nbsp; In others, though, it is tempting to confuse the real problem<BR>with the proposed solution, and that can lead to difficulties.</P>
<P>Consider an example: some years ago, developers working with Linux audio<BR>sought a way to run applications without dropouts or other artifacts caused<BR>by excessive latency in the system.&nbsp; The solution they arrived at was a<BR>kernel module intended to hook into the Linux Security Module (LSM)<BR>framework; this module could be configured to give specific applications<BR>access to the realtime scheduler.&nbsp; This module was implemented and sent to<BR>the linux-kernel mailing list, where it immediately ran into problems.</P>
<P>To the audio developers, this security module was sufficient to solve their<BR>immediate problem.&nbsp; To the wider kernel community, though, it was seen as a<BR>misuse of the LSM framework (which is not intended to confer privileges<BR>onto processes which they would not otherwise have) and a risk to system<BR>stability.&nbsp; Their preferred solutions involved realtime scheduling access<BR>via the rlimit mechanism for the short term, and ongoing latency reduction<BR>work in the long term.</P>
<P>The audio community, however, could not see past the particular solution<BR>they had implemented; they were unwilling to accept alternatives.&nbsp; The<BR>resulting disagreement left those developers feeling disillusioned with the<BR>entire kernel development process; one of them went back to an audio list<BR>and posted this:</P>
<P>&nbsp;There are a number of very good Linux kernel developers, but they<BR>&nbsp;tend to get outshouted by a large crowd of arrogant fools. Trying<BR>&nbsp;to communicate user requirements to these people is a waste of<BR>&nbsp;time. They are much too "intelligent" to listen to lesser mortals.</P>
<P>(<A href="http://lwn.net/Articles/131776/">http://lwn.net/Articles/131776/</A>).</P>
<P>The reality of the situation was different; the kernel developers were far<BR>more concerned about system stability, long-term maintenance, and finding<BR>the right solution to the problem than they were with a specific module.<BR>The moral of the story is to focus on the problem - not a specific solution<BR>- and to discuss it with the development community before investing in the<BR>creation of a body of code.</P>
<P>So, when contemplating a kernel development project, one should obtain<BR>answers to a short set of questions:</P>
<P>&nbsp;- What, exactly, is the problem which needs to be solved?</P>
<P>&nbsp;- Who are the users affected by this problem?&nbsp; Which use cases should the<BR>&nbsp;&nbsp; solution address?</P>
<P>&nbsp;- How does the kernel fall short in addressing that problem now?</P>
<P>Only then does it make sense to start considering possible solutions.</P>
<P><BR>3.2: EARLY DISCUSSION</P>
<P>When planning a kernel development project, it makes great sense to hold<BR>discussions with the community before launching into implementation.&nbsp; Early<BR>communication can save time and trouble in a number of ways:</P>
<P>&nbsp;- It may well be that the problem is addressed by the kernel in ways which<BR>&nbsp;&nbsp; you have not understood.&nbsp; The Linux kernel is large and has a number of<BR>&nbsp;&nbsp; features and capabilities which are not immediately obvious.&nbsp; Not all<BR>&nbsp;&nbsp; kernel capabilities are documented as well as one might like, and it is<BR>&nbsp;&nbsp; easy to miss things.&nbsp; Your author has seen the posting of a complete<BR>&nbsp;&nbsp; driver which duplicated an existing driver that the new author had been<BR>&nbsp;&nbsp; unaware of.&nbsp; Code which reinvents existing wheels is not only wasteful;<BR>&nbsp;&nbsp; it will also not be accepted into the mainline kernel.</P>
<P>&nbsp;- There may be elements of the proposed solution which will not be<BR>&nbsp;&nbsp; acceptable for mainline merging.&nbsp; It is better to find out about<BR>&nbsp;&nbsp; problems like this before writing the code.</P>
<P>&nbsp;- It's entirely possible that other developers have thought about the<BR>&nbsp;&nbsp; problem; they may have ideas for a better solution, and may be willing<BR>&nbsp;&nbsp; to help in the creation of that solution.</P>
<P>Years of experience with the kernel development community have taught a<BR>clear lesson: kernel code which is designed and developed behind closed<BR>doors invariably has problems which are only revealed when the code is<BR>released into the community.&nbsp; Sometimes these problems are severe,<BR>requiring months or years of effort before the code can be brought up to<BR>the kernel community's standards.&nbsp; Some examples include:</P>
<P>&nbsp;- The Devicescape network stack was designed and implemented for<BR>&nbsp;&nbsp; single-processor systems.&nbsp; It could not be merged into the mainline<BR>&nbsp;&nbsp; until it was made suitable for multiprocessor systems.&nbsp; Retrofitting<BR>&nbsp;&nbsp; locking and such into code is a difficult task; as a result, the merging<BR>&nbsp;&nbsp; of this code (now called mac80211) was delayed for over a year.</P>
<P>&nbsp;- The Reiser4 filesystem included a number of capabilities which, in the<BR>&nbsp;&nbsp; core kernel developers' opinion, should have been implemented in the<BR>&nbsp;&nbsp; virtual filesystem layer instead.&nbsp; It also included features which could<BR>&nbsp;&nbsp; not easily be implemented without exposing the system to user-caused<BR>&nbsp;&nbsp; deadlocks.&nbsp; The late revelation of these problems - and refusal to<BR>&nbsp;&nbsp; address some of them - has caused Reiser4 to stay out of the mainline<BR>&nbsp;&nbsp; kernel.</P>
<P>&nbsp;- The AppArmor security module made use of internal virtual filesystem<BR>&nbsp;&nbsp; data structures in ways which were considered to be unsafe and<BR>&nbsp;&nbsp; unreliable.&nbsp; This concern (among others) kept AppArmor out of the<BR>&nbsp;&nbsp; mainline for years.</P>
<P>In each of these cases, a great deal of pain and extra work could have been<BR>avoided with some early discussion with the kernel developers.</P>
<P><BR>3.3: WHO DO YOU TALK TO?</P>
<P>When developers decide to take their plans public, the next question will<BR>be: where do we start?&nbsp; The answer is to find the right mailing list(s) and<BR>the right maintainer.&nbsp; For mailing lists, the best approach is to look in<BR>the MAINTAINERS file for a relevant place to post.&nbsp; If there is a suitable<BR>subsystem list, posting there is often preferable to posting on<BR>linux-kernel; you are more likely to reach developers with expertise in the<BR>relevant subsystem and the environment may be more supportive.</P>
<P>Finding maintainers can be a bit harder.&nbsp; Again, the MAINTAINERS file is<BR>the place to start.&nbsp; That file tends to not always be up to date, though,<BR>and not all subsystems are represented there.&nbsp; The person listed in the<BR>MAINTAINERS file may, in fact, not be the person who is actually acting in<BR>that role currently.&nbsp; So, when there is doubt about who to contact, a<BR>useful trick is to use git (and "git log" in particular) to see who is<BR>currently active within the subsystem of interest.&nbsp; Look at who is writing<BR>patches, and who, if anybody, is attaching Signed-off-by lines to those<BR>patches.&nbsp; Those are the people who will be best placed to help with a new<BR>development project.</P>
<P>The task of finding the right maintainer is sometimes challenging enough<BR>that the kernel developers have added a script to ease the process:</P>
<P>&nbsp;.../scripts/get_maintainer.pl</P>
<P>This script will return the current maintainer(s) for a given file or<BR>directory when given the "-f" option.&nbsp; If passed a patch on the<BR>command line, it will list the maintainers who should probably receive<BR>copies of the patch.&nbsp; There are a number of options regulating how hard<BR>get_maintainer.pl will search for maintainers; please be careful about<BR>using the more aggressive options as you may end up including developers<BR>who have no real interest in the code you are modifying.</P>
<P>If all else fails, talking to Andrew Morton can be an effective way to<BR>track down a maintainer for a specific piece of code.</P>
<P><BR>3.4: WHEN TO POST?</P>
<P>If possible, posting your plans during the early stages can only be<BR>helpful.&nbsp; Describe the problem being solved and any plans that have been<BR>made on how the implementation will be done.&nbsp; Any information you can<BR>provide can help the development community provide useful input on the<BR>project.</P>
<P>One discouraging thing which can happen at this stage is not a hostile<BR>reaction, but, instead, little or no reaction at all.&nbsp; The sad truth of the<BR>matter is (1) kernel developers tend to be busy, (2) there is no shortage<BR>of people with grand plans and little code (or even prospect of code) to<BR>back them up, and (3) nobody is obligated to review or comment on ideas<BR>posted by others.&nbsp; Beyond that, high-level designs often hide problems<BR>which are only reviewed when somebody actually tries to implement those<BR>designs; for that reason, kernel developers would rather see the code.</P>
<P>If a request-for-comments posting yields little in the way of comments, do<BR>not assume that it means there is no interest in the project.<BR>Unfortunately, you also cannot assume that there are no problems with your<BR>idea.&nbsp; The best thing to do in this situation is to proceed, keeping the<BR>community informed as you go.</P>
<P><BR>3.5: GETTING OFFICIAL BUY-IN</P>
<P>If your work is being done in a corporate environment - as most Linux<BR>kernel work is - you must, obviously, have permission from suitably<BR>empowered managers before you can post your company's plans or code to a<BR>public mailing list.&nbsp; The posting of code which has not been cleared for<BR>release under a GPL-compatible license can be especially problematic; the<BR>sooner that a company's management and legal staff can agree on the posting<BR>of a kernel development project, the better off everybody involved will be.</P>
<P>Some readers may be thinking at this point that their kernel work is<BR>intended to support a product which does not yet have an officially<BR>acknowledged existence.&nbsp; Revealing their employer's plans on a public<BR>mailing list may not be a viable option.&nbsp; In cases like this, it is worth<BR>considering whether the secrecy is really necessary; there is often no real<BR>need to keep development plans behind closed doors.</P>
<P>That said, there are also cases where a company legitimately cannot<BR>disclose its plans early in the development process.&nbsp; Companies with<BR>experienced kernel developers may choose to proceed in an open-loop manner<BR>on the assumption that they will be able to avoid serious integration<BR>problems later.&nbsp; For companies without that sort of in-house expertise, the<BR>best option is often to hire an outside developer to review the plans under<BR>a non-disclosure agreement.&nbsp; The Linux Foundation operates an NDA program<BR>designed to help with this sort of situation; more information can be found<BR>at:</P>
<P>&nbsp;&nbsp;&nbsp; <A href="http://www.linuxfoundation.org/en/NDA_program">http://www.linuxfoundation.org/en/NDA_program</A></P>
<P>This kind of review is often enough to avoid serious problems later on<BR>without requiring public disclosure of the project.