# Documentation/clk.txt
<P></P>
<P>&nbsp;&nbsp;The Common Clk Framework<BR>&nbsp;&nbsp;Mike Turquette &lt;<A href="mailto:mturquette@ti.com">mturquette@ti.com</A>&gt;</P>
<P></P>
<P>This document endeavours to explain the common clk framework details,<BR>and how to port a platform over to this framework.&nbsp; It is not yet a<BR>detailed explanation of the clock api in include/linux/clk.h, but<BR>perhaps someday it will include that information.</P>
<P>&nbsp;Part 1 - introduction and interface split</P>
<P>The common clk framework is an interface to control the clock nodes<BR>available on various devices today.&nbsp; This may come in the form of clock<BR>gating, rate adjustment, muxing or other operations.&nbsp; This framework is<BR>enabled with the CONFIG_COMMON_CLK option.</P>
<P>The interface itself is divided into two halves, each shielded from the<BR>details of its counterpart.&nbsp; First is the common definition of struct<BR>clk which unifies the framework-level accounting and infrastructure that<BR>has traditionally been duplicated across a variety of platforms.&nbsp; Second<BR>is a common implementation of the clk.h api, defined in<BR>drivers/clk/clk.c.&nbsp; Finally there is struct clk_ops, whose operations<BR>are invoked by the clk api implementation.</P>
<P>The second half of the interface is comprised of the hardware-specific<BR>callbacks registered with struct clk_ops and the corresponding<BR>hardware-specific structures needed to model a particular clock.&nbsp; For<BR>the remainder of this document any reference to a callback in struct<BR>clk_ops, such as .enable or .set_rate, implies the hardware-specific<BR>implementation of that code.&nbsp; Likewise, references to struct clk_foo<BR>serve as a convenient shorthand for the implementation of the<BR>hardware-specific bits for the hypothetical "foo" hardware.</P>
<P>Tying the two halves of this interface together is struct clk_hw, which<BR>is defined in struct clk_foo and pointed to within struct clk.&nbsp; This<BR>allows easy for navigation between the two discrete halves of the common<BR>clock interface.</P>
<P>&nbsp;Part 2 - common data structures and api</P>
<P>Below is the common struct clk definition from<BR>include/linux/clk-private.h, modified for brevity:</P>
<P>&nbsp;struct clk {<BR>&nbsp;&nbsp;const char&nbsp;&nbsp;*name;<BR>&nbsp;&nbsp;const struct clk_ops&nbsp;*ops;<BR>&nbsp;&nbsp;struct clk_hw&nbsp;&nbsp;*hw;<BR>&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;**parent_names;<BR>&nbsp;&nbsp;struct clk&nbsp;&nbsp;**parents;<BR>&nbsp;&nbsp;struct clk&nbsp;&nbsp;*parent;<BR>&nbsp;&nbsp;struct hlist_head&nbsp;children;<BR>&nbsp;&nbsp;struct hlist_node&nbsp;child_node;<BR>&nbsp;&nbsp;...<BR>&nbsp;};</P>
<P>The members above make up the core of the clk tree topology.&nbsp; The clk<BR>api itself defines several driver-facing functions which operate on<BR>struct clk.&nbsp; That api is documented in include/linux/clk.h.</P>
<P>Platforms and devices utilizing the common struct clk use the struct<BR>clk_ops pointer in struct clk to perform the hardware-specific parts of<BR>the operations defined in clk.h:</P>
<P>&nbsp;struct clk_ops {<BR>&nbsp;&nbsp;int&nbsp;&nbsp;(*prepare)(struct clk_hw *hw);<BR>&nbsp;&nbsp;void&nbsp;&nbsp;(*unprepare)(struct clk_hw *hw);<BR>&nbsp;&nbsp;int&nbsp;&nbsp;(*enable)(struct clk_hw *hw);<BR>&nbsp;&nbsp;void&nbsp;&nbsp;(*disable)(struct clk_hw *hw);<BR>&nbsp;&nbsp;int&nbsp;&nbsp;(*is_enabled)(struct clk_hw *hw);<BR>&nbsp;&nbsp;unsigned long&nbsp;(*recalc_rate)(struct clk_hw *hw,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long parent_rate);<BR>&nbsp;&nbsp;long&nbsp;&nbsp;(*round_rate)(struct clk_hw *hw, unsigned long,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long *);<BR>&nbsp;&nbsp;int&nbsp;&nbsp;(*set_parent)(struct clk_hw *hw, u8 index);<BR>&nbsp;&nbsp;u8&nbsp;&nbsp;(*get_parent)(struct clk_hw *hw);<BR>&nbsp;&nbsp;int&nbsp;&nbsp;(*set_rate)(struct clk_hw *hw, unsigned long);<BR>&nbsp;&nbsp;void&nbsp;&nbsp;(*init)(struct clk_hw *hw);<BR>&nbsp;};</P>
<P>&nbsp;Part 3 - hardware clk implementations</P>
<P>The strength of the common struct clk comes from its .ops and .hw pointers<BR>which abstract the details of struct clk from the hardware-specific bits, and<BR>vice versa.&nbsp; To illustrate consider the simple gateable clk implementation in<BR>drivers/clk/clk-gate.c:</P>
<P>struct clk_gate {<BR>&nbsp;struct clk_hw&nbsp;hw;<BR>&nbsp;void __iomem&nbsp;&nbsp;&nbsp; *reg;<BR>&nbsp;u8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit_idx;<BR>&nbsp;...<BR>};</P>
<P>struct clk_gate contains struct clk_hw hw as well as hardware-specific<BR>knowledge about which register and bit controls this clk's gating.<BR>Nothing about clock topology or accounting, such as enable_count or<BR>notifier_count, is needed here.&nbsp; That is all handled by the common<BR>framework code and struct clk.</P>
<P>Let's walk through enabling this clk from driver code:</P>
<P>&nbsp;struct clk *clk;<BR>&nbsp;clk = clk_get(NULL, "my_gateable_clk");</P>
<P>&nbsp;clk_prepare(clk);<BR>&nbsp;clk_enable(clk);</P>
<P>The call graph for clk_enable is very simple:</P>
<P>clk_enable(clk);<BR>&nbsp;clk-&gt;ops-&gt;enable(clk-&gt;hw);<BR>&nbsp;[resolves to...]<BR>&nbsp;&nbsp;clk_gate_enable(hw);<BR>&nbsp;&nbsp;[resolves struct clk gate with to_clk_gate(hw)]<BR>&nbsp;&nbsp;&nbsp;clk_gate_set_bit(gate);</P>
<P>And the definition of clk_gate_set_bit:</P>
<P>static void clk_gate_set_bit(struct clk_gate *gate)<BR>{<BR>&nbsp;u32 reg;</P>
<P>&nbsp;reg = __raw_readl(gate-&gt;reg);<BR>&nbsp;reg |= BIT(gate-&gt;bit_idx);<BR>&nbsp;writel(reg, gate-&gt;reg);<BR>}</P>
<P>Note that to_clk_gate is defined as:</P>
<P>#define to_clk_gate(_hw) container_of(_hw, struct clk_gate, clk)</P>
<P>This pattern of abstraction is used for every clock hardware<BR>representation.</P>
<P>&nbsp;Part 4 - supporting your own clk hardware</P>
<P>When implementing support for a new type of clock it only necessary to<BR>include the following header:</P>
<P>#include &lt;linux/clk-provider.h&gt;</P>
<P>include/linux/clk.h is included within that header and clk-private.h<BR>must never be included from the code which implements the operations for<BR>a clock.&nbsp; More on that below in Part 5.</P>
<P>To construct a clk hardware structure for your platform you must define<BR>the following:</P>
<P>struct clk_foo {<BR>&nbsp;struct clk_hw hw;<BR>&nbsp;... hardware specific data goes here ...<BR>};</P>
<P>To take advantage of your data you'll need to support valid operations<BR>for your clk:</P>
<P>struct clk_ops clk_foo_ops {<BR>&nbsp;.enable&nbsp;&nbsp;= &amp;clk_foo_enable;<BR>&nbsp;.disable&nbsp;= &amp;clk_foo_disable;<BR>};</P>
<P>Implement the above functions using container_of:</P>
<P>#define to_clk_foo(_hw) container_of(_hw, struct clk_foo, hw)</P>
<P>int clk_foo_enable(struct clk_hw *hw)<BR>{<BR>&nbsp;struct clk_foo *foo;</P>
<P>&nbsp;foo = to_clk_foo(hw);</P>
<P>&nbsp;... perform magic on foo ...</P>
<P>&nbsp;return 0;<BR>};</P>
<P>Below is a matrix detailing which clk_ops are mandatory based upon the<BR>hardware capabilities of that clock.&nbsp; A cell marked as "y" means<BR>mandatory, a cell marked as "n" implies that either including that<BR>callback is invalid or otherwise unnecessary.&nbsp; Empty cells are either<BR>optional or must be evaluated on a case-by-case basis.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clock hardware characteristics<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -----------------------------------------------------------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | gate | change rate | single parent | multiplexer | root |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------|-------------|---------------|-------------|------|<BR>.prepare&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>.unprepare&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>.enable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | y&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>.disable&nbsp;&nbsp;&nbsp;&nbsp; | y&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>.is_enabled&nbsp; | y&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>.recalc_rate |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>.round_rate&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>.set_rate&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>.set_parent&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | n&nbsp;&nbsp;&nbsp; |<BR>.get_parent&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | n&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>.init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -----------------------------------------------------------</P>
<P>Finally, register your clock at run-time with a hardware-specific<BR>registration function.&nbsp; This function simply populates struct clk_foo's<BR>data and then passes the common struct clk parameters to the framework<BR>with a call to:</P>
<P>clk_register(...)</P>
<P>See the basic clock types in drivers/clk/clk-*.c for examples.</P>
<P>&nbsp;Part 5 - static initialization of clock data</P>
<P>For platforms with many clocks (often numbering into the hundreds) it<BR>may be desirable to statically initialize some clock data.&nbsp; This<BR>presents a problem since the definition of struct clk should be hidden<BR>from everyone except for the clock core in drivers/clk/clk.c.</P>
<P>To get around this problem struct clk's definition is exposed in<BR>include/linux/clk-private.h along with some macros for more easily<BR>initializing instances of the basic clock types.&nbsp; These clocks must<BR>still be initialized with the common clock framework via a call to<BR>__clk_init.</P>
<P>clk-private.h must NEVER be included by code which implements struct<BR>clk_ops callbacks, nor must it be included by any logic which pokes<BR>around inside of struct clk at run-time.&nbsp; To do so is a layering<BR>violation.</P>
<P>To better enforce this policy, always follow this simple rule: any<BR>statically initialized clock data MUST be defined in a separate file<BR>from the logic that implements its ops.&nbsp; Basically separate the logic<BR>from the data and all is well.</P>
<P>&nbsp;Part 6 - Disabling clock gating of unused clocks</P>
<P>Sometimes during development it can be useful to be able to bypass the<BR>default disabling of unused clocks. For example, if drivers aren't enabling<BR>clocks properly but rely on them being on from the bootloader, bypassing<BR>the disabling means that the driver will remain functional while the issues<BR>are sorted out.</P>
<P>To bypass this disabling, include "clk_ignore_unused" in the bootargs to the<BR>kernel.