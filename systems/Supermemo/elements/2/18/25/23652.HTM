# include/linux/platform_device.h 
<P></P>
<P>/*<BR>&nbsp;* platform_device.h - generic, centralized driver model<BR>&nbsp;*<BR>&nbsp;* Copyright (c) 2001-2003 Patrick Mochel &lt;<A href="mailto:mochel@osdl.org">mochel@osdl.org</A>&gt;<BR>&nbsp;*<BR>&nbsp;* This file is released under the GPLv2<BR>&nbsp;*<BR>&nbsp;* See Documentation/driver-model/ for more information.<BR>&nbsp;*/</P>
<P></P>
<P>#ifndef _PLATFORM_DEVICE_H_<BR>#define _PLATFORM_DEVICE_H_</P>
<P>#include &lt;linux/device.h&gt;<BR>#include &lt;linux/mod_devicetable.h&gt;</P>
<P>#define PLATFORM_DEVID_NONE&nbsp;(-1)<BR>#define PLATFORM_DEVID_AUTO&nbsp;(-2)</P>
<P>struct mfd_cell;</P>
<P><FONT class=extract>struct platform_device {<BR>&nbsp;const char&nbsp;*name;<BR>&nbsp;int&nbsp;&nbsp;id;<BR>&nbsp;bool&nbsp;&nbsp;id_auto;<BR>&nbsp;struct device&nbsp;dev;<BR>&nbsp;u32&nbsp;&nbsp;num_resources;<BR>&nbsp;struct resource&nbsp;*resource;</FONT></P>
<P><FONT class=extract>&nbsp;const struct platform_device_id&nbsp;*id_entry;</FONT></P>
<P><FONT class=extract>&nbsp;/* MFD cell pointer */<BR>&nbsp;struct mfd_cell *mfd_cell;</FONT></P>
<P><FONT class=extract>&nbsp;/* arch specific additions */<BR>&nbsp;struct pdev_archdata&nbsp;archdata;<BR>};</FONT></P>
<P><FONT class=extract>#define platform_get_device_id(pdev)&nbsp;((pdev)-&gt;id_entry)</FONT></P>
<P><FONT class=extract>#define to_platform_device(x) container_of((x), struct platform_device, dev)</FONT></P>
<P>extern int platform_device_register(struct platform_device *);<BR>extern void platform_device_unregister(struct platform_device *);</P>
<P>extern struct bus_type platform_bus_type;<BR>extern struct device platform_bus;</P>
<P>extern void arch_setup_pdev_archdata(struct platform_device *);<BR>extern struct resource *platform_get_resource(struct platform_device *,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int, unsigned int);<BR>extern int platform_get_irq(struct platform_device *, unsigned int);<BR>extern struct resource *platform_get_resource_byname(struct platform_device *,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *);<BR>extern int platform_get_irq_byname(struct platform_device *, const char *);<BR>extern int platform_add_devices(struct platform_device **, int);</P>
<P>struct platform_device_info {<BR>&nbsp;&nbsp;struct device *parent;<BR>&nbsp;&nbsp;struct acpi_dev_node acpi_node;</P>
<P>&nbsp;&nbsp;const char *name;<BR>&nbsp;&nbsp;int id;</P>
<P>&nbsp;&nbsp;const struct resource *res;<BR>&nbsp;&nbsp;unsigned int num_res;</P>
<P>&nbsp;&nbsp;const void *data;<BR>&nbsp;&nbsp;size_t size_data;<BR>&nbsp;&nbsp;u64 dma_mask;<BR>};<BR>extern struct platform_device *platform_device_register_full(<BR>&nbsp;&nbsp;const struct platform_device_info *pdevinfo);</P>
<P>/**<BR>&nbsp;* platform_device_register_resndata - add a platform-level device with<BR>&nbsp;* resources and platform-specific data<BR>&nbsp;*<BR>&nbsp;* @parent: parent device for the device we're adding<BR>&nbsp;* @name: base name of the device we're adding<BR>&nbsp;* @id: instance id<BR>&nbsp;* @res: set of resources that needs to be allocated for the device<BR>&nbsp;* @num: number of resources<BR>&nbsp;* @data: platform specific data for this platform device<BR>&nbsp;* @size: size of platform specific data<BR>&nbsp;*<BR>&nbsp;* Returns &amp;struct platform_device pointer on success, or ERR_PTR() on error.<BR>&nbsp;*/<BR>static inline struct platform_device *platform_device_register_resndata(<BR>&nbsp;&nbsp;struct device *parent, const char *name, int id,<BR>&nbsp;&nbsp;const struct resource *res, unsigned int num,<BR>&nbsp;&nbsp;const void *data, size_t size) {</P>
<P>&nbsp;struct platform_device_info pdevinfo = {<BR>&nbsp;&nbsp;.parent = parent,<BR>&nbsp;&nbsp;.name = name,<BR>&nbsp;&nbsp;.id = id,<BR>&nbsp;&nbsp;.res = res,<BR>&nbsp;&nbsp;.num_res = num,<BR>&nbsp;&nbsp;.data = data,<BR>&nbsp;&nbsp;.size_data = size,<BR>&nbsp;&nbsp;.dma_mask = 0,<BR>&nbsp;};</P>
<P>&nbsp;return platform_device_register_full(&amp;pdevinfo);<BR>}</P>
<P>/**<BR>&nbsp;* platform_device_register_simple - add a platform-level device and its resources<BR>&nbsp;* @name: base name of the device we're adding<BR>&nbsp;* @id: instance id<BR>&nbsp;* @res: set of resources that needs to be allocated for the device<BR>&nbsp;* @num: number of resources<BR>&nbsp;*<BR>&nbsp;* This function creates a simple platform device that requires minimal<BR>&nbsp;* resource and memory management. Canned release function freeing memory<BR>&nbsp;* allocated for the device allows drivers using such devices to be<BR>&nbsp;* unloaded without waiting for the last reference to the device to be<BR>&nbsp;* dropped.<BR>&nbsp;*<BR>&nbsp;* This interface is primarily intended for use with legacy drivers which<BR>&nbsp;* probe hardware directly.&nbsp; Because such drivers create sysfs device nodes<BR>&nbsp;* themselves, rather than letting system infrastructure handle such device<BR>&nbsp;* enumeration tasks, they don't fully conform to the Linux driver model.<BR>&nbsp;* In particular, when such drivers are built as modules, they can't be<BR>&nbsp;* "hotplugged".<BR>&nbsp;*<BR>&nbsp;* Returns &amp;struct platform_device pointer on success, or ERR_PTR() on error.<BR>&nbsp;*/<BR>static inline struct platform_device *platform_device_register_simple(<BR>&nbsp;&nbsp;const char *name, int id,<BR>&nbsp;&nbsp;const struct resource *res, unsigned int num)<BR>{<BR>&nbsp;return platform_device_register_resndata(NULL, name, id,<BR>&nbsp;&nbsp;&nbsp;res, num, NULL, 0);<BR>}</P>
<P>/**<BR>&nbsp;* platform_device_register_data - add a platform-level device with platform-specific data<BR>&nbsp;* @parent: parent device for the device we're adding<BR>&nbsp;* @name: base name of the device we're adding<BR>&nbsp;* @id: instance id<BR>&nbsp;* @data: platform specific data for this platform device<BR>&nbsp;* @size: size of platform specific data<BR>&nbsp;*<BR>&nbsp;* This function creates a simple platform device that requires minimal<BR>&nbsp;* resource and memory management. Canned release function freeing memory<BR>&nbsp;* allocated for the device allows drivers using such devices to be<BR>&nbsp;* unloaded without waiting for the last reference to the device to be<BR>&nbsp;* dropped.<BR>&nbsp;*<BR>&nbsp;* Returns &amp;struct platform_device pointer on success, or ERR_PTR() on error.<BR>&nbsp;*/<BR>static inline struct platform_device *platform_device_register_data(<BR>&nbsp;&nbsp;struct device *parent, const char *name, int id,<BR>&nbsp;&nbsp;const void *data, size_t size)<BR>{<BR>&nbsp;return platform_device_register_resndata(parent, name, id,<BR>&nbsp;&nbsp;&nbsp;NULL, 0, data, size);<BR>}</P>
<P>extern struct platform_device *platform_device_alloc(const char *name, int id);<BR>extern int platform_device_add_resources(struct platform_device *pdev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct resource *res,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int num);<BR>extern int platform_device_add_data(struct platform_device *pdev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *data, size_t size);<BR>extern int platform_device_add(struct platform_device *pdev);<BR>extern void platform_device_del(struct platform_device *pdev);<BR>extern void platform_device_put(struct platform_device *pdev);</P>
<P>struct platform_driver {<BR>&nbsp;int (*probe)(struct platform_device *);<BR>&nbsp;int (*remove)(struct platform_device *);<BR>&nbsp;void (*shutdown)(struct platform_device *);<BR>&nbsp;int (*suspend)(struct platform_device *, pm_message_t state);<BR>&nbsp;int (*resume)(struct platform_device *);<BR>&nbsp;struct device_driver driver;<BR>&nbsp;const struct platform_device_id *id_table;<BR>};</P>
<P>extern int platform_driver_register(struct platform_driver *);<BR>extern void platform_driver_unregister(struct platform_driver *);</P>
<P>/* non-hotpluggable platform devices may use this so that probe() and<BR>&nbsp;* its support may live in __init sections, conserving runtime memory.<BR>&nbsp;*/<BR>extern int platform_driver_probe(struct platform_driver *driver,<BR>&nbsp;&nbsp;int (*probe)(struct platform_device *));</P>
<P>static inline void *platform_get_drvdata(const struct platform_device *pdev)<BR>{<BR>&nbsp;return dev_get_drvdata(&amp;pdev-&gt;dev);<BR>}</P>
<P>static inline void platform_set_drvdata(struct platform_device *pdev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *data)<BR>{<BR>&nbsp;dev_set_drvdata(&amp;pdev-&gt;dev, data);<BR>}</P>
<P>/* module_platform_driver() - Helper macro for drivers that don't do<BR>&nbsp;* anything special in module init/exit.&nbsp; This eliminates a lot of<BR>&nbsp;* boilerplate.&nbsp; Each module may only use this macro once, and<BR>&nbsp;* calling it replaces module_init() and module_exit()<BR>&nbsp;*/<BR>#define module_platform_driver(__platform_driver) \<BR>&nbsp;module_driver(__platform_driver, platform_driver_register, \<BR>&nbsp;&nbsp;&nbsp;platform_driver_unregister)</P>
<P>/* module_platform_driver_probe() - Helper macro for drivers that don't do<BR>&nbsp;* anything special in module init/exit.&nbsp; This eliminates a lot of<BR>&nbsp;* boilerplate.&nbsp; Each module may only use this macro once, and<BR>&nbsp;* calling it replaces module_init() and module_exit()<BR>&nbsp;*/<BR>#define module_platform_driver_probe(__platform_driver, __platform_probe) \<BR>static int __init __platform_driver##_init(void) \<BR>{ \<BR>&nbsp;return platform_driver_probe(&amp;(__platform_driver), \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __platform_probe);&nbsp;&nbsp;&nbsp; \<BR>} \<BR>module_init(__platform_driver##_init); \<BR>static void __exit __platform_driver##_exit(void) \<BR>{ \<BR>&nbsp;platform_driver_unregister(&amp;(__platform_driver)); \<BR>} \<BR>module_exit(__platform_driver##_exit);</P>
<P>extern struct platform_device *platform_create_bundle(<BR>&nbsp;struct platform_driver *driver, int (*probe)(struct platform_device *),<BR>&nbsp;struct resource *res, unsigned int n_res,<BR>&nbsp;const void *data, size_t size);</P>
<P>/* early platform driver interface */<BR>struct early_platform_driver {<BR>&nbsp;const char *class_str;<BR>&nbsp;struct platform_driver *pdrv;<BR>&nbsp;struct list_head list;<BR>&nbsp;int requested_id;<BR>&nbsp;char *buffer;<BR>&nbsp;int bufsize;<BR>};</P>
<P>#define EARLY_PLATFORM_ID_UNSET -2<BR>#define EARLY_PLATFORM_ID_ERROR -3</P>
<P>extern int early_platform_driver_register(struct early_platform_driver *epdrv,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf);<BR>extern void early_platform_add_devices(struct platform_device **devs, int num);</P>
<P>static inline int is_early_platform_device(struct platform_device *pdev)<BR>{<BR>&nbsp;return !pdev-&gt;dev.driver;<BR>}</P>
<P>extern void early_platform_driver_register_all(char *class_str);<BR>extern int early_platform_driver_probe(char *class_str,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nr_probe, int user_only);<BR>extern void early_platform_cleanup(void);</P>
<P>#define early_platform_init(class_string, platdrv)&nbsp;&nbsp;\<BR>&nbsp;early_platform_init_buffer(class_string, platdrv, NULL, 0)</P>
<P>#ifndef MODULE<BR>#define early_platform_init_buffer(class_string, platdrv, buf, bufsiz)&nbsp;\<BR>static __initdata struct early_platform_driver early_driver = {&nbsp;&nbsp;\<BR>&nbsp;.class_str = class_string,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.buffer = buf,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.bufsize = bufsiz,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.pdrv = platdrv,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.requested_id = EARLY_PLATFORM_ID_UNSET,&nbsp;&nbsp;&nbsp;\<BR>};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>static int __init early_platform_driver_setup_func(char *buffer)&nbsp;\<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;return early_platform_driver_register(&amp;early_driver, buffer);&nbsp;\<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>early_param(class_string, early_platform_driver_setup_func)<BR>#else /* MODULE */<BR>#define early_platform_init_buffer(class_string, platdrv, buf, bufsiz)&nbsp;\<BR>static inline char *early_platform_driver_setup_func(void)&nbsp;&nbsp;\<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;return bufsiz ? buf : NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>}<BR>#endif /* MODULE */</P>
<P>#ifdef CONFIG_SUSPEND<BR>extern int platform_pm_suspend(struct device *dev);<BR>extern int platform_pm_resume(struct device *dev);<BR>#else<BR>#define platform_pm_suspend&nbsp;&nbsp;NULL<BR>#define platform_pm_resume&nbsp;&nbsp;NULL<BR>#endif</P>
<P>#ifdef CONFIG_HIBERNATE_CALLBACKS<BR>extern int platform_pm_freeze(struct device *dev);<BR>extern int platform_pm_thaw(struct device *dev);<BR>extern int platform_pm_poweroff(struct device *dev);<BR>extern int platform_pm_restore(struct device *dev);<BR>#else<BR>#define platform_pm_freeze&nbsp;&nbsp;NULL<BR>#define platform_pm_thaw&nbsp;&nbsp;NULL<BR>#define platform_pm_poweroff&nbsp;&nbsp;NULL<BR>#define platform_pm_restore&nbsp;&nbsp;NULL<BR>#endif</P>
<P>#ifdef CONFIG_PM_SLEEP<BR>#define USE_PLATFORM_PM_SLEEP_OPS \<BR>&nbsp;.suspend = platform_pm_suspend, \<BR>&nbsp;.resume = platform_pm_resume, \<BR>&nbsp;.freeze = platform_pm_freeze, \<BR>&nbsp;.thaw = platform_pm_thaw, \<BR>&nbsp;.poweroff = platform_pm_poweroff, \<BR>&nbsp;.restore = platform_pm_restore,<BR>#else<BR>#define USE_PLATFORM_PM_SLEEP_OPS<BR>#endif</P>
<P>#endif /* _PLATFORM_DEVICE_H_ */