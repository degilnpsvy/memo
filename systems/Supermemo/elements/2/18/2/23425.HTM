# Documentation/initrd.txt
<P></P>
<P>Using the initial RAM disk (initrd)<BR>===================================</P>
<P></P>
<P>Written 1996,2000 by Werner Almesberger &lt;<A href="mailto:werner.almesberger@epfl.ch">werner.almesberger@epfl.ch</A>&gt; and<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hans Lermen &lt;<A href="mailto:lermen@fgan.de">lermen@fgan.de</A>&gt;</P>
<P><BR>initrd provides the capability to load a RAM disk by the boot loader.<BR>This RAM disk can then be mounted as the root file system and programs<BR>can be run from it. Afterwards, a new root file system can be mounted<BR>from a different device. The previous root (from initrd) is then moved<BR>to a directory and can be subsequently unmounted.</P>
<P>initrd is mainly designed to allow system startup to occur in two phases,<BR>where the kernel comes up with a minimum set of compiled-in drivers, and<BR>where additional modules are loaded from initrd.</P>
<P>This document gives a brief overview of the use of initrd. A more detailed<BR>discussion of the boot process can be found in [1].</P>
<P><BR>Operation<BR>---------</P>
<P>When using initrd, the system typically boots as follows:</P>
<P>&nbsp; 1) the boot loader loads the kernel and the initial RAM disk<BR>&nbsp; 2) the kernel converts initrd into a "normal" RAM disk and<BR>&nbsp;&nbsp;&nbsp;&nbsp; frees the memory used by initrd<BR>&nbsp; 3) if the root device is not /dev/ram0, the old (deprecated)<BR>&nbsp;&nbsp;&nbsp;&nbsp; change_root procedure is followed. see the "Obsolete root change<BR>&nbsp;&nbsp;&nbsp;&nbsp; mechanism" section below.<BR>&nbsp; 4) root device is mounted. if it is /dev/ram0, the initrd image is<BR>&nbsp;&nbsp;&nbsp;&nbsp; then mounted as root<BR>&nbsp; 5) /sbin/init is executed (this can be any valid executable, including<BR>&nbsp;&nbsp;&nbsp;&nbsp; shell scripts; it is run with uid 0 and can do basically everything<BR>&nbsp;&nbsp;&nbsp;&nbsp; init can do).<BR>&nbsp; 6) init mounts the "real" root file system<BR>&nbsp; 7) init places the root file system at the root directory using the<BR>&nbsp;&nbsp;&nbsp;&nbsp; pivot_root system call<BR>&nbsp; 8) init execs the /sbin/init on the new root filesystem, performing<BR>&nbsp;&nbsp;&nbsp;&nbsp; the usual boot sequence<BR>&nbsp; 9) the initrd file system is removed</P>
<P>Note that changing the root directory does not involve unmounting it.<BR>It is therefore possible to leave processes running on initrd during that<BR>procedure. Also note that file systems mounted under initrd continue to<BR>be accessible.</P>
<P><BR>Boot command-line options<BR>-------------------------</P>
<P>initrd adds the following new options:</P>
<P>&nbsp; initrd=&lt;path&gt;&nbsp;&nbsp;&nbsp; (e.g. LOADLIN)</P>
<P>&nbsp;&nbsp;&nbsp; Loads the specified file as the initial RAM disk. When using LILO, you<BR>&nbsp;&nbsp;&nbsp; have to specify the RAM disk image file in /etc/lilo.conf, using the<BR>&nbsp;&nbsp;&nbsp; INITRD configuration variable.</P>
<P>&nbsp; noinitrd</P>
<P>&nbsp;&nbsp;&nbsp; initrd data is preserved but it is not converted to a RAM disk and<BR>&nbsp;&nbsp;&nbsp; the "normal" root file system is mounted. initrd data can be read<BR>&nbsp;&nbsp;&nbsp; from /dev/initrd. Note that the data in initrd can have any structure<BR>&nbsp;&nbsp;&nbsp; in this case and doesn't necessarily have to be a file system image.<BR>&nbsp;&nbsp;&nbsp; This option is used mainly for debugging.</P>
<P>&nbsp;&nbsp;&nbsp; Note: /dev/initrd is read-only and it can only be used once. As soon<BR>&nbsp;&nbsp;&nbsp; as the last process has closed it, all data is freed and /dev/initrd<BR>&nbsp;&nbsp;&nbsp; can't be opened anymore.</P>
<P>&nbsp; root=/dev/ram0</P>
<P>&nbsp;&nbsp;&nbsp; initrd is mounted as root, and the normal boot procedure is followed,<BR>&nbsp;&nbsp;&nbsp; with the RAM disk mounted as root.</P>
<P>Compressed cpio images<BR>----------------------</P>
<P>Recent kernels have support for populating a ramdisk from a compressed cpio<BR>archive. On such systems, the creation of a ramdisk image doesn't need to<BR>involve special block devices or loopbacks; you merely create a directory on<BR>disk with the desired initrd content, cd to that directory, and run (as an<BR>example):</P>
<P>find . | cpio --quiet -H newc -o | gzip -9 -n &gt; /boot/imagefile.img</P>
<P>Examining the contents of an existing image file is just as simple:</P>
<P>mkdir /tmp/imagefile<BR>cd /tmp/imagefile<BR>gzip -cd /boot/imagefile.img | cpio -imd --quiet</P>
<P>Installation<BR>------------</P>
<P>First, a directory for the initrd file system has to be created on the<BR>"normal" root file system, e.g.</P>
<P># mkdir /initrd</P>
<P>The name is not relevant. More details can be found on the pivot_root(2)<BR>man page.</P>
<P>If the root file system is created during the boot procedure (i.e. if<BR>you're building an install floppy), the root file system creation<BR>procedure should create the /initrd directory.</P>
<P>If initrd will not be mounted in some cases, its content is still<BR>accessible if the following device has been created:</P>
<P># mknod /dev/initrd b 1 250 <BR># chmod 400 /dev/initrd</P>
<P>Second, the kernel has to be compiled with RAM disk support and with<BR>support for the initial RAM disk enabled. Also, at least all components<BR>needed to execute programs from initrd (e.g. executable format and file<BR>system) must be compiled into the kernel.</P>
<P>Third, you have to create the RAM disk image. This is done by creating a<BR>file system on a block device, copying files to it as needed, and then<BR>copying the content of the block device to the initrd file. With recent<BR>kernels, at least three types of devices are suitable for that:</P>
<P>&nbsp;- a floppy disk (works everywhere but it's painfully slow)<BR>&nbsp;- a RAM disk (fast, but allocates physical memory)<BR>&nbsp;- a loopback device (the most elegant solution)</P>
<P>We'll describe the loopback device method:</P>
<P>&nbsp;1) make sure loopback block devices are configured into the kernel<BR>&nbsp;2) create an empty file system of the appropriate size, e.g.<BR>&nbsp;&nbsp;&nbsp; # dd if=/dev/zero of=initrd bs=300k count=1<BR>&nbsp;&nbsp;&nbsp; # mke2fs -F -m0 initrd<BR>&nbsp;&nbsp;&nbsp; (if space is critical, you may want to use the Minix FS instead of Ext2)<BR>&nbsp;3) mount the file system, e.g.<BR>&nbsp;&nbsp;&nbsp; # mount -t ext2 -o loop initrd /mnt<BR>&nbsp;4) create the console device:<BR>&nbsp;&nbsp;&nbsp; # mkdir /mnt/dev<BR>&nbsp;&nbsp;&nbsp; # mknod /mnt/dev/console c 5 1<BR>&nbsp;5) copy all the files that are needed to properly use the initrd<BR>&nbsp;&nbsp;&nbsp; environment. Don't forget the most important file, /sbin/init<BR>&nbsp;&nbsp;&nbsp; Note that /sbin/init's permissions must include "x" (execute).<BR>&nbsp;6) correct operation the initrd environment can frequently be tested<BR>&nbsp;&nbsp;&nbsp; even without rebooting with the command<BR>&nbsp;&nbsp;&nbsp; # chroot /mnt /sbin/init<BR>&nbsp;&nbsp;&nbsp; This is of course limited to initrds that do not interfere with the<BR>&nbsp;&nbsp;&nbsp; general system state (e.g. by reconfiguring network interfaces,<BR>&nbsp;&nbsp;&nbsp; overwriting mounted devices, trying to start already running demons,<BR>&nbsp;&nbsp;&nbsp; etc. Note however that it is usually possible to use pivot_root in<BR>&nbsp;&nbsp;&nbsp; such a chroot'ed initrd environment.)<BR>&nbsp;7) unmount the file system<BR>&nbsp;&nbsp;&nbsp; # umount /mnt<BR>&nbsp;8) the initrd is now in the file "initrd". Optionally, it can now be<BR>&nbsp;&nbsp;&nbsp; compressed<BR>&nbsp;&nbsp;&nbsp; # gzip -9 initrd</P>
<P>For experimenting with initrd, you may want to take a rescue floppy and<BR>only add a symbolic link from /sbin/init to /bin/sh. Alternatively, you<BR>can try the experimental newlib environment [2] to create a small<BR>initrd.</P>
<P>Finally, you have to boot the kernel and load initrd. Almost all Linux<BR>boot loaders support initrd. Since the boot process is still compatible<BR>with an older mechanism, the following boot command line parameters<BR>have to be given:</P>
<P>&nbsp; root=/dev/ram0 rw</P>
<P>(rw is only necessary if writing to the initrd file system.)</P>
<P>With LOADLIN, you simply execute</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; LOADLIN &lt;kernel&gt; initrd=&lt;disk_image&gt;<BR>e.g. LOADLIN C:\LINUX\BZIMAGE initrd=C:\LINUX\INITRD.GZ root=/dev/ram0 rw</P>
<P>With LILO, you add the option INITRD=&lt;path&gt; to either the global section<BR>or to the section of the respective kernel in /etc/lilo.conf, and pass<BR>the options using APPEND, e.g.</P>
<P>&nbsp; image = /bzImage<BR>&nbsp;&nbsp;&nbsp; initrd = /boot/initrd.gz<BR>&nbsp;&nbsp;&nbsp; append = "root=/dev/ram0 rw"</P>
<P>and run /sbin/lilo</P>
<P>For other boot loaders, please refer to the respective documentation.</P>
<P>Now you can boot and enjoy using initrd.</P>
<P><BR>Changing the root device<BR>------------------------</P>
<P>When finished with its duties, init typically changes the root device<BR>and proceeds with starting the Linux system on the "real" root device.</P>
<P>The procedure involves the following steps:<BR>&nbsp;- mounting the new root file system<BR>&nbsp;- turning it into the root file system<BR>&nbsp;- removing all accesses to the old (initrd) root file system<BR>&nbsp;- unmounting the initrd file system and de-allocating the RAM disk</P>
<P>Mounting the new root file system is easy: it just needs to be mounted on<BR>a directory under the current root. Example:</P>
<P># mkdir /new-root<BR># mount -o ro /dev/hda1 /new-root</P>
<P>The root change is accomplished with the pivot_root system call, which<BR>is also available via the pivot_root utility (see pivot_root(8) man<BR>page; pivot_root is distributed with util-linux version 2.10h or higher<BR>[3]). pivot_root moves the current root to a directory under the new<BR>root, and puts the new root at its place. The directory for the old root<BR>must exist before calling pivot_root. Example:</P>
<P># cd /new-root<BR># mkdir initrd<BR># pivot_root . initrd</P>
<P>Now, the init process may still access the old root via its<BR>executable, shared libraries, standard input/output/error, and its<BR>current root directory. All these references are dropped by the<BR>following command:</P>
<P># exec chroot . what-follows &lt;dev/console &gt;dev/console 2&gt;&amp;1</P>
<P>Where what-follows is a program under the new root, e.g. /sbin/init<BR>If the new root file system will be used with udev and has no valid<BR>/dev directory, udev must be initialized before invoking chroot in order<BR>to provide /dev/console.</P>
<P>Note: implementation details of pivot_root may change with time. In order<BR>to ensure compatibility, the following points should be observed:</P>
<P>&nbsp;- before calling pivot_root, the current directory of the invoking<BR>&nbsp;&nbsp; process should point to the new root directory<BR>&nbsp;- use . as the first argument, and the _relative_ path of the directory<BR>&nbsp;&nbsp; for the old root as the second argument<BR>&nbsp;- a chroot program must be available under the old and the new root<BR>&nbsp;- chroot to the new root afterwards<BR>&nbsp;- use relative paths for dev/console in the exec command</P>
<P>Now, the initrd can be unmounted and the memory allocated by the RAM<BR>disk can be freed:</P>
<P># umount /initrd<BR># blockdev --flushbufs /dev/ram0</P>
<P>It is also possible to use initrd with an NFS-mounted root, see the<BR>pivot_root(8) man page for details.</P>
<P><BR>Usage scenarios<BR>---------------</P>
<P>The main motivation for implementing initrd was to allow for modular<BR>kernel configuration at system installation. The procedure would work<BR>as follows:</P>
<P>&nbsp; 1) system boots from floppy or other media with a minimal kernel<BR>&nbsp;&nbsp;&nbsp;&nbsp; (e.g. support for RAM disks, initrd, a.out, and the Ext2 FS) and<BR>&nbsp;&nbsp;&nbsp;&nbsp; loads initrd<BR>&nbsp; 2) /sbin/init determines what is needed to (1) mount the "real" root FS<BR>&nbsp;&nbsp;&nbsp;&nbsp; (i.e. device type, device drivers, file system) and (2) the<BR>&nbsp;&nbsp;&nbsp;&nbsp; distribution media (e.g. CD-ROM, network, tape, ...). This can be<BR>&nbsp;&nbsp;&nbsp;&nbsp; done by asking the user, by auto-probing, or by using a hybrid<BR>&nbsp;&nbsp;&nbsp;&nbsp; approach.<BR>&nbsp; 3) /sbin/init loads the necessary kernel modules<BR>&nbsp; 4) /sbin/init creates and populates the root file system (this doesn't<BR>&nbsp;&nbsp;&nbsp;&nbsp; have to be a very usable system yet)<BR>&nbsp; 5) /sbin/init invokes pivot_root to change the root file system and<BR>&nbsp;&nbsp;&nbsp;&nbsp; execs - via chroot - a program that continues the installation<BR>&nbsp; 6) the boot loader is installed<BR>&nbsp; 7) the boot loader is configured to load an initrd with the set of<BR>&nbsp;&nbsp;&nbsp;&nbsp; modules that was used to bring up the system (e.g. /initrd can be<BR>&nbsp;&nbsp;&nbsp;&nbsp; modified, then unmounted, and finally, the image is written from<BR>&nbsp;&nbsp;&nbsp;&nbsp; /dev/ram0 or /dev/rd/0 to a file)<BR>&nbsp; 8) now the system is bootable and additional installation tasks can be<BR>&nbsp;&nbsp;&nbsp;&nbsp; performed</P>
<P>The key role of initrd here is to re-use the configuration data during<BR>normal system operation without requiring the use of a bloated "generic"<BR>kernel or re-compiling or re-linking the kernel.</P>
<P>A second scenario is for installations where Linux runs on systems with<BR>different hardware configurations in a single administrative domain. In<BR>such cases, it is desirable to generate only a small set of kernels<BR>(ideally only one) and to keep the system-specific part of configuration<BR>information as small as possible. In this case, a common initrd could be<BR>generated with all the necessary modules. Then, only /sbin/init or a file<BR>read by it would have to be different.</P>
<P>A third scenario is more convenient recovery disks, because information<BR>like the location of the root FS partition doesn't have to be provided at<BR>boot time, but the system loaded from initrd can invoke a user-friendly<BR>dialog and it can also perform some sanity checks (or even some form of<BR>auto-detection).</P>
<P>Last not least, CD-ROM distributors may use it for better installation<BR>from CD, e.g. by using a boot floppy and bootstrapping a bigger RAM disk<BR>via initrd from CD; or by booting via a loader like LOADLIN or directly<BR>from the CD-ROM, and loading the RAM disk from CD without need of<BR>floppies. </P>
<P><BR>Obsolete root change mechanism<BR>------------------------------</P>
<P>The following mechanism was used before the introduction of pivot_root.<BR>Current kernels still support it, but you should _not_ rely on its<BR>continued availability.</P>
<P>It works by mounting the "real" root device (i.e. the one set with rdev<BR>in the kernel image or with root=... at the boot command line) as the<BR>root file system when linuxrc exits. The initrd file system is then<BR>unmounted, or, if it is still busy, moved to a directory /initrd, if<BR>such a directory exists on the new root file system.</P>
<P>In order to use this mechanism, you do not have to specify the boot<BR>command options root, init, or rw. (If specified, they will affect<BR>the real root file system, not the initrd environment.)<BR>&nbsp; <BR>If /proc is mounted, the "real" root device can be changed from within<BR>linuxrc by writing the number of the new root FS device to the special<BR>file /proc/sys/kernel/real-root-dev, e.g.</P>
<P>&nbsp; # echo 0x301 &gt;/proc/sys/kernel/real-root-dev</P>
<P>Note that the mechanism is incompatible with NFS and similar file<BR>systems.</P>
<P>This old, deprecated mechanism is commonly called "change_root", while<BR>the new, supported mechanism is called "pivot_root".</P>
<P><BR>Mixed change_root and pivot_root mechanism<BR>------------------------------------------</P>
<P>In case you did not want to use root=/dev/ram0 to trigger the pivot_root<BR>mechanism, you may create both /linuxrc and /sbin/init in your initrd image.</P>
<P>/linuxrc would contain only the following:</P>
<P>#! /bin/sh<BR>mount -n -t proc proc /proc<BR>echo 0x0100 &gt;/proc/sys/kernel/real-root-dev<BR>umount -n /proc</P>
<P>Once linuxrc exited, the kernel would mount again your initrd as root,<BR>this time executing /sbin/init. Again, it would be the duty of this init<BR>to build the right environment (maybe using the root= device passed on<BR>the cmdline) before the final execution of the real /sbin/init.</P>
<P><BR>Resources<BR>---------</P>
<P>[1] Almesberger, Werner; "Booting Linux: The History and the Future"<BR>&nbsp;&nbsp;&nbsp; <A href="http://www.almesberger.net/cv/papers/ols2k-9.ps.gz">http://www.almesberger.net/cv/papers/ols2k-9.ps.gz</A><BR>[2] newlib package (experimental), with initrd example<BR>&nbsp;&nbsp;&nbsp; <A href="http://sources.redhat.com/newlib/">http://sources.redhat.com/newlib/</A><BR>[3] util-linux: Miscellaneous utilities for Linux<BR>&nbsp;&nbsp;&nbsp; <A href="http://www.kernel.org/pub/linux/utils/util-linux/">http://www.kernel.org/pub/linux/utils/util-linux/</A>