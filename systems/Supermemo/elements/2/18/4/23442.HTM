# Documentation/development-process/6.Followthrough
<P></P>
<P>6: FOLLOWTHROUGH</P>
<P></P>
<P>At this point, you have followed the guidelines given so far and, with the<BR>addition of your own engineering skills, have posted a perfect series of<BR>patches.&nbsp; One of the biggest mistakes that even experienced kernel<BR>developers can make is to conclude that their work is now done.&nbsp; In truth,<BR>posting patches indicates a transition into the next stage of the process,<BR>with, possibly, quite a bit of work yet to be done.</P>
<P>It is a rare patch which is so good at its first posting that there is no<BR>room for improvement.&nbsp; The kernel development process recognizes this fact,<BR>and, as a result, is heavily oriented toward the improvement of posted<BR>code.&nbsp; You, as the author of that code, will be expected to work with the<BR>kernel community to ensure that your code is up to the kernel's quality<BR>standards.&nbsp; A failure to participate in this process is quite likely to<BR>prevent the inclusion of your patches into the mainline.</P>
<P><BR>6.1: WORKING WITH REVIEWERS</P>
<P>A patch of any significance will result in a number of comments from other<BR>developers as they review the code.&nbsp; Working with reviewers can be, for<BR>many developers, the most intimidating part of the kernel development<BR>process.&nbsp; Life can be made much easier, though, if you keep a few things in<BR>mind:</P>
<P>&nbsp;- If you have explained your patch well, reviewers will understand its<BR>&nbsp;&nbsp; value and why you went to the trouble of writing it.&nbsp; But that value<BR>&nbsp;&nbsp; will not keep them from asking a fundamental question: what will it be<BR>&nbsp;&nbsp; like to maintain a kernel with this code in it five or ten years later?<BR>&nbsp;&nbsp; Many of the changes you may be asked to make - from coding style tweaks<BR>&nbsp;&nbsp; to substantial rewrites - come from the understanding that Linux will<BR>&nbsp;&nbsp; still be around and under development a decade from now.</P>
<P>&nbsp;- Code review is hard work, and it is a relatively thankless occupation;<BR>&nbsp;&nbsp; people remember who wrote kernel code, but there is little lasting fame<BR>&nbsp;&nbsp; for those who reviewed it.&nbsp; So reviewers can get grumpy, especially when<BR>&nbsp;&nbsp; they see the same mistakes being made over and over again.&nbsp; If you get a<BR>&nbsp;&nbsp; review which seems angry, insulting, or outright offensive, resist the<BR>&nbsp;&nbsp; impulse to respond in kind.&nbsp; Code review is about the code, not about<BR>&nbsp;&nbsp; the people, and code reviewers are not attacking you personally.</P>
<P>&nbsp;- Similarly, code reviewers are not trying to promote their employers'<BR>&nbsp;&nbsp; agendas at the expense of your own.&nbsp; Kernel developers often expect to<BR>&nbsp;&nbsp; be working on the kernel years from now, but they understand that their<BR>&nbsp;&nbsp; employer could change.&nbsp; They truly are, almost without exception,<BR>&nbsp;&nbsp; working toward the creation of the best kernel they can; they are not<BR>&nbsp;&nbsp; trying to create discomfort for their employers' competitors.</P>
<P>What all of this comes down to is that, when reviewers send you comments,<BR>you need to pay attention to the technical observations that they are<BR>making.&nbsp; Do not let their form of expression or your own pride keep that<BR>from happening.&nbsp; When you get review comments on a patch, take the time to<BR>understand what the reviewer is trying to say.&nbsp; If possible, fix the things<BR>that the reviewer is asking you to fix.&nbsp; And respond back to the reviewer:<BR>thank them, and describe how you will answer their questions.</P>
<P>Note that you do not have to agree with every change suggested by<BR>reviewers.&nbsp; If you believe that the reviewer has misunderstood your code,<BR>explain what is really going on.&nbsp; If you have a technical objection to a<BR>suggested change, describe it and justify your solution to the problem.&nbsp; If<BR>your explanations make sense, the reviewer will accept them.&nbsp; Should your<BR>explanation not prove persuasive, though, especially if others start to<BR>agree with the reviewer, take some time to think things over again.&nbsp; It can<BR>be easy to become blinded by your own solution to a problem to the point<BR>that you don't realize that something is fundamentally wrong or, perhaps,<BR>you're not even solving the right problem.</P>
<P>Andrew Morton has suggested that every review comment which does not result<BR>in a code change should result in an additional code comment instead; that<BR>can help future reviewers avoid the questions which came up the first time<BR>around.</P>
<P>One fatal mistake is to ignore review comments in the hope that they will<BR>go away.&nbsp; They will not go away.&nbsp; If you repost code without having<BR>responded to the comments you got the time before, you're likely to find<BR>that your patches go nowhere.</P>
<P>Speaking of reposting code: please bear in mind that reviewers are not<BR>going to remember all the details of the code you posted the last time<BR>around.&nbsp; So it is always a good idea to remind reviewers of previously<BR>raised issues and how you dealt with them; the patch changelog is a good<BR>place for this kind of information.&nbsp; Reviewers should not have to search<BR>through list archives to familiarize themselves with what was said last<BR>time; if you help them get a running start, they will be in a better mood<BR>when they revisit your code.</P>
<P>What if you've tried to do everything right and things still aren't going<BR>anywhere?&nbsp; Most technical disagreements can be resolved through discussion,<BR>but there are times when somebody simply has to make a decision.&nbsp; If you<BR>honestly believe that this decision is going against you wrongly, you can<BR>always try appealing to a higher power.&nbsp; As of this writing, that higher<BR>power tends to be Andrew Morton.&nbsp; Andrew has a great deal of respect in the<BR>kernel development community; he can often unjam a situation which seems to<BR>be hopelessly blocked.&nbsp; Appealing to Andrew should not be done lightly,<BR>though, and not before all other alternatives have been explored.&nbsp; And bear<BR>in mind, of course, that he may not agree with you either.</P>
<P><BR>6.2: WHAT HAPPENS NEXT</P>
<P>If a patch is considered to be a good thing to add to the kernel, and once<BR>most of the review issues have been resolved, the next step is usually<BR>entry into a subsystem maintainer's tree.&nbsp; How that works varies from one<BR>subsystem to the next; each maintainer has his or her own way of doing<BR>things.&nbsp; In particular, there may be more than one tree - one, perhaps,<BR>dedicated to patches planned for the next merge window, and another for<BR>longer-term work.</P>
<P>For patches applying to areas for which there is no obvious subsystem tree<BR>(memory management patches, for example), the default tree often ends up<BR>being -mm.&nbsp; Patches which affect multiple subsystems can also end up going<BR>through the -mm tree.</P>
<P>Inclusion into a subsystem tree can bring a higher level of visibility to a<BR>patch.&nbsp; Now other developers working with that tree will get the patch by<BR>default.&nbsp; Subsystem trees typically feed linux-next as well, making their<BR>contents visible to the development community as a whole.&nbsp; At this point,<BR>there's a good chance that you will get more comments from a new set of<BR>reviewers; these comments need to be answered as in the previous round.</P>
<P>What may also happen at this point, depending on the nature of your patch,<BR>is that conflicts with work being done by others turn up.&nbsp; In the worst<BR>case, heavy patch conflicts can result in some work being put on the back<BR>burner so that the remaining patches can be worked into shape and merged.<BR>Other times, conflict resolution will involve working with the other<BR>developers and, possibly, moving some patches between trees to ensure that<BR>everything applies cleanly.&nbsp; This work can be a pain, but count your<BR>blessings: before the advent of the linux-next tree, these conflicts often<BR>only turned up during the merge window and had to be addressed in a hurry.<BR>Now they can be resolved at leisure, before the merge window opens.</P>
<P>Some day, if all goes well, you'll log on and see that your patch has been<BR>merged into the mainline kernel.&nbsp; Congratulations!&nbsp; Once the celebration is<BR>complete (and you have added yourself to the MAINTAINERS file), though, it<BR>is worth remembering an important little fact: the job still is not done.<BR>Merging into the mainline brings its own challenges.</P>
<P>To begin with, the visibility of your patch has increased yet again.&nbsp; There<BR>may be a new round of comments from developers who had not been aware of<BR>the patch before.&nbsp; It may be tempting to ignore them, since there is no<BR>longer any question of your code being merged.&nbsp; Resist that temptation,<BR>though; you still need to be responsive to developers who have questions or<BR>suggestions.</P>
<P>More importantly, though: inclusion into the mainline puts your code into<BR>the hands of a much larger group of testers.&nbsp; Even if you have contributed<BR>a driver for hardware which is not yet available, you will be surprised by<BR>how many people will build your code into their kernels.&nbsp; And, of course,<BR>where there are testers, there will be bug reports.</P>
<P>The worst sort of bug reports are regressions.&nbsp; If your patch causes a<BR>regression, you'll find an uncomfortable number of eyes upon you;<BR>regressions need to be fixed as soon as possible.&nbsp; If you are unwilling or<BR>unable to fix the regression (and nobody else does it for you), your patch<BR>will almost certainly be removed during the stabilization period.&nbsp; Beyond<BR>negating all of the work you have done to get your patch into the mainline,<BR>having a patch pulled as the result of a failure to fix a regression could<BR>well make it harder for you to get work merged in the future.</P>
<P>After any regressions have been dealt with, there may be other, ordinary<BR>bugs to deal with.&nbsp; The stabilization period is your best opportunity to<BR>fix these bugs and ensure that your code's debut in a mainline kernel<BR>release is as solid as possible.&nbsp; So, please, answer bug reports, and fix<BR>the problems if at all possible.&nbsp; That's what the stabilization period is<BR>for; you can start creating cool new patches once any problems with the old<BR>ones have been taken care of.</P>
<P>And don't forget that there are other milestones which may also create bug<BR>reports: the next mainline stable release, when prominent distributors pick<BR>up a version of the kernel containing your patch, etc.&nbsp; Continuing to<BR>respond to these reports is a matter of basic pride in your work.&nbsp; If that<BR>is insufficient motivation, though, it's also worth considering that the<BR>development community remembers developers who lose interest in their code<BR>after it's merged.&nbsp; The next time you post a patch, they will be evaluating<BR>it with the assumption that you will not be around to maintain it<BR>afterward.</P>
<P><BR>6.3: OTHER THINGS THAT CAN HAPPEN</P>
<P>One day, you may open your mail client and see that somebody has mailed you<BR>a patch to your code.&nbsp; That is one of the advantages of having your code<BR>out there in the open, after all.&nbsp; If you agree with the patch, you can<BR>either forward it on to the subsystem maintainer (be sure to include a<BR>proper From: line so that the attribution is correct, and add a signoff of<BR>your own), or send an Acked-by: response back and let the original poster<BR>send it upward.</P>
<P>If you disagree with the patch, send a polite response explaining why.&nbsp; If<BR>possible, tell the author what changes need to be made to make the patch<BR>acceptable to you.&nbsp; There is a certain resistance to merging patches which<BR>are opposed by the author and maintainer of the code, but it only goes so<BR>far.&nbsp; If you are seen as needlessly blocking good work, those patches will<BR>eventually flow around you and get into the mainline anyway.&nbsp; In the Linux<BR>kernel, nobody has absolute veto power over any code.&nbsp; Except maybe Linus.</P>
<P>On very rare occasion, you may see something completely different: another<BR>developer posts a different solution to your problem.&nbsp; At that point,<BR>chances are that one of the two patches will not be merged, and "mine was<BR>here first" is not considered to be a compelling technical argument.&nbsp; If<BR>somebody else's patch displaces yours and gets into the mainline, there is<BR>really only one way to respond: be pleased that your problem got solved and<BR>get on with your work.&nbsp; Having one's work shoved aside in this manner can<BR>be hurtful and discouraging, but the community will remember your reaction<BR>long after they have forgotten whose patch actually got merged.