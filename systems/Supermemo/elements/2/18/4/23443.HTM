# Documentation/development-process/7.AdvancedTopics
<P></P>
<P>7: ADVANCED TOPICS</P>
<P></P>
<P>At this point, hopefully, you have a handle on how the development process<BR>works.&nbsp; There is still more to learn, however!&nbsp; This section will cover a<BR>number of topics which can be helpful for developers wanting to become a<BR>regular part of the Linux kernel development process.</P>
<P>7.1: MANAGING PATCHES WITH GIT</P>
<P>The use of distributed version control for the kernel began in early 2002,<BR>when Linus first started playing with the proprietary BitKeeper<BR>application.&nbsp; While BitKeeper was controversial, the approach to software<BR>version management it embodied most certainly was not.&nbsp; Distributed version<BR>control enabled an immediate acceleration of the kernel development<BR>project.&nbsp; In current times, there are several free alternatives to<BR>BitKeeper.&nbsp; For better or for worse, the kernel project has settled on git<BR>as its tool of choice.</P>
<P>Managing patches with git can make life much easier for the developer,<BR>especially as the volume of those patches grows.&nbsp; Git also has its rough<BR>edges and poses certain hazards; it is a young and powerful tool which is<BR>still being civilized by its developers.&nbsp; This document will not attempt to<BR>teach the reader how to use git; that would be sufficient material for a<BR>long document in its own right.&nbsp; Instead, the focus here will be on how git<BR>fits into the kernel development process in particular.&nbsp; Developers who<BR>wish to come up to speed with git will find more information at:</P>
<P>&nbsp;<A href="http://git-scm.com/">http://git-scm.com/</A></P>
<P>&nbsp;<A href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">http://www.kernel.org/pub/software/scm/git/docs/user-manual.html</A></P>
<P>and on various tutorials found on the web.</P>
<P>The first order of business is to read the above sites and get a solid<BR>understanding of how git works before trying to use it to make patches<BR>available to others.&nbsp; A git-using developer should be able to obtain a copy<BR>of the mainline repository, explore the revision history, commit changes to<BR>the tree, use branches, etc.&nbsp; An understanding of git's tools for the<BR>rewriting of history (such as rebase) is also useful.&nbsp; Git comes with its<BR>own terminology and concepts; a new user of git should know about refs,<BR>remote branches, the index, fast-forward merges, pushes and pulls, detached<BR>heads, etc.&nbsp; It can all be a little intimidating at the outset, but the<BR>concepts are not that hard to grasp with a bit of study.</P>
<P>Using git to generate patches for submission by email can be a good<BR>exercise while coming up to speed.</P>
<P>When you are ready to start putting up git trees for others to look at, you<BR>will, of course, need a server that can be pulled from.&nbsp; Setting up such a<BR>server with git-daemon is relatively straightforward if you have a system<BR>which is accessible to the Internet.&nbsp; Otherwise, free, public hosting sites<BR>(Github, for example) are starting to appear on the net.&nbsp; Established<BR>developers can get an account on kernel.org, but those are not easy to come<BR>by; see <A href="http://kernel.org/faq/">http://kernel.org/faq/</A> for more information.</P>
<P>The normal git workflow involves the use of a lot of branches.&nbsp; Each line<BR>of development can be separated into a separate "topic branch" and<BR>maintained independently.&nbsp; Branches in git are cheap, there is no reason to<BR>not make free use of them.&nbsp; And, in any case, you should not do your<BR>development in any branch which you intend to ask others to pull from.<BR>Publicly-available branches should be created with care; merge in patches<BR>from development branches when they are in complete form and ready to go -<BR>not before.</P>
<P>Git provides some powerful tools which can allow you to rewrite your<BR>development history.&nbsp; An inconvenient patch (one which breaks bisection,<BR>say, or which has some other sort of obvious bug) can be fixed in place or<BR>made to disappear from the history entirely.&nbsp; A patch series can be<BR>rewritten as if it had been written on top of today's mainline, even though<BR>you have been working on it for months.&nbsp; Changes can be transparently<BR>shifted from one branch to another.&nbsp; And so on.&nbsp; Judicious use of git's<BR>ability to revise history can help in the creation of clean patch sets with<BR>fewer problems.</P>
<P>Excessive use of this capability can lead to other problems, though, beyond<BR>a simple obsession for the creation of the perfect project history.<BR>Rewriting history will rewrite the changes contained in that history,<BR>turning a tested (hopefully) kernel tree into an untested one.&nbsp; But, beyond<BR>that, developers cannot easily collaborate if they do not have a shared<BR>view of the project history; if you rewrite history which other developers<BR>have pulled into their repositories, you will make life much more difficult<BR>for those developers.&nbsp; So a simple rule of thumb applies here: history<BR>which has been exported to others should generally be seen as immutable<BR>thereafter.</P>
<P>So, once you push a set of changes to your publicly-available server, those<BR>changes should not be rewritten.&nbsp; Git will attempt to enforce this rule if<BR>you try to push changes which do not result in a fast-forward merge<BR>(i.e. changes which do not share the same history).&nbsp; It is possible to<BR>override this check, and there may be times when it is necessary to rewrite<BR>an exported tree.&nbsp; Moving changesets between trees to avoid conflicts in<BR>linux-next is one example.&nbsp; But such actions should be rare.&nbsp; This is one<BR>of the reasons why development should be done in private branches (which<BR>can be rewritten if necessary) and only moved into public branches when<BR>it's in a reasonably advanced state.</P>
<P>As the mainline (or other tree upon which a set of changes is based)<BR>advances, it is tempting to merge with that tree to stay on the leading<BR>edge.&nbsp; For a private branch, rebasing can be an easy way to keep up with<BR>another tree, but rebasing is not an option once a tree is exported to the<BR>world.&nbsp; Once that happens, a full merge must be done.&nbsp; Merging occasionally<BR>makes good sense, but overly frequent merges can clutter the history<BR>needlessly.&nbsp; Suggested technique in this case is to merge infrequently, and<BR>generally only at specific release points (such as a mainline -rc<BR>release).&nbsp; If you are nervous about specific changes, you can always<BR>perform test merges in a private branch.&nbsp; The git "rerere" tool can be<BR>useful in such situations; it remembers how merge conflicts were resolved<BR>so that you don't have to do the same work twice.</P>
<P>One of the biggest recurring complaints about tools like git is this: the<BR>mass movement of patches from one repository to another makes it easy to<BR>slip in ill-advised changes which go into the mainline below the review<BR>radar.&nbsp; Kernel developers tend to get unhappy when they see that kind of<BR>thing happening; putting up a git tree with unreviewed or off-topic patches<BR>can affect your ability to get trees pulled in the future.&nbsp; Quoting Linus:</P>
<P>&nbsp;You can send me patches, but for me to pull a git patch from you, I<BR>&nbsp;need to know that you know what you're doing, and I need to be able<BR>&nbsp;to trust things *without* then having to go and check every<BR>&nbsp;individual change by hand.</P>
<P>(<A href="http://lwn.net/Articles/224135/">http://lwn.net/Articles/224135/</A>).</P>
<P>To avoid this kind of situation, ensure that all patches within a given<BR>branch stick closely to the associated topic; a "driver fixes" branch<BR>should not be making changes to the core memory management code.&nbsp; And, most<BR>importantly, do not use a git tree to bypass the review process.&nbsp; Post an<BR>occasional summary of the tree to the relevant list, and, when the time is<BR>right, request that the tree be included in linux-next.</P>
<P>If and when others start to send patches for inclusion into your tree,<BR>don't forget to review them.&nbsp; Also ensure that you maintain the correct<BR>authorship information; the git "am" tool does its best in this regard, but<BR>you may have to add a "From:" line to the patch if it has been relayed to<BR>you via a third party.</P>
<P>When requesting a pull, be sure to give all the relevant information: where<BR>your tree is, what branch to pull, and what changes will result from the<BR>pull.&nbsp; The git request-pull command can be helpful in this regard; it will<BR>format the request as other developers expect, and will also check to be<BR>sure that you have remembered to push those changes to the public server.</P>
<P><BR>7.2: REVIEWING PATCHES</P>
<P>Some readers will certainly object to putting this section with "advanced<BR>topics" on the grounds that even beginning kernel developers should be<BR>reviewing patches.&nbsp; It is certainly true that there is no better way to<BR>learn how to program in the kernel environment than by looking at code<BR>posted by others.&nbsp; In addition, reviewers are forever in short supply; by<BR>looking at code you can make a significant contribution to the process as a<BR>whole.</P>
<P>Reviewing code can be an intimidating prospect, especially for a new kernel<BR>developer who may well feel nervous about questioning code - in public -<BR>which has been posted by those with more experience.&nbsp; Even code written by<BR>the most experienced developers can be improved, though.&nbsp; Perhaps the best<BR>piece of advice for reviewers (all reviewers) is this: phrase review<BR>comments as questions rather than criticisms.&nbsp; Asking "how does the lock<BR>get released in this path?" will always work better than stating "the<BR>locking here is wrong."</P>
<P>Different developers will review code from different points of view.&nbsp; Some<BR>are mostly concerned with coding style and whether code lines have trailing<BR>white space.&nbsp; Others will focus primarily on whether the change implemented<BR>by the patch as a whole is a good thing for the kernel or not.&nbsp; Yet others<BR>will check for problematic locking, excessive stack usage, possible<BR>security issues, duplication of code found elsewhere, adequate<BR>documentation, adverse effects on performance, user-space ABI changes, etc.<BR>All types of review, if they lead to better code going into the kernel, are<BR>welcome and worthwhile.</P>
<P><BR>&nbsp;