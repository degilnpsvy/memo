<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>7.5 Where's the Template?</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-template-instantiation-3815></A>C++ templates are the first language feature to require more intelligence from the environment than one usually finds on a UNIX system. Somehow the compiler and linker have to make sure that each template instance occurs exactly once in the executable if it is needed, and not at all otherwise. There are two basic approaches to this problem, which are referred to as the Borland model and the Cfront model.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT>Borland model</DT>
<DD>Borland C++ solved the template instantiation problem by adding the code equivalent of common blocks to their linker; the compiler emits template instances in each translation unit that uses them, and the linker collapses them together. The advantage of this model is that the linker only has to consider the object files themselves; there is no external complexity to worry about. This disadvantage is that compilation time is increased because the template code is being compiled repeatedly. Code written for this model tends to include definitions of all templates in the header file, since they must be seen to be instantiated.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT>Cfront model</DT>
<DD>The AT&amp;T C++ translator, Cfront, solved the template instantiation problem by creating the notion of a template repository, an automatically maintained place where template instances are stored. A more modern version of the repository works as follows: As individual object files are built, the compiler places any template definitions and instantiations encountered in the repository. At link time, the link wrapper adds in the objects in the repository and compiles any needed instances that were not previously emitted. The advantages of this model are more optimal compilation speed and the ability to use the system linker; to implement the Borland model a compiler vendor also needs to replace the linker. The disadvantages are vastly increased complexity, and thus potential for error; for some code this can be just as transparent, but in practice it can been very difficult to build multiple programs in one directory and one program in multiple directories. Code written for this model tends to separate definitions of non-inline member templates into a separate file, which should be compiled separately.</DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">When used with GNU ld version 2.8 or later on an ELF system such as GNU/Linux or Solaris 2, or on Microsoft Windows, G++ supports the Borland model. On other systems, G++ implements neither automatic model.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">You have the following options for dealing with template instantiations:</P>
<OL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" type=1>
<LI><A name=index-frepo-3816></A>Compile your template-using code with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-frepo</SPAN></SAMP>. The compiler generates files with the extension &#8216;<SAMP><SPAN class=samp>.rpo</SPAN></SAMP>&#8217; listing all of the template instantiations used in the corresponding object files that could be instantiated there; the link wrapper, &#8216;<SAMP><SPAN class=samp>collect2</SPAN></SAMP>&#8217;, then updates the &#8216;<SAMP><SPAN class=samp>.rpo</SPAN></SAMP>&#8217; files to tell the compiler where to place those instantiations and rebuild any affected object files. The link-time overhead is negligible after the first pass, as the compiler continues to place the instantiations in the same files.
<P>This is your best option for application code written for the Borland model, as it just works. Code written for the Cfront model needs to be modified so that the template definitions are available at one or more points of instantiation; usually this is as simple as adding<CODE>#include &lt;tmethods.cc&gt;</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>to the end of each template header.</P>
<P>For library code, if you want the library to provide all of the template instantiations it needs, just try to link all of its object files together; the link will fail, but cause the instantiations to be generated as a side effect. Be warned, however, that this may cause conflicts if multiple libraries try to provide the same instantiations. For greater control, use explicit instantiation as described in the next option.</P></LI>
<LI><A name=index-fno-implicit-templates-3817></A>Compile your code with<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-implicit-templates</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to disable the implicit generation of template instances, and explicitly instantiate all the ones you use. This approach requires more knowledge of exactly which instances you need than do the others, but it's less mysterious and allows greater control. You can scatter the explicit instantiations throughout your program, perhaps putting them in the translation units where the instances are used or the translation units that define the templates themselves; you can put all of the explicit instantiations you need into one big file; or you can create small files like<PRE style="FONT-SIZE: smaller" class=smallexample>          #include "Foo.h"
          #include "Foo.cc"
          
          template class Foo&lt;int&gt;;
          template ostream&amp; operator &lt;&lt;
                          (ostream&amp;, const Foo&lt;int&gt;&amp;);
</PRE>
<P class=noindent>for each of the instances you need, and create a template instantiation library from those.</P>
<P>If you are using Cfront-model code, you can probably get away with not using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-implicit-templates</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>when compiling files that don't &#8216;<SAMP><SPAN class=samp>#include</SPAN></SAMP>&#8217; the member template definitions.</P>
<P>If you use one big file to do the instantiations, you may want to compile it without<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fno-implicit-templates</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>so you get all of the instances required by your explicit instantiations (but not by any other files) without having to specify them as well.</P>
<P>The ISO C++ 2011 standard allows forward declaration of explicit instantiations (with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>extern</CODE>). G++ supports explicit instantiation declarations in C++98 mode and has extended the template instantiation syntax to support instantiation of the compiler support data for a template class (i.e. the vtable) without instantiating any of its members (with<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>inline</CODE>), and instantiation of only the static data members of a template class, without the support data or member functions (with (<CODE>static</CODE>):</P><PRE style="FONT-SIZE: smaller" class=smallexample>          extern template int max (int, int);
          inline template class Foo&lt;int&gt;;
          static template class Foo&lt;int&gt;;
</PRE></LI>
<LI>Do nothing. Pretend G++ does implement automatic instantiation management. Code written for the Borland model works fine, but each translation unit contains instances of each of the templates it uses. In a large program, this can lead to an unacceptable amount of code duplication.</LI></OL>