<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>7.7 C++-Specific Variable, Function, and Type Attributes</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Some attributes only make sense for C++ programs.</P>
<DL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<DT><CODE>abi_tag ("</CODE><VAR>tag</VAR><CODE>", ...)</CODE></DT>
<DD><A name=index-g_t_0040code_007babi_005ftag_007d-attribute-3822></A>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>abi_tag</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute can be applied to a function or class declaration. It modifies the mangled name of the function or class to incorporate the tag name, in order to distinguish the function or class from an earlier version with a different ABI; perhaps the class has changed size, or the function has a different return type that is not encoded in the mangled name.
<P>The argument can be a list of strings of arbitrary length. The strings are sorted on output, so the order of the list is unimportant.</P>
<P>A redeclaration of a function or class must not add new ABI tags, since doing so would change the mangled name.</P>
<P>The ABI tags apply to a name, so all instantiations and specializations of a template have the same tags. The attribute will be ignored if applied to an explicit specialization or instantiation.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-Wabi-tag</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>flag enables a warning about a class which does not have all the ABI tags used by its subobjects and virtual functions; for users with code that needs to coexist with an earlier ABI, using this option can help to find all affected types that need to be tagged.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>init_priority (</CODE><VAR>priority</VAR><CODE>)</CODE></DT>
<DD><A name=index-g_t_0040code_007binit_005fpriority_007d-attribute-3823></A>
<P>In Standard C++, objects defined at namespace scope are guaranteed to be initialized in an order in strict accordance with that of their definitions<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>in a given translation unit</EM>. No guarantee is made for initializations across translation units. However, GNU C++ allows users to control the order of initialization of objects defined at namespace scope with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>init_priority</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute by specifying a relative<VAR>priority</VAR>, a constant integral expression currently bounded between 101 and 65535 inclusive. Lower numbers indicate a higher priority.</P>
<P>In the following example,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>A</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>would normally be created before<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>B</CODE>, but the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>init_priority</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>attribute reverses that order:</P><PRE style="FONT-SIZE: smaller" class=smallexample>          Some_Class  A  __attribute__ ((init_priority (2000)));
          Some_Class  B  __attribute__ ((init_priority (543)));
</PRE>
<P class=noindent>Note that the particular values of<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>priority</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>do not matter; only their relative ordering.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></P></DD>
<DT><CODE>java_interface</CODE></DT>
<DD><A name=index-g_t_0040code_007bjava_005finterface_007d-attribute-3824></A>This type attribute informs C++ that the class is a Java interface. It may only be applied to classes declared within an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>extern "Java"</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>block. Calls to methods declared in this interface are dispatched using GCJ's interface table mechanism, instead of regular virtual table dispatch.<SPAN class=Apple-converted-space>&nbsp;</SPAN><BR></DD>
<DT><CODE>warn_unused</CODE></DT>
<DD><A name=index-g_t_0040code_007bwarn_005funused_007d-attribute-3825></A>For C++ types with non-trivial constructors and/or destructors it is impossible for the compiler to determine whether a variable of this type is truly unused if it is not referenced. This type attribute informs the compiler that variables of this type should be warned about if they appear to be unused, just like variables of fundamental types.
<P>This attribute is appropriate for types which just represent a value, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>std::string</CODE>; it is not appropriate for types which control a resource, such as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>std::mutex</CODE>.</P>
<P>This attribute is also accepted in C, but it is unnecessary because C does not have constructors or destructors.</P></DD></DL>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">See also<SPAN class=Apple-converted-space>&nbsp;</SPAN><A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Namespace-Association.html#Namespace-Association">Namespace Association</A>.