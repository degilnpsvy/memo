<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>11.7.3 Temporaries May Vanish Before You Expect</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-temporaries_002c-lifetime-of-3876></A><A name=index-portions-of-temporary-objects_002c-pointers-to-3877></A>It is dangerous to use pointers or references to<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>portions</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>of a temporary object. The compiler may very well delete the object before you expect it to, leaving a pointer to garbage. The most common place where this problem crops up is in classes like string classes, especially ones that define a conversion function to type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>char *</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>const char *</CODE>&#8212;which is one reason why the standard<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>string</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>class requires you to call the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>c_str</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>member function. However, any class that returns a pointer to some internal structure is potentially subject to this problem.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">For example, a program may use a function<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>strfunc</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>that returns<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>string</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>objects, and another function<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>charfunc</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>that operates on pointers to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>char</CODE>:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     string strfunc ();
     void charfunc (const char *);
     
     void
     f ()
     {
       const char *p = strfunc().c_str();
       ...
       charfunc (p);
       ...
       charfunc (p);
     }
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=noindent>In this situation, it may seem reasonable to save a pointer to the C string returned by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>c_str</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>member function and use that rather than call<CODE>c_str</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>repeatedly. However, the temporary string created by the call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>strfunc</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is destroyed after<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>p</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is initialized, at which point<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>p</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is left pointing to freed memory.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Code like this may run successfully under some other compilers, particularly obsolete cfront-based compilers that delete temporaries along with normal local variables. However, the GNU C++ behavior is standard-conforming, so if your program depends on late destruction of temporaries it is not portable.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">The safe way to write such code is to give the temporary a name, which forces it to remain until the end of the scope of the name. For example:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     const string&amp; tmp = strfunc ();
     charfunc (tmp.c_str ());</PRE>