<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>11.7.1 Declare<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>and</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>Define Static Members</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-C_002b_002b-static-data_002c-declaring-and-defining-3869></A><A name=index-static-data-in-C_002b_002b_002c-declaring-and-defining-3870></A><A name=index-declaring-static-data-in-C_002b_002b-3871></A><A name=index-defining-static-data-in-C_002b_002b-3872></A>When a class has static data members, it is not enough to<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>declare</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>the static member; you must also<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM>define</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN>it. For example:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     class Foo
     {
       ...
       void method();
       static int bar;
     };
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">This declaration only establishes that the class<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>has an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>named<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Foo::bar</CODE>, and a member function named<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Foo::method</CODE>. But you still need to define<EM>both</EM><SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>method</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>bar</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>elsewhere. According to the ISO standard, you must supply an initializer in one (and only one) source file, such as:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>     int Foo::bar = 0;
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Other C++ compilers may not correctly implement the standard behavior. As a result, when you switch to<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>g++</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>from one of these compilers, you may discover that a program that appeared to work correctly in fact does not conform to the standard:<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=command>g++</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>reports as undefined symbols any static data members that lack definitions.