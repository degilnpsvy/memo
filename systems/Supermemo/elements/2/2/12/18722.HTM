<H4 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: medium; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=subsection>11.7.2 Name lookup, templates, and accessing members of base classes</H4>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-base-class-members-3873></A><A name=index-two-stage-name-lookup-3874></A><A name=index-dependent-name-lookup-3875></A>The C++ standard prescribes that all names that are not dependent on template parameters are bound to their present definitions when parsing a template function or class.<A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Name-lookup.html#fn-1" name=fnd-1 rel=footnote><SUP>1</SUP></A><SPAN class=Apple-converted-space>&nbsp;</SPAN>Only names that are dependent are looked up at the point of instantiation. For example, consider</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>       void foo(double);
     
       struct A {
         template &lt;typename T&gt;
         void f () {
           foo (1);        // <SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman>1</SPAN>
           int i = N;      // <SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman>2</SPAN>
           T t;
           t.bar();        // <SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman>3</SPAN>
           foo (t);        // <SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman>4</SPAN>
         }
     
         static const int N;
       };
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Here, the names<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>N</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>appear in a context that does not depend on the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>T</CODE>. The compiler will thus require that they are defined in the context of use in the template, not only before the point of instantiation, and will here use<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>::foo(double)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>A::N</CODE>, respectively. In particular, it will convert the integer value to a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>double</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>when passing it to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>::foo(double)</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Conversely,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>bar</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>foo</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in the fourth marked line are used in contexts that do depend on the type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>T</CODE>, so they are only looked up at the point of instantiation, and you can provide declarations for them after declaring the template, but before instantiating it. In particular, if you instantiate<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>A::f&lt;int&gt;</CODE>, the last line will call an overloaded<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>::foo(int)</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if one was provided, even if after the declaration of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>struct A</CODE>.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">This distinction between lookup of dependent and non-dependent names is called two-stage (or dependent) name lookup. G++ implements it since version 3.4.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Two-stage name lookup sometimes leads to situations with behavior different from non-template codes. The most common is probably this:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>       template &lt;typename T&gt; struct Base {
         int i;
       };
     
       template &lt;typename T&gt; struct Derived : public Base&lt;T&gt; {
         int get_i() { return i; }
       };
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>get_i()</CODE>,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>i</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not used in a dependent context, so the compiler will look for a name declared at the enclosing namespace scope (which is the global scope here). It will not look into the base class, since that is dependent and you may declare specializations of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Base</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>even after declaring<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Derived</CODE>, so the compiler can't really know what<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>i</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>would refer to. If there is no global variable<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>i</CODE>, then you will get an error message.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">In order to make it clear that you want the member of the base class, you need to defer lookup until instantiation time, at which the base class is known. For this, you need to access<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>i</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>in a dependent context, by either using<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>this-&gt;i</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(remember that<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>this</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is of type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Derived&lt;T&gt;*</CODE>, so is obviously dependent), or using<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Base&lt;T&gt;::i</CODE>. Alternatively,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Base&lt;T&gt;::i</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>might be brought into scope by a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>using</CODE>-declaration.</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Another, similar example involves calling member functions of a base class:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>       template &lt;typename T&gt; struct Base {
           int f();
       };
     
       template &lt;typename T&gt; struct Derived : Base&lt;T&gt; {
           int g() { return f(); };
       };
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Again, the call to<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>f()</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is not dependent on template arguments (there are no arguments that depend on the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>T</CODE>, and it is also not otherwise specified that the call should be in a dependent context). Thus a global declaration of such a function must be available, since the one in the base class is not visible until instantiation time. The compiler will consequently produce the following error message:</P><PRE style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; LETTER-SPACING: normal; COLOR: rgb(0,0,0); FONT-SIZE: smaller; FONT-WEIGHT: normal; WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=smallexample>       x.cc: In member function `int Derived&lt;T&gt;::g()':
       x.cc:6: error: there are no arguments to `f' that depend on a template
          parameter, so a declaration of `f' must be available
       x.cc:6: error: (if you use `-fpermissive', G++ will accept your code, but
          allowing the use of an undeclared name is deprecated)
</PRE>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">To make the code valid either use<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>this-&gt;f()</CODE>, or<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>Base&lt;T&gt;::f()</CODE>. Using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fpermissive</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>flag will also let the compiler accept the code, by marking all function calls for which no declaration is visible at the time of definition of the template for later lookup at instantiation time, as if it were a dependent call. We do not recommend using<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fpermissive</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>to work around invalid code, and it will also only catch cases where functions in base classes are called, not where variables in base classes are used (as in the example above).</P>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">Note that some compilers (including G++ versions prior to 3.4) get these examples wrong and accept above code without an error. Those compilers do not implement two-stage name lookup correctly.</P>
<DIV style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=footnote>
<HR>

<H4>Footnotes</H4>
<P class=footnote><SMALL>[<A href="https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Name-lookup.html#fnd-1" name=fn-1>1</A>]</SMALL><SPAN class=Apple-converted-space>&nbsp;</SPAN>The C++ standard just uses the term &#8220;dependent&#8221; for names that depend on the type or value of template parameters. This shorter term will also be used in the rest of this section.</P></DIV><BR class=Apple-interchange-newline>