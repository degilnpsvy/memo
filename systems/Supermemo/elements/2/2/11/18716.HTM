<H3 style="LINE-HEIGHT: normal; TEXT-TRANSFORM: none; FONT-VARIANT: normal; FONT-STYLE: normal; TEXT-INDENT: 0px; FONT-FAMILY: Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px" class=section>11.3 Incompatibilities of GCC</H3>
<P style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px"><A name=index-incompatibilities-of-GCC-3836></A><A name=index-traditional-3837></A>There are several noteworthy incompatibilities between GNU C and K&amp;R (non-ISO) versions of C.<A name=index-string-constants-3838></A><A name=index-read-only-strings-3839></A><A name=index-shared-strings-3840></A></P>
<UL style="TEXT-TRANSFORM: none; TEXT-INDENT: 0px; FONT: medium Simsun; WHITE-SPACE: normal; LETTER-SPACING: normal; COLOR: rgb(0,0,0); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px">
<LI>GCC normally makes string constants read-only. If several identical-looking string constants are used, GCC stores only one copy of the string.
<P><A name=index-g_t_0040code_007bmktemp_007d_002c-and-constant-strings-3841></A>One consequence is that you cannot call<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>mktemp</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>with a string constant argument. The function<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>mktemp</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>always alters the string its argument points to.</P>
<P><A name=index-g_t_0040code_007bsscanf_007d_002c-and-constant-strings-3842></A><A name=index-g_t_0040code_007bfscanf_007d_002c-and-constant-strings-3843></A><A name=index-g_t_0040code_007bscanf_007d_002c-and-constant-strings-3844></A>Another consequence is that<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>sscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>does not work on some very old systems when passed a string constant as its format control string or input. This is because<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>sscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>incorrectly tries to write into the string constant. Likewise<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>fscanf</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>scanf</CODE>.</P>
<P>The solution to these problems is to change the program to use<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>char</CODE>-array variables with initialization strings for these purposes instead of string constants.</P></LI>
<LI><CODE>-2147483648</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is positive.
<P>This is because 2147483648 cannot fit in the type<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE>, so (following the ISO C rules) its data type is<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>unsigned long int</CODE>. Negating this value yields 2147483648 again.</P></LI>
<LI>GCC does not substitute macro arguments when they appear inside of string constants. For example, the following macro in GCC<PRE style="FONT-SIZE: smaller" class=smallexample>          #define foo(a) "a"
</PRE>
<P class=noindent>will produce output<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>"a"</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>regardless of what the argument<SPAN class=Apple-converted-space>&nbsp;</SPAN><VAR>a</VAR><SPAN class=Apple-converted-space>&nbsp;</SPAN>is.</P>
<P><A name=index-g_t_0040code_007bsetjmp_007d-incompatibilities-3845></A><A name=index-g_t_0040code_007blongjmp_007d-incompatibilities-3846></A></P></LI>
<LI>When you use<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>setjmp</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>longjmp</CODE>, the only automatic variables guaranteed to remain valid are those declared<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>volatile</CODE>. This is a consequence of automatic register allocation. Consider this function:<PRE style="FONT-SIZE: smaller" class=smallexample>          jmp_buf j;
          
          foo ()
          {
            int a, b;
          
            a = fun1 ();
            if (setjmp (j))
              return a;
          
            a = fun2 ();
            /* <CODE>longjmp (j)</CODE><SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman> may occur in </SPAN><CODE>fun3</CODE><SPAN style="FONT-FAMILY: serif; FONT-WEIGHT: normal" class=roman>.</SPAN> */
            return a + fun3 ();
          }
</PRE>
<P>Here<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>may or may not be restored to its first value when the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>longjmp</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>occurs. If<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>a</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is allocated in a register, then its first value is restored; otherwise, it keeps the last value stored in it.</P>
<P><A name=index-W-3847></A>If you use the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-W</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option with the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-O</SPAN></SAMP><SPAN class=Apple-converted-space>&nbsp;</SPAN>option, you will get a warning when GCC thinks such a problem might be possible.</P></LI>
<LI>Programs that use preprocessing directives in the middle of macro arguments do not work with GCC. For example, a program like this will not work:<PRE style="FONT-SIZE: smaller" class=smallexample>          foobar (
          #define luser
                  hack)
</PRE>
<P>ISO C does not permit such a construct.</P></LI>
<LI>K&amp;R compilers allow comments to cross over an inclusion boundary (i.e. started in an include file and ended in the including file).
<P><A name=index-external-declaration-scope-3848></A><A name=index-scope-of-external-declarations-3849></A><A name=index-declaration-scope-3850></A></P></LI>
<LI>Declarations of external variables and functions within a block apply only to the block containing the declaration. In other words, they have the same scope as any other declaration in the same place.
<P>In some other C compilers, an<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>extern</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>declaration affects all the rest of the file even if it happens within a block.</P></LI>
<LI>In traditional C, you can combine<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>long</CODE>, etc., with a typedef name, as shown here:<PRE style="FONT-SIZE: smaller" class=smallexample>          typedef int foo;
          typedef long foo bar;
</PRE>
<P>In ISO C, this is not allowed:<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>long</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and other type modifiers require an explicit<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>int</CODE>.</P>
<P><A name=index-typedef-names-as-function-parameters-3851></A></P></LI>
<LI>PCC allows typedef names to be used as function parameters.</LI>
<LI>Traditional C allows the following erroneous pair of declarations to appear together in a given scope:<PRE style="FONT-SIZE: smaller" class=smallexample>          typedef int foo;
          typedef foo foo;
</PRE></LI>
<LI>GCC treats all characters of identifiers as significant. According to K&amp;R-1 (2.2), &#8220;No more than the first eight characters are significant, although more may be used.&#8221;. Also according to K&amp;R-1 (2.2), &#8220;An identifier is a sequence of letters and digits; the first character must be a letter. The underscore _ counts as a letter.&#8221;, but GCC also allows dollar signs in identifiers.
<P><A name=index-whitespace-3852></A></P></LI>
<LI>PCC allows whitespace in the middle of compound assignment operators such as &#8216;<SAMP><SPAN class=samp>+=</SPAN></SAMP>&#8217;. GCC, following the ISO standard, does not allow this.
<P><A name=index-apostrophes-3853></A><A name=index-g_t_0040code_007b_0027_007d-3854></A></P></LI>
<LI>GCC complains about unterminated character constants inside of preprocessing conditionals that fail. Some programs have English comments enclosed in conditionals that are guaranteed to fail; if these comments contain apostrophes, GCC will probably report an error. For example, this code would produce an error:<PRE style="FONT-SIZE: smaller" class=smallexample>          #if 0
          You can't expect this to work.
          #endif
</PRE>
<P>The best solution to such a problem is to put the text into an actual C comment delimited by &#8216;<SAMP><SPAN class=samp>/*...*/</SPAN></SAMP>&#8217;.</P></LI>
<LI>Many user programs contain the declaration &#8216;<SAMP><SPAN class=samp>long time ();</SPAN></SAMP>&#8217;. In the past, the system header files on many systems did not actually declare<CODE>time</CODE>, so it did not matter what type your program declared it to return. But in systems with ISO C headers,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>time</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is declared to return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>time_t</CODE>, and if that is not the same as<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>long</CODE>, then &#8216;<SAMP><SPAN class=samp>long time ();</SPAN></SAMP>&#8217; is erroneous.
<P>The solution is to change your program to use appropriate system headers (<CODE>&lt;time.h&gt;</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>on systems with ISO C headers) and not to declare<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>time</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>if the system header files declare it, or failing that to use<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>time_t</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>as the return type of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>time</CODE>.</P>
<P><A name=index-g_t_0040code_007bfloat_007d-as-function-value-type-3855></A></P></LI>
<LI>When compiling functions that return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>float</CODE>, PCC converts it to a double. GCC actually returns a<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>float</CODE>. If you are concerned with PCC compatibility, you should declare your functions to return<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>double</CODE>; you might as well say what you mean.
<P><A name=index-structures-3856></A><A name=index-unions-3857></A></P></LI>
<LI>When compiling functions that return structures or unions, GCC output code normally uses a method different from that used on most versions of Unix. As a result, code compiled with GCC cannot call a structure-returning function compiled with PCC, and vice versa.
<P>The method used by GCC is as follows: a structure or union which is 1, 2, 4 or 8 bytes long is returned like a scalar. A structure or union with any other size is stored into an address supplied by the caller (usually in a special, fixed register, but on some machines it is passed on the stack). The target hook<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE>TARGET_STRUCT_VALUE_RTX</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>tells GCC where to pass this address.</P>
<P>By contrast, PCC on most target machines returns structures and unions of any size by copying the data into an area of static storage, and then returning the address of that storage as if it were a pointer value. The caller must copy the data from that memory area to the place where the value is wanted. GCC does not use this method because it is slower and nonreentrant.</P>
<P>On some newer machines, PCC uses a reentrant convention for all structure and union returning. GCC on most of these machines uses a compatible convention when returning structures and unions in memory, but still returns small structures and unions in registers.</P>
<P><A name=index-fpcc-struct-return-3858></A>You can tell GCC to use a compatible convention for all structure and union returning with the option<SPAN class=Apple-converted-space>&nbsp;</SPAN><SAMP><SPAN class=option>-fpcc-struct-return</SPAN></SAMP>.</P>
<P><A name=index-preprocessing-tokens-3859></A><A name=index-preprocessing-numbers-3860></A></P></LI>
<LI>GCC complains about program fragments such as &#8216;<SAMP><SPAN class=samp>0x74ae-0x4000</SPAN></SAMP>&#8217; which appear to be two hexadecimal constants separated by the minus operator. Actually, this string is a single<SPAN class=Apple-converted-space>&nbsp;</SPAN><DFN>preprocessing token</DFN>. Each such token must correspond to one token in C. Since this does not, GCC prints an error message. Although it may appear obvious that what is meant is an operator and two values, the ISO C standard specifically requires that this be treated as erroneous.
<P>A<SPAN class=Apple-converted-space>&nbsp;</SPAN><DFN>preprocessing token</DFN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a<SPAN class=Apple-converted-space>&nbsp;</SPAN><DFN>preprocessing number</DFN><SPAN class=Apple-converted-space>&nbsp;</SPAN>if it begins with a digit and is followed by letters, underscores, digits, periods and &#8216;<SAMP><SPAN class=samp>e+</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>e-</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>E+</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>E-</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>p+</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>p-</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>P+</SPAN></SAMP>&#8217;, or &#8216;<SAMP><SPAN class=samp>P-</SPAN></SAMP>&#8217; character sequences. (In strict C90 mode, the sequences &#8216;<SAMP><SPAN class=samp>p+</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>p-</SPAN></SAMP>&#8217;, &#8216;<SAMP><SPAN class=samp>P+</SPAN></SAMP>&#8217; and &#8216;<SAMP><SPAN class=samp>P-</SPAN></SAMP>&#8217; cannot appear in preprocessing numbers.)</P>
<P>To make the above program fragment valid, place whitespace in front of the minus sign. This whitespace will end the preprocessing number.</P></LI></UL>