--- 6.7 Commands useful for building a boot image 
<P></P>
<P>&nbsp;Kbuild provides a few macros that are useful when building a<BR>&nbsp;boot image.</P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; if_changed</FONT></P>
<P><FONT class=extract>&nbsp;if_changed is the infrastructure used for the following commands.</FONT></P>
<P><FONT class=extract>&nbsp;Usage:<BR>&nbsp;&nbsp;target: source(s) FORCE<BR>&nbsp;&nbsp;&nbsp;$(call if_changed,ld/objcopy/gzip)</FONT></P>
<P><FONT class=extract>&nbsp;When the rule is evaluated, it is checked to see if any files<BR>&nbsp;need an update, or the command line has changed since the last<BR>&nbsp;invocation. The latter will force a rebuild if any options<BR>&nbsp;to the executable have changed.<BR>&nbsp;Any target that utilises if_changed must be listed in $(targets),<BR>&nbsp;otherwise the command line check will fail, and the target will<BR>&nbsp;always be built.<BR>&nbsp;Assignments to $(targets) are without $(obj)/ prefix.<BR>&nbsp;if_changed may be used in conjunction with custom commands as<BR>&nbsp;defined in 6.8 "Custom kbuild commands".</FONT></P>
<P><FONT class=extract>&nbsp;Note: It is a typical mistake to forget the FORCE prerequisite.<BR>&nbsp;Another common pitfall is that whitespace is sometimes<BR>&nbsp;significant; for instance, the below will fail (note the extra space<BR>&nbsp;after the comma):<BR>&nbsp;&nbsp;target: source(s) FORCE<BR>&nbsp;#WRONG!#&nbsp;$(call if_changed, ld/objcopy/gzip)</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; ld<BR>&nbsp;Link target. Often, LDFLAGS_$@ is used to set specific options to ld.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; objcopy<BR>&nbsp;Copy binary. Uses OBJCOPYFLAGS usually specified in<BR>&nbsp;arch/$(ARCH)/Makefile.<BR>&nbsp;OBJCOPYFLAGS_$@ may be used to set additional options.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; gzip<BR>&nbsp;Compress target. Use maximum compression to compress target.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;#arch/x86/boot/Makefile<BR>&nbsp;&nbsp;LDFLAGS_bootsect := -Ttext 0x0 -s --oformat binary<BR>&nbsp;&nbsp;LDFLAGS_setup&nbsp;&nbsp;&nbsp; := -Ttext 0x0 -s --oformat binary -e begtext</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;targets += setup setup.o bootsect bootsect.o<BR>&nbsp;&nbsp;$(obj)/setup $(obj)/bootsect: %: %.o FORCE<BR>&nbsp;&nbsp;&nbsp;$(call if_changed,ld)</FONT></P>
<P><FONT class=extract>&nbsp;In this example, there are two possible targets, requiring different<BR>&nbsp;options to the linker. The linker options are specified using the<BR>&nbsp;LDFLAGS_$@ syntax - one for each potential target.<BR>&nbsp;$(targets) are assigned all potential targets, by which kbuild knows<BR>&nbsp;the targets and will:<BR>&nbsp;&nbsp;1) check for commandline changes<BR>&nbsp;&nbsp;2) delete target during make clean</FONT></P>
<P><FONT class=extract>&nbsp;The ": %: %.o" part of the prerequisite is a shorthand that<BR>&nbsp;free us from listing the setup.o and bootsect.o files.<BR>&nbsp;Note: It is a common mistake to forget the "target :=" assignment,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resulting in the target file being recompiled for no<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obvious reason.</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; dtc<BR>&nbsp;Create flattened device tree blob object suitable for linking<BR>&nbsp;into vmlinux. Device tree blobs linked into vmlinux are placed<BR>&nbsp;in an init section in the image. Platform code *must* copy the<BR>&nbsp;blob to non-init memory prior to calling unflatten_device_tree().</FONT></P>
<P><FONT class=extract>&nbsp;To use this command, simply add *.dtb into obj-y or targets, or make<BR>&nbsp;some other target depend on %.dtb</FONT></P>
<P><FONT class=extract>&nbsp;A central rule exists to create $(obj)/%.dtb from $(src)/%.dts;<BR>&nbsp;architecture Makefiles do no need to explicitly write out that rule.</FONT></P>
<P><FONT class=extract>&nbsp;Example:<BR>&nbsp;&nbsp;targets += $(dtb-y)<BR>&nbsp;&nbsp;clean-files += *.dtb<BR>&nbsp;&nbsp;DTC_FLAGS ?= -p 1024</FONT></P>
<P><FONT class=extract>&nbsp;&nbsp;&nbsp; dtc_cpp<BR>&nbsp;This is just like dtc as describe above, except that the C pre-<BR>&nbsp;processor is invoked upon the .dtsp file before compiling the result<BR>&nbsp;with dtc.</FONT></P>
<P><FONT class=extract>&nbsp;In order for build dependencies to work, all files compiled using<BR>&nbsp;dtc_cpp must use the C pre-processor's #include functionality and not<BR>&nbsp;dtc's /include/ functionality.</FONT></P>
<P><FONT class=extract>&nbsp;Using the C pre-processor allows use of #define to create named<BR>&nbsp;constants. In turn, the #defines will typically appear in a header<BR>&nbsp;file, which may be shared with regular C code. Since the dtc language<BR>&nbsp;represents a data structure rather than code in C syntax, similar<BR>&nbsp;restrictions are placed on a header file included by a device tree<BR>&nbsp;file as for a header file included by an assembly language file.<BR>&nbsp;In particular, the C pre-processor is passed -x assembler-with-cpp,<BR>&nbsp;which sets macro __ASSEMBLY__. __DTS__ is also set. These allow header<BR>&nbsp;files to restrict their content to that compatible with device tree<BR>&nbsp;source.</FONT></P>
<P><FONT class=extract>&nbsp;A central rule exists to create $(obj)/%.dtb from $(src)/%.dtsp;<BR>&nbsp;architecture Makefiles do no need to explicitly write out that rule.</FONT>