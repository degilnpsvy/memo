<P class=docText>The driver has to first request the IRQ and associate an interrupt handler with it:</P>
<DIV class=docText><PRE>#define ROLLER_IRQ  7
static irqreturn_t roller_interrupt(int irq, void *dev_id);


if (request_irq(ROLLER_IRQ, roller_interrupt, IRQF_DISABLED |
                IRQF_TRIGGER_RISING, "roll", NULL)) {
  printk(KERN_ERR "Roll: Can't register IRQ %d\n", ROLLER_IRQ);
  return -EIO;
}</PRE></DIV><BR>
<P class=docText><A name=iddle1892></A><A name=iddle2102></A><A name=iddle2105></A><A name=iddle2430></A><A name=iddle2434></A><A name=iddle2435></A><A name=iddle2475></A><A name=iddle2476></A><A name=iddle2477></A><A name=iddle2478></A><A name=iddle2479></A><A name=iddle2480></A><A name=iddle2486></A><A name=iddle2733></A><A name=iddle3831></A><A name=iddle3832></A><A name="look at"></A>Let's look at the arguments passed to <TT>request_irq()</TT><A name="number is"></A>. The IRQ number is not queried or probed but hard-coded to <TT>ROLLER_IRQ</TT><A name="this simple"></A> in this simple case as per the hardware connection. The second argument, <TT>roller_interrupt()</TT><A name="type of"></A>, is the interrupt handler routine. Its prototype specifies a return type of <TT>irqreturn_t</TT>, which can be <TT>IRQ_HANDLED</TT><A name="successfully or"></A> if the interrupt is handled successfully or <TT>IRQ_NONE</TT><A name="technologies such"></A> if it isn't. The return value assumes more significance for I/O technologies such as PCI, where multiple devices can share the same IRQ.</P>
<P class=docText><FONT class=extract>The <TT>IRQF_DISABLED</TT></FONT><A name="has to"></A><FONT class=extract> flag specifies that this interrupt handler has to be treated as a fast handler, so the kernel has to disable interrupts while invoking the handler.</FONT> <TT><FONT class=extract>IRQF_TRIGGER_RISING</FONT></TT><A name="edge on"></A><FONT class=extract> announces that the roller wheel generates a rising edge on the interrupt line when it wants to signal an interrupt. In other words, the roller wheel is an <SPAN class=docEmphasis>edge-sensitive</SPAN></FONT><A name="devices are"></A><FONT class=extract> device.</FONT> <FONT class=extract>Some devices are instead <SPAN class=docEmphasis>level-sensitive</SPAN></FONT><A name="To flag"></A><FONT class=extract> and keep the interrupt line asserted until the CPU services it. To flag an interrupt as level-sensitive, use the <TT>IRQF_TRIGGER_HIGH</TT></FONT><A name="Other possible"></A><FONT class=extract> flag.</FONT> <FONT class=extract>Other possible values for this argument include <TT>IRQF_SAMPLE_RANDOM</TT> (used in the section, "</FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch05lev1sec6.html#ch05lev1sec6"><FONT class=extract>Pseudo Char Drivers</FONT></A><FONT class=extract>" in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch05.html#ch05"><FONT class=extract>Chapter 5</FONT></A><FONT class=extract>, "Character Drivers")</FONT> and <TT><FONT class=extract>IRQF_SHARED</FONT></TT><A name="that this"></A><FONT class=extract> (used to specify that this IRQ is shared among multiple devices)</FONT>.</P>
<P class=docText><A name="next argument"></A>The next argument, <TT>"roll"</TT><A name="by files"></A>, is used to identify this device in data generated by files such as <SPAN class=docEmphasis>/proc/interrupts.</SPAN> The final parameter, set to <TT>NULL</TT><A name="for shared"></A> in this case, is relevant only for shared interrupt handlers and is used to identify each device sharing the IRQ line.