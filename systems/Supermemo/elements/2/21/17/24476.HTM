<H4 id=title-ID0EI3OM class=docSection2Title>Device Example: Roller Wheel</H4>
<P class=docText><A name="implement an"></A>Now that you have learned the basics of interrupt handling, let's implement an interrupt handler for an example roller wheel device. Roller wheels can be found on some phones and PDAs for easy menu navigation and are capable of three movements: clockwise rotation, anticlockwise rotation, and key-press. Our imaginary roller wheel is wired such that any of these movements interrupt the processor on IRQ 7. Three <A name=iddle2135></A><A name=iddle2157></A><A name=iddle2431></A><A name=iddle2436></A><A name=iddle2440></A><A name=iddle2487></A><A name=iddle3800></A><A name=iddle3834></A><A name=iddle3838></A>low order bits of <SPAN class=docEmphasis>General Purpose I/O</SPAN><A name="connected to"></A> (GPIO) Port D of the processor are connected to the roller device. The waveforms generated on these pins corresponding to different wheel movements are shown in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch04lev1sec2.html#ch04fig03">Figure 4.3</A><A name="decipher the"></A>. The job of the interrupt handler is to decipher the wheel movements by looking at the Port D GPIO data register.</P><A name=ch04fig03></A>
<P>
<CENTER>
<H5 class=docFigureTitle><A name="Sample wave"></A>Figure 4.3. Sample wave forms generated by the roller wheel.</H5>
<P class=docText><IMG border=0 alt="" src="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/images/YTNyaWQ3ODBzOS9jL2VnbXRwNjQ5NWEzMi9yZzE1ZmkwcGdmaS4wLzNoaWc0c2M-.jpg" width=450 height=495></P></CENTER>
<P></P><BR>
<P class=docText><A name="an interrupt"></A><FONT class=extract>The driver has to first request the IRQ and associate an interrupt handler with it:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>#define ROLLER_IRQ  7
static irqreturn_t roller_interrupt(int irq, void *dev_id);


if (request_irq(ROLLER_IRQ, roller_interrupt, IRQF_DISABLED |
                IRQF_TRIGGER_RISING, "roll", NULL)) {
  printk(KERN_ERR "Roll: Can't register IRQ %d\n", ROLLER_IRQ);
  return -EIO;
}</FONT></PRE></DIV><BR>
<P class=docText><A name=iddle1892></A><A name=iddle2102></A><A name=iddle2105></A><A name=iddle2430></A><A name=iddle2434></A><A name=iddle2435></A><A name=iddle2475></A><A name=iddle2476></A><A name=iddle2477></A><A name=iddle2478></A><A name=iddle2479></A><A name=iddle2480></A><A name=iddle2486></A><A name=iddle2733></A><A name=iddle3831></A><A name=iddle3832></A><A name="look at"></A><FONT class=extract>Let's look at the arguments passed to <TT>request_irq()</TT></FONT><A name="number is"></A><FONT class=extract>. The IRQ number is not queried or probed but hard-coded to <TT>ROLLER_IRQ</TT></FONT><A name="this simple"></A><FONT class=extract> in this simple case as per the hardware connection. The second argument, <TT>roller_interrupt()</TT></FONT><A name="type of"></A><FONT class=extract>, is the interrupt handler routine. Its prototype specifies a return type of <TT>irqreturn_t</TT>, which can be <TT>IRQ_HANDLED</TT></FONT><A name="successfully or"></A><FONT class=extract> if the interrupt is handled successfully or <TT>IRQ_NONE</TT></FONT><A name="technologies such"></A><FONT class=extract> if it isn't. The return value assumes more significance for I/O technologies such as PCI, where multiple devices can share the same IRQ.</FONT></P>
<P class=docText><FONT class=extract>The <TT>IRQF_DISABLED</TT></FONT><A name="has to"></A><FONT class=extract> flag specifies that this interrupt handler has to be treated as a fast handler, so the kernel has to disable interrupts while invoking the handler. <TT>IRQF_TRIGGER_RISING</TT></FONT><A name="edge on"></A><FONT class=extract> announces that the roller wheel generates a rising edge on the interrupt line when it wants to signal an interrupt. In other words, the roller wheel is an <SPAN class=docEmphasis>edge-sensitive</SPAN></FONT><A name="devices are"></A><FONT class=extract> device. Some devices are instead <SPAN class=docEmphasis>level-sensitive</SPAN></FONT><A name="To flag"></A><FONT class=extract> and keep the interrupt line asserted until the CPU services it. To flag an interrupt as level-sensitive, use the <TT>IRQF_TRIGGER_HIGH</TT></FONT><A name="Other possible"></A><FONT class=extract> flag. Other possible values for this argument include <TT>IRQF_SAMPLE_RANDOM</TT> (used in the section, "</FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch05lev1sec6.html#ch05lev1sec6"><FONT class=extract>Pseudo Char Drivers</FONT></A><FONT class=extract>" in </FONT><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch05.html#ch05"><FONT class=extract>Chapter 5</FONT></A><FONT class=extract>, "Character Drivers") and <TT>IRQF_SHARED</TT></FONT><A name="that this"></A><FONT class=extract> (used to specify that this IRQ is shared among multiple devices).</FONT></P>
<P class=docText><A name="next argument"></A><FONT class=extract>The next argument, <TT>"roll"</TT></FONT><A name="by files"></A><FONT class=extract>, is used to identify this device in data generated by files such as <SPAN class=docEmphasis>/proc/interrupts.</SPAN> The final parameter, set to <TT>NULL</TT></FONT><A name="for shared"></A><FONT class=extract> in this case, is relevant only for shared interrupt handlers and is used to identify each device sharing the IRQ line.</FONT></P><A name=ch04note01></A>
<DIV class=docNote>
<P>
<P class=docText><A name="the interrupt"></A>Starting with the 2.6.19 kernel, there have been some changes to the interrupt handler interface. Interrupt handlers used to take a third argument (<TT>struct pt_regs *</TT><A name="but this"></A>) that contained a pointer to CPU registers, but this has been removed starting with the 2.6.19 kernel. Also, the <TT>IRQF_xxx</TT> family of interrupt flags replaced the <TT>SA_xxx</TT> family. For example, with earlier kernels, you had to use <TT>SA_INTERRUPT</TT> rather than <TT>IRQF_DISABLED</TT> to mark an interrupt handler as fast.</P>
<P></P></DIV><BR>
<P class=docText><A name="requesting an"></A><FONT class=extract>Driver initialization is not a good place for requesting an IRQ because that can hog that valuable resource even when the device is not in use. So, device drivers usually request the IRQ when the device is opened by an application. Similarly, the IRQ is freed when the application closes the device and not while exiting the driver module. Freeing an IRQ is done as follows:</FONT></P>
<DIV class=docText><PRE><FONT class=extract>free_irq(int irq, void *dev_id);</FONT></PRE></DIV><BR>
<P class=docText><A name=iddle2437></A><A name=iddle3827></A><A name=iddle3835></A><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch04lev1sec2.html#ch04ex01">Listing 4.1</A><A name="the implementation"></A> shows the implementation of the roller interrupt handler. <TT>roller_interrupt()</TT><A name="the final"></A> takes two arguments: the IRQ and the device identifier passed as the final argument to the associated <TT>request_irq()</TT><A name="Look at"></A>. Look at <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch04lev1sec2.html#ch04fig03">Figure 4.3</A><A name="side with"></A> side by side with this listing.</P><A name=ch04ex01></A>
<H5 id=title-ID0E2JPM class=docExampleTitle>Listing 4.1. The Roller Interrupt Handler</H5>
<P>
<TABLE cellSpacing=0 cellPadding=5 border=1>
<TBODY>
<TR>
<TD>
<DIV class=codeSegmentsExpansionLinks>Code View:</DIV><PRE>spinlock_t roller_lock = SPIN_LOCK_UNLOCKED;
static DECLARE_WAIT_QUEUE_HEAD(roller_poll);

static irqreturn_t
roller_interrupt(int irq, void *dev_id)
{
  int i, PA_t, PA_delta_t, movement = 0;

  /* Get the waveforms from bits 0, 1 and 2
     of Port D as shown in Figure 4.3 */
  PA_t = PORTD &amp; 0x07;

  /* Wait until the state of the pins change.
     (Add some timeout to the loop) */
  for (i=0; (PA_t==PA_delta_t); i++){
    PA_delta_t = PORTD &amp; 0x07;
  }

  movement = determine_movement(PA_t, PA_delta_t); /* See below */

  spin_lock(&amp;roller_lock);

  /* Store the wheel movement in a buffer for
     later access by the read()/poll() entry points */
  store_movements(movement);

  spin_unlock(&amp;roller_lock);

  /* Wake up the poll entry point that might have
     gone to sleep, waiting for a wheel movement */
  wake_up_interruptible(&amp;roller_poll);

  return IRQ_HANDLED;
}
int
determine_movement(int PA_t, int PA_delta_t)
{
  switch (PA_t){
    case 0:
      switch (PA_delta_t){
      case 1:
        movement = ANTICLOCKWISE;
        break;
      case 2:
        movement = CLOCKWISE;
        break;
      case 4:
        movement = KEYPRESSED;
        break;
      }
      break;
    case 1:
      switch (PA_delta_t){
      case 3:
        movement = ANTICLOCKWISE;
        break;
      case 0:
        movement = CLOCKWISE;
        break;
      }
      break;
    case 2:
      switch (PA_delta_t){
      case 0:
        movement = ANTICLOCKWISE;
        break;
      case 3:
        movement = CLOCKWISE;
        break;
      }
      break;
    case 3:
      switch (PA_delta_t){
      case 2:
        movement = ANTICLOCKWISE;
        break;
      case 1:
        movement = CLOCKWISE;
        break;
      }
    case 4:
      movement = KEYPRESSED;
      break;
  }
}

					  </PRE><BR></TD></TR></TBODY></TABLE></P>
<P class=docText>&nbsp;</P>
<P class=docText><A name=iddle1802></A><A name=iddle1804></A><A name=iddle1806></A><A name=iddle1984></A><A name=iddle1986></A><A name=iddle2429></A><A name=iddle2441></A><A name=iddle2443></A><A name=iddle2485></A><A name=iddle4078></A><A name=iddle4228></A><A name="entry points"></A>Driver entry points such as <TT>read()</TT> and <TT>poll()</TT> operate in tandem with <TT>roller_interrupt()</TT><A name="any waiting"></A>. For example, when the handler deciphers wheel movement, it wakes up any waiting <TT>poll()</TT><A name="to sleep"></A> threads that may have gone to sleep in response to a <TT>select()</TT><A name=Revisit></A> system call issued by an application such as X Windows. Revisit <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch04lev1sec2.html#ch04ex01">Listing 4.1</A><A name="after learning"></A> and implement the complete roller driver after learning the internals of character drivers in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch05.html#ch05">Chapter 5</A>.</P>
<P class=docText><A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch07lev1sec2.html#ch07ex03">Listing 7.3</A> in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch07.html#ch07">Chapter 7</A>, "Input Drivers," takes advantage of the kernel's <SPAN class=docEmphasis>input</SPAN><A name="roller mouse"></A> interface to convert this roller wheel into a roller mouse.</P>
<P class=docText><A name="this section"></A><FONT class=extract>Let's end this section by introducing some functions that enable and disable interrupts on a particular IRQ. <TT>enable_irq(ROLLER_IRQ)</TT> enables interrupt generation when the roller wheel moves, while <TT>disable_irq(ROLLER_IRQ)</TT> does the reverse. <TT>disable_irq_nosync(ROLLER_IRQ)</TT></FONT><A name="executing instance"></A><FONT class=extract> disables roller interrupts but does not wait for any currently executing instance of <TT>roller_interrupt()</TT></FONT><A name="to return"></A><FONT class=extract> to return. This <TT>nosync</TT> flavor of <TT>disable_irq()</TT></FONT><A name="but can"></A><FONT class=extract> is faster but can potentially cause race conditions. Use this only when you know that there can be no races. An example user of <TT>disable_irq_nosync()</TT> is <SPAN class=docEmphasis>drivers/ide/ide-io.c</SPAN></FONT><A name="blocks interrupts"></A><FONT class=extract>, which blocks interrupts during initialization, because some systems have trouble with that.</FONT>