<P class=docText>Here is a list of do's and don'ts for code executing in interrupt context:</P>
<DIV style="FONT-WEIGHT: bold">
<OL class=docList type=1>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="context code"></A><FONT class=extract>It's a jailable offense if your interrupt context code goes to sleep.</FONT> Interrupt handlers cannot relinquish the processor by calling sleepy functions such as <TT>schedule_timeout()</TT><A name="penetrate the"></A>. Before invoking a kernel API from your interrupt handler, penetrate the nested invocation train and ensure that it does not internally trigger a blocking wait. For example, <TT>input_register_device()</TT><A name="harmless from"></A> looks harmless from the surface, but tosses a call to <TT>kmalloc</TT><TT>()</TT> under the hood specifying <TT>GFP_KERNEL</TT> as an argument. As you saw in <A class=docLink href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch02.html#ch02">Chapter 2</A>, "A Peek Inside the Kernel," if your system's free memory dips below a watermark, <TT>kmalloc()</TT><A name="invoke it"></A> sleep-waits for memory to get freed up by the swapper, if you invoke it in this manner.</P></DIV>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="For protecting"></A>For protecting critical sections inside interrupt handlers, you can't use mutexes because they may go to sleep. Use spinlocks instead, and use them only if you must.</P></DIV>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="cannot directly"></A><FONT class=extract>Interrupt handlers cannot directly exchange data with user space because they are not connected to user land via process contexts. This brings us to another reason why interrupt handlers cannot sleep: The scheduler works at the granularity of processes, so if interrupt handlers sleep and are scheduled out, how can they be put back into the run queue?</FONT></P></DIV>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="handlers are"></A>Interrupt handlers are supposed to get out of the way quickly but are expected to get the job done. To circumvent this Catch-22, interrupt handlers usually split their work into two. The slim <SPAN class=docEmphasis>top half</SPAN><A name="has serviced"></A> of the handler flags an acknowledgment claiming that it has serviced the interrupt but, in reality, offloads all the hard work to a fat <SPAN class=docEmphasis>bottom half.</SPAN><A name="is deferred"></A> Execution of the bottom half is deferred to a later point in time when all interrupts are enabled. You will learn to develop bottom halves while discussing <SPAN class=docEmphasis>softirqs</SPAN> and <SPAN class=docEmphasis>tasklets</SPAN> later.</P></DIV>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="an interrupt"></A>You need not design interrupt handlers to be reentrant. When an interrupt handler is running, the corresponding IRQ is disabled until the handler returns. So, unlike process context code, different instances of the same handler will not run simultaneously on multiple processors.</P></DIV>
<LI>
<DIV style="FONT-WEIGHT: normal">
<P class=docList><A name="handlers associated"></A>Interrupt handlers can be interrupted by handlers associated with IRQs that have higher priority. You can prevent this nested interruption by specifically requesting the kernel to treat your interrupt handler as a <SPAN class=docEmphasis>fast</SPAN><A name="the local"></A> handler. <FONT class=extract>Fast handlers run with all interrupts disabled on the local processor.</FONT> Before disabling <A name=iddle1136></A><A name=iddle1139></A><A name=iddle1779></A><A name=iddle2172></A><A name=iddle2322></A><A name=iddle2423></A><A name=iddle2424></A><A name=iddle2427></A><A name=iddle2433></A><A name=iddle2442></A><A name=iddle2445></A><A name=iddle2481></A><A name=iddle2482></A><A name=iddle2488></A><A name=iddle3811></A><A name=iddle3830></A><A name=iddle3833></A><A name=iddle4191></A><A name="or labeling"></A>interrupts or labeling your interrupt handler as fast, be aware that interrupt-off times are bad for system performance. More the interrupt-off times, more is the interrupt latency, or the delay before a generated interrupt is serviced. Interrupt latency is inversely proportional to the real time responsiveness of the system.</P></DIV></LI></OL></DIV>