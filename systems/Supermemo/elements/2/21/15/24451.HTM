include/linux/wait.h 
<P></P>
<P>#ifndef _LINUX_WAIT_H<BR>#define _LINUX_WAIT_H<BR>/*<BR>&nbsp;* Linux wait queue related types and methods<BR>&nbsp;*/<BR>#include &lt;linux/list.h&gt;<BR>#include &lt;linux/stddef.h&gt;<BR>#include &lt;linux/spinlock.h&gt;<BR>#include &lt;asm/current.h&gt;<BR>#include &lt;uapi/linux/wait.h&gt;</P>
<P></P>
<P><FONT class=extract>typedef struct __wait_queue wait_queue_t;<BR>typedef int (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int flags, void *key);<BR>int default_wake_function(wait_queue_t *wait, unsigned mode, int flags, void *key);</FONT></P>
<P><FONT class=extract>/* __wait_queue::flags */<BR>#define WQ_FLAG_EXCLUSIVE&nbsp;0x01<BR>#define WQ_FLAG_WOKEN&nbsp;&nbsp;0x02</FONT></P>
<P><FONT class=extract>struct __wait_queue {<BR>&nbsp;unsigned int&nbsp;&nbsp;flags;<BR>&nbsp;void&nbsp;&nbsp;&nbsp;*private;<BR>&nbsp;wait_queue_func_t&nbsp;func;<BR>&nbsp;struct list_head&nbsp;task_list;<BR>};</FONT></P>
<P><FONT class=extract>struct wait_bit_key {<BR>&nbsp;void&nbsp;&nbsp;&nbsp;*flags;<BR>&nbsp;int&nbsp;&nbsp;&nbsp;bit_nr;<BR>#define WAIT_ATOMIC_T_BIT_NR&nbsp;-1<BR>&nbsp;unsigned long&nbsp;&nbsp;timeout;<BR>};</FONT></P>
<P><FONT class=extract>struct wait_bit_queue {<BR>&nbsp;struct wait_bit_key&nbsp;key;<BR>&nbsp;wait_queue_t&nbsp;&nbsp;wait;<BR>};</FONT></P>
<P><FONT class=extract>struct __wait_queue_head {<BR>&nbsp;spinlock_t&nbsp;&nbsp;lock;<BR>&nbsp;struct list_head&nbsp;task_list;<BR>};<BR>typedef struct __wait_queue_head wait_queue_head_t;</FONT></P>
<P>struct task_struct;</P>
<P>/*<BR>&nbsp;* Macros for declaration and initialisaton of the datatypes<BR>&nbsp;*/</P>
<P><FONT class=extract>#define __WAITQUEUE_INITIALIZER(name, tsk) {&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.private&nbsp;= tsk,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.func&nbsp;&nbsp;= default_wake_function,&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.task_list&nbsp;= { NULL, NULL } }</FONT></P>
<P><FONT class=extract>#define DECLARE_WAITQUEUE(name, tsk)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk)</FONT></P>
<P><FONT class=extract>#define __WAIT_QUEUE_HEAD_INITIALIZER(name) {&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;.lock&nbsp;&nbsp;= __SPIN_LOCK_UNLOCKED(name.lock),&nbsp;&nbsp;\<BR>&nbsp;.task_list&nbsp;= { &amp;(name).task_list, &amp;(name).task_list } }</FONT></P>
<P><FONT class=extract>#define DECLARE_WAIT_QUEUE_HEAD(name) \<BR>&nbsp;wait_queue_head_t name = __WAIT_QUEUE_HEAD_INITIALIZER(name)</FONT></P>
<P>#define __WAIT_BIT_KEY_INITIALIZER(word, bit)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;{ .flags = word, .bit_nr = bit, }</P>
<P>#define __WAIT_ATOMIC_T_KEY_INITIALIZER(p)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;{ .flags = p, .bit_nr = WAIT_ATOMIC_T_BIT_NR, }</P>
<P><FONT class=extract>extern void __init_waitqueue_head(wait_queue_head_t *q, const char *name, struct lock_class_key *);</FONT></P>
<P><FONT class=extract>#define init_waitqueue_head(q)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;static struct lock_class_key __key;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__init_waitqueue_head((q), #q, &amp;__key);&nbsp;\<BR>&nbsp;} while (0)</FONT></P>
<P>#ifdef CONFIG_LOCKDEP<BR># define __WAIT_QUEUE_HEAD_INIT_ONSTACK(name) \<BR>&nbsp;({ init_waitqueue_head(&amp;name); name; })<BR># define DECLARE_WAIT_QUEUE_HEAD_ONSTACK(name) \<BR>&nbsp;wait_queue_head_t name = __WAIT_QUEUE_HEAD_INIT_ONSTACK(name)<BR>#else<BR># define DECLARE_WAIT_QUEUE_HEAD_ONSTACK(name) DECLARE_WAIT_QUEUE_HEAD(name)<BR>#endif</P>
<P><FONT class=extract>static inline void init_waitqueue_entry(wait_queue_t *q, struct task_struct *p)<BR>{<BR>&nbsp;q-&gt;flags&nbsp;= 0;<BR>&nbsp;q-&gt;private&nbsp;= p;<BR>&nbsp;q-&gt;func&nbsp;&nbsp;= default_wake_function;<BR>}</FONT></P>
<P><FONT class=extract>static inline void<BR>init_waitqueue_func_entry(wait_queue_t *q, wait_queue_func_t func)<BR>{<BR>&nbsp;q-&gt;flags&nbsp;= 0;<BR>&nbsp;q-&gt;private&nbsp;= NULL;<BR>&nbsp;q-&gt;func&nbsp;&nbsp;= func;<BR>}</FONT></P>
<P><FONT class=extract>static inline int waitqueue_active(wait_queue_head_t *q)<BR>{<BR>&nbsp;return !list_empty(&amp;q-&gt;task_list);<BR>}</FONT></P>
<P><FONT class=extract>extern void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait);<BR>extern void add_wait_queue_exclusive(wait_queue_head_t *q, wait_queue_t *wait);<BR>extern void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait);</FONT></P>
<P><FONT class=extract>static inline void __add_wait_queue(wait_queue_head_t *head, wait_queue_t *new)<BR>{<BR>&nbsp;list_add(&amp;new-&gt;task_list, &amp;head-&gt;task_list);<BR>}</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Used for wake-one threads:<BR>&nbsp;*/<BR>static inline void<BR>__add_wait_queue_exclusive(wait_queue_head_t *q, wait_queue_t *wait)<BR>{<BR>&nbsp;wait-&gt;flags |= WQ_FLAG_EXCLUSIVE;<BR>&nbsp;__add_wait_queue(q, wait);<BR>}</FONT></P>
<P><FONT class=extract>static inline void __add_wait_queue_tail(wait_queue_head_t *head,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wait_queue_t *new)<BR>{<BR>&nbsp;list_add_tail(&amp;new-&gt;task_list, &amp;head-&gt;task_list);<BR>}</FONT></P>
<P><FONT class=extract>static inline void<BR>__add_wait_queue_tail_exclusive(wait_queue_head_t *q, wait_queue_t *wait)<BR>{<BR>&nbsp;wait-&gt;flags |= WQ_FLAG_EXCLUSIVE;<BR>&nbsp;__add_wait_queue_tail(q, wait);<BR>}</FONT></P>
<P><FONT class=extract>static inline void<BR>__remove_wait_queue(wait_queue_head_t *head, wait_queue_t *old)<BR>{<BR>&nbsp;list_del(&amp;old-&gt;task_list);<BR>}</FONT></P>
<P><FONT class=extract>typedef int wait_bit_action_f(struct wait_bit_key *);<BR>void __wake_up(wait_queue_head_t *q, unsigned int mode, int nr, void *key);<BR>void __wake_up_locked_key(wait_queue_head_t *q, unsigned int mode, void *key);<BR>void __wake_up_sync_key(wait_queue_head_t *q, unsigned int mode, int nr, void *key);<BR>void __wake_up_locked(wait_queue_head_t *q, unsigned int mode, int nr);<BR>void __wake_up_sync(wait_queue_head_t *q, unsigned int mode, int nr);<BR>void __wake_up_bit(wait_queue_head_t *, void *, int);<BR>int __wait_on_bit(wait_queue_head_t *, struct wait_bit_queue *, wait_bit_action_f *, unsigned);<BR>int __wait_on_bit_lock(wait_queue_head_t *, struct wait_bit_queue *, wait_bit_action_f *, unsigned);<BR>void wake_up_bit(void *, int);<BR>void wake_up_atomic_t(atomic_t *);<BR>int out_of_line_wait_on_bit(void *, int, wait_bit_action_f *, unsigned);<BR>int out_of_line_wait_on_bit_timeout(void *, int, wait_bit_action_f *, unsigned, unsigned long);<BR>int out_of_line_wait_on_bit_lock(void *, int, wait_bit_action_f *, unsigned);<BR>int out_of_line_wait_on_atomic_t(atomic_t *, int (*)(atomic_t *), unsigned);<BR>wait_queue_head_t *bit_waitqueue(void *, int);</FONT></P>
<P><FONT class=extract>#define wake_up(x)&nbsp;&nbsp;&nbsp;__wake_up(x, TASK_NORMAL, 1, NULL)<BR>#define wake_up_nr(x, nr)&nbsp;&nbsp;__wake_up(x, TASK_NORMAL, nr, NULL)<BR>#define wake_up_all(x)&nbsp;&nbsp;&nbsp;__wake_up(x, TASK_NORMAL, 0, NULL)<BR>#define wake_up_locked(x)&nbsp;&nbsp;__wake_up_locked((x), TASK_NORMAL, 1)<BR>#define wake_up_all_locked(x)&nbsp;&nbsp;__wake_up_locked((x), TASK_NORMAL, 0)</FONT></P>
<P><FONT class=extract>#define wake_up_interruptible(x)&nbsp;__wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)<BR>#define wake_up_interruptible_nr(x, nr)&nbsp;__wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)<BR>#define wake_up_interruptible_all(x)&nbsp;__wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)<BR>#define wake_up_interruptible_sync(x)&nbsp;__wake_up_sync((x), TASK_INTERRUPTIBLE, 1)</FONT></P>
<P>/*<BR>&nbsp;* Wakeup macros to be used to report events to the targets.<BR>&nbsp;*/<BR>#define wake_up_poll(x, m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__wake_up(x, TASK_NORMAL, 1, (void *) (m))<BR>#define wake_up_locked_poll(x, m)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__wake_up_locked_key((x), TASK_NORMAL, (void *) (m))<BR>#define wake_up_interruptible_poll(x, m)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__wake_up(x, TASK_INTERRUPTIBLE, 1, (void *) (m))<BR>#define wake_up_interruptible_sync_poll(x, m)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__wake_up_sync_key((x), TASK_INTERRUPTIBLE, 1, (void *) (m))</P>
<P>#define ___wait_cond_timeout(condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;bool __cond = (condition);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (__cond &amp;&amp; !__ret)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__cond || !__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>#define ___wait_is_interruptible(state)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;(!__builtin_constant_p(state) ||&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;state == TASK_INTERRUPTIBLE || state == TASK_KILLABLE)&nbsp;\</P>
<P>/*<BR>&nbsp;* The below macro ___wait_event() has an explicit shadow of the __ret<BR>&nbsp;* variable when used from the wait_event_*() macros.<BR>&nbsp;*<BR>&nbsp;* This is so that both can use the ___wait_cond_timeout() construct<BR>&nbsp;* to wrap the condition.<BR>&nbsp;*<BR>&nbsp;* The type inconsistency of the wait_event_*() __ret variable is also<BR>&nbsp;* on purpose; we use long where we can return timeout values and int<BR>&nbsp;* otherwise.<BR>&nbsp;*/</P>
<P>#define ___wait_event(wq, condition, state, exclusive, ret, cmd)&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__label__ __out;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;wait_queue_t __wait;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;long __ret = ret;&nbsp;/* explicit shadow */&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;INIT_LIST_HEAD(&amp;__wait.task_list);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (exclusive)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__wait.flags = WQ_FLAG_EXCLUSIVE;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__wait.flags = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;for (;;) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;long __int = prepare_to_wait_event(&amp;wq, &amp;__wait, state);\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (___wait_is_interruptible(state) &amp;&amp; __int) {&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;__ret = __int;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;if (exclusive) {&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;abort_exclusive_wait(&amp;wq, &amp;__wait,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state, NULL);&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;goto __out;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;cmd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;finish_wait(&amp;wq, &amp;__wait);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>__out:&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>#define __wait_event(wq, condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;(void)___wait_event(wq, condition, TASK_UNINTERRUPTIBLE, 0, 0,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schedule())</P>
<P>/**<BR>&nbsp;* wait_event - sleep until a condition gets true<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_UNINTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true. The @condition is checked each time<BR>&nbsp;* the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*/<BR>#define wait_event(wq, condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;might_sleep();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__wait_event(wq, condition);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>} while (0)</P>
<P>#define __io_wait_event(wq, condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;(void)___wait_event(wq, condition, TASK_UNINTERRUPTIBLE, 0, 0,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; io_schedule())</P>
<P>/*<BR>&nbsp;* io_wait_event() -- like wait_event() but with io_schedule()<BR>&nbsp;*/<BR>#define io_wait_event(wq, condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;might_sleep();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__io_wait_event(wq, condition);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>} while (0)</P>
<P>#define __wait_event_freezable(wq, condition)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;___wait_event(wq, condition, TASK_INTERRUPTIBLE, 0, 0,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schedule(); try_to_freeze())</P>
<P>/**<BR>&nbsp;* wait_event - sleep (or freeze) until a condition gets true<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_INTERRUPTIBLE -- so as not to contribute<BR>&nbsp;* to system load) until the @condition evaluates to true. The<BR>&nbsp;* @condition is checked each time the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*/<BR>#define wait_event_freezable(wq, condition)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;int __ret = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;might_sleep();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!(condition))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = __wait_event_freezable(wq, condition);&nbsp;&nbsp;\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>#define __wait_event_timeout(wq, condition, timeout)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;___wait_event(wq, ___wait_cond_timeout(condition),&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TASK_UNINTERRUPTIBLE, 0, timeout,&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __ret = schedule_timeout(__ret))</P>
<P>/**<BR>&nbsp;* wait_event_timeout - sleep until a condition gets true or a timeout elapses<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;* @timeout: timeout, in jiffies<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_UNINTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true. The @condition is checked each time<BR>&nbsp;* the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* Returns:<BR>&nbsp;* 0 if the @condition evaluated to %false after the @timeout elapsed,<BR>&nbsp;* 1 if the @condition evaluated to %true after the @timeout elapsed,<BR>&nbsp;* or the remaining jiffies (at least 1) if the @condition evaluated<BR>&nbsp;* to %true before the @timeout elapsed.<BR>&nbsp;*/<BR>#define wait_event_timeout(wq, condition, timeout)&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;long __ret = timeout;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;might_sleep();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!___wait_cond_timeout(condition))&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = __wait_event_timeout(wq, condition, timeout);&nbsp;\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>#define __wait_event_freezable_timeout(wq, condition, timeout)&nbsp;&nbsp;\<BR>&nbsp;___wait_event(wq, ___wait_cond_timeout(condition),&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TASK_INTERRUPTIBLE, 0, timeout,&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __ret = schedule_timeout(__ret); try_to_freeze())</P>
<P>/*<BR>&nbsp;* like wait_event_timeout() -- except it uses TASK_INTERRUPTIBLE to avoid<BR>&nbsp;* increasing load and is freezable.<BR>&nbsp;*/<BR>#define wait_event_freezable_timeout(wq, condition, timeout)&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;long __ret = timeout;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;might_sleep();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!___wait_cond_timeout(condition))&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = __wait_event_freezable_timeout(wq, condition, timeout);&nbsp;\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>#define __wait_event_exclusive_cmd(wq, condition, cmd1, cmd2)&nbsp;&nbsp;\<BR>&nbsp;(void)___wait_event(wq, condition, TASK_UNINTERRUPTIBLE, 1, 0,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd1; schedule(); cmd2)<BR>/*<BR>&nbsp;* Just like wait_event_cmd(), except it sets exclusive flag<BR>&nbsp;*/<BR>#define wait_event_exclusive_cmd(wq, condition, cmd1, cmd2)&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__wait_event_exclusive_cmd(wq, condition, cmd1, cmd2);&nbsp;&nbsp;\<BR>} while (0)</P>
<P>#define __wait_event_cmd(wq, condition, cmd1, cmd2)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;(void)___wait_event(wq, condition, TASK_UNINTERRUPTIBLE, 0, 0,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd1; schedule(); cmd2)</P>
<P>/**<BR>&nbsp;* wait_event_cmd - sleep until a condition gets true<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;* @cmd1: the command will be executed before sleep<BR>&nbsp;* @cmd2: the command will be executed after sleep<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_UNINTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true. The @condition is checked each time<BR>&nbsp;* the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*/<BR>#define wait_event_cmd(wq, condition, cmd1, cmd2)&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__wait_event_cmd(wq, condition, cmd1, cmd2);&nbsp;&nbsp;&nbsp;\<BR>} while (0)</P>
<P>#define __wait_event_interruptible(wq, condition)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;___wait_event(wq, condition, TASK_INTERRUPTIBLE, 0, 0,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schedule())</P>
<P>/**<BR>&nbsp;* wait_event_interruptible - sleep until a condition gets true<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_INTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true or a signal is received.<BR>&nbsp;* The @condition is checked each time the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* The function will return -ERESTARTSYS if it was interrupted by a<BR>&nbsp;* signal and 0 if @condition evaluated to true.<BR>&nbsp;*/<BR>#define wait_event_interruptible(wq, condition)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;int __ret = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;might_sleep();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!(condition))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = __wait_event_interruptible(wq, condition);&nbsp;\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>#define __wait_event_interruptible_timeout(wq, condition, timeout)&nbsp;\<BR>&nbsp;___wait_event(wq, ___wait_cond_timeout(condition),&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TASK_INTERRUPTIBLE, 0, timeout,&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __ret = schedule_timeout(__ret))</P>
<P>/**<BR>&nbsp;* wait_event_interruptible_timeout - sleep until a condition gets true or a timeout elapses<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;* @timeout: timeout, in jiffies<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_INTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true or a signal is received.<BR>&nbsp;* The @condition is checked each time the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* Returns:<BR>&nbsp;* 0 if the @condition evaluated to %false after the @timeout elapsed,<BR>&nbsp;* 1 if the @condition evaluated to %true after the @timeout elapsed,<BR>&nbsp;* the remaining jiffies (at least 1) if the @condition evaluated<BR>&nbsp;* to %true before the @timeout elapsed, or -%ERESTARTSYS if it was<BR>&nbsp;* interrupted by a signal.<BR>&nbsp;*/<BR>#define wait_event_interruptible_timeout(wq, condition, timeout)&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;long __ret = timeout;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;might_sleep();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!___wait_cond_timeout(condition))&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = __wait_event_interruptible_timeout(wq,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;condition, timeout);&nbsp;\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>#define __wait_event_hrtimeout(wq, condition, timeout, state)&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;int __ret = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;struct hrtimer_sleeper __t;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;hrtimer_init_on_stack(&amp;__t.timer, CLOCK_MONOTONIC,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRTIMER_MODE_REL);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;hrtimer_init_sleeper(&amp;__t, current);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if ((timeout).tv64 != KTIME_MAX)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;hrtimer_start_range_ns(&amp;__t.timer, timeout,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; current-&gt;timer_slack_ns,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRTIMER_MODE_REL);&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__ret = ___wait_event(wq, condition, state, 0, 0,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (!__t.task) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;__ret = -ETIME;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;schedule());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;hrtimer_cancel(&amp;__t.timer);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;destroy_hrtimer_on_stack(&amp;__t.timer);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>/**<BR>&nbsp;* wait_event_hrtimeout - sleep until a condition gets true or a timeout elapses<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;* @timeout: timeout, as a ktime_t<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_UNINTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true or a signal is received.<BR>&nbsp;* The @condition is checked each time the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* The function returns 0 if @condition became true, or -ETIME if the timeout<BR>&nbsp;* elapsed.<BR>&nbsp;*/<BR>#define wait_event_hrtimeout(wq, condition, timeout)&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;int __ret = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;might_sleep();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!(condition))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = __wait_event_hrtimeout(wq, condition, timeout,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TASK_UNINTERRUPTIBLE);&nbsp;\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>/**<BR>&nbsp;* wait_event_interruptible_hrtimeout - sleep until a condition gets true or a timeout elapses<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;* @timeout: timeout, as a ktime_t<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_INTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true or a signal is received.<BR>&nbsp;* The @condition is checked each time the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* The function returns 0 if @condition became true, -ERESTARTSYS if it was<BR>&nbsp;* interrupted by a signal, or -ETIME if the timeout elapsed.<BR>&nbsp;*/<BR>#define wait_event_interruptible_hrtimeout(wq, condition, timeout)&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;long __ret = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;might_sleep();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!(condition))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = __wait_event_hrtimeout(wq, condition, timeout,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TASK_INTERRUPTIBLE);&nbsp;\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>#define __wait_event_interruptible_exclusive(wq, condition)&nbsp;&nbsp;\<BR>&nbsp;___wait_event(wq, condition, TASK_INTERRUPTIBLE, 1, 0,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schedule())</P>
<P>#define wait_event_interruptible_exclusive(wq, condition)&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;int __ret = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;might_sleep();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!(condition))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = __wait_event_interruptible_exclusive(wq, condition);\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P><BR>#define __wait_event_freezable_exclusive(wq, condition)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;___wait_event(wq, condition, TASK_INTERRUPTIBLE, 1, 0,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;schedule(); try_to_freeze())</P>
<P>#define wait_event_freezable_exclusive(wq, condition)&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;int __ret = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;might_sleep();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!(condition))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = __wait_event_freezable_exclusive(wq, condition);\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P><BR>#define __wait_event_interruptible_locked(wq, condition, exclusive, irq) \<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;int __ret = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;DEFINE_WAIT(__wait);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (exclusive)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__wait.flags |= WQ_FLAG_EXCLUSIVE;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (likely(list_empty(&amp;__wait.task_list)))&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;__add_wait_queue_tail(&amp;(wq), &amp;__wait);&nbsp;&nbsp;\<BR>&nbsp;&nbsp;set_current_state(TASK_INTERRUPTIBLE);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (signal_pending(current)) {&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;__ret = -ERESTARTSYS;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (irq)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;spin_unlock_irq(&amp;(wq).lock);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;spin_unlock(&amp;(wq).lock);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;schedule();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;if (irq)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;spin_lock_irq(&amp;(wq).lock);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;spin_lock(&amp;(wq).lock);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;} while (!(condition));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__remove_wait_queue(&amp;(wq), &amp;__wait);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__set_current_state(TASK_RUNNING);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P><BR>/**<BR>&nbsp;* wait_event_interruptible_locked - sleep until a condition gets true<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_INTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true or a signal is received.<BR>&nbsp;* The @condition is checked each time the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* It must be called with wq.lock being held.&nbsp; This spinlock is<BR>&nbsp;* unlocked while sleeping but @condition testing is done while lock<BR>&nbsp;* is held and when this macro exits the lock is held.<BR>&nbsp;*<BR>&nbsp;* The lock is locked/unlocked using spin_lock()/spin_unlock()<BR>&nbsp;* functions which must match the way they are locked/unlocked outside<BR>&nbsp;* of this macro.<BR>&nbsp;*<BR>&nbsp;* wake_up_locked() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* The function will return -ERESTARTSYS if it was interrupted by a<BR>&nbsp;* signal and 0 if @condition evaluated to true.<BR>&nbsp;*/<BR>#define wait_event_interruptible_locked(wq, condition)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;((condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp; ? 0 : __wait_event_interruptible_locked(wq, condition, 0, 0))</P>
<P>/**<BR>&nbsp;* wait_event_interruptible_locked_irq - sleep until a condition gets true<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_INTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true or a signal is received.<BR>&nbsp;* The @condition is checked each time the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* It must be called with wq.lock being held.&nbsp; This spinlock is<BR>&nbsp;* unlocked while sleeping but @condition testing is done while lock<BR>&nbsp;* is held and when this macro exits the lock is held.<BR>&nbsp;*<BR>&nbsp;* The lock is locked/unlocked using spin_lock_irq()/spin_unlock_irq()<BR>&nbsp;* functions which must match the way they are locked/unlocked outside<BR>&nbsp;* of this macro.<BR>&nbsp;*<BR>&nbsp;* wake_up_locked() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* The function will return -ERESTARTSYS if it was interrupted by a<BR>&nbsp;* signal and 0 if @condition evaluated to true.<BR>&nbsp;*/<BR>#define wait_event_interruptible_locked_irq(wq, condition)&nbsp;&nbsp;\<BR>&nbsp;((condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp; ? 0 : __wait_event_interruptible_locked(wq, condition, 0, 1))</P>
<P>/**<BR>&nbsp;* wait_event_interruptible_exclusive_locked - sleep exclusively until a condition gets true<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_INTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true or a signal is received.<BR>&nbsp;* The @condition is checked each time the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* It must be called with wq.lock being held.&nbsp; This spinlock is<BR>&nbsp;* unlocked while sleeping but @condition testing is done while lock<BR>&nbsp;* is held and when this macro exits the lock is held.<BR>&nbsp;*<BR>&nbsp;* The lock is locked/unlocked using spin_lock()/spin_unlock()<BR>&nbsp;* functions which must match the way they are locked/unlocked outside<BR>&nbsp;* of this macro.<BR>&nbsp;*<BR>&nbsp;* The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag<BR>&nbsp;* set thus when other process waits process on the list if this<BR>&nbsp;* process is awaken further processes are not considered.<BR>&nbsp;*<BR>&nbsp;* wake_up_locked() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* The function will return -ERESTARTSYS if it was interrupted by a<BR>&nbsp;* signal and 0 if @condition evaluated to true.<BR>&nbsp;*/<BR>#define wait_event_interruptible_exclusive_locked(wq, condition)&nbsp;\<BR>&nbsp;((condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp; ? 0 : __wait_event_interruptible_locked(wq, condition, 1, 0))</P>
<P>/**<BR>&nbsp;* wait_event_interruptible_exclusive_locked_irq - sleep until a condition gets true<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_INTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true or a signal is received.<BR>&nbsp;* The @condition is checked each time the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* It must be called with wq.lock being held.&nbsp; This spinlock is<BR>&nbsp;* unlocked while sleeping but @condition testing is done while lock<BR>&nbsp;* is held and when this macro exits the lock is held.<BR>&nbsp;*<BR>&nbsp;* The lock is locked/unlocked using spin_lock_irq()/spin_unlock_irq()<BR>&nbsp;* functions which must match the way they are locked/unlocked outside<BR>&nbsp;* of this macro.<BR>&nbsp;*<BR>&nbsp;* The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag<BR>&nbsp;* set thus when other process waits process on the list if this<BR>&nbsp;* process is awaken further processes are not considered.<BR>&nbsp;*<BR>&nbsp;* wake_up_locked() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* The function will return -ERESTARTSYS if it was interrupted by a<BR>&nbsp;* signal and 0 if @condition evaluated to true.<BR>&nbsp;*/<BR>#define wait_event_interruptible_exclusive_locked_irq(wq, condition)&nbsp;\<BR>&nbsp;((condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp; ? 0 : __wait_event_interruptible_locked(wq, condition, 1, 1))</P>
<P><BR>#define __wait_event_killable(wq, condition)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;___wait_event(wq, condition, TASK_KILLABLE, 0, 0, schedule())</P>
<P>/**<BR>&nbsp;* wait_event_killable - sleep until a condition gets true<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_KILLABLE) until the<BR>&nbsp;* @condition evaluates to true or a signal is received.<BR>&nbsp;* The @condition is checked each time the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* The function will return -ERESTARTSYS if it was interrupted by a<BR>&nbsp;* signal and 0 if @condition evaluated to true.<BR>&nbsp;*/<BR>#define wait_event_killable(wq, condition)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;int __ret = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;might_sleep();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!(condition))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = __wait_event_killable(wq, condition);&nbsp;&nbsp;\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P><BR>#define __wait_event_lock_irq(wq, condition, lock, cmd)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;(void)___wait_event(wq, condition, TASK_UNINTERRUPTIBLE, 0, 0,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock_irq(&amp;lock);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schedule();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_lock_irq(&amp;lock))</P>
<P>/**<BR>&nbsp;* wait_event_lock_irq_cmd - sleep until a condition gets true. The<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condition is checked under the lock. This<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is expected to be called with the lock<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; taken.<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;* @lock: a locked spinlock_t, which will be released before cmd<BR>&nbsp;*&nbsp;&nbsp; and schedule() and reacquired afterwards.<BR>&nbsp;* @cmd: a command which is invoked outside the critical section before<BR>&nbsp;*&nbsp; sleep<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_UNINTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true. The @condition is checked each time<BR>&nbsp;* the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* This is supposed to be called while holding the lock. The lock is<BR>&nbsp;* dropped before invoking the cmd and going to sleep and is reacquired<BR>&nbsp;* afterwards.<BR>&nbsp;*/<BR>#define wait_event_lock_irq_cmd(wq, condition, lock, cmd)&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__wait_event_lock_irq(wq, condition, lock, cmd);&nbsp;&nbsp;\<BR>} while (0)</P>
<P>/**<BR>&nbsp;* wait_event_lock_irq - sleep until a condition gets true. The<BR>&nbsp;*&nbsp;&nbsp;&nbsp; condition is checked under the lock. This<BR>&nbsp;*&nbsp;&nbsp;&nbsp; is expected to be called with the lock<BR>&nbsp;*&nbsp;&nbsp;&nbsp; taken.<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;* @lock: a locked spinlock_t, which will be released before schedule()<BR>&nbsp;*&nbsp;&nbsp; and reacquired afterwards.<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_UNINTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true. The @condition is checked each time<BR>&nbsp;* the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* This is supposed to be called while holding the lock. The lock is<BR>&nbsp;* dropped before going to sleep and is reacquired afterwards.<BR>&nbsp;*/<BR>#define wait_event_lock_irq(wq, condition, lock)&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__wait_event_lock_irq(wq, condition, lock, );&nbsp;&nbsp;&nbsp;\<BR>} while (0)</P>
<P><BR>#define __wait_event_interruptible_lock_irq(wq, condition, lock, cmd)&nbsp;\<BR>&nbsp;___wait_event(wq, condition, TASK_INTERRUPTIBLE, 0, 0,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock_irq(&amp;lock);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schedule();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_lock_irq(&amp;lock))</P>
<P>/**<BR>&nbsp;* wait_event_interruptible_lock_irq_cmd - sleep until a condition gets true.<BR>&nbsp;*&nbsp;&nbsp;The condition is checked under the lock. This is expected to<BR>&nbsp;*&nbsp;&nbsp;be called with the lock taken.<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;* @lock: a locked spinlock_t, which will be released before cmd and<BR>&nbsp;*&nbsp;&nbsp; schedule() and reacquired afterwards.<BR>&nbsp;* @cmd: a command which is invoked outside the critical section before<BR>&nbsp;*&nbsp; sleep<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_INTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true or a signal is received. The @condition is<BR>&nbsp;* checked each time the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* This is supposed to be called while holding the lock. The lock is<BR>&nbsp;* dropped before invoking the cmd and going to sleep and is reacquired<BR>&nbsp;* afterwards.<BR>&nbsp;*<BR>&nbsp;* The macro will return -ERESTARTSYS if it was interrupted by a signal<BR>&nbsp;* and 0 if @condition evaluated to true.<BR>&nbsp;*/<BR>#define wait_event_interruptible_lock_irq_cmd(wq, condition, lock, cmd)&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;int __ret = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!(condition))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = __wait_event_interruptible_lock_irq(wq,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;condition, lock, cmd);&nbsp;\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>/**<BR>&nbsp;* wait_event_interruptible_lock_irq - sleep until a condition gets true.<BR>&nbsp;*&nbsp;&nbsp;The condition is checked under the lock. This is expected<BR>&nbsp;*&nbsp;&nbsp;to be called with the lock taken.<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;* @lock: a locked spinlock_t, which will be released before schedule()<BR>&nbsp;*&nbsp;&nbsp; and reacquired afterwards.<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_INTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true or signal is received. The @condition is<BR>&nbsp;* checked each time the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* This is supposed to be called while holding the lock. The lock is<BR>&nbsp;* dropped before going to sleep and is reacquired afterwards.<BR>&nbsp;*<BR>&nbsp;* The macro will return -ERESTARTSYS if it was interrupted by a signal<BR>&nbsp;* and 0 if @condition evaluated to true.<BR>&nbsp;*/<BR>#define wait_event_interruptible_lock_irq(wq, condition, lock)&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;int __ret = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!(condition))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = __wait_event_interruptible_lock_irq(wq,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;condition, lock,);&nbsp;\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>#define __wait_event_interruptible_lock_irq_timeout(wq, condition,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock, timeout)&nbsp;\<BR>&nbsp;___wait_event(wq, ___wait_cond_timeout(condition),&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TASK_INTERRUPTIBLE, 0, timeout,&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock_irq(&amp;lock);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __ret = schedule_timeout(__ret);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_lock_irq(&amp;lock));</P>
<P>/**<BR>&nbsp;* wait_event_interruptible_lock_irq_timeout - sleep until a condition gets<BR>&nbsp;*&nbsp;&nbsp;true or a timeout elapses. The condition is checked under<BR>&nbsp;*&nbsp;&nbsp;the lock. This is expected to be called with the lock taken.<BR>&nbsp;* @wq: the waitqueue to wait on<BR>&nbsp;* @condition: a C expression for the event to wait for<BR>&nbsp;* @lock: a locked spinlock_t, which will be released before schedule()<BR>&nbsp;*&nbsp;&nbsp; and reacquired afterwards.<BR>&nbsp;* @timeout: timeout, in jiffies<BR>&nbsp;*<BR>&nbsp;* The process is put to sleep (TASK_INTERRUPTIBLE) until the<BR>&nbsp;* @condition evaluates to true or signal is received. The @condition is<BR>&nbsp;* checked each time the waitqueue @wq is woken up.<BR>&nbsp;*<BR>&nbsp;* wake_up() has to be called after changing any variable that could<BR>&nbsp;* change the result of the wait condition.<BR>&nbsp;*<BR>&nbsp;* This is supposed to be called while holding the lock. The lock is<BR>&nbsp;* dropped before going to sleep and is reacquired afterwards.<BR>&nbsp;*<BR>&nbsp;* The function returns 0 if the @timeout elapsed, -ERESTARTSYS if it<BR>&nbsp;* was interrupted by a signal, and the remaining jiffies otherwise<BR>&nbsp;* if the condition evaluated to true before the timeout elapsed.<BR>&nbsp;*/<BR>#define wait_event_interruptible_lock_irq_timeout(wq, condition, lock,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timeout)&nbsp;&nbsp;\<BR>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;long __ret = timeout;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (!___wait_cond_timeout(condition))&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ret = __wait_event_interruptible_lock_irq_timeout(&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wq, condition, lock, timeout);&nbsp;\<BR>&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>})</P>
<P>/*<BR>&nbsp;* Waitqueues which are removed from the waitqueue_head at wakeup time<BR>&nbsp;*/<BR>void prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state);<BR>void prepare_to_wait_exclusive(wait_queue_head_t *q, wait_queue_t *wait, int state);<BR>long prepare_to_wait_event(wait_queue_head_t *q, wait_queue_t *wait, int state);<BR>void finish_wait(wait_queue_head_t *q, wait_queue_t *wait);<BR>void abort_exclusive_wait(wait_queue_head_t *q, wait_queue_t *wait, unsigned int mode, void *key);<BR>long wait_woken(wait_queue_t *wait, unsigned mode, long timeout);<BR>int woken_wake_function(wait_queue_t *wait, unsigned mode, int sync, void *key);<BR>int autoremove_wake_function(wait_queue_t *wait, unsigned mode, int sync, void *key);<BR>int wake_bit_function(wait_queue_t *wait, unsigned mode, int sync, void *key);</P>
<P>#define DEFINE_WAIT_FUNC(name, function)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;wait_queue_t name = {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.private&nbsp;= current,&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.func&nbsp;&nbsp;= function,&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.task_list&nbsp;= LIST_HEAD_INIT((name).task_list),&nbsp;\<BR>&nbsp;}</P>
<P>#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)</P>
<P>#define DEFINE_WAIT_BIT(name, word, bit)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;struct wait_bit_queue name = {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.key = __WAIT_BIT_KEY_INITIALIZER(word, bit),&nbsp;&nbsp;\<BR>&nbsp;&nbsp;.wait&nbsp;= {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;.private&nbsp;= current,&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;.func&nbsp;&nbsp;= wake_bit_function,&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;.task_list&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;LIST_HEAD_INIT((name).wait.task_list),&nbsp;\<BR>&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;}</P>
<P>#define init_wait(wait)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;(wait)-&gt;private = current;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;(wait)-&gt;func = autoremove_wake_function;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;INIT_LIST_HEAD(&amp;(wait)-&gt;task_list);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;(wait)-&gt;flags = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;} while (0)</P>
<P><BR>extern int bit_wait(struct wait_bit_key *);<BR>extern int bit_wait_io(struct wait_bit_key *);<BR>extern int bit_wait_timeout(struct wait_bit_key *);<BR>extern int bit_wait_io_timeout(struct wait_bit_key *);</P>
<P>/**<BR>&nbsp;* wait_on_bit - wait for a bit to be cleared<BR>&nbsp;* @word: the word being waited on, a kernel virtual address<BR>&nbsp;* @bit: the bit of the word being waited on<BR>&nbsp;* @mode: the task state to sleep in<BR>&nbsp;*<BR>&nbsp;* There is a standard hashed waitqueue table for generic use. This<BR>&nbsp;* is the part of the hashtable's accessor API that waits on a bit.<BR>&nbsp;* For instance, if one were to have waiters on a bitflag, one would<BR>&nbsp;* call wait_on_bit() in threads waiting for the bit to clear.<BR>&nbsp;* One uses wait_on_bit() where one is waiting for the bit to clear,<BR>&nbsp;* but has no intention of setting it.<BR>&nbsp;* Returned value will be zero if the bit was cleared, or non-zero<BR>&nbsp;* if the process received a signal and the mode permitted wakeup<BR>&nbsp;* on that signal.<BR>&nbsp;*/<BR>static inline int<BR>wait_on_bit(unsigned long *word, int bit, unsigned mode)<BR>{<BR>&nbsp;might_sleep();<BR>&nbsp;if (!test_bit(bit, word))<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;return out_of_line_wait_on_bit(word, bit,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit_wait,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode);<BR>}</P>
<P>/**<BR>&nbsp;* wait_on_bit_io - wait for a bit to be cleared<BR>&nbsp;* @word: the word being waited on, a kernel virtual address<BR>&nbsp;* @bit: the bit of the word being waited on<BR>&nbsp;* @mode: the task state to sleep in<BR>&nbsp;*<BR>&nbsp;* Use the standard hashed waitqueue table to wait for a bit<BR>&nbsp;* to be cleared.&nbsp; This is similar to wait_on_bit(), but calls<BR>&nbsp;* io_schedule() instead of schedule() for the actual waiting.<BR>&nbsp;*<BR>&nbsp;* Returned value will be zero if the bit was cleared, or non-zero<BR>&nbsp;* if the process received a signal and the mode permitted wakeup<BR>&nbsp;* on that signal.<BR>&nbsp;*/<BR>static inline int<BR>wait_on_bit_io(unsigned long *word, int bit, unsigned mode)<BR>{<BR>&nbsp;might_sleep();<BR>&nbsp;if (!test_bit(bit, word))<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;return out_of_line_wait_on_bit(word, bit,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit_wait_io,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode);<BR>}</P>
<P>/**<BR>&nbsp;* wait_on_bit_timeout - wait for a bit to be cleared or a timeout elapses<BR>&nbsp;* @word: the word being waited on, a kernel virtual address<BR>&nbsp;* @bit: the bit of the word being waited on<BR>&nbsp;* @mode: the task state to sleep in<BR>&nbsp;* @timeout: timeout, in jiffies<BR>&nbsp;*<BR>&nbsp;* Use the standard hashed waitqueue table to wait for a bit<BR>&nbsp;* to be cleared. This is similar to wait_on_bit(), except also takes a<BR>&nbsp;* timeout parameter.<BR>&nbsp;*<BR>&nbsp;* Returned value will be zero if the bit was cleared before the<BR>&nbsp;* @timeout elapsed, or non-zero if the @timeout elapsed or process<BR>&nbsp;* received a signal and the mode permitted wakeup on that signal.<BR>&nbsp;*/<BR>static inline int<BR>wait_on_bit_timeout(unsigned long *word, int bit, unsigned mode,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long timeout)<BR>{<BR>&nbsp;might_sleep();<BR>&nbsp;if (!test_bit(bit, word))<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;return out_of_line_wait_on_bit_timeout(word, bit,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bit_wait_timeout,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode, timeout);<BR>}</P>
<P>/**<BR>&nbsp;* wait_on_bit_action - wait for a bit to be cleared<BR>&nbsp;* @word: the word being waited on, a kernel virtual address<BR>&nbsp;* @bit: the bit of the word being waited on<BR>&nbsp;* @action: the function used to sleep, which may take special actions<BR>&nbsp;* @mode: the task state to sleep in<BR>&nbsp;*<BR>&nbsp;* Use the standard hashed waitqueue table to wait for a bit<BR>&nbsp;* to be cleared, and allow the waiting action to be specified.<BR>&nbsp;* This is like wait_on_bit() but allows fine control of how the waiting<BR>&nbsp;* is done.<BR>&nbsp;*<BR>&nbsp;* Returned value will be zero if the bit was cleared, or non-zero<BR>&nbsp;* if the process received a signal and the mode permitted wakeup<BR>&nbsp;* on that signal.<BR>&nbsp;*/<BR>static inline int<BR>wait_on_bit_action(unsigned long *word, int bit, wait_bit_action_f *action,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned mode)<BR>{<BR>&nbsp;might_sleep();<BR>&nbsp;if (!test_bit(bit, word))<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;return out_of_line_wait_on_bit(word, bit, action, mode);<BR>}</P>
<P>/**<BR>&nbsp;* wait_on_bit_lock - wait for a bit to be cleared, when wanting to set it<BR>&nbsp;* @word: the word being waited on, a kernel virtual address<BR>&nbsp;* @bit: the bit of the word being waited on<BR>&nbsp;* @mode: the task state to sleep in<BR>&nbsp;*<BR>&nbsp;* There is a standard hashed waitqueue table for generic use. This<BR>&nbsp;* is the part of the hashtable's accessor API that waits on a bit<BR>&nbsp;* when one intends to set it, for instance, trying to lock bitflags.<BR>&nbsp;* For instance, if one were to have waiters trying to set bitflag<BR>&nbsp;* and waiting for it to clear before setting it, one would call<BR>&nbsp;* wait_on_bit() in threads waiting to be able to set the bit.<BR>&nbsp;* One uses wait_on_bit_lock() where one is waiting for the bit to<BR>&nbsp;* clear with the intention of setting it, and when done, clearing it.<BR>&nbsp;*<BR>&nbsp;* Returns zero if the bit was (eventually) found to be clear and was<BR>&nbsp;* set.&nbsp; Returns non-zero if a signal was delivered to the process and<BR>&nbsp;* the @mode allows that signal to wake the process.<BR>&nbsp;*/<BR>static inline int<BR>wait_on_bit_lock(unsigned long *word, int bit, unsigned mode)<BR>{<BR>&nbsp;might_sleep();<BR>&nbsp;if (!test_and_set_bit(bit, word))<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;return out_of_line_wait_on_bit_lock(word, bit, bit_wait, mode);<BR>}</P>
<P>/**<BR>&nbsp;* wait_on_bit_lock_io - wait for a bit to be cleared, when wanting to set it<BR>&nbsp;* @word: the word being waited on, a kernel virtual address<BR>&nbsp;* @bit: the bit of the word being waited on<BR>&nbsp;* @mode: the task state to sleep in<BR>&nbsp;*<BR>&nbsp;* Use the standard hashed waitqueue table to wait for a bit<BR>&nbsp;* to be cleared and then to atomically set it.&nbsp; This is similar<BR>&nbsp;* to wait_on_bit(), but calls io_schedule() instead of schedule()<BR>&nbsp;* for the actual waiting.<BR>&nbsp;*<BR>&nbsp;* Returns zero if the bit was (eventually) found to be clear and was<BR>&nbsp;* set.&nbsp; Returns non-zero if a signal was delivered to the process and<BR>&nbsp;* the @mode allows that signal to wake the process.<BR>&nbsp;*/<BR>static inline int<BR>wait_on_bit_lock_io(unsigned long *word, int bit, unsigned mode)<BR>{<BR>&nbsp;might_sleep();<BR>&nbsp;if (!test_and_set_bit(bit, word))<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;return out_of_line_wait_on_bit_lock(word, bit, bit_wait_io, mode);<BR>}</P>
<P>/**<BR>&nbsp;* wait_on_bit_lock_action - wait for a bit to be cleared, when wanting to set it<BR>&nbsp;* @word: the word being waited on, a kernel virtual address<BR>&nbsp;* @bit: the bit of the word being waited on<BR>&nbsp;* @action: the function used to sleep, which may take special actions<BR>&nbsp;* @mode: the task state to sleep in<BR>&nbsp;*<BR>&nbsp;* Use the standard hashed waitqueue table to wait for a bit<BR>&nbsp;* to be cleared and then to set it, and allow the waiting action<BR>&nbsp;* to be specified.<BR>&nbsp;* This is like wait_on_bit() but allows fine control of how the waiting<BR>&nbsp;* is done.<BR>&nbsp;*<BR>&nbsp;* Returns zero if the bit was (eventually) found to be clear and was<BR>&nbsp;* set.&nbsp; Returns non-zero if a signal was delivered to the process and<BR>&nbsp;* the @mode allows that signal to wake the process.<BR>&nbsp;*/<BR>static inline int<BR>wait_on_bit_lock_action(unsigned long *word, int bit, wait_bit_action_f *action,<BR>&nbsp;&nbsp;&nbsp;unsigned mode)<BR>{<BR>&nbsp;might_sleep();<BR>&nbsp;if (!test_and_set_bit(bit, word))<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;return out_of_line_wait_on_bit_lock(word, bit, action, mode);<BR>}</P>
<P>/**<BR>&nbsp;* wait_on_atomic_t - Wait for an atomic_t to become 0<BR>&nbsp;* @val: The atomic value being waited on, a kernel virtual address<BR>&nbsp;* @action: the function used to sleep, which may take special actions<BR>&nbsp;* @mode: the task state to sleep in<BR>&nbsp;*<BR>&nbsp;* Wait for an atomic_t to become 0.&nbsp; We abuse the bit-wait waitqueue table for<BR>&nbsp;* the purpose of getting a waitqueue, but we set the key to a bit number<BR>&nbsp;* outside of the target 'word'.<BR>&nbsp;*/<BR>static inline<BR>int wait_on_atomic_t(atomic_t *val, int (*action)(atomic_t *), unsigned mode)<BR>{<BR>&nbsp;might_sleep();<BR>&nbsp;if (atomic_read(val) == 0)<BR>&nbsp;&nbsp;return 0;<BR>&nbsp;return out_of_line_wait_on_atomic_t(val, action, mode);<BR>}</P>
<P>#endif /* _LINUX_WAIT_H */