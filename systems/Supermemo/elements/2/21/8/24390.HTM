# Linux 4.5-rc6 include/linux/kernel.h 
<P></P>
<P>#ifndef _LINUX_KERNEL_H<BR>#define _LINUX_KERNEL_H</P>
<P></P>
<P><BR>#include &lt;stdarg.h&gt;<BR>#include &lt;linux/linkage.h&gt;<BR>#include &lt;linux/stddef.h&gt;<BR>#include &lt;linux/types.h&gt;<BR>#include &lt;linux/compiler.h&gt;<BR>#include &lt;linux/bitops.h&gt;<BR>#include &lt;linux/log2.h&gt;<BR>#include &lt;linux/typecheck.h&gt;<BR>#include &lt;linux/printk.h&gt;<BR>#include &lt;linux/dynamic_debug.h&gt;<BR>#include &lt;asm/byteorder.h&gt;<BR>#include &lt;uapi/linux/kernel.h&gt;</P>
<P><FONT class=extract>#define USHRT_MAX&nbsp;((u16)(~0U))<BR>#define SHRT_MAX&nbsp;((s16)(USHRT_MAX&gt;&gt;1))<BR>#define SHRT_MIN&nbsp;((s16)(-SHRT_MAX - 1))<BR>#define INT_MAX&nbsp;&nbsp;((int)(~0U&gt;&gt;1))<BR>#define INT_MIN&nbsp;&nbsp;(-INT_MAX - 1)<BR>#define UINT_MAX&nbsp;(~0U)<BR>#define LONG_MAX&nbsp;((long)(~0UL&gt;&gt;1))<BR>#define LONG_MIN&nbsp;(-LONG_MAX - 1)<BR>#define ULONG_MAX&nbsp;(~0UL)<BR>#define LLONG_MAX&nbsp;((long long)(~0ULL&gt;&gt;1))<BR>#define LLONG_MIN&nbsp;(-LLONG_MAX - 1)<BR>#define ULLONG_MAX&nbsp;(~0ULL)<BR>#define SIZE_MAX&nbsp;(~(size_t)0)</FONT></P>
<P><FONT class=extract>#define U8_MAX&nbsp;&nbsp;((u8)~0U)<BR>#define S8_MAX&nbsp;&nbsp;((s8)(U8_MAX&gt;&gt;1))<BR>#define S8_MIN&nbsp;&nbsp;((s8)(-S8_MAX - 1))<BR>#define U16_MAX&nbsp;&nbsp;((u16)~0U)<BR>#define S16_MAX&nbsp;&nbsp;((s16)(U16_MAX&gt;&gt;1))<BR>#define S16_MIN&nbsp;&nbsp;((s16)(-S16_MAX - 1))<BR>#define U32_MAX&nbsp;&nbsp;((u32)~0U)<BR>#define S32_MAX&nbsp;&nbsp;((s32)(U32_MAX&gt;&gt;1))<BR>#define S32_MIN&nbsp;&nbsp;((s32)(-S32_MAX - 1))<BR>#define U64_MAX&nbsp;&nbsp;((u64)~0ULL)<BR>#define S64_MAX&nbsp;&nbsp;((s64)(U64_MAX&gt;&gt;1))<BR>#define S64_MIN&nbsp;&nbsp;((s64)(-S64_MAX - 1))</FONT></P>
<P><FONT class=extract>#define STACK_MAGIC&nbsp;0xdeadbeef</FONT></P>
<P><FONT class=extract>#define REPEAT_BYTE(x)&nbsp;((~0ul / 0xff) * (x))</FONT></P>
<P><FONT class=extract>#define ALIGN(x, a)&nbsp;&nbsp;__ALIGN_KERNEL((x), (a))<BR>#define __ALIGN_MASK(x, mask)&nbsp;__ALIGN_KERNEL_MASK((x), (mask))<BR>#define PTR_ALIGN(p, a)&nbsp;&nbsp;((typeof(p))ALIGN((unsigned long)(p), (a)))<BR>#define IS_ALIGNED(x, a)&nbsp;&nbsp;(((x) &amp; ((typeof(x))(a) - 1)) == 0)</FONT></P>
<P><FONT class=extract>#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* This looks more complex than it should be. But we need to<BR>&nbsp;* get the type for the ~ right in round_down (it needs to be<BR>&nbsp;* as wide as the result!), and we want to evaluate the macro<BR>&nbsp;* arguments just once each.<BR>&nbsp;*/<BR>#define __round_mask(x, y) ((__typeof__(x))((y)-1))<BR>#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)<BR>#define round_down(x, y) ((x) &amp; ~__round_mask(x, y))</FONT></P>
<P><FONT class=extract>#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)-&gt;f))</FONT><BR><FONT class=extract>#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))<BR>#define DIV_ROUND_UP_ULL(ll,d) \<BR>&nbsp;({ unsigned long long _tmp = (ll)+(d)-1; do_div(_tmp, d); _tmp; })</FONT></P>
<P><FONT class=extract>#if BITS_PER_LONG == 32<BR># define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP_ULL(ll, d)<BR>#else<BR># define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP(ll,d)<BR>#endif</FONT></P>
<P><FONT class=extract>/* The `const' in roundup() prevents gcc-3.3 from calling __divdi3 */<BR>#define roundup(x, y) (&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;const typeof(y) __y = y;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;(((x) + (__y - 1)) / __y) * __y;&nbsp;&nbsp;\<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>)<BR>#define rounddown(x, y) (&nbsp;&nbsp;&nbsp;&nbsp;\<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(x) __x = (x);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__x - (__x % (y));&nbsp;&nbsp;&nbsp;&nbsp;\<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>)</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Divide positive or negative dividend by positive divisor and round<BR>&nbsp;* to closest integer. Result is undefined for negative divisors and<BR>&nbsp;* for negative dividends if the divisor variable type is unsigned.<BR>&nbsp;*/<BR>#define DIV_ROUND_CLOSEST(x, divisor)(&nbsp;&nbsp;&nbsp;\<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(x) __x = x;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(divisor) __d = divisor;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;(((typeof(x))-1) &gt; 0 ||&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp; ((typeof(divisor))-1) &gt; 0 || (__x) &gt; 0) ?&nbsp;\<BR>&nbsp;&nbsp;(((__x) + ((__d) / 2)) / (__d)) :&nbsp;\<BR>&nbsp;&nbsp;(((__x) - ((__d) / 2)) / (__d));&nbsp;\<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>)<BR>/*<BR>&nbsp;* Same as above but for u64 dividends. divisor must be a 32-bit<BR>&nbsp;* number.<BR>&nbsp;*/<BR>#define DIV_ROUND_CLOSEST_ULL(x, divisor)(&nbsp;&nbsp;\<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(divisor) __d = divisor;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;unsigned long long _tmp = (x) + (__d) / 2;&nbsp;\<BR>&nbsp;do_div(_tmp, __d);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;_tmp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>)</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Multiplies an integer by a fraction, while avoiding unnecessary<BR>&nbsp;* overflow or loss of precision.<BR>&nbsp;*/<BR>#define mult_frac(x, numer, denom)(&nbsp;&nbsp;&nbsp;\<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(x) quot = (x) / (denom);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(x) rem&nbsp; = (x) % (denom);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;(quot * (numer)) + ((rem * (numer)) / (denom));&nbsp;\<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>)</FONT></P>
<P><BR><FONT class=extract>#define _RET_IP_&nbsp;&nbsp;(unsigned long)__builtin_return_address(0)<BR>#define _THIS_IP_&nbsp; ({ __label__ __here; __here: (unsigned long)&amp;&amp;__here; })</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_LBDAF<BR># include &lt;asm/div64.h&gt;<BR># define sector_div(a, b) do_div(a, b)<BR>#else<BR># define sector_div(n, b)( \<BR>{ \<BR>&nbsp;int _res; \<BR>&nbsp;_res = (n) % (b); \<BR>&nbsp;(n) /= (b); \<BR>&nbsp;_res; \<BR>} \<BR>)<BR>#endif</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* upper_32_bits - return bits 32-63 of a number<BR>&nbsp;* @n: the number we're accessing<BR>&nbsp;*<BR>&nbsp;* A basic shift-right of a 64- or 32-bit quantity.&nbsp; Use this to suppress<BR>&nbsp;* the "right shift count &gt;= width of type" warning when that quantity is<BR>&nbsp;* 32-bits.<BR>&nbsp;*/<BR>#define upper_32_bits(n) ((u32)(((n) &gt;&gt; 16) &gt;&gt; 16))</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* lower_32_bits - return bits 0-31 of a number<BR>&nbsp;* @n: the number we're accessing<BR>&nbsp;*/<BR>#define lower_32_bits(n) ((u32)(n))</FONT></P>
<P><FONT class=extract>struct completion;<BR></FONT><FONT class=extract>struct pt_regs;</FONT><BR><FONT class=extract>struct user;</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_PREEMPT_VOLUNTARY<BR>extern int _cond_resched(void);<BR># define might_resched() _cond_resched()<BR>#else<BR># define might_resched() do { } while (0)<BR>#endif</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_DEBUG_ATOMIC_SLEEP<BR>&nbsp; void ___might_sleep(const char *file, int line, int preempt_offset);<BR>&nbsp; void __might_sleep(const char *file, int line, int preempt_offset);<BR>/**<BR>&nbsp;* might_sleep - annotation for functions that can sleep<BR>&nbsp;*<BR>&nbsp;* this macro will print a stack trace if it is executed in an atomic<BR>&nbsp;* context (spinlock, irq-handler, ...).<BR>&nbsp;*<BR>&nbsp;* This is a useful debugging help to be able to catch problems early and not<BR>&nbsp;* be bitten later when the calling function happens to sleep when it is not<BR>&nbsp;* supposed to.<BR>&nbsp;*/<BR># define might_sleep() \<BR>&nbsp;do { __might_sleep(__FILE__, __LINE__, 0); might_resched(); } while (0)<BR># define sched_annotate_sleep()&nbsp;(current-&gt;task_state_change = 0)<BR>#else<BR>&nbsp; static inline void ___might_sleep(const char *file, int line,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int preempt_offset) { }<BR>&nbsp; static inline void __might_sleep(const char *file, int line,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int preempt_offset) { }<BR># define might_sleep() do { might_resched(); } while (0)<BR># define sched_annotate_sleep() do { } while (0)<BR>#endif</FONT></P>
<P><FONT class=extract>#define might_sleep_if(cond) do { if (cond) might_sleep(); } while (0)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* abs - return absolute value of an argument<BR>&nbsp;* @x: the value.&nbsp; If it is unsigned type, it is converted to signed type first.<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; char is treated as if it was signed (regardless of whether it really is)<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp; but the macro's return type is preserved as char.<BR>&nbsp;*<BR>&nbsp;* Return: an absolute value of x.<BR>&nbsp;*/<BR>#define abs(x)&nbsp;__abs_choose_expr(x, long long,&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__abs_choose_expr(x, long,&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__abs_choose_expr(x, int,&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__abs_choose_expr(x, short,&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__abs_choose_expr(x, char,&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__builtin_choose_expr(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;__builtin_types_compatible_p(typeof(x), char),&nbsp;\<BR>&nbsp;&nbsp;&nbsp;(char)({ signed char __x = (x); __x&lt;0?-__x:__x; }), \<BR>&nbsp;&nbsp;&nbsp;((void)0)))))))</FONT></P>
<P><FONT class=extract>#define __abs_choose_expr(x, type, other) __builtin_choose_expr(&nbsp;\<BR>&nbsp;__builtin_types_compatible_p(typeof(x),&nbsp;&nbsp; signed type) ||&nbsp;\<BR>&nbsp;__builtin_types_compatible_p(typeof(x), unsigned type),&nbsp;&nbsp;\<BR>&nbsp;({ signed type __x = (x); __x &lt; 0 ? -__x : __x; }), other)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* reciprocal_scale - "scale" a value into range [0, ep_ro)<BR>&nbsp;* @val: value<BR>&nbsp;* @ep_ro: right open interval endpoint<BR>&nbsp;*<BR>&nbsp;* Perform a "reciprocal multiplication" in order to "scale" a value into<BR>&nbsp;* range [0, ep_ro), where the upper interval endpoint is right-open.<BR>&nbsp;* This is useful, e.g. for accessing a index of an array containing<BR>&nbsp;* ep_ro elements, for example. Think of it as sort of modulus, only that<BR>&nbsp;* the result isn't that of modulo. ;) Note that if initial input is a<BR>&nbsp;* small value, then result will return 0.<BR>&nbsp;*<BR>&nbsp;* Return: a result based on val in interval [0, ep_ro).<BR>&nbsp;*/<BR>static inline u32 reciprocal_scale(u32 val, u32 ep_ro)<BR>{<BR>&nbsp;return (u32)(((u64) val * ep_ro) &gt;&gt; 32);<BR>}</FONT></P>
<P><FONT class=extract>#if defined(CONFIG_MMU) &amp;&amp; \<BR>&nbsp;(defined(CONFIG_PROVE_LOCKING) || defined(CONFIG_DEBUG_ATOMIC_SLEEP))<BR>#define might_fault() __might_fault(__FILE__, __LINE__)<BR>void __might_fault(const char *file, int line);<BR>#else<BR>static inline void might_fault(void) { }<BR>#endif</FONT></P>
<P><FONT class=extract>extern struct atomic_notifier_head panic_notifier_list;<BR>extern long (*panic_blink)(int state);<BR>__printf(1, 2)<BR>void panic(const char *fmt, ...)<BR>&nbsp;__noreturn __cold;<BR>void nmi_panic_self_stop(struct pt_regs *);<BR>extern void oops_enter(void);<BR>extern void oops_exit(void);<BR>void print_oops_end_marker(void);<BR>extern int oops_may_print(void);<BR>void do_exit(long error_code)<BR>&nbsp;__noreturn;<BR>void complete_and_exit(struct completion *, long)<BR>&nbsp;__noreturn;</FONT></P>
<P><FONT class=extract>/* Internal, do not use. */<BR>int __must_check _kstrtoul(const char *s, unsigned int base, unsigned long *res);<BR>int __must_check _kstrtol(const char *s, unsigned int base, long *res);</FONT></P>
<P><FONT class=extract>int __must_check kstrtoull(const char *s, unsigned int base, unsigned long long *res);<BR>int __must_check kstrtoll(const char *s, unsigned int base, long long *res);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kstrtoul - convert a string to an unsigned long<BR>&nbsp;* @s: The start of the string. The string must be null-terminated, and may also<BR>&nbsp;*&nbsp; include a single newline before its terminating null. The first character<BR>&nbsp;*&nbsp; may also be a plus sign, but not a minus sign.<BR>&nbsp;* @base: The number base to use. The maximum supported base is 16. If base is<BR>&nbsp;*&nbsp; given as 0, then the base of the string is automatically detected with the<BR>&nbsp;*&nbsp; conventional semantics - If it begins with 0x the number will be parsed as a<BR>&nbsp;*&nbsp; hexadecimal (case insensitive), if it otherwise begins with 0, it will be<BR>&nbsp;*&nbsp; parsed as an octal number. Otherwise it will be parsed as a decimal.<BR>&nbsp;* @res: Where to write the result of the conversion on success.<BR>&nbsp;*<BR>&nbsp;* Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.<BR>&nbsp;* Used as a replacement for the obsolete simple_strtoull. Return code must<BR>&nbsp;* be checked.<BR>*/<BR>static inline int __must_check kstrtoul(const char *s, unsigned int base, unsigned long *res)<BR>{<BR>&nbsp;/*<BR>&nbsp; * We want to shortcut function call, but<BR>&nbsp; * __builtin_types_compatible_p(unsigned long, unsigned long long) = 0.<BR>&nbsp; */<BR>&nbsp;if (sizeof(unsigned long) == sizeof(unsigned long long) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; __alignof__(unsigned long) == __alignof__(unsigned long long))<BR>&nbsp;&nbsp;return kstrtoull(s, base, (unsigned long long *)res);<BR>&nbsp;else<BR>&nbsp;&nbsp;return _kstrtoul(s, base, res);<BR>}</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* kstrtol - convert a string to a long<BR>&nbsp;* @s: The start of the string. The string must be null-terminated, and may also<BR>&nbsp;*&nbsp; include a single newline before its terminating null. The first character<BR>&nbsp;*&nbsp; may also be a plus sign or a minus sign.<BR>&nbsp;* @base: The number base to use. The maximum supported base is 16. If base is<BR>&nbsp;*&nbsp; given as 0, then the base of the string is automatically detected with the<BR>&nbsp;*&nbsp; conventional semantics - If it begins with 0x the number will be parsed as a<BR>&nbsp;*&nbsp; hexadecimal (case insensitive), if it otherwise begins with 0, it will be<BR>&nbsp;*&nbsp; parsed as an octal number. Otherwise it will be parsed as a decimal.<BR>&nbsp;* @res: Where to write the result of the conversion on success.<BR>&nbsp;*<BR>&nbsp;* Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.<BR>&nbsp;* Used as a replacement for the obsolete simple_strtoull. Return code must<BR>&nbsp;* be checked.<BR>&nbsp;*/<BR>static inline int __must_check kstrtol(const char *s, unsigned int base, long *res)<BR>{<BR>&nbsp;/*<BR>&nbsp; * We want to shortcut function call, but<BR>&nbsp; * __builtin_types_compatible_p(long, long long) = 0.<BR>&nbsp; */<BR>&nbsp;if (sizeof(long) == sizeof(long long) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp; __alignof__(long) == __alignof__(long long))<BR>&nbsp;&nbsp;return kstrtoll(s, base, (long long *)res);<BR>&nbsp;else<BR>&nbsp;&nbsp;return _kstrtol(s, base, res);<BR>}</FONT></P>
<P><FONT class=extract>int __must_check kstrtouint(const char *s, unsigned int base, unsigned int *res);<BR>int __must_check kstrtoint(const char *s, unsigned int base, int *res);</FONT></P>
<P><FONT class=extract>static inline int __must_check kstrtou64(const char *s, unsigned int base, u64 *res)<BR>{<BR>&nbsp;return kstrtoull(s, base, res);<BR>}</FONT></P>
<P><FONT class=extract>static inline int __must_check kstrtos64(const char *s, unsigned int base, s64 *res)<BR>{<BR>&nbsp;return kstrtoll(s, base, res);<BR>}</FONT></P>
<P><FONT class=extract>static inline int __must_check kstrtou32(const char *s, unsigned int base, u32 *res)<BR>{<BR>&nbsp;return kstrtouint(s, base, res);<BR>}</FONT></P>
<P><FONT class=extract>static inline int __must_check kstrtos32(const char *s, unsigned int base, s32 *res)<BR>{<BR>&nbsp;return kstrtoint(s, base, res);<BR>}</FONT></P>
<P><FONT class=extract>int __must_check kstrtou16(const char *s, unsigned int base, u16 *res);<BR>int __must_check kstrtos16(const char *s, unsigned int base, s16 *res);<BR>int __must_check kstrtou8(const char *s, unsigned int base, u8 *res);<BR>int __must_check kstrtos8(const char *s, unsigned int base, s8 *res);</FONT></P>
<P><FONT class=extract>int __must_check kstrtoull_from_user(const char __user *s, size_t count, unsigned int base, unsigned long long *res);<BR>int __must_check kstrtoll_from_user(const char __user *s, size_t count, unsigned int base, long long *res);<BR>int __must_check kstrtoul_from_user(const char __user *s, size_t count, unsigned int base, unsigned long *res);<BR>int __must_check kstrtol_from_user(const char __user *s, size_t count, unsigned int base, long *res);<BR>int __must_check kstrtouint_from_user(const char __user *s, size_t count, unsigned int base, unsigned int *res);<BR>int __must_check kstrtoint_from_user(const char __user *s, size_t count, unsigned int base, int *res);<BR>int __must_check kstrtou16_from_user(const char __user *s, size_t count, unsigned int base, u16 *res);<BR>int __must_check kstrtos16_from_user(const char __user *s, size_t count, unsigned int base, s16 *res);<BR>int __must_check kstrtou8_from_user(const char __user *s, size_t count, unsigned int base, u8 *res);<BR>int __must_check kstrtos8_from_user(const char __user *s, size_t count, unsigned int base, s8 *res);</FONT></P>
<P><FONT class=extract>static inline int __must_check kstrtou64_from_user(const char __user *s, size_t count, unsigned int base, u64 *res)<BR>{<BR>&nbsp;return kstrtoull_from_user(s, count, base, res);<BR>}</FONT></P>
<P><FONT class=extract>static inline int __must_check kstrtos64_from_user(const char __user *s, size_t count, unsigned int base, s64 *res)<BR>{<BR>&nbsp;return kstrtoll_from_user(s, count, base, res);<BR>}</FONT></P>
<P><FONT class=extract>static inline int __must_check kstrtou32_from_user(const char __user *s, size_t count, unsigned int base, u32 *res)<BR>{<BR>&nbsp;return kstrtouint_from_user(s, count, base, res);<BR>}</FONT></P>
<P><FONT class=extract>static inline int __must_check kstrtos32_from_user(const char __user *s, size_t count, unsigned int base, s32 *res)<BR>{<BR>&nbsp;return kstrtoint_from_user(s, count, base, res);<BR>}</FONT></P>
<P><FONT class=extract>/* Obsolete, do not use.&nbsp; Use kstrto&lt;foo&gt; instead */</FONT></P>
<P><FONT class=extract>extern unsigned long simple_strtoul(const char *,char **,unsigned int);<BR>extern long simple_strtol(const char *,char **,unsigned int);<BR>extern unsigned long long simple_strtoull(const char *,char **,unsigned int);<BR>extern long long simple_strtoll(const char *,char **,unsigned int);</FONT></P>
<P><FONT class=extract>extern int num_to_str(char *buf, int size, unsigned long long num);</FONT></P>
<P><FONT class=extract>/* lib/printf utilities */</FONT></P>
<P><FONT class=extract>extern __printf(2, 3) int sprintf(char *buf, const char * fmt, ...);<BR>extern __printf(2, 0) int vsprintf(char *buf, const char *, va_list);<BR>extern __printf(3, 4)<BR>int snprintf(char *buf, size_t size, const char *fmt, ...);<BR>extern __printf(3, 0)<BR>int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);<BR>extern __printf(3, 4)<BR>int scnprintf(char *buf, size_t size, const char *fmt, ...);<BR>extern __printf(3, 0)<BR>int vscnprintf(char *buf, size_t size, const char *fmt, va_list args);<BR>extern __printf(2, 3)<BR>char *kasprintf(gfp_t gfp, const char *fmt, ...);<BR>extern __printf(2, 0)<BR>char *kvasprintf(gfp_t gfp, const char *fmt, va_list args);<BR>extern __printf(2, 0)<BR>const char *kvasprintf_const(gfp_t gfp, const char *fmt, va_list args);</FONT></P>
<P><FONT class=extract>extern __scanf(2, 3)<BR>int sscanf(const char *, const char *, ...);<BR>extern __scanf(2, 0)<BR>int vsscanf(const char *, const char *, va_list);</FONT></P>
<P><FONT class=extract>extern int get_option(char **str, int *pint);<BR>extern char *get_options(const char *str, int nints, int *ints);<BR>extern unsigned long long memparse(const char *ptr, char **retptr);<BR>extern bool parse_option_str(const char *str, const char *option);</FONT></P>
<P><FONT class=extract>extern int core_kernel_text(unsigned long addr);<BR>extern int core_kernel_data(unsigned long addr);<BR>extern int __kernel_text_address(unsigned long addr);<BR>extern int kernel_text_address(unsigned long addr);<BR>extern int func_ptr_is_kernel_text(void *ptr);</FONT></P>
<P><FONT class=extract>unsigned long int_sqrt(unsigned long);</FONT></P>
<P><FONT class=extract>extern void bust_spinlocks(int yes);<BR>extern int oops_in_progress;&nbsp;&nbsp;/* If set, an oops, panic(), BUG() or die() is in progress */<BR>extern int panic_timeout;<BR>extern int panic_on_oops;<BR>extern int panic_on_unrecovered_nmi;<BR>extern int panic_on_io_nmi;<BR>extern int panic_on_warn;<BR>extern int sysctl_panic_on_stackoverflow;</FONT></P>
<P><FONT class=extract>extern bool crash_kexec_post_notifiers;</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* panic_cpu is used for synchronizing panic() and crash_kexec() execution. It<BR>&nbsp;* holds a CPU number which is executing panic() currently. A value of<BR>&nbsp;* PANIC_CPU_INVALID means no CPU has entered panic() or crash_kexec().<BR>&nbsp;*/<BR>extern atomic_t panic_cpu;<BR>#define PANIC_CPU_INVALID&nbsp;-1</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* A variant of panic() called from NMI context. We return if we've already<BR>&nbsp;* panicked on this CPU. If another CPU already panicked, loop in<BR>&nbsp;* nmi_panic_self_stop() which can provide architecture dependent code such<BR>&nbsp;* as saving register state for crash dump.<BR>&nbsp;*/<BR>#define nmi_panic(regs, fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;int old_cpu, cpu;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;cpu = raw_smp_processor_id();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;old_cpu = atomic_cmpxchg(&amp;panic_cpu, PANIC_CPU_INVALID, cpu);&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (old_cpu == PANIC_CPU_INVALID)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;panic(fmt, ##__VA_ARGS__);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;else if (old_cpu != cpu)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;nmi_panic_self_stop(regs);&nbsp;&nbsp;&nbsp;&nbsp;\<BR>} while (0)</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Only to be used by arch init code. If the user over-wrote the default<BR>&nbsp;* CONFIG_PANIC_TIMEOUT, honor it.<BR>&nbsp;*/<BR>static inline void set_arch_panic_timeout(int timeout, int arch_default_timeout)<BR>{<BR>&nbsp;if (panic_timeout == arch_default_timeout)<BR>&nbsp;&nbsp;panic_timeout = timeout;<BR>}<BR></FONT><FONT class=extract>extern const char *print_tainted(void);<BR>enum lockdep_ok {<BR>&nbsp;LOCKDEP_STILL_OK,<BR>&nbsp;LOCKDEP_NOW_UNRELIABLE<BR>};<BR>extern void add_taint(unsigned flag, enum lockdep_ok);<BR>extern int test_taint(unsigned flag);<BR>extern unsigned long get_taint(void);<BR>extern int root_mountflags;</FONT></P>
<P><FONT class=extract>extern bool early_boot_irqs_disabled;</FONT></P>
<P><FONT class=extract>/* Values used for system_state */<BR>extern enum system_states {<BR>&nbsp;SYSTEM_BOOTING,<BR>&nbsp;SYSTEM_RUNNING,<BR>&nbsp;SYSTEM_HALT,<BR>&nbsp;SYSTEM_POWER_OFF,<BR>&nbsp;SYSTEM_RESTART,<BR>} system_state;</FONT></P>
<P><FONT class=extract>#define TAINT_PROPRIETARY_MODULE&nbsp;0<BR>#define TAINT_FORCED_MODULE&nbsp;&nbsp;1<BR>#define TAINT_CPU_OUT_OF_SPEC&nbsp;&nbsp;2<BR>#define TAINT_FORCED_RMMOD&nbsp;&nbsp;3<BR>#define TAINT_MACHINE_CHECK&nbsp;&nbsp;4<BR>#define TAINT_BAD_PAGE&nbsp;&nbsp;&nbsp;5<BR>#define TAINT_USER&nbsp;&nbsp;&nbsp;6<BR>#define TAINT_DIE&nbsp;&nbsp;&nbsp;7<BR>#define TAINT_OVERRIDDEN_ACPI_TABLE&nbsp;8<BR>#define TAINT_WARN&nbsp;&nbsp;&nbsp;9<BR>#define TAINT_CRAP&nbsp;&nbsp;&nbsp;10<BR>#define TAINT_FIRMWARE_WORKAROUND&nbsp;11<BR>#define TAINT_OOT_MODULE&nbsp;&nbsp;12<BR>#define TAINT_UNSIGNED_MODULE&nbsp;&nbsp;13<BR>#define TAINT_SOFTLOCKUP&nbsp;&nbsp;14<BR>#define TAINT_LIVEPATCH&nbsp;&nbsp;&nbsp;15</FONT></P>
<P><FONT class=extract>extern const char hex_asc[];<BR>#define hex_asc_lo(x)&nbsp;hex_asc[((x) &amp; 0x0f)]<BR>#define hex_asc_hi(x)&nbsp;hex_asc[((x) &amp; 0xf0) &gt;&gt; 4]</FONT></P>
<P><FONT class=extract>static inline char *hex_byte_pack(char *buf, u8 byte)<BR>{<BR>&nbsp;*buf++ = hex_asc_hi(byte);<BR>&nbsp;*buf++ = hex_asc_lo(byte);<BR>&nbsp;return buf;<BR>}</FONT></P>
<P><FONT class=extract>extern const char hex_asc_upper[];<BR>#define hex_asc_upper_lo(x)&nbsp;hex_asc_upper[((x) &amp; 0x0f)]<BR>#define hex_asc_upper_hi(x)&nbsp;hex_asc_upper[((x) &amp; 0xf0) &gt;&gt; 4]</FONT></P>
<P><FONT class=extract>static inline char *hex_byte_pack_upper(char *buf, u8 byte)<BR>{<BR>&nbsp;*buf++ = hex_asc_upper_hi(byte);<BR>&nbsp;*buf++ = hex_asc_upper_lo(byte);<BR>&nbsp;return buf;<BR>}</FONT></P>
<P><FONT class=extract>extern int hex_to_bin(char ch);<BR>extern int __must_check hex2bin(u8 *dst, const char *src, size_t count);<BR>extern char *bin2hex(char *dst, const void *src, size_t count);</FONT></P>
<P><FONT class=extract>bool mac_pton(const char *s, u8 *mac);</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* General tracing related utility functions - trace_printk(),<BR>&nbsp;* tracing_on/tracing_off and tracing_start()/tracing_stop<BR>&nbsp;*<BR>&nbsp;* Use tracing_on/tracing_off when you want to quickly turn on or off<BR>&nbsp;* tracing. It simply enables or disables the recording of the trace events.<BR>&nbsp;* This also corresponds to the user space /sys/kernel/debug/tracing/tracing_on<BR>&nbsp;* file, which gives a means for the kernel and userspace to interact.<BR>&nbsp;* Place a tracing_off() in the kernel where you want tracing to end.<BR>&nbsp;* From user space, examine the trace, and then echo 1 &gt; tracing_on<BR>&nbsp;* to continue tracing.<BR>&nbsp;*<BR>&nbsp;* tracing_stop/tracing_start has slightly more overhead. It is used<BR>&nbsp;* by things like suspend to ram where disabling the recording of the<BR>&nbsp;* trace is not enough, but tracing must actually stop because things<BR>&nbsp;* like calling smp_processor_id() may crash the system.<BR>&nbsp;*<BR>&nbsp;* Most likely, you want to use tracing_on/tracing_off.<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>enum ftrace_dump_mode {<BR>&nbsp;DUMP_NONE,<BR>&nbsp;DUMP_ALL,<BR>&nbsp;DUMP_ORIG,<BR>};</FONT></P>
<P><FONT class=extract>#ifdef CONFIG_TRACING<BR>void tracing_on(void);<BR>void tracing_off(void);<BR>int tracing_is_on(void);<BR>void tracing_snapshot(void);<BR>void tracing_snapshot_alloc(void);</FONT></P>
<P><FONT class=extract>extern void tracing_start(void);<BR>extern void tracing_stop(void);</FONT></P>
<P><FONT class=extract>static inline __printf(1, 2)<BR>void ____trace_printk_check_format(const char *fmt, ...)<BR>{<BR>}<BR>#define __trace_printk_check_format(fmt, args...)&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;____trace_printk_check_format(fmt, ##args);&nbsp;&nbsp;\<BR>} while (0)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* trace_printk - printf formatting in the ftrace buffer<BR>&nbsp;* @fmt: the printf format for printing<BR>&nbsp;*<BR>&nbsp;* Note: __trace_printk is an internal function for trace_printk and<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the @ip is passed in via the trace_printk macro.<BR>&nbsp;*<BR>&nbsp;* This function allows a kernel developer to debug fast path sections<BR>&nbsp;* that printk is not appropriate for. By scattering in various<BR>&nbsp;* printk like tracing in the code, a developer can quickly see<BR>&nbsp;* where problems are occurring.<BR>&nbsp;*<BR>&nbsp;* This is intended as a debugging tool for the developer only.<BR>&nbsp;* Please refrain from leaving trace_printks scattered around in<BR>&nbsp;* your code. (Extra memory is used for special buffers that are<BR>&nbsp;* allocated when trace_printk() is used)<BR>&nbsp;*<BR>&nbsp;* A little optization trick is done here. If there's only one<BR>&nbsp;* argument, there's no need to scan the string for printf formats.<BR>&nbsp;* The trace_puts() will suffice. But how can we take advantage of<BR>&nbsp;* using trace_puts() when trace_printk() has only one argument?<BR>&nbsp;* By stringifying the args and checking the size we can tell<BR>&nbsp;* whether or not there are args. __stringify((__VA_ARGS__)) will<BR>&nbsp;* turn into "()\0" with a size of 3 when there are no args, anything<BR>&nbsp;* else will be bigger. All we need to do is define a string to this,<BR>&nbsp;* and then take its size and compare to 3. If it's bigger, use<BR>&nbsp;* do_trace_printk() otherwise, optimize it to trace_puts(). Then just<BR>&nbsp;* let gcc optimize the rest.<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>#define trace_printk(fmt, ...)&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;char _______STR[] = __stringify((__VA_ARGS__));&nbsp;\<BR>&nbsp;if (sizeof(_______STR) &gt; 3)&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;do_trace_printk(fmt, ##__VA_ARGS__);&nbsp;\<BR>&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;trace_puts(fmt);&nbsp;&nbsp;&nbsp;\<BR>} while (0)</FONT></P>
<P><FONT class=extract>#define do_trace_printk(fmt, args...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static const char *trace_printk_fmt&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__attribute__((section("__trace_printk_fmt"))) =&nbsp;\<BR>&nbsp;&nbsp;__builtin_constant_p(fmt) ? fmt : NULL;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__trace_printk_check_format(fmt, ##args);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (__builtin_constant_p(fmt))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__trace_bprintk(_THIS_IP_, trace_printk_fmt, ##args);&nbsp;\<BR>&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__trace_printk(_THIS_IP_, fmt, ##args);&nbsp;&nbsp;&nbsp;\<BR>} while (0)</FONT></P>
<P><FONT class=extract>extern __printf(2, 3)<BR>int __trace_bprintk(unsigned long ip, const char *fmt, ...);</FONT></P>
<P><FONT class=extract>extern __printf(2, 3)<BR>int __trace_printk(unsigned long ip, const char *fmt, ...);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* trace_puts - write a string into the ftrace buffer<BR>&nbsp;* @str: the string to record<BR>&nbsp;*<BR>&nbsp;* Note: __trace_bputs is an internal function for trace_puts and<BR>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the @ip is passed in via the trace_puts macro.<BR>&nbsp;*<BR>&nbsp;* This is similar to trace_printk() but is made for those really fast<BR>&nbsp;* paths that a developer wants the least amount of "Heisenbug" affects,<BR>&nbsp;* where the processing of the print format is still too much.<BR>&nbsp;*<BR>&nbsp;* This function allows a kernel developer to debug fast path sections<BR>&nbsp;* that printk is not appropriate for. By scattering in various<BR>&nbsp;* printk like tracing in the code, a developer can quickly see<BR>&nbsp;* where problems are occurring.<BR>&nbsp;*<BR>&nbsp;* This is intended as a debugging tool for the developer only.<BR>&nbsp;* Please refrain from leaving trace_puts scattered around in<BR>&nbsp;* your code. (Extra memory is used for special buffers that are<BR>&nbsp;* allocated when trace_puts() is used)<BR>&nbsp;*<BR>&nbsp;* Returns: 0 if nothing was written, positive # if string was.<BR>&nbsp;*&nbsp; (1 when __trace_bputs is used, strlen(str) when __trace_puts is used)<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>#define trace_puts(str) ({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;static const char *trace_printk_fmt&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__attribute__((section("__trace_printk_fmt"))) =&nbsp;\<BR>&nbsp;&nbsp;__builtin_constant_p(str) ? str : NULL;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (__builtin_constant_p(str))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__trace_bputs(_THIS_IP_, trace_printk_fmt);&nbsp;&nbsp;\<BR>&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__trace_puts(_THIS_IP_, str, strlen(str));&nbsp;&nbsp;\<BR>})<BR>extern int __trace_bputs(unsigned long ip, const char *str);<BR>extern int __trace_puts(unsigned long ip, const char *str, int size);</FONT></P>
<P><FONT class=extract>extern void trace_dump_stack(int skip);</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* The double __builtin_constant_p is because gcc will give us an error<BR>&nbsp;* if we try to allocate the static variable to fmt if it is not a<BR>&nbsp;* constant. Even with the outer if statement.<BR>&nbsp;*/<BR>#define ftrace_vprintk(fmt, vargs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>do {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (__builtin_constant_p(fmt)) {&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;static const char *trace_printk_fmt&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp; __attribute__((section("__trace_printk_fmt"))) =&nbsp;\<BR>&nbsp;&nbsp;&nbsp;__builtin_constant_p(fmt) ? fmt : NULL;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ftrace_vbprintk(_THIS_IP_, trace_printk_fmt, vargs);&nbsp;\<BR>&nbsp;} else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;__ftrace_vprintk(_THIS_IP_, fmt, vargs);&nbsp;&nbsp;\<BR>} while (0)</FONT></P>
<P><FONT class=extract>extern __printf(2, 0) int<BR>__ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap);</FONT></P>
<P><FONT class=extract>extern __printf(2, 0) int<BR>__ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap);</FONT></P>
<P><FONT class=extract>extern void ftrace_dump(enum ftrace_dump_mode oops_dump_mode);<BR>#else<BR>static inline void tracing_start(void) { }<BR>static inline void tracing_stop(void) { }<BR>static inline void trace_dump_stack(int skip) { }</FONT></P>
<P><FONT class=extract>static inline void tracing_on(void) { }<BR>static inline void tracing_off(void) { }<BR>static inline int tracing_is_on(void) { return 0; }<BR>static inline void tracing_snapshot(void) { }<BR>static inline void tracing_snapshot_alloc(void) { }</FONT></P>
<P><FONT class=extract>static inline __printf(1, 2)<BR>int trace_printk(const char *fmt, ...)<BR>{<BR>&nbsp;return 0;<BR>}<BR>static __printf(1, 0) inline int<BR>ftrace_vprintk(const char *fmt, va_list ap)<BR>{<BR>&nbsp;return 0;<BR>}<BR>static inline void ftrace_dump(enum ftrace_dump_mode oops_dump_mode) { }<BR>#endif /* CONFIG_TRACING */</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* min()/max()/clamp() macros that also do<BR>&nbsp;* strict type-checking.. See the<BR>&nbsp;* "unnecessary" pointer comparison.<BR>&nbsp;*/<BR>#define min(x, y) ({&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(x) _min1 = (x);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(y) _min2 = (y);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;(void) (&amp;_min1 == &amp;_min2);&nbsp;&nbsp;\<BR>&nbsp;_min1 &lt; _min2 ? _min1 : _min2; })</FONT></P>
<P><FONT class=extract>#define max(x, y) ({&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(x) _max1 = (x);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(y) _max2 = (y);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;(void) (&amp;_max1 == &amp;_max2);&nbsp;&nbsp;\<BR>&nbsp;_max1 &gt; _max2 ? _max1 : _max2; })</FONT></P>
<P><FONT class=extract>#define min3(x, y, z) min((typeof(x))min(x, y), z)<BR>#define max3(x, y, z) max((typeof(x))max(x, y), z)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* min_not_zero - return the minimum that is _not_ zero, unless both are zero<BR>&nbsp;* @x: value1<BR>&nbsp;* @y: value2<BR>&nbsp;*/<BR>#define min_not_zero(x, y) ({&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(x) __x = (x);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;typeof(y) __y = (y);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__x == 0 ? __y : ((__y == 0) ? __x : min(__x, __y)); })</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* clamp - return a value clamped to a given range with strict typechecking<BR>&nbsp;* @val: current value<BR>&nbsp;* @lo: lowest allowable value<BR>&nbsp;* @hi: highest allowable value<BR>&nbsp;*<BR>&nbsp;* This macro does strict typechecking of lo/hi to make sure they are of the<BR>&nbsp;* same type as val.&nbsp; See the unnecessary pointer comparisons.<BR>&nbsp;*/<BR>#define clamp(val, lo, hi) min((typeof(val))max(val, lo), hi)</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* ..and if you can't take the strict<BR>&nbsp;* types, you can specify one yourself.<BR>&nbsp;*<BR>&nbsp;* Or not use min/max/clamp at all, of course.<BR>&nbsp;*/<BR>#define min_t(type, x, y) ({&nbsp;&nbsp;&nbsp;\<BR>&nbsp;type __min1 = (x);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;type __min2 = (y);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__min1 &lt; __min2 ? __min1: __min2; })</FONT></P>
<P><FONT class=extract>#define max_t(type, x, y) ({&nbsp;&nbsp;&nbsp;\<BR>&nbsp;type __max1 = (x);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;type __max2 = (y);&nbsp;&nbsp;&nbsp;\<BR>&nbsp;__max1 &gt; __max2 ? __max1: __max2; })</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* clamp_t - return a value clamped to a given range using a given type<BR>&nbsp;* @type: the type of variable to use<BR>&nbsp;* @val: current value<BR>&nbsp;* @lo: minimum allowable value<BR>&nbsp;* @hi: maximum allowable value<BR>&nbsp;*<BR>&nbsp;* This macro does no typechecking and uses temporary variables of type<BR>&nbsp;* 'type' to make all the comparisons.<BR>&nbsp;*/<BR>#define clamp_t(type, val, lo, hi) min_t(type, max_t(type, val, lo), hi)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* clamp_val - return a value clamped to a given range using val's type<BR>&nbsp;* @val: current value<BR>&nbsp;* @lo: minimum allowable value<BR>&nbsp;* @hi: maximum allowable value<BR>&nbsp;*<BR>&nbsp;* This macro does no typechecking and uses temporary variables of whatever<BR>&nbsp;* type the input argument 'val' is.&nbsp; This is useful when val is an unsigned<BR>&nbsp;* type and min and max are literals that will otherwise be assigned a signed<BR>&nbsp;* integer type.<BR>&nbsp;*/<BR>#define clamp_val(val, lo, hi) clamp_t(typeof(val), val, lo, hi)</FONT></P>
<P><BR><FONT class=extract>/*<BR>&nbsp;* swap - swap value of @a and @b<BR>&nbsp;*/<BR>#define swap(a, b) \<BR>&nbsp;do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* container_of - cast a member of a structure out to the containing structure<BR>&nbsp;* @ptr:&nbsp;the pointer to the member.<BR>&nbsp;* @type:&nbsp;the type of the container struct this is embedded in.<BR>&nbsp;* @member:&nbsp;the name of the member within the struct.<BR>&nbsp;*<BR>&nbsp;*/<BR>#define container_of(ptr, type, member) ({&nbsp;&nbsp;&nbsp;\<BR>&nbsp;const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);&nbsp;\<BR>&nbsp;(type *)( (char *)__mptr - offsetof(type,member) );})</FONT></P>
<P><FONT class=extract>/* Rebuild everything on CONFIG_FTRACE_MCOUNT_RECORD */<BR>#ifdef CONFIG_FTRACE_MCOUNT_RECORD<BR># define REBUILD_DUE_TO_FTRACE_MCOUNT_RECORD<BR>#endif</FONT></P>
<P><FONT class=extract>/* Permissions on a sysfs file: you didn't miss the 0 prefix did you? */<BR>#define VERIFY_OCTAL_PERMISSIONS(perms)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;(BUILD_BUG_ON_ZERO((perms) &lt; 0) +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp; BUILD_BUG_ON_ZERO((perms) &gt; 0777) +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp; /* USER_READABLE &gt;= GROUP_READABLE &gt;= OTHER_READABLE */&nbsp;&nbsp;\<BR>&nbsp; BUILD_BUG_ON_ZERO((((perms) &gt;&gt; 6) &amp; 4) &lt; (((perms) &gt;&gt; 3) &amp; 4)) +&nbsp;\<BR>&nbsp; BUILD_BUG_ON_ZERO((((perms) &gt;&gt; 3) &amp; 4) &lt; ((perms) &amp; 4)) +&nbsp;&nbsp;\<BR>&nbsp; /* USER_WRITABLE &gt;= GROUP_WRITABLE */&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp; BUILD_BUG_ON_ZERO((((perms) &gt;&gt; 6) &amp; 2) &lt; (((perms) &gt;&gt; 3) &amp; 2)) +&nbsp;\<BR>&nbsp; /* OTHER_WRITABLE?&nbsp; Generally considered a bad idea. */&nbsp;&nbsp;\<BR>&nbsp; BUILD_BUG_ON_ZERO((perms) &amp; 2) +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp; (perms))<BR>#endif</FONT>