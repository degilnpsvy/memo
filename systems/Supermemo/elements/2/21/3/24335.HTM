include/linux/input.h 
<P></P>
<P>/*<BR>&nbsp;* Copyright (c) 1999-2002 Vojtech Pavlik<BR>&nbsp;*<BR>&nbsp;* This program is free software; you can redistribute it and/or modify it<BR>&nbsp;* under the terms of the GNU General Public License version 2 as published by<BR>&nbsp;* the Free Software Foundation.<BR>&nbsp;*/<BR>#ifndef _INPUT_H<BR>#define _INPUT_H</P>
<P></P>
<P>#include &lt;linux/time.h&gt;<BR>#include &lt;linux/list.h&gt;<BR>#include &lt;uapi/linux/input.h&gt;<BR>/* Implementation details, userspace should not care about these */<BR>#define ABS_MT_FIRST&nbsp;&nbsp;ABS_MT_TOUCH_MAJOR<BR>#define ABS_MT_LAST&nbsp;&nbsp;ABS_MT_TOOL_Y</P>
<P>/*<BR>&nbsp;* In-kernel definitions.<BR>&nbsp;*/</P>
<P>#include &lt;linux/device.h&gt;<BR>#include &lt;linux/fs.h&gt;<BR>#include &lt;linux/timer.h&gt;<BR>#include &lt;linux/mod_devicetable.h&gt;</P>
<P><FONT class=extract>/**<BR>&nbsp;* struct input_value - input value representation<BR>&nbsp;* @type: type of value (EV_KEY, EV_ABS, etc)<BR>&nbsp;* @code: the value code<BR>&nbsp;* @value: the value<BR>&nbsp;*/<BR>struct input_value {<BR>&nbsp;__u16 type;<BR>&nbsp;__u16 code;<BR>&nbsp;__s32 value;<BR>};</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* struct input_dev - represents an input device<BR>&nbsp;* @name: name of the device<BR>&nbsp;* @phys: physical path to the device in the system hierarchy<BR>&nbsp;* @uniq: unique identification code for the device (if device has it)<BR>&nbsp;* @id: id of the device (struct input_id)<BR>&nbsp;* @propbit: bitmap of device properties and quirks<BR>&nbsp;* @evbit: bitmap of types of events supported by the device (EV_KEY,<BR>&nbsp;*&nbsp;EV_REL, etc.)<BR>&nbsp;* @keybit: bitmap of keys/buttons this device has<BR>&nbsp;* @relbit: bitmap of relative axes for the device<BR>&nbsp;* @absbit: bitmap of absolute axes for the device<BR>&nbsp;* @mscbit: bitmap of miscellaneous events supported by the device<BR>&nbsp;* @ledbit: bitmap of leds present on the device<BR>&nbsp;* @sndbit: bitmap of sound effects supported by the device<BR>&nbsp;* @ffbit: bitmap of force feedback effects supported by the device<BR>&nbsp;* @swbit: bitmap of switches present on the device<BR>&nbsp;* @hint_events_per_packet: average number of events generated by the<BR>&nbsp;*&nbsp;device in a packet (between EV_SYN/SYN_REPORT events). Used by<BR>&nbsp;*&nbsp;event handlers to estimate size of the buffer needed to hold<BR>&nbsp;*&nbsp;events.<BR>&nbsp;* @keycodemax: size of keycode table<BR>&nbsp;* @keycodesize: size of elements in keycode table<BR>&nbsp;* @keycode: map of scancodes to keycodes for this device<BR>&nbsp;* @getkeycode: optional legacy method to retrieve current keymap.<BR>&nbsp;* @setkeycode: optional method to alter current keymap, used to implement<BR>&nbsp;*&nbsp;sparse keymaps. If not supplied default mechanism will be used.<BR>&nbsp;*&nbsp;The method is being called while holding event_lock and thus must<BR>&nbsp;*&nbsp;not sleep<BR>&nbsp;* @ff: force feedback structure associated with the device if device<BR>&nbsp;*&nbsp;supports force feedback effects<BR>&nbsp;* @repeat_key: stores key code of the last key pressed; used to implement<BR>&nbsp;*&nbsp;software autorepeat<BR>&nbsp;* @timer: timer for software autorepeat<BR>&nbsp;* @rep: current values for autorepeat parameters (delay, rate)<BR>&nbsp;* @mt: pointer to multitouch state<BR>&nbsp;* @absinfo: array of &amp;struct input_absinfo elements holding information<BR>&nbsp;*&nbsp;about absolute axes (current value, min, max, flat, fuzz,<BR>&nbsp;*&nbsp;resolution)<BR>&nbsp;* @key: reflects current state of device's keys/buttons<BR>&nbsp;* @led: reflects current state of device's LEDs<BR>&nbsp;* @snd: reflects current state of sound effects<BR>&nbsp;* @sw: reflects current state of device's switches<BR>&nbsp;* @open: this method is called when the very first user calls<BR>&nbsp;*&nbsp;input_open_device(). The driver must prepare the device<BR>&nbsp;*&nbsp;to start generating events (start polling thread,<BR>&nbsp;*&nbsp;request an IRQ, submit URB, etc.)<BR>&nbsp;* @close: this method is called when the very last user calls<BR>&nbsp;*&nbsp;input_close_device().<BR>&nbsp;* @flush: purges the device. Most commonly used to get rid of force<BR>&nbsp;*&nbsp;feedback effects loaded into the device when disconnecting<BR>&nbsp;*&nbsp;from it<BR>&nbsp;* @event: event handler for events sent _to_ the device, like EV_LED<BR>&nbsp;*&nbsp;or EV_SND. The device is expected to carry out the requested<BR>&nbsp;*&nbsp;action (turn on a LED, play sound, etc.) The call is protected<BR>&nbsp;*&nbsp;by @event_lock and must not sleep<BR>&nbsp;* @grab: input handle that currently has the device grabbed (via<BR>&nbsp;*&nbsp;EVIOCGRAB ioctl). When a handle grabs a device it becomes sole<BR>&nbsp;*&nbsp;recipient for all input events coming from the device<BR>&nbsp;* @event_lock: this spinlock is is taken when input core receives<BR>&nbsp;*&nbsp;and processes a new event for the device (in input_event()).<BR>&nbsp;*&nbsp;Code that accesses and/or modifies parameters of a device<BR>&nbsp;*&nbsp;(such as keymap or absmin, absmax, absfuzz, etc.) after device<BR>&nbsp;*&nbsp;has been registered with input core must take this lock.<BR>&nbsp;* @mutex: serializes calls to open(), close() and flush() methods<BR>&nbsp;* @users: stores number of users (input handlers) that opened this<BR>&nbsp;*&nbsp;device. It is used by input_open_device() and input_close_device()<BR>&nbsp;*&nbsp;to make sure that dev-&gt;open() is only called when the first<BR>&nbsp;*&nbsp;user opens device and dev-&gt;close() is called when the very<BR>&nbsp;*&nbsp;last user closes the device<BR>&nbsp;* @going_away: marks devices that are in a middle of unregistering and<BR>&nbsp;*&nbsp;causes input_open_device*() fail with -ENODEV.<BR>&nbsp;* @dev: driver model's view of this device<BR>&nbsp;* @h_list: list of input handles associated with the device. When<BR>&nbsp;*&nbsp;accessing the list dev-&gt;mutex must be held<BR>&nbsp;* @node: used to place the device onto input_dev_list<BR>&nbsp;* @num_vals: number of values queued in the current frame<BR>&nbsp;* @max_vals: maximum number of values queued in a frame<BR>&nbsp;* @vals: array of values queued in the current frame<BR>&nbsp;* @devres_managed: indicates that devices is managed with devres framework<BR>&nbsp;*&nbsp;and needs not be explicitly unregistered or freed.<BR>&nbsp;*/<BR>struct input_dev {<BR>&nbsp;const char *name;<BR>&nbsp;const char *phys;<BR>&nbsp;const char *uniq;<BR>&nbsp;struct input_id id;</FONT></P>
<P><FONT class=extract>&nbsp;unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</FONT></P>
<P><FONT class=extract>&nbsp;unsigned long evbit[BITS_TO_LONGS(EV_CNT)];<BR>&nbsp;unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];<BR>&nbsp;unsigned long relbit[BITS_TO_LONGS(REL_CNT)];<BR>&nbsp;unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];<BR>&nbsp;unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];<BR>&nbsp;unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];<BR>&nbsp;unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];<BR>&nbsp;unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];<BR>&nbsp;unsigned long swbit[BITS_TO_LONGS(SW_CNT)];</FONT></P>
<P><FONT class=extract>&nbsp;unsigned int hint_events_per_packet;</FONT></P>
<P><FONT class=extract>&nbsp;unsigned int keycodemax;<BR>&nbsp;unsigned int keycodesize;<BR>&nbsp;void *keycode;</FONT></P>
<P><FONT class=extract>&nbsp;int (*setkeycode)(struct input_dev *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp; const struct input_keymap_entry *ke,<BR>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int *old_keycode);<BR>&nbsp;int (*getkeycode)(struct input_dev *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp; struct input_keymap_entry *ke);</FONT></P>
<P><FONT class=extract>&nbsp;struct ff_device *ff;</FONT></P>
<P><FONT class=extract>&nbsp;unsigned int repeat_key;<BR>&nbsp;struct timer_list timer;</FONT></P>
<P><FONT class=extract>&nbsp;int rep[REP_CNT];</FONT></P>
<P><FONT class=extract>&nbsp;struct input_mt *mt;</FONT></P>
<P><FONT class=extract>&nbsp;struct input_absinfo *absinfo;</FONT></P>
<P><FONT class=extract>&nbsp;unsigned long key[BITS_TO_LONGS(KEY_CNT)];<BR>&nbsp;unsigned long led[BITS_TO_LONGS(LED_CNT)];<BR>&nbsp;unsigned long snd[BITS_TO_LONGS(SND_CNT)];<BR>&nbsp;unsigned long sw[BITS_TO_LONGS(SW_CNT)];</FONT></P>
<P><FONT class=extract>&nbsp;int (*open)(struct input_dev *dev);<BR>&nbsp;void (*close)(struct input_dev *dev);<BR>&nbsp;int (*flush)(struct input_dev *dev, struct file *file);<BR>&nbsp;int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);</FONT></P>
<P><FONT class=extract>&nbsp;struct input_handle __rcu *grab;</FONT></P>
<P><FONT class=extract>&nbsp;spinlock_t event_lock;<BR>&nbsp;struct mutex mutex;</FONT></P>
<P><FONT class=extract>&nbsp;unsigned int users;<BR>&nbsp;bool going_away;</FONT></P>
<P><FONT class=extract>&nbsp;struct device dev;</FONT></P>
<P><FONT class=extract>&nbsp;struct list_head&nbsp;h_list;<BR>&nbsp;struct list_head&nbsp;node;</FONT></P>
<P><FONT class=extract>&nbsp;unsigned int num_vals;<BR>&nbsp;unsigned int max_vals;<BR>&nbsp;struct input_value *vals;</FONT></P>
<P><FONT class=extract>&nbsp;bool devres_managed;<BR>};<BR>#define to_input_dev(d) container_of(d, struct input_dev, dev)</FONT></P>
<P><FONT class=extract>/*<BR>&nbsp;* Verify that we are in sync with input_device_id mod_devicetable.h #defines<BR>&nbsp;*/</FONT></P>
<P><FONT class=extract>#if EV_MAX != INPUT_DEVICE_ID_EV_MAX<BR>#error "EV_MAX and INPUT_DEVICE_ID_EV_MAX do not match"<BR>#endif</FONT></P>
<P><FONT class=extract>#if KEY_MIN_INTERESTING != INPUT_DEVICE_ID_KEY_MIN_INTERESTING<BR>#error "KEY_MIN_INTERESTING and INPUT_DEVICE_ID_KEY_MIN_INTERESTING do not match"<BR>#endif</FONT></P>
<P><FONT class=extract>#if KEY_MAX != INPUT_DEVICE_ID_KEY_MAX<BR>#error "KEY_MAX and INPUT_DEVICE_ID_KEY_MAX do not match"<BR>#endif</FONT></P>
<P><FONT class=extract>#if REL_MAX != INPUT_DEVICE_ID_REL_MAX<BR>#error "REL_MAX and INPUT_DEVICE_ID_REL_MAX do not match"<BR>#endif</FONT></P>
<P><FONT class=extract>#if ABS_MAX != INPUT_DEVICE_ID_ABS_MAX<BR>#error "ABS_MAX and INPUT_DEVICE_ID_ABS_MAX do not match"<BR>#endif</FONT></P>
<P><FONT class=extract>#if MSC_MAX != INPUT_DEVICE_ID_MSC_MAX<BR>#error "MSC_MAX and INPUT_DEVICE_ID_MSC_MAX do not match"<BR>#endif</FONT></P>
<P><FONT class=extract>#if LED_MAX != INPUT_DEVICE_ID_LED_MAX<BR>#error "LED_MAX and INPUT_DEVICE_ID_LED_MAX do not match"<BR>#endif</FONT></P>
<P><FONT class=extract>#if SND_MAX != INPUT_DEVICE_ID_SND_MAX<BR>#error "SND_MAX and INPUT_DEVICE_ID_SND_MAX do not match"<BR>#endif</FONT></P>
<P><FONT class=extract>#if FF_MAX != INPUT_DEVICE_ID_FF_MAX<BR>#error "FF_MAX and INPUT_DEVICE_ID_FF_MAX do not match"<BR>#endif</FONT></P>
<P><FONT class=extract>#if SW_MAX != INPUT_DEVICE_ID_SW_MAX<BR>#error "SW_MAX and INPUT_DEVICE_ID_SW_MAX do not match"<BR>#endif</FONT></P>
<P><FONT class=extract>#define INPUT_DEVICE_ID_MATCH_DEVICE \<BR>&nbsp;(INPUT_DEVICE_ID_MATCH_BUS | INPUT_DEVICE_ID_MATCH_VENDOR | INPUT_DEVICE_ID_MATCH_PRODUCT)<BR>#define INPUT_DEVICE_ID_MATCH_DEVICE_AND_VERSION \<BR>&nbsp;(INPUT_DEVICE_ID_MATCH_DEVICE | INPUT_DEVICE_ID_MATCH_VERSION)</FONT></P>
<P>struct input_handle;</P>
<P><FONT class=extract>/**<BR>&nbsp;* struct input_handler - implements one of interfaces for input devices<BR>&nbsp;* @private: driver-specific data<BR>&nbsp;* @event: event handler. This method is being called by input core with<BR>&nbsp;*&nbsp;interrupts disabled and dev-&gt;event_lock spinlock held and so<BR>&nbsp;*&nbsp;it may not sleep<BR>&nbsp;* @events: event sequence handler. This method is being called by<BR>&nbsp;*&nbsp;input core with interrupts disabled and dev-&gt;event_lock<BR>&nbsp;*&nbsp;spinlock held and so it may not sleep<BR>&nbsp;* @filter: similar to @event; separates normal event handlers from<BR>&nbsp;*&nbsp;"filters".<BR>&nbsp;* @match: called after comparing device's id with handler's id_table<BR>&nbsp;*&nbsp;to perform fine-grained matching between device and handler<BR>&nbsp;* @connect: called when attaching a handler to an input device<BR>&nbsp;* @disconnect: disconnects a handler from input device<BR>&nbsp;* @start: starts handler for given handle. This function is called by<BR>&nbsp;*&nbsp;input core right after connect() method and also when a process<BR>&nbsp;*&nbsp;that "grabbed" a device releases it<BR>&nbsp;* @legacy_minors: set to %true by drivers using legacy minor ranges<BR>&nbsp;* @minor: beginning of range of 32 legacy minors for devices this driver<BR>&nbsp;*&nbsp;can provide<BR>&nbsp;* @name: name of the handler, to be shown in /proc/bus/input/handlers<BR>&nbsp;* @id_table: pointer to a table of input_device_ids this driver can<BR>&nbsp;*&nbsp;handle<BR>&nbsp;* @h_list: list of input handles associated with the handler<BR>&nbsp;* @node: for placing the driver onto input_handler_list<BR>&nbsp;*<BR>&nbsp;* Input handlers attach to input devices and create input handles. There<BR>&nbsp;* are likely several handlers attached to any given input device at the<BR>&nbsp;* same time. All of them will get their copy of input event generated by<BR>&nbsp;* the device.<BR>&nbsp;*<BR>&nbsp;* The very same structure is used to implement input filters. Input core<BR>&nbsp;* allows filters to run first and will not pass event to regular handlers<BR>&nbsp;* if any of the filters indicate that the event should be filtered (by<BR>&nbsp;* returning %true from their filter() method).<BR>&nbsp;*<BR>&nbsp;* Note that input core serializes calls to connect() and disconnect()<BR>&nbsp;* methods.<BR>&nbsp;*/<BR>struct input_handler {</FONT></P>
<P><FONT class=extract>&nbsp;void *private;</FONT></P>
<P><FONT class=extract>&nbsp;void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);<BR>&nbsp;void (*events)(struct input_handle *handle,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct input_value *vals, unsigned int count);<BR>&nbsp;bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);<BR>&nbsp;bool (*match)(struct input_handler *handler, struct input_dev *dev);<BR>&nbsp;int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);<BR>&nbsp;void (*disconnect)(struct input_handle *handle);<BR>&nbsp;void (*start)(struct input_handle *handle);</FONT></P>
<P><FONT class=extract>&nbsp;bool legacy_minors;<BR>&nbsp;int minor;<BR>&nbsp;const char *name;</FONT></P>
<P><FONT class=extract>&nbsp;const struct input_device_id *id_table;</FONT></P>
<P><FONT class=extract>&nbsp;struct list_head&nbsp;h_list;<BR>&nbsp;struct list_head&nbsp;node;<BR>};</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* struct input_handle - links input device with an input handler<BR>&nbsp;* @private: handler-specific data<BR>&nbsp;* @open: counter showing whether the handle is 'open', i.e. should deliver<BR>&nbsp;*&nbsp;events from its device<BR>&nbsp;* @name: name given to the handle by handler that created it<BR>&nbsp;* @dev: input device the handle is attached to<BR>&nbsp;* @handler: handler that works with the device through this handle<BR>&nbsp;* @d_node: used to put the handle on device's list of attached handles<BR>&nbsp;* @h_node: used to put the handle on handler's list of handles from which<BR>&nbsp;*&nbsp;it gets events<BR>&nbsp;*/<BR>struct input_handle {</FONT></P>
<P><FONT class=extract>&nbsp;void *private;</FONT></P>
<P><FONT class=extract>&nbsp;int open;<BR>&nbsp;const char *name;</FONT></P>
<P><FONT class=extract>&nbsp;struct input_dev *dev;<BR>&nbsp;struct input_handler *handler;</FONT></P>
<P><FONT class=extract>&nbsp;struct list_head&nbsp;d_node;<BR>&nbsp;struct list_head&nbsp;h_node;<BR>};</FONT></P>
<P><FONT class=extract>struct input_dev __must_check *input_allocate_device(void);<BR>struct input_dev __must_check *devm_input_allocate_device(struct device *);<BR>void input_free_device(struct input_dev *dev);</FONT></P>
<P><FONT class=extract>static inline struct input_dev *input_get_device(struct input_dev *dev)<BR>{<BR>&nbsp;return dev ? to_input_dev(get_device(&amp;dev-&gt;dev)) : NULL;<BR>}</FONT></P>
<P><FONT class=extract>static inline void input_put_device(struct input_dev *dev)<BR>{<BR>&nbsp;if (dev)<BR>&nbsp;&nbsp;put_device(&amp;dev-&gt;dev);<BR>}</FONT></P>
<P><FONT class=extract>static inline void *input_get_drvdata(struct input_dev *dev)<BR>{<BR>&nbsp;return dev_get_drvdata(&amp;dev-&gt;dev);<BR>}</FONT></P>
<P><FONT class=extract>static inline void input_set_drvdata(struct input_dev *dev, void *data)<BR>{<BR>&nbsp;dev_set_drvdata(&amp;dev-&gt;dev, data);<BR>}</FONT></P>
<P><FONT class=extract>int __must_check input_register_device(struct input_dev *);<BR>void input_unregister_device(struct input_dev *);</FONT></P>
<P><FONT class=extract>void input_reset_device(struct input_dev *);</FONT></P>
<P><FONT class=extract>int __must_check input_register_handler(struct input_handler *);<BR>void input_unregister_handler(struct input_handler *);</FONT></P>
<P><FONT class=extract>int __must_check input_get_new_minor(int legacy_base, unsigned int legacy_num,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool allow_dynamic);<BR>void input_free_minor(unsigned int minor);</FONT></P>
<P><FONT class=extract>int input_handler_for_each_handle(struct input_handler *, void *data,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*fn)(struct input_handle *, void *));</FONT></P>
<P><FONT class=extract>int input_register_handle(struct input_handle *);<BR>void input_unregister_handle(struct input_handle *);</FONT></P>
<P><FONT class=extract>int input_grab_device(struct input_handle *);<BR>void input_release_device(struct input_handle *);</FONT></P>
<P><FONT class=extract>int input_open_device(struct input_handle *);<BR>void input_close_device(struct input_handle *);</FONT></P>
<P><FONT class=extract>int input_flush_device(struct input_handle *handle, struct file *file);</FONT></P>
<P><FONT class=extract>void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value);<BR>void input_inject_event(struct input_handle *handle, unsigned int type, unsigned int code, int value);</FONT></P>
<P><FONT class=extract>static inline void input_report_key(struct input_dev *dev, unsigned int code, int value)<BR>{<BR>&nbsp;input_event(dev, EV_KEY, code, !!value);<BR>}</FONT></P>
<P><FONT class=extract>static inline void input_report_rel(struct input_dev *dev, unsigned int code, int value)<BR>{<BR>&nbsp;input_event(dev, EV_REL, code, value);<BR>}</FONT></P>
<P><FONT class=extract>static inline void input_report_abs(struct input_dev *dev, unsigned int code, int value)<BR>{<BR>&nbsp;input_event(dev, EV_ABS, code, value);<BR>}</FONT></P>
<P><FONT class=extract>static inline void input_report_ff_status(struct input_dev *dev, unsigned int code, int value)<BR>{<BR>&nbsp;input_event(dev, EV_FF_STATUS, code, value);<BR>}</FONT></P>
<P><FONT class=extract>static inline void input_report_switch(struct input_dev *dev, unsigned int code, int value)<BR>{<BR>&nbsp;input_event(dev, EV_SW, code, !!value);<BR>}</FONT></P>
<P><FONT class=extract>static inline void input_sync(struct input_dev *dev)<BR>{<BR>&nbsp;input_event(dev, EV_SYN, SYN_REPORT, 0);<BR>}</FONT></P>
<P><FONT class=extract>static inline void input_mt_sync(struct input_dev *dev)<BR>{<BR>&nbsp;input_event(dev, EV_SYN, SYN_MT_REPORT, 0);<BR>}</FONT></P>
<P><FONT class=extract>void input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code);</FONT></P>
<P><FONT class=extract>/**<BR>&nbsp;* input_set_events_per_packet - tell handlers about the driver event rate<BR>&nbsp;* @dev: the input device used by the driver<BR>&nbsp;* @n_events: the average number of events between calls to input_sync()<BR>&nbsp;*<BR>&nbsp;* If the event rate sent from a device is unusually large, use this<BR>&nbsp;* function to set the expected event rate. This will allow handlers<BR>&nbsp;* to set up an appropriate buffer size for the event stream, in order<BR>&nbsp;* to minimize information loss.<BR>&nbsp;*/<BR>static inline void input_set_events_per_packet(struct input_dev *dev, int n_events)<BR>{<BR>&nbsp;dev-&gt;hint_events_per_packet = n_events;<BR>}</FONT></P>
<P><FONT class=extract>void input_alloc_absinfo(struct input_dev *dev);<BR>void input_set_abs_params(struct input_dev *dev, unsigned int axis,<BR>&nbsp;&nbsp;&nbsp;&nbsp; int min, int max, int fuzz, int flat);</FONT></P>
<P><FONT class=extract>#define INPUT_GENERATE_ABS_ACCESSORS(_suffix, _item)&nbsp;&nbsp;&nbsp;\<BR>static inline int input_abs_get_##_suffix(struct input_dev *dev,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int axis)&nbsp;&nbsp;\<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;return dev-&gt;absinfo ? dev-&gt;absinfo[axis]._item : 0;&nbsp;&nbsp;\<BR>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>static inline void input_abs_set_##_suffix(struct input_dev *dev,&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int axis, int val)&nbsp;\<BR>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;input_alloc_absinfo(dev);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;if (dev-&gt;absinfo)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;dev-&gt;absinfo[axis]._item = val;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>}</FONT></P>
<P><FONT class=extract>INPUT_GENERATE_ABS_ACCESSORS(val, value)<BR>INPUT_GENERATE_ABS_ACCESSORS(min, minimum)<BR>INPUT_GENERATE_ABS_ACCESSORS(max, maximum)<BR>INPUT_GENERATE_ABS_ACCESSORS(fuzz, fuzz)<BR>INPUT_GENERATE_ABS_ACCESSORS(flat, flat)<BR>INPUT_GENERATE_ABS_ACCESSORS(res, resolution)</FONT></P>
<P><FONT class=extract>int input_scancode_to_scalar(const struct input_keymap_entry *ke,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int *scancode);</FONT></P>
<P><FONT class=extract>int input_get_keycode(struct input_dev *dev, struct input_keymap_entry *ke);<BR>int input_set_keycode(struct input_dev *dev,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct input_keymap_entry *ke);</FONT></P>
<P>extern struct class input_class;</P>
<P><FONT class=extract>/**<BR>&nbsp;* struct ff_device - force-feedback part of an input device<BR>&nbsp;* @upload: Called to upload an new effect into device<BR>&nbsp;* @erase: Called to erase an effect from device<BR>&nbsp;* @playback: Called to request device to start playing specified effect<BR>&nbsp;* @set_gain: Called to set specified gain<BR>&nbsp;* @set_autocenter: Called to auto-center device<BR>&nbsp;* @destroy: called by input core when parent input device is being<BR>&nbsp;*&nbsp;destroyed<BR>&nbsp;* @private: driver-specific data, will be freed automatically<BR>&nbsp;* @ffbit: bitmap of force feedback capabilities truly supported by<BR>&nbsp;*&nbsp;device (not emulated like ones in input_dev-&gt;ffbit)<BR>&nbsp;* @mutex: mutex for serializing access to the device<BR>&nbsp;* @max_effects: maximum number of effects supported by device<BR>&nbsp;* @effects: pointer to an array of effects currently loaded into device<BR>&nbsp;* @effect_owners: array of effect owners; when file handle owning<BR>&nbsp;*&nbsp;an effect gets closed the effect is automatically erased<BR>&nbsp;*<BR>&nbsp;* Every force-feedback device must implement upload() and playback()<BR>&nbsp;* methods; erase() is optional. set_gain() and set_autocenter() need<BR>&nbsp;* only be implemented if driver sets up FF_GAIN and FF_AUTOCENTER<BR>&nbsp;* bits.<BR>&nbsp;*<BR>&nbsp;* Note that playback(), set_gain() and set_autocenter() are called with<BR>&nbsp;* dev-&gt;event_lock spinlock held and interrupts off and thus may not<BR>&nbsp;* sleep.<BR>&nbsp;*/<BR>struct ff_device {<BR>&nbsp;int (*upload)(struct input_dev *dev, struct ff_effect *effect,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct ff_effect *old);<BR>&nbsp;int (*erase)(struct input_dev *dev, int effect_id);</FONT></P>
<P><FONT class=extract>&nbsp;int (*playback)(struct input_dev *dev, int effect_id, int value);<BR>&nbsp;void (*set_gain)(struct input_dev *dev, u16 gain);<BR>&nbsp;void (*set_autocenter)(struct input_dev *dev, u16 magnitude);</FONT></P>
<P><FONT class=extract>&nbsp;void (*destroy)(struct ff_device *);</FONT></P>
<P><FONT class=extract>&nbsp;void *private;</FONT></P>
<P><FONT class=extract>&nbsp;unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];</FONT></P>
<P><FONT class=extract>&nbsp;struct mutex mutex;</FONT></P>
<P><FONT class=extract>&nbsp;int max_effects;<BR>&nbsp;struct ff_effect *effects;<BR>&nbsp;struct file *effect_owners[];<BR>};</FONT></P>
<P><FONT class=extract>int input_ff_create(struct input_dev *dev, unsigned int max_effects);<BR>void input_ff_destroy(struct input_dev *dev);</FONT></P>
<P><FONT class=extract>int input_ff_event(struct input_dev *dev, unsigned int type, unsigned int code, int value);</FONT></P>
<P><FONT class=extract>int input_ff_upload(struct input_dev *dev, struct ff_effect *effect, struct file *file);<BR>int input_ff_erase(struct input_dev *dev, int effect_id, struct file *file);</FONT></P>
<P><FONT class=extract>int input_ff_create_memless(struct input_dev *dev, void *data,<BR>&nbsp;&nbsp;int (*play_effect)(struct input_dev *, void *, struct ff_effect *));</FONT></P>
<P>#endif