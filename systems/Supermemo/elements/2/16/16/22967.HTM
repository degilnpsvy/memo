# Documentation/robust-futexes.txt</P>
<P>Started by: Ingo Molnar &lt;<A href="mailto:mingo@redhat.com">mingo@redhat.com</A>&gt;</P>
<P></P>
<P>Background<BR>----------</P>
<P>what are robust futexes? To answer that, we first need to understand<BR>what futexes are: normal futexes are special types of locks that in the<BR>noncontended case can be acquired/released from userspace without having<BR>to enter the kernel.</P>
<P>A futex is in essence a user-space address, e.g. a 32-bit lock variable<BR>field. If userspace notices contention (the lock is already owned and<BR>someone else wants to grab it too) then the lock is marked with a value<BR>that says "there's a waiter pending", and the sys_futex(FUTEX_WAIT)<BR>syscall is used to wait for the other guy to release it. The kernel<BR>creates a 'futex queue' internally, so that it can later on match up the<BR>waiter with the waker - without them having to know about each other.<BR>When the owner thread releases the futex, it notices (via the variable<BR>value) that there were waiter(s) pending, and does the<BR>sys_futex(FUTEX_WAKE) syscall to wake them up.&nbsp; Once all waiters have<BR>taken and released the lock, the futex is again back to 'uncontended'<BR>state, and there's no in-kernel state associated with it. The kernel<BR>completely forgets that there ever was a futex at that address. This<BR>method makes futexes very lightweight and scalable.</P>
<P>"Robustness" is about dealing with crashes while holding a lock: if a<BR>process exits prematurely while holding a pthread_mutex_t lock that is<BR>also shared with some other process (e.g. yum segfaults while holding a<BR>pthread_mutex_t, or yum is kill -9-ed), then waiters for that lock need<BR>to be notified that the last owner of the lock exited in some irregular<BR>way.</P>
<P>To solve such types of problems, "robust mutex" userspace APIs were<BR>created: pthread_mutex_lock() returns an error value if the owner exits<BR>prematurely - and the new owner can decide whether the data protected by<BR>the lock can be recovered safely.</P>
<P>There is a big conceptual problem with futex based mutexes though: it is<BR>the kernel that destroys the owner task (e.g. due to a SEGFAULT), but<BR>the kernel cannot help with the cleanup: if there is no 'futex queue'<BR>(and in most cases there is none, futexes being fast lightweight locks)<BR>then the kernel has no information to clean up after the held lock!<BR>Userspace has no chance to clean up after the lock either - userspace is<BR>the one that crashes, so it has no opportunity to clean up. Catch-22.</P>
<P>In practice, when e.g. yum is kill -9-ed (or segfaults), a system reboot<BR>is needed to release that futex based lock. This is one of the leading<BR>bugreports against yum.</P>
<P>To solve this problem, the traditional approach was to extend the vma<BR>(virtual memory area descriptor) concept to have a notion of 'pending<BR>robust futexes attached to this area'. This approach requires 3 new<BR>syscall variants to sys_futex(): FUTEX_REGISTER, FUTEX_DEREGISTER and<BR>FUTEX_RECOVER. At do_exit() time, all vmas are searched to see whether<BR>they have a robust_head set. This approach has two fundamental problems<BR>left:</P>
<P>&nbsp;- it has quite complex locking and race scenarios. The vma-based<BR>&nbsp;&nbsp; approach had been pending for years, but they are still not completely<BR>&nbsp;&nbsp; reliable.</P>
<P>&nbsp;- they have to scan _every_ vma at sys_exit() time, per thread!</P>
<P>The second disadvantage is a real killer: pthread_exit() takes around 1<BR>microsecond on Linux, but with thousands (or tens of thousands) of vmas<BR>every pthread_exit() takes a millisecond or more, also totally<BR>destroying the CPU's L1 and L2 caches!</P>
<P>This is very much noticeable even for normal process sys_exit_group()<BR>calls: the kernel has to do the vma scanning unconditionally! (this is<BR>because the kernel has no knowledge about how many robust futexes there<BR>are to be cleaned up, because a robust futex might have been registered<BR>in another task, and the futex variable might have been simply mmap()-ed<BR>into this process's address space).</P>
<P>This huge overhead forced the creation of CONFIG_FUTEX_ROBUST so that<BR>normal kernels can turn it off, but worse than that: the overhead makes<BR>robust futexes impractical for any type of generic Linux distribution.</P>
<P>So something had to be done.</P>
<P>New approach to robust futexes<BR>------------------------------</P>
<P>At the heart of this new approach there is a per-thread private list of<BR>robust locks that userspace is holding (maintained by glibc) - which<BR>userspace list is registered with the kernel via a new syscall [this<BR>registration happens at most once per thread lifetime]. At do_exit()<BR>time, the kernel checks this user-space list: are there any robust futex<BR>locks to be cleaned up?</P>
<P>In the common case, at do_exit() time, there is no list registered, so<BR>the cost of robust futexes is just a simple current-&gt;robust_list != NULL<BR>comparison. If the thread has registered a list, then normally the list<BR>is empty. If the thread/process crashed or terminated in some incorrect<BR>way then the list might be non-empty: in this case the kernel carefully<BR>walks the list [not trusting it], and marks all locks that are owned by<BR>this thread with the FUTEX_OWNER_DIED bit, and wakes up one waiter (if<BR>any).</P>
<P>The list is guaranteed to be private and per-thread at do_exit() time,<BR>so it can be accessed by the kernel in a lockless way.</P>
<P>There is one race possible though: since adding to and removing from the<BR>list is done after the futex is acquired by glibc, there is a few<BR>instructions window for the thread (or process) to die there, leaving<BR>the futex hung. To protect against this possibility, userspace (glibc)<BR>also maintains a simple per-thread 'list_op_pending' field, to allow the<BR>kernel to clean up if the thread dies after acquiring the lock, but just<BR>before it could have added itself to the list. Glibc sets this<BR>list_op_pending field before it tries to acquire the futex, and clears<BR>it after the list-add (or list-remove) has finished.</P>
<P>That's all that is needed - all the rest of robust-futex cleanup is done<BR>in userspace [just like with the previous patches].</P>
<P>Ulrich Drepper has implemented the necessary glibc support for this new<BR>mechanism, which fully enables robust mutexes.</P>
<P>Key differences of this userspace-list based approach, compared to the<BR>vma based method:</P>
<P>&nbsp;- it's much, much faster: at thread exit time, there's no need to loop<BR>&nbsp;&nbsp; over every vma (!), which the VM-based method has to do. Only a very<BR>&nbsp;&nbsp; simple 'is the list empty' op is done.</P>
<P>&nbsp;- no VM changes are needed - 'struct address_space' is left alone.</P>
<P>&nbsp;- no registration of individual locks is needed: robust mutexes dont<BR>&nbsp;&nbsp; need any extra per-lock syscalls. Robust mutexes thus become a very<BR>&nbsp;&nbsp; lightweight primitive - so they dont force the application designer<BR>&nbsp;&nbsp; to do a hard choice between performance and robustness - robust<BR>&nbsp;&nbsp; mutexes are just as fast.</P>
<P>&nbsp;- no per-lock kernel allocation happens.</P>
<P>&nbsp;- no resource limits are needed.</P>
<P>&nbsp;- no kernel-space recovery call (FUTEX_RECOVER) is needed.</P>
<P>&nbsp;- the implementation and the locking is "obvious", and there are no<BR>&nbsp;&nbsp; interactions with the VM.</P>
<P>Performance<BR>-----------</P>
<P>I have benchmarked the time needed for the kernel to process a list of 1<BR>million (!) held locks, using the new method [on a 2GHz CPU]:</P>
<P>&nbsp;- with FUTEX_WAIT set [contended mutex]: 130 msecs<BR>&nbsp;- without FUTEX_WAIT set [uncontended mutex]: 30 msecs</P>
<P>I have also measured an approach where glibc does the lock notification<BR>[which it currently does for !pshared robust mutexes], and that took 256<BR>msecs - clearly slower, due to the 1 million FUTEX_WAKE syscalls<BR>userspace had to do.</P>
<P>(1 million held locks are unheard of - we expect at most a handful of<BR>locks to be held at a time. Nevertheless it's nice to know that this<BR>approach scales nicely.)</P>
<P>Implementation details<BR>----------------------</P>
<P>The patch adds two new syscalls: one to register the userspace list, and<BR>one to query the registered list pointer:</P>
<P>&nbsp;asmlinkage long<BR>&nbsp;sys_set_robust_list(struct robust_list_head __user *head,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len);</P>
<P>&nbsp;asmlinkage long<BR>&nbsp;sys_get_robust_list(int pid, struct robust_list_head __user **head_ptr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t __user *len_ptr);</P>
<P>List registration is very fast: the pointer is simply stored in<BR>current-&gt;robust_list. [Note that in the future, if robust futexes become<BR>widespread, we could extend sys_clone() to register a robust-list head<BR>for new threads, without the need of another syscall.]</P>
<P>So there is virtually zero overhead for tasks not using robust futexes,<BR>and even for robust futex users, there is only one extra syscall per<BR>thread lifetime, and the cleanup operation, if it happens, is fast and<BR>straightforward. The kernel doesn't have any internal distinction between<BR>robust and normal futexes.</P>
<P>If a futex is found to be held at exit time, the kernel sets the<BR>following bit of the futex word:</P>
<P>&nbsp;#define FUTEX_OWNER_DIED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x40000000</P>
<P>and wakes up the next futex waiter (if any). User-space does the rest of<BR>the cleanup.</P>
<P>Otherwise, robust futexes are acquired by glibc by putting the TID into<BR>the futex field atomically. Waiters set the FUTEX_WAITERS bit:</P>
<P>&nbsp;#define FUTEX_WAITERS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80000000</P>
<P>and the remaining bits are for the TID.</P>
<P>Testing, architecture support<BR>-----------------------------</P>
<P>i've tested the new syscalls on x86 and x86_64, and have made sure the<BR>parsing of the userspace list is robust [ ;-) ] even if the list is<BR>deliberately corrupted.</P>
<P>i386 and x86_64 syscalls are wired up at the moment, and Ulrich has<BR>tested the new glibc code (on x86_64 and i386), and it works for his<BR>robust-mutex testcases.</P>
<P>All other architectures should build just fine too - but they wont have<BR>the new syscalls yet.</P>
<P>Architectures need to implement the new futex_atomic_cmpxchg_inatomic()<BR>inline function before writing up the syscalls (that function returns<BR>-ENOSYS right now).