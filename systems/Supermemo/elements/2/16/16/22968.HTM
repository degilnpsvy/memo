# Documentation/robust-futex-ABI.txt
<P></P>
<P>Started by Paul Jackson &lt;<A href="mailto:pj@sgi.com">pj@sgi.com</A>&gt;</P>
<P></P>
<P>The robust futex ABI<BR>--------------------</P>
<P>Robust_futexes provide a mechanism that is used in addition to normal<BR>futexes, for kernel assist of cleanup of held locks on task exit.</P>
<P>The interesting data as to what futexes a thread is holding is kept on a<BR>linked list in user space, where it can be updated efficiently as locks<BR>are taken and dropped, without kernel intervention.&nbsp; The only additional<BR>kernel intervention required for robust_futexes above and beyond what is<BR>required for futexes is:</P>
<P>&nbsp;1) a one time call, per thread, to tell the kernel where its list of<BR>&nbsp;&nbsp;&nbsp; held robust_futexes begins, and<BR>&nbsp;2) internal kernel code at exit, to handle any listed locks held<BR>&nbsp;&nbsp;&nbsp; by the exiting thread.</P>
<P>The existing normal futexes already provide a "Fast Userspace Locking"<BR>mechanism, which handles uncontested locking without needing a system<BR>call, and handles contested locking by maintaining a list of waiting<BR>threads in the kernel.&nbsp; Options on the sys_futex(2) system call support<BR>waiting on a particular futex, and waking up the next waiter on a<BR>particular futex.</P>
<P>For robust_futexes to work, the user code (typically in a library such<BR>as glibc linked with the application) has to manage and place the<BR>necessary list elements exactly as the kernel expects them.&nbsp; If it fails<BR>to do so, then improperly listed locks will not be cleaned up on exit,<BR>probably causing deadlock or other such failure of the other threads<BR>waiting on the same locks.</P>
<P>A thread that anticipates possibly using robust_futexes should first<BR>issue the system call:</P>
<P>&nbsp;&nbsp;&nbsp; asmlinkage long<BR>&nbsp;&nbsp;&nbsp; sys_set_robust_list(struct robust_list_head __user *head, size_t len);</P>
<P>The pointer 'head' points to a structure in the threads address space<BR>consisting of three words.&nbsp; Each word is 32 bits on 32 bit arch's, or 64<BR>bits on 64 bit arch's, and local byte order.&nbsp; Each thread should have<BR>its own thread private 'head'.</P>
<P>If a thread is running in 32 bit compatibility mode on a 64 native arch<BR>kernel, then it can actually have two such structures - one using 32 bit<BR>words for 32 bit compatibility mode, and one using 64 bit words for 64<BR>bit native mode.&nbsp; The kernel, if it is a 64 bit kernel supporting 32 bit<BR>compatibility mode, will attempt to process both lists on each task<BR>exit, if the corresponding sys_set_robust_list() call has been made to<BR>setup that list.</P>
<P>&nbsp; The first word in the memory structure at 'head' contains a<BR>&nbsp; pointer to a single linked list of 'lock entries', one per lock,<BR>&nbsp; as described below.&nbsp; If the list is empty, the pointer will point<BR>&nbsp; to itself, 'head'.&nbsp; The last 'lock entry' points back to the 'head'.</P>
<P>&nbsp; The second word, called 'offset', specifies the offset from the<BR>&nbsp; address of the associated 'lock entry', plus or minus, of what will<BR>&nbsp; be called the 'lock word', from that 'lock entry'.&nbsp; The 'lock word'<BR>&nbsp; is always a 32 bit word, unlike the other words above.&nbsp; The 'lock<BR>&nbsp; word' holds 3 flag bits in the upper 3 bits, and the thread id (TID)<BR>&nbsp; of the thread holding the lock in the bottom 29 bits.&nbsp; See further<BR>&nbsp; below for a description of the flag bits.</P>
<P>&nbsp; The third word, called 'list_op_pending', contains transient copy of<BR>&nbsp; the address of the 'lock entry', during list insertion and removal,<BR>&nbsp; and is needed to correctly resolve races should a thread exit while<BR>&nbsp; in the middle of a locking or unlocking operation.</P>
<P>Each 'lock entry' on the single linked list starting at 'head' consists<BR>of just a single word, pointing to the next 'lock entry', or back to<BR>'head' if there are no more entries.&nbsp; In addition, nearby to each 'lock<BR>entry', at an offset from the 'lock entry' specified by the 'offset'<BR>word, is one 'lock word'.</P>
<P>The 'lock word' is always 32 bits, and is intended to be the same 32 bit<BR>lock variable used by the futex mechanism, in conjunction with<BR>robust_futexes.&nbsp; The kernel will only be able to wakeup the next thread<BR>waiting for a lock on a threads exit if that next thread used the futex<BR>mechanism to register the address of that 'lock word' with the kernel.</P>
<P>For each futex lock currently held by a thread, if it wants this<BR>robust_futex support for exit cleanup of that lock, it should have one<BR>'lock entry' on this list, with its associated 'lock word' at the<BR>specified 'offset'.&nbsp; Should a thread die while holding any such locks,<BR>the kernel will walk this list, mark any such locks with a bit<BR>indicating their holder died, and wakeup the next thread waiting for<BR>that lock using the futex mechanism.</P>
<P>When a thread has invoked the above system call to indicate it<BR>anticipates using robust_futexes, the kernel stores the passed in 'head'<BR>pointer for that task.&nbsp; The task may retrieve that value later on by<BR>using the system call:</P>
<P>&nbsp;&nbsp;&nbsp; asmlinkage long<BR>&nbsp;&nbsp;&nbsp; sys_get_robust_list(int pid, struct robust_list_head __user **head_ptr,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t __user *len_ptr);</P>
<P>It is anticipated that threads will use robust_futexes embedded in<BR>larger, user level locking structures, one per lock.&nbsp; The kernel<BR>robust_futex mechanism doesn't care what else is in that structure, so<BR>long as the 'offset' to the 'lock word' is the same for all<BR>robust_futexes used by that thread.&nbsp; The thread should link those locks<BR>it currently holds using the 'lock entry' pointers.&nbsp; It may also have<BR>other links between the locks, such as the reverse side of a double<BR>linked list, but that doesn't matter to the kernel.</P>
<P>By keeping its locks linked this way, on a list starting with a 'head'<BR>pointer known to the kernel, the kernel can provide to a thread the<BR>essential service available for robust_futexes, which is to help clean<BR>up locks held at the time of (a perhaps unexpectedly) exit.</P>
<P>Actual locking and unlocking, during normal operations, is handled<BR>entirely by user level code in the contending threads, and by the<BR>existing futex mechanism to wait for, and wakeup, locks.&nbsp; The kernels<BR>only essential involvement in robust_futexes is to remember where the<BR>list 'head' is, and to walk the list on thread exit, handling locks<BR>still held by the departing thread, as described below.</P>
<P>There may exist thousands of futex lock structures in a threads shared<BR>memory, on various data structures, at a given point in time. Only those<BR>lock structures for locks currently held by that thread should be on<BR>that thread's robust_futex linked lock list a given time.</P>
<P>A given futex lock structure in a user shared memory region may be held<BR>at different times by any of the threads with access to that region. The<BR>thread currently holding such a lock, if any, is marked with the threads<BR>TID in the lower 29 bits of the 'lock word'.</P>
<P>When adding or removing a lock from its list of held locks, in order for<BR>the kernel to correctly handle lock cleanup regardless of when the task<BR>exits (perhaps it gets an unexpected signal 9 in the middle of<BR>manipulating this list), the user code must observe the following<BR>protocol on 'lock entry' insertion and removal:</P>
<P>On insertion:<BR>&nbsp;1) set the 'list_op_pending' word to the address of the 'lock entry'<BR>&nbsp;&nbsp;&nbsp; to be inserted,<BR>&nbsp;2) acquire the futex lock,<BR>&nbsp;3) add the lock entry, with its thread id (TID) in the bottom 29 bits<BR>&nbsp;&nbsp;&nbsp; of the 'lock word', to the linked list starting at 'head', and<BR>&nbsp;4) clear the 'list_op_pending' word.</P>
<P>On removal:<BR>&nbsp;1) set the 'list_op_pending' word to the address of the 'lock entry'<BR>&nbsp;&nbsp;&nbsp; to be removed,<BR>&nbsp;2) remove the lock entry for this lock from the 'head' list,<BR>&nbsp;2) release the futex lock, and<BR>&nbsp;2) clear the 'lock_op_pending' word.</P>
<P>On exit, the kernel will consider the address stored in<BR>'list_op_pending' and the address of each 'lock word' found by walking<BR>the list starting at 'head'.&nbsp; For each such address, if the bottom 29<BR>bits of the 'lock word' at offset 'offset' from that address equals the<BR>exiting threads TID, then the kernel will do two things:</P>
<P>&nbsp;1) if bit 31 (0x80000000) is set in that word, then attempt a futex<BR>&nbsp;&nbsp;&nbsp; wakeup on that address, which will waken the next thread that has<BR>&nbsp;&nbsp;&nbsp; used to the futex mechanism to wait on that address, and<BR>&nbsp;2) atomically set&nbsp; bit 30 (0x40000000) in the 'lock word'.</P>
<P>In the above, bit 31 was set by futex waiters on that lock to indicate<BR>they were waiting, and bit 30 is set by the kernel to indicate that the<BR>lock owner died holding the lock.</P>
<P>The kernel exit code will silently stop scanning the list further if at<BR>any point:</P>
<P>&nbsp;1) the 'head' pointer or an subsequent linked list pointer<BR>&nbsp;&nbsp;&nbsp; is not a valid address of a user space word<BR>&nbsp;2) the calculated location of the 'lock word' (address plus<BR>&nbsp;&nbsp;&nbsp; 'offset') is not the valid address of a 32 bit user space<BR>&nbsp;&nbsp;&nbsp; word<BR>&nbsp;3) if the list contains more than 1 million (subject to<BR>&nbsp;&nbsp;&nbsp; future kernel configuration changes) elements.</P>
<P>When the kernel sees a list entry whose 'lock word' doesn't have the<BR>current threads TID in the lower 29 bits, it does nothing with that<BR>entry, and goes on to the next entry.</P>
<P>Bit 29 (0x20000000) of the 'lock word' is reserved for future use.