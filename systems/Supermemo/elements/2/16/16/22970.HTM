2. Programmer's View of /dev/fb*<BR>-------------------------------- 
<P></P>
<P><FONT class=extract>As you already know, a frame buffer device is a memory device like /dev/mem and<BR>it has the same features. You can read it, write it, seek to some location in<BR>it and mmap() it (the main usage). The difference is just that the memory that<BR>appears in the special file is not the whole memory, but the frame buffer of<BR>some video hardware.</FONT></P>
<P><FONT class=extract>/dev/fb* also allows several ioctls on it, by which lots of information about<BR>the hardware can be queried and set. The color map handling works via ioctls,<BR>too. Look into &lt;linux/fb.h&gt; for more information on what ioctls exist and on<BR>which data structures they work. Here's just a brief overview:</FONT></P>
<P><FONT class=extract>&nbsp; - You can request unchangeable information about the hardware, like name,<BR>&nbsp;&nbsp;&nbsp; organization of the screen memory (planes, packed pixels, ...) and address<BR>&nbsp;&nbsp;&nbsp; and length of the screen memory.</FONT></P>
<P><FONT class=extract>&nbsp; - You can request and change variable information about the hardware, like<BR>&nbsp;&nbsp;&nbsp; visible and virtual geometry, depth, color map format, timing, and so on.<BR>&nbsp;&nbsp;&nbsp; If you try to change that information, the driver maybe will round up some<BR>&nbsp;&nbsp;&nbsp; values to meet the hardware's capabilities (or return EINVAL if that isn't<BR>&nbsp;&nbsp;&nbsp; possible).</FONT></P>
<P><FONT class=extract>&nbsp; - You can get and set parts of the color map. Communication is done with 16<BR>&nbsp;&nbsp;&nbsp; bits per color part (red, green, blue, transparency) to support all <BR>&nbsp;&nbsp;&nbsp; existing hardware. The driver does all the computations needed to apply <BR>&nbsp;&nbsp;&nbsp; it to the hardware (round it down to less bits, maybe throw away <BR>&nbsp;&nbsp;&nbsp; transparency).</FONT></P>
<P><FONT class=extract>All this hardware abstraction makes the implementation of application programs<BR>easier and more portable. E.g. the X server works completely on /dev/fb* and<BR>thus doesn't need to know, for example, how the color registers of the concrete<BR>hardware are organized. XF68_FBDev is a general X server for bitmapped,<BR>unaccelerated video hardware. The only thing that has to be built into<BR>application programs is the screen organization (bitplanes or chunky pixels<BR>etc.), because it works on the frame buffer image data directly.</FONT></P>
<P><FONT class=extract>For the future it is planned that frame buffer drivers for graphics cards and<BR>the like can be implemented as kernel modules that are loaded at runtime. Such<BR>a driver just has to call register_framebuffer() and supply some functions.<BR>Writing and distributing such drivers independently from the kernel will save<BR>much trouble...</FONT>