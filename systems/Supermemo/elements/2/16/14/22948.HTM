# Documentation/sysrq.txt
<P></P>
<P>Linux Magic System Request Key Hacks<BR>Documentation for sysrq.c</P>
<P></P>
<P>*&nbsp; What is the magic SysRq key?<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>It is a 'magical' key combo you can hit which the kernel will respond to<BR>regardless of whatever else it is doing, unless it is completely locked up.</P>
<P>*&nbsp; How do I enable the magic SysRq key?<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>You need to say "yes" to 'Magic SysRq key (CONFIG_MAGIC_SYSRQ)' when<BR>configuring the kernel. When running a kernel with SysRq compiled in,<BR>/proc/sys/kernel/sysrq controls the functions allowed to be invoked via<BR>the SysRq key. By default the file contains 1 which means that every<BR>possible SysRq request is allowed (in older versions SysRq was disabled<BR>by default, and you were required to specifically enable it at run-time<BR>but this is not the case any more). Here is the list of possible values<BR>in /proc/sys/kernel/sysrq:<BR>&nbsp;&nbsp; 0 - disable sysrq completely<BR>&nbsp;&nbsp; 1 - enable all functions of sysrq<BR>&nbsp; &gt;1 - bitmask of allowed sysrq functions (see below for detailed function<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; description):<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 - enable control of console logging level<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 - enable control of keyboard (SAK, unraw)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 - enable debugging dumps of processes etc.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 - enable sync command<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 - enable remount read-only<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64 - enable signalling of processes (term, kill, oom-kill)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 128 - allow reboot/poweroff<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 256 - allow nicing of all RT tasks</P>
<P>You can set the value in the file by the following command:<BR>&nbsp;&nbsp;&nbsp; echo "number" &gt;/proc/sys/kernel/sysrq</P>
<P>Note that the value of /proc/sys/kernel/sysrq influences only the invocation<BR>via a keyboard. Invocation of any operation via /proc/sysrq-trigger is always<BR>allowed (by a user with admin privileges).</P>
<P>*&nbsp; How do I use the magic SysRq key?<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>On x86&nbsp;&nbsp; - You press the key combo 'ALT-SysRq-&lt;command key&gt;'. Note - Some<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyboards may not have a key labeled 'SysRq'. The 'SysRq' key is<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; also known as the 'Print Screen' key. Also some keyboards cannot<BR>&nbsp;&nbsp;&nbsp; handle so many keys being pressed at the same time, so you might<BR>&nbsp;&nbsp;&nbsp; have better luck with "press Alt", "press SysRq", "release SysRq",<BR>&nbsp;&nbsp;&nbsp; "press &lt;command key&gt;", release everything.</P>
<P>On SPARC - You press 'ALT-STOP-&lt;command key&gt;', I believe.</P>
<P>On the serial console (PC style standard serial ports only) -<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You send a BREAK, then within 5 seconds a command key. Sending<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BREAK twice is interpreted as a normal BREAK.</P>
<P>On PowerPC - Press 'ALT - Print Screen (or F13) - &lt;command key&gt;,&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print Screen (or F13) - &lt;command key&gt; may suffice.</P>
<P>On other - If you know of the key combos for other architectures, please<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let me know so I can add them to this section.</P>
<P>On all -&nbsp; write a character to /proc/sysrq-trigger.&nbsp; e.g.:</P>
<P>&nbsp;&nbsp;echo t &gt; /proc/sysrq-trigger</P>
<P>*&nbsp; What are the 'command' keys?<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>'b'&nbsp;&nbsp;&nbsp;&nbsp; - Will immediately reboot the system without syncing or unmounting<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; your disks.</P>
<P>'c'&nbsp;- Will perform a system crash by a NULL pointer dereference.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A crashdump will be taken if configured.</P>
<P>'d'&nbsp;- Shows all locks that are held.</P>
<P>'e'&nbsp;&nbsp;&nbsp;&nbsp; - Send a SIGTERM to all processes, except for init.</P>
<P>'f'&nbsp;- Will call oom_kill to kill a memory hog process.</P>
<P>'g'&nbsp;- Used by kgdb (kernel debugger)</P>
<P>'h'&nbsp;&nbsp;&nbsp;&nbsp; - Will display help (actually any other key than those listed<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; here will display help. but 'h' is easy to remember :-)</P>
<P>'i'&nbsp;&nbsp;&nbsp;&nbsp; - Send a SIGKILL to all processes, except for init.</P>
<P>'j'&nbsp;&nbsp;&nbsp;&nbsp; - Forcibly "Just thaw it" - filesystems frozen by the FIFREEZE ioctl.</P>
<P>'k'&nbsp;&nbsp;&nbsp;&nbsp; - Secure Access Key (SAK) Kills all programs on the current virtual<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console. NOTE: See important comments below in SAK section.</P>
<P>'l'&nbsp;&nbsp;&nbsp;&nbsp; - Shows a stack backtrace for all active CPUs.</P>
<P>'m'&nbsp;&nbsp;&nbsp;&nbsp; - Will dump current memory info to your console.</P>
<P>'n'&nbsp;- Used to make RT tasks nice-able</P>
<P>'o'&nbsp;&nbsp;&nbsp;&nbsp; - Will shut your system off (if configured and supported).</P>
<P>'p'&nbsp;&nbsp;&nbsp;&nbsp; - Will dump the current registers and flags to your console.</P>
<P>'q'&nbsp;&nbsp;&nbsp;&nbsp; - Will dump per CPU lists of all armed hrtimers (but NOT regular<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timer_list timers) and detailed information about all<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clockevent devices.</P>
<P>'r'&nbsp;&nbsp;&nbsp;&nbsp; - Turns off keyboard raw mode and sets it to XLATE.</P>
<P>'s'&nbsp;&nbsp;&nbsp;&nbsp; - Will attempt to sync all mounted filesystems.</P>
<P>'t'&nbsp;&nbsp;&nbsp;&nbsp; - Will dump a list of current tasks and their information to your<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.</P>
<P>'u'&nbsp;&nbsp;&nbsp;&nbsp; - Will attempt to remount all mounted filesystems read-only.</P>
<P>'v'&nbsp;- Forcefully restores framebuffer console<BR>'v'&nbsp;- Causes ETM buffer dump [ARM-specific]</P>
<P>'w'&nbsp;- Dumps tasks that are in uninterruptable (blocked) state.</P>
<P>'x'&nbsp;- Used by xmon interface on ppc/powerpc platforms.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Show global PMU Registers on sparc64.</P>
<P>'y'&nbsp;- Show global CPU Registers [SPARC-64 specific]</P>
<P>'z'&nbsp;- Dump the ftrace buffer</P>
<P>'0'-'9' - Sets the console log level, controlling which kernel messages<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; will be printed to your console. ('0', for example would make<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it so that only emergency messages like PANICs or OOPSes would<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make it to your console.)</P>
<P>*&nbsp; Okay, so what can I use them for?<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>Well, unraw(r) is very handy when your X server or a svgalib program crashes.</P>
<P>sak(k) (Secure Access Key) is useful when you want to be sure there is no<BR>trojan program running at console which could grab your password<BR>when you would try to login. It will kill all programs on given console,<BR>thus letting you make sure that the login prompt you see is actually<BR>the one from init, not some trojan program.<BR>IMPORTANT: In its true form it is not a true SAK like the one in a :IMPORTANT<BR>IMPORTANT: c2 compliant system, and it should not be mistaken as&nbsp;&nbsp; :IMPORTANT<BR>IMPORTANT: such.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :IMPORTANT<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It seems others find it useful as (System Attention Key) which is<BR>useful when you want to exit a program that will not let you switch consoles.<BR>(For example, X or a svgalib program.)</P>
<P>reboot(b) is good when you're unable to shut down. But you should also<BR>sync(s) and umount(u) first.</P>
<P>crash(c) can be used to manually trigger a crashdump when the system is hung.<BR>Note that this just triggers a crash if there is no dump mechanism available.</P>
<P>sync(s) is great when your system is locked up, it allows you to sync your<BR>disks and will certainly lessen the chance of data loss and fscking. Note<BR>that the sync hasn't taken place until you see the "OK" and "Done" appear<BR>on the screen. (If the kernel is really in strife, you may not ever get the<BR>OK or Done message...)</P>
<P>umount(u) is basically useful in the same ways as sync(s). I generally sync(s),<BR>umount(u), then reboot(b) when my system locks. It's saved me many a fsck.<BR>Again, the unmount (remount read-only) hasn't taken place until you see the<BR>"OK" and "Done" message appear on the screen.</P>
<P>The loglevels '0'-'9' are useful when your console is being flooded with<BR>kernel messages you do not want to see. Selecting '0' will prevent all but<BR>the most urgent kernel messages from reaching your console. (They will<BR>still be logged if syslogd/klogd are alive, though.)</P>
<P>term(e) and kill(i) are useful if you have some sort of runaway process you<BR>are unable to kill any other way, especially if it's spawning other<BR>processes.</P>
<P>"just thaw it(j)" is useful if your system becomes unresponsive due to a frozen<BR>(probably root) filesystem via the FIFREEZE ioctl.</P>
<P>*&nbsp; Sometimes SysRq seems to get 'stuck' after using it, what can I do?<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>That happens to me, also. I've found that tapping shift, alt, and control<BR>on both sides of the keyboard, and hitting an invalid sysrq sequence again<BR>will fix the problem. (i.e., something like alt-sysrq-z). Switching to another<BR>virtual console (ALT+Fn) and then back again should also help.</P>
<P>*&nbsp; I hit SysRq, but nothing seems to happen, what's wrong?<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>There are some keyboards that produce a different keycode for SysRq than the<BR>pre-defined value of 99 (see KEY_SYSRQ in include/linux/input.h), or which<BR>don't have a SysRq key at all. In these cases, run 'showkey -s' to find an<BR>appropriate scancode sequence, and use 'setkeycodes &lt;sequence&gt; 99' to map<BR>this sequence to the usual SysRq code (e.g., 'setkeycodes e05b 99'). It's<BR>probably best to put this command in a boot script. Oh, and by the way, you<BR>exit 'showkey' by not typing anything for ten seconds.</P>
<P>*&nbsp; I want to add SysRQ key events to a module, how does it work?<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>In order to register a basic function with the table, you must first include<BR>the header 'include/linux/sysrq.h', this will define everything else you need.<BR>Next, you must create a sysrq_key_op struct, and populate it with A) the key<BR>handler function you will use, B) a help_msg string, that will print when SysRQ<BR>prints help, and C) an action_msg string, that will print right before your<BR>handler is called. Your handler must conform to the prototype in 'sysrq.h'.</P>
<P>After the sysrq_key_op is created, you can call the kernel function<BR>register_sysrq_key(int key, struct sysrq_key_op *op_p); this will<BR>register the operation pointed to by 'op_p' at table key 'key',<BR>if that slot in the table is blank. At module unload time, you must call<BR>the function unregister_sysrq_key(int key, struct sysrq_key_op *op_p), which<BR>will remove the key op pointed to by 'op_p' from the key 'key', if and only if<BR>it is currently registered in that slot. This is in case the slot has been<BR>overwritten since you registered it.</P>
<P>The Magic SysRQ system works by registering key operations against a key op<BR>lookup table, which is defined in 'drivers/char/sysrq.c'. This key table has<BR>a number of operations registered into it at compile time, but is mutable,<BR>and 2 functions are exported for interface to it:<BR>&nbsp;register_sysrq_key and unregister_sysrq_key.<BR>Of course, never ever leave an invalid pointer in the table. I.e., when<BR>your module that called register_sysrq_key() exits, it must call<BR>unregister_sysrq_key() to clean up the sysrq key table entry that it used.<BR>Null pointers in the table are always safe. :)</P>
<P>If for some reason you feel the need to call the handle_sysrq function from<BR>within a function called by handle_sysrq, you must be aware that you are in<BR>a lock (you are also in an interrupt handler, which means don't sleep!), so<BR>you must call __handle_sysrq_nolock instead.</P>
<P>*&nbsp; When I hit a SysRq key combination only the header appears on the console?<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>Sysrq output is subject to the same console loglevel control as all<BR>other console output.&nbsp; This means that if the kernel was booted 'quiet'<BR>as is common on distro kernels the output may not appear on the actual<BR>console, even though it will appear in the dmesg buffer, and be accessible<BR>via the dmesg command and to the consumers of /proc/kmsg.&nbsp; As a specific<BR>exception the header line from the sysrq command is passed to all console<BR>consumers as if the current loglevel was maximum.&nbsp; If only the header<BR>is emitted it is almost certain that the kernel loglevel is too low.<BR>Should you require the output on the console channel then you will need<BR>to temporarily up the console loglevel using alt-sysrq-8 or:</P>
<P>&nbsp;&nbsp;&nbsp; echo 8 &gt; /proc/sysrq-trigger</P>
<P>Remember to return the loglevel to normal after triggering the sysrq<BR>command you are interested in.</P>
<P>*&nbsp; I have more questions, who can I ask?<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>Just ask them on the linux-kernel mailing list:<BR>&nbsp;<A href="mailto:linux-kernel@vger.kernel.org">linux-kernel@vger.kernel.org</A></P>
<P>*&nbsp; Credits<BR>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>Written by Mydraal &lt;<A href="mailto:vulpyne@vulpyne.net">vulpyne@vulpyne.net</A>&gt;<BR>Updated by Adam Sulmicki &lt;<A href="mailto:adam@cfar.umd.edu">adam@cfar.umd.edu</A>&gt;<BR>Updated by Jeremy M. Dolan &lt;<A href="mailto:jmd@turbogeek.org">jmd@turbogeek.org</A>&gt; 2001/01/28 10:15:59<BR>Added to by Crutcher Dunnavant &lt;<A href="mailto:crutcher+kernel@datastacks.com">crutcher+kernel@datastacks.com</A>&gt;