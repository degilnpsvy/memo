# Documentation/virtual/kvm/devices/UserModeLinux-HOWTO.txt
<P></P>
<P>&nbsp; User Mode Linux HOWTO<BR>&nbsp; User Mode Linux Core Team<BR>&nbsp; Mon Nov 18 14:16:16 EST 2002</P>
<P></P>
<P>&nbsp; This document describes the use and abuse of Jeff Dike's User Mode<BR>&nbsp; Linux: a port of the Linux kernel as a normal Intel Linux process.<BR>&nbsp; ______________________________________________________________________</P>
<P>&nbsp; Table of Contents</P>
<P>&nbsp; 1. Introduction</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 1.1 How is User Mode Linux Different?<BR>&nbsp;&nbsp;&nbsp;&nbsp; 1.2 Why Would I Want User Mode Linux?</P>
<P>&nbsp; 2. Compiling the kernel and modules</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 2.1 Compiling the kernel<BR>&nbsp;&nbsp;&nbsp;&nbsp; 2.2 Compiling and installing kernel modules<BR>&nbsp;&nbsp;&nbsp;&nbsp; 2.3 Compiling and installing uml_utilities</P>
<P>&nbsp; 3. Running UML and logging in</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 3.1 Running UML<BR>&nbsp;&nbsp;&nbsp;&nbsp; 3.2 Logging in<BR>&nbsp;&nbsp;&nbsp;&nbsp; 3.3 Examples</P>
<P>&nbsp; 4. UML on 2G/2G hosts</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 4.1 Introduction<BR>&nbsp;&nbsp;&nbsp;&nbsp; 4.2 The problem<BR>&nbsp;&nbsp;&nbsp;&nbsp; 4.3 The solution</P>
<P>&nbsp; 5. Setting up serial lines and consoles</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 5.1 Specifying the device<BR>&nbsp;&nbsp;&nbsp;&nbsp; 5.2 Specifying the channel<BR>&nbsp;&nbsp;&nbsp;&nbsp; 5.3 Examples</P>
<P>&nbsp; 6. Setting up the network</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 6.1 General setup<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6.2 Userspace daemons<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6.3 Specifying ethernet addresses<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6.4 UML interface setup<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6.5 Multicast<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6.6 TUN/TAP with the uml_net helper<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6.7 TUN/TAP with a preconfigured tap device<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6.8 Ethertap<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6.9 The switch daemon<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6.10 Slip<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6.11 Slirp<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6.12 pcap<BR>&nbsp;&nbsp;&nbsp;&nbsp; 6.13 Setting up the host yourself</P>
<P>&nbsp; 7. Sharing Filesystems between Virtual Machines</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 7.1 A warning<BR>&nbsp;&nbsp;&nbsp;&nbsp; 7.2 Using layered block devices<BR>&nbsp;&nbsp;&nbsp;&nbsp; 7.3 Note!<BR>&nbsp;&nbsp;&nbsp;&nbsp; 7.4 Another warning<BR>&nbsp;&nbsp;&nbsp;&nbsp; 7.5 uml_moo : Merging a COW file with its backing file</P>
<P>&nbsp; 8. Creating filesystems</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 8.1 Create the filesystem file<BR>&nbsp;&nbsp;&nbsp;&nbsp; 8.2 Assign the file to a UML device<BR>&nbsp;&nbsp;&nbsp;&nbsp; 8.3 Creating and mounting the filesystem</P>
<P>&nbsp; 9. Host file access</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 9.1 Using hostfs<BR>&nbsp;&nbsp;&nbsp;&nbsp; 9.2 hostfs as the root filesystem<BR>&nbsp;&nbsp;&nbsp;&nbsp; 9.3 Building hostfs</P>
<P>&nbsp; 10. The Management Console<BR>&nbsp;&nbsp;&nbsp;&nbsp; 10.1 version<BR>&nbsp;&nbsp;&nbsp;&nbsp; 10.2 halt and reboot<BR>&nbsp;&nbsp;&nbsp;&nbsp; 10.3 config<BR>&nbsp;&nbsp;&nbsp;&nbsp; 10.4 remove<BR>&nbsp;&nbsp;&nbsp;&nbsp; 10.5 sysrq<BR>&nbsp;&nbsp;&nbsp;&nbsp; 10.6 help<BR>&nbsp;&nbsp;&nbsp;&nbsp; 10.7 cad<BR>&nbsp;&nbsp;&nbsp;&nbsp; 10.8 stop<BR>&nbsp;&nbsp;&nbsp;&nbsp; 10.9 go</P>
<P>&nbsp; 11. Kernel debugging</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 11.1 Starting the kernel under gdb<BR>&nbsp;&nbsp;&nbsp;&nbsp; 11.2 Examining sleeping processes<BR>&nbsp;&nbsp;&nbsp;&nbsp; 11.3 Running ddd on UML<BR>&nbsp;&nbsp;&nbsp;&nbsp; 11.4 Debugging modules<BR>&nbsp;&nbsp;&nbsp;&nbsp; 11.5 Attaching gdb to the kernel<BR>&nbsp;&nbsp;&nbsp;&nbsp; 11.6 Using alternate debuggers</P>
<P>&nbsp; 12. Kernel debugging examples</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 12.1 The case of the hung fsck<BR>&nbsp;&nbsp;&nbsp;&nbsp; 12.2 Episode 2: The case of the hung fsck</P>
<P>&nbsp; 13. What to do when UML doesn't work</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 13.1 Strange compilation errors when you build from source<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.2 (obsolete)<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.3 A variety of panics and hangs with /tmp on a reiserfs&nbsp; filesystem<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.4 The compile fails with errors about conflicting types for 'open', 'dup', and 'waitpid'<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.5 UML doesn't work when /tmp is an NFS filesystem<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.6 UML hangs on boot when compiled with gprof support<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.7 syslogd dies with a SIGTERM on startup<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.8 TUN/TAP networking doesn't work on a 2.4 host<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.9 You can network to the host but not to other machines on the net<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.10 I have no root and I want to scream<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.11 UML build conflict between ptrace.h and ucontext.h<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.12 The UML BogoMips is exactly half the host's BogoMips<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.13 When you run UML, it immediately segfaults<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.14 xterms appear, then immediately disappear<BR>&nbsp;&nbsp;&nbsp;&nbsp; 13.15 Any other panic, hang, or strange behavior</P>
<P>&nbsp; 14. Diagnosing Problems</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 14.1 Case 1 : Normal kernel panics<BR>&nbsp;&nbsp;&nbsp;&nbsp; 14.2 Case 2 : Tracing thread panics<BR>&nbsp;&nbsp;&nbsp;&nbsp; 14.3 Case 3 : Tracing thread panics caused by other threads<BR>&nbsp;&nbsp;&nbsp;&nbsp; 14.4 Case 4 : Hangs</P>
<P>&nbsp; 15. Thanks</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; 15.1 Code and Documentation<BR>&nbsp;&nbsp;&nbsp;&nbsp; 15.2 Flushing out bugs<BR>&nbsp;&nbsp;&nbsp;&nbsp; 15.3 Buglets and clean-ups<BR>&nbsp;&nbsp;&nbsp;&nbsp; 15.4 Case Studies<BR>&nbsp;&nbsp;&nbsp;&nbsp; 15.5 Other contributions</P>
<P><BR>&nbsp; ______________________________________________________________________</P>
<P>&nbsp; 1.&nbsp; Introduction</P>
<P>&nbsp; Welcome to User Mode Linux.&nbsp; It's going to be fun.</P>
<P>&nbsp;</P>
<P>&nbsp; 1.1.&nbsp; How is User Mode Linux Different?</P>
<P>&nbsp; Normally, the Linux Kernel talks straight to your hardware (video<BR>&nbsp; card, keyboard, hard drives, etc), and any programs which run ask the<BR>&nbsp; kernel to operate the hardware, like so:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----------+-----------+----+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Process 1 | Process 2 | ...|<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----------+-----------+----+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Linux Kernel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------------------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hardware&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------------------+</P>
<P>&nbsp;</P>
<P><BR>&nbsp; The User Mode Linux Kernel is different; instead of talking to the<BR>&nbsp; hardware, it talks to a `real' Linux kernel (called the `host kernel'<BR>&nbsp; from now on), like any other program.&nbsp; Programs can then run inside<BR>&nbsp; User-Mode Linux as if they were running under a normal kernel, like<BR>&nbsp; so:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Process 2 | ...|<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----------+----------------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Process 1 | User-Mode Linux|<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------------------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Linux Kernel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------------------+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hardware&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------------------------+</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; 1.2.&nbsp; Why Would I Want User Mode Linux?</P>
<P><BR>&nbsp; 1. If User Mode Linux crashes, your host kernel is still fine.</P>
<P>&nbsp; 2. You can run a usermode kernel as a non-root user.</P>
<P>&nbsp; 3. You can debug the User Mode Linux like any normal process.</P>
<P>&nbsp; 4. You can run gprof (profiling) and gcov (coverage testing).</P>
<P>&nbsp; 5. You can play with your kernel without breaking things.</P>
<P>&nbsp; 6. You can use it as a sandbox for testing new apps.</P>
<P>&nbsp; 7. You can try new development kernels safely.</P>
<P>&nbsp; 8. You can run different distributions simultaneously.</P>
<P>&nbsp; 9. It's extremely fun.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; 2.&nbsp; Compiling the kernel and modules</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 2.1.&nbsp; Compiling the kernel</P>
<P><BR>&nbsp; Compiling the user mode kernel is just like compiling any other<BR>&nbsp; kernel.&nbsp; Let's go through the steps, using 2.4.0-prerelease (current<BR>&nbsp; as of this writing) as an example:</P>
<P><BR>&nbsp; 1. Download the latest UML patch from</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; the download page &lt;<A href="http://user-mode-linux.sourceforge.net/">http://user-mode-linux.sourceforge.net/</A></P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; In this example, the file is uml-patch-2.4.0-prerelease.bz2.</P>
<P><BR>&nbsp; 2. Download the matching kernel from your favourite kernel mirror,<BR>&nbsp;&nbsp;&nbsp;&nbsp; such as:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; <A href="ftp://ftp.ca.kernel.org/pub/kernel/v2.4/linux-2.4.0-prerelease.tar.bz2">ftp://ftp.ca.kernel.org/pub/kernel/v2.4/linux-2.4.0-prerelease.tar.bz2</A><BR>&nbsp;&nbsp;&nbsp;&nbsp; &lt;<A href="ftp://ftp.ca.kernel.org/pub/kernel/v2.4/linux-2.4.0-prerelease.tar.bz2">ftp://ftp.ca.kernel.org/pub/kernel/v2.4/linux-2.4.0-prerelease.tar.bz2</A>&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp; .</P>
<P><BR>&nbsp; 3. Make a directory and unpack the kernel into it.</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host%<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mkdir ~/uml</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host%<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cd ~/uml</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host%<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tar -xzvf linux-2.4.0-prerelease.tar.bz2</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 4. Apply the patch using</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host%<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cd ~/uml/linux</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host%<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bzcat uml-patch-2.4.0-prerelease.bz2 | patch -p1</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 5. Run your favorite config; `make xconfig ARCH=um' is the most<BR>&nbsp;&nbsp;&nbsp;&nbsp; convenient.&nbsp; `make config ARCH=um' and 'make menuconfig ARCH=um'<BR>&nbsp;&nbsp;&nbsp;&nbsp; will work as well.&nbsp; The defaults will give you a useful kernel.&nbsp; If<BR>&nbsp;&nbsp;&nbsp;&nbsp; you want to change something, go ahead, it probably won't hurt<BR>&nbsp;&nbsp;&nbsp;&nbsp; anything.</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp; Note:&nbsp; If the host is configured with a 2G/2G address space split<BR>&nbsp;&nbsp;&nbsp;&nbsp; rather than the usual 3G/1G split, then the packaged UML binaries<BR>&nbsp;&nbsp;&nbsp;&nbsp; will not run.&nbsp; They will immediately segfault.&nbsp; See ``UML on 2G/2G<BR>&nbsp;&nbsp;&nbsp;&nbsp; hosts''&nbsp; for the scoop on running UML on your system.</P>
<P>&nbsp;</P>
<P>&nbsp; 6. Finish with `make linux ARCH=um': the result is a file called<BR>&nbsp;&nbsp;&nbsp;&nbsp; `linux' in the top directory of your source tree.</P>
<P>&nbsp; Make sure that you don't build this kernel in /usr/src/linux.&nbsp; On some<BR>&nbsp; distributions, /usr/include/asm is a link into this pool.&nbsp; The user-<BR>&nbsp; mode build changes the other end of that link, and things that include<BR>&nbsp; &lt;asm/anything.h&gt; stop compiling.</P>
<P>&nbsp; The sources are also available from cvs at the project's cvs page,<BR>&nbsp; which has directions on getting the sources. You can also browse the<BR>&nbsp; CVS pool from there.</P>
<P>&nbsp; If you get the CVS sources, you will have to check them out into an<BR>&nbsp; empty directory. You will then have to copy each file into the<BR>&nbsp; corresponding directory in the appropriate kernel pool.</P>
<P>&nbsp; If you don't have the latest kernel pool, you can get the<BR>&nbsp; corresponding user-mode sources with</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% cvs co -r v_2_3_x linux</P>
<P>&nbsp;</P>
<P><BR>&nbsp; where 'x' is the version in your pool. Note that you will not get the<BR>&nbsp; bug fixes and enhancements that have gone into subsequent releases.</P>
<P><BR>&nbsp; 2.2.&nbsp; Compiling and installing kernel modules</P>
<P>&nbsp; UML modules are built in the same way as the native kernel (with the<BR>&nbsp; exception of the 'ARCH=um' that you always need for UML):</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% make modules ARCH=um</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Any modules that you want to load into this kernel need to be built in<BR>&nbsp; the user-mode pool.&nbsp; Modules from the native kernel won't work.</P>
<P>&nbsp; You can install them by using ftp or something to copy them into the<BR>&nbsp; virtual machine and dropping them into /lib/modules/`uname -r`.</P>
<P>&nbsp; You can also get the kernel build process to install them as follows:</P>
<P>&nbsp; 1. with the kernel not booted, mount the root filesystem in the top<BR>&nbsp;&nbsp;&nbsp;&nbsp; level of the kernel pool:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% mount root_fs mnt -o loop</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 2. run</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host%<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make modules_install INSTALL_MOD_PATH=`pwd`/mnt ARCH=um</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 3. unmount the filesystem</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% umount mnt</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 4. boot the kernel on it</P>
<P><BR>&nbsp; When the system is booted, you can use insmod as usual to get the<BR>&nbsp; modules into the kernel.&nbsp; A number of things have been loaded into UML<BR>&nbsp; as modules, especially filesystems and network protocols and filters,<BR>&nbsp; so most symbols which need to be exported probably already are.<BR>&nbsp; However, if you do find symbols that need exporting, let&nbsp; us<BR>&nbsp; &lt;<A href="http://user-mode-linux.sourceforge.net/">http://user-mode-linux.sourceforge.net/</A>&gt;&nbsp; know, and<BR>&nbsp; they'll be "taken care of".</P>
<P>&nbsp;</P>
<P>&nbsp; 2.3.&nbsp; Compiling and installing uml_utilities</P>
<P>&nbsp; Many features of the UML kernel require a user-space helper program,<BR>&nbsp; so a uml_utilities package is distributed separately from the kernel<BR>&nbsp; patch which provides these helpers. Included within this is:</P>
<P>&nbsp; o&nbsp; port-helper - Used by consoles which connect to xterms or ports</P>
<P>&nbsp; o&nbsp; tunctl - Configuration tool to create and delete tap devices</P>
<P>&nbsp; o&nbsp; uml_net - Setuid binary for automatic tap device configuration</P>
<P>&nbsp; o&nbsp; uml_switch - User-space virtual switch required for daemon<BR>&nbsp;&nbsp;&nbsp;&nbsp; transport</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; The uml_utilities tree is compiled with:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make &amp;&amp; make install</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Note that UML kernel patches may require a specific version of the<BR>&nbsp; uml_utilities distribution. If you don't keep up with the mailing<BR>&nbsp; lists, ensure that you have the latest release of uml_utilities if you<BR>&nbsp; are experiencing problems with your UML kernel, particularly when<BR>&nbsp; dealing with consoles or command-line switches to the helper programs</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 3.&nbsp; Running UML and logging in</P>
<P>&nbsp;</P>
<P>&nbsp; 3.1.&nbsp; Running UML</P>
<P>&nbsp; It runs on 2.2.15 or later, and all 2.4 kernels.</P>
<P><BR>&nbsp; Booting UML is straightforward.&nbsp; Simply run 'linux': it will try to<BR>&nbsp; mount the file `root_fs' in the current directory.&nbsp; You do not need to<BR>&nbsp; run it as root.&nbsp; If your root filesystem is not named `root_fs', then<BR>&nbsp; you need to put a `ubd0=root_fs_whatever' switch on the linux command<BR>&nbsp; line.</P>
<P><BR>&nbsp; You will need a filesystem to boot UML from.&nbsp; There are a number<BR>&nbsp; available for download from&nbsp; here&nbsp; &lt;<A href="http://user-mode">http://user-mode</A>-<BR>&nbsp; linux.sourceforge.net/&gt; .&nbsp; There are also&nbsp; several tools<BR>&nbsp; &lt;<A href="http://user-mode-linux.sourceforge.net/">http://user-mode-linux.sourceforge.net/</A>&gt;&nbsp; which can be<BR>&nbsp; used to generate UML-compatible filesystem images from media.<BR>&nbsp; The kernel will boot up and present you with a login prompt.</P>
<P><BR>&nbsp; Note:&nbsp; If the host is configured with a 2G/2G address space split<BR>&nbsp; rather than the usual 3G/1G split, then the packaged UML binaries will<BR>&nbsp; not run.&nbsp; They will immediately segfault.&nbsp; See ``UML on 2G/2G hosts''<BR>&nbsp; for the scoop on running UML on your system.</P>
<P>&nbsp;</P>
<P>&nbsp; 3.2.&nbsp; Logging in</P>
<P>&nbsp;</P>
<P>&nbsp; The prepackaged filesystems have a root account with password 'root'<BR>&nbsp; and a user account with password 'user'.&nbsp; The login banner will<BR>&nbsp; generally tell you how to log in.&nbsp; So, you log in and you will find<BR>&nbsp; yourself inside a little virtual machine. Our filesystems have a<BR>&nbsp; variety of commands and utilities installed (and it is fairly easy to<BR>&nbsp; add more), so you will have a lot of tools with which to poke around<BR>&nbsp; the system.</P>
<P>&nbsp; There are a couple of other ways to log in:</P>
<P>&nbsp; o&nbsp; On a virtual console</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Each virtual console that is configured (i.e. the device exists in<BR>&nbsp;&nbsp;&nbsp;&nbsp; /dev and /etc/inittab runs a getty on it) will come up in its own<BR>&nbsp;&nbsp;&nbsp;&nbsp; xterm.&nbsp; If you get tired of the xterms, read ``Setting up serial<BR>&nbsp;&nbsp;&nbsp;&nbsp; lines and consoles''&nbsp; to see how to attach the consoles to<BR>&nbsp;&nbsp;&nbsp;&nbsp; something else, like host ptys.</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; Over the serial line</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp; In the boot output, find a line that looks like:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serial line 0 assigned pty /dev/ptyp1</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Attach your favorite terminal program to the corresponding tty.&nbsp; I.e.<BR>&nbsp; for minicom, the command would be</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% minicom -o -p /dev/ttyp1</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; o&nbsp; Over the net</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp; If the network is running, then you can telnet to the virtual<BR>&nbsp;&nbsp;&nbsp;&nbsp; machine and log in to it.&nbsp; See ``Setting up the network''&nbsp; to learn<BR>&nbsp;&nbsp;&nbsp;&nbsp; about setting up a virtual network.</P>
<P>&nbsp; When you're done using it, run halt, and the kernel will bring itself<BR>&nbsp; down and the process will exit.</P>
<P><BR>&nbsp; 3.3.&nbsp; Examples</P>
<P>&nbsp; Here are some examples of UML in action:</P>
<P>&nbsp; o&nbsp; A login session &lt;<A href="http://user-mode-linux.sourceforge.net/login.html">http://user-mode-linux.sourceforge.net/login.html</A>&gt;</P>
<P>&nbsp; o&nbsp; A virtual network &lt;<A href="http://user-mode-linux.sourceforge.net/net.html">http://user-mode-linux.sourceforge.net/net.html</A>&gt;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; 4.&nbsp; UML on 2G/2G hosts</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 4.1.&nbsp; Introduction</P>
<P><BR>&nbsp; Most Linux machines are configured so that the kernel occupies the<BR>&nbsp; upper 1G (0xc0000000 - 0xffffffff) of the 4G address space and<BR>&nbsp; processes use the lower 3G (0x00000000 - 0xbfffffff).&nbsp; However, some<BR>&nbsp; machine are configured with a 2G/2G split, with the kernel occupying<BR>&nbsp; the upper 2G (0x80000000 - 0xffffffff) and processes using the lower<BR>&nbsp; 2G (0x00000000 - 0x7fffffff).</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 4.2.&nbsp; The problem</P>
<P><BR>&nbsp; The prebuilt UML binaries on this site will not run on 2G/2G hosts<BR>&nbsp; because UML occupies the upper .5G of the 3G process address space<BR>&nbsp; (0xa0000000 - 0xbfffffff).&nbsp; Obviously, on 2G/2G hosts, this is right<BR>&nbsp; in the middle of the kernel address space, so UML won't even load - it<BR>&nbsp; will immediately segfault.</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 4.3.&nbsp; The solution</P>
<P><BR>&nbsp; The fix for this is to rebuild UML from source after enabling<BR>&nbsp; CONFIG_HOST_2G_2G (under 'General Setup').&nbsp; This will cause UML to<BR>&nbsp; load itself in the top .5G of that smaller process address space,<BR>&nbsp; where it will run fine.&nbsp; See ``Compiling the kernel and modules''&nbsp; if<BR>&nbsp; you need help building UML from source.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 5.&nbsp; Setting up serial lines and consoles</P>
<P><BR>&nbsp; It is possible to attach UML serial lines and consoles to many types<BR>&nbsp; of host I/O channels by specifying them on the command line.</P>
<P><BR>&nbsp; You can attach them to host ptys, ttys, file descriptors, and ports.<BR>&nbsp; This allows you to do things like</P>
<P>&nbsp; o&nbsp; have a UML console appear on an unused host console,</P>
<P>&nbsp; o&nbsp; hook two virtual machines together by having one attach to a pty<BR>&nbsp;&nbsp;&nbsp;&nbsp; and having the other attach to the corresponding tty</P>
<P>&nbsp; o&nbsp; make a virtual machine accessible from the net by attaching a<BR>&nbsp;&nbsp;&nbsp;&nbsp; console to a port on the host.</P>
<P><BR>&nbsp; The general format of the command line option is device=channel.</P>
<P>&nbsp;</P>
<P>&nbsp; 5.1.&nbsp; Specifying the device</P>
<P>&nbsp; Devices are specified with "con" or "ssl" (console or serial line,<BR>&nbsp; respectively), optionally with a device number if you are talking<BR>&nbsp; about a specific device.</P>
<P><BR>&nbsp; Using just "con" or "ssl" describes all of the consoles or serial<BR>&nbsp; lines.&nbsp; If you want to talk about console #3 or serial line #10, they<BR>&nbsp; would be "con3" and "ssl10", respectively.</P>
<P><BR>&nbsp; A specific device name will override a less general "con=" or "ssl=".<BR>&nbsp; So, for example, you can assign a pty to each of the serial lines<BR>&nbsp; except for the first two like this:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssl=pty ssl0=tty:/dev/tty0 ssl1=tty:/dev/tty1</P>
<P>&nbsp;</P>
<P><BR>&nbsp; The specificity of the device name is all that matters; order on the<BR>&nbsp; command line is irrelevant.</P>
<P>&nbsp;</P>
<P>&nbsp; 5.2.&nbsp; Specifying the channel</P>
<P>&nbsp; There are a number of different types of channels to attach a UML<BR>&nbsp; device to, each with a different way of specifying exactly what to<BR>&nbsp; attach to.</P>
<P>&nbsp; o&nbsp; pseudo-terminals - device=pty pts terminals - device=pts</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp; This will cause UML to allocate a free host pseudo-terminal for the<BR>&nbsp;&nbsp;&nbsp;&nbsp; device.&nbsp; The terminal that it got will be announced in the boot<BR>&nbsp;&nbsp;&nbsp;&nbsp; log.&nbsp; You access it by attaching a terminal program to the<BR>&nbsp;&nbsp;&nbsp;&nbsp; corresponding tty:</P>
<P>&nbsp; o&nbsp; screen /dev/pts/n</P>
<P>&nbsp; o&nbsp; screen /dev/ttyxx</P>
<P>&nbsp; o&nbsp; minicom -o -p /dev/ttyxx - minicom seems not able to handle pts<BR>&nbsp;&nbsp;&nbsp;&nbsp; devices</P>
<P>&nbsp; o&nbsp; kermit - start it up, 'open' the device, then 'connect'</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; terminals - device=tty:tty device file</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp; This will make UML attach the device to the specified tty (i.e</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; con1=tty:/dev/tty3</P>
<P>&nbsp;</P>
<P><BR>&nbsp; will attach UML's console 1 to the host's /dev/tty3).&nbsp; If the tty that<BR>&nbsp; you specify is the slave end of a tty/pty pair, something else must<BR>&nbsp; have already opened the corresponding pty in order for this to work.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; xterms - device=xterm</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp; UML will run an xterm and the device will be attached to it.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; Port - device=port:port number</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp; This will attach the UML devices to the specified host port.<BR>&nbsp;&nbsp;&nbsp;&nbsp; Attaching console 1 to the host's port 9000 would be done like<BR>&nbsp;&nbsp;&nbsp;&nbsp; this:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; con1=port:9000</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Attaching all the serial lines to that port would be done similarly:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssl=port:9000</P>
<P>&nbsp;</P>
<P><BR>&nbsp; You access these devices by telnetting to that port.&nbsp; Each active tel-<BR>&nbsp; net session gets a different device.&nbsp; If there are more telnets to a<BR>&nbsp; port than UML devices attached to it, then the extra telnet sessions<BR>&nbsp; will block until an existing telnet detaches, or until another device<BR>&nbsp; becomes active (i.e. by being activated in /etc/inittab).</P>
<P>&nbsp; This channel has the advantage that you can both attach multiple UML<BR>&nbsp; devices to it and know how to access them without reading the UML boot<BR>&nbsp; log.&nbsp; It is also unique in allowing access to a UML from remote<BR>&nbsp; machines without requiring that the UML be networked.&nbsp; This could be<BR>&nbsp; useful in allowing public access to UMLs because they would be<BR>&nbsp; accessible from the net, but wouldn't need any kind of network<BR>&nbsp; filtering or access control because they would have no network access.</P>
<P><BR>&nbsp; If you attach the main console to a portal, then the UML boot will<BR>&nbsp; appear to hang.&nbsp; In reality, it's waiting for a telnet to connect, at<BR>&nbsp; which point the boot will proceed.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; already-existing file descriptors - device=file descriptor</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp; If you set up a file descriptor on the UML command line, you can<BR>&nbsp;&nbsp;&nbsp;&nbsp; attach a UML device to it.&nbsp; This is most commonly used to put the<BR>&nbsp;&nbsp;&nbsp;&nbsp; main console back on stdin and stdout after assigning all the other<BR>&nbsp;&nbsp;&nbsp;&nbsp; consoles to something else:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; con0=fd:0,fd:1 con=pts</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; o&nbsp; Nothing - device=null</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp; This allows the device to be opened, in contrast to 'none', but<BR>&nbsp;&nbsp;&nbsp;&nbsp; reads will block, and writes will succeed and the data will be<BR>&nbsp;&nbsp;&nbsp;&nbsp; thrown out.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; None - device=none</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp; This causes the device to disappear.</P>
<P>&nbsp;</P>
<P>&nbsp; You can also specify different input and output channels for a device<BR>&nbsp; by putting a comma between them:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssl3=tty:/dev/tty2,xterm</P>
<P>&nbsp;</P>
<P><BR>&nbsp; will cause serial line 3 to accept input on the host's /dev/tty2 and<BR>&nbsp; display output on an xterm.&nbsp; That's a silly example - the most common<BR>&nbsp; use of this syntax is to reattach the main console to stdin and stdout<BR>&nbsp; as shown above.</P>
<P><BR>&nbsp; If you decide to move the main console away from stdin/stdout, the<BR>&nbsp; initial boot output will appear in the terminal that you're running<BR>&nbsp; UML in.&nbsp; However, once the console driver has been officially<BR>&nbsp; initialized, then the boot output will start appearing wherever you<BR>&nbsp; specified that console 0 should be.&nbsp; That device will receive all<BR>&nbsp; subsequent output.</P>
<P>&nbsp;</P>
<P>&nbsp; 5.3.&nbsp; Examples</P>
<P>&nbsp; There are a number of interesting things you can do with this<BR>&nbsp; capability.</P>
<P><BR>&nbsp; First, this is how you get rid of those bleeding console xterms by<BR>&nbsp; attaching them to host ptys:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; con=pty con0=fd:0,fd:1</P>
<P>&nbsp;</P>
<P><BR>&nbsp; This will make a UML console take over an unused host virtual console,<BR>&nbsp; so that when you switch to it, you will see the UML login prompt<BR>&nbsp; rather than the host login prompt:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; con1=tty:/dev/tty6</P>
<P>&nbsp;</P>
<P><BR>&nbsp; You can attach two virtual machines together with what amounts to a<BR>&nbsp; serial line as follows:</P>
<P>&nbsp; Run one UML with a serial line attached to a pty -</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssl1=pty</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Look at the boot log to see what pty it got (this example will assume<BR>&nbsp; that it got /dev/ptyp1).</P>
<P>&nbsp; Boot the other UML with a serial line attached to the corresponding<BR>&nbsp; tty -</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssl1=tty:/dev/ttyp1</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Log in, make sure that it has no getty on that serial line, attach a<BR>&nbsp; terminal program like minicom to it, and you should see the login<BR>&nbsp; prompt of the other virtual machine.</P>
<P><BR>&nbsp; 6.&nbsp; Setting up the network</P>
<P>&nbsp;</P>
<P>&nbsp; This page describes how to set up the various transports and to<BR>&nbsp; provide a UML instance with network access to the host, other machines<BR>&nbsp; on the local net, and the rest of the net.</P>
<P><BR>&nbsp; As of 2.4.5, UML networking has been completely redone to make it much<BR>&nbsp; easier to set up, fix bugs, and add new features.</P>
<P><BR>&nbsp; There is a new helper, uml_net, which does the host setup that<BR>&nbsp; requires root privileges.</P>
<P><BR>&nbsp; There are currently five transport types available for a UML virtual<BR>&nbsp; machine to exchange packets with other hosts:</P>
<P>&nbsp; o&nbsp; ethertap</P>
<P>&nbsp; o&nbsp; TUN/TAP</P>
<P>&nbsp; o&nbsp; Multicast</P>
<P>&nbsp; o&nbsp; a switch daemon</P>
<P>&nbsp; o&nbsp; slip</P>
<P>&nbsp; o&nbsp; slirp</P>
<P>&nbsp; o&nbsp; pcap</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; The TUN/TAP, ethertap, slip, and slirp transports allow a UML<BR>&nbsp;&nbsp;&nbsp;&nbsp; instance to exchange packets with the host.&nbsp; They may be directed<BR>&nbsp;&nbsp;&nbsp;&nbsp; to the host or the host may just act as a router to provide access<BR>&nbsp;&nbsp;&nbsp;&nbsp; to other physical or virtual machines.</P>
<P><BR>&nbsp; The pcap transport is a synthetic read-only interface, using the<BR>&nbsp; libpcap binary to collect packets from interfaces on the host and<BR>&nbsp; filter them.&nbsp; This is useful for building preconfigured traffic<BR>&nbsp; monitors or sniffers.</P>
<P><BR>&nbsp; The daemon and multicast transports provide a completely virtual<BR>&nbsp; network to other virtual machines.&nbsp; This network is completely<BR>&nbsp; disconnected from the physical network unless one of the virtual<BR>&nbsp; machines on it is acting as a gateway.</P>
<P><BR>&nbsp; With so many host transports, which one should you use?&nbsp; Here's when<BR>&nbsp; you should use each one:</P>
<P>&nbsp; o&nbsp; ethertap - if you want access to the host networking and it is<BR>&nbsp;&nbsp;&nbsp;&nbsp; running 2.2</P>
<P>&nbsp; o&nbsp; TUN/TAP - if you want access to the host networking and it is<BR>&nbsp;&nbsp;&nbsp;&nbsp; running 2.4.&nbsp; Also, the TUN/TAP transport is able to use a<BR>&nbsp;&nbsp;&nbsp;&nbsp; preconfigured device, allowing it to avoid using the setuid uml_net<BR>&nbsp;&nbsp;&nbsp;&nbsp; helper, which is a security advantage.</P>
<P>&nbsp; o&nbsp; Multicast - if you want a purely virtual network and you don't want<BR>&nbsp;&nbsp;&nbsp;&nbsp; to set up anything but the UML</P>
<P>&nbsp; o&nbsp; a switch daemon - if you want a purely virtual network and you<BR>&nbsp;&nbsp;&nbsp;&nbsp; don't mind running the daemon in order to get somewhat better<BR>&nbsp;&nbsp;&nbsp;&nbsp; performance</P>
<P>&nbsp; o&nbsp; slip - there is no particular reason to run the slip backend unless<BR>&nbsp;&nbsp;&nbsp;&nbsp; ethertap and TUN/TAP are just not available for some reason</P>
<P>&nbsp; o&nbsp; slirp - if you don't have root access on the host to setup<BR>&nbsp;&nbsp;&nbsp;&nbsp; networking, or if you don't want to allocate an IP to your UML</P>
<P>&nbsp; o&nbsp; pcap - not much use for actual network connectivity, but great for<BR>&nbsp;&nbsp;&nbsp;&nbsp; monitoring traffic on the host</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Ethertap is available on 2.4 and works fine.&nbsp; TUN/TAP is preferred<BR>&nbsp;&nbsp;&nbsp;&nbsp; to it because it has better performance and ethertap is officially<BR>&nbsp;&nbsp;&nbsp;&nbsp; considered obsolete in 2.4.&nbsp; Also, the root helper only needs to<BR>&nbsp;&nbsp;&nbsp;&nbsp; run occasionally for TUN/TAP, rather than handling every packet, as<BR>&nbsp;&nbsp;&nbsp;&nbsp; it does with ethertap.&nbsp; This is a slight security advantage since<BR>&nbsp;&nbsp;&nbsp;&nbsp; it provides fewer opportunities for a nasty UML user to somehow<BR>&nbsp;&nbsp;&nbsp;&nbsp; exploit the helper's root privileges.</P>
<P><BR>&nbsp; 6.1.&nbsp; General setup</P>
<P>&nbsp; First, you must have the virtual network enabled in your UML.&nbsp; If are<BR>&nbsp; running a prebuilt kernel from this site, everything is already<BR>&nbsp; enabled.&nbsp; If you build the kernel yourself, under the "Network device<BR>&nbsp; support" menu, enable "Network device support", and then the three<BR>&nbsp; transports.</P>
<P><BR>&nbsp; The next step is to provide a network device to the virtual machine.<BR>&nbsp; This is done by describing it on the kernel command line.</P>
<P>&nbsp; The general format is</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eth &lt;n&gt; = &lt;transport&gt; , &lt;transport args&gt;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; For example, a virtual ethernet device may be attached to a host<BR>&nbsp; ethertap device as follows:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eth0=ethertap,tap0,fe:fd:0:0:0:1,192.168.0.254</P>
<P>&nbsp;</P>
<P><BR>&nbsp; This sets up eth0 inside the virtual machine to attach itself to the<BR>&nbsp; host /dev/tap0, assigns it an ethernet address, and assigns the host<BR>&nbsp; tap0 interface an IP address.</P>
<P>&nbsp;</P>
<P>&nbsp; Note that the IP address you assign to the host end of the tap device<BR>&nbsp; must be different than the IP you assign to the eth device inside UML.<BR>&nbsp; If you are short on IPs and don't want to consume two per UML, then<BR>&nbsp; you can reuse the host's eth IP address for the host ends of the tap<BR>&nbsp; devices.&nbsp; Internally, the UMLs must still get unique IPs for their eth<BR>&nbsp; devices.&nbsp; You can also give the UMLs non-routable IPs (192.168.x.x or<BR>&nbsp; 10.x.x.x) and have the host masquerade them.&nbsp; This will let outgoing<BR>&nbsp; connections work, but incoming connections won't without more work,<BR>&nbsp; such as port forwarding from the host.<BR>&nbsp; Also note that when you configure the host side of an interface, it is<BR>&nbsp; only acting as a gateway.&nbsp; It will respond to pings sent to it<BR>&nbsp; locally, but is not useful to do that since it's a host interface.<BR>&nbsp; You are not talking to the UML when you ping that interface and get a<BR>&nbsp; response.</P>
<P><BR>&nbsp; You can also add devices to a UML and remove them at runtime.&nbsp; See the<BR>&nbsp; ``The Management Console''&nbsp; page for details.</P>
<P><BR>&nbsp; The sections below describe this in more detail.</P>
<P><BR>&nbsp; Once you've decided how you're going to set up the devices, you boot<BR>&nbsp; UML, log in, configure the UML side of the devices, and set up routes<BR>&nbsp; to the outside world.&nbsp; At that point, you will be able to talk to any<BR>&nbsp; other machines, physical or virtual, on the net.</P>
<P><BR>&nbsp; If ifconfig inside UML fails and the network refuses to come up, run<BR>&nbsp; tell you what went wrong.</P>
<P>&nbsp;</P>
<P>&nbsp; 6.2.&nbsp; Userspace daemons</P>
<P>&nbsp; You will likely need the setuid helper, or the switch daemon, or both.<BR>&nbsp; They are both installed with the RPM and deb, so if you've installed<BR>&nbsp; either, you can skip the rest of this section.</P>
<P><BR>&nbsp; If not, then you need to check them out of CVS, build them, and<BR>&nbsp; install them.&nbsp; The helper is uml_net, in CVS /tools/uml_net, and the<BR>&nbsp; daemon is uml_switch, in CVS /tools/uml_router.&nbsp; They are both built<BR>&nbsp; with a plain 'make'.&nbsp; Both need to be installed in a directory that's<BR>&nbsp; in your path - /usr/bin is recommend.&nbsp; On top of that, uml_net needs<BR>&nbsp; to be setuid root.</P>
<P>&nbsp;</P>
<P>&nbsp; 6.3.&nbsp; Specifying ethernet addresses</P>
<P>&nbsp; Below, you will see that the TUN/TAP, ethertap, and daemon interfaces<BR>&nbsp; allow you to specify hardware addresses for the virtual ethernet<BR>&nbsp; devices.&nbsp; This is generally not necessary.&nbsp; If you don't have a<BR>&nbsp; specific reason to do it, you probably shouldn't.&nbsp; If one is not<BR>&nbsp; specified on the command line, the driver will assign one based on the<BR>&nbsp; device IP address.&nbsp; It will provide the address fe:fd:nn:nn:nn:nn<BR>&nbsp; where nn.nn.nn.nn is the device IP address.&nbsp; This is nearly always<BR>&nbsp; sufficient to guarantee a unique hardware address for the device.&nbsp; A<BR>&nbsp; couple of exceptions are:</P>
<P>&nbsp; o&nbsp; Another set of virtual ethernet devices are on the same network and<BR>&nbsp;&nbsp;&nbsp;&nbsp; they are assigned hardware addresses using a different scheme which<BR>&nbsp;&nbsp;&nbsp;&nbsp; may conflict with the UML IP address-based scheme</P>
<P>&nbsp; o&nbsp; You aren't going to use the device for IP networking, so you don't<BR>&nbsp;&nbsp;&nbsp;&nbsp; assign the device an IP address</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; If you let the driver provide the hardware address, you should make<BR>&nbsp;&nbsp;&nbsp;&nbsp; sure that the device IP address is known before the interface is<BR>&nbsp;&nbsp;&nbsp;&nbsp; brought up.&nbsp; So, inside UML, this will guarantee that:</P>
<P>&nbsp;</P>
<P>&nbsp; UML#<BR>&nbsp; ifconfig eth0 192.168.0.250 up</P>
<P>&nbsp;</P>
<P><BR>&nbsp; If you decide to assign the hardware address yourself, make sure that<BR>&nbsp; the first byte of the address is even.&nbsp; Addresses with an odd first<BR>&nbsp; byte are broadcast addresses, which you don't want assigned to a<BR>&nbsp; device.</P>
<P>&nbsp;</P>
<P>&nbsp; 6.4.&nbsp; UML interface setup</P>
<P>&nbsp; Once the network devices have been described on the command line, you<BR>&nbsp; should boot UML and log in.</P>
<P><BR>&nbsp; The first thing to do is bring the interface up:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML# ifconfig ethn ip-address up</P>
<P>&nbsp;</P>
<P><BR>&nbsp; You should be able to ping the host at this point.</P>
<P><BR>&nbsp; To reach the rest of the world, you should set a default route to the<BR>&nbsp; host:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML# route add default gw host ip</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Again, with host ip of 192.168.0.4:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML# route add default gw 192.168.0.4</P>
<P>&nbsp;</P>
<P><BR>&nbsp; This page used to recommend setting a network route to your local net.<BR>&nbsp; This is wrong, because it will cause UML to try to figure out hardware<BR>&nbsp; addresses of the local machines by arping on the interface to the<BR>&nbsp; host.&nbsp; Since that interface is basically a single strand of ethernet<BR>&nbsp; with two nodes on it (UML and the host) and arp requests don't cross<BR>&nbsp; networks, they will fail to elicit any responses.&nbsp; So, what you want<BR>&nbsp; is for UML to just blindly throw all packets at the host and let it<BR>&nbsp; figure out what to do with them, which is what leaving out the network<BR>&nbsp; route and adding the default route does.</P>
<P><BR>&nbsp; Note: If you can't communicate with other hosts on your physical<BR>&nbsp; ethernet, it's probably because of a network route that's<BR>&nbsp; automatically set up.&nbsp; If you run 'route -n' and see a route that<BR>&nbsp; looks like this:</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Destination&nbsp;&nbsp;&nbsp;&nbsp; Gateway&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Genmask&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Flags Metric Ref&nbsp;&nbsp;&nbsp; Use Iface<BR>&nbsp; 192.168.0.0&nbsp;&nbsp;&nbsp;&nbsp; 0.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 255.255.255.0&nbsp;&nbsp; U&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp; eth0</P>
<P>&nbsp;</P>
<P><BR>&nbsp; with a mask that's not 255.255.255.255, then replace it with a route<BR>&nbsp; to your host:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; route del -net 192.168.0.0 dev eth0 netmask 255.255.255.0</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; route add -host 192.168.0.4 dev eth0</P>
<P>&nbsp;</P>
<P><BR>&nbsp; This, plus the default route to the host, will allow UML to exchange<BR>&nbsp; packets with any machine on your ethernet.</P>
<P>&nbsp;</P>
<P>&nbsp; 6.5.&nbsp; Multicast</P>
<P>&nbsp; The simplest way to set up a virtual network between multiple UMLs is<BR>&nbsp; to use the mcast transport.&nbsp; This was written by Harald Welte and is<BR>&nbsp; present in UML version 2.4.5-5um and later.&nbsp; Your system must have<BR>&nbsp; multicast enabled in the kernel and there must be a multicast-capable<BR>&nbsp; network device on the host.&nbsp; Normally, this is eth0, but if there is<BR>&nbsp; no ethernet card on the host, then you will likely get strange error<BR>&nbsp; messages when you bring the device up inside UML.</P>
<P><BR>&nbsp; To use it, run two UMLs with</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eth0=mcast</P>
<P>&nbsp;</P>
<P><BR>&nbsp; on their command lines.&nbsp; Log in, configure the ethernet device in each<BR>&nbsp; machine with different IP addresses:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML1# ifconfig eth0 192.168.0.254</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML2# ifconfig eth0 192.168.0.253</P>
<P>&nbsp;</P>
<P><BR>&nbsp; and they should be able to talk to each other.</P>
<P>&nbsp; The full set of command line options for this transport are</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethn=mcast,ethernet address,multicast<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address,multicast port,ttl</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Harald's original README is here &lt;<A href="http://user-mode-linux.source">http://user-mode-linux.source</A>-<BR>&nbsp; forge.net/&gt;&nbsp; and explains these in detail, as well as<BR>&nbsp; some other issues.</P>
<P>&nbsp; There is also a related point-to-point only "ucast" transport.<BR>&nbsp; This is useful when your network does not support multicast, and<BR>&nbsp; all network connections are simple point to point links.</P>
<P>&nbsp; The full set of command line options for this transport are</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethn=ucast,ethernet address,remote address,listen port,remote port</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 6.6.&nbsp; TUN/TAP with the uml_net helper</P>
<P>&nbsp; TUN/TAP is the preferred mechanism on 2.4 to exchange packets with the<BR>&nbsp; host.&nbsp; The TUN/TAP backend has been in UML since 2.4.9-3um.</P>
<P><BR>&nbsp; The easiest way to get up and running is to let the setuid uml_net<BR>&nbsp; helper do the host setup for you.&nbsp; This involves insmod-ing the tun.o<BR>&nbsp; module if necessary, configuring the device, and setting up IP<BR>&nbsp; forwarding, routing, and proxy arp.&nbsp; If you are new to UML networking,<BR>&nbsp; do this first.&nbsp; If you're concerned about the security implications of<BR>&nbsp; the setuid helper, use it to get up and running, then read the next<BR>&nbsp; section to see how to have UML use a preconfigured tap device, which<BR>&nbsp; avoids the use of uml_net.</P>
<P><BR>&nbsp; If you specify an IP address for the host side of the device, the<BR>&nbsp; uml_net helper will do all necessary setup on the host - the only<BR>&nbsp; requirement is that TUN/TAP be available, either built in to the host<BR>&nbsp; kernel or as the tun.o module.</P>
<P>&nbsp; The format of the command line switch to attach a device to a TUN/TAP<BR>&nbsp; device is</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eth &lt;n&gt; =tuntap,,, &lt;IP address&gt;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; For example, this argument will attach the UML's eth0 to the next<BR>&nbsp; available tap device and assign an ethernet address to it based on its<BR>&nbsp; IP address</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eth0=tuntap,,,192.168.0.254</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Note that the IP address that must be used for the eth device inside<BR>&nbsp; UML is fixed by the routing and proxy arp that is set up on the<BR>&nbsp; TUN/TAP device on the host.&nbsp; You can use a different one, but it won't<BR>&nbsp; work because reply packets won't reach the UML.&nbsp; This is a feature.<BR>&nbsp; It prevents a nasty UML user from doing things like setting the UML IP<BR>&nbsp; to the same as the network's nameserver or mail server.</P>
<P><BR>&nbsp; There are a couple potential problems with running the TUN/TAP<BR>&nbsp; transport on a 2.4 host kernel</P>
<P>&nbsp; o&nbsp; TUN/TAP seems not to work on 2.4.3 and earlier.&nbsp; Upgrade the host<BR>&nbsp;&nbsp;&nbsp;&nbsp; kernel or use the ethertap transport.</P>
<P>&nbsp; o&nbsp; With an upgraded kernel, TUN/TAP may fail with</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File descriptor in bad state</P>
<P>&nbsp;</P>
<P><BR>&nbsp; This is due to a header mismatch between the upgraded kernel and the<BR>&nbsp; kernel that was originally installed on the machine.&nbsp; The fix is to<BR>&nbsp; make sure that /usr/src/linux points to the headers for the running<BR>&nbsp; kernel.</P>
<P>&nbsp; These were pointed out by Tim Robinson &lt;timro at trkr dot net&gt; in<BR>&nbsp; &lt;<A href="http://www.geocrawler.com/">http://www.geocrawler.com/</A>&gt; name="this uml-<BR>&nbsp; user post"&gt; .</P>
<P>&nbsp;</P>
<P>&nbsp; 6.7.&nbsp; TUN/TAP with a preconfigured tap device</P>
<P>&nbsp; If you prefer not to have UML use uml_net (which is somewhat<BR>&nbsp; insecure), with UML 2.4.17-11, you can set up a TUN/TAP device<BR>&nbsp; beforehand.&nbsp; The setup needs to be done as root, but once that's done,<BR>&nbsp; there is no need for root assistance.&nbsp; Setting up the device is done<BR>&nbsp; as follows:</P>
<P>&nbsp; o&nbsp; Create the device with tunctl (available from the UML utilities<BR>&nbsp;&nbsp;&nbsp;&nbsp; tarball)</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#&nbsp; tunctl -u uid</P>
<P>&nbsp;</P>
<P><BR>&nbsp; where uid is the user id or username that UML will be run as.&nbsp; This<BR>&nbsp; will tell you what device was created.</P>
<P>&nbsp; o&nbsp; Configure the device IP (change IP addresses and device name to<BR>&nbsp;&nbsp;&nbsp;&nbsp; suit)</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#&nbsp; ifconfig tap0 192.168.0.254 up</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; Set up routing and arping if desired - this is my recipe, there are<BR>&nbsp;&nbsp;&nbsp;&nbsp; other ways of doing the same thing</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bash -c 'echo 1 &gt; /proc/sys/net/ipv4/ip_forward'</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; route add -host 192.168.0.253 dev tap0</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bash -c 'echo 1 &gt; /proc/sys/net/ipv4/conf/tap0/proxy_arp'</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp -Ds 192.168.0.253 eth0 pub</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Note that this must be done every time the host boots - this configu-<BR>&nbsp; ration is not stored across host reboots.&nbsp; So, it's probably a good<BR>&nbsp; idea to stick it in an rc file.&nbsp; An even better idea would be a little<BR>&nbsp; utility which reads the information from a config file and sets up<BR>&nbsp; devices at boot time.</P>
<P>&nbsp; o&nbsp; Rather than using up two IPs and ARPing for one of them, you can<BR>&nbsp;&nbsp;&nbsp;&nbsp; also provide direct access to your LAN by the UML by using a<BR>&nbsp;&nbsp;&nbsp;&nbsp; bridge.</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brctl addbr br0</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ifconfig eth0 0.0.0.0 promisc up</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ifconfig tap0 0.0.0.0 promisc up</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ifconfig br0 192.168.0.1 netmask 255.255.255.0 up</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; host#<BR>&nbsp; brctl stp br0 off</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brctl setfd br0 1</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brctl sethello br0 1</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brctl addif br0 eth0</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brctl addif br0 tap0</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Note that 'br0' should be setup using ifconfig with the existing IP<BR>&nbsp; address of eth0, as eth0 no longer has its own IP.</P>
<P>&nbsp; o</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp; Also, the /dev/net/tun device must be writable by the user running<BR>&nbsp;&nbsp;&nbsp;&nbsp; UML in order for the UML to use the device that's been configured<BR>&nbsp;&nbsp;&nbsp;&nbsp; for it.&nbsp; The simplest thing to do is</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#&nbsp; chmod 666 /dev/net/tun</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Making it world-writable looks bad, but it seems not to be<BR>&nbsp; exploitable as a security hole.&nbsp; However, it does allow anyone to cre-<BR>&nbsp; ate useless tap devices (useless because they can't configure them),<BR>&nbsp; which is a DOS attack.&nbsp; A somewhat more secure alternative would to be<BR>&nbsp; to create a group containing all the users who have preconfigured tap<BR>&nbsp; devices and chgrp /dev/net/tun to that group with mode 664 or 660.</P>
<P><BR>&nbsp; o&nbsp; Once the device is set up, run UML with 'eth0=tuntap,device name'<BR>&nbsp;&nbsp;&nbsp;&nbsp; (i.e. 'eth0=tuntap,tap0') on the command line (or do it with the<BR>&nbsp;&nbsp;&nbsp;&nbsp; mconsole config command).</P>
<P>&nbsp; o&nbsp; Bring the eth device up in UML and you're in business.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; If you don't want that tap device any more, you can make it non-<BR>&nbsp;&nbsp;&nbsp;&nbsp; persistent with</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#&nbsp; tunctl -d tap device</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Finally, tunctl has a -b (for brief mode) switch which causes it to<BR>&nbsp; output only the name of the tap device it created.&nbsp; This makes it<BR>&nbsp; suitable for capture by a script:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#&nbsp; TAP=`tunctl -u 1000 -b`</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 6.8.&nbsp; Ethertap</P>
<P>&nbsp; Ethertap is the general mechanism on 2.2 for userspace processes to<BR>&nbsp; exchange packets with the kernel.</P>
<P>&nbsp;</P>
<P>&nbsp; To use this transport, you need to describe the virtual network device<BR>&nbsp; on the UML command line.&nbsp; The general format for this is</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eth &lt;n&gt; =ethertap, &lt;device&gt; , &lt;ethernet address&gt; , &lt;tap IP address&gt;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; So, the previous example</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eth0=ethertap,tap0,fe:fd:0:0:0:1,192.168.0.254</P>
<P>&nbsp;</P>
<P><BR>&nbsp; attaches the UML eth0 device to the host /dev/tap0, assigns it the<BR>&nbsp; ethernet address fe:fd:0:0:0:1, and assigns the IP address<BR>&nbsp; 192.168.0.254 to the tap device.</P>
<P>&nbsp;</P>
<P>&nbsp; The tap device is mandatory, but the others are optional.&nbsp; If the<BR>&nbsp; ethernet address is omitted, one will be assigned to it.</P>
<P><BR>&nbsp; The presence of the tap IP address will cause the helper to run and do<BR>&nbsp; whatever host setup is needed to allow the virtual machine to<BR>&nbsp; communicate with the outside world.&nbsp; If you're not sure you know what<BR>&nbsp; you're doing, this is the way to go.</P>
<P><BR>&nbsp; If it is absent, then you must configure the tap device and whatever<BR>&nbsp; arping and routing you will need on the host.&nbsp; However, even in this<BR>&nbsp; case, the uml_net helper still needs to be in your path and it must be<BR>&nbsp; setuid root if you're not running UML as root.&nbsp; This is because the<BR>&nbsp; tap device doesn't support SIGIO, which UML needs in order to use<BR>&nbsp; something as a source of input.&nbsp; So, the helper is used as a<BR>&nbsp; convenient asynchronous IO thread.</P>
<P>&nbsp; If you're using the uml_net helper, you can ignore the following host<BR>&nbsp; setup - uml_net will do it for you.&nbsp; You just need to make sure you<BR>&nbsp; have ethertap available, either built in to the host kernel or<BR>&nbsp; available as a module.</P>
<P><BR>&nbsp; If you want to set things up yourself, you need to make sure that the<BR>&nbsp; appropriate /dev entry exists.&nbsp; If it doesn't, become root and create<BR>&nbsp; it as follows:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mknod /dev/tap &lt;minor&gt;&nbsp; c 36&nbsp; &lt;minor&gt;&nbsp; + 16</P>
<P>&nbsp;</P>
<P><BR>&nbsp; For example, this is how to create /dev/tap0:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mknod /dev/tap0 c 36 0 + 16</P>
<P>&nbsp;</P>
<P><BR>&nbsp; You also need to make sure that the host kernel has ethertap support.<BR>&nbsp; If ethertap is enabled as a module, you apparently need to insmod<BR>&nbsp; ethertap once for each ethertap device you want to enable.&nbsp; So,</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insmod ethertap</P>
<P>&nbsp;</P>
<P><BR>&nbsp; will give you the tap0 interface.&nbsp; To get the tap1 interface, you need<BR>&nbsp; to run</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insmod ethertap unit=1 -o ethertap1</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; 6.9.&nbsp; The switch daemon</P>
<P>&nbsp; Note: This is the daemon formerly known as uml_router, but which was<BR>&nbsp; renamed so the network weenies of the world would stop growling at me.</P>
<P><BR>&nbsp; The switch daemon, uml_switch, provides a mechanism for creating a<BR>&nbsp; totally virtual network.&nbsp; By default, it provides no connection to the<BR>&nbsp; host network (but see -tap, below).</P>
<P><BR>&nbsp; The first thing you need to do is run the daemon.&nbsp; Running it with no<BR>&nbsp; arguments will make it listen on a default pair of unix domain<BR>&nbsp; sockets.</P>
<P><BR>&nbsp; If you want it to listen on a different pair of sockets, use</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -unix control socket data socket</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; If you want it to act as a hub rather than a switch, use</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -hub</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; If you want the switch to be connected to host networking (allowing<BR>&nbsp; the umls to get access to the outside world through the host), use</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -tap tap0</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; Note that the tap device must be preconfigured (see "TUN/TAP with a<BR>&nbsp; preconfigured tap device", above).&nbsp; If you're using a different tap<BR>&nbsp; device than tap0, specify that instead of tap0.</P>
<P><BR>&nbsp; uml_switch can be backgrounded as follows</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host%<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uml_switch [ options ] &lt; /dev/null &gt; /dev/null</P>
<P>&nbsp;</P>
<P><BR>&nbsp; The reason it doesn't background by default is that it listens to<BR>&nbsp; stdin for EOF.&nbsp; When it sees that, it exits.</P>
<P><BR>&nbsp; The general format of the kernel command line switch is</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethn=daemon,ethernet address,socket<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type,control socket,data socket</P>
<P>&nbsp;</P>
<P><BR>&nbsp; You can leave off everything except the 'daemon'.&nbsp; You only need to<BR>&nbsp; specify the ethernet address if the one that will be assigned to it<BR>&nbsp; isn't acceptable for some reason.&nbsp; The rest of the arguments describe<BR>&nbsp; how to communicate with the daemon.&nbsp; You should only specify them if<BR>&nbsp; you told the daemon to use different sockets than the default.&nbsp; So, if<BR>&nbsp; you ran the daemon with no arguments, running the UML on the same<BR>&nbsp; machine with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eth0=daemon</P>
<P>&nbsp;</P>
<P><BR>&nbsp; will cause the eth0 driver to attach itself to the daemon correctly.</P>
<P>&nbsp;</P>
<P>&nbsp; 6.10.&nbsp; Slip</P>
<P>&nbsp; Slip is another, less general, mechanism for a process to communicate<BR>&nbsp; with the host networking.&nbsp; In contrast to the ethertap interface,<BR>&nbsp; which exchanges ethernet frames with the host and can be used to<BR>&nbsp; transport any higher-level protocol, it can only be used to transport<BR>&nbsp; IP.</P>
<P><BR>&nbsp; The general format of the command line switch is</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethn=slip,slip IP</P>
<P>&nbsp;</P>
<P><BR>&nbsp; The slip IP argument is the IP address that will be assigned to the<BR>&nbsp; host end of the slip device.&nbsp; If it is specified, the helper will run<BR>&nbsp; and will set up the host so that the virtual machine can reach it and<BR>&nbsp; the rest of the network.</P>
<P><BR>&nbsp; There are some oddities with this interface that you should be aware<BR>&nbsp; of.&nbsp; You should only specify one slip device on a given virtual<BR>&nbsp; machine, and its name inside UML will be 'umn', not 'eth0' or whatever<BR>&nbsp; you specified on the command line.&nbsp; These problems will be fixed at<BR>&nbsp; some point.</P>
<P>&nbsp;</P>
<P>&nbsp; 6.11.&nbsp; Slirp</P>
<P>&nbsp; slirp uses an external program, usually /usr/bin/slirp, to provide IP<BR>&nbsp; only networking connectivity through the host. This is similar to IP<BR>&nbsp; masquerading with a firewall, although the translation is performed in<BR>&nbsp; user-space, rather than by the kernel.&nbsp; As slirp does not set up any<BR>&nbsp; interfaces on the host, or changes routing, slirp does not require<BR>&nbsp; root access or setuid binaries on the host.</P>
<P><BR>&nbsp; The general format of the command line switch for slirp is:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethn=slirp,ethernet address,slirp path</P>
<P>&nbsp;</P>
<P><BR>&nbsp; The ethernet address is optional, as UML will set up the interface<BR>&nbsp; with an ethernet address based upon the initial IP address of the<BR>&nbsp; interface.&nbsp; The slirp path is generally /usr/bin/slirp, although it<BR>&nbsp; will depend on distribution.</P>
<P><BR>&nbsp; The slirp program can have a number of options passed to the command<BR>&nbsp; line and we can't add them to the UML command line, as they will be<BR>&nbsp; parsed incorrectly.&nbsp; Instead, a wrapper shell script can be written or<BR>&nbsp; the options inserted into the&nbsp; /.slirprc file.&nbsp; More information on<BR>&nbsp; all of the slirp options can be found in its man pages.</P>
<P><BR>&nbsp; The eth0 interface on UML should be set up with the IP 10.2.0.15,<BR>&nbsp; although you can use anything as long as it is not used by a network<BR>&nbsp; you will be connecting to. The default route on UML should be set to<BR>&nbsp; use</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; route add default dev eth0</P>
<P>&nbsp;</P>
<P><BR>&nbsp; slirp provides a number of useful IP addresses which can be used by<BR>&nbsp; UML, such as 10.0.2.3 which is an alias for the DNS server specified<BR>&nbsp; in /etc/resolv.conf on the host or the IP given in the 'dns' option<BR>&nbsp; for slirp.</P>
<P><BR>&nbsp; Even with a baudrate setting higher than 115200, the slirp connection<BR>&nbsp; is limited to 115200. If you need it to go faster, the slirp binary<BR>&nbsp; needs to be compiled with FULL_BOLT defined in config.h.</P>
<P>&nbsp;</P>
<P>&nbsp; 6.12.&nbsp; pcap</P>
<P>&nbsp; The pcap transport is attached to a UML ethernet device on the command<BR>&nbsp; line or with uml_mconsole with the following syntax:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ethn=pcap,host interface,filter<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression,option1,option2</P>
<P>&nbsp;</P>
<P><BR>&nbsp; The expression and options are optional.</P>
<P><BR>&nbsp; The interface is whatever network device on the host you want to<BR>&nbsp; sniff.&nbsp; The expression is a pcap filter expression, which is also what<BR>&nbsp; tcpdump uses, so if you know how to specify tcpdump filters, you will<BR>&nbsp; use the same expressions here.&nbsp; The options are up to two of<BR>&nbsp; 'promisc', control whether pcap puts the host interface into<BR>&nbsp; promiscuous mode. 'optimize' and 'nooptimize' control whether the pcap<BR>&nbsp; expression optimizer is used.</P>
<P><BR>&nbsp; Example:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eth0=pcap,eth0,tcp</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eth1=pcap,eth0,!tcp</P>
<P>&nbsp;</P>
<P>&nbsp; will cause the UML eth0 to emit all tcp packets on the host eth0 and<BR>&nbsp; the UML eth1 to emit all non-tcp packets on the host eth0.</P>
<P>&nbsp;</P>
<P>&nbsp; 6.13.&nbsp; Setting up the host yourself</P>
<P>&nbsp; If you don't specify an address for the host side of the ethertap or<BR>&nbsp; slip device, UML won't do any setup on the host.&nbsp; So this is what is<BR>&nbsp; needed to get things working (the examples use a host-side IP of<BR>&nbsp; 192.168.0.251 and a UML-side IP of 192.168.0.250 - adjust to suit your<BR>&nbsp; own network):</P>
<P>&nbsp; o&nbsp; The device needs to be configured with its IP address.&nbsp; Tap devices<BR>&nbsp;&nbsp;&nbsp;&nbsp; are also configured with an mtu of 1484.&nbsp; Slip devices are<BR>&nbsp;&nbsp;&nbsp;&nbsp; configured with a point-to-point address pointing at the UML ip<BR>&nbsp;&nbsp;&nbsp;&nbsp; address.</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#&nbsp; ifconfig tap0 arp mtu 1484 192.168.0.251 up</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ifconfig sl0 192.168.0.251 pointopoint 192.168.0.250 up</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; If a tap device is being set up, a route is set to the UML IP.</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML# route add -host 192.168.0.250 gw 192.168.0.251</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; To allow other hosts on your network to see the virtual machine,<BR>&nbsp;&nbsp;&nbsp;&nbsp; proxy arp is set up for it.</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#&nbsp; arp -Ds 192.168.0.250 eth0 pub</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; Finally, the host is set up to route packets.</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#&nbsp; echo 1 &gt; /proc/sys/net/ipv4/ip_forward</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 7.&nbsp; Sharing Filesystems between Virtual Machines</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 7.1.&nbsp; A warning</P>
<P>&nbsp; Don't attempt to share filesystems simply by booting two UMLs from the<BR>&nbsp; same file.&nbsp; That's the same thing as booting two physical machines<BR>&nbsp; from a shared disk.&nbsp; It will result in filesystem corruption.</P>
<P>&nbsp;</P>
<P>&nbsp; 7.2.&nbsp; Using layered block devices</P>
<P>&nbsp; The way to share a filesystem between two virtual machines is to use<BR>&nbsp; the copy-on-write (COW) layering capability of the ubd block driver.<BR>&nbsp; As of 2.4.6-2um, the driver supports layering a read-write private<BR>&nbsp; device over a read-only shared device.&nbsp; A machine's writes are stored<BR>&nbsp; in the private device, while reads come from either device - the<BR>&nbsp; private one if the requested block is valid in it, the shared one if<BR>&nbsp; not.&nbsp; Using this scheme, the majority of data which is unchanged is<BR>&nbsp; shared between an arbitrary number of virtual machines, each of which<BR>&nbsp; has a much smaller file containing the changes that it has made.&nbsp; With<BR>&nbsp; a large number of UMLs booting from a large root filesystem, this<BR>&nbsp; leads to a huge disk space saving.&nbsp; It will also help performance,<BR>&nbsp; since the host will be able to cache the shared data using a much<BR>&nbsp; smaller amount of memory, so UML disk requests will be served from the<BR>&nbsp; host's memory rather than its disks.</P>
<P>&nbsp;</P>
<P><BR>&nbsp; To add a copy-on-write layer to an existing block device file, simply<BR>&nbsp; add the name of the COW file to the appropriate ubd switch:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ubd0=root_fs_cow,root_fs_debian_22</P>
<P>&nbsp;</P>
<P><BR>&nbsp; where 'root_fs_cow' is the private COW file and 'root_fs_debian_22' is<BR>&nbsp; the existing shared filesystem.&nbsp; The COW file need not exist.&nbsp; If it<BR>&nbsp; doesn't, the driver will create and initialize it.&nbsp; Once the COW file<BR>&nbsp; has been initialized, it can be used on its own on the command line:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ubd0=root_fs_cow</P>
<P>&nbsp;</P>
<P><BR>&nbsp; The name of the backing file is stored in the COW file header, so it<BR>&nbsp; would be redundant to continue specifying it on the command line.</P>
<P>&nbsp;</P>
<P>&nbsp; 7.3.&nbsp; Note!</P>
<P>&nbsp; When checking the size of the COW file in order to see the gobs of<BR>&nbsp; space that you're saving, make sure you use 'ls -ls' to see the actual<BR>&nbsp; disk consumption rather than the length of the file.&nbsp; The COW file is<BR>&nbsp; sparse, so the length will be very different from the disk usage.<BR>&nbsp; Here is a 'ls -l' of a COW file and backing file from one boot and<BR>&nbsp; shutdown:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% ls -l cow.debian debian2.2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -rw-r--r--&nbsp;&nbsp;&nbsp; 1 jdike&nbsp;&nbsp;&nbsp; jdike&nbsp;&nbsp;&nbsp; 492504064 Aug&nbsp; 6 21:16 cow.debian<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -rwxrw-rw-&nbsp;&nbsp;&nbsp; 1 jdike&nbsp;&nbsp;&nbsp; jdike&nbsp;&nbsp;&nbsp; 537919488 Aug&nbsp; 6 20:42 debian2.2</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Doesn't look like much saved space, does it?&nbsp; Well, here's 'ls -ls':</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% ls -ls cow.debian debian2.2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 880 -rw-r--r--&nbsp;&nbsp;&nbsp; 1 jdike&nbsp;&nbsp;&nbsp; jdike&nbsp;&nbsp;&nbsp; 492504064 Aug&nbsp; 6 21:16 cow.debian<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 525832 -rwxrw-rw-&nbsp;&nbsp;&nbsp; 1 jdike&nbsp;&nbsp;&nbsp; jdike&nbsp;&nbsp;&nbsp; 537919488 Aug&nbsp; 6 20:42 debian2.2</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Now, you can see that the COW file has less than a meg of disk, rather<BR>&nbsp; than 492 meg.</P>
<P>&nbsp;</P>
<P>&nbsp; 7.4.&nbsp; Another warning</P>
<P>&nbsp; Once a filesystem is being used as a readonly backing file for a COW<BR>&nbsp; file, do not boot directly from it or modify it in any way.&nbsp; Doing so<BR>&nbsp; will invalidate any COW files that are using it.&nbsp; The mtime and size<BR>&nbsp; of the backing file are stored in the COW file header at its creation,<BR>&nbsp; and they must continue to match.&nbsp; If they don't, the driver will<BR>&nbsp; refuse to use the COW file.</P>
<P>&nbsp;</P>
<P><BR>&nbsp; If you attempt to evade this restriction by changing either the<BR>&nbsp; backing file or the COW header by hand, you will get a corrupted<BR>&nbsp; filesystem.</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Among other things, this means that upgrading the distribution in a<BR>&nbsp; backing file and expecting that all of the COW files using it will see<BR>&nbsp; the upgrade will not work.</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 7.5.&nbsp; uml_moo : Merging a COW file with its backing file</P>
<P>&nbsp; Depending on how you use UML and COW devices, it may be advisable to<BR>&nbsp; merge the changes in the COW file into the backing file every once in<BR>&nbsp; a while.</P>
<P>&nbsp;</P>
<P><BR>&nbsp; The utility that does this is uml_moo.&nbsp; Its usage is</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% uml_moo COW file new backing file</P>
<P>&nbsp;</P>
<P><BR>&nbsp; There's no need to specify the backing file since that information is<BR>&nbsp; already in the COW file header.&nbsp; If you're paranoid, boot the new<BR>&nbsp; merged file, and if you're happy with it, move it over the old backing<BR>&nbsp; file.</P>
<P>&nbsp;</P>
<P><BR>&nbsp; uml_moo creates a new backing file by default as a safety measure.&nbsp; It<BR>&nbsp; also has a destructive merge option which will merge the COW file<BR>&nbsp; directly into its current backing file.&nbsp; This is really only usable<BR>&nbsp; when the backing file only has one COW file associated with it.&nbsp; If<BR>&nbsp; there are multiple COWs associated with a backing file, a -d merge of<BR>&nbsp; one of them will invalidate all of the others.&nbsp; However, it is<BR>&nbsp; convenient if you're short of disk space, and it should also be<BR>&nbsp; noticeably faster than a non-destructive merge.</P>
<P>&nbsp;</P>
<P><BR>&nbsp; uml_moo is installed with the UML deb and RPM.&nbsp; If you didn't install<BR>&nbsp; UML from one of those packages, you can also get it from the UML<BR>&nbsp; utilities &lt;<A href="http://user-mode-linux.sourceforge.net/">http://user-mode-linux.sourceforge.net/</A><BR>&nbsp; utilities&gt;&nbsp; tar file in tools/moo.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 8.&nbsp; Creating filesystems</P>
<P><BR>&nbsp; You may want to create and mount new UML filesystems, either because<BR>&nbsp; your root filesystem isn't large enough or because you want to use a<BR>&nbsp; filesystem other than ext2.</P>
<P><BR>&nbsp; This was written on the occasion of reiserfs being included in the<BR>&nbsp; 2.4.1 kernel pool, and therefore the 2.4.1 UML, so the examples will<BR>&nbsp; talk about reiserfs.&nbsp; This information is generic, and the examples<BR>&nbsp; should be easy to translate to the filesystem of your choice.</P>
<P><BR>&nbsp; 8.1.&nbsp; Create the filesystem file</P>
<P>&nbsp; dd is your friend.&nbsp; All you need to do is tell dd to create an empty<BR>&nbsp; file of the appropriate size.&nbsp; I usually make it sparse to save time<BR>&nbsp; and to avoid allocating disk space until it's actually used.&nbsp; For<BR>&nbsp; example, the following command will create a sparse 100 meg file full<BR>&nbsp; of zeroes.</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host%<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dd if=/dev/zero of=new_filesystem seek=100 count=1 bs=1M</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 8.2.&nbsp; Assign the file to a UML device</P>
<P>&nbsp; Add an argument like the following to the UML command line:</P>
<P>&nbsp; ubd4=new_filesystem</P>
<P>&nbsp;</P>
<P><BR>&nbsp; making sure that you use an unassigned ubd device number.</P>
<P>&nbsp;</P>
<P>&nbsp; 8.3.&nbsp; Creating and mounting the filesystem</P>
<P>&nbsp; Make sure that the filesystem is available, either by being built into<BR>&nbsp; the kernel, or available as a module, then boot up UML and log in.&nbsp; If<BR>&nbsp; the root filesystem doesn't have the filesystem utilities (mkfs, fsck,<BR>&nbsp; etc), then get them into UML by way of the net or hostfs.</P>
<P><BR>&nbsp; Make the new filesystem on the device assigned to the new file:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#&nbsp; mkreiserfs /dev/ubd/4</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;----------- MKREISERFSv2 -----------&gt;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReiserFS version 3.6.25<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Block size 4096 bytes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Block count 25856<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Used blocks 8212<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Journal - 8192 blocks (18-8209), journal header is in block 8210<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bitmaps: 17<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root block 8211<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hash function "r5"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ATTENTION: ALL DATA WILL BE LOST ON '/dev/ubd/4'! (y/n)y<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; journal size 8192 (from 18)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Initializing journal - 0%....20%....40%....60%....80%....100%<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Syncing..done.</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Now, mount it:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mount /dev/ubd/4 /mnt</P>
<P>&nbsp;</P>
<P><BR>&nbsp; and you're in business.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; 9.&nbsp; Host file access</P>
<P><BR>&nbsp; If you want to access files on the host machine from inside UML, you<BR>&nbsp; can treat it as a separate machine and either nfs mount directories<BR>&nbsp; from the host or copy files into the virtual machine with scp or rcp.<BR>&nbsp; However, since UML is running on the host, it can access those<BR>&nbsp; files just like any other process and make them available inside the<BR>&nbsp; virtual machine without needing to use the network.</P>
<P><BR>&nbsp; This is now possible with the hostfs virtual filesystem.&nbsp; With it, you<BR>&nbsp; can mount a host directory into the UML filesystem and access the<BR>&nbsp; files contained in it just as you would on the host.</P>
<P><BR>&nbsp; 9.1.&nbsp; Using hostfs</P>
<P>&nbsp; To begin with, make sure that hostfs is available inside the virtual<BR>&nbsp; machine with</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML# cat /proc/filesystems</P>
<P>&nbsp;</P>
<P>&nbsp; .&nbsp; hostfs should be listed.&nbsp; If it's not, either rebuild the kernel<BR>&nbsp; with hostfs configured into it or make sure that hostfs is built as a<BR>&nbsp; module and available inside the virtual machine, and insmod it.</P>
<P><BR>&nbsp; Now all you need to do is run mount:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML# mount none /mnt/host -t hostfs</P>
<P>&nbsp;</P>
<P><BR>&nbsp; will mount the host's / on the virtual machine's /mnt/host.</P>
<P><BR>&nbsp; If you don't want to mount the host root directory, then you can<BR>&nbsp; specify a subdirectory to mount with the -o switch to mount:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML# mount none /mnt/home -t hostfs -o /home</P>
<P>&nbsp;</P>
<P><BR>&nbsp; will mount the hosts's /home on the virtual machine's /mnt/home.</P>
<P>&nbsp;</P>
<P>&nbsp; 9.2.&nbsp; hostfs as the root filesystem</P>
<P>&nbsp; It's possible to boot from a directory hierarchy on the host using<BR>&nbsp; hostfs rather than using the standard filesystem in a file.</P>
<P>&nbsp; To start, you need that hierarchy.&nbsp; The easiest way is to loop mount<BR>&nbsp; an existing root_fs file:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#&nbsp; mount root_fs uml_root_dir -o loop</P>
<P>&nbsp;</P>
<P><BR>&nbsp; You need to change the filesystem type of / in etc/fstab to be<BR>&nbsp; 'hostfs', so that line looks like this:</P>
<P>&nbsp; /dev/ubd/0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hostfs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defaults&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; 1</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Then you need to chown to yourself all the files in that directory<BR>&nbsp; that are owned by root.&nbsp; This worked for me:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host#&nbsp; find . -uid 0 -exec chown jdike {} \;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Next, make sure that your UML kernel has hostfs compiled in, not as a<BR>&nbsp; module.&nbsp; Then run UML with the boot device pointing at that directory:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ubd0=/path/to/uml/root/directory</P>
<P>&nbsp;</P>
<P><BR>&nbsp; UML should then boot as it does normally.</P>
<P><BR>&nbsp; 9.3.&nbsp; Building hostfs</P>
<P>&nbsp; If you need to build hostfs because it's not in your kernel, you have<BR>&nbsp; two choices:</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; Compiling hostfs into the kernel:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp; Reconfigure the kernel and set the 'Host filesystem' option under</P>
<P><BR>&nbsp; o&nbsp; Compiling hostfs as a module:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp; Reconfigure the kernel and set the 'Host filesystem' option under<BR>&nbsp;&nbsp;&nbsp;&nbsp; be in arch/um/fs/hostfs/hostfs.o.&nbsp; Install that in<BR>&nbsp;&nbsp;&nbsp;&nbsp; /lib/modules/`uname -r`/fs in the virtual machine, boot it up, and</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML# insmod hostfs</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 10.&nbsp; The Management Console</P>
<P>&nbsp;</P>
<P>&nbsp; The UML management console is a low-level interface to the kernel,<BR>&nbsp; somewhat like the i386 SysRq interface.&nbsp; Since there is a full-blown<BR>&nbsp; operating system under UML, there is much greater flexibility possible<BR>&nbsp; than with the SysRq mechanism.</P>
<P><BR>&nbsp; There are a number of things you can do with the mconsole interface:</P>
<P>&nbsp; o&nbsp; get the kernel version</P>
<P>&nbsp; o&nbsp; add and remove devices</P>
<P>&nbsp; o&nbsp; halt or reboot the machine</P>
<P>&nbsp; o&nbsp; Send SysRq commands</P>
<P>&nbsp; o&nbsp; Pause and resume the UML</P>
<P><BR>&nbsp; You need the mconsole client (uml_mconsole) which is present in CVS<BR>&nbsp; (/tools/mconsole) in 2.4.5-9um and later, and will be in the RPM in<BR>&nbsp; 2.4.6.</P>
<P><BR>&nbsp; You also need CONFIG_MCONSOLE (under 'General Setup') enabled in UML.<BR>&nbsp; When you boot UML, you'll see a line like:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mconsole initialized on /home/jdike/.uml/umlNJ32yL/mconsole</P>
<P>&nbsp;</P>
<P><BR>&nbsp; If you specify a unique machine id one the UML command line, i.e.</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umid=debian</P>
<P>&nbsp;</P>
<P><BR>&nbsp; you'll see this</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mconsole initialized on /home/jdike/.uml/debian/mconsole</P>
<P>&nbsp;</P>
<P><BR>&nbsp; That file is the socket that uml_mconsole will use to communicate with<BR>&nbsp; UML.&nbsp; Run it with either the umid or the full path as its argument:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% uml_mconsole debian</P>
<P>&nbsp;</P>
<P><BR>&nbsp; or</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% uml_mconsole /home/jdike/.uml/debian/mconsole</P>
<P>&nbsp;</P>
<P><BR>&nbsp; You'll get a prompt, at which you can run one of these commands:</P>
<P>&nbsp; o&nbsp; version</P>
<P>&nbsp; o&nbsp; halt</P>
<P>&nbsp; o&nbsp; reboot</P>
<P>&nbsp; o&nbsp; config</P>
<P>&nbsp; o&nbsp; remove</P>
<P>&nbsp; o&nbsp; sysrq</P>
<P>&nbsp; o&nbsp; help</P>
<P>&nbsp; o&nbsp; cad</P>
<P>&nbsp; o&nbsp; stop</P>
<P>&nbsp; o&nbsp; go</P>
<P><BR>&nbsp; 10.1.&nbsp; version</P>
<P>&nbsp; This takes no arguments.&nbsp; It prints the UML version.</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (mconsole)&nbsp; version<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OK Linux usermode 2.4.5-9um #1 Wed Jun 20 22:47:08 EDT 2001 i686</P>
<P>&nbsp;</P>
<P><BR>&nbsp; There are a couple actual uses for this.&nbsp; It's a simple no-op which<BR>&nbsp; can be used to check that a UML is running.&nbsp; It's also a way of<BR>&nbsp; sending an interrupt to the UML.&nbsp; This is sometimes useful on SMP<BR>&nbsp; hosts, where there's a bug which causes signals to UML to be lost,<BR>&nbsp; often causing it to appear to hang.&nbsp; Sending such a UML the mconsole<BR>&nbsp; version command is a good way to 'wake it up' before networking has<BR>&nbsp; been enabled, as it does not do anything to the function of the UML.</P>
<P>&nbsp;</P>
<P>&nbsp; 10.2.&nbsp; halt and reboot</P>
<P>&nbsp; These take no arguments.&nbsp; They shut the machine down immediately, with<BR>&nbsp; no syncing of disks and no clean shutdown of userspace.&nbsp; So, they are<BR>&nbsp; pretty close to crashing the machine.</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (mconsole)&nbsp; halt<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OK</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 10.3.&nbsp; config</P>
<P>&nbsp; "config" adds a new device to the virtual machine.&nbsp; Currently the ubd<BR>&nbsp; and network drivers support this.&nbsp; It takes one argument, which is the<BR>&nbsp; device to add, with the same syntax as the kernel command line.</P>
<P>&nbsp;</P>
<P><BR>&nbsp; (mconsole)<BR>&nbsp; config ubd3=/home/jdike/incoming/roots/root_fs_debian22</P>
<P>&nbsp; OK<BR>&nbsp; (mconsole)&nbsp; config eth1=mcast<BR>&nbsp; OK</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 10.4.&nbsp; remove</P>
<P>&nbsp; "remove" deletes a device from the system.&nbsp; Its argument is just the<BR>&nbsp; name of the device to be removed. The device must be idle in whatever<BR>&nbsp; sense the driver considers necessary.&nbsp; In the case of the ubd driver,<BR>&nbsp; the removed block device must not be mounted, swapped on, or otherwise<BR>&nbsp; open, and in the case of the network driver, the device must be down.</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (mconsole)&nbsp; remove ubd3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OK<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (mconsole)&nbsp; remove eth1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OK</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 10.5.&nbsp; sysrq</P>
<P>&nbsp; This takes one argument, which is a single letter.&nbsp; It calls the<BR>&nbsp; generic kernel's SysRq driver, which does whatever is called for by<BR>&nbsp; that argument.&nbsp; See the SysRq documentation in Documentation/sysrq.txt<BR>&nbsp; in your favorite kernel tree to see what letters are valid and what<BR>&nbsp; they do.</P>
<P>&nbsp;</P>
<P>&nbsp; 10.6.&nbsp; help</P>
<P>&nbsp; "help" returns a string listing the valid commands and what each one<BR>&nbsp; does.</P>
<P>&nbsp;</P>
<P>&nbsp; 10.7.&nbsp; cad</P>
<P>&nbsp; This invokes the Ctl-Alt-Del action on init.&nbsp; What exactly this ends<BR>&nbsp; up doing is up to /etc/inittab.&nbsp; Normally, it reboots the machine.<BR>&nbsp; With UML, this is usually not desired, so if a halt would be better,<BR>&nbsp; then find the section of inittab that looks like this</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # What to do when CTRL-ALT-DEL is pressed.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now</P>
<P>&nbsp;</P>
<P><BR>&nbsp; and change the command to halt.</P>
<P>&nbsp;</P>
<P>&nbsp; 10.8.&nbsp; stop</P>
<P>&nbsp; This puts the UML in a loop reading mconsole requests until a 'go'<BR>&nbsp; mconsole command is received. This is very useful for making backups<BR>&nbsp; of UML filesystems, as the UML can be stopped, then synced via 'sysrq<BR>&nbsp; s', so that everything is written to the filesystem. You can then copy<BR>&nbsp; the filesystem and then send the UML 'go' via mconsole.</P>
<P><BR>&nbsp; Note that a UML running with more than one CPU will have problems<BR>&nbsp; after you send the 'stop' command, as only one CPU will be held in a<BR>&nbsp; mconsole loop and all others will continue as normal.&nbsp; This is a bug,<BR>&nbsp; and will be fixed.</P>
<P>&nbsp;</P>
<P>&nbsp; 10.9.&nbsp; go</P>
<P>&nbsp; This resumes a UML after being paused by a 'stop' command. Note that<BR>&nbsp; when the UML has resumed, TCP connections may have timed out and if<BR>&nbsp; the UML is paused for a long period of time, crond might go a little<BR>&nbsp; crazy, running all the jobs it didn't do earlier.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 11.&nbsp; Kernel debugging</P>
<P><BR>&nbsp; Note: The interface that makes debugging, as described here, possible<BR>&nbsp; is present in 2.4.0-test6 kernels and later.</P>
<P><BR>&nbsp; Since the user-mode kernel runs as a normal Linux process, it is<BR>&nbsp; possible to debug it with gdb almost like any other process.&nbsp; It is<BR>&nbsp; slightly different because the kernel's threads are already being<BR>&nbsp; ptraced for system call interception, so gdb can't ptrace them.<BR>&nbsp; However, a mechanism has been added to work around that problem.</P>
<P><BR>&nbsp; In order to debug the kernel, you need build it from source.&nbsp; See<BR>&nbsp; ``Compiling the kernel and modules''&nbsp; for information on doing that.<BR>&nbsp; Make sure that you enable CONFIG_DEBUGSYM and CONFIG_PT_PROXY during<BR>&nbsp; the config.&nbsp; These will compile the kernel with -g, and enable the<BR>&nbsp; ptrace proxy so that gdb works with UML, respectively.</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 11.1.&nbsp; Starting the kernel under gdb</P>
<P>&nbsp; You can have the kernel running under the control of gdb from the<BR>&nbsp; beginning by putting 'debug' on the command line.&nbsp; You will get an<BR>&nbsp; xterm with gdb running inside it.&nbsp; The kernel will send some commands<BR>&nbsp; to gdb which will leave it stopped at the beginning of start_kernel.<BR>&nbsp; At this point, you can get things going with 'next', 'step', or<BR>&nbsp; 'cont'.</P>
<P><BR>&nbsp; There is a transcript of a debugging session&nbsp; here &lt;debug-<BR>&nbsp; session.html&gt; , with breakpoints being set in the scheduler and in an<BR>&nbsp; interrupt handler.<BR>&nbsp; 11.2.&nbsp; Examining sleeping processes</P>
<P>&nbsp; Not every bug is evident in the currently running process.&nbsp; Sometimes,<BR>&nbsp; processes hang in the kernel when they shouldn't because they've<BR>&nbsp; deadlocked on a semaphore or something similar.&nbsp; In this case, when<BR>&nbsp; you ^C gdb and get a backtrace, you will see the idle thread, which<BR>&nbsp; isn't very relevant.</P>
<P><BR>&nbsp; What you want is the stack of whatever process is sleeping when it<BR>&nbsp; shouldn't be.&nbsp; You need to figure out which process that is, which is<BR>&nbsp; generally fairly easy.&nbsp; Then you need to get its host process id,<BR>&nbsp; which you can do either by looking at ps on the host or at<BR>&nbsp; task.thread.extern_pid in gdb.</P>
<P><BR>&nbsp; Now what you do is this:</P>
<P>&nbsp; o&nbsp; detach from the current thread</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UML gdb)&nbsp; det</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; attach to the thread you are interested in</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UML gdb)&nbsp; att &lt;host pid&gt;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; look at its stack and anything else of interest</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UML gdb)&nbsp; bt</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Note that you can't do anything at this point that requires that a<BR>&nbsp; process execute, e.g. calling a function</P>
<P>&nbsp; o&nbsp; when you're done looking at that process, reattach to the current<BR>&nbsp;&nbsp;&nbsp;&nbsp; thread and continue it</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UML gdb)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; att 1</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UML gdb)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Here, specifying any pid which is not the process id of a UML thread<BR>&nbsp; will cause gdb to reattach to the current thread.&nbsp; I commonly use 1,<BR>&nbsp; but any other invalid pid would work.</P>
<P>&nbsp;</P>
<P>&nbsp; 11.3.&nbsp; Running ddd on UML</P>
<P>&nbsp; ddd works on UML, but requires a special kludge.&nbsp; The process goes<BR>&nbsp; like this:</P>
<P>&nbsp; o&nbsp; Start ddd</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% ddd linux</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; With ps, get the pid of the gdb that ddd started.&nbsp; You can ask the<BR>&nbsp;&nbsp;&nbsp;&nbsp; gdb to tell you, but for some reason that confuses things and<BR>&nbsp;&nbsp;&nbsp;&nbsp; causes a hang.</P>
<P>&nbsp; o&nbsp; run UML with 'debug=parent gdb-pid=&lt;pid&gt;' added to the command line<BR>&nbsp;&nbsp;&nbsp;&nbsp; - it will just sit there after you hit return</P>
<P>&nbsp; o&nbsp; type 'att 1' to the ddd gdb and you will see something like</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xa013dc51 in __kill ()</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb)</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; At this point, type 'c', UML will boot up, and you can use ddd just<BR>&nbsp;&nbsp;&nbsp;&nbsp; as you do on any other process.</P>
<P>&nbsp;</P>
<P>&nbsp; 11.4.&nbsp; Debugging modules</P>
<P>&nbsp; gdb has support for debugging code which is dynamically loaded into<BR>&nbsp; the process.&nbsp; This support is what is needed to debug kernel modules<BR>&nbsp; under UML.</P>
<P><BR>&nbsp; Using that support is somewhat complicated.&nbsp; You have to tell gdb what<BR>&nbsp; object file you just loaded into UML and where in memory it is.&nbsp; Then,<BR>&nbsp; it can read the symbol table, and figure out where all the symbols are<BR>&nbsp; from the load address that you provided.&nbsp; It gets more interesting<BR>&nbsp; when you load the module again (i.e. after an rmmod).&nbsp; You have to<BR>&nbsp; tell gdb to forget about all its symbols, including the main UML ones<BR>&nbsp; for some reason, then load then all back in again.</P>
<P><BR>&nbsp; There's an easy way and a hard way to do this.&nbsp; The easy way is to use<BR>&nbsp; the umlgdb expect script written by Chandan Kudige.&nbsp; It basically<BR>&nbsp; automates the process for you.</P>
<P><BR>&nbsp; First, you must tell it where your modules are.&nbsp; There is a list in<BR>&nbsp; the script that looks like this:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set MODULE_PATHS {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "fat" "/usr/src/uml/linux-2.4.18/fs/fat/fat.o"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "isofs" "/usr/src/uml/linux-2.4.18/fs/isofs/isofs.o"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "minix" "/usr/src/uml/linux-2.4.18/fs/minix/minix.o"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;</P>
<P><BR>&nbsp; You change that to list the names and paths of the modules that you<BR>&nbsp; are going to debug.&nbsp; Then you run it from the toplevel directory of<BR>&nbsp; your UML pool and it basically tells you what to do:</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ******** GDB pid is 21903 ********<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Start UML as: ./linux &lt;kernel switches&gt; debug gdb-pid=21903</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GNU gdb 5.0rh-5 Red Hat Linux 7.1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Copyright 2001 Free Software Foundation, Inc.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GDB is free software, covered by the GNU General Public License, and you are<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; welcome to change it and/or distribute copies of it under certain conditions.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type "show copying" to see the conditions.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There is absolutely no warranty for GDB.&nbsp; Type "show warranty" for details.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This GDB was configured as "i386-redhat-linux"...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) b sys_init_module<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Breakpoint 1 at 0xa0011923: file module.c, line 349.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) att 1</P>
<P>&nbsp;</P>
<P><BR>&nbsp; After you run UML and it sits there doing nothing, you hit return at<BR>&nbsp; the 'att 1' and continue it:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Attaching to program: /home/jdike/linux/2.4/um/./linux, process 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xa00f4221 in __kill ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UML gdb)&nbsp; c<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Continuing.</P>
<P>&nbsp;</P>
<P><BR>&nbsp; At this point, you debug normally.&nbsp; When you insmod something, the<BR>&nbsp; expect magic will kick in and you'll see something like:</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp; *** Module hostfs loaded ***<BR>&nbsp; Breakpoint 1, sys_init_module (name_user=0x805abb0 "hostfs",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod_user=0x8070e00) at module.c:349<BR>&nbsp; 349&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *name, *n_name, *name_tmp = NULL;<BR>&nbsp; (UML gdb)&nbsp; finish<BR>&nbsp; Run till exit from #0&nbsp; sys_init_module (name_user=0x805abb0 "hostfs",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod_user=0x8070e00) at module.c:349<BR>&nbsp; 0xa00e2e23 in execute_syscall (r=0xa8140284) at syscall_kern.c:411<BR>&nbsp; 411&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else res = EXECUTE_SYSCALL(syscall, regs);<BR>&nbsp; Value returned is $1 = 0<BR>&nbsp; (UML gdb)<BR>&nbsp; p/x (int)module_list + module_list-&gt;size_of_struct</P>
<P>&nbsp; $2 = 0xa9021054<BR>&nbsp; (UML gdb)&nbsp; symbol-file ./linux<BR>&nbsp; Load new symbol table from "./linux"? (y or n) y<BR>&nbsp; Reading symbols from ./linux...<BR>&nbsp; done.<BR>&nbsp; (UML gdb)<BR>&nbsp; add-symbol-file /home/jdike/linux/2.4/um/arch/um/fs/hostfs/hostfs.o 0xa9021054</P>
<P>&nbsp; add symbol table from file "/home/jdike/linux/2.4/um/arch/um/fs/hostfs/hostfs.o" at<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .text_addr = 0xa9021054<BR>&nbsp;&nbsp; (y or n) y</P>
<P>&nbsp; Reading symbols from /home/jdike/linux/2.4/um/arch/um/fs/hostfs/hostfs.o...<BR>&nbsp; done.<BR>&nbsp; (UML gdb)&nbsp; p *module_list<BR>&nbsp; $1 = {size_of_struct = 84, next = 0xa0178720, name = 0xa9022de0 "hostfs",<BR>&nbsp;&nbsp;&nbsp; size = 9016, uc = {usecount = {counter = 0}, pad = 0}, flags = 1,<BR>&nbsp;&nbsp;&nbsp; nsyms = 57, ndeps = 0, syms = 0xa9023170, deps = 0x0, refs = 0x0,<BR>&nbsp;&nbsp;&nbsp; init = 0xa90221f0 &lt;init_hostfs&gt;, cleanup = 0xa902222c &lt;exit_hostfs&gt;,<BR>&nbsp;&nbsp;&nbsp; ex_table_start = 0x0, ex_table_end = 0x0, persist_start = 0x0,<BR>&nbsp;&nbsp;&nbsp; persist_end = 0x0, can_unload = 0, runsize = 0, kallsyms_start = 0x0,<BR>&nbsp;&nbsp;&nbsp; kallsyms_end = 0x0,<BR>&nbsp;&nbsp;&nbsp; archdata_start = 0x1b855 &lt;Address 0x1b855 out of bounds&gt;,<BR>&nbsp;&nbsp;&nbsp; archdata_end = 0xe5890000 &lt;Address 0xe5890000 out of bounds&gt;,<BR>&nbsp;&nbsp;&nbsp; kernel_data = 0xf689c35d &lt;Address 0xf689c35d out of bounds&gt;}<BR>&nbsp; &gt;&gt; Finished loading symbols for hostfs ...</P>
<P>&nbsp;</P>
<P><BR>&nbsp; That's the easy way.&nbsp; It's highly recommended.&nbsp; The hard way is<BR>&nbsp; described below in case you're interested in what's going on.</P>
<P><BR>&nbsp; Boot the kernel under the debugger and load the module with insmod or<BR>&nbsp; modprobe.&nbsp; With gdb, do:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UML gdb)&nbsp; p module_list</P>
<P>&nbsp;</P>
<P><BR>&nbsp; This is a list of modules that have been loaded into the kernel, with<BR>&nbsp; the most recently loaded module first.&nbsp; Normally, the module you want<BR>&nbsp; is at module_list.&nbsp; If it's not, walk down the next links, looking at<BR>&nbsp; the name fields until find the module you want to debug.&nbsp; Take the<BR>&nbsp; address of that structure, and add module.size_of_struct (which in<BR>&nbsp; 2.4.10 kernels is 96 (0x60)) to it.&nbsp; Gdb can make this hard addition<BR>&nbsp; for you :-):</P>
<P>&nbsp;</P>
<P>&nbsp; (UML gdb)<BR>&nbsp; printf "%#x\n", (int)module_list module_list-&gt;size_of_struct</P>
<P>&nbsp;</P>
<P><BR>&nbsp; The offset from the module start occasionally changes (before 2.4.0,<BR>&nbsp; it was module.size_of_struct + 4), so it's a good idea to check the<BR>&nbsp; init and cleanup addresses once in a while, as describe below.&nbsp; Now<BR>&nbsp; do:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UML gdb)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add-symbol-file /path/to/module/on/host that_address</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Tell gdb you really want to do it, and you're in business.</P>
<P><BR>&nbsp; If there's any doubt that you got the offset right, like breakpoints<BR>&nbsp; appear not to work, or they're appearing in the wrong place, you can<BR>&nbsp; check it by looking at the module structure.&nbsp; The init and cleanup<BR>&nbsp; fields should look like:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; init = 0x588066b0 &lt;init_hostfs&gt;, cleanup = 0x588066c0 &lt;exit_hostfs&gt;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; with no offsets on the symbol names.&nbsp; If the names are right, but they<BR>&nbsp; are offset, then the offset tells you how much you need to add to the<BR>&nbsp; address you gave to add-symbol-file.</P>
<P><BR>&nbsp; When you want to load in a new version of the module, you need to get<BR>&nbsp; gdb to forget about the old one.&nbsp; The only way I've found to do that<BR>&nbsp; is to tell gdb to forget about all symbols that it knows about:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UML gdb)&nbsp; symbol-file</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Then reload the symbols from the kernel binary:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UML gdb)&nbsp; symbol-file /path/to/kernel</P>
<P>&nbsp;</P>
<P><BR>&nbsp; and repeat the process above.&nbsp; You'll also need to re-enable break-<BR>&nbsp; points.&nbsp; They were disabled when you dumped all the symbols because<BR>&nbsp; gdb couldn't figure out where they should go.</P>
<P>&nbsp;</P>
<P>&nbsp; 11.5.&nbsp; Attaching gdb to the kernel</P>
<P>&nbsp; If you don't have the kernel running under gdb, you can attach gdb to<BR>&nbsp; it later by sending the tracing thread a SIGUSR1.&nbsp; The first line of<BR>&nbsp; the console output identifies its pid:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tracing thread pid = 20093</P>
<P>&nbsp;</P>
<P><BR>&nbsp; When you send it the signal:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% kill -USR1 20093</P>
<P>&nbsp;</P>
<P><BR>&nbsp; you will get an xterm with gdb running in it.</P>
<P><BR>&nbsp; If you have the mconsole compiled into UML, then the mconsole client<BR>&nbsp; can be used to start gdb:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (mconsole)&nbsp; (mconsole) config gdb=xterm</P>
<P>&nbsp;</P>
<P><BR>&nbsp; will fire up an xterm with gdb running in it.</P>
<P>&nbsp;</P>
<P>&nbsp; 11.6.&nbsp; Using alternate debuggers</P>
<P>&nbsp; UML has support for attaching to an already running debugger rather<BR>&nbsp; than starting gdb itself.&nbsp; This is present in CVS as of 17 Apr 2001.<BR>&nbsp; I sent it to Alan for inclusion in the ac tree, and it will be in my<BR>&nbsp; 2.4.4 release.</P>
<P><BR>&nbsp; This is useful when gdb is a subprocess of some UI, such as emacs or<BR>&nbsp; ddd.&nbsp; It can also be used to run debuggers other than gdb on UML.<BR>&nbsp; Below is an example of using strace as an alternate debugger.</P>
<P><BR>&nbsp; To do this, you need to get the pid of the debugger and pass it in<BR>&nbsp; with the</P>
<P><BR>&nbsp; If you are using gdb under some UI, then tell it to 'att 1', and<BR>&nbsp; you'll find yourself attached to UML.</P>
<P><BR>&nbsp; If you are using something other than gdb as your debugger, then<BR>&nbsp; you'll need to get it to do the equivalent of 'att 1' if it doesn't do<BR>&nbsp; it automatically.</P>
<P><BR>&nbsp; An example of an alternate debugger is strace.&nbsp; You can strace the<BR>&nbsp; actual kernel as follows:</P>
<P>&nbsp; o&nbsp; Run the following in a shell</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host%<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sh -c 'echo pid=$$; echo -n hit return; read x; exec strace -p 1 -o strace.out'</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; Run UML with 'debug' and 'gdb-pid=&lt;pid&gt;' with the pid printed out<BR>&nbsp;&nbsp;&nbsp;&nbsp; by the previous command</P>
<P>&nbsp; o&nbsp; Hit return in the shell, and UML will start running, and strace<BR>&nbsp;&nbsp;&nbsp;&nbsp; output will start accumulating in the output file.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; Note that this is different from running</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% strace ./linux</P>
<P>&nbsp;</P>
<P><BR>&nbsp; That will strace only the main UML thread, the tracing thread, which<BR>&nbsp; doesn't do any of the actual kernel work.&nbsp; It just oversees the vir-<BR>&nbsp; tual machine.&nbsp; In contrast, using strace as described above will show<BR>&nbsp; you the low-level activity of the virtual machine.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; 12.&nbsp; Kernel debugging examples</P>
<P>&nbsp; 12.1.&nbsp; The case of the hung fsck</P>
<P>&nbsp; When booting up the kernel, fsck failed, and dropped me into a shell<BR>&nbsp; to fix things up.&nbsp; I ran fsck -y, which hung:</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; Setting hostname uml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ OK ]<BR>&nbsp; Checking root filesystem<BR>&nbsp; /dev/fhd0 was not cleanly unmounted, check forced.<BR>&nbsp; Error reading block 86894 (Attempt to read block from filesystem resulted in short read) while reading indirect blocks of inode 19780.</P>
<P>&nbsp; /dev/fhd0: UNEXPECTED INCONSISTENCY; RUN fsck MANUALLY.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (i.e., without -a or -p options)<BR>&nbsp; [ FAILED ]</P>
<P>&nbsp; *** An error occurred during the file system check.<BR>&nbsp; *** Dropping you to a shell; the system will reboot<BR>&nbsp; *** when you leave the shell.<BR>&nbsp; Give root password for maintenance<BR>&nbsp; (or type Control-D for normal startup):</P>
<P>&nbsp; [root@uml /root]# fsck -y /dev/fhd0<BR>&nbsp; fsck -y /dev/fhd0<BR>&nbsp; Parallelizing fsck version 1.14 (9-Jan-1999)<BR>&nbsp; e2fsck 1.14, 9-Jan-1999 for EXT2 FS 0.5b, 95/08/09<BR>&nbsp; /dev/fhd0 contains a file system with errors, check forced.<BR>&nbsp; Pass 1: Checking inodes, blocks, and sizes<BR>&nbsp; Error reading block 86894 (Attempt to read block from filesystem resulted in short read) while reading indirect blocks of inode 19780.&nbsp; Ignore error? yes</P>
<P>&nbsp; Inode 19780, i_blocks is 1548, should be 540.&nbsp; Fix? yes</P>
<P>&nbsp; Pass 2: Checking directory structure<BR>&nbsp; Error reading block 49405 (Attempt to read block from filesystem resulted in short read).&nbsp; Ignore error? yes</P>
<P>&nbsp; Directory inode 11858, block 0, offset 0: directory corrupted<BR>&nbsp; Salvage? yes</P>
<P>&nbsp; Missing '.' in directory inode 11858.<BR>&nbsp; Fix? yes</P>
<P>&nbsp; Missing '..' in directory inode 11858.<BR>&nbsp; Fix? yes</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; The standard drill in this sort of situation is to fire up gdb on the<BR>&nbsp; signal thread, which, in this case, was pid 1935.&nbsp; In another window,<BR>&nbsp; I run gdb and attach pid 1935.</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~/linux/2.3.26/um 1016: gdb linux<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GNU gdb 4.17.0.11 with Linux support<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Copyright 1998 Free Software Foundation, Inc.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GDB is free software, covered by the GNU General Public License, and you are<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; welcome to change it and/or distribute copies of it under certain conditions.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type "show copying" to see the conditions.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There is absolutely no warranty for GDB.&nbsp; Type "show warranty" for details.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This GDB was configured as "i386-redhat-linux"...</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) att 1935<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Attaching to program `/home/dike/linux/2.3.26/um/linux', Pid 1935<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x100756d9 in __wait4 ()</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Let's see what's currently running:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p current_task.pid<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $1 = 0</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; It's the idle thread, which means that fsck went to sleep for some<BR>&nbsp; reason and never woke up.</P>
<P><BR>&nbsp; Let's guess that the last process in the process list is fsck:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p current_task.prev_task.comm<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $13 = "fsck.ext2\000\000\000\000\000\000"</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; It is, so let's see what it thinks it's up to:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p current_task.prev_task.thread<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $14 = {extern_pid = 1980, tracing = 0, want_tracing = 0, forking = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kernel_stack_page = 0, signal_stack = 1342627840, syscall = {id = 4, args = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3, 134973440, 1024, 0, 1024}, have_result = 0, result = 50590720},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; request = {op = 2, u = {exec = {ip = 1350467584, sp = 2952789424}, fork = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; regs = {1350467584, 2952789424, 0 &lt;repeats 15 times&gt;}, sigstack = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pid = 0}, switch_to = 0x507e8000, thread = {proc = 0x507e8000,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg = 0xaffffdb0, flags = 0, new_pid = 0}, input_request = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; op = 1350467584, fd = -1342177872, proc = 0, pid = 0}}}}</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; The interesting things here are the fact that its .thread.syscall.id<BR>&nbsp; is __NR_write (see the big switch in arch/um/kernel/syscall_kern.c or<BR>&nbsp; the defines in include/asm-um/arch/unistd.h), and that it never<BR>&nbsp; returned.&nbsp; Also, its .request.op is OP_SWITCH (see<BR>&nbsp; arch/um/include/user_util.h).&nbsp; These mean that it went into a write,<BR>&nbsp; and, for some reason, called schedule().</P>
<P><BR>&nbsp; The fact that it never returned from write means that its stack should<BR>&nbsp; be fairly interesting.&nbsp; Its pid is 1980 (.thread.extern_pid).&nbsp; That<BR>&nbsp; process is being ptraced by the signal thread, so it must be detached<BR>&nbsp; before gdb can attach it:</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; (gdb) call detach(1980)</P>
<P>&nbsp; Program received signal SIGSEGV, Segmentation fault.<BR>&nbsp; &lt;function called from gdb&gt;<BR>&nbsp; The program being debugged stopped while in a function called from GDB.<BR>&nbsp; When the function (detach) is done executing, GDB will silently<BR>&nbsp; stop (instead of continuing to evaluate the expression containing<BR>&nbsp; the function call).<BR>&nbsp; (gdb) call detach(1980)<BR>&nbsp; $15 = 0</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; The first detach segfaults for some reason, and the second one<BR>&nbsp; succeeds.</P>
<P><BR>&nbsp; Now I detach from the signal thread, attach to the fsck thread, and<BR>&nbsp; look at its stack:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) det<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Detaching from program: /home/dike/linux/2.3.26/um/linux Pid 1935<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) att 1980<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Attaching to program `/home/dike/linux/2.3.26/um/linux', Pid 1980<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10070451 in __kill ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) bt<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #0&nbsp; 0x10070451 in __kill ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #1&nbsp; 0x10068ccd in usr1_pid (pid=1980) at process.c:30<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #2&nbsp; 0x1006a03f in _switch_to (prev=0x50072000, next=0x507e8000)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at process_kern.c:156<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #3&nbsp; 0x1006a052 in switch_to (prev=0x50072000, next=0x507e8000, last=0x50072000)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at process_kern.c:161<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #4&nbsp; 0x10001d12 in schedule () at sched.c:777<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #5&nbsp; 0x1006a744 in __down (sem=0x507d241c) at semaphore.c:71<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #6&nbsp; 0x1006aa10 in __down_failed () at semaphore.c:157<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #7&nbsp; 0x1006c5d8 in segv_handler (sc=0x5006e940) at trap_user.c:174<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #8&nbsp; 0x1006c5ec in kern_segv_handler (sig=11) at trap_user.c:182<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #9&nbsp; &lt;signal handler called&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #10 0x10155404 in errno ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #11 0x1006c0aa in segv (address=1342179328, is_write=2) at trap_kern.c:50<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #12 0x1006c5d8 in segv_handler (sc=0x5006eaf8) at trap_user.c:174<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #13 0x1006c5ec in kern_segv_handler (sig=11) at trap_user.c:182<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #14 &lt;signal handler called&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #15 0xc0fd in ?? ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #16 0x10016647 in sys_write (fd=3,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf=0x80b8800 &lt;Address 0x80b8800 out of bounds&gt;, count=1024)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at read_write.c:159<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #17 0x1006d5b3 in execute_syscall (syscall=4, args=0x5006ef08)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at syscall_kern.c:254<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #18 0x1006af87 in really_do_syscall (sig=12) at syscall_user.c:35<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #19 &lt;signal handler called&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #20 0x400dc8b0 in ?? ()</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; The interesting things here are :</P>
<P>&nbsp; o&nbsp; There are two segfaults on this stack (frames 9 and 14)</P>
<P>&nbsp; o&nbsp; The first faulting address (frame 11) is 0x50000800</P>
<P>&nbsp; (gdb) p (void *)1342179328<BR>&nbsp; $16 = (void *) 0x50000800</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; The initial faulting address is interesting because it is on the idle<BR>&nbsp; thread's stack.&nbsp; I had been seeing the idle thread segfault for no<BR>&nbsp; apparent reason, and the cause looked like stack corruption.&nbsp; In hopes<BR>&nbsp; of catching the culprit in the act, I had turned off all protections<BR>&nbsp; to that stack while the idle thread wasn't running.&nbsp; This apparently<BR>&nbsp; tripped that trap.</P>
<P><BR>&nbsp; However, the more immediate problem is that second segfault and I'm<BR>&nbsp; going to concentrate on that.&nbsp; First, I want to see where the fault<BR>&nbsp; happened, so I have to go look at the sigcontent struct in frame 8:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) up<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #1&nbsp; 0x10068ccd in usr1_pid (pid=1980) at process.c:30<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kill(pid, SIGUSR1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #2&nbsp; 0x1006a03f in _switch_to (prev=0x50072000, next=0x507e8000)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at process_kern.c:156<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 156&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usr1_pid(getpid());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #3&nbsp; 0x1006a052 in switch_to (prev=0x50072000, next=0x507e8000, last=0x50072000)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at process_kern.c:161<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 161&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _switch_to(prev, next);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #4&nbsp; 0x10001d12 in schedule () at sched.c:777<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 777&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch_to(prev, next, prev);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #5&nbsp; 0x1006a744 in __down (sem=0x507d241c) at semaphore.c:71<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 71&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schedule();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #6&nbsp; 0x1006aa10 in __down_failed () at semaphore.c:157<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 157&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #7&nbsp; 0x1006c5d8 in segv_handler (sc=0x5006e940) at trap_user.c:174<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 174&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segv(sc-&gt;cr2, sc-&gt;err &amp; 2);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #8&nbsp; 0x1006c5ec in kern_segv_handler (sig=11) at trap_user.c:182<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 182&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segv_handler(sc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p *sc<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cannot access memory at address 0x0.</P>
<P>&nbsp;</P>
<P><BR>&nbsp; That's not very useful, so I'll try a more manual method:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p *((struct sigcontext *) (&amp;sig + 1))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $19 = {gs = 0, __gsh = 0, fs = 0, __fsh = 0, es = 43, __esh = 0, ds = 43,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __dsh = 0, edi = 1342179328, esi = 1350378548, ebp = 1342630440,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esp = 1342630420, ebx = 1348150624, edx = 1280, ecx = 0, eax = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trapno = 14, err = 4, eip = 268480945, cs = 35, __csh = 0, eflags = 66118,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esp_at_signal = 1342630420, ss = 43, __ssh = 0, fpstate = 0x0, oldmask = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cr2 = 1280}</P>
<P>&nbsp;</P>
<P>&nbsp; The ip is in handle_mm_fault:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p (void *)268480945<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $20 = (void *) 0x1000b1b1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) i sym $20<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle_mm_fault + 57 in section .text</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; Specifically, it's in pte_alloc:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) i line *$20<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Line 124 of "/home/dike/linux/2.3.26/um/include/asm/pgalloc.h"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; starts at address 0x1000b1b1 &lt;handle_mm_fault+57&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and ends at 0x1000b1b7 &lt;handle_mm_fault+63&gt;.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; To find where in handle_mm_fault this is, I'll jump forward in the<BR>&nbsp; code until I see an address in that procedure:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) i line *0x1000b1c0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Line 126 of "/home/dike/linux/2.3.26/um/include/asm/pgalloc.h"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; starts at address 0x1000b1b7 &lt;handle_mm_fault+63&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and ends at 0x1000b1c3 &lt;handle_mm_fault+75&gt;.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) i line *0x1000b1d0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Line 131 of "/home/dike/linux/2.3.26/um/include/asm/pgalloc.h"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; starts at address 0x1000b1d0 &lt;handle_mm_fault+88&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and ends at 0x1000b1da &lt;handle_mm_fault+98&gt;.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) i line *0x1000b1e0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Line 61 of "/home/dike/linux/2.3.26/um/include/asm/pgalloc.h"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; starts at address 0x1000b1da &lt;handle_mm_fault+98&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and ends at 0x1000b1e1 &lt;handle_mm_fault+105&gt;.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) i line *0x1000b1f0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Line 134 of "/home/dike/linux/2.3.26/um/include/asm/pgalloc.h"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; starts at address 0x1000b1f0 &lt;handle_mm_fault+120&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and ends at 0x1000b200 &lt;handle_mm_fault+136&gt;.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) i line *0x1000b200<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Line 135 of "/home/dike/linux/2.3.26/um/include/asm/pgalloc.h"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; starts at address 0x1000b200 &lt;handle_mm_fault+136&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and ends at 0x1000b208 &lt;handle_mm_fault+144&gt;.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) i line *0x1000b210<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Line 139 of "/home/dike/linux/2.3.26/um/include/asm/pgalloc.h"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; starts at address 0x1000b210 &lt;handle_mm_fault+152&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and ends at 0x1000b219 &lt;handle_mm_fault+161&gt;.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) i line *0x1000b220<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Line 1168 of "memory.c" starts at address 0x1000b21e &lt;handle_mm_fault+166&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and ends at 0x1000b222 &lt;handle_mm_fault+170&gt;.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; Something is apparently wrong with the page tables or vma_structs, so<BR>&nbsp; lets go back to frame 11 and have a look at them:</P>
<P>&nbsp;</P>
<P>&nbsp; #11 0x1006c0aa in segv (address=1342179328, is_write=2) at trap_kern.c:50<BR>&nbsp; 50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle_mm_fault(current, vma, address, is_write);<BR>&nbsp; (gdb) call pgd_offset_proc(vma-&gt;vm_mm, address)<BR>&nbsp; $22 = (pgd_t *) 0x80a548c</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; That's pretty bogus.&nbsp; Page tables aren't supposed to be in process<BR>&nbsp; text or data areas.&nbsp; Let's see what's in the vma:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p *vma<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $23 = {vm_mm = 0x507d2434, vm_start = 0, vm_end = 134512640,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vm_next = 0x80a4f8c, vm_page_prot = {pgprot = 0}, vm_flags = 31200,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vm_avl_height = 2058, vm_avl_left = 0x80a8c94, vm_avl_right = 0x80d1000,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vm_next_share = 0xaffffdb0, vm_pprev_share = 0xaffffe63,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vm_ops = 0xaffffe7a, vm_pgoff = 2952789626, vm_file = 0xafffffec,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vm_private_data = 0x62}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p *vma.vm_mm<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $24 = {mmap = 0x507d2434, mmap_avl = 0x0, mmap_cache = 0x8048000,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pgd = 0x80a4f8c, mm_users = {counter = 0}, mm_count = {counter = 134904288},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; map_count = 134909076, mmap_sem = {count = {counter = 135073792},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sleepers = -1342177872, wait = {lock = &lt;optimized out or zero length&gt;,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; task_list = {next = 0xaffffe63, prev = 0xaffffe7a},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __magic = -1342177670, __creator = -1342177300}, __magic = 98},<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; page_table_lock = {}, context = 138, start_code = 0, end_code = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start_data = 0, end_data = 0, start_brk = 0, brk = 0, start_stack = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg_start = 0, arg_end = 0, env_start = 0, env_end = 0, rss = 1350381536,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total_vm = 0, locked_vm = 0, def_flags = 0, cpu_vm_mask = 0, swap_cnt = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; swap_address = 0, segments = 0x0}</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; This also pretty bogus.&nbsp; With all of the 0x80xxxxx and 0xaffffxxx<BR>&nbsp; addresses, this is looking like a stack was plonked down on top of<BR>&nbsp; these structures.&nbsp; Maybe it's a stack overflow from the next page:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p vma<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $25 = (struct vm_area_struct *) 0x507d2434</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; That's towards the lower quarter of the page, so that would have to<BR>&nbsp; have been pretty heavy stack overflow:</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; (gdb) x/100x $25<BR>&nbsp; 0x507d2434:&nbsp;&nbsp;&nbsp;&nbsp; 0x507d2434&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x08048000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x080a4f8c<BR>&nbsp; 0x507d2444:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x080a79e0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x080a8c94&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x080d1000<BR>&nbsp; 0x507d2454:&nbsp;&nbsp;&nbsp;&nbsp; 0xaffffdb0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xaffffe63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xaffffe7a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xaffffe7a<BR>&nbsp; 0x507d2464:&nbsp;&nbsp;&nbsp;&nbsp; 0xafffffec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000062&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000008a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d2474:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d2484:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d2494:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x507d2fe0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d24a4:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d24b4:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d24c4:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d24d4:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d24e4:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d24f4:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d2504:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d2514:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d2524:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d2534:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x507d25dc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d2544:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d2554:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d2564:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d2574:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d2584:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d2594:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d25a4:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000<BR>&nbsp; 0x507d25b4:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; It's not stack overflow.&nbsp; The only "stack-like" piece of this data is<BR>&nbsp; the vma_struct itself.</P>
<P><BR>&nbsp; At this point, I don't see any avenues to pursue, so I just have to<BR>&nbsp; admit that I have no idea what's going on.&nbsp; What I will do, though, is<BR>&nbsp; stick a trap on the segfault handler which will stop if it sees any<BR>&nbsp; writes to the idle thread's stack.&nbsp; That was the thing that happened<BR>&nbsp; first, and it may be that if I can catch it immediately, what's going<BR>&nbsp; on will be somewhat clearer.</P>
<P><BR>&nbsp; 12.2.&nbsp; Episode 2: The case of the hung fsck</P>
<P>&nbsp; After setting a trap in the SEGV handler for accesses to the signal<BR>&nbsp; thread's stack, I reran the kernel.</P>
<P><BR>&nbsp; fsck hung again, this time by hitting the trap:</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Setting hostname uml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ OK ]<BR>&nbsp; Checking root filesystem<BR>&nbsp; /dev/fhd0 contains a file system with errors, check forced.<BR>&nbsp; Error reading block 86894 (Attempt to read block from filesystem resulted in short read) while reading indirect blocks of inode 19780.</P>
<P>&nbsp; /dev/fhd0: UNEXPECTED INCONSISTENCY; RUN fsck MANUALLY.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (i.e., without -a or -p options)<BR>&nbsp; [ FAILED ]</P>
<P>&nbsp; *** An error occurred during the file system check.<BR>&nbsp; *** Dropping you to a shell; the system will reboot<BR>&nbsp; *** when you leave the shell.<BR>&nbsp; Give root password for maintenance<BR>&nbsp; (or type Control-D for normal startup):</P>
<P>&nbsp; [root@uml /root]# fsck -y /dev/fhd0<BR>&nbsp; fsck -y /dev/fhd0<BR>&nbsp; Parallelizing fsck version 1.14 (9-Jan-1999)<BR>&nbsp; e2fsck 1.14, 9-Jan-1999 for EXT2 FS 0.5b, 95/08/09<BR>&nbsp; /dev/fhd0 contains a file system with errors, check forced.<BR>&nbsp; Pass 1: Checking inodes, blocks, and sizes<BR>&nbsp; Error reading block 86894 (Attempt to read block from filesystem resulted in short read) while reading indirect blocks of inode 19780.&nbsp; Ignore error? yes</P>
<P>&nbsp; Pass 2: Checking directory structure<BR>&nbsp; Error reading block 49405 (Attempt to read block from filesystem resulted in short read).&nbsp; Ignore error? yes</P>
<P>&nbsp; Directory inode 11858, block 0, offset 0: directory corrupted<BR>&nbsp; Salvage? yes</P>
<P>&nbsp; Missing '.' in directory inode 11858.<BR>&nbsp; Fix? yes</P>
<P>&nbsp; Missing '..' in directory inode 11858.<BR>&nbsp; Fix? yes</P>
<P>&nbsp; Untested (4127) [100fe44c]: trap_kern.c line 31</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; I need to get the signal thread to detach from pid 4127 so that I can<BR>&nbsp; attach to it with gdb.&nbsp; This is done by sending it a SIGUSR1, which is<BR>&nbsp; caught by the signal thread, which detaches the process:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kill -USR1 4127</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; Now I can run gdb on it:</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; ~/linux/2.3.26/um 1034: gdb linux<BR>&nbsp; GNU gdb 4.17.0.11 with Linux support<BR>&nbsp; Copyright 1998 Free Software Foundation, Inc.<BR>&nbsp; GDB is free software, covered by the GNU General Public License, and you are<BR>&nbsp; welcome to change it and/or distribute copies of it under certain conditions.<BR>&nbsp; Type "show copying" to see the conditions.<BR>&nbsp; There is absolutely no warranty for GDB.&nbsp; Type "show warranty" for details.<BR>&nbsp; This GDB was configured as "i386-redhat-linux"...<BR>&nbsp; (gdb) att 4127<BR>&nbsp; Attaching to program `/home/dike/linux/2.3.26/um/linux', Pid 4127<BR>&nbsp; 0x10075891 in __libc_nanosleep ()</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; The backtrace shows that it was in a write and that the fault address<BR>&nbsp; (address in frame 3) is 0x50000800, which is right in the middle of<BR>&nbsp; the signal thread's stack page:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) bt<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #0&nbsp; 0x10075891 in __libc_nanosleep ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #1&nbsp; 0x1007584d in __sleep (seconds=1000000)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at ../sysdeps/unix/sysv/linux/sleep.c:78<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #2&nbsp; 0x1006ce9a in stop () at user_util.c:191<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #3&nbsp; 0x1006bf88 in segv (address=1342179328, is_write=2) at trap_kern.c:31<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #4&nbsp; 0x1006c628 in segv_handler (sc=0x5006eaf8) at trap_user.c:174<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #5&nbsp; 0x1006c63c in kern_segv_handler (sig=11) at trap_user.c:182<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #6&nbsp; &lt;signal handler called&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #7&nbsp; 0xc0fd in ?? ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #8&nbsp; 0x10016647 in sys_write (fd=3, buf=0x80b8800 "R.", count=1024)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at read_write.c:159<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #9&nbsp; 0x1006d603 in execute_syscall (syscall=4, args=0x5006ef08)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at syscall_kern.c:254<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #10 0x1006af87 in really_do_syscall (sig=12) at syscall_user.c:35<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #11 &lt;signal handler called&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #12 0x400dc8b0 in ?? ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #13 &lt;signal handler called&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #14 0x400dc8b0 in ?? ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #15 0x80545fd in ?? ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #16 0x804daae in ?? ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #17 0x8054334 in ?? ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #18 0x804d23e in ?? ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #19 0x8049632 in ?? ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #20 0x80491d2 in ?? ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #21 0x80596b5 in ?? ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p (void *)1342179328<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $3 = (void *) 0x50000800</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; Going up the stack to the segv_handler frame and looking at where in<BR>&nbsp; the code the access happened shows that it happened near line 110 of<BR>&nbsp; block_dev.c:</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; (gdb) up<BR>&nbsp; #1&nbsp; 0x1007584d in __sleep (seconds=1000000)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at ../sysdeps/unix/sysv/linux/sleep.c:78<BR>&nbsp; ../sysdeps/unix/sysv/linux/sleep.c:78: No such file or directory.<BR>&nbsp; (gdb)<BR>&nbsp; #2&nbsp; 0x1006ce9a in stop () at user_util.c:191<BR>&nbsp; 191&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(1) sleep(1000000);<BR>&nbsp; (gdb)<BR>&nbsp; #3&nbsp; 0x1006bf88 in segv (address=1342179328, is_write=2) at trap_kern.c:31<BR>&nbsp; 31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KERN_UNTESTED();<BR>&nbsp; (gdb)<BR>&nbsp; #4&nbsp; 0x1006c628 in segv_handler (sc=0x5006eaf8) at trap_user.c:174<BR>&nbsp; 174&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segv(sc-&gt;cr2, sc-&gt;err &amp; 2);<BR>&nbsp; (gdb) p *sc<BR>&nbsp; $1 = {gs = 0, __gsh = 0, fs = 0, __fsh = 0, es = 43, __esh = 0, ds = 43,<BR>&nbsp;&nbsp;&nbsp; __dsh = 0, edi = 1342179328, esi = 134973440, ebp = 1342631484,<BR>&nbsp;&nbsp;&nbsp; esp = 1342630864, ebx = 256, edx = 0, ecx = 256, eax = 1024, trapno = 14,<BR>&nbsp;&nbsp;&nbsp; err = 6, eip = 268550834, cs = 35, __csh = 0, eflags = 66070,<BR>&nbsp;&nbsp;&nbsp; esp_at_signal = 1342630864, ss = 43, __ssh = 0, fpstate = 0x0, oldmask = 0,<BR>&nbsp;&nbsp;&nbsp; cr2 = 1342179328}<BR>&nbsp; (gdb) p (void *)268550834<BR>&nbsp; $2 = (void *) 0x1001c2b2<BR>&nbsp; (gdb) i sym $2<BR>&nbsp; block_write + 1090 in section .text<BR>&nbsp; (gdb) i line *$2<BR>&nbsp; Line 209 of "/home/dike/linux/2.3.26/um/include/asm/arch/string.h"<BR>&nbsp;&nbsp;&nbsp;&nbsp; starts at address 0x1001c2a1 &lt;block_write+1073&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp; and ends at 0x1001c2bf &lt;block_write+1103&gt;.<BR>&nbsp; (gdb) i line *0x1001c2c0<BR>&nbsp; Line 110 of "block_dev.c" starts at address 0x1001c2bf &lt;block_write+1103&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp; and ends at 0x1001c2e3 &lt;block_write+1139&gt;.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; Looking at the source shows that the fault happened during a call to<BR>&nbsp; copy_from_user to copy the data into the kernel:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 107&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count -= chars;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 108&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy_from_user(p,buf,chars);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 109&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p += chars;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf += chars;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; p is the pointer which must contain 0x50000800, since buf contains<BR>&nbsp; 0x80b8800 (frame 8 above).&nbsp; It is defined as:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = offset + bh-&gt;b_data;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; I need to figure out what bh is, and it just so happens that bh is<BR>&nbsp; passed as an argument to mark_buffer_uptodate and mark_buffer_dirty a<BR>&nbsp; few lines later, so I do a little disassembly:</P>
<P>&nbsp;</P>
<P><BR>&nbsp; (gdb) disas 0x1001c2bf 0x1001c2e0<BR>&nbsp; Dump of assembler code from 0x1001c2bf to 0x1001c2d0:<BR>&nbsp; 0x1001c2bf &lt;block_write+1103&gt;:&nbsp; addl&nbsp;&nbsp; %eax,0xc(%ebp)<BR>&nbsp; 0x1001c2c2 &lt;block_write+1106&gt;:&nbsp; movl&nbsp;&nbsp; 0xfffffdd4(%ebp),%edx<BR>&nbsp; 0x1001c2c8 &lt;block_write+1112&gt;:&nbsp; btsl&nbsp;&nbsp; $0x0,0x18(%edx)<BR>&nbsp; 0x1001c2cd &lt;block_write+1117&gt;:&nbsp; btsl&nbsp;&nbsp; $0x1,0x18(%edx)<BR>&nbsp; 0x1001c2d2 &lt;block_write+1122&gt;:&nbsp; sbbl&nbsp;&nbsp; %ecx,%ecx<BR>&nbsp; 0x1001c2d4 &lt;block_write+1124&gt;:&nbsp; testl&nbsp; %ecx,%ecx<BR>&nbsp; 0x1001c2d6 &lt;block_write+1126&gt;:&nbsp; jne&nbsp;&nbsp;&nbsp; 0x1001c2e3 &lt;block_write+1139&gt;<BR>&nbsp; 0x1001c2d8 &lt;block_write+1128&gt;:&nbsp; pushl&nbsp; $0x0<BR>&nbsp; 0x1001c2da &lt;block_write+1130&gt;:&nbsp; pushl&nbsp; %edx<BR>&nbsp; 0x1001c2db &lt;block_write+1131&gt;:&nbsp; call&nbsp;&nbsp; 0x1001819c &lt;__mark_buffer_dirty&gt;<BR>&nbsp; End of assembler dump.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; At that point, bh is in %edx (address 0x1001c2da), which is calculated<BR>&nbsp; at 0x1001c2c2 as %ebp + 0xfffffdd4, so I figure exactly what that is,<BR>&nbsp; taking %ebp from the sigcontext_struct above:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p (void *)1342631484<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $5 = (void *) 0x5006ee3c<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p 0x5006ee3c+0xfffffdd4<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $6 = 1342630928<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p (void *)$6<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $7 = (void *) 0x5006ec10<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p *((void **)$7)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $8 = (void *) 0x50100200</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; Now, I look at the structure to see what's in it, and particularly,<BR>&nbsp; what its b_data field contains:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p *((struct buffer_head *)0x50100200)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $13 = {b_next = 0x50289380, b_blocknr = 49405, b_size = 1024, b_list = 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b_dev = 15872, b_count = {counter = 1}, b_rdev = 15872, b_state = 24,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b_flushtime = 0, b_next_free = 0x501001a0, b_prev_free = 0x50100260,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b_this_page = 0x501001a0, b_reqnext = 0x0, b_pprev = 0x507fcf58,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b_data = 0x50000800 "", b_page = 0x50004000,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b_end_io = 0x10017f60 &lt;end_buffer_io_sync&gt;, b_dev_id = 0x0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b_rsector = 98810, b_wait = {lock = &lt;optimized out or zero length&gt;,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; task_list = {next = 0x50100248, prev = 0x50100248}, __magic = 1343226448,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __creator = 0}, b_kiobuf = 0x0}</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; The b_data field is indeed 0x50000800, so the question becomes how<BR>&nbsp; that happened.&nbsp; The rest of the structure looks fine, so this probably<BR>&nbsp; is not a case of data corruption.&nbsp; It happened on purpose somehow.</P>
<P><BR>&nbsp; The b_page field is a pointer to the page_struct representing the<BR>&nbsp; 0x50000000 page.&nbsp; Looking at it shows the kernel's idea of the state<BR>&nbsp; of that page:</P>
<P>&nbsp;</P>
<P>&nbsp; (gdb) p *$13.b_page<BR>&nbsp; $17 = {list = {next = 0x50004a5c, prev = 0x100c5174}, mapping = 0x0,<BR>&nbsp;&nbsp;&nbsp; index = 0, next_hash = 0x0, count = {counter = 1}, flags = 132, lru = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next = 0x50008460, prev = 0x50019350}, wait = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock = &lt;optimized out or zero length&gt;, task_list = {next = 0x50004024,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev = 0x50004024}, __magic = 1342193708, __creator = 0},<BR>&nbsp;&nbsp;&nbsp; pprev_hash = 0x0, buffers = 0x501002c0, virtual = 1342177280,<BR>&nbsp;&nbsp;&nbsp; zone = 0x100c5160}</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; Some sanity-checking: the virtual field shows the "virtual" address of<BR>&nbsp; this page, which in this kernel is the same as its "physical" address,<BR>&nbsp; and the page_struct itself should be mem_map[0], since it represents<BR>&nbsp; the first page of memory:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p (void *)1342177280<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $18 = (void *) 0x50000000<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p mem_map<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $19 = (mem_map_t *) 0x50004000</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; These check out fine.</P>
<P><BR>&nbsp; Now to check out the page_struct itself.&nbsp; In particular, the flags<BR>&nbsp; field shows whether the page is considered free or not:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p (void *)132<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $21 = (void *) 0x84</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; The "reserved" bit is the high bit, which is definitely not set, so<BR>&nbsp; the kernel considers the signal stack page to be free and available to<BR>&nbsp; be used.</P>
<P><BR>&nbsp; At this point, I jump to conclusions and start looking at my early<BR>&nbsp; boot code, because that's where that page is supposed to be reserved.</P>
<P><BR>&nbsp; In my setup_arch procedure, I have the following code which looks just<BR>&nbsp; fine:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bootmap_size = init_bootmem(start_pfn, end_pfn - start_pfn);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free_bootmem(__pa(low_physmem) + bootmap_size, high_physmem - low_physmem);</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; Two stack pages have already been allocated, and low_physmem points to<BR>&nbsp; the third page, which is the beginning of free memory.<BR>&nbsp; The init_bootmem call declares the entire memory to the boot memory<BR>&nbsp; manager, which marks it all reserved.&nbsp; The free_bootmem call frees up<BR>&nbsp; all of it, except for the first two pages.&nbsp; This looks correct to me.</P>
<P><BR>&nbsp; So, I decide to see init_bootmem run and make sure that it is marking<BR>&nbsp; those first two pages as reserved.&nbsp; I never get that far.</P>
<P><BR>&nbsp; Stepping into init_bootmem, and looking at bootmem_map before looking<BR>&nbsp; at what it contains shows the following:</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gdb) p bootmem_map<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $3 = (void *) 0x50000000</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; Aha!&nbsp; The light dawns.&nbsp; That first page is doing double duty as a<BR>&nbsp; stack and as the boot memory map.&nbsp; The last thing that the boot memory<BR>&nbsp; manager does is to free the pages used by its memory map, so this page<BR>&nbsp; is getting freed even its marked as reserved.</P>
<P><BR>&nbsp; The fix was to initialize the boot memory manager before allocating<BR>&nbsp; those two stack pages, and then allocate them through the boot memory<BR>&nbsp; manager.&nbsp; After doing this, and fixing a couple of subsequent buglets,<BR>&nbsp; the stack corruption problem disappeared.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; 13.&nbsp; What to do when UML doesn't work</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 13.1.&nbsp; Strange compilation errors when you build from source</P>
<P>&nbsp; As of test11, it is necessary to have "ARCH=um" in the environment or<BR>&nbsp; on the make command line for all steps in building UML, including<BR>&nbsp; clean, distclean, or mrproper, config, menuconfig, or xconfig, dep,<BR>&nbsp; and linux.&nbsp; If you forget for any of them, the i386 build seems to<BR>&nbsp; contaminate the UML build.&nbsp; If this happens, start from scratch with</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host%<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make mrproper ARCH=um</P>
<P>&nbsp;</P>
<P><BR>&nbsp; and repeat the build process with ARCH=um on all the steps.</P>
<P><BR>&nbsp; See ``Compiling the kernel and modules''&nbsp; for more details.</P>
<P><BR>&nbsp; Another cause of strange compilation errors is building UML in<BR>&nbsp; /usr/src/linux.&nbsp; If you do this, the first thing you need to do is<BR>&nbsp; clean up the mess you made.&nbsp; The /usr/src/linux/asm link will now<BR>&nbsp; point to /usr/src/linux/asm-um.&nbsp; Make it point back to<BR>&nbsp; /usr/src/linux/asm-i386.&nbsp; Then, move your UML pool someplace else and<BR>&nbsp; build it there.&nbsp; Also see below, where a more specific set of symptoms<BR>&nbsp; is described.</P>
<P>&nbsp;</P>
<P>&nbsp; 13.3.&nbsp; A variety of panics and hangs with /tmp on a reiserfs&nbsp; filesys-<BR>&nbsp; tem</P>
<P>&nbsp; I saw this on reiserfs 3.5.21 and it seems to be fixed in 3.5.27.<BR>&nbsp; Panics preceded by</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Detaching pid nnnn</P>
<P>&nbsp;</P>
<P>&nbsp; are diagnostic of this problem.&nbsp; This is a reiserfs bug which causes a<BR>&nbsp; thread to occasionally read stale data from a mmapped page shared with<BR>&nbsp; another thread.&nbsp; The fix is to upgrade the filesystem or to have /tmp<BR>&nbsp; be an ext2 filesystem.</P>
<P>&nbsp;</P>
<P>&nbsp; 13.4.&nbsp; The compile fails with errors about conflicting types for<BR>&nbsp; 'open', 'dup', and 'waitpid'</P>
<P>&nbsp; This happens when you build in /usr/src/linux.&nbsp; The UML build makes<BR>&nbsp; the include/asm link point to include/asm-um.&nbsp; /usr/include/asm points<BR>&nbsp; to /usr/src/linux/include/asm, so when that link gets moved, files<BR>&nbsp; which need to include the asm-i386 versions of headers get the<BR>&nbsp; incompatible asm-um versions.&nbsp; The fix is to move the include/asm link<BR>&nbsp; back to include/asm-i386 and to do UML builds someplace else.</P>
<P>&nbsp;</P>
<P>&nbsp; 13.5.&nbsp; UML doesn't work when /tmp is an NFS filesystem</P>
<P>&nbsp; This seems to be a similar situation with the ReiserFS problem above.<BR>&nbsp; Some versions of NFS seems not to handle mmap correctly, which UML<BR>&nbsp; depends on.&nbsp; The workaround is have /tmp be a non-NFS directory.</P>
<P><BR>&nbsp; 13.6.&nbsp; UML hangs on boot when compiled with gprof support</P>
<P>&nbsp; If you build UML with gprof support and, early in the boot, it does<BR>&nbsp; this</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kernel BUG at page_alloc.c:100!</P>
<P>&nbsp;</P>
<P><BR>&nbsp; you have a buggy gcc.&nbsp; You can work around the problem by removing<BR>&nbsp; UM_FASTCALL from CFLAGS in arch/um/Makefile-i386.&nbsp; This will open up<BR>&nbsp; another bug, but that one is fairly hard to reproduce.</P>
<P>&nbsp;</P>
<P>&nbsp; 13.7.&nbsp; syslogd dies with a SIGTERM on startup</P>
<P>&nbsp; The exact boot error depends on the distribution that you're booting,<BR>&nbsp; but Debian produces this:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /etc/rc2.d/S10sysklogd: line 49:&nbsp;&nbsp;&nbsp; 93 Terminated<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start-stop-daemon --start --quiet --exec /sbin/syslogd -- $SYSLOGD</P>
<P>&nbsp;</P>
<P><BR>&nbsp; This is a syslogd bug.&nbsp; There's a race between a parent process<BR>&nbsp; installing a signal handler and its child sending the signal.&nbsp; See<BR>&nbsp; this uml-devel post &lt;<A href="http://www.geocrawler.com/lists/3/Source">http://www.geocrawler.com/lists/3/Source</A>-<BR>&nbsp; Forge/709/0/6612801&gt;&nbsp; for the details.</P>
<P>&nbsp;</P>
<P>&nbsp; 13.8.&nbsp; TUN/TAP networking doesn't work on a 2.4 host</P>
<P>&nbsp; There are a couple of problems which were<BR>&nbsp; &lt;<A href="http://www.geocrawler.com/lists/3/SourceForge/597/0/">http://www.geocrawler.com/lists/3/SourceForge/597/0/</A>&gt; name="pointed<BR>&nbsp; out"&gt;&nbsp; by Tim Robinson &lt;timro at trkr dot net&gt;</P>
<P>&nbsp; o&nbsp; It doesn't work on hosts running 2.4.7 (or thereabouts) or earlier.<BR>&nbsp;&nbsp;&nbsp;&nbsp; The fix is to upgrade to something more recent and then read the<BR>&nbsp;&nbsp;&nbsp;&nbsp; next item.</P>
<P>&nbsp; o&nbsp; If you see</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File descriptor in bad state</P>
<P>&nbsp;</P>
<P>&nbsp; when you bring up the device inside UML, you have a header mismatch<BR>&nbsp; between the original kernel and the upgraded one.&nbsp; Make /usr/src/linux<BR>&nbsp; point at the new headers.&nbsp; This will only be a problem if you build<BR>&nbsp; uml_net yourself.</P>
<P>&nbsp;</P>
<P>&nbsp; 13.9.&nbsp; You can network to the host but not to other machines on the<BR>&nbsp; net</P>
<P>&nbsp; If you can connect to the host, and the host can connect to UML, but<BR>&nbsp; you cannot connect to any other machines, then you may need to enable<BR>&nbsp; IP Masquerading on the host.&nbsp; Usually this is only experienced when<BR>&nbsp; using private IP addresses (192.168.x.x or 10.x.x.x) for host/UML<BR>&nbsp; networking, rather than the public address space that your host is<BR>&nbsp; connected to.&nbsp; UML does not enable IP Masquerading, so you will need<BR>&nbsp; to create a static rule to enable it:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host%<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Replace eth0 with the interface that you use to talk to the rest of<BR>&nbsp; the world.</P>
<P><BR>&nbsp; Documentation on IP Masquerading, and SNAT, can be found at<BR>&nbsp; <A href="http://www.netfilter.org">www.netfilter.org</A>&nbsp; &lt;<A href="http://www.netfilter.org">http://www.netfilter.org</A>&gt; .</P>
<P><BR>&nbsp; If you can reach the local net, but not the outside Internet, then<BR>&nbsp; that is usually a routing problem.&nbsp; The UML needs a default route:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UML#<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; route add default gw gateway IP</P>
<P>&nbsp;</P>
<P><BR>&nbsp; The gateway IP can be any machine on the local net that knows how to<BR>&nbsp; reach the outside world.&nbsp; Usually, this is the host or the local net-<BR>&nbsp; work's gateway.</P>
<P><BR>&nbsp; Occasionally, we hear from someone who can reach some machines, but<BR>&nbsp; not others on the same net, or who can reach some ports on other<BR>&nbsp; machines, but not others.&nbsp; These are usually caused by strange<BR>&nbsp; firewalling somewhere between the UML and the other box.&nbsp; You track<BR>&nbsp; this down by running tcpdump on every interface the packets travel<BR>&nbsp; over and see where they disappear.&nbsp; When you find a machine that takes<BR>&nbsp; the packets in, but does not send them onward, that's the culprit.</P>
<P>&nbsp;</P>
<P>&nbsp; 13.10.&nbsp; I have no root and I want to scream</P>
<P>&nbsp; Thanks to Birgit Wahlich for telling me about this strange one.&nbsp; It<BR>&nbsp; turns out that there's a limit of six environment variables on the<BR>&nbsp; kernel command line.&nbsp; When that limit is reached or exceeded, argument<BR>&nbsp; processing stops, which means that the 'root=' argument that UML<BR>&nbsp; usually adds is not seen.&nbsp; So, the filesystem has no idea what the<BR>&nbsp; root device is, so it panics.</P>
<P><BR>&nbsp; The fix is to put less stuff on the command line.&nbsp; Glomming all your<BR>&nbsp; setup variables into one is probably the best way to go.</P>
<P>&nbsp;</P>
<P>&nbsp; 13.11.&nbsp; UML build conflict between ptrace.h and ucontext.h</P>
<P>&nbsp; On some older systems, /usr/include/asm/ptrace.h and<BR>&nbsp; /usr/include/sys/ucontext.h define the same names.&nbsp; So, when they're<BR>&nbsp; included together, the defines from one completely mess up the parsing<BR>&nbsp; of the other, producing errors like:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /usr/include/sys/ucontext.h:47: parse error before<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `10'</P>
<P>&nbsp;</P>
<P><BR>&nbsp; plus a pile of warnings.</P>
<P><BR>&nbsp; This is a libc botch, which has since been fixed, and I don't see any<BR>&nbsp; way around it besides upgrading.</P>
<P>&nbsp;</P>
<P>&nbsp; 13.12.&nbsp; The UML BogoMips is exactly half the host's BogoMips</P>
<P>&nbsp; On i386 kernels, there are two ways of running the loop that is used<BR>&nbsp; to calculate the BogoMips rating, using the TSC if it's there or using<BR>&nbsp; a one-instruction loop.&nbsp; The TSC produces twice the BogoMips as the<BR>&nbsp; loop.&nbsp; UML uses the loop, since it has nothing resembling a TSC, and<BR>&nbsp; will get almost exactly the same BogoMips as a host using the loop.<BR>&nbsp; However, on a host with a TSC, its BogoMips will be double the loop<BR>&nbsp; BogoMips, and therefore double the UML BogoMips.</P>
<P>&nbsp;</P>
<P>&nbsp; 13.13.&nbsp; When you run UML, it immediately segfaults</P>
<P>&nbsp; If the host is configured with the 2G/2G address space split, that's<BR>&nbsp; why.&nbsp; See ``UML on 2G/2G hosts''&nbsp; for the details on getting UML to<BR>&nbsp; run on your host.</P>
<P>&nbsp;</P>
<P>&nbsp; 13.14.&nbsp; xterms appear, then immediately disappear</P>
<P>&nbsp; If you're running an up to date kernel with an old release of<BR>&nbsp; uml_utilities, the port-helper program will not work properly, so<BR>&nbsp; xterms will exit straight after they appear. The solution is to<BR>&nbsp; upgrade to the latest release of uml_utilities.&nbsp; Usually this problem<BR>&nbsp; occurs when you have installed a packaged release of UML then compiled<BR>&nbsp; your own development kernel without upgrading the uml_utilities from<BR>&nbsp; the source distribution.</P>
<P>&nbsp;</P>
<P>&nbsp; 13.15.&nbsp; Any other panic, hang, or strange behavior</P>
<P>&nbsp; If you're seeing truly strange behavior, such as hangs or panics that<BR>&nbsp; happen in random places, or you try running the debugger to see what's<BR>&nbsp; happening and it acts strangely, then it could be a problem in the<BR>&nbsp; host kernel.&nbsp; If you're not running a stock Linus or -ac kernel, then<BR>&nbsp; try that.&nbsp; An early version of the preemption patch and a 2.4.10 SuSE<BR>&nbsp; kernel have caused very strange problems in UML.</P>
<P><BR>&nbsp; Otherwise, let me know about it.&nbsp; Send a message to one of the UML<BR>&nbsp; mailing lists - either the developer list - user-mode-linux-devel at<BR>&nbsp; lists dot sourceforge dot net (subscription info) or the user list -<BR>&nbsp; user-mode-linux-user at lists dot sourceforge do net (subscription<BR>&nbsp; info), whichever you prefer.&nbsp; Don't assume that everyone knows about<BR>&nbsp; it and that a fix is imminent.</P>
<P><BR>&nbsp; If you want to be super-helpful, read ``Diagnosing Problems'' and<BR>&nbsp; follow the instructions contained therein.<BR>&nbsp; 14.&nbsp; Diagnosing Problems</P>
<P><BR>&nbsp; If you get UML to crash, hang, or otherwise misbehave, you should<BR>&nbsp; report this on one of the project mailing lists, either the developer<BR>&nbsp; list - user-mode-linux-devel at lists dot sourceforge dot net<BR>&nbsp; (subscription info) or the user list - user-mode-linux-user at lists<BR>&nbsp; dot sourceforge dot net (subscription info).&nbsp; When you do, it is<BR>&nbsp; likely that I will want more information.&nbsp; So, it would be helpful to<BR>&nbsp; read the stuff below, do whatever is applicable in your case, and<BR>&nbsp; report the results to the list.</P>
<P><BR>&nbsp; For any diagnosis, you're going to need to build a debugging kernel.<BR>&nbsp; The binaries from this site aren't debuggable.&nbsp; If you haven't done<BR>&nbsp; this before, read about ``Compiling the kernel and modules''&nbsp; and<BR>&nbsp; ``Kernel debugging''&nbsp; UML first.</P>
<P><BR>&nbsp; 14.1.&nbsp; Case 1 : Normal kernel panics</P>
<P>&nbsp; The most common case is for a normal thread to panic.&nbsp; To debug this,<BR>&nbsp; you will need to run it under the debugger (add 'debug' to the command<BR>&nbsp; line).&nbsp; An xterm will start up with gdb running inside it.&nbsp; Continue<BR>&nbsp; it when it stops in start_kernel and make it crash.&nbsp; Now ^C gdb and</P>
<P><BR>&nbsp; If the panic was a "Kernel mode fault", then there will be a segv<BR>&nbsp; frame on the stack and I'm going to want some more information.&nbsp; The<BR>&nbsp; stack might look something like this:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UML gdb)&nbsp; backtrace<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #0&nbsp; 0x1009bf76 in __sigprocmask (how=1, set=0x5f347940, oset=0x0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at ../sysdeps/unix/sysv/linux/sigprocmask.c:49<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #1&nbsp; 0x10091411 in change_sig (signal=10, on=1) at process.c:218<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #2&nbsp; 0x10094785 in timer_handler (sig=26) at time_kern.c:32<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #3&nbsp; 0x1009bf38 in __restore ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at ../sysdeps/unix/sysv/linux/i386/sigaction.c:125<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #4&nbsp; 0x1009534c in segv (address=8, ip=268849158, is_write=2, is_user=0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at trap_kern.c:66<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #5&nbsp; 0x10095c04 in segv_handler (sig=11) at trap_user.c:285<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #6&nbsp; 0x1009bf38 in __restore ()</P>
<P>&nbsp;</P>
<P><BR>&nbsp; I'm going to want to see the symbol and line information for the value<BR>&nbsp; of ip in the segv frame.&nbsp; In this case, you would do the following:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UML gdb)&nbsp; i sym 268849158</P>
<P>&nbsp;</P>
<P><BR>&nbsp; and</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UML gdb)&nbsp; i line *268849158</P>
<P>&nbsp;</P>
<P><BR>&nbsp; The reason for this is the __restore frame right above the segv_han-<BR>&nbsp; dler frame is hiding the frame that actually segfaulted.&nbsp; So, I have<BR>&nbsp; to get that information from the faulting ip.</P>
<P><BR>&nbsp; 14.2.&nbsp; Case 2 : Tracing thread panics</P>
<P>&nbsp; The less common and more painful case is when the tracing thread<BR>&nbsp; panics.&nbsp; In this case, the kernel debugger will be useless because it<BR>&nbsp; needs a healthy tracing thread in order to work.&nbsp; The first thing to<BR>&nbsp; do is get a backtrace from the tracing thread.&nbsp; This is done by<BR>&nbsp; figuring out what its pid is, firing up gdb, and attaching it to that<BR>&nbsp; pid.&nbsp; You can figure out the tracing thread pid by looking at the<BR>&nbsp; first line of the console output, which will look like this:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tracing thread pid = 15851</P>
<P>&nbsp;</P>
<P><BR>&nbsp; or by running ps on the host and finding the line that looks like<BR>&nbsp; this:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jdike 15851 4.5 0.4 132568 1104 pts/0 S 21:34 0:05 ./linux [(tracing thread)]</P>
<P>&nbsp;</P>
<P><BR>&nbsp; If the panic was 'segfault in signals', then follow the instructions<BR>&nbsp; above for collecting information about the location of the seg fault.</P>
<P><BR>&nbsp; If the tracing thread flaked out all by itself, then send that<BR>&nbsp; backtrace in and wait for our crack debugging team to fix the problem.</P>
<P><BR>&nbsp; 14.3.&nbsp; Case 3 : Tracing thread panics caused by other threads</P>
<P>&nbsp; However, there are cases where the misbehavior of another thread<BR>&nbsp; caused the problem.&nbsp; The most common panic of this type is:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wait_for_stop failed to wait for&nbsp; &lt;pid&gt;&nbsp; to stop with&nbsp; &lt;signal number&gt;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; In this case, you'll need to get a backtrace from the process men-<BR>&nbsp; tioned in the panic, which is complicated by the fact that the kernel<BR>&nbsp; debugger is defunct and without some fancy footwork, another gdb can't<BR>&nbsp; attach to it.&nbsp; So, this is how the fancy footwork goes:</P>
<P>&nbsp; In a shell:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host% kill -STOP pid</P>
<P>&nbsp;</P>
<P><BR>&nbsp; Run gdb on the tracing thread as described in case 2 and do:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (host gdb)&nbsp; call detach(pid)</P>
<P><BR>&nbsp; If you get a segfault, do it again.&nbsp; It always works the second time.</P>
<P>&nbsp; Detach from the tracing thread and attach to that other thread:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (host gdb)&nbsp; detach</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (host gdb)&nbsp; attach pid</P>
<P>&nbsp;</P>
<P><BR>&nbsp; If gdb hangs when attaching to that process, go back to a shell and<BR>&nbsp; do:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host%<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kill -CONT pid</P>
<P>&nbsp;</P>
<P><BR>&nbsp; And then get the backtrace:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (host gdb)&nbsp; backtrace</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp; 14.4.&nbsp; Case 4 : Hangs</P>
<P>&nbsp; Hangs seem to be fairly rare, but they sometimes happen.&nbsp; When a hang<BR>&nbsp; happens, we need a backtrace from the offending process.&nbsp; Run the<BR>&nbsp; kernel debugger as described in case 1 and get a backtrace.&nbsp; If the<BR>&nbsp; current process is not the idle thread, then send in the backtrace.<BR>&nbsp; You can tell that it's the idle thread if the stack looks like this:</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #0&nbsp; 0x100b1401 in __libc_nanosleep ()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #1&nbsp; 0x100a2885 in idle_sleep (secs=10) at time.c:122<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #2&nbsp; 0x100a546f in do_idle () at process_kern.c:445<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #3&nbsp; 0x100a5508 in cpu_idle () at process_kern.c:471<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #4&nbsp; 0x100ec18f in start_kernel () at init/main.c:592<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #5&nbsp; 0x100a3e10 in start_kernel_proc (unused=0x0) at um_arch.c:71<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #6&nbsp; 0x100a383f in signal_tramp (arg=0x100a3dd8) at trap_user.c:50</P>
<P>&nbsp;</P>
<P><BR>&nbsp; If this is the case, then some other process is at fault, and went to<BR>&nbsp; sleep when it shouldn't have.&nbsp; Run ps on the host and figure out which<BR>&nbsp; process should not have gone to sleep and stayed asleep.&nbsp; Then attach<BR>&nbsp; to it with gdb and get a backtrace as described in case 3.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 15.&nbsp; Thanks</P>
<P><BR>&nbsp; A number of people have helped this project in various ways, and this<BR>&nbsp; page gives recognition where recognition is due.</P>
<P><BR>&nbsp; If you're listed here and you would prefer a real link on your name,<BR>&nbsp; or no link at all, instead of the despammed email address pseudo-link,<BR>&nbsp; let me know.</P>
<P><BR>&nbsp; If you're not listed here and you think maybe you should be, please<BR>&nbsp; let me know that as well.&nbsp; I try to get everyone, but sometimes my<BR>&nbsp; bookkeeping lapses and I forget about contributions.</P>
<P><BR>&nbsp; 15.1.&nbsp; Code and Documentation</P>
<P>&nbsp; Rusty Russell &lt;rusty at linuxcare.com.au&gt;&nbsp; -</P>
<P>&nbsp; o&nbsp; wrote the&nbsp; HOWTO &lt;<A href="http://user-mode">http://user-mode</A>-<BR>&nbsp;&nbsp;&nbsp;&nbsp; linux.sourceforge.net/UserModeLinux-HOWTO.html&gt;</P>
<P>&nbsp; o&nbsp; prodded me into making this project official and putting it on<BR>&nbsp;&nbsp;&nbsp;&nbsp; SourceForge</P>
<P>&nbsp; o&nbsp; came up with the way cool UML logo &lt;<A href="http://user-mode">http://user-mode</A>-<BR>&nbsp;&nbsp;&nbsp;&nbsp; linux.sourceforge.net/uml-small.png&gt;</P>
<P>&nbsp; o&nbsp; redid the config process</P>
<P><BR>&nbsp; Peter Moulder &lt;reiter at netspace.net.au&gt;&nbsp; - Fixed my config and build<BR>&nbsp; processes, and added some useful code to the block driver</P>
<P><BR>&nbsp; Bill Stearns &lt;wstearns at pobox.com&gt;&nbsp; -</P>
<P>&nbsp; o&nbsp; HOWTO updates</P>
<P>&nbsp; o&nbsp; lots of bug reports</P>
<P>&nbsp; o&nbsp; lots of testing</P>
<P>&nbsp; o&nbsp; dedicated a box (uml.ists.dartmouth.edu) to support UML development</P>
<P>&nbsp; o&nbsp; wrote the mkrootfs script, which allows bootable filesystems of<BR>&nbsp;&nbsp;&nbsp;&nbsp; RPM-based distributions to be cranked out</P>
<P>&nbsp; o&nbsp; cranked out a large number of filesystems with said script</P>
<P><BR>&nbsp; Jim Leu &lt;jleu at mindspring.com&gt;&nbsp; - Wrote the virtual ethernet driver<BR>&nbsp; and associated usermode tools</P>
<P>&nbsp; Lars Brinkhoff &lt;<A href="http://lars.nocrew.org/">http://lars.nocrew.org/</A>&gt;&nbsp; - Contributed the ptrace<BR>&nbsp; proxy from his own&nbsp; project &lt;<A href="http://a386.nocrew.org/">http://a386.nocrew.org/</A>&gt; to allow easier<BR>&nbsp; kernel debugging</P>
<P><BR>&nbsp; Andrea Arcangeli &lt;andrea at suse.de&gt;&nbsp; - Redid some of the early boot<BR>&nbsp; code so that it would work on machines with Large File Support</P>
<P><BR>&nbsp; Chris Emerson &lt;<A href="http://www.chiark.greenend.org.uk/~cemerson/">http://www.chiark.greenend.org.uk/~cemerson/</A>&gt;&nbsp; - Did<BR>&nbsp; the first UML port to Linux/ppc</P>
<P><BR>&nbsp; Harald Welte &lt;laforge at gnumonks.org&gt;&nbsp; - Wrote the multicast<BR>&nbsp; transport for the network driver</P>
<P><BR>&nbsp; Jorgen Cederlof - Added special file support to hostfs</P>
<P><BR>&nbsp; Greg Lonnon&nbsp; &lt;glonnon at ridgerun dot com&gt;&nbsp; - Changed the ubd driver<BR>&nbsp; to allow it to layer a COW file on a shared read-only filesystem and<BR>&nbsp; wrote the iomem emulation support</P>
<P><BR>&nbsp; Henrik Nordstrom &lt;<A href="http://hem.passagen.se/hno/">http://hem.passagen.se/hno/</A>&gt;&nbsp; - Provided a variety<BR>&nbsp; of patches, fixes, and clues</P>
<P><BR>&nbsp; Lennert Buytenhek - Contributed various patches, a rewrite of the<BR>&nbsp; network driver, the first implementation of the mconsole driver, and<BR>&nbsp; did the bulk of the work needed to get SMP working again.</P>
<P><BR>&nbsp; Yon Uriarte - Fixed the TUN/TAP network backend while I slept.</P>
<P><BR>&nbsp; Adam Heath - Made a bunch of nice cleanups to the initialization code,<BR>&nbsp; plus various other small patches.</P>
<P><BR>&nbsp; Matt Zimmerman - Matt volunteered to be the UML Debian maintainer and<BR>&nbsp; is doing a real nice job of it.&nbsp; He also noticed and fixed a number of<BR>&nbsp; actually and potentially exploitable security holes in uml_net.&nbsp; Plus<BR>&nbsp; the occasional patch.&nbsp; I like patches.</P>
<P><BR>&nbsp; James McMechan - James seems to have taken over maintenance of the ubd<BR>&nbsp; driver and is doing a nice job of it.</P>
<P><BR>&nbsp; Chandan Kudige - wrote the umlgdb script which automates the reloading<BR>&nbsp; of module symbols.</P>
<P><BR>&nbsp; Steve Schmidtke - wrote the UML slirp transport and hostaudio drivers,<BR>&nbsp; enabling UML processes to access audio devices on the host. He also<BR>&nbsp; submitted patches for the slip transport and lots of other things.</P>
<P><BR>&nbsp; David Coulson &lt;<A href="http://davidcoulson.net">http://davidcoulson.net</A>&gt;&nbsp; -</P>
<P>&nbsp; o&nbsp; Set up the usermodelinux.org &lt;<A href="http://usermodelinux.org">http://usermodelinux.org</A>&gt;&nbsp; site,<BR>&nbsp;&nbsp;&nbsp;&nbsp; which is a great way of keeping the UML user community on top of<BR>&nbsp;&nbsp;&nbsp;&nbsp; UML goings-on.</P>
<P>&nbsp; o&nbsp; Site documentation and updates</P>
<P>&nbsp; o&nbsp; Nifty little UML management daemon&nbsp; UMLd<BR>&nbsp;&nbsp;&nbsp;&nbsp; &lt;<A href="http://uml.openconsultancy.com/umld/">http://uml.openconsultancy.com/umld/</A>&gt;</P>
<P>&nbsp; o&nbsp; Lots of testing and bug reports</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 15.2.&nbsp; Flushing out bugs</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; Yuri Pudgorodsky</P>
<P>&nbsp; o&nbsp; Gerald Britton</P>
<P>&nbsp; o&nbsp; Ian Wehrman</P>
<P>&nbsp; o&nbsp; Gord Lamb</P>
<P>&nbsp; o&nbsp; Eugene Koontz</P>
<P>&nbsp; o&nbsp; John H. Hartman</P>
<P>&nbsp; o&nbsp; Anders Karlsson</P>
<P>&nbsp; o&nbsp; Daniel Phillips</P>
<P>&nbsp; o&nbsp; John Fremlin</P>
<P>&nbsp; o&nbsp; Rainer Burgstaller</P>
<P>&nbsp; o&nbsp; James Stevenson</P>
<P>&nbsp; o&nbsp; Matt Clay</P>
<P>&nbsp; o&nbsp; Cliff Jefferies</P>
<P>&nbsp; o&nbsp; Geoff Hoff</P>
<P>&nbsp; o&nbsp; Lennert Buytenhek</P>
<P>&nbsp; o&nbsp; Al Viro</P>
<P>&nbsp; o&nbsp; Frank Klingenhoefer</P>
<P>&nbsp; o&nbsp; Livio Baldini Soares</P>
<P>&nbsp; o&nbsp; Jon Burgess</P>
<P>&nbsp; o&nbsp; Petru Paler</P>
<P>&nbsp; o&nbsp; Paul</P>
<P>&nbsp; o&nbsp; Chris Reahard</P>
<P>&nbsp; o&nbsp; Sverker Nilsson</P>
<P>&nbsp; o&nbsp; Gong Su</P>
<P>&nbsp; o&nbsp; johan verrept</P>
<P>&nbsp; o&nbsp; Bjorn Eriksson</P>
<P>&nbsp; o&nbsp; Lorenzo Allegrucci</P>
<P>&nbsp; o&nbsp; Muli Ben-Yehuda</P>
<P>&nbsp; o&nbsp; David Mansfield</P>
<P>&nbsp; o&nbsp; Howard Goff</P>
<P>&nbsp; o&nbsp; Mike Anderson</P>
<P>&nbsp; o&nbsp; John Byrne</P>
<P>&nbsp; o&nbsp; Sapan J. Batia</P>
<P>&nbsp; o&nbsp; Iris Huang</P>
<P>&nbsp; o&nbsp; Jan Hudec</P>
<P>&nbsp; o&nbsp; Voluspa</P>
<P>&nbsp;</P>
<P><BR>&nbsp; 15.3.&nbsp; Buglets and clean-ups</P>
<P>&nbsp;</P>
<P>&nbsp; o&nbsp; Dave Zarzycki</P>
<P>&nbsp; o&nbsp; Adam Lazur</P>
<P>&nbsp; o&nbsp; Boria Feigin</P>
<P>&nbsp; o&nbsp; Brian J. Murrell</P>
<P>&nbsp; o&nbsp; JS</P>
<P>&nbsp; o&nbsp; Roman Zippel</P>
<P>&nbsp; o&nbsp; Wil Cooley</P>
<P>&nbsp; o&nbsp; Ayelet Shemesh</P>
<P>&nbsp; o&nbsp; Will Dyson</P>
<P>&nbsp; o&nbsp; Sverker Nilsson</P>
<P>&nbsp; o&nbsp; dvorak</P>
<P>&nbsp; o&nbsp; v.naga srinivas</P>
<P>&nbsp; o&nbsp; Shlomi Fish</P>
<P>&nbsp; o&nbsp; Roger Binns</P>
<P>&nbsp; o&nbsp; johan verrept</P>
<P>&nbsp; o&nbsp; MrChuoi</P>
<P>&nbsp; o&nbsp; Peter Cleve</P>
<P>&nbsp; o&nbsp; Vincent Guffens</P>
<P>&nbsp; o&nbsp; Nathan Scott</P>
<P>&nbsp; o&nbsp; Patrick Caulfield</P>
<P>&nbsp; o&nbsp; jbearce</P>
<P>&nbsp; o&nbsp; Catalin Marinas</P>
<P>&nbsp; o&nbsp; Shane Spencer</P>
<P>&nbsp; o&nbsp; Zou Min</P>
<P><BR>&nbsp; o&nbsp; Ryan Boder</P>
<P>&nbsp; o&nbsp; Lorenzo Colitti</P>
<P>&nbsp; o&nbsp; Gwendal Grignou</P>
<P>&nbsp; o&nbsp; Andre' Breiler</P>
<P>&nbsp; o&nbsp; Tsutomu Yasuda</P>
<P>&nbsp;</P>
<P>&nbsp; 15.4.&nbsp; Case Studies</P>
<P><BR>&nbsp; o&nbsp; Jon Wright</P>
<P>&nbsp; o&nbsp; William McEwan</P>
<P>&nbsp; o&nbsp; Michael Richardson</P>
<P>&nbsp;</P>
<P>&nbsp; 15.5.&nbsp; Other contributions</P>
<P><BR>&nbsp; Bill Carr &lt;Bill.Carr at compaq.com&gt;&nbsp; made the Red Hat mkrootfs script<BR>&nbsp; work with RH 6.2.</P>
<P>&nbsp; Michael Jennings &lt;mikejen at hevanet.com&gt;&nbsp; sent in some material which<BR>&nbsp; is now gracing the top of the&nbsp; index&nbsp; page &lt;<A href="http://user-mode">http://user-mode</A>-<BR>&nbsp; linux.sourceforge.net/&gt;&nbsp; of this site.</P>
<P>&nbsp; SGI &lt;<A href="http://www.sgi.com">http://www.sgi.com</A>&gt;&nbsp; (and more specifically Ralf Baechle &lt;ralf at<BR>&nbsp; uni-koblenz.de&gt; ) gave me an account on oss.sgi.com<BR>&nbsp; &lt;<A href="http://www.oss.sgi.com">http://www.oss.sgi.com</A>&gt; .&nbsp; The bandwidth there made it possible to<BR>&nbsp; produce most of the filesystems available on the project download<BR>&nbsp; page.</P>
<P>&nbsp; Laurent Bonnaud &lt;Laurent.Bonnaud at inpg.fr&gt;&nbsp; took the old grotty<BR>&nbsp; Debian filesystem that I've been distributing and updated it to 2.2.<BR>&nbsp; It is now available by itself here.</P>
<P>&nbsp; Rik van Riel gave me some ftp space on <A href="ftp://ftp.nl.linux.org">ftp.nl.linux.org</A> so I can make<BR>&nbsp; releases even when Sourceforge is broken.</P>
<P>&nbsp; Rodrigo de Castro looked at my broken pte code and told me what was<BR>&nbsp; wrong with it, letting me fix a long-standing (several weeks) and<BR>&nbsp; serious set of bugs.</P>
<P>&nbsp; Chris Reahard built a specialized root filesystem for running a DNS<BR>&nbsp; server jailed inside UML.&nbsp; It's available from the download<BR>&nbsp; &lt;<A href="http://user-mode-linux.sourceforge.net/dl-sf.html">http://user-mode-linux.sourceforge.net/dl-sf.html</A>&gt;&nbsp; page in the Jail<BR>&nbsp; Filesystems section.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P><BR>&nbsp;